const __vite__mapDeps=(i,m=__vite__mapDeps,d=(m.f||(m.f=["assets/index-vzch8Vsw.js","assets/vendor-CYUu28OS.js","assets/web-DC9BkHtD.js","assets/web-T21xEGcd.js","assets/index.esm-4Q1Ufeeo.js","assets/index.esm2017-YGo5mYZM.js","assets/index.esm-BB3lfauv.js","assets/ReportScreen-oSpIKUUr.js","assets/circle-vE8yasc-.js","assets/index-BJAMM_Pa.js","assets/camera-BfDh98wj.js","assets/CommunityScreen-D3u4riBz.js","assets/select-Otq6mO8S.js","assets/check-CPZybvMl.js","assets/UserRoleBadgeWrapper-DMxU8KTQ.js","assets/plus-B7vZspfX.js","assets/arrow-left-BjTckGNp.js","assets/WantedScreen-3ZoZ5CNG.js","assets/dropdown-menu-D_fKQ3sK.js","assets/phone-poxpY5Wz.js","assets/ProfileScreen-B-u0OBWE.js","assets/star-ah6ajVvg.js","assets/FriendsScreen-9dg4djNo.js","assets/NotificationsPage-BOueT-I7.js"])))=>i.map(i=>d[i]);
var __defProp = Object.defineProperty;
var __typeError = (msg) => {
  throw TypeError(msg);
};
var __defNormalProp = (obj, key2, value) => key2 in obj ? __defProp(obj, key2, { enumerable: true, configurable: true, writable: true, value }) : obj[key2] = value;
var __publicField = (obj, key2, value) => __defNormalProp(obj, typeof key2 !== "symbol" ? key2 + "" : key2, value);
var __accessCheck = (obj, member, msg) => member.has(obj) || __typeError("Cannot " + msg);
var __privateGet = (obj, member, getter) => (__accessCheck(obj, member, "read from private field"), getter ? getter.call(obj) : member.get(obj));
var __privateAdd = (obj, member, value) => member.has(obj) ? __typeError("Cannot add the same private member more than once") : member instanceof WeakSet ? member.add(obj) : member.set(obj, value);
var __privateSet = (obj, member, value, setter) => (__accessCheck(obj, member, "write to private field"), setter ? setter.call(obj, value) : member.set(obj, value), value);
var __privateMethod = (obj, member, method) => (__accessCheck(obj, member, "access private method"), method);
var __privateWrapper = (obj, member, setter, getter) => ({
  set _(value) {
    __privateSet(obj, member, value, setter);
  },
  get _() {
    return __privateGet(obj, member, getter);
  }
});
var _focused, _cleanup, _setup, _a, _online, _cleanup2, _setup2, _b, _gcTimeout, _c, _initialState, _revertState, _cache, _retryer, _defaultOptions, _abortSignalConsumed, _Query_instances, dispatch_fn, _d, _queries, _e, _observers, _mutationCache, _retryer2, _Mutation_instances, dispatch_fn2, _f, _mutations, _mutationId, _g, _queryCache, _mutationCache2, _defaultOptions2, _queryDefaults, _mutationDefaults, _mountCount, _unsubscribeFocus, _unsubscribeOnline, _h, _client, _currentResult, _currentMutation, _mutateOptions, _MutationObserver_instances, updateResult_fn, notify_fn, _i;
import { r as reactExports, a as reactDomExports, R as React, _ as __vitePreload, b as ReactDOM, c as React$1, d as createClient, u as useNavigate, e as useLocation, f as commonjsGlobal, g as getDefaultExportFromCjs, O as Outlet, B as BrowserRouter, h as Routes, i as Route, N as Navigate } from "./vendor-CYUu28OS.js";
(function polyfill() {
  const relList = document.createElement("link").relList;
  if (relList && relList.supports && relList.supports("modulepreload")) {
    return;
  }
  for (const link of document.querySelectorAll('link[rel="modulepreload"]')) {
    processPreload(link);
  }
  new MutationObserver((mutations) => {
    for (const mutation of mutations) {
      if (mutation.type !== "childList") {
        continue;
      }
      for (const node2 of mutation.addedNodes) {
        if (node2.tagName === "LINK" && node2.rel === "modulepreload")
          processPreload(node2);
      }
    }
  }).observe(document, { childList: true, subtree: true });
  function getFetchOpts(link) {
    const fetchOpts = {};
    if (link.integrity) fetchOpts.integrity = link.integrity;
    if (link.referrerPolicy) fetchOpts.referrerPolicy = link.referrerPolicy;
    if (link.crossOrigin === "use-credentials")
      fetchOpts.credentials = "include";
    else if (link.crossOrigin === "anonymous") fetchOpts.credentials = "omit";
    else fetchOpts.credentials = "same-origin";
    return fetchOpts;
  }
  function processPreload(link) {
    if (link.ep)
      return;
    link.ep = true;
    const fetchOpts = getFetchOpts(link);
    fetch(link.href, fetchOpts);
  }
})();
var jsxRuntime = { exports: {} };
var reactJsxRuntime_production_min = {};
/**
 * @license React
 * react-jsx-runtime.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var f$1 = reactExports, k$1 = Symbol.for("react.element"), l$2 = Symbol.for("react.fragment"), m$3 = Object.prototype.hasOwnProperty, n$1 = f$1.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED.ReactCurrentOwner, p$2 = { key: true, ref: true, __self: true, __source: true };
function q$2(c2, a2, g2) {
  var b2, d2 = {}, e2 = null, h2 = null;
  void 0 !== g2 && (e2 = "" + g2);
  void 0 !== a2.key && (e2 = "" + a2.key);
  void 0 !== a2.ref && (h2 = a2.ref);
  for (b2 in a2) m$3.call(a2, b2) && !p$2.hasOwnProperty(b2) && (d2[b2] = a2[b2]);
  if (c2 && c2.defaultProps) for (b2 in a2 = c2.defaultProps, a2) void 0 === d2[b2] && (d2[b2] = a2[b2]);
  return { $$typeof: k$1, type: c2, key: e2, ref: h2, props: d2, _owner: n$1.current };
}
reactJsxRuntime_production_min.Fragment = l$2;
reactJsxRuntime_production_min.jsx = q$2;
reactJsxRuntime_production_min.jsxs = q$2;
{
  jsxRuntime.exports = reactJsxRuntime_production_min;
}
var jsxRuntimeExports = jsxRuntime.exports;
var createRoot;
var m$2 = reactDomExports;
{
  createRoot = m$2.createRoot;
  m$2.hydrateRoot;
}
const TOAST_LIMIT = 1;
const TOAST_REMOVE_DELAY = 1e6;
let count$2 = 0;
function genId() {
  count$2 = (count$2 + 1) % Number.MAX_SAFE_INTEGER;
  return count$2.toString();
}
const toastTimeouts = /* @__PURE__ */ new Map();
const addToRemoveQueue = (toastId) => {
  if (toastTimeouts.has(toastId)) {
    return;
  }
  const timeout = setTimeout(() => {
    toastTimeouts.delete(toastId);
    dispatch({
      type: "REMOVE_TOAST",
      toastId
    });
  }, TOAST_REMOVE_DELAY);
  toastTimeouts.set(toastId, timeout);
};
const reducer = (state, action) => {
  switch (action.type) {
    case "ADD_TOAST":
      return {
        ...state,
        toasts: [action.toast, ...state.toasts].slice(0, TOAST_LIMIT)
      };
    case "UPDATE_TOAST":
      return {
        ...state,
        toasts: state.toasts.map(
          (t2) => t2.id === action.toast.id ? { ...t2, ...action.toast } : t2
        )
      };
    case "DISMISS_TOAST": {
      const { toastId } = action;
      if (toastId) {
        addToRemoveQueue(toastId);
      } else {
        state.toasts.forEach((toast2) => {
          addToRemoveQueue(toast2.id);
        });
      }
      return {
        ...state,
        toasts: state.toasts.map(
          (t2) => t2.id === toastId || toastId === void 0 ? {
            ...t2,
            open: false
          } : t2
        )
      };
    }
    case "REMOVE_TOAST":
      if (action.toastId === void 0) {
        return {
          ...state,
          toasts: []
        };
      }
      return {
        ...state,
        toasts: state.toasts.filter((t2) => t2.id !== action.toastId)
      };
  }
};
const listeners = [];
let memoryState = { toasts: [] };
function dispatch(action) {
  memoryState = reducer(memoryState, action);
  listeners.forEach((listener) => {
    listener(memoryState);
  });
}
function toast({ ...props }) {
  const id2 = genId();
  const update = (props2) => dispatch({
    type: "UPDATE_TOAST",
    toast: { ...props2, id: id2 }
  });
  const dismiss = () => dispatch({ type: "DISMISS_TOAST", toastId: id2 });
  dispatch({
    type: "ADD_TOAST",
    toast: {
      ...props,
      id: id2,
      open: true,
      onOpenChange: (open) => {
        if (!open) dismiss();
      }
    }
  });
  return {
    id: id2,
    dismiss,
    update
  };
}
function useToast() {
  const [state, setState] = reactExports.useState(memoryState);
  reactExports.useEffect(() => {
    listeners.push(setState);
    return () => {
      const index2 = listeners.indexOf(setState);
      if (index2 > -1) {
        listeners.splice(index2, 1);
      }
    };
  }, [state]);
  return {
    ...state,
    toast,
    dismiss: (toastId) => dispatch({ type: "DISMISS_TOAST", toastId })
  };
}
function createContext2$1(options = {}) {
  const {
    strict = true,
    errorMessage = "useContext: `context` is undefined. Seems you forgot to wrap component within the Provider",
    name
  } = options;
  const Context = reactExports.createContext(void 0);
  Context.displayName = name;
  function useContext2() {
    var _a2;
    const context = reactExports.useContext(Context);
    if (!context && strict) {
      const error = new Error(errorMessage);
      error.name = "ContextError";
      (_a2 = Error.captureStackTrace) == null ? void 0 : _a2.call(Error, error, useContext2);
      throw error;
    }
    return context;
  }
  return [Context.Provider, useContext2, Context];
}
function useDOMRef(ref) {
  const domRef = reactExports.useRef(null);
  reactExports.useImperativeHandle(ref, () => domRef.current);
  return domRef;
}
function isArray(value) {
  return Array.isArray(value);
}
function isEmptyArray(value) {
  return isArray(value) && value.length === 0;
}
function isObject$1(value) {
  const type = typeof value;
  return value != null && (type === "object" || type === "function") && !isArray(value);
}
function isEmptyObject(value) {
  return isObject$1(value) && Object.keys(value).length === 0;
}
function isEmpty$1(value) {
  if (isArray(value)) return isEmptyArray(value);
  if (isObject$1(value)) return isEmptyObject(value);
  if (value == null || value === "") return true;
  return false;
}
var dataAttr = (condition) => condition ? "true" : void 0;
function toVal(mix2) {
  var k2, y2, str = "";
  if (typeof mix2 === "string" || typeof mix2 === "number") {
    str += mix2;
  } else if (typeof mix2 === "object") {
    if (Array.isArray(mix2)) {
      for (k2 = 0; k2 < mix2.length; k2++) {
        if (mix2[k2]) {
          if (y2 = toVal(mix2[k2])) {
            str && (str += " ");
            str += y2;
          }
        }
      }
    } else {
      for (k2 in mix2) {
        if (mix2[k2]) {
          str && (str += " ");
          str += k2;
        }
      }
    }
  }
  return str;
}
function clsx$1(...args) {
  var i2 = 0, tmp, x2, str = "";
  while (i2 < args.length) {
    if (tmp = args[i2++]) {
      if (x2 = toVal(tmp)) {
        str && (str += " ");
        str += x2;
      }
    }
  }
  return str;
}
function getUniqueID(prefix2) {
  return `${prefix2}-${Math.floor(Math.random() * 1e6)}`;
}
function objectToDeps(obj) {
  if (!obj || typeof obj !== "object") {
    return "";
  }
  try {
    return JSON.stringify(obj);
  } catch (e2) {
    return "";
  }
}
function clamp$5(value, min2, max2) {
  return Math.min(Math.max(value, min2), max2);
}
function clampPercentage(value, max2 = 100) {
  return Math.min(Math.max(value, 0), max2);
}
var DOMPropNames = /* @__PURE__ */ new Set([
  "id",
  "type",
  "style",
  "title",
  "role",
  "tabIndex",
  "htmlFor",
  "width",
  "height",
  "abbr",
  "accept",
  "acceptCharset",
  "accessKey",
  "action",
  "allowFullScreen",
  "allowTransparency",
  "alt",
  "async",
  "autoComplete",
  "autoFocus",
  "autoPlay",
  "cellPadding",
  "cellSpacing",
  "challenge",
  "charset",
  "checked",
  "cite",
  "class",
  "className",
  "cols",
  "colSpan",
  "command",
  "content",
  "contentEditable",
  "contextMenu",
  "controls",
  "coords",
  "crossOrigin",
  "data",
  "dateTime",
  "default",
  "defer",
  "dir",
  "disabled",
  "download",
  "draggable",
  "dropzone",
  "encType",
  "enterKeyHint",
  "for",
  "form",
  "formAction",
  "formEncType",
  "formMethod",
  "formNoValidate",
  "formTarget",
  "frameBorder",
  "headers",
  "hidden",
  "high",
  "href",
  "hrefLang",
  "httpEquiv",
  "icon",
  "inputMode",
  "isMap",
  "itemId",
  "itemProp",
  "itemRef",
  "itemScope",
  "itemType",
  "kind",
  "label",
  "lang",
  "list",
  "loop",
  "manifest",
  "max",
  "maxLength",
  "media",
  "mediaGroup",
  "method",
  "min",
  "minLength",
  "multiple",
  "muted",
  "name",
  "noValidate",
  "open",
  "optimum",
  "pattern",
  "ping",
  "placeholder",
  "poster",
  "preload",
  "radioGroup",
  "referrerPolicy",
  "readOnly",
  "rel",
  "required",
  "rows",
  "rowSpan",
  "sandbox",
  "scope",
  "scoped",
  "scrolling",
  "seamless",
  "selected",
  "shape",
  "size",
  "sizes",
  "slot",
  "sortable",
  "span",
  "spellCheck",
  "src",
  "srcDoc",
  "srcSet",
  "start",
  "step",
  "target",
  "translate",
  "typeMustMatch",
  "useMap",
  "value",
  "wmode",
  "wrap"
]);
var DOMEventNames = /* @__PURE__ */ new Set([
  "onCopy",
  "onCut",
  "onPaste",
  "onLoad",
  "onError",
  "onWheel",
  "onScroll",
  "onCompositionEnd",
  "onCompositionStart",
  "onCompositionUpdate",
  "onKeyDown",
  "onKeyPress",
  "onKeyUp",
  "onFocus",
  "onBlur",
  "onChange",
  "onInput",
  "onSubmit",
  "onClick",
  "onContextMenu",
  "onDoubleClick",
  "onDrag",
  "onDragEnd",
  "onDragEnter",
  "onDragExit",
  "onDragLeave",
  "onDragOver",
  "onDragStart",
  "onDrop",
  "onMouseDown",
  "onMouseEnter",
  "onMouseLeave",
  "onMouseMove",
  "onMouseOut",
  "onMouseOver",
  "onMouseUp",
  "onPointerDown",
  "onPointerEnter",
  "onPointerLeave",
  "onPointerUp",
  "onSelect",
  "onTouchCancel",
  "onTouchEnd",
  "onTouchMove",
  "onTouchStart",
  "onAnimationStart",
  "onAnimationEnd",
  "onAnimationIteration",
  "onTransitionEnd"
]);
var propRe = /^(data-.*)$/;
var ariaRe = /^(aria-.*)$/;
var funcRe = /^(on[A-Z].*)$/;
function filterDOMProps(props, opts = {}) {
  let {
    labelable = true,
    enabled = true,
    propNames,
    omitPropNames,
    omitEventNames,
    omitDataProps,
    omitEventProps
  } = opts;
  let filteredProps = {};
  if (!enabled) {
    return props;
  }
  for (const prop in props) {
    if (omitPropNames == null ? void 0 : omitPropNames.has(prop)) {
      continue;
    }
    if ((omitEventNames == null ? void 0 : omitEventNames.has(prop)) && funcRe.test(prop)) {
      continue;
    }
    if (funcRe.test(prop) && !DOMEventNames.has(prop)) {
      continue;
    }
    if (omitDataProps && propRe.test(prop)) {
      continue;
    }
    if (omitEventProps && funcRe.test(prop)) {
      continue;
    }
    if (Object.prototype.hasOwnProperty.call(props, prop) && (DOMPropNames.has(prop) || labelable && ariaRe.test(prop) || (propNames == null ? void 0 : propNames.has(prop)) || propRe.test(prop)) || funcRe.test(prop)) {
      filteredProps[prop] = props[prop];
    }
  }
  return filteredProps;
}
var [ProviderContext, useProviderContext] = createContext2$1({
  name: "ProviderContext",
  strict: false
});
const $b5e257d569688ac6$var$defaultContext = {
  prefix: String(Math.round(Math.random() * 1e10)),
  current: 0
};
const $b5e257d569688ac6$var$SSRContext = /* @__PURE__ */ React.createContext($b5e257d569688ac6$var$defaultContext);
const $b5e257d569688ac6$var$IsSSRContext = /* @__PURE__ */ React.createContext(false);
let $b5e257d569688ac6$var$canUseDOM = Boolean(typeof window !== "undefined" && window.document && window.document.createElement);
let $b5e257d569688ac6$var$componentIds = /* @__PURE__ */ new WeakMap();
function $b5e257d569688ac6$var$useCounter(isDisabled = false) {
  let ctx = reactExports.useContext($b5e257d569688ac6$var$SSRContext);
  let ref = reactExports.useRef(null);
  if (ref.current === null && !isDisabled) {
    var _React___SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED_ReactCurrentOwner, _React___SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED;
    let currentOwner = (_React___SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED = React.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED) === null || _React___SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED === void 0 ? void 0 : (_React___SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED_ReactCurrentOwner = _React___SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED.ReactCurrentOwner) === null || _React___SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED_ReactCurrentOwner === void 0 ? void 0 : _React___SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED_ReactCurrentOwner.current;
    if (currentOwner) {
      let prevComponentValue = $b5e257d569688ac6$var$componentIds.get(currentOwner);
      if (prevComponentValue == null)
        $b5e257d569688ac6$var$componentIds.set(currentOwner, {
          id: ctx.current,
          state: currentOwner.memoizedState
        });
      else if (currentOwner.memoizedState !== prevComponentValue.state) {
        ctx.current = prevComponentValue.id;
        $b5e257d569688ac6$var$componentIds.delete(currentOwner);
      }
    }
    ref.current = ++ctx.current;
  }
  return ref.current;
}
function $b5e257d569688ac6$var$useLegacySSRSafeId(defaultId) {
  let ctx = reactExports.useContext($b5e257d569688ac6$var$SSRContext);
  if (ctx === $b5e257d569688ac6$var$defaultContext && !$b5e257d569688ac6$var$canUseDOM && false) console.warn("When server rendering, you must wrap your application in an <SSRProvider> to ensure consistent ids are generated between the client and server.");
  let counter = $b5e257d569688ac6$var$useCounter(!!defaultId);
  let prefix2 = ctx === $b5e257d569688ac6$var$defaultContext && false ? "react-aria" : `react-aria${ctx.prefix}`;
  return defaultId || `${prefix2}-${counter}`;
}
function $b5e257d569688ac6$var$useModernSSRSafeId(defaultId) {
  let id2 = React.useId();
  let [didSSR] = reactExports.useState($b5e257d569688ac6$export$535bd6ca7f90a273());
  let prefix2 = didSSR || false ? "react-aria" : `react-aria${$b5e257d569688ac6$var$defaultContext.prefix}`;
  return defaultId || `${prefix2}-${id2}`;
}
const $b5e257d569688ac6$export$619500959fc48b26 = typeof React["useId"] === "function" ? $b5e257d569688ac6$var$useModernSSRSafeId : $b5e257d569688ac6$var$useLegacySSRSafeId;
function $b5e257d569688ac6$var$getSnapshot() {
  return false;
}
function $b5e257d569688ac6$var$getServerSnapshot() {
  return true;
}
function $b5e257d569688ac6$var$subscribe(onStoreChange) {
  return () => {
  };
}
function $b5e257d569688ac6$export$535bd6ca7f90a273() {
  if (typeof React["useSyncExternalStore"] === "function") return React["useSyncExternalStore"]($b5e257d569688ac6$var$subscribe, $b5e257d569688ac6$var$getSnapshot, $b5e257d569688ac6$var$getServerSnapshot);
  return reactExports.useContext($b5e257d569688ac6$var$IsSSRContext);
}
var __assign = function() {
  __assign = Object.assign || function __assign2(t2) {
    for (var s, i2 = 1, n2 = arguments.length; i2 < n2; i2++) {
      s = arguments[i2];
      for (var p2 in s) if (Object.prototype.hasOwnProperty.call(s, p2)) t2[p2] = s[p2];
    }
    return t2;
  };
  return __assign.apply(this, arguments);
};
function __rest(s, e2) {
  var t2 = {};
  for (var p2 in s) if (Object.prototype.hasOwnProperty.call(s, p2) && e2.indexOf(p2) < 0)
    t2[p2] = s[p2];
  if (s != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i2 = 0, p2 = Object.getOwnPropertySymbols(s); i2 < p2.length; i2++) {
      if (e2.indexOf(p2[i2]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p2[i2]))
        t2[p2[i2]] = s[p2[i2]];
    }
  return t2;
}
function __spreadArray(to, from2, pack) {
  if (pack || arguments.length === 2) for (var i2 = 0, l2 = from2.length, ar; i2 < l2; i2++) {
    if (ar || !(i2 in from2)) {
      if (!ar) ar = Array.prototype.slice.call(from2, 0, i2);
      ar[i2] = from2[i2];
    }
  }
  return to.concat(ar || Array.prototype.slice.call(from2));
}
typeof SuppressedError === "function" ? SuppressedError : function(error, suppressed, message) {
  var e2 = new Error(message);
  return e2.name = "SuppressedError", e2.error = error, e2.suppressed = suppressed, e2;
};
function _check_private_redeclaration(obj, privateCollection) {
  if (privateCollection.has(obj)) {
    throw new TypeError("Cannot initialize the same private elements twice on an object");
  }
}
function _class_private_field_init(obj, privateMap, value) {
  _check_private_redeclaration(obj, privateMap);
  privateMap.set(obj, value);
}
const $f0a04ccd8dbdd83b$export$e5c5a5f917a5871c = typeof document !== "undefined" ? React.useLayoutEffect : () => {
};
function $8ae05eaa5c114e9c$export$7f54fc3180508a52(fn) {
  const ref = reactExports.useRef(null);
  $f0a04ccd8dbdd83b$export$e5c5a5f917a5871c(() => {
    ref.current = fn;
  }, [
    fn
  ]);
  return reactExports.useCallback((...args) => {
    const f2 = ref.current;
    return f2 === null || f2 === void 0 ? void 0 : f2(...args);
  }, []);
}
let $bdb11010cef70236$var$canUseDOM = Boolean(typeof window !== "undefined" && window.document && window.document.createElement);
let $bdb11010cef70236$export$d41a04c74483c6ef = /* @__PURE__ */ new Map();
let $bdb11010cef70236$var$registry;
if (typeof FinalizationRegistry !== "undefined") $bdb11010cef70236$var$registry = new FinalizationRegistry((heldValue) => {
  $bdb11010cef70236$export$d41a04c74483c6ef.delete(heldValue);
});
function $bdb11010cef70236$export$f680877a34711e37(defaultId) {
  let [value, setValue2] = reactExports.useState(defaultId);
  let nextId = reactExports.useRef(null);
  let res = $b5e257d569688ac6$export$619500959fc48b26(value);
  let cleanupRef = reactExports.useRef(null);
  if ($bdb11010cef70236$var$registry) $bdb11010cef70236$var$registry.register(cleanupRef, res);
  if ($bdb11010cef70236$var$canUseDOM) {
    const cacheIdRef = $bdb11010cef70236$export$d41a04c74483c6ef.get(res);
    if (cacheIdRef && !cacheIdRef.includes(nextId)) cacheIdRef.push(nextId);
    else $bdb11010cef70236$export$d41a04c74483c6ef.set(res, [
      nextId
    ]);
  }
  $f0a04ccd8dbdd83b$export$e5c5a5f917a5871c(() => {
    let r2 = res;
    return () => {
      if ($bdb11010cef70236$var$registry) $bdb11010cef70236$var$registry.unregister(cleanupRef);
      $bdb11010cef70236$export$d41a04c74483c6ef.delete(r2);
    };
  }, [
    res
  ]);
  reactExports.useEffect(() => {
    let newId = nextId.current;
    if (newId) setValue2(newId);
    return () => {
      if (newId) nextId.current = null;
    };
  });
  return res;
}
function $bdb11010cef70236$export$cd8c9cb68f842629(idA, idB) {
  if (idA === idB) return idA;
  let setIdsA = $bdb11010cef70236$export$d41a04c74483c6ef.get(idA);
  if (setIdsA) {
    setIdsA.forEach((ref) => ref.current = idB);
    return idB;
  }
  let setIdsB = $bdb11010cef70236$export$d41a04c74483c6ef.get(idB);
  if (setIdsB) {
    setIdsB.forEach((ref) => ref.current = idA);
    return idA;
  }
  return idB;
}
function $ff5963eb1fccf552$export$e08e3b67e392101e(...callbacks) {
  return (...args) => {
    for (let callback of callbacks) if (typeof callback === "function") callback(...args);
  };
}
const $431fbd86ca7dc216$export$b204af158042fbac = (el) => {
  var _el_ownerDocument;
  return (_el_ownerDocument = el === null || el === void 0 ? void 0 : el.ownerDocument) !== null && _el_ownerDocument !== void 0 ? _el_ownerDocument : document;
};
const $431fbd86ca7dc216$export$f21a1ffae260145a = (el) => {
  if (el && "window" in el && el.window === el) return el;
  const doc2 = $431fbd86ca7dc216$export$b204af158042fbac(el);
  return doc2.defaultView || window;
};
function $431fbd86ca7dc216$var$isNode(value) {
  return value !== null && typeof value === "object" && "nodeType" in value && typeof value.nodeType === "number";
}
function $431fbd86ca7dc216$export$af51f0f06c0f328a(node2) {
  return $431fbd86ca7dc216$var$isNode(node2) && node2.nodeType === Node.DOCUMENT_FRAGMENT_NODE && "host" in node2;
}
let $f4e2df6bd15f8569$var$_shadowDOM = false;
function $f4e2df6bd15f8569$export$98658e8c59125e6a() {
  return $f4e2df6bd15f8569$var$_shadowDOM;
}
function $d4ee10de306f2510$export$4282f70798064fe0(node2, otherNode) {
  if (!$f4e2df6bd15f8569$export$98658e8c59125e6a()) return otherNode && node2 ? node2.contains(otherNode) : false;
  if (!node2 || !otherNode) return false;
  let currentNode = otherNode;
  while (currentNode !== null) {
    if (currentNode === node2) return true;
    if (currentNode.tagName === "SLOT" && currentNode.assignedSlot)
      currentNode = currentNode.assignedSlot.parentNode;
    else if ($431fbd86ca7dc216$export$af51f0f06c0f328a(currentNode))
      currentNode = currentNode.host;
    else currentNode = currentNode.parentNode;
  }
  return false;
}
const $d4ee10de306f2510$export$cd4e5573fbe2b576 = (doc2 = document) => {
  var _activeElement_shadowRoot;
  if (!$f4e2df6bd15f8569$export$98658e8c59125e6a()) return doc2.activeElement;
  let activeElement = doc2.activeElement;
  while (activeElement && "shadowRoot" in activeElement && ((_activeElement_shadowRoot = activeElement.shadowRoot) === null || _activeElement_shadowRoot === void 0 ? void 0 : _activeElement_shadowRoot.activeElement)) activeElement = activeElement.shadowRoot.activeElement;
  return activeElement;
};
function $d4ee10de306f2510$export$e58f029f0fbfdb29(event) {
  if ($f4e2df6bd15f8569$export$98658e8c59125e6a() && event.target.shadowRoot) {
    if (event.composedPath) return event.composedPath()[0];
  }
  return event.target;
}
function r$1(e2) {
  var t2, f2, n2 = "";
  if ("string" == typeof e2 || "number" == typeof e2) n2 += e2;
  else if ("object" == typeof e2) if (Array.isArray(e2)) {
    var o = e2.length;
    for (t2 = 0; t2 < o; t2++) e2[t2] && (f2 = r$1(e2[t2])) && (n2 && (n2 += " "), n2 += f2);
  } else for (f2 in e2) e2[f2] && (n2 && (n2 += " "), n2 += f2);
  return n2;
}
function clsx() {
  for (var e2, t2, f2 = 0, n2 = "", o = arguments.length; f2 < o; f2++) (e2 = arguments[f2]) && (t2 = r$1(e2)) && (n2 && (n2 += " "), n2 += t2);
  return n2;
}
function $3ef42575df84b30b$export$9d1611c77c2fe928(...args) {
  let result = {
    ...args[0]
  };
  for (let i2 = 1; i2 < args.length; i2++) {
    let props = args[i2];
    for (let key2 in props) {
      let a2 = result[key2];
      let b2 = props[key2];
      if (typeof a2 === "function" && typeof b2 === "function" && // This is a lot faster than a regex.
      key2[0] === "o" && key2[1] === "n" && key2.charCodeAt(2) >= /* 'A' */
      65 && key2.charCodeAt(2) <= /* 'Z' */
      90) result[key2] = $ff5963eb1fccf552$export$e08e3b67e392101e(a2, b2);
      else if ((key2 === "className" || key2 === "UNSAFE_className") && typeof a2 === "string" && typeof b2 === "string") result[key2] = clsx(a2, b2);
      else if (key2 === "id" && a2 && b2) result.id = $bdb11010cef70236$export$cd8c9cb68f842629(a2, b2);
      else result[key2] = b2 !== void 0 ? b2 : a2;
    }
  }
  return result;
}
const $65484d02dcb7eb3e$var$DOMPropNames = /* @__PURE__ */ new Set([
  "id"
]);
const $65484d02dcb7eb3e$var$labelablePropNames = /* @__PURE__ */ new Set([
  "aria-label",
  "aria-labelledby",
  "aria-describedby",
  "aria-details"
]);
const $65484d02dcb7eb3e$var$linkPropNames = /* @__PURE__ */ new Set([
  "href",
  "hrefLang",
  "target",
  "rel",
  "download",
  "ping",
  "referrerPolicy"
]);
const $65484d02dcb7eb3e$var$propRe = /^(data-.*)$/;
function $65484d02dcb7eb3e$export$457c3d6518dd4c6f(props, opts = {}) {
  let { labelable, isLink, propNames } = opts;
  let filteredProps = {};
  for (const prop in props) if (Object.prototype.hasOwnProperty.call(props, prop) && ($65484d02dcb7eb3e$var$DOMPropNames.has(prop) || labelable && $65484d02dcb7eb3e$var$labelablePropNames.has(prop) || isLink && $65484d02dcb7eb3e$var$linkPropNames.has(prop) || (propNames === null || propNames === void 0 ? void 0 : propNames.has(prop)) || $65484d02dcb7eb3e$var$propRe.test(prop))) filteredProps[prop] = props[prop];
  return filteredProps;
}
function $7215afc6de606d6b$export$de79e2c695e052f3(element) {
  if ($7215afc6de606d6b$var$supportsPreventScroll()) element.focus({
    preventScroll: true
  });
  else {
    let scrollableElements = $7215afc6de606d6b$var$getScrollableElements(element);
    element.focus();
    $7215afc6de606d6b$var$restoreScrollPosition(scrollableElements);
  }
}
let $7215afc6de606d6b$var$supportsPreventScrollCached = null;
function $7215afc6de606d6b$var$supportsPreventScroll() {
  if ($7215afc6de606d6b$var$supportsPreventScrollCached == null) {
    $7215afc6de606d6b$var$supportsPreventScrollCached = false;
    try {
      let focusElem = document.createElement("div");
      focusElem.focus({
        get preventScroll() {
          $7215afc6de606d6b$var$supportsPreventScrollCached = true;
          return true;
        }
      });
    } catch {
    }
  }
  return $7215afc6de606d6b$var$supportsPreventScrollCached;
}
function $7215afc6de606d6b$var$getScrollableElements(element) {
  let parent2 = element.parentNode;
  let scrollableElements = [];
  let rootScrollingElement = document.scrollingElement || document.documentElement;
  while (parent2 instanceof HTMLElement && parent2 !== rootScrollingElement) {
    if (parent2.offsetHeight < parent2.scrollHeight || parent2.offsetWidth < parent2.scrollWidth) scrollableElements.push({
      element: parent2,
      scrollTop: parent2.scrollTop,
      scrollLeft: parent2.scrollLeft
    });
    parent2 = parent2.parentNode;
  }
  if (rootScrollingElement instanceof HTMLElement) scrollableElements.push({
    element: rootScrollingElement,
    scrollTop: rootScrollingElement.scrollTop,
    scrollLeft: rootScrollingElement.scrollLeft
  });
  return scrollableElements;
}
function $7215afc6de606d6b$var$restoreScrollPosition(scrollableElements) {
  for (let { element, scrollTop, scrollLeft } of scrollableElements) {
    element.scrollTop = scrollTop;
    element.scrollLeft = scrollLeft;
  }
}
function $c87311424ea30a05$var$testUserAgent(re) {
  var _window_navigator_userAgentData;
  if (typeof window === "undefined" || window.navigator == null) return false;
  return ((_window_navigator_userAgentData = window.navigator["userAgentData"]) === null || _window_navigator_userAgentData === void 0 ? void 0 : _window_navigator_userAgentData.brands.some((brand) => re.test(brand.brand))) || re.test(window.navigator.userAgent);
}
function $c87311424ea30a05$var$testPlatform(re) {
  var _window_navigator_userAgentData;
  return typeof window !== "undefined" && window.navigator != null ? re.test(((_window_navigator_userAgentData = window.navigator["userAgentData"]) === null || _window_navigator_userAgentData === void 0 ? void 0 : _window_navigator_userAgentData.platform) || window.navigator.platform) : false;
}
function $c87311424ea30a05$var$cached(fn) {
  let res = null;
  return () => {
    if (res == null) res = fn();
    return res;
  };
}
const $c87311424ea30a05$export$9ac100e40613ea10 = $c87311424ea30a05$var$cached(function() {
  return $c87311424ea30a05$var$testPlatform(/^Mac/i);
});
const $c87311424ea30a05$export$186c6964ca17d99 = $c87311424ea30a05$var$cached(function() {
  return $c87311424ea30a05$var$testPlatform(/^iPhone/i);
});
const $c87311424ea30a05$export$7bef049ce92e4224 = $c87311424ea30a05$var$cached(function() {
  return $c87311424ea30a05$var$testPlatform(/^iPad/i) || // iPadOS 13 lies and says it's a Mac, but we can distinguish by detecting touch support.
  $c87311424ea30a05$export$9ac100e40613ea10() && navigator.maxTouchPoints > 1;
});
const $c87311424ea30a05$export$fedb369cb70207f1 = $c87311424ea30a05$var$cached(function() {
  return $c87311424ea30a05$export$186c6964ca17d99() || $c87311424ea30a05$export$7bef049ce92e4224();
});
const $c87311424ea30a05$export$78551043582a6a98 = $c87311424ea30a05$var$cached(function() {
  return $c87311424ea30a05$var$testUserAgent(/AppleWebKit/i) && !$c87311424ea30a05$export$6446a186d09e379e();
});
const $c87311424ea30a05$export$6446a186d09e379e = $c87311424ea30a05$var$cached(function() {
  return $c87311424ea30a05$var$testUserAgent(/Chrome/i);
});
const $c87311424ea30a05$export$a11b0059900ceec8 = $c87311424ea30a05$var$cached(function() {
  return $c87311424ea30a05$var$testUserAgent(/Android/i);
});
const $c87311424ea30a05$export$b7d78993b74f766d = $c87311424ea30a05$var$cached(function() {
  return $c87311424ea30a05$var$testUserAgent(/Firefox/i);
});
function $ea8dcbcb9ea1b556$export$95185d699e05d4d7(target, modifiers, setOpening = true) {
  var _window_event_type, _window_event;
  let { metaKey, ctrlKey, altKey, shiftKey } = modifiers;
  if ($c87311424ea30a05$export$b7d78993b74f766d() && ((_window_event = window.event) === null || _window_event === void 0 ? void 0 : (_window_event_type = _window_event.type) === null || _window_event_type === void 0 ? void 0 : _window_event_type.startsWith("key")) && target.target === "_blank") {
    if ($c87311424ea30a05$export$9ac100e40613ea10()) metaKey = true;
    else ctrlKey = true;
  }
  let event = $c87311424ea30a05$export$78551043582a6a98() && $c87311424ea30a05$export$9ac100e40613ea10() && !$c87311424ea30a05$export$7bef049ce92e4224() && true ? new KeyboardEvent("keydown", {
    keyIdentifier: "Enter",
    metaKey,
    ctrlKey,
    altKey,
    shiftKey
  }) : new MouseEvent("click", {
    metaKey,
    ctrlKey,
    altKey,
    shiftKey,
    bubbles: true,
    cancelable: true
  });
  $ea8dcbcb9ea1b556$export$95185d699e05d4d7.isOpening = setOpening;
  $7215afc6de606d6b$export$de79e2c695e052f3(target);
  target.dispatchEvent(event);
  $ea8dcbcb9ea1b556$export$95185d699e05d4d7.isOpening = false;
}
$ea8dcbcb9ea1b556$export$95185d699e05d4d7.isOpening = false;
let $bbed8b41f857bcc0$var$transitionsByElement = /* @__PURE__ */ new Map();
let $bbed8b41f857bcc0$var$transitionCallbacks = /* @__PURE__ */ new Set();
function $bbed8b41f857bcc0$var$setupGlobalEvents() {
  if (typeof window === "undefined") return;
  function isTransitionEvent(event) {
    return "propertyName" in event;
  }
  let onTransitionStart = (e2) => {
    if (!isTransitionEvent(e2) || !e2.target) return;
    let transitions = $bbed8b41f857bcc0$var$transitionsByElement.get(e2.target);
    if (!transitions) {
      transitions = /* @__PURE__ */ new Set();
      $bbed8b41f857bcc0$var$transitionsByElement.set(e2.target, transitions);
      e2.target.addEventListener("transitioncancel", onTransitionEnd, {
        once: true
      });
    }
    transitions.add(e2.propertyName);
  };
  let onTransitionEnd = (e2) => {
    if (!isTransitionEvent(e2) || !e2.target) return;
    let properties2 = $bbed8b41f857bcc0$var$transitionsByElement.get(e2.target);
    if (!properties2) return;
    properties2.delete(e2.propertyName);
    if (properties2.size === 0) {
      e2.target.removeEventListener("transitioncancel", onTransitionEnd);
      $bbed8b41f857bcc0$var$transitionsByElement.delete(e2.target);
    }
    if ($bbed8b41f857bcc0$var$transitionsByElement.size === 0) {
      for (let cb of $bbed8b41f857bcc0$var$transitionCallbacks) cb();
      $bbed8b41f857bcc0$var$transitionCallbacks.clear();
    }
  };
  document.body.addEventListener("transitionrun", onTransitionStart);
  document.body.addEventListener("transitionend", onTransitionEnd);
}
if (typeof document !== "undefined") {
  if (document.readyState !== "loading") $bbed8b41f857bcc0$var$setupGlobalEvents();
  else document.addEventListener("DOMContentLoaded", $bbed8b41f857bcc0$var$setupGlobalEvents);
}
function $bbed8b41f857bcc0$var$cleanupDetachedElements() {
  for (const [eventTarget] of $bbed8b41f857bcc0$var$transitionsByElement)
    if ("isConnected" in eventTarget && !eventTarget.isConnected) $bbed8b41f857bcc0$var$transitionsByElement.delete(eventTarget);
}
function $bbed8b41f857bcc0$export$24490316f764c430(fn) {
  requestAnimationFrame(() => {
    $bbed8b41f857bcc0$var$cleanupDetachedElements();
    if ($bbed8b41f857bcc0$var$transitionsByElement.size === 0) fn();
    else $bbed8b41f857bcc0$var$transitionCallbacks.add(fn);
  });
}
function $03deb23ff14920c4$export$4eaf04e54aa8eed6() {
  let globalListeners = reactExports.useRef(/* @__PURE__ */ new Map());
  let addGlobalListener = reactExports.useCallback((eventTarget, type, listener, options) => {
    let fn = (options === null || options === void 0 ? void 0 : options.once) ? (...args) => {
      globalListeners.current.delete(listener);
      listener(...args);
    } : listener;
    globalListeners.current.set(listener, {
      type,
      eventTarget,
      fn,
      options
    });
    eventTarget.addEventListener(type, fn, options);
  }, []);
  let removeGlobalListener = reactExports.useCallback((eventTarget, type, listener, options) => {
    var _globalListeners_current_get;
    let fn = ((_globalListeners_current_get = globalListeners.current.get(listener)) === null || _globalListeners_current_get === void 0 ? void 0 : _globalListeners_current_get.fn) || listener;
    eventTarget.removeEventListener(type, fn, options);
    globalListeners.current.delete(listener);
  }, []);
  let removeAllGlobalListeners = reactExports.useCallback(() => {
    globalListeners.current.forEach((value, key2) => {
      removeGlobalListener(value.eventTarget, value.type, key2, value.options);
    });
  }, [
    removeGlobalListener
  ]);
  reactExports.useEffect(() => {
    return removeAllGlobalListeners;
  }, [
    removeAllGlobalListeners
  ]);
  return {
    addGlobalListener,
    removeGlobalListener,
    removeAllGlobalListeners
  };
}
function $e7801be82b4b2a53$export$4debdb1a3f0fa79e(context, ref) {
  $f0a04ccd8dbdd83b$export$e5c5a5f917a5871c(() => {
    if (context && context.ref && ref) {
      context.ref.current = ref.current;
      return () => {
        if (context.ref) context.ref.current = null;
      };
    }
  });
}
function $6a7db85432448f7f$export$60278871457622de(event) {
  if (event.mozInputSource === 0 && event.isTrusted) return true;
  if ($c87311424ea30a05$export$a11b0059900ceec8() && event.pointerType) return event.type === "click" && event.buttons === 1;
  return event.detail === 0 && !event.pointerType;
}
function $6a7db85432448f7f$export$29bf1b5f2c56cf63(event) {
  return !$c87311424ea30a05$export$a11b0059900ceec8() && event.width === 0 && event.height === 0 || event.width === 1 && event.height === 1 && event.pressure === 0 && event.detail === 0 && event.pointerType === "mouse";
}
const $b4b717babfbb907b$var$focusableElements = [
  "input:not([disabled]):not([type=hidden])",
  "select:not([disabled])",
  "textarea:not([disabled])",
  "button:not([disabled])",
  "a[href]",
  "area[href]",
  "summary",
  "iframe",
  "object",
  "embed",
  "audio[controls]",
  "video[controls]",
  '[contenteditable]:not([contenteditable^="false"])'
];
const $b4b717babfbb907b$var$FOCUSABLE_ELEMENT_SELECTOR = $b4b717babfbb907b$var$focusableElements.join(":not([hidden]),") + ",[tabindex]:not([disabled]):not([hidden])";
$b4b717babfbb907b$var$focusableElements.push('[tabindex]:not([tabindex="-1"]):not([disabled])');
function $b4b717babfbb907b$export$4c063cf1350e6fed(element) {
  return element.matches($b4b717babfbb907b$var$FOCUSABLE_ELEMENT_SELECTOR);
}
function $458b0a5536c1a7cf$export$40bfa8c7b0832715(value, defaultValue, onChange) {
  let [stateValue, setStateValue] = reactExports.useState(value || defaultValue);
  let isControlledRef = reactExports.useRef(value !== void 0);
  let isControlled = value !== void 0;
  reactExports.useEffect(() => {
    let wasControlled = isControlledRef.current;
    if (wasControlled !== isControlled && false) console.warn(`WARN: A component changed from ${wasControlled ? "controlled" : "uncontrolled"} to ${isControlled ? "controlled" : "uncontrolled"}.`);
    isControlledRef.current = isControlled;
  }, [
    isControlled
  ]);
  let currentValue = isControlled ? value : stateValue;
  let setValue2 = reactExports.useCallback((value2, ...args) => {
    let onChangeCaller = (value3, ...onChangeArgs) => {
      if (onChange) {
        if (!Object.is(currentValue, value3)) onChange(value3, ...onChangeArgs);
      }
      if (!isControlled)
        currentValue = value3;
    };
    if (typeof value2 === "function") {
      let updateFunction = (oldValue, ...functionArgs) => {
        let interceptedValue = value2(isControlled ? currentValue : oldValue, ...functionArgs);
        onChangeCaller(interceptedValue, ...args);
        if (!isControlled) return interceptedValue;
        return oldValue;
      };
      setStateValue(updateFunction);
    } else {
      if (!isControlled) setStateValue(value2);
      onChangeCaller(value2, ...args);
    }
  }, [
    isControlled,
    currentValue,
    onChange
  ]);
  return [
    currentValue,
    setValue2
  ];
}
function $8a9cb279dc87e130$export$525bc4921d56d4a(nativeEvent) {
  let event = nativeEvent;
  event.nativeEvent = nativeEvent;
  event.isDefaultPrevented = () => event.defaultPrevented;
  event.isPropagationStopped = () => event.cancelBubble;
  event.persist = () => {
  };
  return event;
}
function $8a9cb279dc87e130$export$c2b7abe5d61ec696(event, target) {
  Object.defineProperty(event, "target", {
    value: target
  });
  Object.defineProperty(event, "currentTarget", {
    value: target
  });
}
function $8a9cb279dc87e130$export$715c682d09d639cc(onBlur) {
  let stateRef = reactExports.useRef({
    isFocused: false,
    observer: null
  });
  $f0a04ccd8dbdd83b$export$e5c5a5f917a5871c(() => {
    const state = stateRef.current;
    return () => {
      if (state.observer) {
        state.observer.disconnect();
        state.observer = null;
      }
    };
  }, []);
  let dispatchBlur = $8ae05eaa5c114e9c$export$7f54fc3180508a52((e2) => {
    onBlur === null || onBlur === void 0 ? void 0 : onBlur(e2);
  });
  return reactExports.useCallback((e2) => {
    if (e2.target instanceof HTMLButtonElement || e2.target instanceof HTMLInputElement || e2.target instanceof HTMLTextAreaElement || e2.target instanceof HTMLSelectElement) {
      stateRef.current.isFocused = true;
      let target = e2.target;
      let onBlurHandler = (e3) => {
        stateRef.current.isFocused = false;
        if (target.disabled) {
          let event = $8a9cb279dc87e130$export$525bc4921d56d4a(e3);
          dispatchBlur(event);
        }
        if (stateRef.current.observer) {
          stateRef.current.observer.disconnect();
          stateRef.current.observer = null;
        }
      };
      target.addEventListener("focusout", onBlurHandler, {
        once: true
      });
      stateRef.current.observer = new MutationObserver(() => {
        if (stateRef.current.isFocused && target.disabled) {
          var _stateRef_current_observer;
          (_stateRef_current_observer = stateRef.current.observer) === null || _stateRef_current_observer === void 0 ? void 0 : _stateRef_current_observer.disconnect();
          let relatedTargetEl = target === document.activeElement ? null : document.activeElement;
          target.dispatchEvent(new FocusEvent("blur", {
            relatedTarget: relatedTargetEl
          }));
          target.dispatchEvent(new FocusEvent("focusout", {
            bubbles: true,
            relatedTarget: relatedTargetEl
          }));
        }
      });
      stateRef.current.observer.observe(target, {
        attributes: true,
        attributeFilter: [
          "disabled"
        ]
      });
    }
  }, [
    dispatchBlur
  ]);
}
let $8a9cb279dc87e130$export$fda7da73ab5d4c48 = false;
function $8a9cb279dc87e130$export$cabe61c495ee3649(target) {
  while (target && !$b4b717babfbb907b$export$4c063cf1350e6fed(target)) target = target.parentElement;
  let window2 = $431fbd86ca7dc216$export$f21a1ffae260145a(target);
  let activeElement = window2.document.activeElement;
  if (!activeElement || activeElement === target) return;
  $8a9cb279dc87e130$export$fda7da73ab5d4c48 = true;
  let isRefocusing = false;
  let onBlur = (e2) => {
    if (e2.target === activeElement || isRefocusing) e2.stopImmediatePropagation();
  };
  let onFocusOut = (e2) => {
    if (e2.target === activeElement || isRefocusing) {
      e2.stopImmediatePropagation();
      if (!target && !isRefocusing) {
        isRefocusing = true;
        $7215afc6de606d6b$export$de79e2c695e052f3(activeElement);
        cleanup();
      }
    }
  };
  let onFocus = (e2) => {
    if (e2.target === target || isRefocusing) e2.stopImmediatePropagation();
  };
  let onFocusIn = (e2) => {
    if (e2.target === target || isRefocusing) {
      e2.stopImmediatePropagation();
      if (!isRefocusing) {
        isRefocusing = true;
        $7215afc6de606d6b$export$de79e2c695e052f3(activeElement);
        cleanup();
      }
    }
  };
  window2.addEventListener("blur", onBlur, true);
  window2.addEventListener("focusout", onFocusOut, true);
  window2.addEventListener("focusin", onFocusIn, true);
  window2.addEventListener("focus", onFocus, true);
  let cleanup = () => {
    cancelAnimationFrame(raf);
    window2.removeEventListener("blur", onBlur, true);
    window2.removeEventListener("focusout", onFocusOut, true);
    window2.removeEventListener("focusin", onFocusIn, true);
    window2.removeEventListener("focus", onFocus, true);
    $8a9cb279dc87e130$export$fda7da73ab5d4c48 = false;
    isRefocusing = false;
  };
  let raf = requestAnimationFrame(cleanup);
  return cleanup;
}
let $14c0b72509d70225$var$state = "default";
let $14c0b72509d70225$var$savedUserSelect = "";
let $14c0b72509d70225$var$modifiedElementMap = /* @__PURE__ */ new WeakMap();
function $14c0b72509d70225$export$16a4697467175487(target) {
  if ($c87311424ea30a05$export$fedb369cb70207f1()) {
    if ($14c0b72509d70225$var$state === "default") {
      const documentObject = $431fbd86ca7dc216$export$b204af158042fbac(target);
      $14c0b72509d70225$var$savedUserSelect = documentObject.documentElement.style.webkitUserSelect;
      documentObject.documentElement.style.webkitUserSelect = "none";
    }
    $14c0b72509d70225$var$state = "disabled";
  } else if (target instanceof HTMLElement || target instanceof SVGElement) {
    let property = "userSelect" in target.style ? "userSelect" : "webkitUserSelect";
    $14c0b72509d70225$var$modifiedElementMap.set(target, target.style[property]);
    target.style[property] = "none";
  }
}
function $14c0b72509d70225$export$b0d6fa1ab32e3295(target) {
  if ($c87311424ea30a05$export$fedb369cb70207f1()) {
    if ($14c0b72509d70225$var$state !== "disabled") return;
    $14c0b72509d70225$var$state = "restoring";
    setTimeout(() => {
      $bbed8b41f857bcc0$export$24490316f764c430(() => {
        if ($14c0b72509d70225$var$state === "restoring") {
          const documentObject = $431fbd86ca7dc216$export$b204af158042fbac(target);
          if (documentObject.documentElement.style.webkitUserSelect === "none") documentObject.documentElement.style.webkitUserSelect = $14c0b72509d70225$var$savedUserSelect || "";
          $14c0b72509d70225$var$savedUserSelect = "";
          $14c0b72509d70225$var$state = "default";
        }
      });
    }, 300);
  } else if (target instanceof HTMLElement || target instanceof SVGElement) {
    if (target && $14c0b72509d70225$var$modifiedElementMap.has(target)) {
      let targetOldUserSelect = $14c0b72509d70225$var$modifiedElementMap.get(target);
      let property = "userSelect" in target.style ? "userSelect" : "webkitUserSelect";
      if (target.style[property] === "none") target.style[property] = targetOldUserSelect;
      if (target.getAttribute("style") === "") target.removeAttribute("style");
      $14c0b72509d70225$var$modifiedElementMap.delete(target);
    }
  }
}
const $ae1eeba8b9eafd08$export$5165eccb35aaadb5 = React.createContext({
  register: () => {
  }
});
$ae1eeba8b9eafd08$export$5165eccb35aaadb5.displayName = "PressResponderContext";
function _class_apply_descriptor_get(receiver, descriptor) {
  if (descriptor.get) return descriptor.get.call(receiver);
  return descriptor.value;
}
function _class_extract_field_descriptor(receiver, privateMap, action) {
  if (!privateMap.has(receiver)) throw new TypeError("attempted to " + action + " private field on non-instance");
  return privateMap.get(receiver);
}
function _class_private_field_get(receiver, privateMap) {
  var descriptor = _class_extract_field_descriptor(receiver, privateMap, "get");
  return _class_apply_descriptor_get(receiver, descriptor);
}
function _class_apply_descriptor_set(receiver, descriptor, value) {
  if (descriptor.set) descriptor.set.call(receiver, value);
  else {
    if (!descriptor.writable) {
      throw new TypeError("attempted to set read only private field");
    }
    descriptor.value = value;
  }
}
function _class_private_field_set(receiver, privateMap, value) {
  var descriptor = _class_extract_field_descriptor(receiver, privateMap, "set");
  _class_apply_descriptor_set(receiver, descriptor, value);
  return value;
}
function $f6c31cce2adf654f$var$usePressResponderContext(props) {
  let context = reactExports.useContext($ae1eeba8b9eafd08$export$5165eccb35aaadb5);
  if (context) {
    let { register, ...contextProps } = context;
    props = $3ef42575df84b30b$export$9d1611c77c2fe928(contextProps, props);
    register();
  }
  $e7801be82b4b2a53$export$4debdb1a3f0fa79e(context, props.ref);
  return props;
}
var $f6c31cce2adf654f$var$_shouldStopPropagation = /* @__PURE__ */ new WeakMap();
class $f6c31cce2adf654f$var$PressEvent {
  continuePropagation() {
    _class_private_field_set(this, $f6c31cce2adf654f$var$_shouldStopPropagation, false);
  }
  get shouldStopPropagation() {
    return _class_private_field_get(this, $f6c31cce2adf654f$var$_shouldStopPropagation);
  }
  constructor(type, pointerType, originalEvent, state) {
    _class_private_field_init(this, $f6c31cce2adf654f$var$_shouldStopPropagation, {
      writable: true,
      value: void 0
    });
    _class_private_field_set(this, $f6c31cce2adf654f$var$_shouldStopPropagation, true);
    var _state_target;
    let currentTarget = (_state_target = state === null || state === void 0 ? void 0 : state.target) !== null && _state_target !== void 0 ? _state_target : originalEvent.currentTarget;
    const rect = currentTarget === null || currentTarget === void 0 ? void 0 : currentTarget.getBoundingClientRect();
    let x2, y2 = 0;
    let clientX, clientY = null;
    if (originalEvent.clientX != null && originalEvent.clientY != null) {
      clientX = originalEvent.clientX;
      clientY = originalEvent.clientY;
    }
    if (rect) {
      if (clientX != null && clientY != null) {
        x2 = clientX - rect.left;
        y2 = clientY - rect.top;
      } else {
        x2 = rect.width / 2;
        y2 = rect.height / 2;
      }
    }
    this.type = type;
    this.pointerType = pointerType;
    this.target = originalEvent.currentTarget;
    this.shiftKey = originalEvent.shiftKey;
    this.metaKey = originalEvent.metaKey;
    this.ctrlKey = originalEvent.ctrlKey;
    this.altKey = originalEvent.altKey;
    this.x = x2;
    this.y = y2;
  }
}
const $f6c31cce2adf654f$var$LINK_CLICKED = Symbol("linkClicked");
const $f6c31cce2adf654f$var$STYLE_ID = "react-aria-pressable-style";
const $f6c31cce2adf654f$var$PRESSABLE_ATTRIBUTE = "data-react-aria-pressable";
function $f6c31cce2adf654f$export$45712eceda6fad21(props) {
  let { onPress, onPressChange, onPressStart, onPressEnd, onPressUp, onClick, isDisabled, isPressed: isPressedProp, preventFocusOnPress, shouldCancelOnPointerExit, allowTextSelectionOnPress, ref: domRef, ...domProps } = $f6c31cce2adf654f$var$usePressResponderContext(props);
  let [isPressed, setPressed] = reactExports.useState(false);
  let ref = reactExports.useRef({
    isPressed: false,
    ignoreEmulatedMouseEvents: false,
    didFirePressStart: false,
    isTriggeringEvent: false,
    activePointerId: null,
    target: null,
    isOverTarget: false,
    pointerType: null,
    disposables: []
  });
  let { addGlobalListener, removeAllGlobalListeners } = $03deb23ff14920c4$export$4eaf04e54aa8eed6();
  let triggerPressStart = $8ae05eaa5c114e9c$export$7f54fc3180508a52((originalEvent, pointerType) => {
    let state = ref.current;
    if (isDisabled || state.didFirePressStart) return false;
    let shouldStopPropagation = true;
    state.isTriggeringEvent = true;
    if (onPressStart) {
      let event = new $f6c31cce2adf654f$var$PressEvent("pressstart", pointerType, originalEvent);
      onPressStart(event);
      shouldStopPropagation = event.shouldStopPropagation;
    }
    if (onPressChange) onPressChange(true);
    state.isTriggeringEvent = false;
    state.didFirePressStart = true;
    setPressed(true);
    return shouldStopPropagation;
  });
  let triggerPressEnd = $8ae05eaa5c114e9c$export$7f54fc3180508a52((originalEvent, pointerType, wasPressed = true) => {
    let state = ref.current;
    if (!state.didFirePressStart) return false;
    state.didFirePressStart = false;
    state.isTriggeringEvent = true;
    let shouldStopPropagation = true;
    if (onPressEnd) {
      let event = new $f6c31cce2adf654f$var$PressEvent("pressend", pointerType, originalEvent);
      onPressEnd(event);
      shouldStopPropagation = event.shouldStopPropagation;
    }
    if (onPressChange) onPressChange(false);
    setPressed(false);
    if (onPress && wasPressed && !isDisabled) {
      let event = new $f6c31cce2adf654f$var$PressEvent("press", pointerType, originalEvent);
      onPress(event);
      shouldStopPropagation && (shouldStopPropagation = event.shouldStopPropagation);
    }
    state.isTriggeringEvent = false;
    return shouldStopPropagation;
  });
  let triggerPressUp = $8ae05eaa5c114e9c$export$7f54fc3180508a52((originalEvent, pointerType) => {
    let state = ref.current;
    if (isDisabled) return false;
    if (onPressUp) {
      state.isTriggeringEvent = true;
      let event = new $f6c31cce2adf654f$var$PressEvent("pressup", pointerType, originalEvent);
      onPressUp(event);
      state.isTriggeringEvent = false;
      return event.shouldStopPropagation;
    }
    return true;
  });
  let cancel = $8ae05eaa5c114e9c$export$7f54fc3180508a52((e2) => {
    let state = ref.current;
    if (state.isPressed && state.target) {
      if (state.didFirePressStart && state.pointerType != null) triggerPressEnd($f6c31cce2adf654f$var$createEvent(state.target, e2), state.pointerType, false);
      state.isPressed = false;
      state.isOverTarget = false;
      state.activePointerId = null;
      state.pointerType = null;
      removeAllGlobalListeners();
      if (!allowTextSelectionOnPress) $14c0b72509d70225$export$b0d6fa1ab32e3295(state.target);
      for (let dispose of state.disposables) dispose();
      state.disposables = [];
    }
  });
  let cancelOnPointerExit = $8ae05eaa5c114e9c$export$7f54fc3180508a52((e2) => {
    if (shouldCancelOnPointerExit) cancel(e2);
  });
  let triggerClick = $8ae05eaa5c114e9c$export$7f54fc3180508a52((e2) => {
    onClick === null || onClick === void 0 ? void 0 : onClick(e2);
  });
  let triggerSyntheticClick = $8ae05eaa5c114e9c$export$7f54fc3180508a52((e2, target) => {
    if (onClick) {
      let event = new MouseEvent("click", e2);
      $8a9cb279dc87e130$export$c2b7abe5d61ec696(event, target);
      onClick($8a9cb279dc87e130$export$525bc4921d56d4a(event));
    }
  });
  let pressProps = reactExports.useMemo(() => {
    let state = ref.current;
    let pressProps2 = {
      onKeyDown(e2) {
        if ($f6c31cce2adf654f$var$isValidKeyboardEvent(e2.nativeEvent, e2.currentTarget) && $d4ee10de306f2510$export$4282f70798064fe0(e2.currentTarget, $d4ee10de306f2510$export$e58f029f0fbfdb29(e2.nativeEvent))) {
          var _state_metaKeyEvents;
          if ($f6c31cce2adf654f$var$shouldPreventDefaultKeyboard($d4ee10de306f2510$export$e58f029f0fbfdb29(e2.nativeEvent), e2.key)) e2.preventDefault();
          let shouldStopPropagation = true;
          if (!state.isPressed && !e2.repeat) {
            state.target = e2.currentTarget;
            state.isPressed = true;
            state.pointerType = "keyboard";
            shouldStopPropagation = triggerPressStart(e2, "keyboard");
            let originalTarget = e2.currentTarget;
            let pressUp = (e22) => {
              if ($f6c31cce2adf654f$var$isValidKeyboardEvent(e22, originalTarget) && !e22.repeat && $d4ee10de306f2510$export$4282f70798064fe0(originalTarget, $d4ee10de306f2510$export$e58f029f0fbfdb29(e22)) && state.target) triggerPressUp($f6c31cce2adf654f$var$createEvent(state.target, e22), "keyboard");
            };
            addGlobalListener($431fbd86ca7dc216$export$b204af158042fbac(e2.currentTarget), "keyup", $ff5963eb1fccf552$export$e08e3b67e392101e(pressUp, onKeyUp), true);
          }
          if (shouldStopPropagation) e2.stopPropagation();
          if (e2.metaKey && $c87311424ea30a05$export$9ac100e40613ea10()) (_state_metaKeyEvents = state.metaKeyEvents) === null || _state_metaKeyEvents === void 0 ? void 0 : _state_metaKeyEvents.set(e2.key, e2.nativeEvent);
        } else if (e2.key === "Meta") state.metaKeyEvents = /* @__PURE__ */ new Map();
      },
      onClick(e2) {
        if (e2 && !$d4ee10de306f2510$export$4282f70798064fe0(e2.currentTarget, $d4ee10de306f2510$export$e58f029f0fbfdb29(e2.nativeEvent))) return;
        if (e2 && e2.button === 0 && !state.isTriggeringEvent && !$ea8dcbcb9ea1b556$export$95185d699e05d4d7.isOpening) {
          let shouldStopPropagation = true;
          if (isDisabled) e2.preventDefault();
          if (!state.ignoreEmulatedMouseEvents && !state.isPressed && (state.pointerType === "virtual" || $6a7db85432448f7f$export$60278871457622de(e2.nativeEvent))) {
            let stopPressStart = triggerPressStart(e2, "virtual");
            let stopPressUp = triggerPressUp(e2, "virtual");
            let stopPressEnd = triggerPressEnd(e2, "virtual");
            triggerClick(e2);
            shouldStopPropagation = stopPressStart && stopPressUp && stopPressEnd;
          } else if (state.isPressed && state.pointerType !== "keyboard") {
            let pointerType = state.pointerType || e2.nativeEvent.pointerType || "virtual";
            let stopPressUp = triggerPressUp($f6c31cce2adf654f$var$createEvent(e2.currentTarget, e2), pointerType);
            let stopPressEnd = triggerPressEnd($f6c31cce2adf654f$var$createEvent(e2.currentTarget, e2), pointerType, true);
            shouldStopPropagation = stopPressUp && stopPressEnd;
            state.isOverTarget = false;
            triggerClick(e2);
            cancel(e2);
          }
          state.ignoreEmulatedMouseEvents = false;
          if (shouldStopPropagation) e2.stopPropagation();
        }
      }
    };
    let onKeyUp = (e2) => {
      var _state_metaKeyEvents;
      if (state.isPressed && state.target && $f6c31cce2adf654f$var$isValidKeyboardEvent(e2, state.target)) {
        var _state_metaKeyEvents1;
        if ($f6c31cce2adf654f$var$shouldPreventDefaultKeyboard($d4ee10de306f2510$export$e58f029f0fbfdb29(e2), e2.key)) e2.preventDefault();
        let target = $d4ee10de306f2510$export$e58f029f0fbfdb29(e2);
        let wasPressed = $d4ee10de306f2510$export$4282f70798064fe0(state.target, $d4ee10de306f2510$export$e58f029f0fbfdb29(e2));
        triggerPressEnd($f6c31cce2adf654f$var$createEvent(state.target, e2), "keyboard", wasPressed);
        if (wasPressed) triggerSyntheticClick(e2, state.target);
        removeAllGlobalListeners();
        if (e2.key !== "Enter" && $f6c31cce2adf654f$var$isHTMLAnchorLink(state.target) && $d4ee10de306f2510$export$4282f70798064fe0(state.target, target) && !e2[$f6c31cce2adf654f$var$LINK_CLICKED]) {
          e2[$f6c31cce2adf654f$var$LINK_CLICKED] = true;
          $ea8dcbcb9ea1b556$export$95185d699e05d4d7(state.target, e2, false);
        }
        state.isPressed = false;
        (_state_metaKeyEvents1 = state.metaKeyEvents) === null || _state_metaKeyEvents1 === void 0 ? void 0 : _state_metaKeyEvents1.delete(e2.key);
      } else if (e2.key === "Meta" && ((_state_metaKeyEvents = state.metaKeyEvents) === null || _state_metaKeyEvents === void 0 ? void 0 : _state_metaKeyEvents.size)) {
        var _state_target;
        let events = state.metaKeyEvents;
        state.metaKeyEvents = void 0;
        for (let event of events.values()) (_state_target = state.target) === null || _state_target === void 0 ? void 0 : _state_target.dispatchEvent(new KeyboardEvent("keyup", event));
      }
    };
    if (typeof PointerEvent !== "undefined") {
      pressProps2.onPointerDown = (e2) => {
        if (e2.button !== 0 || !$d4ee10de306f2510$export$4282f70798064fe0(e2.currentTarget, $d4ee10de306f2510$export$e58f029f0fbfdb29(e2.nativeEvent))) return;
        if ($6a7db85432448f7f$export$29bf1b5f2c56cf63(e2.nativeEvent)) {
          state.pointerType = "virtual";
          return;
        }
        state.pointerType = e2.pointerType;
        let shouldStopPropagation = true;
        if (!state.isPressed) {
          state.isPressed = true;
          state.isOverTarget = true;
          state.activePointerId = e2.pointerId;
          state.target = e2.currentTarget;
          if (!allowTextSelectionOnPress) $14c0b72509d70225$export$16a4697467175487(state.target);
          shouldStopPropagation = triggerPressStart(e2, state.pointerType);
          let target = $d4ee10de306f2510$export$e58f029f0fbfdb29(e2.nativeEvent);
          if ("releasePointerCapture" in target) target.releasePointerCapture(e2.pointerId);
          addGlobalListener($431fbd86ca7dc216$export$b204af158042fbac(e2.currentTarget), "pointerup", onPointerUp, false);
          addGlobalListener($431fbd86ca7dc216$export$b204af158042fbac(e2.currentTarget), "pointercancel", onPointerCancel, false);
        }
        if (shouldStopPropagation) e2.stopPropagation();
      };
      pressProps2.onMouseDown = (e2) => {
        if (!$d4ee10de306f2510$export$4282f70798064fe0(e2.currentTarget, $d4ee10de306f2510$export$e58f029f0fbfdb29(e2.nativeEvent))) return;
        if (e2.button === 0) {
          if (preventFocusOnPress) {
            let dispose = $8a9cb279dc87e130$export$cabe61c495ee3649(e2.target);
            if (dispose) state.disposables.push(dispose);
          }
          e2.stopPropagation();
        }
      };
      pressProps2.onPointerUp = (e2) => {
        if (!$d4ee10de306f2510$export$4282f70798064fe0(e2.currentTarget, $d4ee10de306f2510$export$e58f029f0fbfdb29(e2.nativeEvent)) || state.pointerType === "virtual") return;
        if (e2.button === 0 && !state.isPressed) triggerPressUp(e2, state.pointerType || e2.pointerType);
      };
      pressProps2.onPointerEnter = (e2) => {
        if (e2.pointerId === state.activePointerId && state.target && !state.isOverTarget && state.pointerType != null) {
          state.isOverTarget = true;
          triggerPressStart($f6c31cce2adf654f$var$createEvent(state.target, e2), state.pointerType);
        }
      };
      pressProps2.onPointerLeave = (e2) => {
        if (e2.pointerId === state.activePointerId && state.target && state.isOverTarget && state.pointerType != null) {
          state.isOverTarget = false;
          triggerPressEnd($f6c31cce2adf654f$var$createEvent(state.target, e2), state.pointerType, false);
          cancelOnPointerExit(e2);
        }
      };
      let onPointerUp = (e2) => {
        if (e2.pointerId === state.activePointerId && state.isPressed && e2.button === 0 && state.target) {
          if ($d4ee10de306f2510$export$4282f70798064fe0(state.target, $d4ee10de306f2510$export$e58f029f0fbfdb29(e2)) && state.pointerType != null) {
            let clicked = false;
            let timeout = setTimeout(() => {
              if (state.isPressed && state.target instanceof HTMLElement) {
                if (clicked) cancel(e2);
                else {
                  $7215afc6de606d6b$export$de79e2c695e052f3(state.target);
                  state.target.click();
                }
              }
            }, 80);
            addGlobalListener(e2.currentTarget, "click", () => clicked = true, true);
            state.disposables.push(() => clearTimeout(timeout));
          } else cancel(e2);
          state.isOverTarget = false;
        }
      };
      let onPointerCancel = (e2) => {
        cancel(e2);
      };
      pressProps2.onDragStart = (e2) => {
        if (!$d4ee10de306f2510$export$4282f70798064fe0(e2.currentTarget, $d4ee10de306f2510$export$e58f029f0fbfdb29(e2.nativeEvent))) return;
        cancel(e2);
      };
    }
    return pressProps2;
  }, [
    addGlobalListener,
    isDisabled,
    preventFocusOnPress,
    removeAllGlobalListeners,
    allowTextSelectionOnPress,
    cancel,
    cancelOnPointerExit,
    triggerPressEnd,
    triggerPressStart,
    triggerPressUp,
    triggerClick,
    triggerSyntheticClick
  ]);
  reactExports.useEffect(() => {
    if (!domRef || false) return;
    const ownerDocument2 = $431fbd86ca7dc216$export$b204af158042fbac(domRef.current);
    if (!ownerDocument2 || !ownerDocument2.head || ownerDocument2.getElementById($f6c31cce2adf654f$var$STYLE_ID)) return;
    const style2 = ownerDocument2.createElement("style");
    style2.id = $f6c31cce2adf654f$var$STYLE_ID;
    style2.textContent = `
@layer {
  [${$f6c31cce2adf654f$var$PRESSABLE_ATTRIBUTE}] {
    touch-action: pan-x pan-y pinch-zoom;
  }
}
    `.trim();
    ownerDocument2.head.prepend(style2);
  }, [
    domRef
  ]);
  reactExports.useEffect(() => {
    let state = ref.current;
    return () => {
      var _state_target;
      if (!allowTextSelectionOnPress) $14c0b72509d70225$export$b0d6fa1ab32e3295((_state_target = state.target) !== null && _state_target !== void 0 ? _state_target : void 0);
      for (let dispose of state.disposables) dispose();
      state.disposables = [];
    };
  }, [
    allowTextSelectionOnPress
  ]);
  return {
    isPressed: isPressedProp || isPressed,
    pressProps: $3ef42575df84b30b$export$9d1611c77c2fe928(domProps, pressProps, {
      [$f6c31cce2adf654f$var$PRESSABLE_ATTRIBUTE]: true
    })
  };
}
function $f6c31cce2adf654f$var$isHTMLAnchorLink(target) {
  return target.tagName === "A" && target.hasAttribute("href");
}
function $f6c31cce2adf654f$var$isValidKeyboardEvent(event, currentTarget) {
  const { key: key2, code } = event;
  const element = currentTarget;
  const role = element.getAttribute("role");
  return (key2 === "Enter" || key2 === " " || key2 === "Spacebar" || code === "Space") && !(element instanceof $431fbd86ca7dc216$export$f21a1ffae260145a(element).HTMLInputElement && !$f6c31cce2adf654f$var$isValidInputKey(element, key2) || element instanceof $431fbd86ca7dc216$export$f21a1ffae260145a(element).HTMLTextAreaElement || element.isContentEditable) && // Links should only trigger with Enter key
  !((role === "link" || !role && $f6c31cce2adf654f$var$isHTMLAnchorLink(element)) && key2 !== "Enter");
}
function $f6c31cce2adf654f$var$createEvent(target, e2) {
  let clientX = e2.clientX;
  let clientY = e2.clientY;
  return {
    currentTarget: target,
    shiftKey: e2.shiftKey,
    ctrlKey: e2.ctrlKey,
    metaKey: e2.metaKey,
    altKey: e2.altKey,
    clientX,
    clientY
  };
}
function $f6c31cce2adf654f$var$shouldPreventDefaultUp(target) {
  if (target instanceof HTMLInputElement) return false;
  if (target instanceof HTMLButtonElement) return target.type !== "submit" && target.type !== "reset";
  if ($f6c31cce2adf654f$var$isHTMLAnchorLink(target)) return false;
  return true;
}
function $f6c31cce2adf654f$var$shouldPreventDefaultKeyboard(target, key2) {
  if (target instanceof HTMLInputElement) return !$f6c31cce2adf654f$var$isValidInputKey(target, key2);
  return $f6c31cce2adf654f$var$shouldPreventDefaultUp(target);
}
const $f6c31cce2adf654f$var$nonTextInputTypes = /* @__PURE__ */ new Set([
  "checkbox",
  "radio",
  "range",
  "color",
  "file",
  "image",
  "button",
  "submit",
  "reset"
]);
function $f6c31cce2adf654f$var$isValidInputKey(target, key2) {
  return target.type === "checkbox" || target.type === "radio" ? key2 === " " : $f6c31cce2adf654f$var$nonTextInputTypes.has(target.type);
}
let $507fabe10e71c6fb$var$currentModality = null;
let $507fabe10e71c6fb$var$changeHandlers = /* @__PURE__ */ new Set();
let $507fabe10e71c6fb$export$d90243b58daecda7 = /* @__PURE__ */ new Map();
let $507fabe10e71c6fb$var$hasEventBeforeFocus = false;
let $507fabe10e71c6fb$var$hasBlurredWindowRecently = false;
const $507fabe10e71c6fb$var$FOCUS_VISIBLE_INPUT_KEYS = {
  Tab: true,
  Escape: true
};
function $507fabe10e71c6fb$var$triggerChangeHandlers(modality, e2) {
  for (let handler of $507fabe10e71c6fb$var$changeHandlers) handler(modality, e2);
}
function $507fabe10e71c6fb$var$isValidKey(e2) {
  return !(e2.metaKey || !$c87311424ea30a05$export$9ac100e40613ea10() && e2.altKey || e2.ctrlKey || e2.key === "Control" || e2.key === "Shift" || e2.key === "Meta");
}
function $507fabe10e71c6fb$var$handleKeyboardEvent(e2) {
  $507fabe10e71c6fb$var$hasEventBeforeFocus = true;
  if ($507fabe10e71c6fb$var$isValidKey(e2)) {
    $507fabe10e71c6fb$var$currentModality = "keyboard";
    $507fabe10e71c6fb$var$triggerChangeHandlers("keyboard", e2);
  }
}
function $507fabe10e71c6fb$var$handlePointerEvent(e2) {
  $507fabe10e71c6fb$var$currentModality = "pointer";
  if (e2.type === "mousedown" || e2.type === "pointerdown") {
    $507fabe10e71c6fb$var$hasEventBeforeFocus = true;
    $507fabe10e71c6fb$var$triggerChangeHandlers("pointer", e2);
  }
}
function $507fabe10e71c6fb$var$handleClickEvent(e2) {
  if ($6a7db85432448f7f$export$60278871457622de(e2)) {
    $507fabe10e71c6fb$var$hasEventBeforeFocus = true;
    $507fabe10e71c6fb$var$currentModality = "virtual";
  }
}
function $507fabe10e71c6fb$var$handleFocusEvent(e2) {
  if (e2.target === window || e2.target === document || $8a9cb279dc87e130$export$fda7da73ab5d4c48 || !e2.isTrusted) return;
  if (!$507fabe10e71c6fb$var$hasEventBeforeFocus && !$507fabe10e71c6fb$var$hasBlurredWindowRecently) {
    $507fabe10e71c6fb$var$currentModality = "virtual";
    $507fabe10e71c6fb$var$triggerChangeHandlers("virtual", e2);
  }
  $507fabe10e71c6fb$var$hasEventBeforeFocus = false;
  $507fabe10e71c6fb$var$hasBlurredWindowRecently = false;
}
function $507fabe10e71c6fb$var$handleWindowBlur() {
  if ($8a9cb279dc87e130$export$fda7da73ab5d4c48) return;
  $507fabe10e71c6fb$var$hasEventBeforeFocus = false;
  $507fabe10e71c6fb$var$hasBlurredWindowRecently = true;
}
function $507fabe10e71c6fb$var$setupGlobalFocusEvents(element) {
  if (typeof window === "undefined" || typeof document === "undefined" || $507fabe10e71c6fb$export$d90243b58daecda7.get($431fbd86ca7dc216$export$f21a1ffae260145a(element))) return;
  const windowObject = $431fbd86ca7dc216$export$f21a1ffae260145a(element);
  const documentObject = $431fbd86ca7dc216$export$b204af158042fbac(element);
  let focus2 = windowObject.HTMLElement.prototype.focus;
  windowObject.HTMLElement.prototype.focus = function() {
    $507fabe10e71c6fb$var$hasEventBeforeFocus = true;
    focus2.apply(this, arguments);
  };
  documentObject.addEventListener("keydown", $507fabe10e71c6fb$var$handleKeyboardEvent, true);
  documentObject.addEventListener("keyup", $507fabe10e71c6fb$var$handleKeyboardEvent, true);
  documentObject.addEventListener("click", $507fabe10e71c6fb$var$handleClickEvent, true);
  windowObject.addEventListener("focus", $507fabe10e71c6fb$var$handleFocusEvent, true);
  windowObject.addEventListener("blur", $507fabe10e71c6fb$var$handleWindowBlur, false);
  if (typeof PointerEvent !== "undefined") {
    documentObject.addEventListener("pointerdown", $507fabe10e71c6fb$var$handlePointerEvent, true);
    documentObject.addEventListener("pointermove", $507fabe10e71c6fb$var$handlePointerEvent, true);
    documentObject.addEventListener("pointerup", $507fabe10e71c6fb$var$handlePointerEvent, true);
  }
  windowObject.addEventListener("beforeunload", () => {
    $507fabe10e71c6fb$var$tearDownWindowFocusTracking(element);
  }, {
    once: true
  });
  $507fabe10e71c6fb$export$d90243b58daecda7.set(windowObject, {
    focus: focus2
  });
}
const $507fabe10e71c6fb$var$tearDownWindowFocusTracking = (element, loadListener) => {
  const windowObject = $431fbd86ca7dc216$export$f21a1ffae260145a(element);
  const documentObject = $431fbd86ca7dc216$export$b204af158042fbac(element);
  if (loadListener) documentObject.removeEventListener("DOMContentLoaded", loadListener);
  if (!$507fabe10e71c6fb$export$d90243b58daecda7.has(windowObject)) return;
  windowObject.HTMLElement.prototype.focus = $507fabe10e71c6fb$export$d90243b58daecda7.get(windowObject).focus;
  documentObject.removeEventListener("keydown", $507fabe10e71c6fb$var$handleKeyboardEvent, true);
  documentObject.removeEventListener("keyup", $507fabe10e71c6fb$var$handleKeyboardEvent, true);
  documentObject.removeEventListener("click", $507fabe10e71c6fb$var$handleClickEvent, true);
  windowObject.removeEventListener("focus", $507fabe10e71c6fb$var$handleFocusEvent, true);
  windowObject.removeEventListener("blur", $507fabe10e71c6fb$var$handleWindowBlur, false);
  if (typeof PointerEvent !== "undefined") {
    documentObject.removeEventListener("pointerdown", $507fabe10e71c6fb$var$handlePointerEvent, true);
    documentObject.removeEventListener("pointermove", $507fabe10e71c6fb$var$handlePointerEvent, true);
    documentObject.removeEventListener("pointerup", $507fabe10e71c6fb$var$handlePointerEvent, true);
  }
  $507fabe10e71c6fb$export$d90243b58daecda7.delete(windowObject);
};
function $507fabe10e71c6fb$export$2f1888112f558a7d(element) {
  const documentObject = $431fbd86ca7dc216$export$b204af158042fbac(element);
  let loadListener;
  if (documentObject.readyState !== "loading") $507fabe10e71c6fb$var$setupGlobalFocusEvents(element);
  else {
    loadListener = () => {
      $507fabe10e71c6fb$var$setupGlobalFocusEvents(element);
    };
    documentObject.addEventListener("DOMContentLoaded", loadListener);
  }
  return () => $507fabe10e71c6fb$var$tearDownWindowFocusTracking(element, loadListener);
}
if (typeof document !== "undefined") $507fabe10e71c6fb$export$2f1888112f558a7d();
function $507fabe10e71c6fb$export$b9b3dfddab17db27() {
  return $507fabe10e71c6fb$var$currentModality !== "pointer";
}
function $507fabe10e71c6fb$export$630ff653c5ada6a9() {
  return $507fabe10e71c6fb$var$currentModality;
}
const $507fabe10e71c6fb$var$nonTextInputTypes = /* @__PURE__ */ new Set([
  "checkbox",
  "radio",
  "range",
  "color",
  "file",
  "image",
  "button",
  "submit",
  "reset"
]);
function $507fabe10e71c6fb$var$isKeyboardFocusEvent(isTextInput, modality, e2) {
  let document1 = $431fbd86ca7dc216$export$b204af158042fbac(e2 === null || e2 === void 0 ? void 0 : e2.target);
  const IHTMLInputElement = typeof window !== "undefined" ? $431fbd86ca7dc216$export$f21a1ffae260145a(e2 === null || e2 === void 0 ? void 0 : e2.target).HTMLInputElement : HTMLInputElement;
  const IHTMLTextAreaElement = typeof window !== "undefined" ? $431fbd86ca7dc216$export$f21a1ffae260145a(e2 === null || e2 === void 0 ? void 0 : e2.target).HTMLTextAreaElement : HTMLTextAreaElement;
  const IHTMLElement = typeof window !== "undefined" ? $431fbd86ca7dc216$export$f21a1ffae260145a(e2 === null || e2 === void 0 ? void 0 : e2.target).HTMLElement : HTMLElement;
  const IKeyboardEvent = typeof window !== "undefined" ? $431fbd86ca7dc216$export$f21a1ffae260145a(e2 === null || e2 === void 0 ? void 0 : e2.target).KeyboardEvent : KeyboardEvent;
  isTextInput = isTextInput || document1.activeElement instanceof IHTMLInputElement && !$507fabe10e71c6fb$var$nonTextInputTypes.has(document1.activeElement.type) || document1.activeElement instanceof IHTMLTextAreaElement || document1.activeElement instanceof IHTMLElement && document1.activeElement.isContentEditable;
  return !(isTextInput && modality === "keyboard" && e2 instanceof IKeyboardEvent && !$507fabe10e71c6fb$var$FOCUS_VISIBLE_INPUT_KEYS[e2.key]);
}
function $507fabe10e71c6fb$export$ec71b4b83ac08ec3(fn, deps, opts) {
  $507fabe10e71c6fb$var$setupGlobalFocusEvents();
  reactExports.useEffect(() => {
    let handler = (modality, e2) => {
      if (!$507fabe10e71c6fb$var$isKeyboardFocusEvent(!!(opts === null || opts === void 0 ? void 0 : opts.isTextInput), modality, e2)) return;
      fn($507fabe10e71c6fb$export$b9b3dfddab17db27());
    };
    $507fabe10e71c6fb$var$changeHandlers.add(handler);
    return () => {
      $507fabe10e71c6fb$var$changeHandlers.delete(handler);
    };
  }, deps);
}
function $3ad3f6e1647bc98d$export$80f3e147d781571c(element) {
  const ownerDocument2 = $431fbd86ca7dc216$export$b204af158042fbac(element);
  const activeElement = $d4ee10de306f2510$export$cd4e5573fbe2b576(ownerDocument2);
  if ($507fabe10e71c6fb$export$630ff653c5ada6a9() === "virtual") {
    let lastFocusedElement = activeElement;
    $bbed8b41f857bcc0$export$24490316f764c430(() => {
      if ($d4ee10de306f2510$export$cd4e5573fbe2b576(ownerDocument2) === lastFocusedElement && element.isConnected) $7215afc6de606d6b$export$de79e2c695e052f3(element);
    });
  } else $7215afc6de606d6b$export$de79e2c695e052f3(element);
}
function $a1ea59d68270f0dd$export$f8168d8dd8fd66e6(props) {
  let { isDisabled, onFocus: onFocusProp, onBlur: onBlurProp, onFocusChange } = props;
  const onBlur = reactExports.useCallback((e2) => {
    if (e2.target === e2.currentTarget) {
      if (onBlurProp) onBlurProp(e2);
      if (onFocusChange) onFocusChange(false);
      return true;
    }
  }, [
    onBlurProp,
    onFocusChange
  ]);
  const onSyntheticFocus = $8a9cb279dc87e130$export$715c682d09d639cc(onBlur);
  const onFocus = reactExports.useCallback((e2) => {
    const ownerDocument2 = $431fbd86ca7dc216$export$b204af158042fbac(e2.target);
    const activeElement = ownerDocument2 ? $d4ee10de306f2510$export$cd4e5573fbe2b576(ownerDocument2) : $d4ee10de306f2510$export$cd4e5573fbe2b576();
    if (e2.target === e2.currentTarget && activeElement === $d4ee10de306f2510$export$e58f029f0fbfdb29(e2.nativeEvent)) {
      if (onFocusProp) onFocusProp(e2);
      if (onFocusChange) onFocusChange(true);
      onSyntheticFocus(e2);
    }
  }, [
    onFocusChange,
    onFocusProp,
    onSyntheticFocus
  ]);
  return {
    focusProps: {
      onFocus: !isDisabled && (onFocusProp || onFocusChange || onBlurProp) ? onFocus : void 0,
      onBlur: !isDisabled && (onBlurProp || onFocusChange) ? onBlur : void 0
    }
  };
}
function $93925083ecbb358c$export$48d1ea6320830260(handler) {
  if (!handler) return void 0;
  let shouldStopPropagation = true;
  return (e2) => {
    let event = {
      ...e2,
      preventDefault() {
        e2.preventDefault();
      },
      isDefaultPrevented() {
        return e2.isDefaultPrevented();
      },
      stopPropagation() {
        if (shouldStopPropagation && false) console.error("stopPropagation is now the default behavior for events in React Spectrum. You can use continuePropagation() to revert this behavior.");
        else shouldStopPropagation = true;
      },
      continuePropagation() {
        shouldStopPropagation = false;
      },
      isPropagationStopped() {
        return shouldStopPropagation;
      }
    };
    handler(event);
    if (shouldStopPropagation) e2.stopPropagation();
  };
}
function $46d819fcbaf35654$export$8f71654801c2f7cd(props) {
  return {
    keyboardProps: props.isDisabled ? {} : {
      onKeyDown: $93925083ecbb358c$export$48d1ea6320830260(props.onKeyDown),
      onKeyUp: $93925083ecbb358c$export$48d1ea6320830260(props.onKeyUp)
    }
  };
}
let $f645667febf57a63$export$f9762fab77588ecb = /* @__PURE__ */ React.createContext(null);
function $f645667febf57a63$var$useFocusableContext(ref) {
  let context = reactExports.useContext($f645667febf57a63$export$f9762fab77588ecb) || {};
  $e7801be82b4b2a53$export$4debdb1a3f0fa79e(context, ref);
  let { ref: _2, ...otherProps } = context;
  return otherProps;
}
function $f645667febf57a63$export$4c014de7c8940b4c(props, domRef) {
  let { focusProps } = $a1ea59d68270f0dd$export$f8168d8dd8fd66e6(props);
  let { keyboardProps } = $46d819fcbaf35654$export$8f71654801c2f7cd(props);
  let interactions = $3ef42575df84b30b$export$9d1611c77c2fe928(focusProps, keyboardProps);
  let domProps = $f645667febf57a63$var$useFocusableContext(domRef);
  let interactionProps = props.isDisabled ? {} : domProps;
  let autoFocusRef = reactExports.useRef(props.autoFocus);
  reactExports.useEffect(() => {
    if (autoFocusRef.current && domRef.current) $3ad3f6e1647bc98d$export$80f3e147d781571c(domRef.current);
    autoFocusRef.current = false;
  }, [
    domRef
  ]);
  let tabIndex = props.excludeFromTabOrder ? -1 : 0;
  if (props.isDisabled) tabIndex = void 0;
  return {
    focusableProps: $3ef42575df84b30b$export$9d1611c77c2fe928({
      ...interactions,
      tabIndex
    }, interactionProps)
  };
}
function $9ab94262bd0047c7$export$420e68273165f4ec(props) {
  let { isDisabled, onBlurWithin, onFocusWithin, onFocusWithinChange } = props;
  let state = reactExports.useRef({
    isFocusWithin: false
  });
  let { addGlobalListener, removeAllGlobalListeners } = $03deb23ff14920c4$export$4eaf04e54aa8eed6();
  let onBlur = reactExports.useCallback((e2) => {
    if (!e2.currentTarget.contains(e2.target)) return;
    if (state.current.isFocusWithin && !e2.currentTarget.contains(e2.relatedTarget)) {
      state.current.isFocusWithin = false;
      removeAllGlobalListeners();
      if (onBlurWithin) onBlurWithin(e2);
      if (onFocusWithinChange) onFocusWithinChange(false);
    }
  }, [
    onBlurWithin,
    onFocusWithinChange,
    state,
    removeAllGlobalListeners
  ]);
  let onSyntheticFocus = $8a9cb279dc87e130$export$715c682d09d639cc(onBlur);
  let onFocus = reactExports.useCallback((e2) => {
    if (!e2.currentTarget.contains(e2.target)) return;
    const ownerDocument2 = $431fbd86ca7dc216$export$b204af158042fbac(e2.target);
    const activeElement = $d4ee10de306f2510$export$cd4e5573fbe2b576(ownerDocument2);
    if (!state.current.isFocusWithin && activeElement === $d4ee10de306f2510$export$e58f029f0fbfdb29(e2.nativeEvent)) {
      if (onFocusWithin) onFocusWithin(e2);
      if (onFocusWithinChange) onFocusWithinChange(true);
      state.current.isFocusWithin = true;
      onSyntheticFocus(e2);
      let currentTarget = e2.currentTarget;
      addGlobalListener(ownerDocument2, "focus", (e3) => {
        if (state.current.isFocusWithin && !$d4ee10de306f2510$export$4282f70798064fe0(currentTarget, e3.target)) {
          let nativeEvent = new ownerDocument2.defaultView.FocusEvent("blur", {
            relatedTarget: e3.target
          });
          $8a9cb279dc87e130$export$c2b7abe5d61ec696(nativeEvent, currentTarget);
          let event = $8a9cb279dc87e130$export$525bc4921d56d4a(nativeEvent);
          onBlur(event);
        }
      }, {
        capture: true
      });
    }
  }, [
    onFocusWithin,
    onFocusWithinChange,
    onSyntheticFocus,
    addGlobalListener,
    onBlur
  ]);
  if (isDisabled) return {
    focusWithinProps: {
      // These cannot be null, that would conflict in mergeProps
      onFocus: void 0,
      onBlur: void 0
    }
  };
  return {
    focusWithinProps: {
      onFocus,
      onBlur
    }
  };
}
let $6179b936705e76d3$var$globalIgnoreEmulatedMouseEvents = false;
let $6179b936705e76d3$var$hoverCount = 0;
function $6179b936705e76d3$var$setGlobalIgnoreEmulatedMouseEvents() {
  $6179b936705e76d3$var$globalIgnoreEmulatedMouseEvents = true;
  setTimeout(() => {
    $6179b936705e76d3$var$globalIgnoreEmulatedMouseEvents = false;
  }, 50);
}
function $6179b936705e76d3$var$handleGlobalPointerEvent(e2) {
  if (e2.pointerType === "touch") $6179b936705e76d3$var$setGlobalIgnoreEmulatedMouseEvents();
}
function $6179b936705e76d3$var$setupGlobalTouchEvents() {
  if (typeof document === "undefined") return;
  if (typeof PointerEvent !== "undefined") document.addEventListener("pointerup", $6179b936705e76d3$var$handleGlobalPointerEvent);
  $6179b936705e76d3$var$hoverCount++;
  return () => {
    $6179b936705e76d3$var$hoverCount--;
    if ($6179b936705e76d3$var$hoverCount > 0) return;
    if (typeof PointerEvent !== "undefined") document.removeEventListener("pointerup", $6179b936705e76d3$var$handleGlobalPointerEvent);
  };
}
function $6179b936705e76d3$export$ae780daf29e6d456(props) {
  let { onHoverStart, onHoverChange, onHoverEnd, isDisabled } = props;
  let [isHovered, setHovered] = reactExports.useState(false);
  let state = reactExports.useRef({
    isHovered: false,
    ignoreEmulatedMouseEvents: false,
    pointerType: "",
    target: null
  }).current;
  reactExports.useEffect($6179b936705e76d3$var$setupGlobalTouchEvents, []);
  let { addGlobalListener, removeAllGlobalListeners } = $03deb23ff14920c4$export$4eaf04e54aa8eed6();
  let { hoverProps, triggerHoverEnd } = reactExports.useMemo(() => {
    let triggerHoverStart = (event, pointerType) => {
      state.pointerType = pointerType;
      if (isDisabled || pointerType === "touch" || state.isHovered || !event.currentTarget.contains(event.target)) return;
      state.isHovered = true;
      let target = event.currentTarget;
      state.target = target;
      addGlobalListener($431fbd86ca7dc216$export$b204af158042fbac(event.target), "pointerover", (e2) => {
        if (state.isHovered && state.target && !$d4ee10de306f2510$export$4282f70798064fe0(state.target, e2.target)) triggerHoverEnd2(e2, e2.pointerType);
      }, {
        capture: true
      });
      if (onHoverStart) onHoverStart({
        type: "hoverstart",
        target,
        pointerType
      });
      if (onHoverChange) onHoverChange(true);
      setHovered(true);
    };
    let triggerHoverEnd2 = (event, pointerType) => {
      let target = state.target;
      state.pointerType = "";
      state.target = null;
      if (pointerType === "touch" || !state.isHovered || !target) return;
      state.isHovered = false;
      removeAllGlobalListeners();
      if (onHoverEnd) onHoverEnd({
        type: "hoverend",
        target,
        pointerType
      });
      if (onHoverChange) onHoverChange(false);
      setHovered(false);
    };
    let hoverProps2 = {};
    if (typeof PointerEvent !== "undefined") {
      hoverProps2.onPointerEnter = (e2) => {
        if ($6179b936705e76d3$var$globalIgnoreEmulatedMouseEvents && e2.pointerType === "mouse") return;
        triggerHoverStart(e2, e2.pointerType);
      };
      hoverProps2.onPointerLeave = (e2) => {
        if (!isDisabled && e2.currentTarget.contains(e2.target)) triggerHoverEnd2(e2, e2.pointerType);
      };
    }
    return {
      hoverProps: hoverProps2,
      triggerHoverEnd: triggerHoverEnd2
    };
  }, [
    onHoverStart,
    onHoverChange,
    onHoverEnd,
    isDisabled,
    state,
    addGlobalListener,
    removeAllGlobalListeners
  ]);
  reactExports.useEffect(() => {
    if (isDisabled) triggerHoverEnd({
      currentTarget: state.target
    }, state.pointerType);
  }, [
    isDisabled
  ]);
  return {
    hoverProps,
    isHovered
  };
}
function $f7dceffc5ad7768b$export$4e328f61c538687f(props = {}) {
  let { autoFocus = false, isTextInput, within } = props;
  let state = reactExports.useRef({
    isFocused: false,
    isFocusVisible: autoFocus || $507fabe10e71c6fb$export$b9b3dfddab17db27()
  });
  let [isFocused, setFocused] = reactExports.useState(false);
  let [isFocusVisibleState, setFocusVisible] = reactExports.useState(() => state.current.isFocused && state.current.isFocusVisible);
  let updateState = reactExports.useCallback(() => setFocusVisible(state.current.isFocused && state.current.isFocusVisible), []);
  let onFocusChange = reactExports.useCallback((isFocused2) => {
    state.current.isFocused = isFocused2;
    setFocused(isFocused2);
    updateState();
  }, [
    updateState
  ]);
  $507fabe10e71c6fb$export$ec71b4b83ac08ec3((isFocusVisible2) => {
    state.current.isFocusVisible = isFocusVisible2;
    updateState();
  }, [], {
    isTextInput
  });
  let { focusProps } = $a1ea59d68270f0dd$export$f8168d8dd8fd66e6({
    isDisabled: within,
    onFocusChange
  });
  let { focusWithinProps } = $9ab94262bd0047c7$export$420e68273165f4ec({
    isDisabled: !within,
    onFocusWithinChange: onFocusChange
  });
  return {
    isFocused,
    isFocusVisible: isFocusVisibleState,
    focusProps: within ? focusWithinProps : focusProps
  };
}
const LayoutGroupContext = reactExports.createContext({});
function useConstant(init) {
  const ref = reactExports.useRef(null);
  if (ref.current === null) {
    ref.current = init();
  }
  return ref.current;
}
const isBrowser$2 = typeof window !== "undefined";
const useIsomorphicLayoutEffect$1 = isBrowser$2 ? reactExports.useLayoutEffect : reactExports.useEffect;
const PresenceContext = /* @__PURE__ */ reactExports.createContext(null);
function addUniqueItem(arr, item) {
  if (arr.indexOf(item) === -1)
    arr.push(item);
}
function removeItem(arr, item) {
  const index2 = arr.indexOf(item);
  if (index2 > -1)
    arr.splice(index2, 1);
}
const clamp$4 = (min2, max2, v2) => {
  if (v2 > max2)
    return max2;
  if (v2 < min2)
    return min2;
  return v2;
};
let invariant = () => {
};
const MotionGlobalConfig = {};
const isNumericalString = (v2) => /^-?(?:\d+(?:\.\d+)?|\.\d+)$/u.test(v2);
function isObject(value) {
  return typeof value === "object" && value !== null;
}
const isZeroValueString = (v2) => /^0[^.\s]+$/u.test(v2);
// @__NO_SIDE_EFFECTS__
function memo(callback) {
  let result;
  return () => {
    if (result === void 0)
      result = callback();
    return result;
  };
}
const noop$6 = /* @__NO_SIDE_EFFECTS__ */ (any) => any;
const combineFunctions = (a2, b2) => (v2) => b2(a2(v2));
const pipe = (...transformers) => transformers.reduce(combineFunctions);
const progress = /* @__NO_SIDE_EFFECTS__ */ (from2, to, value) => {
  const toFromDifference = to - from2;
  return toFromDifference === 0 ? 1 : (value - from2) / toFromDifference;
};
class SubscriptionManager {
  constructor() {
    this.subscriptions = [];
  }
  add(handler) {
    addUniqueItem(this.subscriptions, handler);
    return () => removeItem(this.subscriptions, handler);
  }
  notify(a2, b2, c2) {
    const numSubscriptions = this.subscriptions.length;
    if (!numSubscriptions)
      return;
    if (numSubscriptions === 1) {
      this.subscriptions[0](a2, b2, c2);
    } else {
      for (let i2 = 0; i2 < numSubscriptions; i2++) {
        const handler = this.subscriptions[i2];
        handler && handler(a2, b2, c2);
      }
    }
  }
  getSize() {
    return this.subscriptions.length;
  }
  clear() {
    this.subscriptions.length = 0;
  }
}
const secondsToMilliseconds = /* @__NO_SIDE_EFFECTS__ */ (seconds) => seconds * 1e3;
const millisecondsToSeconds = /* @__NO_SIDE_EFFECTS__ */ (milliseconds) => milliseconds / 1e3;
function velocityPerSecond(velocity, frameDuration) {
  return frameDuration ? velocity * (1e3 / frameDuration) : 0;
}
const calcBezier$1 = (t2, a1, a2) => (((1 - 3 * a2 + 3 * a1) * t2 + (3 * a2 - 6 * a1)) * t2 + 3 * a1) * t2;
const subdivisionPrecision = 1e-7;
const subdivisionMaxIterations = 12;
function binarySubdivide$1(x2, lowerBound, upperBound, mX1, mX2) {
  let currentX;
  let currentT;
  let i2 = 0;
  do {
    currentT = lowerBound + (upperBound - lowerBound) / 2;
    currentX = calcBezier$1(currentT, mX1, mX2) - x2;
    if (currentX > 0) {
      upperBound = currentT;
    } else {
      lowerBound = currentT;
    }
  } while (Math.abs(currentX) > subdivisionPrecision && ++i2 < subdivisionMaxIterations);
  return currentT;
}
function cubicBezier$1(mX1, mY1, mX2, mY2) {
  if (mX1 === mY1 && mX2 === mY2)
    return noop$6;
  const getTForX = (aX) => binarySubdivide$1(aX, 0, 1, mX1, mX2);
  return (t2) => t2 === 0 || t2 === 1 ? t2 : calcBezier$1(getTForX(t2), mY1, mY2);
}
const mirrorEasing = (easing2) => (p2) => p2 <= 0.5 ? easing2(2 * p2) / 2 : (2 - easing2(2 * (1 - p2))) / 2;
const reverseEasing = (easing2) => (p2) => 1 - easing2(1 - p2);
const backOut = /* @__PURE__ */ cubicBezier$1(0.33, 1.53, 0.69, 0.99);
const backIn = /* @__PURE__ */ reverseEasing(backOut);
const backInOut = /* @__PURE__ */ mirrorEasing(backIn);
const anticipate = (p2) => (p2 *= 2) < 1 ? 0.5 * backIn(p2) : 0.5 * (2 - Math.pow(2, -10 * (p2 - 1)));
const circIn = (p2) => 1 - Math.sin(Math.acos(p2));
const circOut = reverseEasing(circIn);
const circInOut = mirrorEasing(circIn);
const easeIn = /* @__PURE__ */ cubicBezier$1(0.42, 0, 1, 1);
const easeOut = /* @__PURE__ */ cubicBezier$1(0, 0, 0.58, 1);
const easeInOut = /* @__PURE__ */ cubicBezier$1(0.42, 0, 0.58, 1);
const isEasingArray = (ease2) => {
  return Array.isArray(ease2) && typeof ease2[0] !== "number";
};
const isBezierDefinition = (easing2) => Array.isArray(easing2) && typeof easing2[0] === "number";
const easingLookup = {
  linear: noop$6,
  easeIn,
  easeInOut,
  easeOut,
  circIn,
  circInOut,
  circOut,
  backIn,
  backInOut,
  backOut,
  anticipate
};
const isValidEasing = (easing2) => {
  return typeof easing2 === "string";
};
const easingDefinitionToFunction = (definition) => {
  if (isBezierDefinition(definition)) {
    invariant(definition.length === 4);
    const [x1, y1, x2, y2] = definition;
    return cubicBezier$1(x1, y1, x2, y2);
  } else if (isValidEasing(definition)) {
    invariant(easingLookup[definition] !== void 0);
    return easingLookup[definition];
  }
  return definition;
};
const stepsOrder = [
  "setup",
  // Compute
  "read",
  // Read
  "resolveKeyframes",
  // Write/Read/Write/Read
  "preUpdate",
  // Compute
  "update",
  // Compute
  "preRender",
  // Compute
  "render",
  // Write
  "postRender"
  // Compute
];
const statsBuffer = {
  value: null,
  addProjectionMetrics: null
};
function createRenderStep(runNextFrame, stepName) {
  let thisFrame = /* @__PURE__ */ new Set();
  let nextFrame = /* @__PURE__ */ new Set();
  let isProcessing = false;
  let flushNextFrame = false;
  const toKeepAlive = /* @__PURE__ */ new WeakSet();
  let latestFrameData = {
    delta: 0,
    timestamp: 0,
    isProcessing: false
  };
  let numCalls = 0;
  function triggerCallback(callback) {
    if (toKeepAlive.has(callback)) {
      step.schedule(callback);
      runNextFrame();
    }
    numCalls++;
    callback(latestFrameData);
  }
  const step = {
    /**
     * Schedule a process to run on the next frame.
     */
    schedule: (callback, keepAlive = false, immediate = false) => {
      const addToCurrentFrame = immediate && isProcessing;
      const queue = addToCurrentFrame ? thisFrame : nextFrame;
      if (keepAlive)
        toKeepAlive.add(callback);
      if (!queue.has(callback))
        queue.add(callback);
      return callback;
    },
    /**
     * Cancel the provided callback from running on the next frame.
     */
    cancel: (callback) => {
      nextFrame.delete(callback);
      toKeepAlive.delete(callback);
    },
    /**
     * Execute all schedule callbacks.
     */
    process: (frameData2) => {
      latestFrameData = frameData2;
      if (isProcessing) {
        flushNextFrame = true;
        return;
      }
      isProcessing = true;
      [thisFrame, nextFrame] = [nextFrame, thisFrame];
      thisFrame.forEach(triggerCallback);
      if (stepName && statsBuffer.value) {
        statsBuffer.value.frameloop[stepName].push(numCalls);
      }
      numCalls = 0;
      thisFrame.clear();
      isProcessing = false;
      if (flushNextFrame) {
        flushNextFrame = false;
        step.process(frameData2);
      }
    }
  };
  return step;
}
const maxElapsed = 40;
function createRenderBatcher(scheduleNextBatch, allowKeepAlive) {
  let runNextFrame = false;
  let useDefaultElapsed = true;
  const state = {
    delta: 0,
    timestamp: 0,
    isProcessing: false
  };
  const flagRunNextFrame = () => runNextFrame = true;
  const steps2 = stepsOrder.reduce((acc, key2) => {
    acc[key2] = createRenderStep(flagRunNextFrame, allowKeepAlive ? key2 : void 0);
    return acc;
  }, {});
  const { setup, read, resolveKeyframes, preUpdate, update, preRender, render: render2, postRender } = steps2;
  const processBatch = () => {
    const timestamp = MotionGlobalConfig.useManualTiming ? state.timestamp : performance.now();
    runNextFrame = false;
    if (!MotionGlobalConfig.useManualTiming) {
      state.delta = useDefaultElapsed ? 1e3 / 60 : Math.max(Math.min(timestamp - state.timestamp, maxElapsed), 1);
    }
    state.timestamp = timestamp;
    state.isProcessing = true;
    setup.process(state);
    read.process(state);
    resolveKeyframes.process(state);
    preUpdate.process(state);
    update.process(state);
    preRender.process(state);
    render2.process(state);
    postRender.process(state);
    state.isProcessing = false;
    if (runNextFrame && allowKeepAlive) {
      useDefaultElapsed = false;
      scheduleNextBatch(processBatch);
    }
  };
  const wake = () => {
    runNextFrame = true;
    useDefaultElapsed = true;
    if (!state.isProcessing) {
      scheduleNextBatch(processBatch);
    }
  };
  const schedule = stepsOrder.reduce((acc, key2) => {
    const step = steps2[key2];
    acc[key2] = (process, keepAlive = false, immediate = false) => {
      if (!runNextFrame)
        wake();
      return step.schedule(process, keepAlive, immediate);
    };
    return acc;
  }, {});
  const cancel = (process) => {
    for (let i2 = 0; i2 < stepsOrder.length; i2++) {
      steps2[stepsOrder[i2]].cancel(process);
    }
  };
  return { schedule, cancel, state, steps: steps2 };
}
const { schedule: frame, cancel: cancelFrame, state: frameData, steps: frameSteps } = /* @__PURE__ */ createRenderBatcher(typeof requestAnimationFrame !== "undefined" ? requestAnimationFrame : noop$6, true);
let now$1;
function clearTime() {
  now$1 = void 0;
}
const time = {
  now: () => {
    if (now$1 === void 0) {
      time.set(frameData.isProcessing || MotionGlobalConfig.useManualTiming ? frameData.timestamp : performance.now());
    }
    return now$1;
  },
  set: (newTime) => {
    now$1 = newTime;
    queueMicrotask(clearTime);
  }
};
const checkStringStartsWith = (token2) => (key2) => typeof key2 === "string" && key2.startsWith(token2);
const isCSSVariableName = /* @__PURE__ */ checkStringStartsWith("--");
const startsAsVariableToken = /* @__PURE__ */ checkStringStartsWith("var(--");
const isCSSVariableToken = (value) => {
  const startsWithToken = startsAsVariableToken(value);
  if (!startsWithToken)
    return false;
  return singleCssVariableRegex.test(value.split("/*")[0].trim());
};
const singleCssVariableRegex = /var\(--(?:[\w-]+\s*|[\w-]+\s*,(?:\s*[^)(\s]|\s*\((?:[^)(]|\([^)(]*\))*\))+\s*)\)$/iu;
const number = {
  test: (v2) => typeof v2 === "number",
  parse: parseFloat,
  transform: (v2) => v2
};
const alpha$1 = {
  ...number,
  transform: (v2) => clamp$4(0, 1, v2)
};
const scale = {
  ...number,
  default: 1
};
const sanitize = (v2) => Math.round(v2 * 1e5) / 1e5;
const floatRegex = /-?(?:\d+(?:\.\d+)?|\.\d+)/gu;
function isNullish(v2) {
  return v2 == null;
}
const singleColorRegex = /^(?:#[\da-f]{3,8}|(?:rgb|hsl)a?\((?:-?[\d.]+%?[,\s]+){2}-?[\d.]+%?\s*(?:[,/]\s*)?(?:\b\d+(?:\.\d+)?|\.\d+)?%?\))$/iu;
const isColorString = (type, testProp) => (v2) => {
  return Boolean(typeof v2 === "string" && singleColorRegex.test(v2) && v2.startsWith(type) || testProp && !isNullish(v2) && Object.prototype.hasOwnProperty.call(v2, testProp));
};
const splitColor = (aName, bName, cName) => (v2) => {
  if (typeof v2 !== "string")
    return v2;
  const [a2, b2, c2, alpha2] = v2.match(floatRegex);
  return {
    [aName]: parseFloat(a2),
    [bName]: parseFloat(b2),
    [cName]: parseFloat(c2),
    alpha: alpha2 !== void 0 ? parseFloat(alpha2) : 1
  };
};
const clampRgbUnit = (v2) => clamp$4(0, 255, v2);
const rgbUnit = {
  ...number,
  transform: (v2) => Math.round(clampRgbUnit(v2))
};
const rgba = {
  test: /* @__PURE__ */ isColorString("rgb", "red"),
  parse: /* @__PURE__ */ splitColor("red", "green", "blue"),
  transform: ({ red: red2, green: green2, blue: blue2, alpha: alpha$1$1 = 1 }) => "rgba(" + rgbUnit.transform(red2) + ", " + rgbUnit.transform(green2) + ", " + rgbUnit.transform(blue2) + ", " + sanitize(alpha$1.transform(alpha$1$1)) + ")"
};
function parseHex(v2) {
  let r2 = "";
  let g2 = "";
  let b2 = "";
  let a2 = "";
  if (v2.length > 5) {
    r2 = v2.substring(1, 3);
    g2 = v2.substring(3, 5);
    b2 = v2.substring(5, 7);
    a2 = v2.substring(7, 9);
  } else {
    r2 = v2.substring(1, 2);
    g2 = v2.substring(2, 3);
    b2 = v2.substring(3, 4);
    a2 = v2.substring(4, 5);
    r2 += r2;
    g2 += g2;
    b2 += b2;
    a2 += a2;
  }
  return {
    red: parseInt(r2, 16),
    green: parseInt(g2, 16),
    blue: parseInt(b2, 16),
    alpha: a2 ? parseInt(a2, 16) / 255 : 1
  };
}
const hex = {
  test: /* @__PURE__ */ isColorString("#"),
  parse: parseHex,
  transform: rgba.transform
};
const createUnitType = /* @__NO_SIDE_EFFECTS__ */ (unit) => ({
  test: (v2) => typeof v2 === "string" && v2.endsWith(unit) && v2.split(" ").length === 1,
  parse: parseFloat,
  transform: (v2) => `${v2}${unit}`
});
const degrees = /* @__PURE__ */ createUnitType("deg");
const percent = /* @__PURE__ */ createUnitType("%");
const px = /* @__PURE__ */ createUnitType("px");
const vh = /* @__PURE__ */ createUnitType("vh");
const vw = /* @__PURE__ */ createUnitType("vw");
const progressPercentage = /* @__PURE__ */ (() => ({
  ...percent,
  parse: (v2) => percent.parse(v2) / 100,
  transform: (v2) => percent.transform(v2 * 100)
}))();
const hsla = {
  test: /* @__PURE__ */ isColorString("hsl", "hue"),
  parse: /* @__PURE__ */ splitColor("hue", "saturation", "lightness"),
  transform: ({ hue, saturation, lightness, alpha: alpha$1$1 = 1 }) => {
    return "hsla(" + Math.round(hue) + ", " + percent.transform(sanitize(saturation)) + ", " + percent.transform(sanitize(lightness)) + ", " + sanitize(alpha$1.transform(alpha$1$1)) + ")";
  }
};
const color$1 = {
  test: (v2) => rgba.test(v2) || hex.test(v2) || hsla.test(v2),
  parse: (v2) => {
    if (rgba.test(v2)) {
      return rgba.parse(v2);
    } else if (hsla.test(v2)) {
      return hsla.parse(v2);
    } else {
      return hex.parse(v2);
    }
  },
  transform: (v2) => {
    return typeof v2 === "string" ? v2 : v2.hasOwnProperty("red") ? rgba.transform(v2) : hsla.transform(v2);
  },
  getAnimatableNone: (v2) => {
    const parsed = color$1.parse(v2);
    parsed.alpha = 0;
    return color$1.transform(parsed);
  }
};
const colorRegex = /(?:#[\da-f]{3,8}|(?:rgb|hsl)a?\((?:-?[\d.]+%?[,\s]+){2}-?[\d.]+%?\s*(?:[,/]\s*)?(?:\b\d+(?:\.\d+)?|\.\d+)?%?\))/giu;
function test(v2) {
  return isNaN(v2) && typeof v2 === "string" && (v2.match(floatRegex)?.length || 0) + (v2.match(colorRegex)?.length || 0) > 0;
}
const NUMBER_TOKEN = "number";
const COLOR_TOKEN = "color";
const VAR_TOKEN = "var";
const VAR_FUNCTION_TOKEN = "var(";
const SPLIT_TOKEN = "${}";
const complexRegex = /var\s*\(\s*--(?:[\w-]+\s*|[\w-]+\s*,(?:\s*[^)(\s]|\s*\((?:[^)(]|\([^)(]*\))*\))+\s*)\)|#[\da-f]{3,8}|(?:rgb|hsl)a?\((?:-?[\d.]+%?[,\s]+){2}-?[\d.]+%?\s*(?:[,/]\s*)?(?:\b\d+(?:\.\d+)?|\.\d+)?%?\)|-?(?:\d+(?:\.\d+)?|\.\d+)/giu;
function analyseComplexValue(value) {
  const originalValue = value.toString();
  const values2 = [];
  const indexes = {
    color: [],
    number: [],
    var: []
  };
  const types = [];
  let i2 = 0;
  const tokenised = originalValue.replace(complexRegex, (parsedValue) => {
    if (color$1.test(parsedValue)) {
      indexes.color.push(i2);
      types.push(COLOR_TOKEN);
      values2.push(color$1.parse(parsedValue));
    } else if (parsedValue.startsWith(VAR_FUNCTION_TOKEN)) {
      indexes.var.push(i2);
      types.push(VAR_TOKEN);
      values2.push(parsedValue);
    } else {
      indexes.number.push(i2);
      types.push(NUMBER_TOKEN);
      values2.push(parseFloat(parsedValue));
    }
    ++i2;
    return SPLIT_TOKEN;
  });
  const split = tokenised.split(SPLIT_TOKEN);
  return { values: values2, split, indexes, types };
}
function parseComplexValue(v2) {
  return analyseComplexValue(v2).values;
}
function createTransformer(source) {
  const { split, types } = analyseComplexValue(source);
  const numSections = split.length;
  return (v2) => {
    let output = "";
    for (let i2 = 0; i2 < numSections; i2++) {
      output += split[i2];
      if (v2[i2] !== void 0) {
        const type = types[i2];
        if (type === NUMBER_TOKEN) {
          output += sanitize(v2[i2]);
        } else if (type === COLOR_TOKEN) {
          output += color$1.transform(v2[i2]);
        } else {
          output += v2[i2];
        }
      }
    }
    return output;
  };
}
const convertNumbersToZero = (v2) => typeof v2 === "number" ? 0 : color$1.test(v2) ? color$1.getAnimatableNone(v2) : v2;
function getAnimatableNone$1(v2) {
  const parsed = parseComplexValue(v2);
  const transformer = createTransformer(v2);
  return transformer(parsed.map(convertNumbersToZero));
}
const complex = {
  test,
  parse: parseComplexValue,
  createTransformer,
  getAnimatableNone: getAnimatableNone$1
};
function hueToRgb(p2, q2, t2) {
  if (t2 < 0)
    t2 += 1;
  if (t2 > 1)
    t2 -= 1;
  if (t2 < 1 / 6)
    return p2 + (q2 - p2) * 6 * t2;
  if (t2 < 1 / 2)
    return q2;
  if (t2 < 2 / 3)
    return p2 + (q2 - p2) * (2 / 3 - t2) * 6;
  return p2;
}
function hslaToRgba({ hue, saturation, lightness, alpha: alpha2 }) {
  hue /= 360;
  saturation /= 100;
  lightness /= 100;
  let red2 = 0;
  let green2 = 0;
  let blue2 = 0;
  if (!saturation) {
    red2 = green2 = blue2 = lightness;
  } else {
    const q2 = lightness < 0.5 ? lightness * (1 + saturation) : lightness + saturation - lightness * saturation;
    const p2 = 2 * lightness - q2;
    red2 = hueToRgb(p2, q2, hue + 1 / 3);
    green2 = hueToRgb(p2, q2, hue);
    blue2 = hueToRgb(p2, q2, hue - 1 / 3);
  }
  return {
    red: Math.round(red2 * 255),
    green: Math.round(green2 * 255),
    blue: Math.round(blue2 * 255),
    alpha: alpha2
  };
}
function mixImmediate(a2, b2) {
  return (p2) => p2 > 0 ? b2 : a2;
}
const mixNumber$1 = (from2, to, progress2) => {
  return from2 + (to - from2) * progress2;
};
const mixLinearColor = (from2, to, v2) => {
  const fromExpo = from2 * from2;
  const expo = v2 * (to * to - fromExpo) + fromExpo;
  return expo < 0 ? 0 : Math.sqrt(expo);
};
const colorTypes = [hex, rgba, hsla];
const getColorType = (v2) => colorTypes.find((type) => type.test(v2));
function asRGBA(color2) {
  const type = getColorType(color2);
  if (!Boolean(type))
    return false;
  let model = type.parse(color2);
  if (type === hsla) {
    model = hslaToRgba(model);
  }
  return model;
}
const mixColor = (from2, to) => {
  const fromRGBA = asRGBA(from2);
  const toRGBA = asRGBA(to);
  if (!fromRGBA || !toRGBA) {
    return mixImmediate(from2, to);
  }
  const blended = { ...fromRGBA };
  return (v2) => {
    blended.red = mixLinearColor(fromRGBA.red, toRGBA.red, v2);
    blended.green = mixLinearColor(fromRGBA.green, toRGBA.green, v2);
    blended.blue = mixLinearColor(fromRGBA.blue, toRGBA.blue, v2);
    blended.alpha = mixNumber$1(fromRGBA.alpha, toRGBA.alpha, v2);
    return rgba.transform(blended);
  };
};
const invisibleValues = /* @__PURE__ */ new Set(["none", "hidden"]);
function mixVisibility(origin, target) {
  if (invisibleValues.has(origin)) {
    return (p2) => p2 <= 0 ? origin : target;
  } else {
    return (p2) => p2 >= 1 ? target : origin;
  }
}
function mixNumber(a2, b2) {
  return (p2) => mixNumber$1(a2, b2, p2);
}
function getMixer(a2) {
  if (typeof a2 === "number") {
    return mixNumber;
  } else if (typeof a2 === "string") {
    return isCSSVariableToken(a2) ? mixImmediate : color$1.test(a2) ? mixColor : mixComplex;
  } else if (Array.isArray(a2)) {
    return mixArray;
  } else if (typeof a2 === "object") {
    return color$1.test(a2) ? mixColor : mixObject;
  }
  return mixImmediate;
}
function mixArray(a2, b2) {
  const output = [...a2];
  const numValues = output.length;
  const blendValue = a2.map((v2, i2) => getMixer(v2)(v2, b2[i2]));
  return (p2) => {
    for (let i2 = 0; i2 < numValues; i2++) {
      output[i2] = blendValue[i2](p2);
    }
    return output;
  };
}
function mixObject(a2, b2) {
  const output = { ...a2, ...b2 };
  const blendValue = {};
  for (const key2 in output) {
    if (a2[key2] !== void 0 && b2[key2] !== void 0) {
      blendValue[key2] = getMixer(a2[key2])(a2[key2], b2[key2]);
    }
  }
  return (v2) => {
    for (const key2 in blendValue) {
      output[key2] = blendValue[key2](v2);
    }
    return output;
  };
}
function matchOrder(origin, target) {
  const orderedOrigin = [];
  const pointers = { color: 0, var: 0, number: 0 };
  for (let i2 = 0; i2 < target.values.length; i2++) {
    const type = target.types[i2];
    const originIndex = origin.indexes[type][pointers[type]];
    const originValue = origin.values[originIndex] ?? 0;
    orderedOrigin[i2] = originValue;
    pointers[type]++;
  }
  return orderedOrigin;
}
const mixComplex = (origin, target) => {
  const template = complex.createTransformer(target);
  const originStats = analyseComplexValue(origin);
  const targetStats = analyseComplexValue(target);
  const canInterpolate = originStats.indexes.var.length === targetStats.indexes.var.length && originStats.indexes.color.length === targetStats.indexes.color.length && originStats.indexes.number.length >= targetStats.indexes.number.length;
  if (canInterpolate) {
    if (invisibleValues.has(origin) && !targetStats.values.length || invisibleValues.has(target) && !originStats.values.length) {
      return mixVisibility(origin, target);
    }
    return pipe(mixArray(matchOrder(originStats, targetStats), targetStats.values), template);
  } else {
    return mixImmediate(origin, target);
  }
};
function mix(from2, to, p2) {
  if (typeof from2 === "number" && typeof to === "number" && typeof p2 === "number") {
    return mixNumber$1(from2, to, p2);
  }
  const mixer = getMixer(from2);
  return mixer(from2, to);
}
const frameloopDriver = (update) => {
  const passTimestamp = ({ timestamp }) => update(timestamp);
  return {
    start: (keepAlive = true) => frame.update(passTimestamp, keepAlive),
    stop: () => cancelFrame(passTimestamp),
    /**
     * If we're processing this frame we can use the
     * framelocked timestamp to keep things in sync.
     */
    now: () => frameData.isProcessing ? frameData.timestamp : time.now()
  };
};
const generateLinearEasing = (easing2, duration2, resolution = 10) => {
  let points = "";
  const numPoints = Math.max(Math.round(duration2 / resolution), 2);
  for (let i2 = 0; i2 < numPoints; i2++) {
    points += Math.round(easing2(i2 / (numPoints - 1)) * 1e4) / 1e4 + ", ";
  }
  return `linear(${points.substring(0, points.length - 2)})`;
};
const maxGeneratorDuration = 2e4;
function calcGeneratorDuration(generator) {
  let duration2 = 0;
  const timeStep = 50;
  let state = generator.next(duration2);
  while (!state.done && duration2 < maxGeneratorDuration) {
    duration2 += timeStep;
    state = generator.next(duration2);
  }
  return duration2 >= maxGeneratorDuration ? Infinity : duration2;
}
function createGeneratorEasing(options, scale2 = 100, createGenerator) {
  const generator = createGenerator({ ...options, keyframes: [0, scale2] });
  const duration2 = Math.min(calcGeneratorDuration(generator), maxGeneratorDuration);
  return {
    type: "keyframes",
    ease: (progress2) => {
      return generator.next(duration2 * progress2).value / scale2;
    },
    duration: /* @__PURE__ */ millisecondsToSeconds(duration2)
  };
}
const velocitySampleDuration = 5;
function calcGeneratorVelocity(resolveValue, t2, current) {
  const prevT = Math.max(t2 - velocitySampleDuration, 0);
  return velocityPerSecond(current - resolveValue(prevT), t2 - prevT);
}
const springDefaults = {
  // Default spring physics
  stiffness: 100,
  damping: 10,
  mass: 1,
  velocity: 0,
  // Default duration/bounce-based options
  duration: 800,
  // in ms
  bounce: 0.3,
  visualDuration: 0.3,
  // in seconds
  // Rest thresholds
  restSpeed: {
    granular: 0.01,
    default: 2
  },
  restDelta: {
    granular: 5e-3,
    default: 0.5
  },
  // Limits
  minDuration: 0.01,
  // in seconds
  maxDuration: 10,
  // in seconds
  minDamping: 0.05,
  maxDamping: 1
};
const safeMin = 1e-3;
function findSpring({ duration: duration2 = springDefaults.duration, bounce = springDefaults.bounce, velocity = springDefaults.velocity, mass = springDefaults.mass }) {
  let envelope;
  let derivative;
  let dampingRatio = 1 - bounce;
  dampingRatio = clamp$4(springDefaults.minDamping, springDefaults.maxDamping, dampingRatio);
  duration2 = clamp$4(springDefaults.minDuration, springDefaults.maxDuration, /* @__PURE__ */ millisecondsToSeconds(duration2));
  if (dampingRatio < 1) {
    envelope = (undampedFreq2) => {
      const exponentialDecay = undampedFreq2 * dampingRatio;
      const delta = exponentialDecay * duration2;
      const a2 = exponentialDecay - velocity;
      const b2 = calcAngularFreq(undampedFreq2, dampingRatio);
      const c2 = Math.exp(-delta);
      return safeMin - a2 / b2 * c2;
    };
    derivative = (undampedFreq2) => {
      const exponentialDecay = undampedFreq2 * dampingRatio;
      const delta = exponentialDecay * duration2;
      const d2 = delta * velocity + velocity;
      const e2 = Math.pow(dampingRatio, 2) * Math.pow(undampedFreq2, 2) * duration2;
      const f2 = Math.exp(-delta);
      const g2 = calcAngularFreq(Math.pow(undampedFreq2, 2), dampingRatio);
      const factor = -envelope(undampedFreq2) + safeMin > 0 ? -1 : 1;
      return factor * ((d2 - e2) * f2) / g2;
    };
  } else {
    envelope = (undampedFreq2) => {
      const a2 = Math.exp(-undampedFreq2 * duration2);
      const b2 = (undampedFreq2 - velocity) * duration2 + 1;
      return -safeMin + a2 * b2;
    };
    derivative = (undampedFreq2) => {
      const a2 = Math.exp(-undampedFreq2 * duration2);
      const b2 = (velocity - undampedFreq2) * (duration2 * duration2);
      return a2 * b2;
    };
  }
  const initialGuess = 5 / duration2;
  const undampedFreq = approximateRoot(envelope, derivative, initialGuess);
  duration2 = /* @__PURE__ */ secondsToMilliseconds(duration2);
  if (isNaN(undampedFreq)) {
    return {
      stiffness: springDefaults.stiffness,
      damping: springDefaults.damping,
      duration: duration2
    };
  } else {
    const stiffness = Math.pow(undampedFreq, 2) * mass;
    return {
      stiffness,
      damping: dampingRatio * 2 * Math.sqrt(mass * stiffness),
      duration: duration2
    };
  }
}
const rootIterations = 12;
function approximateRoot(envelope, derivative, initialGuess) {
  let result = initialGuess;
  for (let i2 = 1; i2 < rootIterations; i2++) {
    result = result - envelope(result) / derivative(result);
  }
  return result;
}
function calcAngularFreq(undampedFreq, dampingRatio) {
  return undampedFreq * Math.sqrt(1 - dampingRatio * dampingRatio);
}
const durationKeys = ["duration", "bounce"];
const physicsKeys = ["stiffness", "damping", "mass"];
function isSpringType(options, keys) {
  return keys.some((key2) => options[key2] !== void 0);
}
function getSpringOptions(options) {
  let springOptions = {
    velocity: springDefaults.velocity,
    stiffness: springDefaults.stiffness,
    damping: springDefaults.damping,
    mass: springDefaults.mass,
    isResolvedFromDuration: false,
    ...options
  };
  if (!isSpringType(options, physicsKeys) && isSpringType(options, durationKeys)) {
    if (options.visualDuration) {
      const visualDuration = options.visualDuration;
      const root = 2 * Math.PI / (visualDuration * 1.2);
      const stiffness = root * root;
      const damping = 2 * clamp$4(0.05, 1, 1 - (options.bounce || 0)) * Math.sqrt(stiffness);
      springOptions = {
        ...springOptions,
        mass: springDefaults.mass,
        stiffness,
        damping
      };
    } else {
      const derived = findSpring(options);
      springOptions = {
        ...springOptions,
        ...derived,
        mass: springDefaults.mass
      };
      springOptions.isResolvedFromDuration = true;
    }
  }
  return springOptions;
}
function spring(optionsOrVisualDuration = springDefaults.visualDuration, bounce = springDefaults.bounce) {
  const options = typeof optionsOrVisualDuration !== "object" ? {
    visualDuration: optionsOrVisualDuration,
    keyframes: [0, 1],
    bounce
  } : optionsOrVisualDuration;
  let { restSpeed, restDelta } = options;
  const origin = options.keyframes[0];
  const target = options.keyframes[options.keyframes.length - 1];
  const state = { done: false, value: origin };
  const { stiffness, damping, mass, duration: duration2, velocity, isResolvedFromDuration } = getSpringOptions({
    ...options,
    velocity: -/* @__PURE__ */ millisecondsToSeconds(options.velocity || 0)
  });
  const initialVelocity = velocity || 0;
  const dampingRatio = damping / (2 * Math.sqrt(stiffness * mass));
  const initialDelta = target - origin;
  const undampedAngularFreq = /* @__PURE__ */ millisecondsToSeconds(Math.sqrt(stiffness / mass));
  const isGranularScale = Math.abs(initialDelta) < 5;
  restSpeed || (restSpeed = isGranularScale ? springDefaults.restSpeed.granular : springDefaults.restSpeed.default);
  restDelta || (restDelta = isGranularScale ? springDefaults.restDelta.granular : springDefaults.restDelta.default);
  let resolveSpring;
  if (dampingRatio < 1) {
    const angularFreq = calcAngularFreq(undampedAngularFreq, dampingRatio);
    resolveSpring = (t2) => {
      const envelope = Math.exp(-dampingRatio * undampedAngularFreq * t2);
      return target - envelope * ((initialVelocity + dampingRatio * undampedAngularFreq * initialDelta) / angularFreq * Math.sin(angularFreq * t2) + initialDelta * Math.cos(angularFreq * t2));
    };
  } else if (dampingRatio === 1) {
    resolveSpring = (t2) => target - Math.exp(-undampedAngularFreq * t2) * (initialDelta + (initialVelocity + undampedAngularFreq * initialDelta) * t2);
  } else {
    const dampedAngularFreq = undampedAngularFreq * Math.sqrt(dampingRatio * dampingRatio - 1);
    resolveSpring = (t2) => {
      const envelope = Math.exp(-dampingRatio * undampedAngularFreq * t2);
      const freqForT = Math.min(dampedAngularFreq * t2, 300);
      return target - envelope * ((initialVelocity + dampingRatio * undampedAngularFreq * initialDelta) * Math.sinh(freqForT) + dampedAngularFreq * initialDelta * Math.cosh(freqForT)) / dampedAngularFreq;
    };
  }
  const generator = {
    calculatedDuration: isResolvedFromDuration ? duration2 || null : null,
    next: (t2) => {
      const current = resolveSpring(t2);
      if (!isResolvedFromDuration) {
        let currentVelocity = t2 === 0 ? initialVelocity : 0;
        if (dampingRatio < 1) {
          currentVelocity = t2 === 0 ? /* @__PURE__ */ secondsToMilliseconds(initialVelocity) : calcGeneratorVelocity(resolveSpring, t2, current);
        }
        const isBelowVelocityThreshold = Math.abs(currentVelocity) <= restSpeed;
        const isBelowDisplacementThreshold = Math.abs(target - current) <= restDelta;
        state.done = isBelowVelocityThreshold && isBelowDisplacementThreshold;
      } else {
        state.done = t2 >= duration2;
      }
      state.value = state.done ? target : current;
      return state;
    },
    toString: () => {
      const calculatedDuration = Math.min(calcGeneratorDuration(generator), maxGeneratorDuration);
      const easing2 = generateLinearEasing((progress2) => generator.next(calculatedDuration * progress2).value, calculatedDuration, 30);
      return calculatedDuration + "ms " + easing2;
    },
    toTransition: () => {
    }
  };
  return generator;
}
spring.applyToOptions = (options) => {
  const generatorOptions = createGeneratorEasing(options, 100, spring);
  options.ease = generatorOptions.ease;
  options.duration = /* @__PURE__ */ secondsToMilliseconds(generatorOptions.duration);
  options.type = "keyframes";
  return options;
};
function inertia({ keyframes: keyframes2, velocity = 0, power = 0.8, timeConstant = 325, bounceDamping = 10, bounceStiffness = 500, modifyTarget, min: min2, max: max2, restDelta = 0.5, restSpeed }) {
  const origin = keyframes2[0];
  const state = {
    done: false,
    value: origin
  };
  const isOutOfBounds = (v2) => min2 !== void 0 && v2 < min2 || max2 !== void 0 && v2 > max2;
  const nearestBoundary = (v2) => {
    if (min2 === void 0)
      return max2;
    if (max2 === void 0)
      return min2;
    return Math.abs(min2 - v2) < Math.abs(max2 - v2) ? min2 : max2;
  };
  let amplitude = power * velocity;
  const ideal = origin + amplitude;
  const target = modifyTarget === void 0 ? ideal : modifyTarget(ideal);
  if (target !== ideal)
    amplitude = target - origin;
  const calcDelta = (t2) => -amplitude * Math.exp(-t2 / timeConstant);
  const calcLatest = (t2) => target + calcDelta(t2);
  const applyFriction = (t2) => {
    const delta = calcDelta(t2);
    const latest = calcLatest(t2);
    state.done = Math.abs(delta) <= restDelta;
    state.value = state.done ? target : latest;
  };
  let timeReachedBoundary;
  let spring$1;
  const checkCatchBoundary = (t2) => {
    if (!isOutOfBounds(state.value))
      return;
    timeReachedBoundary = t2;
    spring$1 = spring({
      keyframes: [state.value, nearestBoundary(state.value)],
      velocity: calcGeneratorVelocity(calcLatest, t2, state.value),
      // TODO: This should be passing * 1000
      damping: bounceDamping,
      stiffness: bounceStiffness,
      restDelta,
      restSpeed
    });
  };
  checkCatchBoundary(0);
  return {
    calculatedDuration: null,
    next: (t2) => {
      let hasUpdatedFrame = false;
      if (!spring$1 && timeReachedBoundary === void 0) {
        hasUpdatedFrame = true;
        applyFriction(t2);
        checkCatchBoundary(t2);
      }
      if (timeReachedBoundary !== void 0 && t2 >= timeReachedBoundary) {
        return spring$1.next(t2 - timeReachedBoundary);
      } else {
        !hasUpdatedFrame && applyFriction(t2);
        return state;
      }
    }
  };
}
function createMixers(output, ease2, customMixer) {
  const mixers = [];
  const mixerFactory = customMixer || MotionGlobalConfig.mix || mix;
  const numMixers = output.length - 1;
  for (let i2 = 0; i2 < numMixers; i2++) {
    let mixer = mixerFactory(output[i2], output[i2 + 1]);
    if (ease2) {
      const easingFunction = Array.isArray(ease2) ? ease2[i2] || noop$6 : ease2;
      mixer = pipe(easingFunction, mixer);
    }
    mixers.push(mixer);
  }
  return mixers;
}
function interpolate$2(input, output, { clamp: isClamp = true, ease: ease2, mixer } = {}) {
  const inputLength = input.length;
  invariant(inputLength === output.length);
  if (inputLength === 1)
    return () => output[0];
  if (inputLength === 2 && output[0] === output[1])
    return () => output[1];
  const isZeroDeltaRange = input[0] === input[1];
  if (input[0] > input[inputLength - 1]) {
    input = [...input].reverse();
    output = [...output].reverse();
  }
  const mixers = createMixers(output, ease2, mixer);
  const numMixers = mixers.length;
  const interpolator = (v2) => {
    if (isZeroDeltaRange && v2 < input[0])
      return output[0];
    let i2 = 0;
    if (numMixers > 1) {
      for (; i2 < input.length - 2; i2++) {
        if (v2 < input[i2 + 1])
          break;
      }
    }
    const progressInRange = /* @__PURE__ */ progress(input[i2], input[i2 + 1], v2);
    return mixers[i2](progressInRange);
  };
  return isClamp ? (v2) => interpolator(clamp$4(input[0], input[inputLength - 1], v2)) : interpolator;
}
function fillOffset(offset2, remaining) {
  const min2 = offset2[offset2.length - 1];
  for (let i2 = 1; i2 <= remaining; i2++) {
    const offsetProgress = /* @__PURE__ */ progress(0, remaining, i2);
    offset2.push(mixNumber$1(min2, 1, offsetProgress));
  }
}
function defaultOffset(arr) {
  const offset2 = [0];
  fillOffset(offset2, arr.length - 1);
  return offset2;
}
function convertOffsetToTimes(offset2, duration2) {
  return offset2.map((o) => o * duration2);
}
function defaultEasing(values2, easing2) {
  return values2.map(() => easing2 || easeInOut).splice(0, values2.length - 1);
}
function keyframes$2({ duration: duration2 = 300, keyframes: keyframeValues, times, ease: ease2 = "easeInOut" }) {
  const easingFunctions = isEasingArray(ease2) ? ease2.map(easingDefinitionToFunction) : easingDefinitionToFunction(ease2);
  const state = {
    done: false,
    value: keyframeValues[0]
  };
  const absoluteTimes = convertOffsetToTimes(
    // Only use the provided offsets if they're the correct length
    // TODO Maybe we should warn here if there's a length mismatch
    times && times.length === keyframeValues.length ? times : defaultOffset(keyframeValues),
    duration2
  );
  const mapTimeToKeyframe = interpolate$2(absoluteTimes, keyframeValues, {
    ease: Array.isArray(easingFunctions) ? easingFunctions : defaultEasing(keyframeValues, easingFunctions)
  });
  return {
    calculatedDuration: duration2,
    next: (t2) => {
      state.value = mapTimeToKeyframe(t2);
      state.done = t2 >= duration2;
      return state;
    }
  };
}
const isNotNull$2 = (value) => value !== null;
function getFinalKeyframe$1(keyframes2, { repeat, repeatType = "loop" }, finalKeyframe, speed = 1) {
  const resolvedKeyframes = keyframes2.filter(isNotNull$2);
  const useFirstKeyframe = speed < 0 || repeat && repeatType !== "loop" && repeat % 2 === 1;
  const index2 = useFirstKeyframe ? 0 : resolvedKeyframes.length - 1;
  return !index2 || finalKeyframe === void 0 ? resolvedKeyframes[index2] : finalKeyframe;
}
const transitionTypeMap = {
  decay: inertia,
  inertia,
  tween: keyframes$2,
  keyframes: keyframes$2,
  spring
};
function replaceTransitionType(transition) {
  if (typeof transition.type === "string") {
    transition.type = transitionTypeMap[transition.type];
  }
}
class WithPromise {
  constructor() {
    this.updateFinished();
  }
  get finished() {
    return this._finished;
  }
  updateFinished() {
    this._finished = new Promise((resolve) => {
      this.resolve = resolve;
    });
  }
  notifyFinished() {
    this.resolve();
  }
  /**
   * Allows the animation to be awaited.
   *
   * @deprecated Use `finished` instead.
   */
  then(onResolve, onReject) {
    return this.finished.then(onResolve, onReject);
  }
}
const percentToProgress = (percent2) => percent2 / 100;
let JSAnimation$1 = class JSAnimation extends WithPromise {
  constructor(options) {
    super();
    this.state = "idle";
    this.startTime = null;
    this.isStopped = false;
    this.currentTime = 0;
    this.holdTime = null;
    this.playbackSpeed = 1;
    this.stop = () => {
      const { motionValue: motionValue2 } = this.options;
      if (motionValue2 && motionValue2.updatedAt !== time.now()) {
        this.tick(time.now());
      }
      this.isStopped = true;
      if (this.state === "idle")
        return;
      this.teardown();
      this.options.onStop?.();
    };
    this.options = options;
    this.initAnimation();
    this.play();
    if (options.autoplay === false)
      this.pause();
  }
  initAnimation() {
    const { options } = this;
    replaceTransitionType(options);
    const { type = keyframes$2, repeat = 0, repeatDelay = 0, repeatType, velocity = 0 } = options;
    let { keyframes: keyframes$12 } = options;
    const generatorFactory = type || keyframes$2;
    if (generatorFactory !== keyframes$2 && typeof keyframes$12[0] !== "number") {
      this.mixKeyframes = pipe(percentToProgress, mix(keyframes$12[0], keyframes$12[1]));
      keyframes$12 = [0, 100];
    }
    const generator = generatorFactory({ ...options, keyframes: keyframes$12 });
    if (repeatType === "mirror") {
      this.mirroredGenerator = generatorFactory({
        ...options,
        keyframes: [...keyframes$12].reverse(),
        velocity: -velocity
      });
    }
    if (generator.calculatedDuration === null) {
      generator.calculatedDuration = calcGeneratorDuration(generator);
    }
    const { calculatedDuration } = generator;
    this.calculatedDuration = calculatedDuration;
    this.resolvedDuration = calculatedDuration + repeatDelay;
    this.totalDuration = this.resolvedDuration * (repeat + 1) - repeatDelay;
    this.generator = generator;
  }
  updateTime(timestamp) {
    const animationTime = Math.round(timestamp - this.startTime) * this.playbackSpeed;
    if (this.holdTime !== null) {
      this.currentTime = this.holdTime;
    } else {
      this.currentTime = animationTime;
    }
  }
  tick(timestamp, sample = false) {
    const { generator, totalDuration, mixKeyframes, mirroredGenerator, resolvedDuration, calculatedDuration } = this;
    if (this.startTime === null)
      return generator.next(0);
    const { delay: delay2 = 0, keyframes: keyframes2, repeat, repeatType, repeatDelay, type, onUpdate, finalKeyframe } = this.options;
    if (this.speed > 0) {
      this.startTime = Math.min(this.startTime, timestamp);
    } else if (this.speed < 0) {
      this.startTime = Math.min(timestamp - totalDuration / this.speed, this.startTime);
    }
    if (sample) {
      this.currentTime = timestamp;
    } else {
      this.updateTime(timestamp);
    }
    const timeWithoutDelay = this.currentTime - delay2 * (this.playbackSpeed >= 0 ? 1 : -1);
    const isInDelayPhase = this.playbackSpeed >= 0 ? timeWithoutDelay < 0 : timeWithoutDelay > totalDuration;
    this.currentTime = Math.max(timeWithoutDelay, 0);
    if (this.state === "finished" && this.holdTime === null) {
      this.currentTime = totalDuration;
    }
    let elapsed = this.currentTime;
    let frameGenerator = generator;
    if (repeat) {
      const progress2 = Math.min(this.currentTime, totalDuration) / resolvedDuration;
      let currentIteration = Math.floor(progress2);
      let iterationProgress = progress2 % 1;
      if (!iterationProgress && progress2 >= 1) {
        iterationProgress = 1;
      }
      iterationProgress === 1 && currentIteration--;
      currentIteration = Math.min(currentIteration, repeat + 1);
      const isOddIteration = Boolean(currentIteration % 2);
      if (isOddIteration) {
        if (repeatType === "reverse") {
          iterationProgress = 1 - iterationProgress;
          if (repeatDelay) {
            iterationProgress -= repeatDelay / resolvedDuration;
          }
        } else if (repeatType === "mirror") {
          frameGenerator = mirroredGenerator;
        }
      }
      elapsed = clamp$4(0, 1, iterationProgress) * resolvedDuration;
    }
    const state = isInDelayPhase ? { done: false, value: keyframes2[0] } : frameGenerator.next(elapsed);
    if (mixKeyframes) {
      state.value = mixKeyframes(state.value);
    }
    let { done } = state;
    if (!isInDelayPhase && calculatedDuration !== null) {
      done = this.playbackSpeed >= 0 ? this.currentTime >= totalDuration : this.currentTime <= 0;
    }
    const isAnimationFinished = this.holdTime === null && (this.state === "finished" || this.state === "running" && done);
    if (isAnimationFinished && type !== inertia) {
      state.value = getFinalKeyframe$1(keyframes2, this.options, finalKeyframe, this.speed);
    }
    if (onUpdate) {
      onUpdate(state.value);
    }
    if (isAnimationFinished) {
      this.finish();
    }
    return state;
  }
  /**
   * Allows the returned animation to be awaited or promise-chained. Currently
   * resolves when the animation finishes at all but in a future update could/should
   * reject if its cancels.
   */
  then(resolve, reject) {
    return this.finished.then(resolve, reject);
  }
  get duration() {
    return /* @__PURE__ */ millisecondsToSeconds(this.calculatedDuration);
  }
  get time() {
    return /* @__PURE__ */ millisecondsToSeconds(this.currentTime);
  }
  set time(newTime) {
    newTime = /* @__PURE__ */ secondsToMilliseconds(newTime);
    this.currentTime = newTime;
    if (this.startTime === null || this.holdTime !== null || this.playbackSpeed === 0) {
      this.holdTime = newTime;
    } else if (this.driver) {
      this.startTime = this.driver.now() - newTime / this.playbackSpeed;
    }
    this.driver?.start(false);
  }
  get speed() {
    return this.playbackSpeed;
  }
  set speed(newSpeed) {
    this.updateTime(time.now());
    const hasChanged = this.playbackSpeed !== newSpeed;
    this.playbackSpeed = newSpeed;
    if (hasChanged) {
      this.time = /* @__PURE__ */ millisecondsToSeconds(this.currentTime);
    }
  }
  play() {
    if (this.isStopped)
      return;
    const { driver = frameloopDriver, startTime } = this.options;
    if (!this.driver) {
      this.driver = driver((timestamp) => this.tick(timestamp));
    }
    this.options.onPlay?.();
    const now2 = this.driver.now();
    if (this.state === "finished") {
      this.updateFinished();
      this.startTime = now2;
    } else if (this.holdTime !== null) {
      this.startTime = now2 - this.holdTime;
    } else if (!this.startTime) {
      this.startTime = startTime ?? now2;
    }
    if (this.state === "finished" && this.speed < 0) {
      this.startTime += this.calculatedDuration;
    }
    this.holdTime = null;
    this.state = "running";
    this.driver.start();
  }
  pause() {
    this.state = "paused";
    this.updateTime(time.now());
    this.holdTime = this.currentTime;
  }
  complete() {
    if (this.state !== "running") {
      this.play();
    }
    this.state = "finished";
    this.holdTime = null;
  }
  finish() {
    this.notifyFinished();
    this.teardown();
    this.state = "finished";
    this.options.onComplete?.();
  }
  cancel() {
    this.holdTime = null;
    this.startTime = 0;
    this.tick(0);
    this.teardown();
    this.options.onCancel?.();
  }
  teardown() {
    this.state = "idle";
    this.stopDriver();
    this.startTime = this.holdTime = null;
  }
  stopDriver() {
    if (!this.driver)
      return;
    this.driver.stop();
    this.driver = void 0;
  }
  sample(sampleTime) {
    this.startTime = 0;
    return this.tick(sampleTime, true);
  }
  attachTimeline(timeline) {
    if (this.options.allowFlatten) {
      this.options.type = "keyframes";
      this.options.ease = "linear";
      this.initAnimation();
    }
    this.driver?.stop();
    return timeline.observe(this);
  }
};
function fillWildcards(keyframes2) {
  for (let i2 = 1; i2 < keyframes2.length; i2++) {
    keyframes2[i2] ?? (keyframes2[i2] = keyframes2[i2 - 1]);
  }
}
const radToDeg = (rad) => rad * 180 / Math.PI;
const rotate = (v2) => {
  const angle2 = radToDeg(Math.atan2(v2[1], v2[0]));
  return rebaseAngle(angle2);
};
const matrix2dParsers = {
  x: 4,
  y: 5,
  translateX: 4,
  translateY: 5,
  scaleX: 0,
  scaleY: 3,
  scale: (v2) => (Math.abs(v2[0]) + Math.abs(v2[3])) / 2,
  rotate,
  rotateZ: rotate,
  skewX: (v2) => radToDeg(Math.atan(v2[1])),
  skewY: (v2) => radToDeg(Math.atan(v2[2])),
  skew: (v2) => (Math.abs(v2[1]) + Math.abs(v2[2])) / 2
};
const rebaseAngle = (angle2) => {
  angle2 = angle2 % 360;
  if (angle2 < 0)
    angle2 += 360;
  return angle2;
};
const rotateZ = rotate;
const scaleX = (v2) => Math.sqrt(v2[0] * v2[0] + v2[1] * v2[1]);
const scaleY = (v2) => Math.sqrt(v2[4] * v2[4] + v2[5] * v2[5]);
const matrix3dParsers = {
  x: 12,
  y: 13,
  z: 14,
  translateX: 12,
  translateY: 13,
  translateZ: 14,
  scaleX,
  scaleY,
  scale: (v2) => (scaleX(v2) + scaleY(v2)) / 2,
  rotateX: (v2) => rebaseAngle(radToDeg(Math.atan2(v2[6], v2[5]))),
  rotateY: (v2) => rebaseAngle(radToDeg(Math.atan2(-v2[2], v2[0]))),
  rotateZ,
  rotate: rotateZ,
  skewX: (v2) => radToDeg(Math.atan(v2[4])),
  skewY: (v2) => radToDeg(Math.atan(v2[1])),
  skew: (v2) => (Math.abs(v2[1]) + Math.abs(v2[4])) / 2
};
function defaultTransformValue(name) {
  return name.includes("scale") ? 1 : 0;
}
function parseValueFromTransform(transform2, name) {
  if (!transform2 || transform2 === "none") {
    return defaultTransformValue(name);
  }
  const matrix3dMatch = transform2.match(/^matrix3d\(([-\d.e\s,]+)\)$/u);
  let parsers;
  let match2;
  if (matrix3dMatch) {
    parsers = matrix3dParsers;
    match2 = matrix3dMatch;
  } else {
    const matrix2dMatch = transform2.match(/^matrix\(([-\d.e\s,]+)\)$/u);
    parsers = matrix2dParsers;
    match2 = matrix2dMatch;
  }
  if (!match2) {
    return defaultTransformValue(name);
  }
  const valueParser = parsers[name];
  const values2 = match2[1].split(",").map(convertTransformToNumber);
  return typeof valueParser === "function" ? valueParser(values2) : values2[valueParser];
}
const readTransformValue = (instance, name) => {
  const { transform: transform2 = "none" } = getComputedStyle(instance);
  return parseValueFromTransform(transform2, name);
};
function convertTransformToNumber(value) {
  return parseFloat(value.trim());
}
const transformPropOrder = [
  "transformPerspective",
  "x",
  "y",
  "z",
  "translateX",
  "translateY",
  "translateZ",
  "scale",
  "scaleX",
  "scaleY",
  "rotate",
  "rotateX",
  "rotateY",
  "rotateZ",
  "skew",
  "skewX",
  "skewY"
];
const transformProps = /* @__PURE__ */ (() => new Set(transformPropOrder))();
const isNumOrPxType = (v2) => v2 === number || v2 === px;
const transformKeys = /* @__PURE__ */ new Set(["x", "y", "z"]);
const nonTranslationalTransformKeys = transformPropOrder.filter((key2) => !transformKeys.has(key2));
function removeNonTranslationalTransform(visualElement) {
  const removedTransforms = [];
  nonTranslationalTransformKeys.forEach((key2) => {
    const value = visualElement.getValue(key2);
    if (value !== void 0) {
      removedTransforms.push([key2, value.get()]);
      value.set(key2.startsWith("scale") ? 1 : 0);
    }
  });
  return removedTransforms;
}
const positionalValues = {
  // Dimensions
  width: ({ x: x2 }, { paddingLeft = "0", paddingRight = "0" }) => x2.max - x2.min - parseFloat(paddingLeft) - parseFloat(paddingRight),
  height: ({ y: y2 }, { paddingTop = "0", paddingBottom = "0" }) => y2.max - y2.min - parseFloat(paddingTop) - parseFloat(paddingBottom),
  top: (_bbox, { top }) => parseFloat(top),
  left: (_bbox, { left }) => parseFloat(left),
  bottom: ({ y: y2 }, { top }) => parseFloat(top) + (y2.max - y2.min),
  right: ({ x: x2 }, { left }) => parseFloat(left) + (x2.max - x2.min),
  // Transform
  x: (_bbox, { transform: transform2 }) => parseValueFromTransform(transform2, "x"),
  y: (_bbox, { transform: transform2 }) => parseValueFromTransform(transform2, "y")
};
positionalValues.translateX = positionalValues.x;
positionalValues.translateY = positionalValues.y;
const toResolve = /* @__PURE__ */ new Set();
let isScheduled = false;
let anyNeedsMeasurement = false;
let isForced = false;
function measureAllKeyframes() {
  if (anyNeedsMeasurement) {
    const resolversToMeasure = Array.from(toResolve).filter((resolver) => resolver.needsMeasurement);
    const elementsToMeasure = new Set(resolversToMeasure.map((resolver) => resolver.element));
    const transformsToRestore = /* @__PURE__ */ new Map();
    elementsToMeasure.forEach((element) => {
      const removedTransforms = removeNonTranslationalTransform(element);
      if (!removedTransforms.length)
        return;
      transformsToRestore.set(element, removedTransforms);
      element.render();
    });
    resolversToMeasure.forEach((resolver) => resolver.measureInitialState());
    elementsToMeasure.forEach((element) => {
      element.render();
      const restore = transformsToRestore.get(element);
      if (restore) {
        restore.forEach(([key2, value]) => {
          element.getValue(key2)?.set(value);
        });
      }
    });
    resolversToMeasure.forEach((resolver) => resolver.measureEndState());
    resolversToMeasure.forEach((resolver) => {
      if (resolver.suspendedScrollY !== void 0) {
        window.scrollTo(0, resolver.suspendedScrollY);
      }
    });
  }
  anyNeedsMeasurement = false;
  isScheduled = false;
  toResolve.forEach((resolver) => resolver.complete(isForced));
  toResolve.clear();
}
function readAllKeyframes() {
  toResolve.forEach((resolver) => {
    resolver.readKeyframes();
    if (resolver.needsMeasurement) {
      anyNeedsMeasurement = true;
    }
  });
}
function flushKeyframeResolvers() {
  isForced = true;
  readAllKeyframes();
  measureAllKeyframes();
  isForced = false;
}
class KeyframeResolver {
  constructor(unresolvedKeyframes, onComplete, name, motionValue2, element, isAsync = false) {
    this.state = "pending";
    this.isAsync = false;
    this.needsMeasurement = false;
    this.unresolvedKeyframes = [...unresolvedKeyframes];
    this.onComplete = onComplete;
    this.name = name;
    this.motionValue = motionValue2;
    this.element = element;
    this.isAsync = isAsync;
  }
  scheduleResolve() {
    this.state = "scheduled";
    if (this.isAsync) {
      toResolve.add(this);
      if (!isScheduled) {
        isScheduled = true;
        frame.read(readAllKeyframes);
        frame.resolveKeyframes(measureAllKeyframes);
      }
    } else {
      this.readKeyframes();
      this.complete();
    }
  }
  readKeyframes() {
    const { unresolvedKeyframes, name, element, motionValue: motionValue2 } = this;
    if (unresolvedKeyframes[0] === null) {
      const currentValue = motionValue2?.get();
      const finalKeyframe = unresolvedKeyframes[unresolvedKeyframes.length - 1];
      if (currentValue !== void 0) {
        unresolvedKeyframes[0] = currentValue;
      } else if (element && name) {
        const valueAsRead = element.readValue(name, finalKeyframe);
        if (valueAsRead !== void 0 && valueAsRead !== null) {
          unresolvedKeyframes[0] = valueAsRead;
        }
      }
      if (unresolvedKeyframes[0] === void 0) {
        unresolvedKeyframes[0] = finalKeyframe;
      }
      if (motionValue2 && currentValue === void 0) {
        motionValue2.set(unresolvedKeyframes[0]);
      }
    }
    fillWildcards(unresolvedKeyframes);
  }
  setFinalKeyframe() {
  }
  measureInitialState() {
  }
  renderEndStyles() {
  }
  measureEndState() {
  }
  complete(isForcedComplete = false) {
    this.state = "complete";
    this.onComplete(this.unresolvedKeyframes, this.finalKeyframe, isForcedComplete);
    toResolve.delete(this);
  }
  cancel() {
    if (this.state === "scheduled") {
      toResolve.delete(this);
      this.state = "pending";
    }
  }
  resume() {
    if (this.state === "pending")
      this.scheduleResolve();
  }
}
const isCSSVar = (name) => name.startsWith("--");
function setStyle(element, name, value) {
  isCSSVar(name) ? element.style.setProperty(name, value) : element.style[name] = value;
}
const supportsScrollTimeline = /* @__PURE__ */ memo(() => window.ScrollTimeline !== void 0);
const supportsFlags = {};
function memoSupports(callback, supportsFlag) {
  const memoized = /* @__PURE__ */ memo(callback);
  return () => supportsFlags[supportsFlag] ?? memoized();
}
const supportsLinearEasing = /* @__PURE__ */ memoSupports(() => {
  try {
    document.createElement("div").animate({ opacity: 0 }, { easing: "linear(0, 1)" });
  } catch (e2) {
    return false;
  }
  return true;
}, "linearEasing");
const cubicBezierAsString = ([a2, b2, c2, d2]) => `cubic-bezier(${a2}, ${b2}, ${c2}, ${d2})`;
const supportedWaapiEasing = {
  linear: "linear",
  ease: "ease",
  easeIn: "ease-in",
  easeOut: "ease-out",
  easeInOut: "ease-in-out",
  circIn: /* @__PURE__ */ cubicBezierAsString([0, 0.65, 0.55, 1]),
  circOut: /* @__PURE__ */ cubicBezierAsString([0.55, 0, 1, 0.45]),
  backIn: /* @__PURE__ */ cubicBezierAsString([0.31, 0.01, 0.66, -0.59]),
  backOut: /* @__PURE__ */ cubicBezierAsString([0.33, 1.53, 0.69, 0.99])
};
function mapEasingToNativeEasing(easing2, duration2) {
  if (!easing2) {
    return void 0;
  } else if (typeof easing2 === "function") {
    return supportsLinearEasing() ? generateLinearEasing(easing2, duration2) : "ease-out";
  } else if (isBezierDefinition(easing2)) {
    return cubicBezierAsString(easing2);
  } else if (Array.isArray(easing2)) {
    return easing2.map((segmentEasing) => mapEasingToNativeEasing(segmentEasing, duration2) || supportedWaapiEasing.easeOut);
  } else {
    return supportedWaapiEasing[easing2];
  }
}
function startWaapiAnimation(element, valueName, keyframes2, { delay: delay2 = 0, duration: duration2 = 300, repeat = 0, repeatType = "loop", ease: ease2 = "easeOut", times } = {}, pseudoElement = void 0) {
  const keyframeOptions = {
    [valueName]: keyframes2
  };
  if (times)
    keyframeOptions.offset = times;
  const easing2 = mapEasingToNativeEasing(ease2, duration2);
  if (Array.isArray(easing2))
    keyframeOptions.easing = easing2;
  const options = {
    delay: delay2,
    duration: duration2,
    easing: !Array.isArray(easing2) ? easing2 : "linear",
    fill: "both",
    iterations: repeat + 1,
    direction: repeatType === "reverse" ? "alternate" : "normal"
  };
  if (pseudoElement)
    options.pseudoElement = pseudoElement;
  const animation = element.animate(keyframeOptions, options);
  return animation;
}
function isGenerator(type) {
  return typeof type === "function" && "applyToOptions" in type;
}
function applyGeneratorOptions({ type, ...options }) {
  if (isGenerator(type) && supportsLinearEasing()) {
    return type.applyToOptions(options);
  } else {
    options.duration ?? (options.duration = 300);
    options.ease ?? (options.ease = "easeOut");
  }
  return options;
}
class NativeAnimation extends WithPromise {
  constructor(options) {
    super();
    this.finishedTime = null;
    this.isStopped = false;
    if (!options)
      return;
    const { element, name, keyframes: keyframes2, pseudoElement, allowFlatten = false, finalKeyframe, onComplete } = options;
    this.isPseudoElement = Boolean(pseudoElement);
    this.allowFlatten = allowFlatten;
    this.options = options;
    invariant(typeof options.type !== "string");
    const transition = applyGeneratorOptions(options);
    this.animation = startWaapiAnimation(element, name, keyframes2, transition, pseudoElement);
    if (transition.autoplay === false) {
      this.animation.pause();
    }
    this.animation.onfinish = () => {
      this.finishedTime = this.time;
      if (!pseudoElement) {
        const keyframe = getFinalKeyframe$1(keyframes2, this.options, finalKeyframe, this.speed);
        if (this.updateMotionValue) {
          this.updateMotionValue(keyframe);
        } else {
          setStyle(element, name, keyframe);
        }
        this.animation.cancel();
      }
      onComplete?.();
      this.notifyFinished();
    };
  }
  play() {
    if (this.isStopped)
      return;
    this.animation.play();
    if (this.state === "finished") {
      this.updateFinished();
    }
  }
  pause() {
    this.animation.pause();
  }
  complete() {
    this.animation.finish?.();
  }
  cancel() {
    try {
      this.animation.cancel();
    } catch (e2) {
    }
  }
  stop() {
    if (this.isStopped)
      return;
    this.isStopped = true;
    const { state } = this;
    if (state === "idle" || state === "finished") {
      return;
    }
    if (this.updateMotionValue) {
      this.updateMotionValue();
    } else {
      this.commitStyles();
    }
    if (!this.isPseudoElement)
      this.cancel();
  }
  /**
   * WAAPI doesn't natively have any interruption capabilities.
   *
   * In this method, we commit styles back to the DOM before cancelling
   * the animation.
   *
   * This is designed to be overridden by NativeAnimationExtended, which
   * will create a renderless JS animation and sample it twice to calculate
   * its current value, "previous" value, and therefore allow
   * Motion to also correctly calculate velocity for any subsequent animation
   * while deferring the commit until the next animation frame.
   */
  commitStyles() {
    if (!this.isPseudoElement) {
      this.animation.commitStyles?.();
    }
  }
  get duration() {
    const duration2 = this.animation.effect?.getComputedTiming?.().duration || 0;
    return /* @__PURE__ */ millisecondsToSeconds(Number(duration2));
  }
  get time() {
    return /* @__PURE__ */ millisecondsToSeconds(Number(this.animation.currentTime) || 0);
  }
  set time(newTime) {
    this.finishedTime = null;
    this.animation.currentTime = /* @__PURE__ */ secondsToMilliseconds(newTime);
  }
  /**
   * The playback speed of the animation.
   * 1 = normal speed, 2 = double speed, 0.5 = half speed.
   */
  get speed() {
    return this.animation.playbackRate;
  }
  set speed(newSpeed) {
    if (newSpeed < 0)
      this.finishedTime = null;
    this.animation.playbackRate = newSpeed;
  }
  get state() {
    return this.finishedTime !== null ? "finished" : this.animation.playState;
  }
  get startTime() {
    return Number(this.animation.startTime);
  }
  set startTime(newStartTime) {
    this.animation.startTime = newStartTime;
  }
  /**
   * Attaches a timeline to the animation, for instance the `ScrollTimeline`.
   */
  attachTimeline({ timeline, observe }) {
    if (this.allowFlatten) {
      this.animation.effect?.updateTiming({ easing: "linear" });
    }
    this.animation.onfinish = null;
    if (timeline && supportsScrollTimeline()) {
      this.animation.timeline = timeline;
      return noop$6;
    } else {
      return observe(this);
    }
  }
}
const unsupportedEasingFunctions = {
  anticipate,
  backInOut,
  circInOut
};
function isUnsupportedEase(key2) {
  return key2 in unsupportedEasingFunctions;
}
function replaceStringEasing(transition) {
  if (typeof transition.ease === "string" && isUnsupportedEase(transition.ease)) {
    transition.ease = unsupportedEasingFunctions[transition.ease];
  }
}
const sampleDelta = 10;
class NativeAnimationExtended extends NativeAnimation {
  constructor(options) {
    replaceStringEasing(options);
    replaceTransitionType(options);
    super(options);
    if (options.startTime) {
      this.startTime = options.startTime;
    }
    this.options = options;
  }
  /**
   * WAAPI doesn't natively have any interruption capabilities.
   *
   * Rather than read commited styles back out of the DOM, we can
   * create a renderless JS animation and sample it twice to calculate
   * its current value, "previous" value, and therefore allow
   * Motion to calculate velocity for any subsequent animation.
   */
  updateMotionValue(value) {
    const { motionValue: motionValue2, onUpdate, onComplete, element, ...options } = this.options;
    if (!motionValue2)
      return;
    if (value !== void 0) {
      motionValue2.set(value);
      return;
    }
    const sampleAnimation = new JSAnimation$1({
      ...options,
      autoplay: false
    });
    const sampleTime = /* @__PURE__ */ secondsToMilliseconds(this.finishedTime ?? this.time);
    motionValue2.setWithVelocity(sampleAnimation.sample(sampleTime - sampleDelta).value, sampleAnimation.sample(sampleTime).value, sampleDelta);
    sampleAnimation.stop();
  }
}
const isAnimatable = (value, name) => {
  if (name === "zIndex")
    return false;
  if (typeof value === "number" || Array.isArray(value))
    return true;
  if (typeof value === "string" && // It's animatable if we have a string
  (complex.test(value) || value === "0") && // And it contains numbers and/or colors
  !value.startsWith("url(")) {
    return true;
  }
  return false;
};
function hasKeyframesChanged(keyframes2) {
  const current = keyframes2[0];
  if (keyframes2.length === 1)
    return true;
  for (let i2 = 0; i2 < keyframes2.length; i2++) {
    if (keyframes2[i2] !== current)
      return true;
  }
}
function canAnimate(keyframes2, name, type, velocity) {
  const originKeyframe = keyframes2[0];
  if (originKeyframe === null)
    return false;
  if (name === "display" || name === "visibility")
    return true;
  const targetKeyframe = keyframes2[keyframes2.length - 1];
  const isOriginAnimatable = isAnimatable(originKeyframe, name);
  const isTargetAnimatable = isAnimatable(targetKeyframe, name);
  if (!isOriginAnimatable || !isTargetAnimatable) {
    return false;
  }
  return hasKeyframesChanged(keyframes2) || (type === "spring" || isGenerator(type)) && velocity;
}
function isHTMLElement$1(element) {
  return isObject(element) && "offsetHeight" in element;
}
const acceleratedValues = /* @__PURE__ */ new Set([
  "opacity",
  "clipPath",
  "filter",
  "transform"
  // TODO: Could be re-enabled now we have support for linear() easing
  // "background-color"
]);
const supportsWaapi = /* @__PURE__ */ memo(() => Object.hasOwnProperty.call(Element.prototype, "animate"));
function supportsBrowserAnimation(options) {
  const { motionValue: motionValue2, name, repeatDelay, repeatType, damping, type } = options;
  if (!isHTMLElement$1(motionValue2?.owner?.current)) {
    return false;
  }
  const { onUpdate, transformTemplate } = motionValue2.owner.getProps();
  return supportsWaapi() && name && acceleratedValues.has(name) && (name !== "transform" || !transformTemplate) && /**
   * If we're outputting values to onUpdate then we can't use WAAPI as there's
   * no way to read the value from WAAPI every frame.
   */
  !onUpdate && !repeatDelay && repeatType !== "mirror" && damping !== 0 && type !== "inertia";
}
const MAX_RESOLVE_DELAY = 40;
class AsyncMotionValueAnimation extends WithPromise {
  constructor({ autoplay = true, delay: delay2 = 0, type = "keyframes", repeat = 0, repeatDelay = 0, repeatType = "loop", keyframes: keyframes2, name, motionValue: motionValue2, element, ...options }) {
    super();
    this.stop = () => {
      if (this._animation) {
        this._animation.stop();
        this.stopTimeline?.();
      }
      this.keyframeResolver?.cancel();
    };
    this.createdAt = time.now();
    const optionsWithDefaults = {
      autoplay,
      delay: delay2,
      type,
      repeat,
      repeatDelay,
      repeatType,
      name,
      motionValue: motionValue2,
      element,
      ...options
    };
    const KeyframeResolver$1 = element?.KeyframeResolver || KeyframeResolver;
    this.keyframeResolver = new KeyframeResolver$1(keyframes2, (resolvedKeyframes, finalKeyframe, forced) => this.onKeyframesResolved(resolvedKeyframes, finalKeyframe, optionsWithDefaults, !forced), name, motionValue2, element);
    this.keyframeResolver?.scheduleResolve();
  }
  onKeyframesResolved(keyframes2, finalKeyframe, options, sync) {
    this.keyframeResolver = void 0;
    const { name, type, velocity, delay: delay2, isHandoff, onUpdate } = options;
    this.resolvedAt = time.now();
    if (!canAnimate(keyframes2, name, type, velocity)) {
      if (MotionGlobalConfig.instantAnimations || !delay2) {
        onUpdate?.(getFinalKeyframe$1(keyframes2, options, finalKeyframe));
      }
      keyframes2[0] = keyframes2[keyframes2.length - 1];
      options.duration = 0;
      options.repeat = 0;
    }
    const startTime = sync ? !this.resolvedAt ? this.createdAt : this.resolvedAt - this.createdAt > MAX_RESOLVE_DELAY ? this.resolvedAt : this.createdAt : void 0;
    const resolvedOptions = {
      startTime,
      finalKeyframe,
      ...options,
      keyframes: keyframes2
    };
    const animation = !isHandoff && supportsBrowserAnimation(resolvedOptions) ? new NativeAnimationExtended({
      ...resolvedOptions,
      element: resolvedOptions.motionValue.owner.current
    }) : new JSAnimation$1(resolvedOptions);
    animation.finished.then(() => this.notifyFinished()).catch(noop$6);
    if (this.pendingTimeline) {
      this.stopTimeline = animation.attachTimeline(this.pendingTimeline);
      this.pendingTimeline = void 0;
    }
    this._animation = animation;
  }
  get finished() {
    if (!this._animation) {
      return this._finished;
    } else {
      return this.animation.finished;
    }
  }
  then(onResolve, _onReject) {
    return this.finished.finally(onResolve).then(() => {
    });
  }
  get animation() {
    if (!this._animation) {
      this.keyframeResolver?.resume();
      flushKeyframeResolvers();
    }
    return this._animation;
  }
  get duration() {
    return this.animation.duration;
  }
  get time() {
    return this.animation.time;
  }
  set time(newTime) {
    this.animation.time = newTime;
  }
  get speed() {
    return this.animation.speed;
  }
  get state() {
    return this.animation.state;
  }
  set speed(newSpeed) {
    this.animation.speed = newSpeed;
  }
  get startTime() {
    return this.animation.startTime;
  }
  attachTimeline(timeline) {
    if (this._animation) {
      this.stopTimeline = this.animation.attachTimeline(timeline);
    } else {
      this.pendingTimeline = timeline;
    }
    return () => this.stop();
  }
  play() {
    this.animation.play();
  }
  pause() {
    this.animation.pause();
  }
  complete() {
    this.animation.complete();
  }
  cancel() {
    if (this._animation) {
      this.animation.cancel();
    }
    this.keyframeResolver?.cancel();
  }
}
const splitCSSVariableRegex = (
  // eslint-disable-next-line redos-detector/no-unsafe-regex -- false positive, as it can match a lot of words
  /^var\(--(?:([\w-]+)|([\w-]+), ?([a-zA-Z\d ()%#.,-]+))\)/u
);
function parseCSSVariable(current) {
  const match2 = splitCSSVariableRegex.exec(current);
  if (!match2)
    return [,];
  const [, token1, token2, fallback] = match2;
  return [`--${token1 ?? token2}`, fallback];
}
function getVariableValue(current, element, depth = 1) {
  const [token2, fallback] = parseCSSVariable(current);
  if (!token2)
    return;
  const resolved = window.getComputedStyle(element).getPropertyValue(token2);
  if (resolved) {
    const trimmed = resolved.trim();
    return isNumericalString(trimmed) ? parseFloat(trimmed) : trimmed;
  }
  return isCSSVariableToken(fallback) ? getVariableValue(fallback, element, depth + 1) : fallback;
}
function getValueTransition(transition, key2) {
  return transition?.[key2] ?? transition?.["default"] ?? transition;
}
const positionalKeys = /* @__PURE__ */ new Set([
  "width",
  "height",
  "top",
  "left",
  "right",
  "bottom",
  ...transformPropOrder
]);
const auto = {
  test: (v2) => v2 === "auto",
  parse: (v2) => v2
};
const testValueType = (v2) => (type) => type.test(v2);
const dimensionValueTypes = [number, px, percent, degrees, vw, vh, auto];
const findDimensionValueType = (v2) => dimensionValueTypes.find(testValueType(v2));
function isNone(value) {
  if (typeof value === "number") {
    return value === 0;
  } else if (value !== null) {
    return value === "none" || value === "0" || isZeroValueString(value);
  } else {
    return true;
  }
}
const maxDefaults = /* @__PURE__ */ new Set(["brightness", "contrast", "saturate", "opacity"]);
function applyDefaultFilter(v2) {
  const [name, value] = v2.slice(0, -1).split("(");
  if (name === "drop-shadow")
    return v2;
  const [number2] = value.match(floatRegex) || [];
  if (!number2)
    return v2;
  const unit = value.replace(number2, "");
  let defaultValue = maxDefaults.has(name) ? 1 : 0;
  if (number2 !== value)
    defaultValue *= 100;
  return name + "(" + defaultValue + unit + ")";
}
const functionRegex = /\b([a-z-]*)\(.*?\)/gu;
const filter = {
  ...complex,
  getAnimatableNone: (v2) => {
    const functions = v2.match(functionRegex);
    return functions ? functions.map(applyDefaultFilter).join(" ") : v2;
  }
};
const int = {
  ...number,
  transform: Math.round
};
const transformValueTypes = {
  rotate: degrees,
  rotateX: degrees,
  rotateY: degrees,
  rotateZ: degrees,
  scale,
  scaleX: scale,
  scaleY: scale,
  scaleZ: scale,
  skew: degrees,
  skewX: degrees,
  skewY: degrees,
  distance: px,
  translateX: px,
  translateY: px,
  translateZ: px,
  x: px,
  y: px,
  z: px,
  perspective: px,
  transformPerspective: px,
  opacity: alpha$1,
  originX: progressPercentage,
  originY: progressPercentage,
  originZ: px
};
const numberValueTypes = {
  // Border props
  borderWidth: px,
  borderTopWidth: px,
  borderRightWidth: px,
  borderBottomWidth: px,
  borderLeftWidth: px,
  borderRadius: px,
  radius: px,
  borderTopLeftRadius: px,
  borderTopRightRadius: px,
  borderBottomRightRadius: px,
  borderBottomLeftRadius: px,
  // Positioning props
  width: px,
  maxWidth: px,
  height: px,
  maxHeight: px,
  top: px,
  right: px,
  bottom: px,
  left: px,
  // Spacing props
  padding: px,
  paddingTop: px,
  paddingRight: px,
  paddingBottom: px,
  paddingLeft: px,
  margin: px,
  marginTop: px,
  marginRight: px,
  marginBottom: px,
  marginLeft: px,
  // Misc
  backgroundPositionX: px,
  backgroundPositionY: px,
  ...transformValueTypes,
  zIndex: int,
  // SVG
  fillOpacity: alpha$1,
  strokeOpacity: alpha$1,
  numOctaves: int
};
const defaultValueTypes = {
  ...numberValueTypes,
  // Color props
  color: color$1,
  backgroundColor: color$1,
  outlineColor: color$1,
  fill: color$1,
  stroke: color$1,
  // Border props
  borderColor: color$1,
  borderTopColor: color$1,
  borderRightColor: color$1,
  borderBottomColor: color$1,
  borderLeftColor: color$1,
  filter,
  WebkitFilter: filter
};
const getDefaultValueType = (key2) => defaultValueTypes[key2];
function getAnimatableNone(key2, value) {
  let defaultValueType = getDefaultValueType(key2);
  if (defaultValueType !== filter)
    defaultValueType = complex;
  return defaultValueType.getAnimatableNone ? defaultValueType.getAnimatableNone(value) : void 0;
}
const invalidTemplates = /* @__PURE__ */ new Set(["auto", "none", "0"]);
function makeNoneKeyframesAnimatable(unresolvedKeyframes, noneKeyframeIndexes, name) {
  let i2 = 0;
  let animatableTemplate = void 0;
  while (i2 < unresolvedKeyframes.length && !animatableTemplate) {
    const keyframe = unresolvedKeyframes[i2];
    if (typeof keyframe === "string" && !invalidTemplates.has(keyframe) && analyseComplexValue(keyframe).values.length) {
      animatableTemplate = unresolvedKeyframes[i2];
    }
    i2++;
  }
  if (animatableTemplate && name) {
    for (const noneIndex of noneKeyframeIndexes) {
      unresolvedKeyframes[noneIndex] = getAnimatableNone(name, animatableTemplate);
    }
  }
}
class DOMKeyframesResolver extends KeyframeResolver {
  constructor(unresolvedKeyframes, onComplete, name, motionValue2, element) {
    super(unresolvedKeyframes, onComplete, name, motionValue2, element, true);
  }
  readKeyframes() {
    const { unresolvedKeyframes, element, name } = this;
    if (!element || !element.current)
      return;
    super.readKeyframes();
    for (let i2 = 0; i2 < unresolvedKeyframes.length; i2++) {
      let keyframe = unresolvedKeyframes[i2];
      if (typeof keyframe === "string") {
        keyframe = keyframe.trim();
        if (isCSSVariableToken(keyframe)) {
          const resolved = getVariableValue(keyframe, element.current);
          if (resolved !== void 0) {
            unresolvedKeyframes[i2] = resolved;
          }
          if (i2 === unresolvedKeyframes.length - 1) {
            this.finalKeyframe = keyframe;
          }
        }
      }
    }
    this.resolveNoneKeyframes();
    if (!positionalKeys.has(name) || unresolvedKeyframes.length !== 2) {
      return;
    }
    const [origin, target] = unresolvedKeyframes;
    const originType = findDimensionValueType(origin);
    const targetType = findDimensionValueType(target);
    if (originType === targetType)
      return;
    if (isNumOrPxType(originType) && isNumOrPxType(targetType)) {
      for (let i2 = 0; i2 < unresolvedKeyframes.length; i2++) {
        const value = unresolvedKeyframes[i2];
        if (typeof value === "string") {
          unresolvedKeyframes[i2] = parseFloat(value);
        }
      }
    } else if (positionalValues[name]) {
      this.needsMeasurement = true;
    }
  }
  resolveNoneKeyframes() {
    const { unresolvedKeyframes, name } = this;
    const noneKeyframeIndexes = [];
    for (let i2 = 0; i2 < unresolvedKeyframes.length; i2++) {
      if (unresolvedKeyframes[i2] === null || isNone(unresolvedKeyframes[i2])) {
        noneKeyframeIndexes.push(i2);
      }
    }
    if (noneKeyframeIndexes.length) {
      makeNoneKeyframesAnimatable(unresolvedKeyframes, noneKeyframeIndexes, name);
    }
  }
  measureInitialState() {
    const { element, unresolvedKeyframes, name } = this;
    if (!element || !element.current)
      return;
    if (name === "height") {
      this.suspendedScrollY = window.pageYOffset;
    }
    this.measuredOrigin = positionalValues[name](element.measureViewportBox(), window.getComputedStyle(element.current));
    unresolvedKeyframes[0] = this.measuredOrigin;
    const measureKeyframe = unresolvedKeyframes[unresolvedKeyframes.length - 1];
    if (measureKeyframe !== void 0) {
      element.getValue(name, measureKeyframe).jump(measureKeyframe, false);
    }
  }
  measureEndState() {
    const { element, name, unresolvedKeyframes } = this;
    if (!element || !element.current)
      return;
    const value = element.getValue(name);
    value && value.jump(this.measuredOrigin, false);
    const finalKeyframeIndex = unresolvedKeyframes.length - 1;
    const finalKeyframe = unresolvedKeyframes[finalKeyframeIndex];
    unresolvedKeyframes[finalKeyframeIndex] = positionalValues[name](element.measureViewportBox(), window.getComputedStyle(element.current));
    if (finalKeyframe !== null && this.finalKeyframe === void 0) {
      this.finalKeyframe = finalKeyframe;
    }
    if (this.removedTransforms?.length) {
      this.removedTransforms.forEach(([unsetTransformName, unsetTransformValue]) => {
        element.getValue(unsetTransformName).set(unsetTransformValue);
      });
    }
    this.resolveNoneKeyframes();
  }
}
function resolveElements(elementOrSelector, scope, selectorCache) {
  if (elementOrSelector instanceof EventTarget) {
    return [elementOrSelector];
  } else if (typeof elementOrSelector === "string") {
    let root = document;
    const elements = root.querySelectorAll(elementOrSelector);
    return elements ? Array.from(elements) : [];
  }
  return Array.from(elementOrSelector);
}
const getValueAsType = (value, type) => {
  return type && typeof value === "number" ? type.transform(value) : value;
};
const MAX_VELOCITY_DELTA = 30;
const isFloat = (value) => {
  return !isNaN(parseFloat(value));
};
const collectMotionValues = {
  current: void 0
};
class MotionValue {
  /**
   * @param init - The initiating value
   * @param config - Optional configuration options
   *
   * -  `transformer`: A function to transform incoming values with.
   */
  constructor(init, options = {}) {
    this.canTrackVelocity = null;
    this.events = {};
    this.updateAndNotify = (v2, render2 = true) => {
      const currentTime = time.now();
      if (this.updatedAt !== currentTime) {
        this.setPrevFrameValue();
      }
      this.prev = this.current;
      this.setCurrent(v2);
      if (this.current !== this.prev) {
        this.events.change?.notify(this.current);
        if (this.dependents) {
          for (const dependent of this.dependents) {
            dependent.dirty();
          }
        }
      }
      if (render2) {
        this.events.renderRequest?.notify(this.current);
      }
    };
    this.hasAnimated = false;
    this.setCurrent(init);
    this.owner = options.owner;
  }
  setCurrent(current) {
    this.current = current;
    this.updatedAt = time.now();
    if (this.canTrackVelocity === null && current !== void 0) {
      this.canTrackVelocity = isFloat(this.current);
    }
  }
  setPrevFrameValue(prevFrameValue = this.current) {
    this.prevFrameValue = prevFrameValue;
    this.prevUpdatedAt = this.updatedAt;
  }
  /**
   * Adds a function that will be notified when the `MotionValue` is updated.
   *
   * It returns a function that, when called, will cancel the subscription.
   *
   * When calling `onChange` inside a React component, it should be wrapped with the
   * `useEffect` hook. As it returns an unsubscribe function, this should be returned
   * from the `useEffect` function to ensure you don't add duplicate subscribers..
   *
   * ```jsx
   * export const MyComponent = () => {
   *   const x = useMotionValue(0)
   *   const y = useMotionValue(0)
   *   const opacity = useMotionValue(1)
   *
   *   useEffect(() => {
   *     function updateOpacity() {
   *       const maxXY = Math.max(x.get(), y.get())
   *       const newOpacity = transform(maxXY, [0, 100], [1, 0])
   *       opacity.set(newOpacity)
   *     }
   *
   *     const unsubscribeX = x.on("change", updateOpacity)
   *     const unsubscribeY = y.on("change", updateOpacity)
   *
   *     return () => {
   *       unsubscribeX()
   *       unsubscribeY()
   *     }
   *   }, [])
   *
   *   return <motion.div style={{ x }} />
   * }
   * ```
   *
   * @param subscriber - A function that receives the latest value.
   * @returns A function that, when called, will cancel this subscription.
   *
   * @deprecated
   */
  onChange(subscription) {
    return this.on("change", subscription);
  }
  on(eventName, callback) {
    if (!this.events[eventName]) {
      this.events[eventName] = new SubscriptionManager();
    }
    const unsubscribe = this.events[eventName].add(callback);
    if (eventName === "change") {
      return () => {
        unsubscribe();
        frame.read(() => {
          if (!this.events.change.getSize()) {
            this.stop();
          }
        });
      };
    }
    return unsubscribe;
  }
  clearListeners() {
    for (const eventManagers in this.events) {
      this.events[eventManagers].clear();
    }
  }
  /**
   * Attaches a passive effect to the `MotionValue`.
   */
  attach(passiveEffect, stopPassiveEffect) {
    this.passiveEffect = passiveEffect;
    this.stopPassiveEffect = stopPassiveEffect;
  }
  /**
   * Sets the state of the `MotionValue`.
   *
   * @remarks
   *
   * ```jsx
   * const x = useMotionValue(0)
   * x.set(10)
   * ```
   *
   * @param latest - Latest value to set.
   * @param render - Whether to notify render subscribers. Defaults to `true`
   *
   * @public
   */
  set(v2, render2 = true) {
    if (!render2 || !this.passiveEffect) {
      this.updateAndNotify(v2, render2);
    } else {
      this.passiveEffect(v2, this.updateAndNotify);
    }
  }
  setWithVelocity(prev2, current, delta) {
    this.set(current);
    this.prev = void 0;
    this.prevFrameValue = prev2;
    this.prevUpdatedAt = this.updatedAt - delta;
  }
  /**
   * Set the state of the `MotionValue`, stopping any active animations,
   * effects, and resets velocity to `0`.
   */
  jump(v2, endAnimation = true) {
    this.updateAndNotify(v2);
    this.prev = v2;
    this.prevUpdatedAt = this.prevFrameValue = void 0;
    endAnimation && this.stop();
    if (this.stopPassiveEffect)
      this.stopPassiveEffect();
  }
  dirty() {
    this.events.change?.notify(this.current);
  }
  addDependent(dependent) {
    if (!this.dependents) {
      this.dependents = /* @__PURE__ */ new Set();
    }
    this.dependents.add(dependent);
  }
  removeDependent(dependent) {
    if (this.dependents) {
      this.dependents.delete(dependent);
    }
  }
  /**
   * Returns the latest state of `MotionValue`
   *
   * @returns - The latest state of `MotionValue`
   *
   * @public
   */
  get() {
    if (collectMotionValues.current) {
      collectMotionValues.current.push(this);
    }
    return this.current;
  }
  /**
   * @public
   */
  getPrevious() {
    return this.prev;
  }
  /**
   * Returns the latest velocity of `MotionValue`
   *
   * @returns - The latest velocity of `MotionValue`. Returns `0` if the state is non-numerical.
   *
   * @public
   */
  getVelocity() {
    const currentTime = time.now();
    if (!this.canTrackVelocity || this.prevFrameValue === void 0 || currentTime - this.updatedAt > MAX_VELOCITY_DELTA) {
      return 0;
    }
    const delta = Math.min(this.updatedAt - this.prevUpdatedAt, MAX_VELOCITY_DELTA);
    return velocityPerSecond(parseFloat(this.current) - parseFloat(this.prevFrameValue), delta);
  }
  /**
   * Registers a new animation to control this `MotionValue`. Only one
   * animation can drive a `MotionValue` at one time.
   *
   * ```jsx
   * value.start()
   * ```
   *
   * @param animation - A function that starts the provided animation
   */
  start(startAnimation) {
    this.stop();
    return new Promise((resolve) => {
      this.hasAnimated = true;
      this.animation = startAnimation(resolve);
      if (this.events.animationStart) {
        this.events.animationStart.notify();
      }
    }).then(() => {
      if (this.events.animationComplete) {
        this.events.animationComplete.notify();
      }
      this.clearAnimation();
    });
  }
  /**
   * Stop the currently active animation.
   *
   * @public
   */
  stop() {
    if (this.animation) {
      this.animation.stop();
      if (this.events.animationCancel) {
        this.events.animationCancel.notify();
      }
    }
    this.clearAnimation();
  }
  /**
   * Returns `true` if this value is currently animating.
   *
   * @public
   */
  isAnimating() {
    return !!this.animation;
  }
  clearAnimation() {
    delete this.animation;
  }
  /**
   * Destroy and clean up subscribers to this `MotionValue`.
   *
   * The `MotionValue` hooks like `useMotionValue` and `useTransform` automatically
   * handle the lifecycle of the returned `MotionValue`, so this method is only necessary if you've manually
   * created a `MotionValue` via the `motionValue` function.
   *
   * @public
   */
  destroy() {
    this.dependents?.clear();
    this.events.destroy?.notify();
    this.clearListeners();
    this.stop();
    if (this.stopPassiveEffect) {
      this.stopPassiveEffect();
    }
  }
}
function motionValue(init, options) {
  return new MotionValue(init, options);
}
const { schedule: microtask, cancel: cancelMicrotask } = /* @__PURE__ */ createRenderBatcher(queueMicrotask, false);
const isDragging = {
  x: false,
  y: false
};
function isDragActive() {
  return isDragging.x || isDragging.y;
}
function setDragLock(axis) {
  if (axis === "x" || axis === "y") {
    if (isDragging[axis]) {
      return null;
    } else {
      isDragging[axis] = true;
      return () => {
        isDragging[axis] = false;
      };
    }
  } else {
    if (isDragging.x || isDragging.y) {
      return null;
    } else {
      isDragging.x = isDragging.y = true;
      return () => {
        isDragging.x = isDragging.y = false;
      };
    }
  }
}
function setupGesture(elementOrSelector, options) {
  const elements = resolveElements(elementOrSelector);
  const gestureAbortController = new AbortController();
  const eventOptions = {
    passive: true,
    ...options,
    signal: gestureAbortController.signal
  };
  const cancel = () => gestureAbortController.abort();
  return [elements, eventOptions, cancel];
}
function isValidHover(event) {
  return !(event.pointerType === "touch" || isDragActive());
}
function hover(elementOrSelector, onHoverStart, options = {}) {
  const [elements, eventOptions, cancel] = setupGesture(elementOrSelector, options);
  const onPointerEnter = (enterEvent) => {
    if (!isValidHover(enterEvent))
      return;
    const { target } = enterEvent;
    const onHoverEnd = onHoverStart(target, enterEvent);
    if (typeof onHoverEnd !== "function" || !target)
      return;
    const onPointerLeave = (leaveEvent) => {
      if (!isValidHover(leaveEvent))
        return;
      onHoverEnd(leaveEvent);
      target.removeEventListener("pointerleave", onPointerLeave);
    };
    target.addEventListener("pointerleave", onPointerLeave, eventOptions);
  };
  elements.forEach((element) => {
    element.addEventListener("pointerenter", onPointerEnter, eventOptions);
  });
  return cancel;
}
const isNodeOrChild = (parent2, child) => {
  if (!child) {
    return false;
  } else if (parent2 === child) {
    return true;
  } else {
    return isNodeOrChild(parent2, child.parentElement);
  }
};
const isPrimaryPointer = (event) => {
  if (event.pointerType === "mouse") {
    return typeof event.button !== "number" || event.button <= 0;
  } else {
    return event.isPrimary !== false;
  }
};
const focusableElements = /* @__PURE__ */ new Set([
  "BUTTON",
  "INPUT",
  "SELECT",
  "TEXTAREA",
  "A"
]);
function isElementKeyboardAccessible(element) {
  return focusableElements.has(element.tagName) || element.tabIndex !== -1;
}
const isPressing = /* @__PURE__ */ new WeakSet();
function filterEvents(callback) {
  return (event) => {
    if (event.key !== "Enter")
      return;
    callback(event);
  };
}
function firePointerEvent(target, type) {
  target.dispatchEvent(new PointerEvent("pointer" + type, { isPrimary: true, bubbles: true }));
}
const enableKeyboardPress = (focusEvent, eventOptions) => {
  const element = focusEvent.currentTarget;
  if (!element)
    return;
  const handleKeydown = filterEvents(() => {
    if (isPressing.has(element))
      return;
    firePointerEvent(element, "down");
    const handleKeyup = filterEvents(() => {
      firePointerEvent(element, "up");
    });
    const handleBlur = () => firePointerEvent(element, "cancel");
    element.addEventListener("keyup", handleKeyup, eventOptions);
    element.addEventListener("blur", handleBlur, eventOptions);
  });
  element.addEventListener("keydown", handleKeydown, eventOptions);
  element.addEventListener("blur", () => element.removeEventListener("keydown", handleKeydown), eventOptions);
};
function isValidPressEvent(event) {
  return isPrimaryPointer(event) && !isDragActive();
}
function press(targetOrSelector, onPressStart, options = {}) {
  const [targets, eventOptions, cancelEvents] = setupGesture(targetOrSelector, options);
  const startPress = (startEvent) => {
    const target = startEvent.currentTarget;
    if (!isValidPressEvent(startEvent))
      return;
    isPressing.add(target);
    const onPressEnd = onPressStart(target, startEvent);
    const onPointerEnd = (endEvent, success) => {
      window.removeEventListener("pointerup", onPointerUp);
      window.removeEventListener("pointercancel", onPointerCancel);
      if (isPressing.has(target)) {
        isPressing.delete(target);
      }
      if (!isValidPressEvent(endEvent)) {
        return;
      }
      if (typeof onPressEnd === "function") {
        onPressEnd(endEvent, { success });
      }
    };
    const onPointerUp = (upEvent) => {
      onPointerEnd(upEvent, target === window || target === document || options.useGlobalTarget || isNodeOrChild(target, upEvent.target));
    };
    const onPointerCancel = (cancelEvent) => {
      onPointerEnd(cancelEvent, false);
    };
    window.addEventListener("pointerup", onPointerUp, eventOptions);
    window.addEventListener("pointercancel", onPointerCancel, eventOptions);
  };
  targets.forEach((target) => {
    const pointerDownTarget = options.useGlobalTarget ? window : target;
    pointerDownTarget.addEventListener("pointerdown", startPress, eventOptions);
    if (isHTMLElement$1(target)) {
      target.addEventListener("focus", (event) => enableKeyboardPress(event, eventOptions));
      if (!isElementKeyboardAccessible(target) && !target.hasAttribute("tabindex")) {
        target.tabIndex = 0;
      }
    }
  });
  return cancelEvents;
}
function isSVGElement(element) {
  return isObject(element) && "ownerSVGElement" in element;
}
function isSVGSVGElement(element) {
  return isSVGElement(element) && element.tagName === "svg";
}
function transform(...args) {
  const useImmediate = !Array.isArray(args[0]);
  const argOffset = useImmediate ? 0 : -1;
  const inputValue = args[0 + argOffset];
  const inputRange = args[1 + argOffset];
  const outputRange = args[2 + argOffset];
  const options = args[3 + argOffset];
  const interpolator = interpolate$2(inputRange, outputRange, options);
  return useImmediate ? interpolator(inputValue) : interpolator;
}
const isMotionValue = (value) => Boolean(value && value.getVelocity);
const valueTypes$1 = [...dimensionValueTypes, color$1, complex];
const findValueType = (v2) => valueTypes$1.find(testValueType(v2));
const MotionConfigContext = reactExports.createContext({
  transformPagePoint: (p2) => p2,
  isStatic: false,
  reducedMotion: "never"
});
class PopChildMeasure extends reactExports.Component {
  getSnapshotBeforeUpdate(prevProps) {
    const element = this.props.childRef.current;
    if (element && prevProps.isPresent && !this.props.isPresent) {
      const parent2 = element.offsetParent;
      const parentWidth = isHTMLElement$1(parent2) ? parent2.offsetWidth || 0 : 0;
      const size2 = this.props.sizeRef.current;
      size2.height = element.offsetHeight || 0;
      size2.width = element.offsetWidth || 0;
      size2.top = element.offsetTop;
      size2.left = element.offsetLeft;
      size2.right = parentWidth - size2.width - size2.left;
    }
    return null;
  }
  /**
   * Required with getSnapshotBeforeUpdate to stop React complaining.
   */
  componentDidUpdate() {
  }
  render() {
    return this.props.children;
  }
}
function PopChild({ children, isPresent, anchorX, root }) {
  const id2 = reactExports.useId();
  const ref = reactExports.useRef(null);
  const size2 = reactExports.useRef({
    width: 0,
    height: 0,
    top: 0,
    left: 0,
    right: 0
  });
  const { nonce } = reactExports.useContext(MotionConfigContext);
  reactExports.useInsertionEffect(() => {
    const { width: width2, height: height2, top, left, right } = size2.current;
    if (isPresent || !ref.current || !width2 || !height2)
      return;
    const x2 = anchorX === "left" ? `left: ${left}` : `right: ${right}`;
    ref.current.dataset.motionPopId = id2;
    const style2 = document.createElement("style");
    if (nonce)
      style2.nonce = nonce;
    const parent2 = root ?? document.head;
    parent2.appendChild(style2);
    if (style2.sheet) {
      style2.sheet.insertRule(`
          [data-motion-pop-id="${id2}"] {
            position: absolute !important;
            width: ${width2}px !important;
            height: ${height2}px !important;
            ${x2}px !important;
            top: ${top}px !important;
          }
        `);
    }
    return () => {
      parent2.removeChild(style2);
      if (parent2.contains(style2)) {
        parent2.removeChild(style2);
      }
    };
  }, [isPresent]);
  return jsxRuntimeExports.jsx(PopChildMeasure, { isPresent, childRef: ref, sizeRef: size2, children: reactExports.cloneElement(children, { ref }) });
}
const PresenceChild = ({ children, initial, isPresent, onExitComplete, custom, presenceAffectsLayout, mode, anchorX, root }) => {
  const presenceChildren = useConstant(newChildrenMap);
  const id2 = reactExports.useId();
  let isReusedContext = true;
  let context = reactExports.useMemo(() => {
    isReusedContext = false;
    return {
      id: id2,
      initial,
      isPresent,
      custom,
      onExitComplete: (childId) => {
        presenceChildren.set(childId, true);
        for (const isComplete of presenceChildren.values()) {
          if (!isComplete)
            return;
        }
        onExitComplete && onExitComplete();
      },
      register: (childId) => {
        presenceChildren.set(childId, false);
        return () => presenceChildren.delete(childId);
      }
    };
  }, [isPresent, presenceChildren, onExitComplete]);
  if (presenceAffectsLayout && isReusedContext) {
    context = { ...context };
  }
  reactExports.useMemo(() => {
    presenceChildren.forEach((_2, key2) => presenceChildren.set(key2, false));
  }, [isPresent]);
  reactExports.useEffect(() => {
    !isPresent && !presenceChildren.size && onExitComplete && onExitComplete();
  }, [isPresent]);
  if (mode === "popLayout") {
    children = jsxRuntimeExports.jsx(PopChild, { isPresent, anchorX, root, children });
  }
  return jsxRuntimeExports.jsx(PresenceContext.Provider, { value: context, children });
};
function newChildrenMap() {
  return /* @__PURE__ */ new Map();
}
function usePresence$1(subscribe = true) {
  const context = reactExports.useContext(PresenceContext);
  if (context === null)
    return [true, null];
  const { isPresent, onExitComplete, register } = context;
  const id2 = reactExports.useId();
  reactExports.useEffect(() => {
    if (subscribe) {
      return register(id2);
    }
  }, [subscribe]);
  const safeToRemove = reactExports.useCallback(() => subscribe && onExitComplete && onExitComplete(id2), [id2, onExitComplete, subscribe]);
  return !isPresent && onExitComplete ? [false, safeToRemove] : [true];
}
const getChildKey = (child) => child.key || "";
function onlyElements(children) {
  const filtered = [];
  reactExports.Children.forEach(children, (child) => {
    if (reactExports.isValidElement(child))
      filtered.push(child);
  });
  return filtered;
}
const AnimatePresence = ({ children, custom, initial = true, onExitComplete, presenceAffectsLayout = true, mode = "sync", propagate = false, anchorX = "left", root }) => {
  const [isParentPresent, safeToRemove] = usePresence$1(propagate);
  const presentChildren = reactExports.useMemo(() => onlyElements(children), [children]);
  const presentKeys = propagate && !isParentPresent ? [] : presentChildren.map(getChildKey);
  const isInitialRender = reactExports.useRef(true);
  const pendingPresentChildren = reactExports.useRef(presentChildren);
  const exitComplete = useConstant(() => /* @__PURE__ */ new Map());
  const [diffedChildren, setDiffedChildren] = reactExports.useState(presentChildren);
  const [renderedChildren, setRenderedChildren] = reactExports.useState(presentChildren);
  useIsomorphicLayoutEffect$1(() => {
    isInitialRender.current = false;
    pendingPresentChildren.current = presentChildren;
    for (let i2 = 0; i2 < renderedChildren.length; i2++) {
      const key2 = getChildKey(renderedChildren[i2]);
      if (!presentKeys.includes(key2)) {
        if (exitComplete.get(key2) !== true) {
          exitComplete.set(key2, false);
        }
      } else {
        exitComplete.delete(key2);
      }
    }
  }, [renderedChildren, presentKeys.length, presentKeys.join("-")]);
  const exitingChildren = [];
  if (presentChildren !== diffedChildren) {
    let nextChildren = [...presentChildren];
    for (let i2 = 0; i2 < renderedChildren.length; i2++) {
      const child = renderedChildren[i2];
      const key2 = getChildKey(child);
      if (!presentKeys.includes(key2)) {
        nextChildren.splice(i2, 0, child);
        exitingChildren.push(child);
      }
    }
    if (mode === "wait" && exitingChildren.length) {
      nextChildren = exitingChildren;
    }
    setRenderedChildren(onlyElements(nextChildren));
    setDiffedChildren(presentChildren);
    return null;
  }
  const { forceRender } = reactExports.useContext(LayoutGroupContext);
  return jsxRuntimeExports.jsx(jsxRuntimeExports.Fragment, { children: renderedChildren.map((child) => {
    const key2 = getChildKey(child);
    const isPresent = propagate && !isParentPresent ? false : presentChildren === renderedChildren || presentKeys.includes(key2);
    const onExit = () => {
      if (exitComplete.has(key2)) {
        exitComplete.set(key2, true);
      } else {
        return;
      }
      let isEveryExitComplete = true;
      exitComplete.forEach((isExitComplete) => {
        if (!isExitComplete)
          isEveryExitComplete = false;
      });
      if (isEveryExitComplete) {
        forceRender?.();
        setRenderedChildren(pendingPresentChildren.current);
        propagate && safeToRemove?.();
        onExitComplete && onExitComplete();
      }
    };
    return jsxRuntimeExports.jsx(PresenceChild, { isPresent, initial: !isInitialRender.current || initial ? void 0 : false, custom, presenceAffectsLayout, mode, root, onExitComplete: isPresent ? void 0 : onExit, anchorX, children: child }, key2);
  }) });
};
const LazyContext = reactExports.createContext({ strict: false });
const featureProps = {
  animation: [
    "animate",
    "variants",
    "whileHover",
    "whileTap",
    "exit",
    "whileInView",
    "whileFocus",
    "whileDrag"
  ],
  exit: ["exit"],
  drag: ["drag", "dragControls"],
  focus: ["whileFocus"],
  hover: ["whileHover", "onHoverStart", "onHoverEnd"],
  tap: ["whileTap", "onTap", "onTapStart", "onTapCancel"],
  pan: ["onPan", "onPanStart", "onPanSessionStart", "onPanEnd"],
  inView: ["whileInView", "onViewportEnter", "onViewportLeave"],
  layout: ["layout", "layoutId"]
};
const featureDefinitions = {};
for (const key2 in featureProps) {
  featureDefinitions[key2] = {
    isEnabled: (props) => featureProps[key2].some((name) => !!props[name])
  };
}
function loadFeatures(features) {
  for (const key2 in features) {
    featureDefinitions[key2] = {
      ...featureDefinitions[key2],
      ...features[key2]
    };
  }
}
function LazyMotion({ children, features, strict = false }) {
  const [, setIsLoaded] = reactExports.useState(!isLazyBundle(features));
  const loadedRenderer = reactExports.useRef(void 0);
  if (!isLazyBundle(features)) {
    const { renderer, ...loadedFeatures } = features;
    loadedRenderer.current = renderer;
    loadFeatures(loadedFeatures);
  }
  reactExports.useEffect(() => {
    if (isLazyBundle(features)) {
      features().then(({ renderer, ...loadedFeatures }) => {
        loadFeatures(loadedFeatures);
        loadedRenderer.current = renderer;
        setIsLoaded(true);
      });
    }
  }, []);
  return jsxRuntimeExports.jsx(LazyContext.Provider, { value: { renderer: loadedRenderer.current, strict }, children });
}
function isLazyBundle(features) {
  return typeof features === "function";
}
const validMotionProps = /* @__PURE__ */ new Set([
  "animate",
  "exit",
  "variants",
  "initial",
  "style",
  "values",
  "variants",
  "transition",
  "transformTemplate",
  "custom",
  "inherit",
  "onBeforeLayoutMeasure",
  "onAnimationStart",
  "onAnimationComplete",
  "onUpdate",
  "onDragStart",
  "onDrag",
  "onDragEnd",
  "onMeasureDragConstraints",
  "onDirectionLock",
  "onDragTransitionEnd",
  "_dragX",
  "_dragY",
  "onHoverStart",
  "onHoverEnd",
  "onViewportEnter",
  "onViewportLeave",
  "globalTapTarget",
  "ignoreStrict",
  "viewport"
]);
function isValidMotionProp(key2) {
  return key2.startsWith("while") || key2.startsWith("drag") && key2 !== "draggable" || key2.startsWith("layout") || key2.startsWith("onTap") || key2.startsWith("onPan") || key2.startsWith("onLayout") || validMotionProps.has(key2);
}
let shouldForward = (key2) => !isValidMotionProp(key2);
function loadExternalIsValidProp(isValidProp) {
  if (typeof isValidProp !== "function")
    return;
  shouldForward = (key2) => key2.startsWith("on") ? !isValidMotionProp(key2) : isValidProp(key2);
}
try {
  loadExternalIsValidProp(require("@emotion/is-prop-valid").default);
} catch {
}
function filterProps(props, isDom, forwardMotionProps) {
  const filteredProps = {};
  for (const key2 in props) {
    if (key2 === "values" && typeof props.values === "object")
      continue;
    if (shouldForward(key2) || forwardMotionProps === true && isValidMotionProp(key2) || !isDom && !isValidMotionProp(key2) || // If trying to use native HTML drag events, forward drag listeners
    props["draggable"] && key2.startsWith("onDrag")) {
      filteredProps[key2] = props[key2];
    }
  }
  return filteredProps;
}
function createDOMMotionComponentProxy(componentFactory) {
  if (typeof Proxy === "undefined") {
    return componentFactory;
  }
  const componentCache2 = /* @__PURE__ */ new Map();
  const deprecatedFactoryFunction = (...args) => {
    return componentFactory(...args);
  };
  return new Proxy(deprecatedFactoryFunction, {
    /**
     * Called when `motion` is referenced with a prop: `motion.div`, `motion.input` etc.
     * The prop name is passed through as `key` and we can use that to generate a `motion`
     * DOM component with that name.
     */
    get: (_target, key2) => {
      if (key2 === "create")
        return componentFactory;
      if (!componentCache2.has(key2)) {
        componentCache2.set(key2, componentFactory(key2));
      }
      return componentCache2.get(key2);
    }
  });
}
const MotionContext = /* @__PURE__ */ reactExports.createContext({});
function isAnimationControls(v2) {
  return v2 !== null && typeof v2 === "object" && typeof v2.start === "function";
}
function isVariantLabel(v2) {
  return typeof v2 === "string" || Array.isArray(v2);
}
const variantPriorityOrder = [
  "animate",
  "whileInView",
  "whileFocus",
  "whileHover",
  "whileTap",
  "whileDrag",
  "exit"
];
const variantProps = ["initial", ...variantPriorityOrder];
function isControllingVariants(props) {
  return isAnimationControls(props.animate) || variantProps.some((name) => isVariantLabel(props[name]));
}
function isVariantNode(props) {
  return Boolean(isControllingVariants(props) || props.variants);
}
function getCurrentTreeVariants(props, context) {
  if (isControllingVariants(props)) {
    const { initial, animate: animate2 } = props;
    return {
      initial: initial === false || isVariantLabel(initial) ? initial : void 0,
      animate: isVariantLabel(animate2) ? animate2 : void 0
    };
  }
  return props.inherit !== false ? context : {};
}
function useCreateMotionContext(props) {
  const { initial, animate: animate2 } = getCurrentTreeVariants(props, reactExports.useContext(MotionContext));
  return reactExports.useMemo(() => ({ initial, animate: animate2 }), [variantLabelsAsDependency(initial), variantLabelsAsDependency(animate2)]);
}
function variantLabelsAsDependency(prop) {
  return Array.isArray(prop) ? prop.join(" ") : prop;
}
const motionComponentSymbol = Symbol.for("motionComponentSymbol");
function isRefObject(ref) {
  return ref && typeof ref === "object" && Object.prototype.hasOwnProperty.call(ref, "current");
}
function useMotionRef(visualState, visualElement, externalRef) {
  return reactExports.useCallback(
    (instance) => {
      if (instance) {
        visualState.onMount && visualState.onMount(instance);
      }
      if (visualElement) {
        if (instance) {
          visualElement.mount(instance);
        } else {
          visualElement.unmount();
        }
      }
      if (externalRef) {
        if (typeof externalRef === "function") {
          externalRef(instance);
        } else if (isRefObject(externalRef)) {
          externalRef.current = instance;
        }
      }
    },
    /**
     * Only pass a new ref callback to React if we've received a visual element
     * factory. Otherwise we'll be mounting/remounting every time externalRef
     * or other dependencies change.
     */
    [visualElement]
  );
}
const camelToDash = (str) => str.replace(/([a-z])([A-Z])/gu, "$1-$2").toLowerCase();
const optimizedAppearDataId = "framerAppearId";
const optimizedAppearDataAttribute = "data-" + camelToDash(optimizedAppearDataId);
const SwitchLayoutGroupContext = reactExports.createContext({});
function useVisualElement(Component, visualState, props, createVisualElement, ProjectionNodeConstructor) {
  const { visualElement: parent2 } = reactExports.useContext(MotionContext);
  const lazyContext = reactExports.useContext(LazyContext);
  const presenceContext = reactExports.useContext(PresenceContext);
  const reducedMotionConfig = reactExports.useContext(MotionConfigContext).reducedMotion;
  const visualElementRef = reactExports.useRef(null);
  createVisualElement = createVisualElement || lazyContext.renderer;
  if (!visualElementRef.current && createVisualElement) {
    visualElementRef.current = createVisualElement(Component, {
      visualState,
      parent: parent2,
      props,
      presenceContext,
      blockInitialAnimation: presenceContext ? presenceContext.initial === false : false,
      reducedMotionConfig
    });
  }
  const visualElement = visualElementRef.current;
  const initialLayoutGroupConfig = reactExports.useContext(SwitchLayoutGroupContext);
  if (visualElement && !visualElement.projection && ProjectionNodeConstructor && (visualElement.type === "html" || visualElement.type === "svg")) {
    createProjectionNode$1(visualElementRef.current, props, ProjectionNodeConstructor, initialLayoutGroupConfig);
  }
  const isMounted = reactExports.useRef(false);
  reactExports.useInsertionEffect(() => {
    if (visualElement && isMounted.current) {
      visualElement.update(props, presenceContext);
    }
  });
  const optimisedAppearId = props[optimizedAppearDataAttribute];
  const wantsHandoff = reactExports.useRef(Boolean(optimisedAppearId) && !window.MotionHandoffIsComplete?.(optimisedAppearId) && window.MotionHasOptimisedAnimation?.(optimisedAppearId));
  useIsomorphicLayoutEffect$1(() => {
    if (!visualElement)
      return;
    isMounted.current = true;
    window.MotionIsMounted = true;
    visualElement.updateFeatures();
    microtask.render(visualElement.render);
    if (wantsHandoff.current && visualElement.animationState) {
      visualElement.animationState.animateChanges();
    }
  });
  reactExports.useEffect(() => {
    if (!visualElement)
      return;
    if (!wantsHandoff.current && visualElement.animationState) {
      visualElement.animationState.animateChanges();
    }
    if (wantsHandoff.current) {
      queueMicrotask(() => {
        window.MotionHandoffMarkAsComplete?.(optimisedAppearId);
      });
      wantsHandoff.current = false;
    }
  });
  return visualElement;
}
function createProjectionNode$1(visualElement, props, ProjectionNodeConstructor, initialPromotionConfig) {
  const { layoutId, layout: layout2, drag: drag2, dragConstraints, layoutScroll, layoutRoot, layoutCrossfade } = props;
  visualElement.projection = new ProjectionNodeConstructor(visualElement.latestValues, props["data-framer-portal-id"] ? void 0 : getClosestProjectingNode(visualElement.parent));
  visualElement.projection.setOptions({
    layoutId,
    layout: layout2,
    alwaysMeasureLayout: Boolean(drag2) || dragConstraints && isRefObject(dragConstraints),
    visualElement,
    /**
     * TODO: Update options in an effect. This could be tricky as it'll be too late
     * to update by the time layout animations run.
     * We also need to fix this safeToRemove by linking it up to the one returned by usePresence,
     * ensuring it gets called if there's no potential layout animations.
     *
     */
    animationType: typeof layout2 === "string" ? layout2 : "both",
    initialPromotionConfig,
    crossfade: layoutCrossfade,
    layoutScroll,
    layoutRoot
  });
}
function getClosestProjectingNode(visualElement) {
  if (!visualElement)
    return void 0;
  return visualElement.options.allowProjection !== false ? visualElement.projection : getClosestProjectingNode(visualElement.parent);
}
function createRendererMotionComponent({ preloadedFeatures, createVisualElement, useRender, useVisualState, Component }) {
  preloadedFeatures && loadFeatures(preloadedFeatures);
  function MotionComponent(props, externalRef) {
    let MeasureLayout2;
    const configAndProps = {
      ...reactExports.useContext(MotionConfigContext),
      ...props,
      layoutId: useLayoutId(props)
    };
    const { isStatic } = configAndProps;
    const context = useCreateMotionContext(props);
    const visualState = useVisualState(props, isStatic);
    if (!isStatic && isBrowser$2) {
      useStrictMode();
      const layoutProjection = getProjectionFunctionality(configAndProps);
      MeasureLayout2 = layoutProjection.MeasureLayout;
      context.visualElement = useVisualElement(Component, visualState, configAndProps, createVisualElement, layoutProjection.ProjectionNode);
    }
    return jsxRuntimeExports.jsxs(MotionContext.Provider, { value: context, children: [MeasureLayout2 && context.visualElement ? jsxRuntimeExports.jsx(MeasureLayout2, { visualElement: context.visualElement, ...configAndProps }) : null, useRender(Component, props, useMotionRef(visualState, context.visualElement, externalRef), visualState, isStatic, context.visualElement)] });
  }
  MotionComponent.displayName = `motion.${typeof Component === "string" ? Component : `create(${Component.displayName ?? Component.name ?? ""})`}`;
  const ForwardRefMotionComponent = reactExports.forwardRef(MotionComponent);
  ForwardRefMotionComponent[motionComponentSymbol] = Component;
  return ForwardRefMotionComponent;
}
function useLayoutId({ layoutId }) {
  const layoutGroupId = reactExports.useContext(LayoutGroupContext).id;
  return layoutGroupId && layoutId !== void 0 ? layoutGroupId + "-" + layoutId : layoutId;
}
function useStrictMode(configAndProps, preloadedFeatures) {
  reactExports.useContext(LazyContext).strict;
}
function getProjectionFunctionality(props) {
  const { drag: drag2, layout: layout2 } = featureDefinitions;
  if (!drag2 && !layout2)
    return {};
  const combined = { ...drag2, ...layout2 };
  return {
    MeasureLayout: drag2?.isEnabled(props) || layout2?.isEnabled(props) ? combined.MeasureLayout : void 0,
    ProjectionNode: combined.ProjectionNode
  };
}
const scaleCorrectors = {};
function addScaleCorrector(correctors) {
  for (const key2 in correctors) {
    scaleCorrectors[key2] = correctors[key2];
    if (isCSSVariableName(key2)) {
      scaleCorrectors[key2].isCSSVariable = true;
    }
  }
}
function isForcedMotionValue(key2, { layout: layout2, layoutId }) {
  return transformProps.has(key2) || key2.startsWith("origin") || (layout2 || layoutId !== void 0) && (!!scaleCorrectors[key2] || key2 === "opacity");
}
const translateAlias = {
  x: "translateX",
  y: "translateY",
  z: "translateZ",
  transformPerspective: "perspective"
};
const numTransforms = transformPropOrder.length;
function buildTransform(latestValues, transform2, transformTemplate) {
  let transformString = "";
  let transformIsDefault = true;
  for (let i2 = 0; i2 < numTransforms; i2++) {
    const key2 = transformPropOrder[i2];
    const value = latestValues[key2];
    if (value === void 0)
      continue;
    let valueIsDefault = true;
    if (typeof value === "number") {
      valueIsDefault = value === (key2.startsWith("scale") ? 1 : 0);
    } else {
      valueIsDefault = parseFloat(value) === 0;
    }
    if (!valueIsDefault || transformTemplate) {
      const valueAsType = getValueAsType(value, numberValueTypes[key2]);
      if (!valueIsDefault) {
        transformIsDefault = false;
        const transformName = translateAlias[key2] || key2;
        transformString += `${transformName}(${valueAsType}) `;
      }
      if (transformTemplate) {
        transform2[key2] = valueAsType;
      }
    }
  }
  transformString = transformString.trim();
  if (transformTemplate) {
    transformString = transformTemplate(transform2, transformIsDefault ? "" : transformString);
  } else if (transformIsDefault) {
    transformString = "none";
  }
  return transformString;
}
function buildHTMLStyles(state, latestValues, transformTemplate) {
  const { style: style2, vars, transformOrigin: transformOrigin2 } = state;
  let hasTransform2 = false;
  let hasTransformOrigin = false;
  for (const key2 in latestValues) {
    const value = latestValues[key2];
    if (transformProps.has(key2)) {
      hasTransform2 = true;
      continue;
    } else if (isCSSVariableName(key2)) {
      vars[key2] = value;
      continue;
    } else {
      const valueAsType = getValueAsType(value, numberValueTypes[key2]);
      if (key2.startsWith("origin")) {
        hasTransformOrigin = true;
        transformOrigin2[key2] = valueAsType;
      } else {
        style2[key2] = valueAsType;
      }
    }
  }
  if (!latestValues.transform) {
    if (hasTransform2 || transformTemplate) {
      style2.transform = buildTransform(latestValues, state.transform, transformTemplate);
    } else if (style2.transform) {
      style2.transform = "none";
    }
  }
  if (hasTransformOrigin) {
    const { originX = "50%", originY = "50%", originZ = 0 } = transformOrigin2;
    style2.transformOrigin = `${originX} ${originY} ${originZ}`;
  }
}
const createHtmlRenderState = () => ({
  style: {},
  transform: {},
  transformOrigin: {},
  vars: {}
});
function copyRawValuesOnly(target, source, props) {
  for (const key2 in source) {
    if (!isMotionValue(source[key2]) && !isForcedMotionValue(key2, props)) {
      target[key2] = source[key2];
    }
  }
}
function useInitialMotionValues({ transformTemplate }, visualState) {
  return reactExports.useMemo(() => {
    const state = createHtmlRenderState();
    buildHTMLStyles(state, visualState, transformTemplate);
    return Object.assign({}, state.vars, state.style);
  }, [visualState]);
}
function useStyle(props, visualState) {
  const styleProp = props.style || {};
  const style2 = {};
  copyRawValuesOnly(style2, styleProp, props);
  Object.assign(style2, useInitialMotionValues(props, visualState));
  return style2;
}
function useHTMLProps(props, visualState) {
  const htmlProps = {};
  const style2 = useStyle(props, visualState);
  if (props.drag && props.dragListener !== false) {
    htmlProps.draggable = false;
    style2.userSelect = style2.WebkitUserSelect = style2.WebkitTouchCallout = "none";
    style2.touchAction = props.drag === true ? "none" : `pan-${props.drag === "x" ? "y" : "x"}`;
  }
  if (props.tabIndex === void 0 && (props.onTap || props.onTapStart || props.whileTap)) {
    htmlProps.tabIndex = 0;
  }
  htmlProps.style = style2;
  return htmlProps;
}
const dashKeys = {
  offset: "stroke-dashoffset",
  array: "stroke-dasharray"
};
const camelKeys = {
  offset: "strokeDashoffset",
  array: "strokeDasharray"
};
function buildSVGPath(attrs, length2, spacing = 1, offset2 = 0, useDashCase = true) {
  attrs.pathLength = 1;
  const keys = useDashCase ? dashKeys : camelKeys;
  attrs[keys.offset] = px.transform(-offset2);
  const pathLength = px.transform(length2);
  const pathSpacing = px.transform(spacing);
  attrs[keys.array] = `${pathLength} ${pathSpacing}`;
}
function buildSVGAttrs(state, {
  attrX,
  attrY,
  attrScale,
  pathLength,
  pathSpacing = 1,
  pathOffset = 0,
  // This is object creation, which we try to avoid per-frame.
  ...latest
}, isSVGTag2, transformTemplate, styleProp) {
  buildHTMLStyles(state, latest, transformTemplate);
  if (isSVGTag2) {
    if (state.style.viewBox) {
      state.attrs.viewBox = state.style.viewBox;
    }
    return;
  }
  state.attrs = state.style;
  state.style = {};
  const { attrs, style: style2 } = state;
  if (attrs.transform) {
    style2.transform = attrs.transform;
    delete attrs.transform;
  }
  if (style2.transform || attrs.transformOrigin) {
    style2.transformOrigin = attrs.transformOrigin ?? "50% 50%";
    delete attrs.transformOrigin;
  }
  if (style2.transform) {
    style2.transformBox = styleProp?.transformBox ?? "fill-box";
    delete attrs.transformBox;
  }
  if (attrX !== void 0)
    attrs.x = attrX;
  if (attrY !== void 0)
    attrs.y = attrY;
  if (attrScale !== void 0)
    attrs.scale = attrScale;
  if (pathLength !== void 0) {
    buildSVGPath(attrs, pathLength, pathSpacing, pathOffset, false);
  }
}
const createSvgRenderState = () => ({
  ...createHtmlRenderState(),
  attrs: {}
});
const isSVGTag = (tag) => typeof tag === "string" && tag.toLowerCase() === "svg";
function useSVGProps(props, visualState, _isStatic, Component) {
  const visualProps = reactExports.useMemo(() => {
    const state = createSvgRenderState();
    buildSVGAttrs(state, visualState, isSVGTag(Component), props.transformTemplate, props.style);
    return {
      ...state.attrs,
      style: { ...state.style }
    };
  }, [visualState]);
  if (props.style) {
    const rawStyles = {};
    copyRawValuesOnly(rawStyles, props.style, props);
    visualProps.style = { ...rawStyles, ...visualProps.style };
  }
  return visualProps;
}
const lowercaseSVGElements = [
  "animate",
  "circle",
  "defs",
  "desc",
  "ellipse",
  "g",
  "image",
  "line",
  "filter",
  "marker",
  "mask",
  "metadata",
  "path",
  "pattern",
  "polygon",
  "polyline",
  "rect",
  "stop",
  "switch",
  "symbol",
  "svg",
  "text",
  "tspan",
  "use",
  "view"
];
function isSVGComponent(Component) {
  if (
    /**
     * If it's not a string, it's a custom React component. Currently we only support
     * HTML custom React components.
     */
    typeof Component !== "string" || /**
     * If it contains a dash, the element is a custom HTML webcomponent.
     */
    Component.includes("-")
  ) {
    return false;
  } else if (
    /**
     * If it's in our list of lowercase SVG tags, it's an SVG component
     */
    lowercaseSVGElements.indexOf(Component) > -1 || /**
     * If it contains a capital letter, it's an SVG component
     */
    /[A-Z]/u.test(Component)
  ) {
    return true;
  }
  return false;
}
function createUseRender(forwardMotionProps = false) {
  const useRender = (Component, props, ref, { latestValues }, isStatic) => {
    const useVisualProps = isSVGComponent(Component) ? useSVGProps : useHTMLProps;
    const visualProps = useVisualProps(props, latestValues, isStatic, Component);
    const filteredProps = filterProps(props, typeof Component === "string", forwardMotionProps);
    const elementProps = Component !== reactExports.Fragment ? { ...filteredProps, ...visualProps, ref } : {};
    const { children } = props;
    const renderedChildren = reactExports.useMemo(() => isMotionValue(children) ? children.get() : children, [children]);
    return reactExports.createElement(Component, {
      ...elementProps,
      children: renderedChildren
    });
  };
  return useRender;
}
function getValueState(visualElement) {
  const state = [{}, {}];
  visualElement?.values.forEach((value, key2) => {
    state[0][key2] = value.get();
    state[1][key2] = value.getVelocity();
  });
  return state;
}
function resolveVariantFromProps(props, definition, custom, visualElement) {
  if (typeof definition === "function") {
    const [current, velocity] = getValueState(visualElement);
    definition = definition(custom !== void 0 ? custom : props.custom, current, velocity);
  }
  if (typeof definition === "string") {
    definition = props.variants && props.variants[definition];
  }
  if (typeof definition === "function") {
    const [current, velocity] = getValueState(visualElement);
    definition = definition(custom !== void 0 ? custom : props.custom, current, velocity);
  }
  return definition;
}
function resolveMotionValue(value) {
  return isMotionValue(value) ? value.get() : value;
}
function makeState({ scrapeMotionValuesFromProps: scrapeMotionValuesFromProps2, createRenderState }, props, context, presenceContext) {
  const state = {
    latestValues: makeLatestValues(props, context, presenceContext, scrapeMotionValuesFromProps2),
    renderState: createRenderState()
  };
  return state;
}
const makeUseVisualState = (config2) => (props, isStatic) => {
  const context = reactExports.useContext(MotionContext);
  const presenceContext = reactExports.useContext(PresenceContext);
  const make = () => makeState(config2, props, context, presenceContext);
  return isStatic ? make() : useConstant(make);
};
function makeLatestValues(props, context, presenceContext, scrapeMotionValues) {
  const values2 = {};
  const motionValues = scrapeMotionValues(props, {});
  for (const key2 in motionValues) {
    values2[key2] = resolveMotionValue(motionValues[key2]);
  }
  let { initial, animate: animate2 } = props;
  const isControllingVariants$1 = isControllingVariants(props);
  const isVariantNode$1 = isVariantNode(props);
  if (context && isVariantNode$1 && !isControllingVariants$1 && props.inherit !== false) {
    if (initial === void 0)
      initial = context.initial;
    if (animate2 === void 0)
      animate2 = context.animate;
  }
  let isInitialAnimationBlocked = presenceContext ? presenceContext.initial === false : false;
  isInitialAnimationBlocked = isInitialAnimationBlocked || initial === false;
  const variantToSet = isInitialAnimationBlocked ? animate2 : initial;
  if (variantToSet && typeof variantToSet !== "boolean" && !isAnimationControls(variantToSet)) {
    const list = Array.isArray(variantToSet) ? variantToSet : [variantToSet];
    for (let i2 = 0; i2 < list.length; i2++) {
      const resolved = resolveVariantFromProps(props, list[i2]);
      if (resolved) {
        const { transitionEnd, transition, ...target } = resolved;
        for (const key2 in target) {
          let valueTarget = target[key2];
          if (Array.isArray(valueTarget)) {
            const index2 = isInitialAnimationBlocked ? valueTarget.length - 1 : 0;
            valueTarget = valueTarget[index2];
          }
          if (valueTarget !== null) {
            values2[key2] = valueTarget;
          }
        }
        for (const key2 in transitionEnd) {
          values2[key2] = transitionEnd[key2];
        }
      }
    }
  }
  return values2;
}
function scrapeMotionValuesFromProps$1(props, prevProps, visualElement) {
  const { style: style2 } = props;
  const newValues = {};
  for (const key2 in style2) {
    if (isMotionValue(style2[key2]) || prevProps.style && isMotionValue(prevProps.style[key2]) || isForcedMotionValue(key2, props) || visualElement?.getValue(key2)?.liveStyle !== void 0) {
      newValues[key2] = style2[key2];
    }
  }
  return newValues;
}
const htmlMotionConfig = {
  useVisualState: makeUseVisualState({
    scrapeMotionValuesFromProps: scrapeMotionValuesFromProps$1,
    createRenderState: createHtmlRenderState
  })
};
function scrapeMotionValuesFromProps(props, prevProps, visualElement) {
  const newValues = scrapeMotionValuesFromProps$1(props, prevProps, visualElement);
  for (const key2 in props) {
    if (isMotionValue(props[key2]) || isMotionValue(prevProps[key2])) {
      const targetKey = transformPropOrder.indexOf(key2) !== -1 ? "attr" + key2.charAt(0).toUpperCase() + key2.substring(1) : key2;
      newValues[targetKey] = props[key2];
    }
  }
  return newValues;
}
const svgMotionConfig = {
  useVisualState: makeUseVisualState({
    scrapeMotionValuesFromProps,
    createRenderState: createSvgRenderState
  })
};
function createMotionComponentFactory(preloadedFeatures, createVisualElement) {
  return function createMotionComponent2(Component, { forwardMotionProps } = { forwardMotionProps: false }) {
    const baseConfig = isSVGComponent(Component) ? svgMotionConfig : htmlMotionConfig;
    const config2 = {
      ...baseConfig,
      preloadedFeatures,
      useRender: createUseRender(forwardMotionProps),
      createVisualElement,
      Component
    };
    return createRendererMotionComponent(config2);
  };
}
const createMinimalMotionComponent = /* @__PURE__ */ createMotionComponentFactory();
const m$1 = /* @__PURE__ */ createDOMMotionComponentProxy(createMinimalMotionComponent);
function resolveVariant(visualElement, definition, custom) {
  const props = visualElement.getProps();
  return resolveVariantFromProps(props, definition, custom !== void 0 ? custom : props.custom, visualElement);
}
const isKeyframesTarget = (v2) => {
  return Array.isArray(v2);
};
function setMotionValue(visualElement, key2, value) {
  if (visualElement.hasValue(key2)) {
    visualElement.getValue(key2).set(value);
  } else {
    visualElement.addValue(key2, motionValue(value));
  }
}
function resolveFinalValueInKeyframes(v2) {
  return isKeyframesTarget(v2) ? v2[v2.length - 1] || 0 : v2;
}
function setTarget(visualElement, definition) {
  const resolved = resolveVariant(visualElement, definition);
  let { transitionEnd = {}, transition = {}, ...target } = resolved || {};
  target = { ...target, ...transitionEnd };
  for (const key2 in target) {
    const value = resolveFinalValueInKeyframes(target[key2]);
    setMotionValue(visualElement, key2, value);
  }
}
function isWillChangeMotionValue(value) {
  return Boolean(isMotionValue(value) && value.add);
}
function addValueToWillChange(visualElement, key2) {
  const willChange = visualElement.getValue("willChange");
  if (isWillChangeMotionValue(willChange)) {
    return willChange.add(key2);
  } else if (!willChange && MotionGlobalConfig.WillChange) {
    const newWillChange = new MotionGlobalConfig.WillChange("auto");
    visualElement.addValue("willChange", newWillChange);
    newWillChange.add(key2);
  }
}
function getOptimisedAppearId(visualElement) {
  return visualElement.props[optimizedAppearDataAttribute];
}
const isNotNull$1 = (value) => value !== null;
function getFinalKeyframe(keyframes2, { repeat, repeatType = "loop" }, finalKeyframe) {
  const resolvedKeyframes = keyframes2.filter(isNotNull$1);
  const index2 = repeat && repeatType !== "loop" && repeat % 2 === 1 ? 0 : resolvedKeyframes.length - 1;
  return !index2 || finalKeyframe === void 0 ? resolvedKeyframes[index2] : finalKeyframe;
}
const underDampedSpring = {
  type: "spring",
  stiffness: 500,
  damping: 25,
  restSpeed: 10
};
const criticallyDampedSpring = (target) => ({
  type: "spring",
  stiffness: 550,
  damping: target === 0 ? 2 * Math.sqrt(550) : 30,
  restSpeed: 10
});
const keyframesTransition = {
  type: "keyframes",
  duration: 0.8
};
const ease = {
  type: "keyframes",
  ease: [0.25, 0.1, 0.35, 1],
  duration: 0.3
};
const getDefaultTransition = (valueKey, { keyframes: keyframes2 }) => {
  if (keyframes2.length > 2) {
    return keyframesTransition;
  } else if (transformProps.has(valueKey)) {
    return valueKey.startsWith("scale") ? criticallyDampedSpring(keyframes2[1]) : underDampedSpring;
  }
  return ease;
};
function isTransitionDefined({ when, delay: _delay, delayChildren, staggerChildren, staggerDirection, repeat, repeatType, repeatDelay, from: from2, elapsed, ...transition }) {
  return !!Object.keys(transition).length;
}
const animateMotionValue = (name, value, target, transition = {}, element, isHandoff) => (onComplete) => {
  const valueTransition = getValueTransition(transition, name) || {};
  const delay2 = valueTransition.delay || transition.delay || 0;
  let { elapsed = 0 } = transition;
  elapsed = elapsed - /* @__PURE__ */ secondsToMilliseconds(delay2);
  const options = {
    keyframes: Array.isArray(target) ? target : [null, target],
    ease: "easeOut",
    velocity: value.getVelocity(),
    ...valueTransition,
    delay: -elapsed,
    onUpdate: (v2) => {
      value.set(v2);
      valueTransition.onUpdate && valueTransition.onUpdate(v2);
    },
    onComplete: () => {
      onComplete();
      valueTransition.onComplete && valueTransition.onComplete();
    },
    name,
    motionValue: value,
    element: isHandoff ? void 0 : element
  };
  if (!isTransitionDefined(valueTransition)) {
    Object.assign(options, getDefaultTransition(name, options));
  }
  options.duration && (options.duration = /* @__PURE__ */ secondsToMilliseconds(options.duration));
  options.repeatDelay && (options.repeatDelay = /* @__PURE__ */ secondsToMilliseconds(options.repeatDelay));
  if (options.from !== void 0) {
    options.keyframes[0] = options.from;
  }
  let shouldSkip = false;
  if (options.type === false || options.duration === 0 && !options.repeatDelay) {
    options.duration = 0;
    if (options.delay === 0) {
      shouldSkip = true;
    }
  }
  if (MotionGlobalConfig.instantAnimations || MotionGlobalConfig.skipAnimations) {
    shouldSkip = true;
    options.duration = 0;
    options.delay = 0;
  }
  options.allowFlatten = !valueTransition.type && !valueTransition.ease;
  if (shouldSkip && !isHandoff && value.get() !== void 0) {
    const finalKeyframe = getFinalKeyframe(options.keyframes, valueTransition);
    if (finalKeyframe !== void 0) {
      frame.update(() => {
        options.onUpdate(finalKeyframe);
        options.onComplete();
      });
      return;
    }
  }
  return valueTransition.isSync ? new JSAnimation$1(options) : new AsyncMotionValueAnimation(options);
};
function shouldBlockAnimation({ protectedKeys, needsAnimating }, key2) {
  const shouldBlock = protectedKeys.hasOwnProperty(key2) && needsAnimating[key2] !== true;
  needsAnimating[key2] = false;
  return shouldBlock;
}
function animateTarget(visualElement, targetAndTransition, { delay: delay2 = 0, transitionOverride, type } = {}) {
  let { transition = visualElement.getDefaultTransition(), transitionEnd, ...target } = targetAndTransition;
  if (transitionOverride)
    transition = transitionOverride;
  const animations2 = [];
  const animationTypeState = type && visualElement.animationState && visualElement.animationState.getState()[type];
  for (const key2 in target) {
    const value = visualElement.getValue(key2, visualElement.latestValues[key2] ?? null);
    const valueTarget = target[key2];
    if (valueTarget === void 0 || animationTypeState && shouldBlockAnimation(animationTypeState, key2)) {
      continue;
    }
    const valueTransition = {
      delay: delay2,
      ...getValueTransition(transition || {}, key2)
    };
    const currentValue = value.get();
    if (currentValue !== void 0 && !value.isAnimating && !Array.isArray(valueTarget) && valueTarget === currentValue && !valueTransition.velocity) {
      continue;
    }
    let isHandoff = false;
    if (window.MotionHandoffAnimation) {
      const appearId = getOptimisedAppearId(visualElement);
      if (appearId) {
        const startTime = window.MotionHandoffAnimation(appearId, key2, frame);
        if (startTime !== null) {
          valueTransition.startTime = startTime;
          isHandoff = true;
        }
      }
    }
    addValueToWillChange(visualElement, key2);
    value.start(animateMotionValue(key2, value, valueTarget, visualElement.shouldReduceMotion && positionalKeys.has(key2) ? { type: false } : valueTransition, visualElement, isHandoff));
    const animation = value.animation;
    if (animation) {
      animations2.push(animation);
    }
  }
  if (transitionEnd) {
    Promise.all(animations2).then(() => {
      frame.update(() => {
        transitionEnd && setTarget(visualElement, transitionEnd);
      });
    });
  }
  return animations2;
}
function animateVariant(visualElement, variant, options = {}) {
  const resolved = resolveVariant(visualElement, variant, options.type === "exit" ? visualElement.presenceContext?.custom : void 0);
  let { transition = visualElement.getDefaultTransition() || {} } = resolved || {};
  if (options.transitionOverride) {
    transition = options.transitionOverride;
  }
  const getAnimation = resolved ? () => Promise.all(animateTarget(visualElement, resolved, options)) : () => Promise.resolve();
  const getChildAnimations = visualElement.variantChildren && visualElement.variantChildren.size ? (forwardDelay = 0) => {
    const { delayChildren = 0, staggerChildren, staggerDirection } = transition;
    return animateChildren(visualElement, variant, forwardDelay, delayChildren, staggerChildren, staggerDirection, options);
  } : () => Promise.resolve();
  const { when } = transition;
  if (when) {
    const [first, last] = when === "beforeChildren" ? [getAnimation, getChildAnimations] : [getChildAnimations, getAnimation];
    return first().then(() => last());
  } else {
    return Promise.all([getAnimation(), getChildAnimations(options.delay)]);
  }
}
function animateChildren(visualElement, variant, delay2 = 0, delayChildren = 0, staggerChildren = 0, staggerDirection = 1, options) {
  const animations2 = [];
  const numChildren = visualElement.variantChildren.size;
  const maxStaggerDuration = (numChildren - 1) * staggerChildren;
  const delayIsFunction = typeof delayChildren === "function";
  const generateStaggerDuration = delayIsFunction ? (i2) => delayChildren(i2, numChildren) : (
    // Support deprecated staggerChildren
    staggerDirection === 1 ? (i2 = 0) => i2 * staggerChildren : (i2 = 0) => maxStaggerDuration - i2 * staggerChildren
  );
  Array.from(visualElement.variantChildren).sort(sortByTreeOrder).forEach((child, i2) => {
    child.notify("AnimationStart", variant);
    animations2.push(animateVariant(child, variant, {
      ...options,
      delay: delay2 + (delayIsFunction ? 0 : delayChildren) + generateStaggerDuration(i2)
    }).then(() => child.notify("AnimationComplete", variant)));
  });
  return Promise.all(animations2);
}
function sortByTreeOrder(a2, b2) {
  return a2.sortNodePosition(b2);
}
function animateVisualElement(visualElement, definition, options = {}) {
  visualElement.notify("AnimationStart", definition);
  let animation;
  if (Array.isArray(definition)) {
    const animations2 = definition.map((variant) => animateVariant(visualElement, variant, options));
    animation = Promise.all(animations2);
  } else if (typeof definition === "string") {
    animation = animateVariant(visualElement, definition, options);
  } else {
    const resolvedDefinition = typeof definition === "function" ? resolveVariant(visualElement, definition, options.custom) : definition;
    animation = Promise.all(animateTarget(visualElement, resolvedDefinition, options));
  }
  return animation.then(() => {
    visualElement.notify("AnimationComplete", definition);
  });
}
function shallowCompare(next2, prev2) {
  if (!Array.isArray(prev2))
    return false;
  const prevLength = prev2.length;
  if (prevLength !== next2.length)
    return false;
  for (let i2 = 0; i2 < prevLength; i2++) {
    if (prev2[i2] !== next2[i2])
      return false;
  }
  return true;
}
const numVariantProps = variantProps.length;
function getVariantContext(visualElement) {
  if (!visualElement)
    return void 0;
  if (!visualElement.isControllingVariants) {
    const context2 = visualElement.parent ? getVariantContext(visualElement.parent) || {} : {};
    if (visualElement.props.initial !== void 0) {
      context2.initial = visualElement.props.initial;
    }
    return context2;
  }
  const context = {};
  for (let i2 = 0; i2 < numVariantProps; i2++) {
    const name = variantProps[i2];
    const prop = visualElement.props[name];
    if (isVariantLabel(prop) || prop === false) {
      context[name] = prop;
    }
  }
  return context;
}
const reversePriorityOrder = [...variantPriorityOrder].reverse();
const numAnimationTypes = variantPriorityOrder.length;
function animateList(visualElement) {
  return (animations2) => Promise.all(animations2.map(({ animation, options }) => animateVisualElement(visualElement, animation, options)));
}
function createAnimationState(visualElement) {
  let animate2 = animateList(visualElement);
  let state = createState();
  let isInitialRender = true;
  const buildResolvedTypeValues = (type) => (acc, definition) => {
    const resolved = resolveVariant(visualElement, definition, type === "exit" ? visualElement.presenceContext?.custom : void 0);
    if (resolved) {
      const { transition, transitionEnd, ...target } = resolved;
      acc = { ...acc, ...target, ...transitionEnd };
    }
    return acc;
  };
  function setAnimateFunction(makeAnimator) {
    animate2 = makeAnimator(visualElement);
  }
  function animateChanges(changedActiveType) {
    const { props } = visualElement;
    const context = getVariantContext(visualElement.parent) || {};
    const animations2 = [];
    const removedKeys = /* @__PURE__ */ new Set();
    let encounteredKeys = {};
    let removedVariantIndex = Infinity;
    for (let i2 = 0; i2 < numAnimationTypes; i2++) {
      const type = reversePriorityOrder[i2];
      const typeState = state[type];
      const prop = props[type] !== void 0 ? props[type] : context[type];
      const propIsVariant = isVariantLabel(prop);
      const activeDelta = type === changedActiveType ? typeState.isActive : null;
      if (activeDelta === false)
        removedVariantIndex = i2;
      let isInherited = prop === context[type] && prop !== props[type] && propIsVariant;
      if (isInherited && isInitialRender && visualElement.manuallyAnimateOnMount) {
        isInherited = false;
      }
      typeState.protectedKeys = { ...encounteredKeys };
      if (
        // If it isn't active and hasn't *just* been set as inactive
        !typeState.isActive && activeDelta === null || // If we didn't and don't have any defined prop for this animation type
        !prop && !typeState.prevProp || // Or if the prop doesn't define an animation
        isAnimationControls(prop) || typeof prop === "boolean"
      ) {
        continue;
      }
      const variantDidChange = checkVariantsDidChange(typeState.prevProp, prop);
      let shouldAnimateType = variantDidChange || // If we're making this variant active, we want to always make it active
      type === changedActiveType && typeState.isActive && !isInherited && propIsVariant || // If we removed a higher-priority variant (i is in reverse order)
      i2 > removedVariantIndex && propIsVariant;
      let handledRemovedValues = false;
      const definitionList = Array.isArray(prop) ? prop : [prop];
      let resolvedValues = definitionList.reduce(buildResolvedTypeValues(type), {});
      if (activeDelta === false)
        resolvedValues = {};
      const { prevResolvedValues = {} } = typeState;
      const allKeys = {
        ...prevResolvedValues,
        ...resolvedValues
      };
      const markToAnimate = (key2) => {
        shouldAnimateType = true;
        if (removedKeys.has(key2)) {
          handledRemovedValues = true;
          removedKeys.delete(key2);
        }
        typeState.needsAnimating[key2] = true;
        const motionValue2 = visualElement.getValue(key2);
        if (motionValue2)
          motionValue2.liveStyle = false;
      };
      for (const key2 in allKeys) {
        const next2 = resolvedValues[key2];
        const prev2 = prevResolvedValues[key2];
        if (encounteredKeys.hasOwnProperty(key2))
          continue;
        let valueHasChanged = false;
        if (isKeyframesTarget(next2) && isKeyframesTarget(prev2)) {
          valueHasChanged = !shallowCompare(next2, prev2);
        } else {
          valueHasChanged = next2 !== prev2;
        }
        if (valueHasChanged) {
          if (next2 !== void 0 && next2 !== null) {
            markToAnimate(key2);
          } else {
            removedKeys.add(key2);
          }
        } else if (next2 !== void 0 && removedKeys.has(key2)) {
          markToAnimate(key2);
        } else {
          typeState.protectedKeys[key2] = true;
        }
      }
      typeState.prevProp = prop;
      typeState.prevResolvedValues = resolvedValues;
      if (typeState.isActive) {
        encounteredKeys = { ...encounteredKeys, ...resolvedValues };
      }
      if (isInitialRender && visualElement.blockInitialAnimation) {
        shouldAnimateType = false;
      }
      const willAnimateViaParent = isInherited && variantDidChange;
      const needsAnimating = !willAnimateViaParent || handledRemovedValues;
      if (shouldAnimateType && needsAnimating) {
        animations2.push(...definitionList.map((animation) => ({
          animation,
          options: { type }
        })));
      }
    }
    if (removedKeys.size) {
      const fallbackAnimation = {};
      if (typeof props.initial !== "boolean") {
        const initialTransition = resolveVariant(visualElement, Array.isArray(props.initial) ? props.initial[0] : props.initial);
        if (initialTransition && initialTransition.transition) {
          fallbackAnimation.transition = initialTransition.transition;
        }
      }
      removedKeys.forEach((key2) => {
        const fallbackTarget = visualElement.getBaseTarget(key2);
        const motionValue2 = visualElement.getValue(key2);
        if (motionValue2)
          motionValue2.liveStyle = true;
        fallbackAnimation[key2] = fallbackTarget ?? null;
      });
      animations2.push({ animation: fallbackAnimation });
    }
    let shouldAnimate = Boolean(animations2.length);
    if (isInitialRender && (props.initial === false || props.initial === props.animate) && !visualElement.manuallyAnimateOnMount) {
      shouldAnimate = false;
    }
    isInitialRender = false;
    return shouldAnimate ? animate2(animations2) : Promise.resolve();
  }
  function setActive(type, isActive) {
    if (state[type].isActive === isActive)
      return Promise.resolve();
    visualElement.variantChildren?.forEach((child) => child.animationState?.setActive(type, isActive));
    state[type].isActive = isActive;
    const animations2 = animateChanges(type);
    for (const key2 in state) {
      state[key2].protectedKeys = {};
    }
    return animations2;
  }
  return {
    animateChanges,
    setActive,
    setAnimateFunction,
    getState: () => state,
    reset: () => {
      state = createState();
      isInitialRender = true;
    }
  };
}
function checkVariantsDidChange(prev2, next2) {
  if (typeof next2 === "string") {
    return next2 !== prev2;
  } else if (Array.isArray(next2)) {
    return !shallowCompare(next2, prev2);
  }
  return false;
}
function createTypeState(isActive = false) {
  return {
    isActive,
    protectedKeys: {},
    needsAnimating: {},
    prevResolvedValues: {}
  };
}
function createState() {
  return {
    animate: createTypeState(true),
    whileInView: createTypeState(),
    whileHover: createTypeState(),
    whileTap: createTypeState(),
    whileDrag: createTypeState(),
    whileFocus: createTypeState(),
    exit: createTypeState()
  };
}
class Feature {
  constructor(node2) {
    this.isMounted = false;
    this.node = node2;
  }
  update() {
  }
}
class AnimationFeature extends Feature {
  /**
   * We dynamically generate the AnimationState manager as it contains a reference
   * to the underlying animation library. We only want to load that if we load this,
   * so people can optionally code split it out using the `m` component.
   */
  constructor(node2) {
    super(node2);
    node2.animationState || (node2.animationState = createAnimationState(node2));
  }
  updateAnimationControlsSubscription() {
    const { animate: animate2 } = this.node.getProps();
    if (isAnimationControls(animate2)) {
      this.unmountControls = animate2.subscribe(this.node);
    }
  }
  /**
   * Subscribe any provided AnimationControls to the component's VisualElement
   */
  mount() {
    this.updateAnimationControlsSubscription();
  }
  update() {
    const { animate: animate2 } = this.node.getProps();
    const { animate: prevAnimate } = this.node.prevProps || {};
    if (animate2 !== prevAnimate) {
      this.updateAnimationControlsSubscription();
    }
  }
  unmount() {
    this.node.animationState.reset();
    this.unmountControls?.();
  }
}
let id$1 = 0;
class ExitAnimationFeature extends Feature {
  constructor() {
    super(...arguments);
    this.id = id$1++;
  }
  update() {
    if (!this.node.presenceContext)
      return;
    const { isPresent, onExitComplete } = this.node.presenceContext;
    const { isPresent: prevIsPresent } = this.node.prevPresenceContext || {};
    if (!this.node.animationState || isPresent === prevIsPresent) {
      return;
    }
    const exitAnimation = this.node.animationState.setActive("exit", !isPresent);
    if (onExitComplete && !isPresent) {
      exitAnimation.then(() => {
        onExitComplete(this.id);
      });
    }
  }
  mount() {
    const { register, onExitComplete } = this.node.presenceContext || {};
    if (onExitComplete) {
      onExitComplete(this.id);
    }
    if (register) {
      this.unmount = register(this.id);
    }
  }
  unmount() {
  }
}
const animations = {
  animation: {
    Feature: AnimationFeature
  },
  exit: {
    Feature: ExitAnimationFeature
  }
};
function addDomEvent(target, eventName, handler, options = { passive: true }) {
  target.addEventListener(eventName, handler, options);
  return () => target.removeEventListener(eventName, handler);
}
function extractEventInfo(event) {
  return {
    point: {
      x: event.pageX,
      y: event.pageY
    }
  };
}
const addPointerInfo = (handler) => {
  return (event) => isPrimaryPointer(event) && handler(event, extractEventInfo(event));
};
function addPointerEvent(target, eventName, handler, options) {
  return addDomEvent(target, eventName, addPointerInfo(handler), options);
}
function convertBoundingBoxToBox({ top, left, right, bottom }) {
  return {
    x: { min: left, max: right },
    y: { min: top, max: bottom }
  };
}
function convertBoxToBoundingBox({ x: x2, y: y2 }) {
  return { top: y2.min, right: x2.max, bottom: y2.max, left: x2.min };
}
function transformBoxPoints(point2, transformPoint2) {
  if (!transformPoint2)
    return point2;
  const topLeft = transformPoint2({ x: point2.left, y: point2.top });
  const bottomRight = transformPoint2({ x: point2.right, y: point2.bottom });
  return {
    top: topLeft.y,
    left: topLeft.x,
    bottom: bottomRight.y,
    right: bottomRight.x
  };
}
const SCALE_PRECISION = 1e-4;
const SCALE_MIN = 1 - SCALE_PRECISION;
const SCALE_MAX = 1 + SCALE_PRECISION;
const TRANSLATE_PRECISION = 0.01;
const TRANSLATE_MIN = 0 - TRANSLATE_PRECISION;
const TRANSLATE_MAX = 0 + TRANSLATE_PRECISION;
function calcLength(axis) {
  return axis.max - axis.min;
}
function isNear(value, target, maxDistance) {
  return Math.abs(value - target) <= maxDistance;
}
function calcAxisDelta(delta, source, target, origin = 0.5) {
  delta.origin = origin;
  delta.originPoint = mixNumber$1(source.min, source.max, delta.origin);
  delta.scale = calcLength(target) / calcLength(source);
  delta.translate = mixNumber$1(target.min, target.max, delta.origin) - delta.originPoint;
  if (delta.scale >= SCALE_MIN && delta.scale <= SCALE_MAX || isNaN(delta.scale)) {
    delta.scale = 1;
  }
  if (delta.translate >= TRANSLATE_MIN && delta.translate <= TRANSLATE_MAX || isNaN(delta.translate)) {
    delta.translate = 0;
  }
}
function calcBoxDelta(delta, source, target, origin) {
  calcAxisDelta(delta.x, source.x, target.x, origin ? origin.originX : void 0);
  calcAxisDelta(delta.y, source.y, target.y, origin ? origin.originY : void 0);
}
function calcRelativeAxis(target, relative, parent2) {
  target.min = parent2.min + relative.min;
  target.max = target.min + calcLength(relative);
}
function calcRelativeBox(target, relative, parent2) {
  calcRelativeAxis(target.x, relative.x, parent2.x);
  calcRelativeAxis(target.y, relative.y, parent2.y);
}
function calcRelativeAxisPosition(target, layout2, parent2) {
  target.min = layout2.min - parent2.min;
  target.max = target.min + calcLength(layout2);
}
function calcRelativePosition(target, layout2, parent2) {
  calcRelativeAxisPosition(target.x, layout2.x, parent2.x);
  calcRelativeAxisPosition(target.y, layout2.y, parent2.y);
}
const createAxisDelta = () => ({
  translate: 0,
  scale: 1,
  origin: 0,
  originPoint: 0
});
const createDelta = () => ({
  x: createAxisDelta(),
  y: createAxisDelta()
});
const createAxis = () => ({ min: 0, max: 0 });
const createBox$1 = () => ({
  x: createAxis(),
  y: createAxis()
});
function eachAxis(callback) {
  return [callback("x"), callback("y")];
}
function isIdentityScale(scale2) {
  return scale2 === void 0 || scale2 === 1;
}
function hasScale({ scale: scale2, scaleX: scaleX2, scaleY: scaleY2 }) {
  return !isIdentityScale(scale2) || !isIdentityScale(scaleX2) || !isIdentityScale(scaleY2);
}
function hasTransform(values2) {
  return hasScale(values2) || has2DTranslate(values2) || values2.z || values2.rotate || values2.rotateX || values2.rotateY || values2.skewX || values2.skewY;
}
function has2DTranslate(values2) {
  return is2DTranslate(values2.x) || is2DTranslate(values2.y);
}
function is2DTranslate(value) {
  return value && value !== "0%";
}
function scalePoint(point2, scale2, originPoint) {
  const distanceFromOrigin = point2 - originPoint;
  const scaled = scale2 * distanceFromOrigin;
  return originPoint + scaled;
}
function applyPointDelta(point2, translate, scale2, originPoint, boxScale) {
  if (boxScale !== void 0) {
    point2 = scalePoint(point2, boxScale, originPoint);
  }
  return scalePoint(point2, scale2, originPoint) + translate;
}
function applyAxisDelta(axis, translate = 0, scale2 = 1, originPoint, boxScale) {
  axis.min = applyPointDelta(axis.min, translate, scale2, originPoint, boxScale);
  axis.max = applyPointDelta(axis.max, translate, scale2, originPoint, boxScale);
}
function applyBoxDelta(box, { x: x2, y: y2 }) {
  applyAxisDelta(box.x, x2.translate, x2.scale, x2.originPoint);
  applyAxisDelta(box.y, y2.translate, y2.scale, y2.originPoint);
}
const TREE_SCALE_SNAP_MIN = 0.999999999999;
const TREE_SCALE_SNAP_MAX = 1.0000000000001;
function applyTreeDeltas(box, treeScale, treePath, isSharedTransition = false) {
  const treeLength = treePath.length;
  if (!treeLength)
    return;
  treeScale.x = treeScale.y = 1;
  let node2;
  let delta;
  for (let i2 = 0; i2 < treeLength; i2++) {
    node2 = treePath[i2];
    delta = node2.projectionDelta;
    const { visualElement } = node2.options;
    if (visualElement && visualElement.props.style && visualElement.props.style.display === "contents") {
      continue;
    }
    if (isSharedTransition && node2.options.layoutScroll && node2.scroll && node2 !== node2.root) {
      transformBox(box, {
        x: -node2.scroll.offset.x,
        y: -node2.scroll.offset.y
      });
    }
    if (delta) {
      treeScale.x *= delta.x.scale;
      treeScale.y *= delta.y.scale;
      applyBoxDelta(box, delta);
    }
    if (isSharedTransition && hasTransform(node2.latestValues)) {
      transformBox(box, node2.latestValues);
    }
  }
  if (treeScale.x < TREE_SCALE_SNAP_MAX && treeScale.x > TREE_SCALE_SNAP_MIN) {
    treeScale.x = 1;
  }
  if (treeScale.y < TREE_SCALE_SNAP_MAX && treeScale.y > TREE_SCALE_SNAP_MIN) {
    treeScale.y = 1;
  }
}
function translateAxis(axis, distance2) {
  axis.min = axis.min + distance2;
  axis.max = axis.max + distance2;
}
function transformAxis(axis, axisTranslate, axisScale, boxScale, axisOrigin = 0.5) {
  const originPoint = mixNumber$1(axis.min, axis.max, axisOrigin);
  applyAxisDelta(axis, axisTranslate, axisScale, originPoint, boxScale);
}
function transformBox(box, transform2) {
  transformAxis(box.x, transform2.x, transform2.scaleX, transform2.scale, transform2.originX);
  transformAxis(box.y, transform2.y, transform2.scaleY, transform2.scale, transform2.originY);
}
function measureViewportBox(instance, transformPoint2) {
  return convertBoundingBoxToBox(transformBoxPoints(instance.getBoundingClientRect(), transformPoint2));
}
function measurePageBox(element, rootProjectionNode2, transformPagePoint) {
  const viewportBox = measureViewportBox(element, transformPagePoint);
  const { scroll } = rootProjectionNode2;
  if (scroll) {
    translateAxis(viewportBox.x, scroll.offset.x);
    translateAxis(viewportBox.y, scroll.offset.y);
  }
  return viewportBox;
}
const getContextWindow = ({ current }) => {
  return current ? current.ownerDocument.defaultView : null;
};
const distance$1 = (a2, b2) => Math.abs(a2 - b2);
function distance2D(a2, b2) {
  const xDelta = distance$1(a2.x, b2.x);
  const yDelta = distance$1(a2.y, b2.y);
  return Math.sqrt(xDelta ** 2 + yDelta ** 2);
}
class PanSession {
  constructor(event, handlers, { transformPagePoint, contextWindow = window, dragSnapToOrigin = false, distanceThreshold = 3 } = {}) {
    this.startEvent = null;
    this.lastMoveEvent = null;
    this.lastMoveEventInfo = null;
    this.handlers = {};
    this.contextWindow = window;
    this.updatePoint = () => {
      if (!(this.lastMoveEvent && this.lastMoveEventInfo))
        return;
      const info2 = getPanInfo(this.lastMoveEventInfo, this.history);
      const isPanStarted = this.startEvent !== null;
      const isDistancePastThreshold = distance2D(info2.offset, { x: 0, y: 0 }) >= this.distanceThreshold;
      if (!isPanStarted && !isDistancePastThreshold)
        return;
      const { point: point3 } = info2;
      const { timestamp: timestamp2 } = frameData;
      this.history.push({ ...point3, timestamp: timestamp2 });
      const { onStart, onMove } = this.handlers;
      if (!isPanStarted) {
        onStart && onStart(this.lastMoveEvent, info2);
        this.startEvent = this.lastMoveEvent;
      }
      onMove && onMove(this.lastMoveEvent, info2);
    };
    this.handlePointerMove = (event2, info2) => {
      this.lastMoveEvent = event2;
      this.lastMoveEventInfo = transformPoint(info2, this.transformPagePoint);
      frame.update(this.updatePoint, true);
    };
    this.handlePointerUp = (event2, info2) => {
      this.end();
      const { onEnd, onSessionEnd, resumeAnimation } = this.handlers;
      if (this.dragSnapToOrigin)
        resumeAnimation && resumeAnimation();
      if (!(this.lastMoveEvent && this.lastMoveEventInfo))
        return;
      const panInfo = getPanInfo(event2.type === "pointercancel" ? this.lastMoveEventInfo : transformPoint(info2, this.transformPagePoint), this.history);
      if (this.startEvent && onEnd) {
        onEnd(event2, panInfo);
      }
      onSessionEnd && onSessionEnd(event2, panInfo);
    };
    if (!isPrimaryPointer(event))
      return;
    this.dragSnapToOrigin = dragSnapToOrigin;
    this.handlers = handlers;
    this.transformPagePoint = transformPagePoint;
    this.distanceThreshold = distanceThreshold;
    this.contextWindow = contextWindow || window;
    const info = extractEventInfo(event);
    const initialInfo = transformPoint(info, this.transformPagePoint);
    const { point: point2 } = initialInfo;
    const { timestamp } = frameData;
    this.history = [{ ...point2, timestamp }];
    const { onSessionStart } = handlers;
    onSessionStart && onSessionStart(event, getPanInfo(initialInfo, this.history));
    this.removeListeners = pipe(addPointerEvent(this.contextWindow, "pointermove", this.handlePointerMove), addPointerEvent(this.contextWindow, "pointerup", this.handlePointerUp), addPointerEvent(this.contextWindow, "pointercancel", this.handlePointerUp));
  }
  updateHandlers(handlers) {
    this.handlers = handlers;
  }
  end() {
    this.removeListeners && this.removeListeners();
    cancelFrame(this.updatePoint);
  }
}
function transformPoint(info, transformPagePoint) {
  return transformPagePoint ? { point: transformPagePoint(info.point) } : info;
}
function subtractPoint(a2, b2) {
  return { x: a2.x - b2.x, y: a2.y - b2.y };
}
function getPanInfo({ point: point2 }, history2) {
  return {
    point: point2,
    delta: subtractPoint(point2, lastDevicePoint(history2)),
    offset: subtractPoint(point2, startDevicePoint(history2)),
    velocity: getVelocity(history2, 0.1)
  };
}
function startDevicePoint(history2) {
  return history2[0];
}
function lastDevicePoint(history2) {
  return history2[history2.length - 1];
}
function getVelocity(history2, timeDelta) {
  if (history2.length < 2) {
    return { x: 0, y: 0 };
  }
  let i2 = history2.length - 1;
  let timestampedPoint = null;
  const lastPoint = lastDevicePoint(history2);
  while (i2 >= 0) {
    timestampedPoint = history2[i2];
    if (lastPoint.timestamp - timestampedPoint.timestamp > /* @__PURE__ */ secondsToMilliseconds(timeDelta)) {
      break;
    }
    i2--;
  }
  if (!timestampedPoint) {
    return { x: 0, y: 0 };
  }
  const time2 = /* @__PURE__ */ millisecondsToSeconds(lastPoint.timestamp - timestampedPoint.timestamp);
  if (time2 === 0) {
    return { x: 0, y: 0 };
  }
  const currentVelocity = {
    x: (lastPoint.x - timestampedPoint.x) / time2,
    y: (lastPoint.y - timestampedPoint.y) / time2
  };
  if (currentVelocity.x === Infinity) {
    currentVelocity.x = 0;
  }
  if (currentVelocity.y === Infinity) {
    currentVelocity.y = 0;
  }
  return currentVelocity;
}
function applyConstraints(point2, { min: min2, max: max2 }, elastic) {
  if (min2 !== void 0 && point2 < min2) {
    point2 = elastic ? mixNumber$1(min2, point2, elastic.min) : Math.max(point2, min2);
  } else if (max2 !== void 0 && point2 > max2) {
    point2 = elastic ? mixNumber$1(max2, point2, elastic.max) : Math.min(point2, max2);
  }
  return point2;
}
function calcRelativeAxisConstraints(axis, min2, max2) {
  return {
    min: min2 !== void 0 ? axis.min + min2 : void 0,
    max: max2 !== void 0 ? axis.max + max2 - (axis.max - axis.min) : void 0
  };
}
function calcRelativeConstraints(layoutBox, { top, left, bottom, right }) {
  return {
    x: calcRelativeAxisConstraints(layoutBox.x, left, right),
    y: calcRelativeAxisConstraints(layoutBox.y, top, bottom)
  };
}
function calcViewportAxisConstraints(layoutAxis, constraintsAxis) {
  let min2 = constraintsAxis.min - layoutAxis.min;
  let max2 = constraintsAxis.max - layoutAxis.max;
  if (constraintsAxis.max - constraintsAxis.min < layoutAxis.max - layoutAxis.min) {
    [min2, max2] = [max2, min2];
  }
  return { min: min2, max: max2 };
}
function calcViewportConstraints(layoutBox, constraintsBox) {
  return {
    x: calcViewportAxisConstraints(layoutBox.x, constraintsBox.x),
    y: calcViewportAxisConstraints(layoutBox.y, constraintsBox.y)
  };
}
function calcOrigin(source, target) {
  let origin = 0.5;
  const sourceLength = calcLength(source);
  const targetLength = calcLength(target);
  if (targetLength > sourceLength) {
    origin = /* @__PURE__ */ progress(target.min, target.max - sourceLength, source.min);
  } else if (sourceLength > targetLength) {
    origin = /* @__PURE__ */ progress(source.min, source.max - targetLength, target.min);
  }
  return clamp$4(0, 1, origin);
}
function rebaseAxisConstraints(layout2, constraints) {
  const relativeConstraints = {};
  if (constraints.min !== void 0) {
    relativeConstraints.min = constraints.min - layout2.min;
  }
  if (constraints.max !== void 0) {
    relativeConstraints.max = constraints.max - layout2.min;
  }
  return relativeConstraints;
}
const defaultElastic = 0.35;
function resolveDragElastic(dragElastic = defaultElastic) {
  if (dragElastic === false) {
    dragElastic = 0;
  } else if (dragElastic === true) {
    dragElastic = defaultElastic;
  }
  return {
    x: resolveAxisElastic(dragElastic, "left", "right"),
    y: resolveAxisElastic(dragElastic, "top", "bottom")
  };
}
function resolveAxisElastic(dragElastic, minLabel, maxLabel) {
  return {
    min: resolvePointElastic(dragElastic, minLabel),
    max: resolvePointElastic(dragElastic, maxLabel)
  };
}
function resolvePointElastic(dragElastic, label) {
  return typeof dragElastic === "number" ? dragElastic : dragElastic[label] || 0;
}
const elementDragControls = /* @__PURE__ */ new WeakMap();
class VisualElementDragControls {
  constructor(visualElement) {
    this.openDragLock = null;
    this.isDragging = false;
    this.currentDirection = null;
    this.originPoint = { x: 0, y: 0 };
    this.constraints = false;
    this.hasMutatedConstraints = false;
    this.elastic = createBox$1();
    this.latestPointerEvent = null;
    this.latestPanInfo = null;
    this.visualElement = visualElement;
  }
  start(originEvent, { snapToCursor = false, distanceThreshold } = {}) {
    const { presenceContext } = this.visualElement;
    if (presenceContext && presenceContext.isPresent === false)
      return;
    const onSessionStart = (event) => {
      const { dragSnapToOrigin: dragSnapToOrigin2 } = this.getProps();
      dragSnapToOrigin2 ? this.pauseAnimation() : this.stopAnimation();
      if (snapToCursor) {
        this.snapToCursor(extractEventInfo(event).point);
      }
    };
    const onStart = (event, info) => {
      const { drag: drag2, dragPropagation, onDragStart } = this.getProps();
      if (drag2 && !dragPropagation) {
        if (this.openDragLock)
          this.openDragLock();
        this.openDragLock = setDragLock(drag2);
        if (!this.openDragLock)
          return;
      }
      this.latestPointerEvent = event;
      this.latestPanInfo = info;
      this.isDragging = true;
      this.currentDirection = null;
      this.resolveConstraints();
      if (this.visualElement.projection) {
        this.visualElement.projection.isAnimationBlocked = true;
        this.visualElement.projection.target = void 0;
      }
      eachAxis((axis) => {
        let current = this.getAxisMotionValue(axis).get() || 0;
        if (percent.test(current)) {
          const { projection } = this.visualElement;
          if (projection && projection.layout) {
            const measuredAxis = projection.layout.layoutBox[axis];
            if (measuredAxis) {
              const length2 = calcLength(measuredAxis);
              current = length2 * (parseFloat(current) / 100);
            }
          }
        }
        this.originPoint[axis] = current;
      });
      if (onDragStart) {
        frame.postRender(() => onDragStart(event, info));
      }
      addValueToWillChange(this.visualElement, "transform");
      const { animationState } = this.visualElement;
      animationState && animationState.setActive("whileDrag", true);
    };
    const onMove = (event, info) => {
      this.latestPointerEvent = event;
      this.latestPanInfo = info;
      const { dragPropagation, dragDirectionLock, onDirectionLock, onDrag } = this.getProps();
      if (!dragPropagation && !this.openDragLock)
        return;
      const { offset: offset2 } = info;
      if (dragDirectionLock && this.currentDirection === null) {
        this.currentDirection = getCurrentDirection(offset2);
        if (this.currentDirection !== null) {
          onDirectionLock && onDirectionLock(this.currentDirection);
        }
        return;
      }
      this.updateAxis("x", info.point, offset2);
      this.updateAxis("y", info.point, offset2);
      this.visualElement.render();
      onDrag && onDrag(event, info);
    };
    const onSessionEnd = (event, info) => {
      this.latestPointerEvent = event;
      this.latestPanInfo = info;
      this.stop(event, info);
      this.latestPointerEvent = null;
      this.latestPanInfo = null;
    };
    const resumeAnimation = () => eachAxis((axis) => this.getAnimationState(axis) === "paused" && this.getAxisMotionValue(axis).animation?.play());
    const { dragSnapToOrigin } = this.getProps();
    this.panSession = new PanSession(originEvent, {
      onSessionStart,
      onStart,
      onMove,
      onSessionEnd,
      resumeAnimation
    }, {
      transformPagePoint: this.visualElement.getTransformPagePoint(),
      dragSnapToOrigin,
      distanceThreshold,
      contextWindow: getContextWindow(this.visualElement)
    });
  }
  /**
   * @internal
   */
  stop(event, panInfo) {
    const finalEvent = event || this.latestPointerEvent;
    const finalPanInfo = panInfo || this.latestPanInfo;
    const isDragging2 = this.isDragging;
    this.cancel();
    if (!isDragging2 || !finalPanInfo || !finalEvent)
      return;
    const { velocity } = finalPanInfo;
    this.startAnimation(velocity);
    const { onDragEnd } = this.getProps();
    if (onDragEnd) {
      frame.postRender(() => onDragEnd(finalEvent, finalPanInfo));
    }
  }
  /**
   * @internal
   */
  cancel() {
    this.isDragging = false;
    const { projection, animationState } = this.visualElement;
    if (projection) {
      projection.isAnimationBlocked = false;
    }
    this.panSession && this.panSession.end();
    this.panSession = void 0;
    const { dragPropagation } = this.getProps();
    if (!dragPropagation && this.openDragLock) {
      this.openDragLock();
      this.openDragLock = null;
    }
    animationState && animationState.setActive("whileDrag", false);
  }
  updateAxis(axis, _point, offset2) {
    const { drag: drag2 } = this.getProps();
    if (!offset2 || !shouldDrag(axis, drag2, this.currentDirection))
      return;
    const axisValue = this.getAxisMotionValue(axis);
    let next2 = this.originPoint[axis] + offset2[axis];
    if (this.constraints && this.constraints[axis]) {
      next2 = applyConstraints(next2, this.constraints[axis], this.elastic[axis]);
    }
    axisValue.set(next2);
  }
  resolveConstraints() {
    const { dragConstraints, dragElastic } = this.getProps();
    const layout2 = this.visualElement.projection && !this.visualElement.projection.layout ? this.visualElement.projection.measure(false) : this.visualElement.projection?.layout;
    const prevConstraints = this.constraints;
    if (dragConstraints && isRefObject(dragConstraints)) {
      if (!this.constraints) {
        this.constraints = this.resolveRefConstraints();
      }
    } else {
      if (dragConstraints && layout2) {
        this.constraints = calcRelativeConstraints(layout2.layoutBox, dragConstraints);
      } else {
        this.constraints = false;
      }
    }
    this.elastic = resolveDragElastic(dragElastic);
    if (prevConstraints !== this.constraints && layout2 && this.constraints && !this.hasMutatedConstraints) {
      eachAxis((axis) => {
        if (this.constraints !== false && this.getAxisMotionValue(axis)) {
          this.constraints[axis] = rebaseAxisConstraints(layout2.layoutBox[axis], this.constraints[axis]);
        }
      });
    }
  }
  resolveRefConstraints() {
    const { dragConstraints: constraints, onMeasureDragConstraints } = this.getProps();
    if (!constraints || !isRefObject(constraints))
      return false;
    const constraintsElement = constraints.current;
    const { projection } = this.visualElement;
    if (!projection || !projection.layout)
      return false;
    const constraintsBox = measurePageBox(constraintsElement, projection.root, this.visualElement.getTransformPagePoint());
    let measuredConstraints = calcViewportConstraints(projection.layout.layoutBox, constraintsBox);
    if (onMeasureDragConstraints) {
      const userConstraints = onMeasureDragConstraints(convertBoxToBoundingBox(measuredConstraints));
      this.hasMutatedConstraints = !!userConstraints;
      if (userConstraints) {
        measuredConstraints = convertBoundingBoxToBox(userConstraints);
      }
    }
    return measuredConstraints;
  }
  startAnimation(velocity) {
    const { drag: drag2, dragMomentum, dragElastic, dragTransition, dragSnapToOrigin, onDragTransitionEnd } = this.getProps();
    const constraints = this.constraints || {};
    const momentumAnimations = eachAxis((axis) => {
      if (!shouldDrag(axis, drag2, this.currentDirection)) {
        return;
      }
      let transition = constraints && constraints[axis] || {};
      if (dragSnapToOrigin)
        transition = { min: 0, max: 0 };
      const bounceStiffness = dragElastic ? 200 : 1e6;
      const bounceDamping = dragElastic ? 40 : 1e7;
      const inertia2 = {
        type: "inertia",
        velocity: dragMomentum ? velocity[axis] : 0,
        bounceStiffness,
        bounceDamping,
        timeConstant: 750,
        restDelta: 1,
        restSpeed: 10,
        ...dragTransition,
        ...transition
      };
      return this.startAxisValueAnimation(axis, inertia2);
    });
    return Promise.all(momentumAnimations).then(onDragTransitionEnd);
  }
  startAxisValueAnimation(axis, transition) {
    const axisValue = this.getAxisMotionValue(axis);
    addValueToWillChange(this.visualElement, axis);
    return axisValue.start(animateMotionValue(axis, axisValue, 0, transition, this.visualElement, false));
  }
  stopAnimation() {
    eachAxis((axis) => this.getAxisMotionValue(axis).stop());
  }
  pauseAnimation() {
    eachAxis((axis) => this.getAxisMotionValue(axis).animation?.pause());
  }
  getAnimationState(axis) {
    return this.getAxisMotionValue(axis).animation?.state;
  }
  /**
   * Drag works differently depending on which props are provided.
   *
   * - If _dragX and _dragY are provided, we output the gesture delta directly to those motion values.
   * - Otherwise, we apply the delta to the x/y motion values.
   */
  getAxisMotionValue(axis) {
    const dragKey = `_drag${axis.toUpperCase()}`;
    const props = this.visualElement.getProps();
    const externalMotionValue = props[dragKey];
    return externalMotionValue ? externalMotionValue : this.visualElement.getValue(axis, (props.initial ? props.initial[axis] : void 0) || 0);
  }
  snapToCursor(point2) {
    eachAxis((axis) => {
      const { drag: drag2 } = this.getProps();
      if (!shouldDrag(axis, drag2, this.currentDirection))
        return;
      const { projection } = this.visualElement;
      const axisValue = this.getAxisMotionValue(axis);
      if (projection && projection.layout) {
        const { min: min2, max: max2 } = projection.layout.layoutBox[axis];
        axisValue.set(point2[axis] - mixNumber$1(min2, max2, 0.5));
      }
    });
  }
  /**
   * When the viewport resizes we want to check if the measured constraints
   * have changed and, if so, reposition the element within those new constraints
   * relative to where it was before the resize.
   */
  scalePositionWithinConstraints() {
    if (!this.visualElement.current)
      return;
    const { drag: drag2, dragConstraints } = this.getProps();
    const { projection } = this.visualElement;
    if (!isRefObject(dragConstraints) || !projection || !this.constraints)
      return;
    this.stopAnimation();
    const boxProgress = { x: 0, y: 0 };
    eachAxis((axis) => {
      const axisValue = this.getAxisMotionValue(axis);
      if (axisValue && this.constraints !== false) {
        const latest = axisValue.get();
        boxProgress[axis] = calcOrigin({ min: latest, max: latest }, this.constraints[axis]);
      }
    });
    const { transformTemplate } = this.visualElement.getProps();
    this.visualElement.current.style.transform = transformTemplate ? transformTemplate({}, "") : "none";
    projection.root && projection.root.updateScroll();
    projection.updateLayout();
    this.resolveConstraints();
    eachAxis((axis) => {
      if (!shouldDrag(axis, drag2, null))
        return;
      const axisValue = this.getAxisMotionValue(axis);
      const { min: min2, max: max2 } = this.constraints[axis];
      axisValue.set(mixNumber$1(min2, max2, boxProgress[axis]));
    });
  }
  addListeners() {
    if (!this.visualElement.current)
      return;
    elementDragControls.set(this.visualElement, this);
    const element = this.visualElement.current;
    const stopPointerListener = addPointerEvent(element, "pointerdown", (event) => {
      const { drag: drag2, dragListener = true } = this.getProps();
      drag2 && dragListener && this.start(event);
    });
    const measureDragConstraints = () => {
      const { dragConstraints } = this.getProps();
      if (isRefObject(dragConstraints) && dragConstraints.current) {
        this.constraints = this.resolveRefConstraints();
      }
    };
    const { projection } = this.visualElement;
    const stopMeasureLayoutListener = projection.addEventListener("measure", measureDragConstraints);
    if (projection && !projection.layout) {
      projection.root && projection.root.updateScroll();
      projection.updateLayout();
    }
    frame.read(measureDragConstraints);
    const stopResizeListener = addDomEvent(window, "resize", () => this.scalePositionWithinConstraints());
    const stopLayoutUpdateListener = projection.addEventListener("didUpdate", ({ delta, hasLayoutChanged }) => {
      if (this.isDragging && hasLayoutChanged) {
        eachAxis((axis) => {
          const motionValue2 = this.getAxisMotionValue(axis);
          if (!motionValue2)
            return;
          this.originPoint[axis] += delta[axis].translate;
          motionValue2.set(motionValue2.get() + delta[axis].translate);
        });
        this.visualElement.render();
      }
    });
    return () => {
      stopResizeListener();
      stopPointerListener();
      stopMeasureLayoutListener();
      stopLayoutUpdateListener && stopLayoutUpdateListener();
    };
  }
  getProps() {
    const props = this.visualElement.getProps();
    const { drag: drag2 = false, dragDirectionLock = false, dragPropagation = false, dragConstraints = false, dragElastic = defaultElastic, dragMomentum = true } = props;
    return {
      ...props,
      drag: drag2,
      dragDirectionLock,
      dragPropagation,
      dragConstraints,
      dragElastic,
      dragMomentum
    };
  }
}
function shouldDrag(direction, drag2, currentDirection) {
  return (drag2 === true || drag2 === direction) && (currentDirection === null || currentDirection === direction);
}
function getCurrentDirection(offset2, lockThreshold = 10) {
  let direction = null;
  if (Math.abs(offset2.y) > lockThreshold) {
    direction = "y";
  } else if (Math.abs(offset2.x) > lockThreshold) {
    direction = "x";
  }
  return direction;
}
class DragGesture extends Feature {
  constructor(node2) {
    super(node2);
    this.removeGroupControls = noop$6;
    this.removeListeners = noop$6;
    this.controls = new VisualElementDragControls(node2);
  }
  mount() {
    const { dragControls } = this.node.getProps();
    if (dragControls) {
      this.removeGroupControls = dragControls.subscribe(this.controls);
    }
    this.removeListeners = this.controls.addListeners() || noop$6;
  }
  unmount() {
    this.removeGroupControls();
    this.removeListeners();
  }
}
const asyncHandler = (handler) => (event, info) => {
  if (handler) {
    frame.postRender(() => handler(event, info));
  }
};
class PanGesture extends Feature {
  constructor() {
    super(...arguments);
    this.removePointerDownListener = noop$6;
  }
  onPointerDown(pointerDownEvent) {
    this.session = new PanSession(pointerDownEvent, this.createPanHandlers(), {
      transformPagePoint: this.node.getTransformPagePoint(),
      contextWindow: getContextWindow(this.node)
    });
  }
  createPanHandlers() {
    const { onPanSessionStart, onPanStart, onPan, onPanEnd } = this.node.getProps();
    return {
      onSessionStart: asyncHandler(onPanSessionStart),
      onStart: asyncHandler(onPanStart),
      onMove: onPan,
      onEnd: (event, info) => {
        delete this.session;
        if (onPanEnd) {
          frame.postRender(() => onPanEnd(event, info));
        }
      }
    };
  }
  mount() {
    this.removePointerDownListener = addPointerEvent(this.node.current, "pointerdown", (event) => this.onPointerDown(event));
  }
  update() {
    this.session && this.session.updateHandlers(this.createPanHandlers());
  }
  unmount() {
    this.removePointerDownListener();
    this.session && this.session.end();
  }
}
const globalProjectionState = {
  /**
   * Global flag as to whether the tree has animated since the last time
   * we resized the window
   */
  hasAnimatedSinceResize: true,
  /**
   * We set this to true once, on the first update. Any nodes added to the tree beyond that
   * update will be given a `data-projection-id` attribute.
   */
  hasEverUpdated: false
};
function pixelsToPercent(pixels, axis) {
  if (axis.max === axis.min)
    return 0;
  return pixels / (axis.max - axis.min) * 100;
}
const correctBorderRadius = {
  correct: (latest, node2) => {
    if (!node2.target)
      return latest;
    if (typeof latest === "string") {
      if (px.test(latest)) {
        latest = parseFloat(latest);
      } else {
        return latest;
      }
    }
    const x2 = pixelsToPercent(latest, node2.target.x);
    const y2 = pixelsToPercent(latest, node2.target.y);
    return `${x2}% ${y2}%`;
  }
};
const correctBoxShadow = {
  correct: (latest, { treeScale, projectionDelta }) => {
    const original = latest;
    const shadow2 = complex.parse(latest);
    if (shadow2.length > 5)
      return original;
    const template = complex.createTransformer(latest);
    const offset2 = typeof shadow2[0] !== "number" ? 1 : 0;
    const xScale = projectionDelta.x.scale * treeScale.x;
    const yScale = projectionDelta.y.scale * treeScale.y;
    shadow2[0 + offset2] /= xScale;
    shadow2[1 + offset2] /= yScale;
    const averageScale = mixNumber$1(xScale, yScale, 0.5);
    if (typeof shadow2[2 + offset2] === "number")
      shadow2[2 + offset2] /= averageScale;
    if (typeof shadow2[3 + offset2] === "number")
      shadow2[3 + offset2] /= averageScale;
    return template(shadow2);
  }
};
let hasTakenAnySnapshot = false;
class MeasureLayoutWithContext extends reactExports.Component {
  /**
   * This only mounts projection nodes for components that
   * need measuring, we might want to do it for all components
   * in order to incorporate transforms
   */
  componentDidMount() {
    const { visualElement, layoutGroup, switchLayoutGroup, layoutId } = this.props;
    const { projection } = visualElement;
    addScaleCorrector(defaultScaleCorrectors);
    if (projection) {
      if (layoutGroup.group)
        layoutGroup.group.add(projection);
      if (switchLayoutGroup && switchLayoutGroup.register && layoutId) {
        switchLayoutGroup.register(projection);
      }
      if (hasTakenAnySnapshot) {
        projection.root.didUpdate();
      }
      projection.addEventListener("animationComplete", () => {
        this.safeToRemove();
      });
      projection.setOptions({
        ...projection.options,
        onExitComplete: () => this.safeToRemove()
      });
    }
    globalProjectionState.hasEverUpdated = true;
  }
  getSnapshotBeforeUpdate(prevProps) {
    const { layoutDependency, visualElement, drag: drag2, isPresent } = this.props;
    const { projection } = visualElement;
    if (!projection)
      return null;
    projection.isPresent = isPresent;
    hasTakenAnySnapshot = true;
    if (drag2 || prevProps.layoutDependency !== layoutDependency || layoutDependency === void 0 || prevProps.isPresent !== isPresent) {
      projection.willUpdate();
    } else {
      this.safeToRemove();
    }
    if (prevProps.isPresent !== isPresent) {
      if (isPresent) {
        projection.promote();
      } else if (!projection.relegate()) {
        frame.postRender(() => {
          const stack = projection.getStack();
          if (!stack || !stack.members.length) {
            this.safeToRemove();
          }
        });
      }
    }
    return null;
  }
  componentDidUpdate() {
    const { projection } = this.props.visualElement;
    if (projection) {
      projection.root.didUpdate();
      microtask.postRender(() => {
        if (!projection.currentAnimation && projection.isLead()) {
          this.safeToRemove();
        }
      });
    }
  }
  componentWillUnmount() {
    const { visualElement, layoutGroup, switchLayoutGroup: promoteContext } = this.props;
    const { projection } = visualElement;
    if (projection) {
      projection.scheduleCheckAfterUnmount();
      if (layoutGroup && layoutGroup.group)
        layoutGroup.group.remove(projection);
      if (promoteContext && promoteContext.deregister)
        promoteContext.deregister(projection);
    }
  }
  safeToRemove() {
    const { safeToRemove } = this.props;
    safeToRemove && safeToRemove();
  }
  render() {
    return null;
  }
}
function MeasureLayout(props) {
  const [isPresent, safeToRemove] = usePresence$1();
  const layoutGroup = reactExports.useContext(LayoutGroupContext);
  return jsxRuntimeExports.jsx(MeasureLayoutWithContext, { ...props, layoutGroup, switchLayoutGroup: reactExports.useContext(SwitchLayoutGroupContext), isPresent, safeToRemove });
}
const defaultScaleCorrectors = {
  borderRadius: {
    ...correctBorderRadius,
    applyTo: [
      "borderTopLeftRadius",
      "borderTopRightRadius",
      "borderBottomLeftRadius",
      "borderBottomRightRadius"
    ]
  },
  borderTopLeftRadius: correctBorderRadius,
  borderTopRightRadius: correctBorderRadius,
  borderBottomLeftRadius: correctBorderRadius,
  borderBottomRightRadius: correctBorderRadius,
  boxShadow: correctBoxShadow
};
function animateSingleValue(value, keyframes2, options) {
  const motionValue$1 = isMotionValue(value) ? value : motionValue(value);
  motionValue$1.start(animateMotionValue("", motionValue$1, keyframes2, options));
  return motionValue$1.animation;
}
const compareByDepth = (a2, b2) => a2.depth - b2.depth;
class FlatTree {
  constructor() {
    this.children = [];
    this.isDirty = false;
  }
  add(child) {
    addUniqueItem(this.children, child);
    this.isDirty = true;
  }
  remove(child) {
    removeItem(this.children, child);
    this.isDirty = true;
  }
  forEach(callback) {
    this.isDirty && this.children.sort(compareByDepth);
    this.isDirty = false;
    this.children.forEach(callback);
  }
}
function delay(callback, timeout) {
  const start = time.now();
  const checkElapsed = ({ timestamp }) => {
    const elapsed = timestamp - start;
    if (elapsed >= timeout) {
      cancelFrame(checkElapsed);
      callback(elapsed - timeout);
    }
  };
  frame.setup(checkElapsed, true);
  return () => cancelFrame(checkElapsed);
}
const borders = ["TopLeft", "TopRight", "BottomLeft", "BottomRight"];
const numBorders = borders.length;
const asNumber = (value) => typeof value === "string" ? parseFloat(value) : value;
const isPx = (value) => typeof value === "number" || px.test(value);
function mixValues(target, follow, lead, progress2, shouldCrossfadeOpacity, isOnlyMember) {
  if (shouldCrossfadeOpacity) {
    target.opacity = mixNumber$1(0, lead.opacity ?? 1, easeCrossfadeIn(progress2));
    target.opacityExit = mixNumber$1(follow.opacity ?? 1, 0, easeCrossfadeOut(progress2));
  } else if (isOnlyMember) {
    target.opacity = mixNumber$1(follow.opacity ?? 1, lead.opacity ?? 1, progress2);
  }
  for (let i2 = 0; i2 < numBorders; i2++) {
    const borderLabel = `border${borders[i2]}Radius`;
    let followRadius = getRadius(follow, borderLabel);
    let leadRadius = getRadius(lead, borderLabel);
    if (followRadius === void 0 && leadRadius === void 0)
      continue;
    followRadius || (followRadius = 0);
    leadRadius || (leadRadius = 0);
    const canMix = followRadius === 0 || leadRadius === 0 || isPx(followRadius) === isPx(leadRadius);
    if (canMix) {
      target[borderLabel] = Math.max(mixNumber$1(asNumber(followRadius), asNumber(leadRadius), progress2), 0);
      if (percent.test(leadRadius) || percent.test(followRadius)) {
        target[borderLabel] += "%";
      }
    } else {
      target[borderLabel] = leadRadius;
    }
  }
  if (follow.rotate || lead.rotate) {
    target.rotate = mixNumber$1(follow.rotate || 0, lead.rotate || 0, progress2);
  }
}
function getRadius(values2, radiusName) {
  return values2[radiusName] !== void 0 ? values2[radiusName] : values2.borderRadius;
}
const easeCrossfadeIn = /* @__PURE__ */ compress(0, 0.5, circOut);
const easeCrossfadeOut = /* @__PURE__ */ compress(0.5, 0.95, noop$6);
function compress(min2, max2, easing2) {
  return (p2) => {
    if (p2 < min2)
      return 0;
    if (p2 > max2)
      return 1;
    return easing2(/* @__PURE__ */ progress(min2, max2, p2));
  };
}
function copyAxisInto(axis, originAxis) {
  axis.min = originAxis.min;
  axis.max = originAxis.max;
}
function copyBoxInto(box, originBox) {
  copyAxisInto(box.x, originBox.x);
  copyAxisInto(box.y, originBox.y);
}
function copyAxisDeltaInto(delta, originDelta) {
  delta.translate = originDelta.translate;
  delta.scale = originDelta.scale;
  delta.originPoint = originDelta.originPoint;
  delta.origin = originDelta.origin;
}
function removePointDelta(point2, translate, scale2, originPoint, boxScale) {
  point2 -= translate;
  point2 = scalePoint(point2, 1 / scale2, originPoint);
  if (boxScale !== void 0) {
    point2 = scalePoint(point2, 1 / boxScale, originPoint);
  }
  return point2;
}
function removeAxisDelta(axis, translate = 0, scale2 = 1, origin = 0.5, boxScale, originAxis = axis, sourceAxis = axis) {
  if (percent.test(translate)) {
    translate = parseFloat(translate);
    const relativeProgress = mixNumber$1(sourceAxis.min, sourceAxis.max, translate / 100);
    translate = relativeProgress - sourceAxis.min;
  }
  if (typeof translate !== "number")
    return;
  let originPoint = mixNumber$1(originAxis.min, originAxis.max, origin);
  if (axis === originAxis)
    originPoint -= translate;
  axis.min = removePointDelta(axis.min, translate, scale2, originPoint, boxScale);
  axis.max = removePointDelta(axis.max, translate, scale2, originPoint, boxScale);
}
function removeAxisTransforms(axis, transforms, [key2, scaleKey, originKey], origin, sourceAxis) {
  removeAxisDelta(axis, transforms[key2], transforms[scaleKey], transforms[originKey], transforms.scale, origin, sourceAxis);
}
const xKeys = ["x", "scaleX", "originX"];
const yKeys = ["y", "scaleY", "originY"];
function removeBoxTransforms(box, transforms, originBox, sourceBox) {
  removeAxisTransforms(box.x, transforms, xKeys, originBox ? originBox.x : void 0, sourceBox ? sourceBox.x : void 0);
  removeAxisTransforms(box.y, transforms, yKeys, originBox ? originBox.y : void 0, sourceBox ? sourceBox.y : void 0);
}
function isAxisDeltaZero(delta) {
  return delta.translate === 0 && delta.scale === 1;
}
function isDeltaZero(delta) {
  return isAxisDeltaZero(delta.x) && isAxisDeltaZero(delta.y);
}
function axisEquals(a2, b2) {
  return a2.min === b2.min && a2.max === b2.max;
}
function boxEquals(a2, b2) {
  return axisEquals(a2.x, b2.x) && axisEquals(a2.y, b2.y);
}
function axisEqualsRounded(a2, b2) {
  return Math.round(a2.min) === Math.round(b2.min) && Math.round(a2.max) === Math.round(b2.max);
}
function boxEqualsRounded(a2, b2) {
  return axisEqualsRounded(a2.x, b2.x) && axisEqualsRounded(a2.y, b2.y);
}
function aspectRatio(box) {
  return calcLength(box.x) / calcLength(box.y);
}
function axisDeltaEquals(a2, b2) {
  return a2.translate === b2.translate && a2.scale === b2.scale && a2.originPoint === b2.originPoint;
}
class NodeStack {
  constructor() {
    this.members = [];
  }
  add(node2) {
    addUniqueItem(this.members, node2);
    node2.scheduleRender();
  }
  remove(node2) {
    removeItem(this.members, node2);
    if (node2 === this.prevLead) {
      this.prevLead = void 0;
    }
    if (node2 === this.lead) {
      const prevLead = this.members[this.members.length - 1];
      if (prevLead) {
        this.promote(prevLead);
      }
    }
  }
  relegate(node2) {
    const indexOfNode = this.members.findIndex((member) => node2 === member);
    if (indexOfNode === 0)
      return false;
    let prevLead;
    for (let i2 = indexOfNode; i2 >= 0; i2--) {
      const member = this.members[i2];
      if (member.isPresent !== false) {
        prevLead = member;
        break;
      }
    }
    if (prevLead) {
      this.promote(prevLead);
      return true;
    } else {
      return false;
    }
  }
  promote(node2, preserveFollowOpacity) {
    const prevLead = this.lead;
    if (node2 === prevLead)
      return;
    this.prevLead = prevLead;
    this.lead = node2;
    node2.show();
    if (prevLead) {
      prevLead.instance && prevLead.scheduleRender();
      node2.scheduleRender();
      node2.resumeFrom = prevLead;
      if (preserveFollowOpacity) {
        node2.resumeFrom.preserveOpacity = true;
      }
      if (prevLead.snapshot) {
        node2.snapshot = prevLead.snapshot;
        node2.snapshot.latestValues = prevLead.animationValues || prevLead.latestValues;
      }
      if (node2.root && node2.root.isUpdating) {
        node2.isLayoutDirty = true;
      }
      const { crossfade } = node2.options;
      if (crossfade === false) {
        prevLead.hide();
      }
    }
  }
  exitAnimationComplete() {
    this.members.forEach((node2) => {
      const { options, resumingFrom } = node2;
      options.onExitComplete && options.onExitComplete();
      if (resumingFrom) {
        resumingFrom.options.onExitComplete && resumingFrom.options.onExitComplete();
      }
    });
  }
  scheduleRender() {
    this.members.forEach((node2) => {
      node2.instance && node2.scheduleRender(false);
    });
  }
  /**
   * Clear any leads that have been removed this render to prevent them from being
   * used in future animations and to prevent memory leaks
   */
  removeLeadSnapshot() {
    if (this.lead && this.lead.snapshot) {
      this.lead.snapshot = void 0;
    }
  }
}
function buildProjectionTransform(delta, treeScale, latestTransform) {
  let transform2 = "";
  const xTranslate = delta.x.translate / treeScale.x;
  const yTranslate = delta.y.translate / treeScale.y;
  const zTranslate = latestTransform?.z || 0;
  if (xTranslate || yTranslate || zTranslate) {
    transform2 = `translate3d(${xTranslate}px, ${yTranslate}px, ${zTranslate}px) `;
  }
  if (treeScale.x !== 1 || treeScale.y !== 1) {
    transform2 += `scale(${1 / treeScale.x}, ${1 / treeScale.y}) `;
  }
  if (latestTransform) {
    const { transformPerspective, rotate: rotate2, rotateX, rotateY, skewX, skewY } = latestTransform;
    if (transformPerspective)
      transform2 = `perspective(${transformPerspective}px) ${transform2}`;
    if (rotate2)
      transform2 += `rotate(${rotate2}deg) `;
    if (rotateX)
      transform2 += `rotateX(${rotateX}deg) `;
    if (rotateY)
      transform2 += `rotateY(${rotateY}deg) `;
    if (skewX)
      transform2 += `skewX(${skewX}deg) `;
    if (skewY)
      transform2 += `skewY(${skewY}deg) `;
  }
  const elementScaleX = delta.x.scale * treeScale.x;
  const elementScaleY = delta.y.scale * treeScale.y;
  if (elementScaleX !== 1 || elementScaleY !== 1) {
    transform2 += `scale(${elementScaleX}, ${elementScaleY})`;
  }
  return transform2 || "none";
}
const transformAxes = ["", "X", "Y", "Z"];
const animationTarget = 1e3;
let id = 0;
function resetDistortingTransform(key2, visualElement, values2, sharedAnimationValues) {
  const { latestValues } = visualElement;
  if (latestValues[key2]) {
    values2[key2] = latestValues[key2];
    visualElement.setStaticValue(key2, 0);
    if (sharedAnimationValues) {
      sharedAnimationValues[key2] = 0;
    }
  }
}
function cancelTreeOptimisedTransformAnimations(projectionNode) {
  projectionNode.hasCheckedOptimisedAppear = true;
  if (projectionNode.root === projectionNode)
    return;
  const { visualElement } = projectionNode.options;
  if (!visualElement)
    return;
  const appearId = getOptimisedAppearId(visualElement);
  if (window.MotionHasOptimisedAnimation(appearId, "transform")) {
    const { layout: layout2, layoutId } = projectionNode.options;
    window.MotionCancelOptimisedAnimation(appearId, "transform", frame, !(layout2 || layoutId));
  }
  const { parent: parent2 } = projectionNode;
  if (parent2 && !parent2.hasCheckedOptimisedAppear) {
    cancelTreeOptimisedTransformAnimations(parent2);
  }
}
function createProjectionNode({ attachResizeListener, defaultParent, measureScroll, checkIsScrollRoot, resetTransform }) {
  return class ProjectionNode {
    constructor(latestValues = {}, parent2 = defaultParent?.()) {
      this.id = id++;
      this.animationId = 0;
      this.animationCommitId = 0;
      this.children = /* @__PURE__ */ new Set();
      this.options = {};
      this.isTreeAnimating = false;
      this.isAnimationBlocked = false;
      this.isLayoutDirty = false;
      this.isProjectionDirty = false;
      this.isSharedProjectionDirty = false;
      this.isTransformDirty = false;
      this.updateManuallyBlocked = false;
      this.updateBlockedByResize = false;
      this.isUpdating = false;
      this.isSVG = false;
      this.needsReset = false;
      this.shouldResetTransform = false;
      this.hasCheckedOptimisedAppear = false;
      this.treeScale = { x: 1, y: 1 };
      this.eventHandlers = /* @__PURE__ */ new Map();
      this.hasTreeAnimated = false;
      this.updateScheduled = false;
      this.scheduleUpdate = () => this.update();
      this.projectionUpdateScheduled = false;
      this.checkUpdateFailed = () => {
        if (this.isUpdating) {
          this.isUpdating = false;
          this.clearAllSnapshots();
        }
      };
      this.updateProjection = () => {
        this.projectionUpdateScheduled = false;
        this.nodes.forEach(propagateDirtyNodes);
        this.nodes.forEach(resolveTargetDelta);
        this.nodes.forEach(calcProjection);
        this.nodes.forEach(cleanDirtyNodes);
      };
      this.resolvedRelativeTargetAt = 0;
      this.hasProjected = false;
      this.isVisible = true;
      this.animationProgress = 0;
      this.sharedNodes = /* @__PURE__ */ new Map();
      this.latestValues = latestValues;
      this.root = parent2 ? parent2.root || parent2 : this;
      this.path = parent2 ? [...parent2.path, parent2] : [];
      this.parent = parent2;
      this.depth = parent2 ? parent2.depth + 1 : 0;
      for (let i2 = 0; i2 < this.path.length; i2++) {
        this.path[i2].shouldResetTransform = true;
      }
      if (this.root === this)
        this.nodes = new FlatTree();
    }
    addEventListener(name, handler) {
      if (!this.eventHandlers.has(name)) {
        this.eventHandlers.set(name, new SubscriptionManager());
      }
      return this.eventHandlers.get(name).add(handler);
    }
    notifyListeners(name, ...args) {
      const subscriptionManager = this.eventHandlers.get(name);
      subscriptionManager && subscriptionManager.notify(...args);
    }
    hasListeners(name) {
      return this.eventHandlers.has(name);
    }
    /**
     * Lifecycles
     */
    mount(instance) {
      if (this.instance)
        return;
      this.isSVG = isSVGElement(instance) && !isSVGSVGElement(instance);
      this.instance = instance;
      const { layoutId, layout: layout2, visualElement } = this.options;
      if (visualElement && !visualElement.current) {
        visualElement.mount(instance);
      }
      this.root.nodes.add(this);
      this.parent && this.parent.children.add(this);
      if (this.root.hasTreeAnimated && (layout2 || layoutId)) {
        this.isLayoutDirty = true;
      }
      if (attachResizeListener) {
        let cancelDelay;
        let innerWidth = 0;
        const resizeUnblockUpdate = () => this.root.updateBlockedByResize = false;
        frame.read(() => {
          innerWidth = window.innerWidth;
        });
        attachResizeListener(instance, () => {
          const newInnerWidth = window.innerWidth;
          if (newInnerWidth === innerWidth)
            return;
          innerWidth = newInnerWidth;
          this.root.updateBlockedByResize = true;
          cancelDelay && cancelDelay();
          cancelDelay = delay(resizeUnblockUpdate, 250);
          if (globalProjectionState.hasAnimatedSinceResize) {
            globalProjectionState.hasAnimatedSinceResize = false;
            this.nodes.forEach(finishAnimation);
          }
        });
      }
      if (layoutId) {
        this.root.registerSharedNode(layoutId, this);
      }
      if (this.options.animate !== false && visualElement && (layoutId || layout2)) {
        this.addEventListener("didUpdate", ({ delta, hasLayoutChanged, hasRelativeLayoutChanged, layout: newLayout }) => {
          if (this.isTreeAnimationBlocked()) {
            this.target = void 0;
            this.relativeTarget = void 0;
            return;
          }
          const layoutTransition = this.options.transition || visualElement.getDefaultTransition() || defaultLayoutTransition;
          const { onLayoutAnimationStart, onLayoutAnimationComplete } = visualElement.getProps();
          const hasTargetChanged = !this.targetLayout || !boxEqualsRounded(this.targetLayout, newLayout);
          const hasOnlyRelativeTargetChanged = !hasLayoutChanged && hasRelativeLayoutChanged;
          if (this.options.layoutRoot || this.resumeFrom || hasOnlyRelativeTargetChanged || hasLayoutChanged && (hasTargetChanged || !this.currentAnimation)) {
            if (this.resumeFrom) {
              this.resumingFrom = this.resumeFrom;
              this.resumingFrom.resumingFrom = void 0;
            }
            const animationOptions = {
              ...getValueTransition(layoutTransition, "layout"),
              onPlay: onLayoutAnimationStart,
              onComplete: onLayoutAnimationComplete
            };
            if (visualElement.shouldReduceMotion || this.options.layoutRoot) {
              animationOptions.delay = 0;
              animationOptions.type = false;
            }
            this.startAnimation(animationOptions);
            this.setAnimationOrigin(delta, hasOnlyRelativeTargetChanged);
          } else {
            if (!hasLayoutChanged) {
              finishAnimation(this);
            }
            if (this.isLead() && this.options.onExitComplete) {
              this.options.onExitComplete();
            }
          }
          this.targetLayout = newLayout;
        });
      }
    }
    unmount() {
      this.options.layoutId && this.willUpdate();
      this.root.nodes.remove(this);
      const stack = this.getStack();
      stack && stack.remove(this);
      this.parent && this.parent.children.delete(this);
      this.instance = void 0;
      this.eventHandlers.clear();
      cancelFrame(this.updateProjection);
    }
    // only on the root
    blockUpdate() {
      this.updateManuallyBlocked = true;
    }
    unblockUpdate() {
      this.updateManuallyBlocked = false;
    }
    isUpdateBlocked() {
      return this.updateManuallyBlocked || this.updateBlockedByResize;
    }
    isTreeAnimationBlocked() {
      return this.isAnimationBlocked || this.parent && this.parent.isTreeAnimationBlocked() || false;
    }
    // Note: currently only running on root node
    startUpdate() {
      if (this.isUpdateBlocked())
        return;
      this.isUpdating = true;
      this.nodes && this.nodes.forEach(resetSkewAndRotation);
      this.animationId++;
    }
    getTransformTemplate() {
      const { visualElement } = this.options;
      return visualElement && visualElement.getProps().transformTemplate;
    }
    willUpdate(shouldNotifyListeners = true) {
      this.root.hasTreeAnimated = true;
      if (this.root.isUpdateBlocked()) {
        this.options.onExitComplete && this.options.onExitComplete();
        return;
      }
      if (window.MotionCancelOptimisedAnimation && !this.hasCheckedOptimisedAppear) {
        cancelTreeOptimisedTransformAnimations(this);
      }
      !this.root.isUpdating && this.root.startUpdate();
      if (this.isLayoutDirty)
        return;
      this.isLayoutDirty = true;
      for (let i2 = 0; i2 < this.path.length; i2++) {
        const node2 = this.path[i2];
        node2.shouldResetTransform = true;
        node2.updateScroll("snapshot");
        if (node2.options.layoutRoot) {
          node2.willUpdate(false);
        }
      }
      const { layoutId, layout: layout2 } = this.options;
      if (layoutId === void 0 && !layout2)
        return;
      const transformTemplate = this.getTransformTemplate();
      this.prevTransformTemplateValue = transformTemplate ? transformTemplate(this.latestValues, "") : void 0;
      this.updateSnapshot();
      shouldNotifyListeners && this.notifyListeners("willUpdate");
    }
    update() {
      this.updateScheduled = false;
      const updateWasBlocked = this.isUpdateBlocked();
      if (updateWasBlocked) {
        this.unblockUpdate();
        this.clearAllSnapshots();
        this.nodes.forEach(clearMeasurements);
        return;
      }
      if (this.animationId <= this.animationCommitId) {
        this.nodes.forEach(clearIsLayoutDirty);
        return;
      }
      this.animationCommitId = this.animationId;
      if (!this.isUpdating) {
        this.nodes.forEach(clearIsLayoutDirty);
      } else {
        this.isUpdating = false;
        this.nodes.forEach(resetTransformStyle);
        this.nodes.forEach(updateLayout);
        this.nodes.forEach(notifyLayoutUpdate);
      }
      this.clearAllSnapshots();
      const now2 = time.now();
      frameData.delta = clamp$4(0, 1e3 / 60, now2 - frameData.timestamp);
      frameData.timestamp = now2;
      frameData.isProcessing = true;
      frameSteps.update.process(frameData);
      frameSteps.preRender.process(frameData);
      frameSteps.render.process(frameData);
      frameData.isProcessing = false;
    }
    didUpdate() {
      if (!this.updateScheduled) {
        this.updateScheduled = true;
        microtask.read(this.scheduleUpdate);
      }
    }
    clearAllSnapshots() {
      this.nodes.forEach(clearSnapshot);
      this.sharedNodes.forEach(removeLeadSnapshots);
    }
    scheduleUpdateProjection() {
      if (!this.projectionUpdateScheduled) {
        this.projectionUpdateScheduled = true;
        frame.preRender(this.updateProjection, false, true);
      }
    }
    scheduleCheckAfterUnmount() {
      frame.postRender(() => {
        if (this.isLayoutDirty) {
          this.root.didUpdate();
        } else {
          this.root.checkUpdateFailed();
        }
      });
    }
    /**
     * Update measurements
     */
    updateSnapshot() {
      if (this.snapshot || !this.instance)
        return;
      this.snapshot = this.measure();
      if (this.snapshot && !calcLength(this.snapshot.measuredBox.x) && !calcLength(this.snapshot.measuredBox.y)) {
        this.snapshot = void 0;
      }
    }
    updateLayout() {
      if (!this.instance)
        return;
      this.updateScroll();
      if (!(this.options.alwaysMeasureLayout && this.isLead()) && !this.isLayoutDirty) {
        return;
      }
      if (this.resumeFrom && !this.resumeFrom.instance) {
        for (let i2 = 0; i2 < this.path.length; i2++) {
          const node2 = this.path[i2];
          node2.updateScroll();
        }
      }
      const prevLayout = this.layout;
      this.layout = this.measure(false);
      this.layoutCorrected = createBox$1();
      this.isLayoutDirty = false;
      this.projectionDelta = void 0;
      this.notifyListeners("measure", this.layout.layoutBox);
      const { visualElement } = this.options;
      visualElement && visualElement.notify("LayoutMeasure", this.layout.layoutBox, prevLayout ? prevLayout.layoutBox : void 0);
    }
    updateScroll(phase = "measure") {
      let needsMeasurement = Boolean(this.options.layoutScroll && this.instance);
      if (this.scroll && this.scroll.animationId === this.root.animationId && this.scroll.phase === phase) {
        needsMeasurement = false;
      }
      if (needsMeasurement && this.instance) {
        const isRoot = checkIsScrollRoot(this.instance);
        this.scroll = {
          animationId: this.root.animationId,
          phase,
          isRoot,
          offset: measureScroll(this.instance),
          wasRoot: this.scroll ? this.scroll.isRoot : isRoot
        };
      }
    }
    resetTransform() {
      if (!resetTransform)
        return;
      const isResetRequested = this.isLayoutDirty || this.shouldResetTransform || this.options.alwaysMeasureLayout;
      const hasProjection = this.projectionDelta && !isDeltaZero(this.projectionDelta);
      const transformTemplate = this.getTransformTemplate();
      const transformTemplateValue = transformTemplate ? transformTemplate(this.latestValues, "") : void 0;
      const transformTemplateHasChanged = transformTemplateValue !== this.prevTransformTemplateValue;
      if (isResetRequested && this.instance && (hasProjection || hasTransform(this.latestValues) || transformTemplateHasChanged)) {
        resetTransform(this.instance, transformTemplateValue);
        this.shouldResetTransform = false;
        this.scheduleRender();
      }
    }
    measure(removeTransform = true) {
      const pageBox = this.measurePageBox();
      let layoutBox = this.removeElementScroll(pageBox);
      if (removeTransform) {
        layoutBox = this.removeTransform(layoutBox);
      }
      roundBox(layoutBox);
      return {
        animationId: this.root.animationId,
        measuredBox: pageBox,
        layoutBox,
        latestValues: {},
        source: this.id
      };
    }
    measurePageBox() {
      const { visualElement } = this.options;
      if (!visualElement)
        return createBox$1();
      const box = visualElement.measureViewportBox();
      const wasInScrollRoot = this.scroll?.wasRoot || this.path.some(checkNodeWasScrollRoot);
      if (!wasInScrollRoot) {
        const { scroll } = this.root;
        if (scroll) {
          translateAxis(box.x, scroll.offset.x);
          translateAxis(box.y, scroll.offset.y);
        }
      }
      return box;
    }
    removeElementScroll(box) {
      const boxWithoutScroll = createBox$1();
      copyBoxInto(boxWithoutScroll, box);
      if (this.scroll?.wasRoot) {
        return boxWithoutScroll;
      }
      for (let i2 = 0; i2 < this.path.length; i2++) {
        const node2 = this.path[i2];
        const { scroll, options } = node2;
        if (node2 !== this.root && scroll && options.layoutScroll) {
          if (scroll.wasRoot) {
            copyBoxInto(boxWithoutScroll, box);
          }
          translateAxis(boxWithoutScroll.x, scroll.offset.x);
          translateAxis(boxWithoutScroll.y, scroll.offset.y);
        }
      }
      return boxWithoutScroll;
    }
    applyTransform(box, transformOnly = false) {
      const withTransforms = createBox$1();
      copyBoxInto(withTransforms, box);
      for (let i2 = 0; i2 < this.path.length; i2++) {
        const node2 = this.path[i2];
        if (!transformOnly && node2.options.layoutScroll && node2.scroll && node2 !== node2.root) {
          transformBox(withTransforms, {
            x: -node2.scroll.offset.x,
            y: -node2.scroll.offset.y
          });
        }
        if (!hasTransform(node2.latestValues))
          continue;
        transformBox(withTransforms, node2.latestValues);
      }
      if (hasTransform(this.latestValues)) {
        transformBox(withTransforms, this.latestValues);
      }
      return withTransforms;
    }
    removeTransform(box) {
      const boxWithoutTransform = createBox$1();
      copyBoxInto(boxWithoutTransform, box);
      for (let i2 = 0; i2 < this.path.length; i2++) {
        const node2 = this.path[i2];
        if (!node2.instance)
          continue;
        if (!hasTransform(node2.latestValues))
          continue;
        hasScale(node2.latestValues) && node2.updateSnapshot();
        const sourceBox = createBox$1();
        const nodeBox = node2.measurePageBox();
        copyBoxInto(sourceBox, nodeBox);
        removeBoxTransforms(boxWithoutTransform, node2.latestValues, node2.snapshot ? node2.snapshot.layoutBox : void 0, sourceBox);
      }
      if (hasTransform(this.latestValues)) {
        removeBoxTransforms(boxWithoutTransform, this.latestValues);
      }
      return boxWithoutTransform;
    }
    setTargetDelta(delta) {
      this.targetDelta = delta;
      this.root.scheduleUpdateProjection();
      this.isProjectionDirty = true;
    }
    setOptions(options) {
      this.options = {
        ...this.options,
        ...options,
        crossfade: options.crossfade !== void 0 ? options.crossfade : true
      };
    }
    clearMeasurements() {
      this.scroll = void 0;
      this.layout = void 0;
      this.snapshot = void 0;
      this.prevTransformTemplateValue = void 0;
      this.targetDelta = void 0;
      this.target = void 0;
      this.isLayoutDirty = false;
    }
    forceRelativeParentToResolveTarget() {
      if (!this.relativeParent)
        return;
      if (this.relativeParent.resolvedRelativeTargetAt !== frameData.timestamp) {
        this.relativeParent.resolveTargetDelta(true);
      }
    }
    resolveTargetDelta(forceRecalculation = false) {
      const lead = this.getLead();
      this.isProjectionDirty || (this.isProjectionDirty = lead.isProjectionDirty);
      this.isTransformDirty || (this.isTransformDirty = lead.isTransformDirty);
      this.isSharedProjectionDirty || (this.isSharedProjectionDirty = lead.isSharedProjectionDirty);
      const isShared = Boolean(this.resumingFrom) || this !== lead;
      const canSkip = !(forceRecalculation || isShared && this.isSharedProjectionDirty || this.isProjectionDirty || this.parent?.isProjectionDirty || this.attemptToResolveRelativeTarget || this.root.updateBlockedByResize);
      if (canSkip)
        return;
      const { layout: layout2, layoutId } = this.options;
      if (!this.layout || !(layout2 || layoutId))
        return;
      this.resolvedRelativeTargetAt = frameData.timestamp;
      if (!this.targetDelta && !this.relativeTarget) {
        const relativeParent = this.getClosestProjectingParent();
        if (relativeParent && relativeParent.layout && this.animationProgress !== 1) {
          this.relativeParent = relativeParent;
          this.forceRelativeParentToResolveTarget();
          this.relativeTarget = createBox$1();
          this.relativeTargetOrigin = createBox$1();
          calcRelativePosition(this.relativeTargetOrigin, this.layout.layoutBox, relativeParent.layout.layoutBox);
          copyBoxInto(this.relativeTarget, this.relativeTargetOrigin);
        } else {
          this.relativeParent = this.relativeTarget = void 0;
        }
      }
      if (!this.relativeTarget && !this.targetDelta)
        return;
      if (!this.target) {
        this.target = createBox$1();
        this.targetWithTransforms = createBox$1();
      }
      if (this.relativeTarget && this.relativeTargetOrigin && this.relativeParent && this.relativeParent.target) {
        this.forceRelativeParentToResolveTarget();
        calcRelativeBox(this.target, this.relativeTarget, this.relativeParent.target);
      } else if (this.targetDelta) {
        if (Boolean(this.resumingFrom)) {
          this.target = this.applyTransform(this.layout.layoutBox);
        } else {
          copyBoxInto(this.target, this.layout.layoutBox);
        }
        applyBoxDelta(this.target, this.targetDelta);
      } else {
        copyBoxInto(this.target, this.layout.layoutBox);
      }
      if (this.attemptToResolveRelativeTarget) {
        this.attemptToResolveRelativeTarget = false;
        const relativeParent = this.getClosestProjectingParent();
        if (relativeParent && Boolean(relativeParent.resumingFrom) === Boolean(this.resumingFrom) && !relativeParent.options.layoutScroll && relativeParent.target && this.animationProgress !== 1) {
          this.relativeParent = relativeParent;
          this.forceRelativeParentToResolveTarget();
          this.relativeTarget = createBox$1();
          this.relativeTargetOrigin = createBox$1();
          calcRelativePosition(this.relativeTargetOrigin, this.target, relativeParent.target);
          copyBoxInto(this.relativeTarget, this.relativeTargetOrigin);
        } else {
          this.relativeParent = this.relativeTarget = void 0;
        }
      }
    }
    getClosestProjectingParent() {
      if (!this.parent || hasScale(this.parent.latestValues) || has2DTranslate(this.parent.latestValues)) {
        return void 0;
      }
      if (this.parent.isProjecting()) {
        return this.parent;
      } else {
        return this.parent.getClosestProjectingParent();
      }
    }
    isProjecting() {
      return Boolean((this.relativeTarget || this.targetDelta || this.options.layoutRoot) && this.layout);
    }
    calcProjection() {
      const lead = this.getLead();
      const isShared = Boolean(this.resumingFrom) || this !== lead;
      let canSkip = true;
      if (this.isProjectionDirty || this.parent?.isProjectionDirty) {
        canSkip = false;
      }
      if (isShared && (this.isSharedProjectionDirty || this.isTransformDirty)) {
        canSkip = false;
      }
      if (this.resolvedRelativeTargetAt === frameData.timestamp) {
        canSkip = false;
      }
      if (canSkip)
        return;
      const { layout: layout2, layoutId } = this.options;
      this.isTreeAnimating = Boolean(this.parent && this.parent.isTreeAnimating || this.currentAnimation || this.pendingAnimation);
      if (!this.isTreeAnimating) {
        this.targetDelta = this.relativeTarget = void 0;
      }
      if (!this.layout || !(layout2 || layoutId))
        return;
      copyBoxInto(this.layoutCorrected, this.layout.layoutBox);
      const prevTreeScaleX = this.treeScale.x;
      const prevTreeScaleY = this.treeScale.y;
      applyTreeDeltas(this.layoutCorrected, this.treeScale, this.path, isShared);
      if (lead.layout && !lead.target && (this.treeScale.x !== 1 || this.treeScale.y !== 1)) {
        lead.target = lead.layout.layoutBox;
        lead.targetWithTransforms = createBox$1();
      }
      const { target } = lead;
      if (!target) {
        if (this.prevProjectionDelta) {
          this.createProjectionDeltas();
          this.scheduleRender();
        }
        return;
      }
      if (!this.projectionDelta || !this.prevProjectionDelta) {
        this.createProjectionDeltas();
      } else {
        copyAxisDeltaInto(this.prevProjectionDelta.x, this.projectionDelta.x);
        copyAxisDeltaInto(this.prevProjectionDelta.y, this.projectionDelta.y);
      }
      calcBoxDelta(this.projectionDelta, this.layoutCorrected, target, this.latestValues);
      if (this.treeScale.x !== prevTreeScaleX || this.treeScale.y !== prevTreeScaleY || !axisDeltaEquals(this.projectionDelta.x, this.prevProjectionDelta.x) || !axisDeltaEquals(this.projectionDelta.y, this.prevProjectionDelta.y)) {
        this.hasProjected = true;
        this.scheduleRender();
        this.notifyListeners("projectionUpdate", target);
      }
    }
    hide() {
      this.isVisible = false;
    }
    show() {
      this.isVisible = true;
    }
    scheduleRender(notifyAll = true) {
      this.options.visualElement?.scheduleRender();
      if (notifyAll) {
        const stack = this.getStack();
        stack && stack.scheduleRender();
      }
      if (this.resumingFrom && !this.resumingFrom.instance) {
        this.resumingFrom = void 0;
      }
    }
    createProjectionDeltas() {
      this.prevProjectionDelta = createDelta();
      this.projectionDelta = createDelta();
      this.projectionDeltaWithTransform = createDelta();
    }
    setAnimationOrigin(delta, hasOnlyRelativeTargetChanged = false) {
      const snapshot = this.snapshot;
      const snapshotLatestValues = snapshot ? snapshot.latestValues : {};
      const mixedValues = { ...this.latestValues };
      const targetDelta = createDelta();
      if (!this.relativeParent || !this.relativeParent.options.layoutRoot) {
        this.relativeTarget = this.relativeTargetOrigin = void 0;
      }
      this.attemptToResolveRelativeTarget = !hasOnlyRelativeTargetChanged;
      const relativeLayout = createBox$1();
      const snapshotSource = snapshot ? snapshot.source : void 0;
      const layoutSource = this.layout ? this.layout.source : void 0;
      const isSharedLayoutAnimation = snapshotSource !== layoutSource;
      const stack = this.getStack();
      const isOnlyMember = !stack || stack.members.length <= 1;
      const shouldCrossfadeOpacity = Boolean(isSharedLayoutAnimation && !isOnlyMember && this.options.crossfade === true && !this.path.some(hasOpacityCrossfade));
      this.animationProgress = 0;
      let prevRelativeTarget;
      this.mixTargetDelta = (latest) => {
        const progress2 = latest / 1e3;
        mixAxisDelta(targetDelta.x, delta.x, progress2);
        mixAxisDelta(targetDelta.y, delta.y, progress2);
        this.setTargetDelta(targetDelta);
        if (this.relativeTarget && this.relativeTargetOrigin && this.layout && this.relativeParent && this.relativeParent.layout) {
          calcRelativePosition(relativeLayout, this.layout.layoutBox, this.relativeParent.layout.layoutBox);
          mixBox(this.relativeTarget, this.relativeTargetOrigin, relativeLayout, progress2);
          if (prevRelativeTarget && boxEquals(this.relativeTarget, prevRelativeTarget)) {
            this.isProjectionDirty = false;
          }
          if (!prevRelativeTarget)
            prevRelativeTarget = createBox$1();
          copyBoxInto(prevRelativeTarget, this.relativeTarget);
        }
        if (isSharedLayoutAnimation) {
          this.animationValues = mixedValues;
          mixValues(mixedValues, snapshotLatestValues, this.latestValues, progress2, shouldCrossfadeOpacity, isOnlyMember);
        }
        this.root.scheduleUpdateProjection();
        this.scheduleRender();
        this.animationProgress = progress2;
      };
      this.mixTargetDelta(this.options.layoutRoot ? 1e3 : 0);
    }
    startAnimation(options) {
      this.notifyListeners("animationStart");
      this.currentAnimation?.stop();
      this.resumingFrom?.currentAnimation?.stop();
      if (this.pendingAnimation) {
        cancelFrame(this.pendingAnimation);
        this.pendingAnimation = void 0;
      }
      this.pendingAnimation = frame.update(() => {
        globalProjectionState.hasAnimatedSinceResize = true;
        this.motionValue || (this.motionValue = motionValue(0));
        this.currentAnimation = animateSingleValue(this.motionValue, [0, 1e3], {
          ...options,
          velocity: 0,
          isSync: true,
          onUpdate: (latest) => {
            this.mixTargetDelta(latest);
            options.onUpdate && options.onUpdate(latest);
          },
          onStop: () => {
          },
          onComplete: () => {
            options.onComplete && options.onComplete();
            this.completeAnimation();
          }
        });
        if (this.resumingFrom) {
          this.resumingFrom.currentAnimation = this.currentAnimation;
        }
        this.pendingAnimation = void 0;
      });
    }
    completeAnimation() {
      if (this.resumingFrom) {
        this.resumingFrom.currentAnimation = void 0;
        this.resumingFrom.preserveOpacity = void 0;
      }
      const stack = this.getStack();
      stack && stack.exitAnimationComplete();
      this.resumingFrom = this.currentAnimation = this.animationValues = void 0;
      this.notifyListeners("animationComplete");
    }
    finishAnimation() {
      if (this.currentAnimation) {
        this.mixTargetDelta && this.mixTargetDelta(animationTarget);
        this.currentAnimation.stop();
      }
      this.completeAnimation();
    }
    applyTransformsToTarget() {
      const lead = this.getLead();
      let { targetWithTransforms, target, layout: layout2, latestValues } = lead;
      if (!targetWithTransforms || !target || !layout2)
        return;
      if (this !== lead && this.layout && layout2 && shouldAnimatePositionOnly(this.options.animationType, this.layout.layoutBox, layout2.layoutBox)) {
        target = this.target || createBox$1();
        const xLength = calcLength(this.layout.layoutBox.x);
        target.x.min = lead.target.x.min;
        target.x.max = target.x.min + xLength;
        const yLength = calcLength(this.layout.layoutBox.y);
        target.y.min = lead.target.y.min;
        target.y.max = target.y.min + yLength;
      }
      copyBoxInto(targetWithTransforms, target);
      transformBox(targetWithTransforms, latestValues);
      calcBoxDelta(this.projectionDeltaWithTransform, this.layoutCorrected, targetWithTransforms, latestValues);
    }
    registerSharedNode(layoutId, node2) {
      if (!this.sharedNodes.has(layoutId)) {
        this.sharedNodes.set(layoutId, new NodeStack());
      }
      const stack = this.sharedNodes.get(layoutId);
      stack.add(node2);
      const config2 = node2.options.initialPromotionConfig;
      node2.promote({
        transition: config2 ? config2.transition : void 0,
        preserveFollowOpacity: config2 && config2.shouldPreserveFollowOpacity ? config2.shouldPreserveFollowOpacity(node2) : void 0
      });
    }
    isLead() {
      const stack = this.getStack();
      return stack ? stack.lead === this : true;
    }
    getLead() {
      const { layoutId } = this.options;
      return layoutId ? this.getStack()?.lead || this : this;
    }
    getPrevLead() {
      const { layoutId } = this.options;
      return layoutId ? this.getStack()?.prevLead : void 0;
    }
    getStack() {
      const { layoutId } = this.options;
      if (layoutId)
        return this.root.sharedNodes.get(layoutId);
    }
    promote({ needsReset, transition, preserveFollowOpacity } = {}) {
      const stack = this.getStack();
      if (stack)
        stack.promote(this, preserveFollowOpacity);
      if (needsReset) {
        this.projectionDelta = void 0;
        this.needsReset = true;
      }
      if (transition)
        this.setOptions({ transition });
    }
    relegate() {
      const stack = this.getStack();
      if (stack) {
        return stack.relegate(this);
      } else {
        return false;
      }
    }
    resetSkewAndRotation() {
      const { visualElement } = this.options;
      if (!visualElement)
        return;
      let hasDistortingTransform = false;
      const { latestValues } = visualElement;
      if (latestValues.z || latestValues.rotate || latestValues.rotateX || latestValues.rotateY || latestValues.rotateZ || latestValues.skewX || latestValues.skewY) {
        hasDistortingTransform = true;
      }
      if (!hasDistortingTransform)
        return;
      const resetValues = {};
      if (latestValues.z) {
        resetDistortingTransform("z", visualElement, resetValues, this.animationValues);
      }
      for (let i2 = 0; i2 < transformAxes.length; i2++) {
        resetDistortingTransform(`rotate${transformAxes[i2]}`, visualElement, resetValues, this.animationValues);
        resetDistortingTransform(`skew${transformAxes[i2]}`, visualElement, resetValues, this.animationValues);
      }
      visualElement.render();
      for (const key2 in resetValues) {
        visualElement.setStaticValue(key2, resetValues[key2]);
        if (this.animationValues) {
          this.animationValues[key2] = resetValues[key2];
        }
      }
      visualElement.scheduleRender();
    }
    applyProjectionStyles(targetStyle, styleProp) {
      if (!this.instance || this.isSVG)
        return;
      if (!this.isVisible) {
        targetStyle.visibility = "hidden";
        return;
      }
      const transformTemplate = this.getTransformTemplate();
      if (this.needsReset) {
        this.needsReset = false;
        targetStyle.visibility = "";
        targetStyle.opacity = "";
        targetStyle.pointerEvents = resolveMotionValue(styleProp?.pointerEvents) || "";
        targetStyle.transform = transformTemplate ? transformTemplate(this.latestValues, "") : "none";
        return;
      }
      const lead = this.getLead();
      if (!this.projectionDelta || !this.layout || !lead.target) {
        if (this.options.layoutId) {
          targetStyle.opacity = this.latestValues.opacity !== void 0 ? this.latestValues.opacity : 1;
          targetStyle.pointerEvents = resolveMotionValue(styleProp?.pointerEvents) || "";
        }
        if (this.hasProjected && !hasTransform(this.latestValues)) {
          targetStyle.transform = transformTemplate ? transformTemplate({}, "") : "none";
          this.hasProjected = false;
        }
        return;
      }
      targetStyle.visibility = "";
      const valuesToRender = lead.animationValues || lead.latestValues;
      this.applyTransformsToTarget();
      let transform2 = buildProjectionTransform(this.projectionDeltaWithTransform, this.treeScale, valuesToRender);
      if (transformTemplate) {
        transform2 = transformTemplate(valuesToRender, transform2);
      }
      targetStyle.transform = transform2;
      const { x: x2, y: y2 } = this.projectionDelta;
      targetStyle.transformOrigin = `${x2.origin * 100}% ${y2.origin * 100}% 0`;
      if (lead.animationValues) {
        targetStyle.opacity = lead === this ? valuesToRender.opacity ?? this.latestValues.opacity ?? 1 : this.preserveOpacity ? this.latestValues.opacity : valuesToRender.opacityExit;
      } else {
        targetStyle.opacity = lead === this ? valuesToRender.opacity !== void 0 ? valuesToRender.opacity : "" : valuesToRender.opacityExit !== void 0 ? valuesToRender.opacityExit : 0;
      }
      for (const key2 in scaleCorrectors) {
        if (valuesToRender[key2] === void 0)
          continue;
        const { correct, applyTo, isCSSVariable } = scaleCorrectors[key2];
        const corrected = transform2 === "none" ? valuesToRender[key2] : correct(valuesToRender[key2], lead);
        if (applyTo) {
          const num = applyTo.length;
          for (let i2 = 0; i2 < num; i2++) {
            targetStyle[applyTo[i2]] = corrected;
          }
        } else {
          if (isCSSVariable) {
            this.options.visualElement.renderState.vars[key2] = corrected;
          } else {
            targetStyle[key2] = corrected;
          }
        }
      }
      if (this.options.layoutId) {
        targetStyle.pointerEvents = lead === this ? resolveMotionValue(styleProp?.pointerEvents) || "" : "none";
      }
    }
    clearSnapshot() {
      this.resumeFrom = this.snapshot = void 0;
    }
    // Only run on root
    resetTree() {
      this.root.nodes.forEach((node2) => node2.currentAnimation?.stop());
      this.root.nodes.forEach(clearMeasurements);
      this.root.sharedNodes.clear();
    }
  };
}
function updateLayout(node2) {
  node2.updateLayout();
}
function notifyLayoutUpdate(node2) {
  const snapshot = node2.resumeFrom?.snapshot || node2.snapshot;
  if (node2.isLead() && node2.layout && snapshot && node2.hasListeners("didUpdate")) {
    const { layoutBox: layout2, measuredBox: measuredLayout } = node2.layout;
    const { animationType } = node2.options;
    const isShared = snapshot.source !== node2.layout.source;
    if (animationType === "size") {
      eachAxis((axis) => {
        const axisSnapshot = isShared ? snapshot.measuredBox[axis] : snapshot.layoutBox[axis];
        const length2 = calcLength(axisSnapshot);
        axisSnapshot.min = layout2[axis].min;
        axisSnapshot.max = axisSnapshot.min + length2;
      });
    } else if (shouldAnimatePositionOnly(animationType, snapshot.layoutBox, layout2)) {
      eachAxis((axis) => {
        const axisSnapshot = isShared ? snapshot.measuredBox[axis] : snapshot.layoutBox[axis];
        const length2 = calcLength(layout2[axis]);
        axisSnapshot.max = axisSnapshot.min + length2;
        if (node2.relativeTarget && !node2.currentAnimation) {
          node2.isProjectionDirty = true;
          node2.relativeTarget[axis].max = node2.relativeTarget[axis].min + length2;
        }
      });
    }
    const layoutDelta = createDelta();
    calcBoxDelta(layoutDelta, layout2, snapshot.layoutBox);
    const visualDelta = createDelta();
    if (isShared) {
      calcBoxDelta(visualDelta, node2.applyTransform(measuredLayout, true), snapshot.measuredBox);
    } else {
      calcBoxDelta(visualDelta, layout2, snapshot.layoutBox);
    }
    const hasLayoutChanged = !isDeltaZero(layoutDelta);
    let hasRelativeLayoutChanged = false;
    if (!node2.resumeFrom) {
      const relativeParent = node2.getClosestProjectingParent();
      if (relativeParent && !relativeParent.resumeFrom) {
        const { snapshot: parentSnapshot, layout: parentLayout } = relativeParent;
        if (parentSnapshot && parentLayout) {
          const relativeSnapshot = createBox$1();
          calcRelativePosition(relativeSnapshot, snapshot.layoutBox, parentSnapshot.layoutBox);
          const relativeLayout = createBox$1();
          calcRelativePosition(relativeLayout, layout2, parentLayout.layoutBox);
          if (!boxEqualsRounded(relativeSnapshot, relativeLayout)) {
            hasRelativeLayoutChanged = true;
          }
          if (relativeParent.options.layoutRoot) {
            node2.relativeTarget = relativeLayout;
            node2.relativeTargetOrigin = relativeSnapshot;
            node2.relativeParent = relativeParent;
          }
        }
      }
    }
    node2.notifyListeners("didUpdate", {
      layout: layout2,
      snapshot,
      delta: visualDelta,
      layoutDelta,
      hasLayoutChanged,
      hasRelativeLayoutChanged
    });
  } else if (node2.isLead()) {
    const { onExitComplete } = node2.options;
    onExitComplete && onExitComplete();
  }
  node2.options.transition = void 0;
}
function propagateDirtyNodes(node2) {
  if (!node2.parent)
    return;
  if (!node2.isProjecting()) {
    node2.isProjectionDirty = node2.parent.isProjectionDirty;
  }
  node2.isSharedProjectionDirty || (node2.isSharedProjectionDirty = Boolean(node2.isProjectionDirty || node2.parent.isProjectionDirty || node2.parent.isSharedProjectionDirty));
  node2.isTransformDirty || (node2.isTransformDirty = node2.parent.isTransformDirty);
}
function cleanDirtyNodes(node2) {
  node2.isProjectionDirty = node2.isSharedProjectionDirty = node2.isTransformDirty = false;
}
function clearSnapshot(node2) {
  node2.clearSnapshot();
}
function clearMeasurements(node2) {
  node2.clearMeasurements();
}
function clearIsLayoutDirty(node2) {
  node2.isLayoutDirty = false;
}
function resetTransformStyle(node2) {
  const { visualElement } = node2.options;
  if (visualElement && visualElement.getProps().onBeforeLayoutMeasure) {
    visualElement.notify("BeforeLayoutMeasure");
  }
  node2.resetTransform();
}
function finishAnimation(node2) {
  node2.finishAnimation();
  node2.targetDelta = node2.relativeTarget = node2.target = void 0;
  node2.isProjectionDirty = true;
}
function resolveTargetDelta(node2) {
  node2.resolveTargetDelta();
}
function calcProjection(node2) {
  node2.calcProjection();
}
function resetSkewAndRotation(node2) {
  node2.resetSkewAndRotation();
}
function removeLeadSnapshots(stack) {
  stack.removeLeadSnapshot();
}
function mixAxisDelta(output, delta, p2) {
  output.translate = mixNumber$1(delta.translate, 0, p2);
  output.scale = mixNumber$1(delta.scale, 1, p2);
  output.origin = delta.origin;
  output.originPoint = delta.originPoint;
}
function mixAxis(output, from2, to, p2) {
  output.min = mixNumber$1(from2.min, to.min, p2);
  output.max = mixNumber$1(from2.max, to.max, p2);
}
function mixBox(output, from2, to, p2) {
  mixAxis(output.x, from2.x, to.x, p2);
  mixAxis(output.y, from2.y, to.y, p2);
}
function hasOpacityCrossfade(node2) {
  return node2.animationValues && node2.animationValues.opacityExit !== void 0;
}
const defaultLayoutTransition = {
  duration: 0.45,
  ease: [0.4, 0, 0.1, 1]
};
const userAgentContains = (string) => typeof navigator !== "undefined" && navigator.userAgent && navigator.userAgent.toLowerCase().includes(string);
const roundPoint = userAgentContains("applewebkit/") && !userAgentContains("chrome/") ? Math.round : noop$6;
function roundAxis(axis) {
  axis.min = roundPoint(axis.min);
  axis.max = roundPoint(axis.max);
}
function roundBox(box) {
  roundAxis(box.x);
  roundAxis(box.y);
}
function shouldAnimatePositionOnly(animationType, snapshot, layout2) {
  return animationType === "position" || animationType === "preserve-aspect" && !isNear(aspectRatio(snapshot), aspectRatio(layout2), 0.2);
}
function checkNodeWasScrollRoot(node2) {
  return node2 !== node2.root && node2.scroll?.wasRoot;
}
const DocumentProjectionNode = createProjectionNode({
  attachResizeListener: (ref, notify) => addDomEvent(ref, "resize", notify),
  measureScroll: () => ({
    x: document.documentElement.scrollLeft || document.body.scrollLeft,
    y: document.documentElement.scrollTop || document.body.scrollTop
  }),
  checkIsScrollRoot: () => true
});
const rootProjectionNode = {
  current: void 0
};
const HTMLProjectionNode = createProjectionNode({
  measureScroll: (instance) => ({
    x: instance.scrollLeft,
    y: instance.scrollTop
  }),
  defaultParent: () => {
    if (!rootProjectionNode.current) {
      const documentNode = new DocumentProjectionNode({});
      documentNode.mount(window);
      documentNode.setOptions({ layoutScroll: true });
      rootProjectionNode.current = documentNode;
    }
    return rootProjectionNode.current;
  },
  resetTransform: (instance, value) => {
    instance.style.transform = value !== void 0 ? value : "none";
  },
  checkIsScrollRoot: (instance) => Boolean(window.getComputedStyle(instance).position === "fixed")
});
const drag = {
  pan: {
    Feature: PanGesture
  },
  drag: {
    Feature: DragGesture,
    ProjectionNode: HTMLProjectionNode,
    MeasureLayout
  }
};
function handleHoverEvent(node2, event, lifecycle) {
  const { props } = node2;
  if (node2.animationState && props.whileHover) {
    node2.animationState.setActive("whileHover", lifecycle === "Start");
  }
  const eventName = "onHover" + lifecycle;
  const callback = props[eventName];
  if (callback) {
    frame.postRender(() => callback(event, extractEventInfo(event)));
  }
}
class HoverGesture extends Feature {
  mount() {
    const { current } = this.node;
    if (!current)
      return;
    this.unmount = hover(current, (_element, startEvent) => {
      handleHoverEvent(this.node, startEvent, "Start");
      return (endEvent) => handleHoverEvent(this.node, endEvent, "End");
    });
  }
  unmount() {
  }
}
class FocusGesture extends Feature {
  constructor() {
    super(...arguments);
    this.isActive = false;
  }
  onFocus() {
    let isFocusVisible2 = false;
    try {
      isFocusVisible2 = this.node.current.matches(":focus-visible");
    } catch (e2) {
      isFocusVisible2 = true;
    }
    if (!isFocusVisible2 || !this.node.animationState)
      return;
    this.node.animationState.setActive("whileFocus", true);
    this.isActive = true;
  }
  onBlur() {
    if (!this.isActive || !this.node.animationState)
      return;
    this.node.animationState.setActive("whileFocus", false);
    this.isActive = false;
  }
  mount() {
    this.unmount = pipe(addDomEvent(this.node.current, "focus", () => this.onFocus()), addDomEvent(this.node.current, "blur", () => this.onBlur()));
  }
  unmount() {
  }
}
function handlePressEvent(node2, event, lifecycle) {
  const { props } = node2;
  if (node2.current instanceof HTMLButtonElement && node2.current.disabled) {
    return;
  }
  if (node2.animationState && props.whileTap) {
    node2.animationState.setActive("whileTap", lifecycle === "Start");
  }
  const eventName = "onTap" + (lifecycle === "End" ? "" : lifecycle);
  const callback = props[eventName];
  if (callback) {
    frame.postRender(() => callback(event, extractEventInfo(event)));
  }
}
class PressGesture extends Feature {
  mount() {
    const { current } = this.node;
    if (!current)
      return;
    this.unmount = press(current, (_element, startEvent) => {
      handlePressEvent(this.node, startEvent, "Start");
      return (endEvent, { success }) => handlePressEvent(this.node, endEvent, success ? "End" : "Cancel");
    }, { useGlobalTarget: this.node.props.globalTapTarget });
  }
  unmount() {
  }
}
const observerCallbacks = /* @__PURE__ */ new WeakMap();
const observers = /* @__PURE__ */ new WeakMap();
const fireObserverCallback = (entry) => {
  const callback = observerCallbacks.get(entry.target);
  callback && callback(entry);
};
const fireAllObserverCallbacks = (entries) => {
  entries.forEach(fireObserverCallback);
};
function initIntersectionObserver({ root, ...options }) {
  const lookupRoot = root || document;
  if (!observers.has(lookupRoot)) {
    observers.set(lookupRoot, {});
  }
  const rootObservers = observers.get(lookupRoot);
  const key2 = JSON.stringify(options);
  if (!rootObservers[key2]) {
    rootObservers[key2] = new IntersectionObserver(fireAllObserverCallbacks, { root, ...options });
  }
  return rootObservers[key2];
}
function observeIntersection(element, options, callback) {
  const rootInteresectionObserver = initIntersectionObserver(options);
  observerCallbacks.set(element, callback);
  rootInteresectionObserver.observe(element);
  return () => {
    observerCallbacks.delete(element);
    rootInteresectionObserver.unobserve(element);
  };
}
const thresholdNames = {
  some: 0,
  all: 1
};
class InViewFeature extends Feature {
  constructor() {
    super(...arguments);
    this.hasEnteredView = false;
    this.isInView = false;
  }
  startObserver() {
    this.unmount();
    const { viewport = {} } = this.node.getProps();
    const { root, margin: rootMargin, amount = "some", once } = viewport;
    const options = {
      root: root ? root.current : void 0,
      rootMargin,
      threshold: typeof amount === "number" ? amount : thresholdNames[amount]
    };
    const onIntersectionUpdate = (entry) => {
      const { isIntersecting } = entry;
      if (this.isInView === isIntersecting)
        return;
      this.isInView = isIntersecting;
      if (once && !isIntersecting && this.hasEnteredView) {
        return;
      } else if (isIntersecting) {
        this.hasEnteredView = true;
      }
      if (this.node.animationState) {
        this.node.animationState.setActive("whileInView", isIntersecting);
      }
      const { onViewportEnter, onViewportLeave } = this.node.getProps();
      const callback = isIntersecting ? onViewportEnter : onViewportLeave;
      callback && callback(entry);
    };
    return observeIntersection(this.node.current, options, onIntersectionUpdate);
  }
  mount() {
    this.startObserver();
  }
  update() {
    if (typeof IntersectionObserver === "undefined")
      return;
    const { props, prevProps } = this.node;
    const hasOptionsChanged = ["amount", "margin", "root"].some(hasViewportOptionChanged(props, prevProps));
    if (hasOptionsChanged) {
      this.startObserver();
    }
  }
  unmount() {
  }
}
function hasViewportOptionChanged({ viewport = {} }, { viewport: prevViewport = {} } = {}) {
  return (name) => viewport[name] !== prevViewport[name];
}
const gestureAnimations = {
  inView: {
    Feature: InViewFeature
  },
  tap: {
    Feature: PressGesture
  },
  focus: {
    Feature: FocusGesture
  },
  hover: {
    Feature: HoverGesture
  }
};
const layout = {
  layout: {
    ProjectionNode: HTMLProjectionNode,
    MeasureLayout
  }
};
const prefersReducedMotion = { current: null };
const hasReducedMotionListener = { current: false };
function initPrefersReducedMotion() {
  hasReducedMotionListener.current = true;
  if (!isBrowser$2)
    return;
  if (window.matchMedia) {
    const motionMediaQuery = window.matchMedia("(prefers-reduced-motion)");
    const setReducedMotionPreferences = () => prefersReducedMotion.current = motionMediaQuery.matches;
    motionMediaQuery.addEventListener("change", setReducedMotionPreferences);
    setReducedMotionPreferences();
  } else {
    prefersReducedMotion.current = false;
  }
}
const visualElementStore = /* @__PURE__ */ new WeakMap();
function updateMotionValuesFromProps(element, next2, prev2) {
  for (const key2 in next2) {
    const nextValue = next2[key2];
    const prevValue = prev2[key2];
    if (isMotionValue(nextValue)) {
      element.addValue(key2, nextValue);
    } else if (isMotionValue(prevValue)) {
      element.addValue(key2, motionValue(nextValue, { owner: element }));
    } else if (prevValue !== nextValue) {
      if (element.hasValue(key2)) {
        const existingValue = element.getValue(key2);
        if (existingValue.liveStyle === true) {
          existingValue.jump(nextValue);
        } else if (!existingValue.hasAnimated) {
          existingValue.set(nextValue);
        }
      } else {
        const latestValue = element.getStaticValue(key2);
        element.addValue(key2, motionValue(latestValue !== void 0 ? latestValue : nextValue, { owner: element }));
      }
    }
  }
  for (const key2 in prev2) {
    if (next2[key2] === void 0)
      element.removeValue(key2);
  }
  return next2;
}
const propEventHandlers = [
  "AnimationStart",
  "AnimationComplete",
  "Update",
  "BeforeLayoutMeasure",
  "LayoutMeasure",
  "LayoutAnimationStart",
  "LayoutAnimationComplete"
];
class VisualElement {
  /**
   * This method takes React props and returns found MotionValues. For example, HTML
   * MotionValues will be found within the style prop, whereas for Three.js within attribute arrays.
   *
   * This isn't an abstract method as it needs calling in the constructor, but it is
   * intended to be one.
   */
  scrapeMotionValuesFromProps(_props, _prevProps, _visualElement) {
    return {};
  }
  constructor({ parent: parent2, props, presenceContext, reducedMotionConfig, blockInitialAnimation, visualState }, options = {}) {
    this.current = null;
    this.children = /* @__PURE__ */ new Set();
    this.isVariantNode = false;
    this.isControllingVariants = false;
    this.shouldReduceMotion = null;
    this.values = /* @__PURE__ */ new Map();
    this.KeyframeResolver = KeyframeResolver;
    this.features = {};
    this.valueSubscriptions = /* @__PURE__ */ new Map();
    this.prevMotionValues = {};
    this.events = {};
    this.propEventSubscriptions = {};
    this.notifyUpdate = () => this.notify("Update", this.latestValues);
    this.render = () => {
      if (!this.current)
        return;
      this.triggerBuild();
      this.renderInstance(this.current, this.renderState, this.props.style, this.projection);
    };
    this.renderScheduledAt = 0;
    this.scheduleRender = () => {
      const now2 = time.now();
      if (this.renderScheduledAt < now2) {
        this.renderScheduledAt = now2;
        frame.render(this.render, false, true);
      }
    };
    const { latestValues, renderState } = visualState;
    this.latestValues = latestValues;
    this.baseTarget = { ...latestValues };
    this.initialValues = props.initial ? { ...latestValues } : {};
    this.renderState = renderState;
    this.parent = parent2;
    this.props = props;
    this.presenceContext = presenceContext;
    this.depth = parent2 ? parent2.depth + 1 : 0;
    this.reducedMotionConfig = reducedMotionConfig;
    this.options = options;
    this.blockInitialAnimation = Boolean(blockInitialAnimation);
    this.isControllingVariants = isControllingVariants(props);
    this.isVariantNode = isVariantNode(props);
    if (this.isVariantNode) {
      this.variantChildren = /* @__PURE__ */ new Set();
    }
    this.manuallyAnimateOnMount = Boolean(parent2 && parent2.current);
    const { willChange, ...initialMotionValues } = this.scrapeMotionValuesFromProps(props, {}, this);
    for (const key2 in initialMotionValues) {
      const value = initialMotionValues[key2];
      if (latestValues[key2] !== void 0 && isMotionValue(value)) {
        value.set(latestValues[key2], false);
      }
    }
  }
  mount(instance) {
    this.current = instance;
    visualElementStore.set(instance, this);
    if (this.projection && !this.projection.instance) {
      this.projection.mount(instance);
    }
    if (this.parent && this.isVariantNode && !this.isControllingVariants) {
      this.removeFromVariantTree = this.parent.addVariantChild(this);
    }
    this.values.forEach((value, key2) => this.bindToMotionValue(key2, value));
    if (!hasReducedMotionListener.current) {
      initPrefersReducedMotion();
    }
    this.shouldReduceMotion = this.reducedMotionConfig === "never" ? false : this.reducedMotionConfig === "always" ? true : prefersReducedMotion.current;
    if (this.parent)
      this.parent.children.add(this);
    this.update(this.props, this.presenceContext);
  }
  unmount() {
    this.projection && this.projection.unmount();
    cancelFrame(this.notifyUpdate);
    cancelFrame(this.render);
    this.valueSubscriptions.forEach((remove) => remove());
    this.valueSubscriptions.clear();
    this.removeFromVariantTree && this.removeFromVariantTree();
    this.parent && this.parent.children.delete(this);
    for (const key2 in this.events) {
      this.events[key2].clear();
    }
    for (const key2 in this.features) {
      const feature2 = this.features[key2];
      if (feature2) {
        feature2.unmount();
        feature2.isMounted = false;
      }
    }
    this.current = null;
  }
  bindToMotionValue(key2, value) {
    if (this.valueSubscriptions.has(key2)) {
      this.valueSubscriptions.get(key2)();
    }
    const valueIsTransform = transformProps.has(key2);
    if (valueIsTransform && this.onBindTransform) {
      this.onBindTransform();
    }
    const removeOnChange = value.on("change", (latestValue) => {
      this.latestValues[key2] = latestValue;
      this.props.onUpdate && frame.preRender(this.notifyUpdate);
      if (valueIsTransform && this.projection) {
        this.projection.isTransformDirty = true;
      }
    });
    const removeOnRenderRequest = value.on("renderRequest", this.scheduleRender);
    let removeSyncCheck;
    if (window.MotionCheckAppearSync) {
      removeSyncCheck = window.MotionCheckAppearSync(this, key2, value);
    }
    this.valueSubscriptions.set(key2, () => {
      removeOnChange();
      removeOnRenderRequest();
      if (removeSyncCheck)
        removeSyncCheck();
      if (value.owner)
        value.stop();
    });
  }
  sortNodePosition(other) {
    if (!this.current || !this.sortInstanceNodePosition || this.type !== other.type) {
      return 0;
    }
    return this.sortInstanceNodePosition(this.current, other.current);
  }
  updateFeatures() {
    let key2 = "animation";
    for (key2 in featureDefinitions) {
      const featureDefinition = featureDefinitions[key2];
      if (!featureDefinition)
        continue;
      const { isEnabled, Feature: FeatureConstructor } = featureDefinition;
      if (!this.features[key2] && FeatureConstructor && isEnabled(this.props)) {
        this.features[key2] = new FeatureConstructor(this);
      }
      if (this.features[key2]) {
        const feature2 = this.features[key2];
        if (feature2.isMounted) {
          feature2.update();
        } else {
          feature2.mount();
          feature2.isMounted = true;
        }
      }
    }
  }
  triggerBuild() {
    this.build(this.renderState, this.latestValues, this.props);
  }
  /**
   * Measure the current viewport box with or without transforms.
   * Only measures axis-aligned boxes, rotate and skew must be manually
   * removed with a re-render to work.
   */
  measureViewportBox() {
    return this.current ? this.measureInstanceViewportBox(this.current, this.props) : createBox$1();
  }
  getStaticValue(key2) {
    return this.latestValues[key2];
  }
  setStaticValue(key2, value) {
    this.latestValues[key2] = value;
  }
  /**
   * Update the provided props. Ensure any newly-added motion values are
   * added to our map, old ones removed, and listeners updated.
   */
  update(props, presenceContext) {
    if (props.transformTemplate || this.props.transformTemplate) {
      this.scheduleRender();
    }
    this.prevProps = this.props;
    this.props = props;
    this.prevPresenceContext = this.presenceContext;
    this.presenceContext = presenceContext;
    for (let i2 = 0; i2 < propEventHandlers.length; i2++) {
      const key2 = propEventHandlers[i2];
      if (this.propEventSubscriptions[key2]) {
        this.propEventSubscriptions[key2]();
        delete this.propEventSubscriptions[key2];
      }
      const listenerName = "on" + key2;
      const listener = props[listenerName];
      if (listener) {
        this.propEventSubscriptions[key2] = this.on(key2, listener);
      }
    }
    this.prevMotionValues = updateMotionValuesFromProps(this, this.scrapeMotionValuesFromProps(props, this.prevProps, this), this.prevMotionValues);
    if (this.handleChildMotionValue) {
      this.handleChildMotionValue();
    }
  }
  getProps() {
    return this.props;
  }
  /**
   * Returns the variant definition with a given name.
   */
  getVariant(name) {
    return this.props.variants ? this.props.variants[name] : void 0;
  }
  /**
   * Returns the defined default transition on this component.
   */
  getDefaultTransition() {
    return this.props.transition;
  }
  getTransformPagePoint() {
    return this.props.transformPagePoint;
  }
  getClosestVariantNode() {
    return this.isVariantNode ? this : this.parent ? this.parent.getClosestVariantNode() : void 0;
  }
  /**
   * Add a child visual element to our set of children.
   */
  addVariantChild(child) {
    const closestVariantNode = this.getClosestVariantNode();
    if (closestVariantNode) {
      closestVariantNode.variantChildren && closestVariantNode.variantChildren.add(child);
      return () => closestVariantNode.variantChildren.delete(child);
    }
  }
  /**
   * Add a motion value and bind it to this visual element.
   */
  addValue(key2, value) {
    const existingValue = this.values.get(key2);
    if (value !== existingValue) {
      if (existingValue)
        this.removeValue(key2);
      this.bindToMotionValue(key2, value);
      this.values.set(key2, value);
      this.latestValues[key2] = value.get();
    }
  }
  /**
   * Remove a motion value and unbind any active subscriptions.
   */
  removeValue(key2) {
    this.values.delete(key2);
    const unsubscribe = this.valueSubscriptions.get(key2);
    if (unsubscribe) {
      unsubscribe();
      this.valueSubscriptions.delete(key2);
    }
    delete this.latestValues[key2];
    this.removeValueFromRenderState(key2, this.renderState);
  }
  /**
   * Check whether we have a motion value for this key
   */
  hasValue(key2) {
    return this.values.has(key2);
  }
  getValue(key2, defaultValue) {
    if (this.props.values && this.props.values[key2]) {
      return this.props.values[key2];
    }
    let value = this.values.get(key2);
    if (value === void 0 && defaultValue !== void 0) {
      value = motionValue(defaultValue === null ? void 0 : defaultValue, { owner: this });
      this.addValue(key2, value);
    }
    return value;
  }
  /**
   * If we're trying to animate to a previously unencountered value,
   * we need to check for it in our state and as a last resort read it
   * directly from the instance (which might have performance implications).
   */
  readValue(key2, target) {
    let value = this.latestValues[key2] !== void 0 || !this.current ? this.latestValues[key2] : this.getBaseTargetFromProps(this.props, key2) ?? this.readValueFromInstance(this.current, key2, this.options);
    if (value !== void 0 && value !== null) {
      if (typeof value === "string" && (isNumericalString(value) || isZeroValueString(value))) {
        value = parseFloat(value);
      } else if (!findValueType(value) && complex.test(target)) {
        value = getAnimatableNone(key2, target);
      }
      this.setBaseTarget(key2, isMotionValue(value) ? value.get() : value);
    }
    return isMotionValue(value) ? value.get() : value;
  }
  /**
   * Set the base target to later animate back to. This is currently
   * only hydrated on creation and when we first read a value.
   */
  setBaseTarget(key2, value) {
    this.baseTarget[key2] = value;
  }
  /**
   * Find the base target for a value thats been removed from all animation
   * props.
   */
  getBaseTarget(key2) {
    const { initial } = this.props;
    let valueFromInitial;
    if (typeof initial === "string" || typeof initial === "object") {
      const variant = resolveVariantFromProps(this.props, initial, this.presenceContext?.custom);
      if (variant) {
        valueFromInitial = variant[key2];
      }
    }
    if (initial && valueFromInitial !== void 0) {
      return valueFromInitial;
    }
    const target = this.getBaseTargetFromProps(this.props, key2);
    if (target !== void 0 && !isMotionValue(target))
      return target;
    return this.initialValues[key2] !== void 0 && valueFromInitial === void 0 ? void 0 : this.baseTarget[key2];
  }
  on(eventName, callback) {
    if (!this.events[eventName]) {
      this.events[eventName] = new SubscriptionManager();
    }
    return this.events[eventName].add(callback);
  }
  notify(eventName, ...args) {
    if (this.events[eventName]) {
      this.events[eventName].notify(...args);
    }
  }
}
class DOMVisualElement extends VisualElement {
  constructor() {
    super(...arguments);
    this.KeyframeResolver = DOMKeyframesResolver;
  }
  sortInstanceNodePosition(a2, b2) {
    return a2.compareDocumentPosition(b2) & 2 ? 1 : -1;
  }
  getBaseTargetFromProps(props, key2) {
    return props.style ? props.style[key2] : void 0;
  }
  removeValueFromRenderState(key2, { vars, style: style2 }) {
    delete vars[key2];
    delete style2[key2];
  }
  handleChildMotionValue() {
    if (this.childSubscription) {
      this.childSubscription();
      delete this.childSubscription;
    }
    const { children } = this.props;
    if (isMotionValue(children)) {
      this.childSubscription = children.on("change", (latest) => {
        if (this.current) {
          this.current.textContent = `${latest}`;
        }
      });
    }
  }
}
function renderHTML(element, { style: style2, vars }, styleProp, projection) {
  const elementStyle = element.style;
  let key2;
  for (key2 in style2) {
    elementStyle[key2] = style2[key2];
  }
  projection?.applyProjectionStyles(elementStyle, styleProp);
  for (key2 in vars) {
    elementStyle.setProperty(key2, vars[key2]);
  }
}
function getComputedStyle$2(element) {
  return window.getComputedStyle(element);
}
class HTMLVisualElement extends DOMVisualElement {
  constructor() {
    super(...arguments);
    this.type = "html";
    this.renderInstance = renderHTML;
  }
  readValueFromInstance(instance, key2) {
    if (transformProps.has(key2)) {
      return this.projection?.isProjecting ? defaultTransformValue(key2) : readTransformValue(instance, key2);
    } else {
      const computedStyle = getComputedStyle$2(instance);
      const value = (isCSSVariableName(key2) ? computedStyle.getPropertyValue(key2) : computedStyle[key2]) || 0;
      return typeof value === "string" ? value.trim() : value;
    }
  }
  measureInstanceViewportBox(instance, { transformPagePoint }) {
    return measureViewportBox(instance, transformPagePoint);
  }
  build(renderState, latestValues, props) {
    buildHTMLStyles(renderState, latestValues, props.transformTemplate);
  }
  scrapeMotionValuesFromProps(props, prevProps, visualElement) {
    return scrapeMotionValuesFromProps$1(props, prevProps, visualElement);
  }
}
const camelCaseAttributes = /* @__PURE__ */ new Set([
  "baseFrequency",
  "diffuseConstant",
  "kernelMatrix",
  "kernelUnitLength",
  "keySplines",
  "keyTimes",
  "limitingConeAngle",
  "markerHeight",
  "markerWidth",
  "numOctaves",
  "targetX",
  "targetY",
  "surfaceScale",
  "specularConstant",
  "specularExponent",
  "stdDeviation",
  "tableValues",
  "viewBox",
  "gradientTransform",
  "pathLength",
  "startOffset",
  "textLength",
  "lengthAdjust"
]);
function renderSVG(element, renderState, _styleProp, projection) {
  renderHTML(element, renderState, void 0, projection);
  for (const key2 in renderState.attrs) {
    element.setAttribute(!camelCaseAttributes.has(key2) ? camelToDash(key2) : key2, renderState.attrs[key2]);
  }
}
class SVGVisualElement extends DOMVisualElement {
  constructor() {
    super(...arguments);
    this.type = "svg";
    this.isSVGTag = false;
    this.measureInstanceViewportBox = createBox$1;
  }
  getBaseTargetFromProps(props, key2) {
    return props[key2];
  }
  readValueFromInstance(instance, key2) {
    if (transformProps.has(key2)) {
      const defaultType = getDefaultValueType(key2);
      return defaultType ? defaultType.default || 0 : 0;
    }
    key2 = !camelCaseAttributes.has(key2) ? camelToDash(key2) : key2;
    return instance.getAttribute(key2);
  }
  scrapeMotionValuesFromProps(props, prevProps, visualElement) {
    return scrapeMotionValuesFromProps(props, prevProps, visualElement);
  }
  build(renderState, latestValues, props) {
    buildSVGAttrs(renderState, latestValues, this.isSVGTag, props.transformTemplate, props.style);
  }
  renderInstance(instance, renderState, styleProp, projection) {
    renderSVG(instance, renderState, styleProp, projection);
  }
  mount(instance) {
    this.isSVGTag = isSVGTag(instance.tagName);
    super.mount(instance);
  }
}
const createDomVisualElement = (Component, options) => {
  return isSVGComponent(Component) ? new SVGVisualElement(options) : new HTMLVisualElement(options, {
    allowProjection: Component !== reactExports.Fragment
  });
};
const createMotionComponent = /* @__PURE__ */ createMotionComponentFactory({
  ...animations,
  ...gestureAnimations,
  ...drag,
  ...layout
}, createDomVisualElement);
const motion = /* @__PURE__ */ createDOMMotionComponentProxy(createMotionComponent);
function useMotionValue(initial) {
  const value = useConstant(() => motionValue(initial));
  const { isStatic } = reactExports.useContext(MotionConfigContext);
  if (isStatic) {
    const [, setLatest] = reactExports.useState(initial);
    reactExports.useEffect(() => value.on("change", setLatest), []);
  }
  return value;
}
function useCombineMotionValues(values2, combineValues) {
  const value = useMotionValue(combineValues());
  const updateValue = () => value.set(combineValues());
  updateValue();
  useIsomorphicLayoutEffect$1(() => {
    const scheduleUpdate = () => frame.preRender(updateValue, false, true);
    const subscriptions = values2.map((v2) => v2.on("change", scheduleUpdate));
    return () => {
      subscriptions.forEach((unsubscribe) => unsubscribe());
      cancelFrame(updateValue);
    };
  });
  return value;
}
function useComputed(compute) {
  collectMotionValues.current = [];
  compute();
  const value = useCombineMotionValues(collectMotionValues.current, compute);
  collectMotionValues.current = void 0;
  return value;
}
function useTransform(input, inputRangeOrTransformer, outputRange, options) {
  if (typeof input === "function") {
    return useComputed(input);
  }
  const transformer = typeof inputRangeOrTransformer === "function" ? inputRangeOrTransformer : transform(inputRangeOrTransformer, outputRange, options);
  return Array.isArray(input) ? useListTransform(input, transformer) : useListTransform([input], ([latest]) => transformer(latest));
}
function useListTransform(values2, transformer) {
  const latest = useConstant(() => []);
  return useCombineMotionValues(values2, () => {
    latest.length = 0;
    const numValues = values2.length;
    for (let i2 = 0; i2 < numValues; i2++) {
      latest[i2] = values2[i2].get();
    }
    return transformer(latest);
  });
}
function forwardRef(component) {
  return reactExports.forwardRef(component);
}
var mapPropsVariants = (props, variantKeys, removeVariantProps = true) => {
  if (!variantKeys) {
    return [props, {}];
  }
  const picked = variantKeys.reduce((acc, key2) => {
    if (key2 in props) {
      return { ...acc, [key2]: props[key2] };
    } else {
      return acc;
    }
  }, {});
  if (removeVariantProps) {
    const omitted = Object.keys(props).filter((key2) => !variantKeys.includes(key2)).reduce((acc, key2) => ({ ...acc, [key2]: props[key2] }), {});
    return [omitted, picked];
  } else {
    return [props, picked];
  }
};
var solid = {
  default: "bg-default text-default-foreground",
  primary: "bg-primary text-primary-foreground",
  secondary: "bg-secondary text-secondary-foreground",
  success: "bg-success text-success-foreground",
  warning: "bg-warning text-warning-foreground",
  danger: "bg-danger text-danger-foreground",
  foreground: "bg-foreground text-background"
};
var shadow = {
  default: "shadow-lg shadow-default/50 bg-default text-default-foreground",
  primary: "shadow-lg shadow-primary/40 bg-primary text-primary-foreground",
  secondary: "shadow-lg shadow-secondary/40 bg-secondary text-secondary-foreground",
  success: "shadow-lg shadow-success/40 bg-success text-success-foreground",
  warning: "shadow-lg shadow-warning/40 bg-warning text-warning-foreground",
  danger: "shadow-lg shadow-danger/40 bg-danger text-danger-foreground",
  foreground: "shadow-lg shadow-foreground/40 bg-foreground text-background"
};
var bordered = {
  default: "bg-transparent border-default text-foreground",
  primary: "bg-transparent border-primary text-primary",
  secondary: "bg-transparent border-secondary text-secondary",
  success: "bg-transparent border-success text-success",
  warning: "bg-transparent border-warning text-warning",
  danger: "bg-transparent border-danger text-danger",
  foreground: "bg-transparent border-foreground text-foreground"
};
var flat = {
  default: "bg-default/40 text-default-700",
  primary: "bg-primary/20 text-primary-600",
  secondary: "bg-secondary/20 text-secondary-600",
  success: "bg-success/20 text-success-700 dark:text-success",
  warning: "bg-warning/20 text-warning-700 dark:text-warning",
  danger: "bg-danger/20 text-danger-600 dark:text-danger-500",
  foreground: "bg-foreground/10 text-foreground"
};
var faded = {
  default: "border-default bg-default-100 text-default-foreground",
  primary: "border-default bg-default-100 text-primary",
  secondary: "border-default bg-default-100 text-secondary",
  success: "border-default bg-default-100 text-success",
  warning: "border-default bg-default-100 text-warning",
  danger: "border-default bg-default-100 text-danger",
  foreground: "border-default bg-default-100 text-foreground"
};
var light$1 = {
  default: "bg-transparent text-default-foreground",
  primary: "bg-transparent text-primary",
  secondary: "bg-transparent text-secondary",
  success: "bg-transparent text-success",
  warning: "bg-transparent text-warning",
  danger: "bg-transparent text-danger",
  foreground: "bg-transparent text-foreground"
};
var ghost = {
  default: "border-default text-default-foreground",
  primary: "border-primary text-primary",
  secondary: "border-secondary text-secondary",
  success: "border-success text-success",
  warning: "border-warning text-warning",
  danger: "border-danger text-danger",
  foreground: "border-foreground text-foreground hover:!bg-foreground"
};
var colorVariants = {
  solid,
  shadow,
  bordered,
  flat,
  faded,
  light: light$1,
  ghost
};
var COMMON_UNITS = ["small", "medium", "large"];
var twMergeConfig = {
  theme: {
    opacity: ["disabled"],
    spacing: ["divider"],
    borderWidth: COMMON_UNITS,
    borderRadius: COMMON_UNITS
  },
  classGroups: {
    shadow: [{ shadow: COMMON_UNITS }],
    "font-size": [{ text: ["tiny", ...COMMON_UNITS] }],
    "bg-image": [
      "bg-stripe-gradient-default",
      "bg-stripe-gradient-primary",
      "bg-stripe-gradient-secondary",
      "bg-stripe-gradient-success",
      "bg-stripe-gradient-warning",
      "bg-stripe-gradient-danger"
    ]
  }
};
var l$1 = (e2) => typeof e2 == "boolean" ? `${e2}` : e2 === 0 ? "0" : e2, u$1 = (e2) => !e2 || typeof e2 != "object" || Object.keys(e2).length === 0, x$2 = (e2, o) => JSON.stringify(e2) === JSON.stringify(o);
function i(e2, o) {
  e2.forEach(function(r2) {
    Array.isArray(r2) ? i(r2, o) : o.push(r2);
  });
}
function y$1(e2) {
  let o = [];
  return i(e2, o), o;
}
var a = (...e2) => y$1(e2).filter(Boolean), p$1 = (e2, o) => {
  let r2 = {}, c2 = Object.keys(e2), f2 = Object.keys(o);
  for (let t2 of c2) if (f2.includes(t2)) {
    let s = e2[t2], n2 = o[t2];
    Array.isArray(s) || Array.isArray(n2) ? r2[t2] = a(n2, s) : typeof s == "object" && typeof n2 == "object" ? r2[t2] = p$1(s, n2) : r2[t2] = n2 + " " + s;
  } else r2[t2] = e2[t2];
  for (let t2 of f2) c2.includes(t2) || (r2[t2] = o[t2]);
  return r2;
}, g$1 = (e2) => !e2 || typeof e2 != "string" ? e2 : e2.replace(/\s+/g, " ").trim();
const CLASS_PART_SEPARATOR = "-";
const createClassGroupUtils = (config2) => {
  const classMap = createClassMap(config2);
  const {
    conflictingClassGroups,
    conflictingClassGroupModifiers
  } = config2;
  const getClassGroupId = (className) => {
    const classParts = className.split(CLASS_PART_SEPARATOR);
    if (classParts[0] === "" && classParts.length !== 1) {
      classParts.shift();
    }
    return getGroupRecursive(classParts, classMap) || getGroupIdForArbitraryProperty(className);
  };
  const getConflictingClassGroupIds = (classGroupId, hasPostfixModifier) => {
    const conflicts = conflictingClassGroups[classGroupId] || [];
    if (hasPostfixModifier && conflictingClassGroupModifiers[classGroupId]) {
      return [...conflicts, ...conflictingClassGroupModifiers[classGroupId]];
    }
    return conflicts;
  };
  return {
    getClassGroupId,
    getConflictingClassGroupIds
  };
};
const getGroupRecursive = (classParts, classPartObject) => {
  if (classParts.length === 0) {
    return classPartObject.classGroupId;
  }
  const currentClassPart = classParts[0];
  const nextClassPartObject = classPartObject.nextPart.get(currentClassPart);
  const classGroupFromNextClassPart = nextClassPartObject ? getGroupRecursive(classParts.slice(1), nextClassPartObject) : void 0;
  if (classGroupFromNextClassPart) {
    return classGroupFromNextClassPart;
  }
  if (classPartObject.validators.length === 0) {
    return void 0;
  }
  const classRest = classParts.join(CLASS_PART_SEPARATOR);
  return classPartObject.validators.find(({
    validator
  }) => validator(classRest))?.classGroupId;
};
const arbitraryPropertyRegex = /^\[(.+)\]$/;
const getGroupIdForArbitraryProperty = (className) => {
  if (arbitraryPropertyRegex.test(className)) {
    const arbitraryPropertyClassName = arbitraryPropertyRegex.exec(className)[1];
    const property = arbitraryPropertyClassName?.substring(0, arbitraryPropertyClassName.indexOf(":"));
    if (property) {
      return "arbitrary.." + property;
    }
  }
};
const createClassMap = (config2) => {
  const {
    theme,
    prefix: prefix2
  } = config2;
  const classMap = {
    nextPart: /* @__PURE__ */ new Map(),
    validators: []
  };
  const prefixedClassGroupEntries = getPrefixedClassGroupEntries(Object.entries(config2.classGroups), prefix2);
  prefixedClassGroupEntries.forEach(([classGroupId, classGroup]) => {
    processClassesRecursively(classGroup, classMap, classGroupId, theme);
  });
  return classMap;
};
const processClassesRecursively = (classGroup, classPartObject, classGroupId, theme) => {
  classGroup.forEach((classDefinition) => {
    if (typeof classDefinition === "string") {
      const classPartObjectToEdit = classDefinition === "" ? classPartObject : getPart(classPartObject, classDefinition);
      classPartObjectToEdit.classGroupId = classGroupId;
      return;
    }
    if (typeof classDefinition === "function") {
      if (isThemeGetter(classDefinition)) {
        processClassesRecursively(classDefinition(theme), classPartObject, classGroupId, theme);
        return;
      }
      classPartObject.validators.push({
        validator: classDefinition,
        classGroupId
      });
      return;
    }
    Object.entries(classDefinition).forEach(([key2, classGroup2]) => {
      processClassesRecursively(classGroup2, getPart(classPartObject, key2), classGroupId, theme);
    });
  });
};
const getPart = (classPartObject, path) => {
  let currentClassPartObject = classPartObject;
  path.split(CLASS_PART_SEPARATOR).forEach((pathPart) => {
    if (!currentClassPartObject.nextPart.has(pathPart)) {
      currentClassPartObject.nextPart.set(pathPart, {
        nextPart: /* @__PURE__ */ new Map(),
        validators: []
      });
    }
    currentClassPartObject = currentClassPartObject.nextPart.get(pathPart);
  });
  return currentClassPartObject;
};
const isThemeGetter = (func) => func.isThemeGetter;
const getPrefixedClassGroupEntries = (classGroupEntries, prefix2) => {
  if (!prefix2) {
    return classGroupEntries;
  }
  return classGroupEntries.map(([classGroupId, classGroup]) => {
    const prefixedClassGroup = classGroup.map((classDefinition) => {
      if (typeof classDefinition === "string") {
        return prefix2 + classDefinition;
      }
      if (typeof classDefinition === "object") {
        return Object.fromEntries(Object.entries(classDefinition).map(([key2, value]) => [prefix2 + key2, value]));
      }
      return classDefinition;
    });
    return [classGroupId, prefixedClassGroup];
  });
};
const createLruCache = (maxCacheSize) => {
  if (maxCacheSize < 1) {
    return {
      get: () => void 0,
      set: () => {
      }
    };
  }
  let cacheSize = 0;
  let cache = /* @__PURE__ */ new Map();
  let previousCache = /* @__PURE__ */ new Map();
  const update = (key2, value) => {
    cache.set(key2, value);
    cacheSize++;
    if (cacheSize > maxCacheSize) {
      cacheSize = 0;
      previousCache = cache;
      cache = /* @__PURE__ */ new Map();
    }
  };
  return {
    get(key2) {
      let value = cache.get(key2);
      if (value !== void 0) {
        return value;
      }
      if ((value = previousCache.get(key2)) !== void 0) {
        update(key2, value);
        return value;
      }
    },
    set(key2, value) {
      if (cache.has(key2)) {
        cache.set(key2, value);
      } else {
        update(key2, value);
      }
    }
  };
};
const IMPORTANT_MODIFIER = "!";
const createParseClassName = (config2) => {
  const {
    separator,
    experimentalParseClassName
  } = config2;
  const isSeparatorSingleCharacter = separator.length === 1;
  const firstSeparatorCharacter = separator[0];
  const separatorLength = separator.length;
  const parseClassName = (className) => {
    const modifiers = [];
    let bracketDepth = 0;
    let modifierStart = 0;
    let postfixModifierPosition;
    for (let index2 = 0; index2 < className.length; index2++) {
      let currentCharacter = className[index2];
      if (bracketDepth === 0) {
        if (currentCharacter === firstSeparatorCharacter && (isSeparatorSingleCharacter || className.slice(index2, index2 + separatorLength) === separator)) {
          modifiers.push(className.slice(modifierStart, index2));
          modifierStart = index2 + separatorLength;
          continue;
        }
        if (currentCharacter === "/") {
          postfixModifierPosition = index2;
          continue;
        }
      }
      if (currentCharacter === "[") {
        bracketDepth++;
      } else if (currentCharacter === "]") {
        bracketDepth--;
      }
    }
    const baseClassNameWithImportantModifier = modifiers.length === 0 ? className : className.substring(modifierStart);
    const hasImportantModifier = baseClassNameWithImportantModifier.startsWith(IMPORTANT_MODIFIER);
    const baseClassName = hasImportantModifier ? baseClassNameWithImportantModifier.substring(1) : baseClassNameWithImportantModifier;
    const maybePostfixModifierPosition = postfixModifierPosition && postfixModifierPosition > modifierStart ? postfixModifierPosition - modifierStart : void 0;
    return {
      modifiers,
      hasImportantModifier,
      baseClassName,
      maybePostfixModifierPosition
    };
  };
  if (experimentalParseClassName) {
    return (className) => experimentalParseClassName({
      className,
      parseClassName
    });
  }
  return parseClassName;
};
const sortModifiers = (modifiers) => {
  if (modifiers.length <= 1) {
    return modifiers;
  }
  const sortedModifiers = [];
  let unsortedModifiers = [];
  modifiers.forEach((modifier) => {
    const isArbitraryVariant = modifier[0] === "[";
    if (isArbitraryVariant) {
      sortedModifiers.push(...unsortedModifiers.sort(), modifier);
      unsortedModifiers = [];
    } else {
      unsortedModifiers.push(modifier);
    }
  });
  sortedModifiers.push(...unsortedModifiers.sort());
  return sortedModifiers;
};
const createConfigUtils = (config2) => ({
  cache: createLruCache(config2.cacheSize),
  parseClassName: createParseClassName(config2),
  ...createClassGroupUtils(config2)
});
const SPLIT_CLASSES_REGEX = /\s+/;
const mergeClassList = (classList, configUtils) => {
  const {
    parseClassName,
    getClassGroupId,
    getConflictingClassGroupIds
  } = configUtils;
  const classGroupsInConflict = [];
  const classNames = classList.trim().split(SPLIT_CLASSES_REGEX);
  let result = "";
  for (let index2 = classNames.length - 1; index2 >= 0; index2 -= 1) {
    const originalClassName = classNames[index2];
    const {
      modifiers,
      hasImportantModifier,
      baseClassName,
      maybePostfixModifierPosition
    } = parseClassName(originalClassName);
    let hasPostfixModifier = Boolean(maybePostfixModifierPosition);
    let classGroupId = getClassGroupId(hasPostfixModifier ? baseClassName.substring(0, maybePostfixModifierPosition) : baseClassName);
    if (!classGroupId) {
      if (!hasPostfixModifier) {
        result = originalClassName + (result.length > 0 ? " " + result : result);
        continue;
      }
      classGroupId = getClassGroupId(baseClassName);
      if (!classGroupId) {
        result = originalClassName + (result.length > 0 ? " " + result : result);
        continue;
      }
      hasPostfixModifier = false;
    }
    const variantModifier = sortModifiers(modifiers).join(":");
    const modifierId = hasImportantModifier ? variantModifier + IMPORTANT_MODIFIER : variantModifier;
    const classId = modifierId + classGroupId;
    if (classGroupsInConflict.includes(classId)) {
      continue;
    }
    classGroupsInConflict.push(classId);
    const conflictGroups = getConflictingClassGroupIds(classGroupId, hasPostfixModifier);
    for (let i2 = 0; i2 < conflictGroups.length; ++i2) {
      const group = conflictGroups[i2];
      classGroupsInConflict.push(modifierId + group);
    }
    result = originalClassName + (result.length > 0 ? " " + result : result);
  }
  return result;
};
function twJoin() {
  let index2 = 0;
  let argument;
  let resolvedValue;
  let string = "";
  while (index2 < arguments.length) {
    if (argument = arguments[index2++]) {
      if (resolvedValue = toValue(argument)) {
        string && (string += " ");
        string += resolvedValue;
      }
    }
  }
  return string;
}
const toValue = (mix2) => {
  if (typeof mix2 === "string") {
    return mix2;
  }
  let resolvedValue;
  let string = "";
  for (let k2 = 0; k2 < mix2.length; k2++) {
    if (mix2[k2]) {
      if (resolvedValue = toValue(mix2[k2])) {
        string && (string += " ");
        string += resolvedValue;
      }
    }
  }
  return string;
};
function createTailwindMerge(createConfigFirst, ...createConfigRest) {
  let configUtils;
  let cacheGet;
  let cacheSet;
  let functionToCall = initTailwindMerge;
  function initTailwindMerge(classList) {
    const config2 = createConfigRest.reduce((previousConfig, createConfigCurrent) => createConfigCurrent(previousConfig), createConfigFirst());
    configUtils = createConfigUtils(config2);
    cacheGet = configUtils.cache.get;
    cacheSet = configUtils.cache.set;
    functionToCall = tailwindMerge;
    return tailwindMerge(classList);
  }
  function tailwindMerge(classList) {
    const cachedResult = cacheGet(classList);
    if (cachedResult) {
      return cachedResult;
    }
    const result = mergeClassList(classList, configUtils);
    cacheSet(classList, result);
    return result;
  }
  return function callTailwindMerge() {
    return functionToCall(twJoin.apply(null, arguments));
  };
}
const fromTheme = (key2) => {
  const themeGetter = (theme) => theme[key2] || [];
  themeGetter.isThemeGetter = true;
  return themeGetter;
};
const arbitraryValueRegex = /^\[(?:([a-z-]+):)?(.+)\]$/i;
const fractionRegex = /^\d+\/\d+$/;
const stringLengths = /* @__PURE__ */ new Set(["px", "full", "screen"]);
const tshirtUnitRegex = /^(\d+(\.\d+)?)?(xs|sm|md|lg|xl)$/;
const lengthUnitRegex = /\d+(%|px|r?em|[sdl]?v([hwib]|min|max)|pt|pc|in|cm|mm|cap|ch|ex|r?lh|cq(w|h|i|b|min|max))|\b(calc|min|max|clamp)\(.+\)|^0$/;
const colorFunctionRegex = /^(rgba?|hsla?|hwb|(ok)?(lab|lch))\(.+\)$/;
const shadowRegex = /^(inset_)?-?((\d+)?\.?(\d+)[a-z]+|0)_-?((\d+)?\.?(\d+)[a-z]+|0)/;
const imageRegex = /^(url|image|image-set|cross-fade|element|(repeating-)?(linear|radial|conic)-gradient)\(.+\)$/;
const isLength = (value) => isNumber$1(value) || stringLengths.has(value) || fractionRegex.test(value);
const isArbitraryLength = (value) => getIsArbitraryValue(value, "length", isLengthOnly);
const isNumber$1 = (value) => Boolean(value) && !Number.isNaN(Number(value));
const isArbitraryNumber = (value) => getIsArbitraryValue(value, "number", isNumber$1);
const isInteger = (value) => Boolean(value) && Number.isInteger(Number(value));
const isPercent = (value) => value.endsWith("%") && isNumber$1(value.slice(0, -1));
const isArbitraryValue = (value) => arbitraryValueRegex.test(value);
const isTshirtSize = (value) => tshirtUnitRegex.test(value);
const sizeLabels = /* @__PURE__ */ new Set(["length", "size", "percentage"]);
const isArbitrarySize = (value) => getIsArbitraryValue(value, sizeLabels, isNever);
const isArbitraryPosition = (value) => getIsArbitraryValue(value, "position", isNever);
const imageLabels = /* @__PURE__ */ new Set(["image", "url"]);
const isArbitraryImage = (value) => getIsArbitraryValue(value, imageLabels, isImage);
const isArbitraryShadow = (value) => getIsArbitraryValue(value, "", isShadow);
const isAny = () => true;
const getIsArbitraryValue = (value, label, testValue) => {
  const result = arbitraryValueRegex.exec(value);
  if (result) {
    if (result[1]) {
      return typeof label === "string" ? result[1] === label : label.has(result[1]);
    }
    return testValue(result[2]);
  }
  return false;
};
const isLengthOnly = (value) => (
  // `colorFunctionRegex` check is necessary because color functions can have percentages in them which which would be incorrectly classified as lengths.
  // For example, `hsl(0 0% 0%)` would be classified as a length without this check.
  // I could also use lookbehind assertion in `lengthUnitRegex` but that isn't supported widely enough.
  lengthUnitRegex.test(value) && !colorFunctionRegex.test(value)
);
const isNever = () => false;
const isShadow = (value) => shadowRegex.test(value);
const isImage = (value) => imageRegex.test(value);
const getDefaultConfig = () => {
  const colors = fromTheme("colors");
  const spacing = fromTheme("spacing");
  const blur = fromTheme("blur");
  const brightness = fromTheme("brightness");
  const borderColor2 = fromTheme("borderColor");
  const borderRadius2 = fromTheme("borderRadius");
  const borderSpacing = fromTheme("borderSpacing");
  const borderWidth = fromTheme("borderWidth");
  const contrast = fromTheme("contrast");
  const grayscale = fromTheme("grayscale");
  const hueRotate = fromTheme("hueRotate");
  const invert = fromTheme("invert");
  const gap2 = fromTheme("gap");
  const gradientColorStops = fromTheme("gradientColorStops");
  const gradientColorStopPositions = fromTheme("gradientColorStopPositions");
  const inset = fromTheme("inset");
  const margin2 = fromTheme("margin");
  const opacity = fromTheme("opacity");
  const padding2 = fromTheme("padding");
  const saturate = fromTheme("saturate");
  const scale2 = fromTheme("scale");
  const sepia = fromTheme("sepia");
  const skew = fromTheme("skew");
  const space = fromTheme("space");
  const translate = fromTheme("translate");
  const getOverscroll = () => ["auto", "contain", "none"];
  const getOverflow = () => ["auto", "hidden", "clip", "visible", "scroll"];
  const getSpacingWithAutoAndArbitrary = () => ["auto", isArbitraryValue, spacing];
  const getSpacingWithArbitrary = () => [isArbitraryValue, spacing];
  const getLengthWithEmptyAndArbitrary = () => ["", isLength, isArbitraryLength];
  const getNumberWithAutoAndArbitrary = () => ["auto", isNumber$1, isArbitraryValue];
  const getPositions = () => ["bottom", "center", "left", "left-bottom", "left-top", "right", "right-bottom", "right-top", "top"];
  const getLineStyles = () => ["solid", "dashed", "dotted", "double", "none"];
  const getBlendModes = () => ["normal", "multiply", "screen", "overlay", "darken", "lighten", "color-dodge", "color-burn", "hard-light", "soft-light", "difference", "exclusion", "hue", "saturation", "color", "luminosity"];
  const getAlign = () => ["start", "end", "center", "between", "around", "evenly", "stretch"];
  const getZeroAndEmpty = () => ["", "0", isArbitraryValue];
  const getBreaks = () => ["auto", "avoid", "all", "avoid-page", "page", "left", "right", "column"];
  const getNumberAndArbitrary = () => [isNumber$1, isArbitraryValue];
  return {
    cacheSize: 500,
    separator: ":",
    theme: {
      colors: [isAny],
      spacing: [isLength, isArbitraryLength],
      blur: ["none", "", isTshirtSize, isArbitraryValue],
      brightness: getNumberAndArbitrary(),
      borderColor: [colors],
      borderRadius: ["none", "", "full", isTshirtSize, isArbitraryValue],
      borderSpacing: getSpacingWithArbitrary(),
      borderWidth: getLengthWithEmptyAndArbitrary(),
      contrast: getNumberAndArbitrary(),
      grayscale: getZeroAndEmpty(),
      hueRotate: getNumberAndArbitrary(),
      invert: getZeroAndEmpty(),
      gap: getSpacingWithArbitrary(),
      gradientColorStops: [colors],
      gradientColorStopPositions: [isPercent, isArbitraryLength],
      inset: getSpacingWithAutoAndArbitrary(),
      margin: getSpacingWithAutoAndArbitrary(),
      opacity: getNumberAndArbitrary(),
      padding: getSpacingWithArbitrary(),
      saturate: getNumberAndArbitrary(),
      scale: getNumberAndArbitrary(),
      sepia: getZeroAndEmpty(),
      skew: getNumberAndArbitrary(),
      space: getSpacingWithArbitrary(),
      translate: getSpacingWithArbitrary()
    },
    classGroups: {
      // Layout
      /**
       * Aspect Ratio
       * @see https://tailwindcss.com/docs/aspect-ratio
       */
      aspect: [{
        aspect: ["auto", "square", "video", isArbitraryValue]
      }],
      /**
       * Container
       * @see https://tailwindcss.com/docs/container
       */
      container: ["container"],
      /**
       * Columns
       * @see https://tailwindcss.com/docs/columns
       */
      columns: [{
        columns: [isTshirtSize]
      }],
      /**
       * Break After
       * @see https://tailwindcss.com/docs/break-after
       */
      "break-after": [{
        "break-after": getBreaks()
      }],
      /**
       * Break Before
       * @see https://tailwindcss.com/docs/break-before
       */
      "break-before": [{
        "break-before": getBreaks()
      }],
      /**
       * Break Inside
       * @see https://tailwindcss.com/docs/break-inside
       */
      "break-inside": [{
        "break-inside": ["auto", "avoid", "avoid-page", "avoid-column"]
      }],
      /**
       * Box Decoration Break
       * @see https://tailwindcss.com/docs/box-decoration-break
       */
      "box-decoration": [{
        "box-decoration": ["slice", "clone"]
      }],
      /**
       * Box Sizing
       * @see https://tailwindcss.com/docs/box-sizing
       */
      box: [{
        box: ["border", "content"]
      }],
      /**
       * Display
       * @see https://tailwindcss.com/docs/display
       */
      display: ["block", "inline-block", "inline", "flex", "inline-flex", "table", "inline-table", "table-caption", "table-cell", "table-column", "table-column-group", "table-footer-group", "table-header-group", "table-row-group", "table-row", "flow-root", "grid", "inline-grid", "contents", "list-item", "hidden"],
      /**
       * Floats
       * @see https://tailwindcss.com/docs/float
       */
      float: [{
        float: ["right", "left", "none", "start", "end"]
      }],
      /**
       * Clear
       * @see https://tailwindcss.com/docs/clear
       */
      clear: [{
        clear: ["left", "right", "both", "none", "start", "end"]
      }],
      /**
       * Isolation
       * @see https://tailwindcss.com/docs/isolation
       */
      isolation: ["isolate", "isolation-auto"],
      /**
       * Object Fit
       * @see https://tailwindcss.com/docs/object-fit
       */
      "object-fit": [{
        object: ["contain", "cover", "fill", "none", "scale-down"]
      }],
      /**
       * Object Position
       * @see https://tailwindcss.com/docs/object-position
       */
      "object-position": [{
        object: [...getPositions(), isArbitraryValue]
      }],
      /**
       * Overflow
       * @see https://tailwindcss.com/docs/overflow
       */
      overflow: [{
        overflow: getOverflow()
      }],
      /**
       * Overflow X
       * @see https://tailwindcss.com/docs/overflow
       */
      "overflow-x": [{
        "overflow-x": getOverflow()
      }],
      /**
       * Overflow Y
       * @see https://tailwindcss.com/docs/overflow
       */
      "overflow-y": [{
        "overflow-y": getOverflow()
      }],
      /**
       * Overscroll Behavior
       * @see https://tailwindcss.com/docs/overscroll-behavior
       */
      overscroll: [{
        overscroll: getOverscroll()
      }],
      /**
       * Overscroll Behavior X
       * @see https://tailwindcss.com/docs/overscroll-behavior
       */
      "overscroll-x": [{
        "overscroll-x": getOverscroll()
      }],
      /**
       * Overscroll Behavior Y
       * @see https://tailwindcss.com/docs/overscroll-behavior
       */
      "overscroll-y": [{
        "overscroll-y": getOverscroll()
      }],
      /**
       * Position
       * @see https://tailwindcss.com/docs/position
       */
      position: ["static", "fixed", "absolute", "relative", "sticky"],
      /**
       * Top / Right / Bottom / Left
       * @see https://tailwindcss.com/docs/top-right-bottom-left
       */
      inset: [{
        inset: [inset]
      }],
      /**
       * Right / Left
       * @see https://tailwindcss.com/docs/top-right-bottom-left
       */
      "inset-x": [{
        "inset-x": [inset]
      }],
      /**
       * Top / Bottom
       * @see https://tailwindcss.com/docs/top-right-bottom-left
       */
      "inset-y": [{
        "inset-y": [inset]
      }],
      /**
       * Start
       * @see https://tailwindcss.com/docs/top-right-bottom-left
       */
      start: [{
        start: [inset]
      }],
      /**
       * End
       * @see https://tailwindcss.com/docs/top-right-bottom-left
       */
      end: [{
        end: [inset]
      }],
      /**
       * Top
       * @see https://tailwindcss.com/docs/top-right-bottom-left
       */
      top: [{
        top: [inset]
      }],
      /**
       * Right
       * @see https://tailwindcss.com/docs/top-right-bottom-left
       */
      right: [{
        right: [inset]
      }],
      /**
       * Bottom
       * @see https://tailwindcss.com/docs/top-right-bottom-left
       */
      bottom: [{
        bottom: [inset]
      }],
      /**
       * Left
       * @see https://tailwindcss.com/docs/top-right-bottom-left
       */
      left: [{
        left: [inset]
      }],
      /**
       * Visibility
       * @see https://tailwindcss.com/docs/visibility
       */
      visibility: ["visible", "invisible", "collapse"],
      /**
       * Z-Index
       * @see https://tailwindcss.com/docs/z-index
       */
      z: [{
        z: ["auto", isInteger, isArbitraryValue]
      }],
      // Flexbox and Grid
      /**
       * Flex Basis
       * @see https://tailwindcss.com/docs/flex-basis
       */
      basis: [{
        basis: getSpacingWithAutoAndArbitrary()
      }],
      /**
       * Flex Direction
       * @see https://tailwindcss.com/docs/flex-direction
       */
      "flex-direction": [{
        flex: ["row", "row-reverse", "col", "col-reverse"]
      }],
      /**
       * Flex Wrap
       * @see https://tailwindcss.com/docs/flex-wrap
       */
      "flex-wrap": [{
        flex: ["wrap", "wrap-reverse", "nowrap"]
      }],
      /**
       * Flex
       * @see https://tailwindcss.com/docs/flex
       */
      flex: [{
        flex: ["1", "auto", "initial", "none", isArbitraryValue]
      }],
      /**
       * Flex Grow
       * @see https://tailwindcss.com/docs/flex-grow
       */
      grow: [{
        grow: getZeroAndEmpty()
      }],
      /**
       * Flex Shrink
       * @see https://tailwindcss.com/docs/flex-shrink
       */
      shrink: [{
        shrink: getZeroAndEmpty()
      }],
      /**
       * Order
       * @see https://tailwindcss.com/docs/order
       */
      order: [{
        order: ["first", "last", "none", isInteger, isArbitraryValue]
      }],
      /**
       * Grid Template Columns
       * @see https://tailwindcss.com/docs/grid-template-columns
       */
      "grid-cols": [{
        "grid-cols": [isAny]
      }],
      /**
       * Grid Column Start / End
       * @see https://tailwindcss.com/docs/grid-column
       */
      "col-start-end": [{
        col: ["auto", {
          span: ["full", isInteger, isArbitraryValue]
        }, isArbitraryValue]
      }],
      /**
       * Grid Column Start
       * @see https://tailwindcss.com/docs/grid-column
       */
      "col-start": [{
        "col-start": getNumberWithAutoAndArbitrary()
      }],
      /**
       * Grid Column End
       * @see https://tailwindcss.com/docs/grid-column
       */
      "col-end": [{
        "col-end": getNumberWithAutoAndArbitrary()
      }],
      /**
       * Grid Template Rows
       * @see https://tailwindcss.com/docs/grid-template-rows
       */
      "grid-rows": [{
        "grid-rows": [isAny]
      }],
      /**
       * Grid Row Start / End
       * @see https://tailwindcss.com/docs/grid-row
       */
      "row-start-end": [{
        row: ["auto", {
          span: [isInteger, isArbitraryValue]
        }, isArbitraryValue]
      }],
      /**
       * Grid Row Start
       * @see https://tailwindcss.com/docs/grid-row
       */
      "row-start": [{
        "row-start": getNumberWithAutoAndArbitrary()
      }],
      /**
       * Grid Row End
       * @see https://tailwindcss.com/docs/grid-row
       */
      "row-end": [{
        "row-end": getNumberWithAutoAndArbitrary()
      }],
      /**
       * Grid Auto Flow
       * @see https://tailwindcss.com/docs/grid-auto-flow
       */
      "grid-flow": [{
        "grid-flow": ["row", "col", "dense", "row-dense", "col-dense"]
      }],
      /**
       * Grid Auto Columns
       * @see https://tailwindcss.com/docs/grid-auto-columns
       */
      "auto-cols": [{
        "auto-cols": ["auto", "min", "max", "fr", isArbitraryValue]
      }],
      /**
       * Grid Auto Rows
       * @see https://tailwindcss.com/docs/grid-auto-rows
       */
      "auto-rows": [{
        "auto-rows": ["auto", "min", "max", "fr", isArbitraryValue]
      }],
      /**
       * Gap
       * @see https://tailwindcss.com/docs/gap
       */
      gap: [{
        gap: [gap2]
      }],
      /**
       * Gap X
       * @see https://tailwindcss.com/docs/gap
       */
      "gap-x": [{
        "gap-x": [gap2]
      }],
      /**
       * Gap Y
       * @see https://tailwindcss.com/docs/gap
       */
      "gap-y": [{
        "gap-y": [gap2]
      }],
      /**
       * Justify Content
       * @see https://tailwindcss.com/docs/justify-content
       */
      "justify-content": [{
        justify: ["normal", ...getAlign()]
      }],
      /**
       * Justify Items
       * @see https://tailwindcss.com/docs/justify-items
       */
      "justify-items": [{
        "justify-items": ["start", "end", "center", "stretch"]
      }],
      /**
       * Justify Self
       * @see https://tailwindcss.com/docs/justify-self
       */
      "justify-self": [{
        "justify-self": ["auto", "start", "end", "center", "stretch"]
      }],
      /**
       * Align Content
       * @see https://tailwindcss.com/docs/align-content
       */
      "align-content": [{
        content: ["normal", ...getAlign(), "baseline"]
      }],
      /**
       * Align Items
       * @see https://tailwindcss.com/docs/align-items
       */
      "align-items": [{
        items: ["start", "end", "center", "baseline", "stretch"]
      }],
      /**
       * Align Self
       * @see https://tailwindcss.com/docs/align-self
       */
      "align-self": [{
        self: ["auto", "start", "end", "center", "stretch", "baseline"]
      }],
      /**
       * Place Content
       * @see https://tailwindcss.com/docs/place-content
       */
      "place-content": [{
        "place-content": [...getAlign(), "baseline"]
      }],
      /**
       * Place Items
       * @see https://tailwindcss.com/docs/place-items
       */
      "place-items": [{
        "place-items": ["start", "end", "center", "baseline", "stretch"]
      }],
      /**
       * Place Self
       * @see https://tailwindcss.com/docs/place-self
       */
      "place-self": [{
        "place-self": ["auto", "start", "end", "center", "stretch"]
      }],
      // Spacing
      /**
       * Padding
       * @see https://tailwindcss.com/docs/padding
       */
      p: [{
        p: [padding2]
      }],
      /**
       * Padding X
       * @see https://tailwindcss.com/docs/padding
       */
      px: [{
        px: [padding2]
      }],
      /**
       * Padding Y
       * @see https://tailwindcss.com/docs/padding
       */
      py: [{
        py: [padding2]
      }],
      /**
       * Padding Start
       * @see https://tailwindcss.com/docs/padding
       */
      ps: [{
        ps: [padding2]
      }],
      /**
       * Padding End
       * @see https://tailwindcss.com/docs/padding
       */
      pe: [{
        pe: [padding2]
      }],
      /**
       * Padding Top
       * @see https://tailwindcss.com/docs/padding
       */
      pt: [{
        pt: [padding2]
      }],
      /**
       * Padding Right
       * @see https://tailwindcss.com/docs/padding
       */
      pr: [{
        pr: [padding2]
      }],
      /**
       * Padding Bottom
       * @see https://tailwindcss.com/docs/padding
       */
      pb: [{
        pb: [padding2]
      }],
      /**
       * Padding Left
       * @see https://tailwindcss.com/docs/padding
       */
      pl: [{
        pl: [padding2]
      }],
      /**
       * Margin
       * @see https://tailwindcss.com/docs/margin
       */
      m: [{
        m: [margin2]
      }],
      /**
       * Margin X
       * @see https://tailwindcss.com/docs/margin
       */
      mx: [{
        mx: [margin2]
      }],
      /**
       * Margin Y
       * @see https://tailwindcss.com/docs/margin
       */
      my: [{
        my: [margin2]
      }],
      /**
       * Margin Start
       * @see https://tailwindcss.com/docs/margin
       */
      ms: [{
        ms: [margin2]
      }],
      /**
       * Margin End
       * @see https://tailwindcss.com/docs/margin
       */
      me: [{
        me: [margin2]
      }],
      /**
       * Margin Top
       * @see https://tailwindcss.com/docs/margin
       */
      mt: [{
        mt: [margin2]
      }],
      /**
       * Margin Right
       * @see https://tailwindcss.com/docs/margin
       */
      mr: [{
        mr: [margin2]
      }],
      /**
       * Margin Bottom
       * @see https://tailwindcss.com/docs/margin
       */
      mb: [{
        mb: [margin2]
      }],
      /**
       * Margin Left
       * @see https://tailwindcss.com/docs/margin
       */
      ml: [{
        ml: [margin2]
      }],
      /**
       * Space Between X
       * @see https://tailwindcss.com/docs/space
       */
      "space-x": [{
        "space-x": [space]
      }],
      /**
       * Space Between X Reverse
       * @see https://tailwindcss.com/docs/space
       */
      "space-x-reverse": ["space-x-reverse"],
      /**
       * Space Between Y
       * @see https://tailwindcss.com/docs/space
       */
      "space-y": [{
        "space-y": [space]
      }],
      /**
       * Space Between Y Reverse
       * @see https://tailwindcss.com/docs/space
       */
      "space-y-reverse": ["space-y-reverse"],
      // Sizing
      /**
       * Width
       * @see https://tailwindcss.com/docs/width
       */
      w: [{
        w: ["auto", "min", "max", "fit", "svw", "lvw", "dvw", isArbitraryValue, spacing]
      }],
      /**
       * Min-Width
       * @see https://tailwindcss.com/docs/min-width
       */
      "min-w": [{
        "min-w": [isArbitraryValue, spacing, "min", "max", "fit"]
      }],
      /**
       * Max-Width
       * @see https://tailwindcss.com/docs/max-width
       */
      "max-w": [{
        "max-w": [isArbitraryValue, spacing, "none", "full", "min", "max", "fit", "prose", {
          screen: [isTshirtSize]
        }, isTshirtSize]
      }],
      /**
       * Height
       * @see https://tailwindcss.com/docs/height
       */
      h: [{
        h: [isArbitraryValue, spacing, "auto", "min", "max", "fit", "svh", "lvh", "dvh"]
      }],
      /**
       * Min-Height
       * @see https://tailwindcss.com/docs/min-height
       */
      "min-h": [{
        "min-h": [isArbitraryValue, spacing, "min", "max", "fit", "svh", "lvh", "dvh"]
      }],
      /**
       * Max-Height
       * @see https://tailwindcss.com/docs/max-height
       */
      "max-h": [{
        "max-h": [isArbitraryValue, spacing, "min", "max", "fit", "svh", "lvh", "dvh"]
      }],
      /**
       * Size
       * @see https://tailwindcss.com/docs/size
       */
      size: [{
        size: [isArbitraryValue, spacing, "auto", "min", "max", "fit"]
      }],
      // Typography
      /**
       * Font Size
       * @see https://tailwindcss.com/docs/font-size
       */
      "font-size": [{
        text: ["base", isTshirtSize, isArbitraryLength]
      }],
      /**
       * Font Smoothing
       * @see https://tailwindcss.com/docs/font-smoothing
       */
      "font-smoothing": ["antialiased", "subpixel-antialiased"],
      /**
       * Font Style
       * @see https://tailwindcss.com/docs/font-style
       */
      "font-style": ["italic", "not-italic"],
      /**
       * Font Weight
       * @see https://tailwindcss.com/docs/font-weight
       */
      "font-weight": [{
        font: ["thin", "extralight", "light", "normal", "medium", "semibold", "bold", "extrabold", "black", isArbitraryNumber]
      }],
      /**
       * Font Family
       * @see https://tailwindcss.com/docs/font-family
       */
      "font-family": [{
        font: [isAny]
      }],
      /**
       * Font Variant Numeric
       * @see https://tailwindcss.com/docs/font-variant-numeric
       */
      "fvn-normal": ["normal-nums"],
      /**
       * Font Variant Numeric
       * @see https://tailwindcss.com/docs/font-variant-numeric
       */
      "fvn-ordinal": ["ordinal"],
      /**
       * Font Variant Numeric
       * @see https://tailwindcss.com/docs/font-variant-numeric
       */
      "fvn-slashed-zero": ["slashed-zero"],
      /**
       * Font Variant Numeric
       * @see https://tailwindcss.com/docs/font-variant-numeric
       */
      "fvn-figure": ["lining-nums", "oldstyle-nums"],
      /**
       * Font Variant Numeric
       * @see https://tailwindcss.com/docs/font-variant-numeric
       */
      "fvn-spacing": ["proportional-nums", "tabular-nums"],
      /**
       * Font Variant Numeric
       * @see https://tailwindcss.com/docs/font-variant-numeric
       */
      "fvn-fraction": ["diagonal-fractions", "stacked-fractons"],
      /**
       * Letter Spacing
       * @see https://tailwindcss.com/docs/letter-spacing
       */
      tracking: [{
        tracking: ["tighter", "tight", "normal", "wide", "wider", "widest", isArbitraryValue]
      }],
      /**
       * Line Clamp
       * @see https://tailwindcss.com/docs/line-clamp
       */
      "line-clamp": [{
        "line-clamp": ["none", isNumber$1, isArbitraryNumber]
      }],
      /**
       * Line Height
       * @see https://tailwindcss.com/docs/line-height
       */
      leading: [{
        leading: ["none", "tight", "snug", "normal", "relaxed", "loose", isLength, isArbitraryValue]
      }],
      /**
       * List Style Image
       * @see https://tailwindcss.com/docs/list-style-image
       */
      "list-image": [{
        "list-image": ["none", isArbitraryValue]
      }],
      /**
       * List Style Type
       * @see https://tailwindcss.com/docs/list-style-type
       */
      "list-style-type": [{
        list: ["none", "disc", "decimal", isArbitraryValue]
      }],
      /**
       * List Style Position
       * @see https://tailwindcss.com/docs/list-style-position
       */
      "list-style-position": [{
        list: ["inside", "outside"]
      }],
      /**
       * Placeholder Color
       * @deprecated since Tailwind CSS v3.0.0
       * @see https://tailwindcss.com/docs/placeholder-color
       */
      "placeholder-color": [{
        placeholder: [colors]
      }],
      /**
       * Placeholder Opacity
       * @see https://tailwindcss.com/docs/placeholder-opacity
       */
      "placeholder-opacity": [{
        "placeholder-opacity": [opacity]
      }],
      /**
       * Text Alignment
       * @see https://tailwindcss.com/docs/text-align
       */
      "text-alignment": [{
        text: ["left", "center", "right", "justify", "start", "end"]
      }],
      /**
       * Text Color
       * @see https://tailwindcss.com/docs/text-color
       */
      "text-color": [{
        text: [colors]
      }],
      /**
       * Text Opacity
       * @see https://tailwindcss.com/docs/text-opacity
       */
      "text-opacity": [{
        "text-opacity": [opacity]
      }],
      /**
       * Text Decoration
       * @see https://tailwindcss.com/docs/text-decoration
       */
      "text-decoration": ["underline", "overline", "line-through", "no-underline"],
      /**
       * Text Decoration Style
       * @see https://tailwindcss.com/docs/text-decoration-style
       */
      "text-decoration-style": [{
        decoration: [...getLineStyles(), "wavy"]
      }],
      /**
       * Text Decoration Thickness
       * @see https://tailwindcss.com/docs/text-decoration-thickness
       */
      "text-decoration-thickness": [{
        decoration: ["auto", "from-font", isLength, isArbitraryLength]
      }],
      /**
       * Text Underline Offset
       * @see https://tailwindcss.com/docs/text-underline-offset
       */
      "underline-offset": [{
        "underline-offset": ["auto", isLength, isArbitraryValue]
      }],
      /**
       * Text Decoration Color
       * @see https://tailwindcss.com/docs/text-decoration-color
       */
      "text-decoration-color": [{
        decoration: [colors]
      }],
      /**
       * Text Transform
       * @see https://tailwindcss.com/docs/text-transform
       */
      "text-transform": ["uppercase", "lowercase", "capitalize", "normal-case"],
      /**
       * Text Overflow
       * @see https://tailwindcss.com/docs/text-overflow
       */
      "text-overflow": ["truncate", "text-ellipsis", "text-clip"],
      /**
       * Text Wrap
       * @see https://tailwindcss.com/docs/text-wrap
       */
      "text-wrap": [{
        text: ["wrap", "nowrap", "balance", "pretty"]
      }],
      /**
       * Text Indent
       * @see https://tailwindcss.com/docs/text-indent
       */
      indent: [{
        indent: getSpacingWithArbitrary()
      }],
      /**
       * Vertical Alignment
       * @see https://tailwindcss.com/docs/vertical-align
       */
      "vertical-align": [{
        align: ["baseline", "top", "middle", "bottom", "text-top", "text-bottom", "sub", "super", isArbitraryValue]
      }],
      /**
       * Whitespace
       * @see https://tailwindcss.com/docs/whitespace
       */
      whitespace: [{
        whitespace: ["normal", "nowrap", "pre", "pre-line", "pre-wrap", "break-spaces"]
      }],
      /**
       * Word Break
       * @see https://tailwindcss.com/docs/word-break
       */
      break: [{
        break: ["normal", "words", "all", "keep"]
      }],
      /**
       * Hyphens
       * @see https://tailwindcss.com/docs/hyphens
       */
      hyphens: [{
        hyphens: ["none", "manual", "auto"]
      }],
      /**
       * Content
       * @see https://tailwindcss.com/docs/content
       */
      content: [{
        content: ["none", isArbitraryValue]
      }],
      // Backgrounds
      /**
       * Background Attachment
       * @see https://tailwindcss.com/docs/background-attachment
       */
      "bg-attachment": [{
        bg: ["fixed", "local", "scroll"]
      }],
      /**
       * Background Clip
       * @see https://tailwindcss.com/docs/background-clip
       */
      "bg-clip": [{
        "bg-clip": ["border", "padding", "content", "text"]
      }],
      /**
       * Background Opacity
       * @deprecated since Tailwind CSS v3.0.0
       * @see https://tailwindcss.com/docs/background-opacity
       */
      "bg-opacity": [{
        "bg-opacity": [opacity]
      }],
      /**
       * Background Origin
       * @see https://tailwindcss.com/docs/background-origin
       */
      "bg-origin": [{
        "bg-origin": ["border", "padding", "content"]
      }],
      /**
       * Background Position
       * @see https://tailwindcss.com/docs/background-position
       */
      "bg-position": [{
        bg: [...getPositions(), isArbitraryPosition]
      }],
      /**
       * Background Repeat
       * @see https://tailwindcss.com/docs/background-repeat
       */
      "bg-repeat": [{
        bg: ["no-repeat", {
          repeat: ["", "x", "y", "round", "space"]
        }]
      }],
      /**
       * Background Size
       * @see https://tailwindcss.com/docs/background-size
       */
      "bg-size": [{
        bg: ["auto", "cover", "contain", isArbitrarySize]
      }],
      /**
       * Background Image
       * @see https://tailwindcss.com/docs/background-image
       */
      "bg-image": [{
        bg: ["none", {
          "gradient-to": ["t", "tr", "r", "br", "b", "bl", "l", "tl"]
        }, isArbitraryImage]
      }],
      /**
       * Background Color
       * @see https://tailwindcss.com/docs/background-color
       */
      "bg-color": [{
        bg: [colors]
      }],
      /**
       * Gradient Color Stops From Position
       * @see https://tailwindcss.com/docs/gradient-color-stops
       */
      "gradient-from-pos": [{
        from: [gradientColorStopPositions]
      }],
      /**
       * Gradient Color Stops Via Position
       * @see https://tailwindcss.com/docs/gradient-color-stops
       */
      "gradient-via-pos": [{
        via: [gradientColorStopPositions]
      }],
      /**
       * Gradient Color Stops To Position
       * @see https://tailwindcss.com/docs/gradient-color-stops
       */
      "gradient-to-pos": [{
        to: [gradientColorStopPositions]
      }],
      /**
       * Gradient Color Stops From
       * @see https://tailwindcss.com/docs/gradient-color-stops
       */
      "gradient-from": [{
        from: [gradientColorStops]
      }],
      /**
       * Gradient Color Stops Via
       * @see https://tailwindcss.com/docs/gradient-color-stops
       */
      "gradient-via": [{
        via: [gradientColorStops]
      }],
      /**
       * Gradient Color Stops To
       * @see https://tailwindcss.com/docs/gradient-color-stops
       */
      "gradient-to": [{
        to: [gradientColorStops]
      }],
      // Borders
      /**
       * Border Radius
       * @see https://tailwindcss.com/docs/border-radius
       */
      rounded: [{
        rounded: [borderRadius2]
      }],
      /**
       * Border Radius Start
       * @see https://tailwindcss.com/docs/border-radius
       */
      "rounded-s": [{
        "rounded-s": [borderRadius2]
      }],
      /**
       * Border Radius End
       * @see https://tailwindcss.com/docs/border-radius
       */
      "rounded-e": [{
        "rounded-e": [borderRadius2]
      }],
      /**
       * Border Radius Top
       * @see https://tailwindcss.com/docs/border-radius
       */
      "rounded-t": [{
        "rounded-t": [borderRadius2]
      }],
      /**
       * Border Radius Right
       * @see https://tailwindcss.com/docs/border-radius
       */
      "rounded-r": [{
        "rounded-r": [borderRadius2]
      }],
      /**
       * Border Radius Bottom
       * @see https://tailwindcss.com/docs/border-radius
       */
      "rounded-b": [{
        "rounded-b": [borderRadius2]
      }],
      /**
       * Border Radius Left
       * @see https://tailwindcss.com/docs/border-radius
       */
      "rounded-l": [{
        "rounded-l": [borderRadius2]
      }],
      /**
       * Border Radius Start Start
       * @see https://tailwindcss.com/docs/border-radius
       */
      "rounded-ss": [{
        "rounded-ss": [borderRadius2]
      }],
      /**
       * Border Radius Start End
       * @see https://tailwindcss.com/docs/border-radius
       */
      "rounded-se": [{
        "rounded-se": [borderRadius2]
      }],
      /**
       * Border Radius End End
       * @see https://tailwindcss.com/docs/border-radius
       */
      "rounded-ee": [{
        "rounded-ee": [borderRadius2]
      }],
      /**
       * Border Radius End Start
       * @see https://tailwindcss.com/docs/border-radius
       */
      "rounded-es": [{
        "rounded-es": [borderRadius2]
      }],
      /**
       * Border Radius Top Left
       * @see https://tailwindcss.com/docs/border-radius
       */
      "rounded-tl": [{
        "rounded-tl": [borderRadius2]
      }],
      /**
       * Border Radius Top Right
       * @see https://tailwindcss.com/docs/border-radius
       */
      "rounded-tr": [{
        "rounded-tr": [borderRadius2]
      }],
      /**
       * Border Radius Bottom Right
       * @see https://tailwindcss.com/docs/border-radius
       */
      "rounded-br": [{
        "rounded-br": [borderRadius2]
      }],
      /**
       * Border Radius Bottom Left
       * @see https://tailwindcss.com/docs/border-radius
       */
      "rounded-bl": [{
        "rounded-bl": [borderRadius2]
      }],
      /**
       * Border Width
       * @see https://tailwindcss.com/docs/border-width
       */
      "border-w": [{
        border: [borderWidth]
      }],
      /**
       * Border Width X
       * @see https://tailwindcss.com/docs/border-width
       */
      "border-w-x": [{
        "border-x": [borderWidth]
      }],
      /**
       * Border Width Y
       * @see https://tailwindcss.com/docs/border-width
       */
      "border-w-y": [{
        "border-y": [borderWidth]
      }],
      /**
       * Border Width Start
       * @see https://tailwindcss.com/docs/border-width
       */
      "border-w-s": [{
        "border-s": [borderWidth]
      }],
      /**
       * Border Width End
       * @see https://tailwindcss.com/docs/border-width
       */
      "border-w-e": [{
        "border-e": [borderWidth]
      }],
      /**
       * Border Width Top
       * @see https://tailwindcss.com/docs/border-width
       */
      "border-w-t": [{
        "border-t": [borderWidth]
      }],
      /**
       * Border Width Right
       * @see https://tailwindcss.com/docs/border-width
       */
      "border-w-r": [{
        "border-r": [borderWidth]
      }],
      /**
       * Border Width Bottom
       * @see https://tailwindcss.com/docs/border-width
       */
      "border-w-b": [{
        "border-b": [borderWidth]
      }],
      /**
       * Border Width Left
       * @see https://tailwindcss.com/docs/border-width
       */
      "border-w-l": [{
        "border-l": [borderWidth]
      }],
      /**
       * Border Opacity
       * @see https://tailwindcss.com/docs/border-opacity
       */
      "border-opacity": [{
        "border-opacity": [opacity]
      }],
      /**
       * Border Style
       * @see https://tailwindcss.com/docs/border-style
       */
      "border-style": [{
        border: [...getLineStyles(), "hidden"]
      }],
      /**
       * Divide Width X
       * @see https://tailwindcss.com/docs/divide-width
       */
      "divide-x": [{
        "divide-x": [borderWidth]
      }],
      /**
       * Divide Width X Reverse
       * @see https://tailwindcss.com/docs/divide-width
       */
      "divide-x-reverse": ["divide-x-reverse"],
      /**
       * Divide Width Y
       * @see https://tailwindcss.com/docs/divide-width
       */
      "divide-y": [{
        "divide-y": [borderWidth]
      }],
      /**
       * Divide Width Y Reverse
       * @see https://tailwindcss.com/docs/divide-width
       */
      "divide-y-reverse": ["divide-y-reverse"],
      /**
       * Divide Opacity
       * @see https://tailwindcss.com/docs/divide-opacity
       */
      "divide-opacity": [{
        "divide-opacity": [opacity]
      }],
      /**
       * Divide Style
       * @see https://tailwindcss.com/docs/divide-style
       */
      "divide-style": [{
        divide: getLineStyles()
      }],
      /**
       * Border Color
       * @see https://tailwindcss.com/docs/border-color
       */
      "border-color": [{
        border: [borderColor2]
      }],
      /**
       * Border Color X
       * @see https://tailwindcss.com/docs/border-color
       */
      "border-color-x": [{
        "border-x": [borderColor2]
      }],
      /**
       * Border Color Y
       * @see https://tailwindcss.com/docs/border-color
       */
      "border-color-y": [{
        "border-y": [borderColor2]
      }],
      /**
       * Border Color S
       * @see https://tailwindcss.com/docs/border-color
       */
      "border-color-s": [{
        "border-s": [borderColor2]
      }],
      /**
       * Border Color E
       * @see https://tailwindcss.com/docs/border-color
       */
      "border-color-e": [{
        "border-e": [borderColor2]
      }],
      /**
       * Border Color Top
       * @see https://tailwindcss.com/docs/border-color
       */
      "border-color-t": [{
        "border-t": [borderColor2]
      }],
      /**
       * Border Color Right
       * @see https://tailwindcss.com/docs/border-color
       */
      "border-color-r": [{
        "border-r": [borderColor2]
      }],
      /**
       * Border Color Bottom
       * @see https://tailwindcss.com/docs/border-color
       */
      "border-color-b": [{
        "border-b": [borderColor2]
      }],
      /**
       * Border Color Left
       * @see https://tailwindcss.com/docs/border-color
       */
      "border-color-l": [{
        "border-l": [borderColor2]
      }],
      /**
       * Divide Color
       * @see https://tailwindcss.com/docs/divide-color
       */
      "divide-color": [{
        divide: [borderColor2]
      }],
      /**
       * Outline Style
       * @see https://tailwindcss.com/docs/outline-style
       */
      "outline-style": [{
        outline: ["", ...getLineStyles()]
      }],
      /**
       * Outline Offset
       * @see https://tailwindcss.com/docs/outline-offset
       */
      "outline-offset": [{
        "outline-offset": [isLength, isArbitraryValue]
      }],
      /**
       * Outline Width
       * @see https://tailwindcss.com/docs/outline-width
       */
      "outline-w": [{
        outline: [isLength, isArbitraryLength]
      }],
      /**
       * Outline Color
       * @see https://tailwindcss.com/docs/outline-color
       */
      "outline-color": [{
        outline: [colors]
      }],
      /**
       * Ring Width
       * @see https://tailwindcss.com/docs/ring-width
       */
      "ring-w": [{
        ring: getLengthWithEmptyAndArbitrary()
      }],
      /**
       * Ring Width Inset
       * @see https://tailwindcss.com/docs/ring-width
       */
      "ring-w-inset": ["ring-inset"],
      /**
       * Ring Color
       * @see https://tailwindcss.com/docs/ring-color
       */
      "ring-color": [{
        ring: [colors]
      }],
      /**
       * Ring Opacity
       * @see https://tailwindcss.com/docs/ring-opacity
       */
      "ring-opacity": [{
        "ring-opacity": [opacity]
      }],
      /**
       * Ring Offset Width
       * @see https://tailwindcss.com/docs/ring-offset-width
       */
      "ring-offset-w": [{
        "ring-offset": [isLength, isArbitraryLength]
      }],
      /**
       * Ring Offset Color
       * @see https://tailwindcss.com/docs/ring-offset-color
       */
      "ring-offset-color": [{
        "ring-offset": [colors]
      }],
      // Effects
      /**
       * Box Shadow
       * @see https://tailwindcss.com/docs/box-shadow
       */
      shadow: [{
        shadow: ["", "inner", "none", isTshirtSize, isArbitraryShadow]
      }],
      /**
       * Box Shadow Color
       * @see https://tailwindcss.com/docs/box-shadow-color
       */
      "shadow-color": [{
        shadow: [isAny]
      }],
      /**
       * Opacity
       * @see https://tailwindcss.com/docs/opacity
       */
      opacity: [{
        opacity: [opacity]
      }],
      /**
       * Mix Blend Mode
       * @see https://tailwindcss.com/docs/mix-blend-mode
       */
      "mix-blend": [{
        "mix-blend": [...getBlendModes(), "plus-lighter", "plus-darker"]
      }],
      /**
       * Background Blend Mode
       * @see https://tailwindcss.com/docs/background-blend-mode
       */
      "bg-blend": [{
        "bg-blend": getBlendModes()
      }],
      // Filters
      /**
       * Filter
       * @deprecated since Tailwind CSS v3.0.0
       * @see https://tailwindcss.com/docs/filter
       */
      filter: [{
        filter: ["", "none"]
      }],
      /**
       * Blur
       * @see https://tailwindcss.com/docs/blur
       */
      blur: [{
        blur: [blur]
      }],
      /**
       * Brightness
       * @see https://tailwindcss.com/docs/brightness
       */
      brightness: [{
        brightness: [brightness]
      }],
      /**
       * Contrast
       * @see https://tailwindcss.com/docs/contrast
       */
      contrast: [{
        contrast: [contrast]
      }],
      /**
       * Drop Shadow
       * @see https://tailwindcss.com/docs/drop-shadow
       */
      "drop-shadow": [{
        "drop-shadow": ["", "none", isTshirtSize, isArbitraryValue]
      }],
      /**
       * Grayscale
       * @see https://tailwindcss.com/docs/grayscale
       */
      grayscale: [{
        grayscale: [grayscale]
      }],
      /**
       * Hue Rotate
       * @see https://tailwindcss.com/docs/hue-rotate
       */
      "hue-rotate": [{
        "hue-rotate": [hueRotate]
      }],
      /**
       * Invert
       * @see https://tailwindcss.com/docs/invert
       */
      invert: [{
        invert: [invert]
      }],
      /**
       * Saturate
       * @see https://tailwindcss.com/docs/saturate
       */
      saturate: [{
        saturate: [saturate]
      }],
      /**
       * Sepia
       * @see https://tailwindcss.com/docs/sepia
       */
      sepia: [{
        sepia: [sepia]
      }],
      /**
       * Backdrop Filter
       * @deprecated since Tailwind CSS v3.0.0
       * @see https://tailwindcss.com/docs/backdrop-filter
       */
      "backdrop-filter": [{
        "backdrop-filter": ["", "none"]
      }],
      /**
       * Backdrop Blur
       * @see https://tailwindcss.com/docs/backdrop-blur
       */
      "backdrop-blur": [{
        "backdrop-blur": [blur]
      }],
      /**
       * Backdrop Brightness
       * @see https://tailwindcss.com/docs/backdrop-brightness
       */
      "backdrop-brightness": [{
        "backdrop-brightness": [brightness]
      }],
      /**
       * Backdrop Contrast
       * @see https://tailwindcss.com/docs/backdrop-contrast
       */
      "backdrop-contrast": [{
        "backdrop-contrast": [contrast]
      }],
      /**
       * Backdrop Grayscale
       * @see https://tailwindcss.com/docs/backdrop-grayscale
       */
      "backdrop-grayscale": [{
        "backdrop-grayscale": [grayscale]
      }],
      /**
       * Backdrop Hue Rotate
       * @see https://tailwindcss.com/docs/backdrop-hue-rotate
       */
      "backdrop-hue-rotate": [{
        "backdrop-hue-rotate": [hueRotate]
      }],
      /**
       * Backdrop Invert
       * @see https://tailwindcss.com/docs/backdrop-invert
       */
      "backdrop-invert": [{
        "backdrop-invert": [invert]
      }],
      /**
       * Backdrop Opacity
       * @see https://tailwindcss.com/docs/backdrop-opacity
       */
      "backdrop-opacity": [{
        "backdrop-opacity": [opacity]
      }],
      /**
       * Backdrop Saturate
       * @see https://tailwindcss.com/docs/backdrop-saturate
       */
      "backdrop-saturate": [{
        "backdrop-saturate": [saturate]
      }],
      /**
       * Backdrop Sepia
       * @see https://tailwindcss.com/docs/backdrop-sepia
       */
      "backdrop-sepia": [{
        "backdrop-sepia": [sepia]
      }],
      // Tables
      /**
       * Border Collapse
       * @see https://tailwindcss.com/docs/border-collapse
       */
      "border-collapse": [{
        border: ["collapse", "separate"]
      }],
      /**
       * Border Spacing
       * @see https://tailwindcss.com/docs/border-spacing
       */
      "border-spacing": [{
        "border-spacing": [borderSpacing]
      }],
      /**
       * Border Spacing X
       * @see https://tailwindcss.com/docs/border-spacing
       */
      "border-spacing-x": [{
        "border-spacing-x": [borderSpacing]
      }],
      /**
       * Border Spacing Y
       * @see https://tailwindcss.com/docs/border-spacing
       */
      "border-spacing-y": [{
        "border-spacing-y": [borderSpacing]
      }],
      /**
       * Table Layout
       * @see https://tailwindcss.com/docs/table-layout
       */
      "table-layout": [{
        table: ["auto", "fixed"]
      }],
      /**
       * Caption Side
       * @see https://tailwindcss.com/docs/caption-side
       */
      caption: [{
        caption: ["top", "bottom"]
      }],
      // Transitions and Animation
      /**
       * Tranisition Property
       * @see https://tailwindcss.com/docs/transition-property
       */
      transition: [{
        transition: ["none", "all", "", "colors", "opacity", "shadow", "transform", isArbitraryValue]
      }],
      /**
       * Transition Duration
       * @see https://tailwindcss.com/docs/transition-duration
       */
      duration: [{
        duration: getNumberAndArbitrary()
      }],
      /**
       * Transition Timing Function
       * @see https://tailwindcss.com/docs/transition-timing-function
       */
      ease: [{
        ease: ["linear", "in", "out", "in-out", isArbitraryValue]
      }],
      /**
       * Transition Delay
       * @see https://tailwindcss.com/docs/transition-delay
       */
      delay: [{
        delay: getNumberAndArbitrary()
      }],
      /**
       * Animation
       * @see https://tailwindcss.com/docs/animation
       */
      animate: [{
        animate: ["none", "spin", "ping", "pulse", "bounce", isArbitraryValue]
      }],
      // Transforms
      /**
       * Transform
       * @see https://tailwindcss.com/docs/transform
       */
      transform: [{
        transform: ["", "gpu", "none"]
      }],
      /**
       * Scale
       * @see https://tailwindcss.com/docs/scale
       */
      scale: [{
        scale: [scale2]
      }],
      /**
       * Scale X
       * @see https://tailwindcss.com/docs/scale
       */
      "scale-x": [{
        "scale-x": [scale2]
      }],
      /**
       * Scale Y
       * @see https://tailwindcss.com/docs/scale
       */
      "scale-y": [{
        "scale-y": [scale2]
      }],
      /**
       * Rotate
       * @see https://tailwindcss.com/docs/rotate
       */
      rotate: [{
        rotate: [isInteger, isArbitraryValue]
      }],
      /**
       * Translate X
       * @see https://tailwindcss.com/docs/translate
       */
      "translate-x": [{
        "translate-x": [translate]
      }],
      /**
       * Translate Y
       * @see https://tailwindcss.com/docs/translate
       */
      "translate-y": [{
        "translate-y": [translate]
      }],
      /**
       * Skew X
       * @see https://tailwindcss.com/docs/skew
       */
      "skew-x": [{
        "skew-x": [skew]
      }],
      /**
       * Skew Y
       * @see https://tailwindcss.com/docs/skew
       */
      "skew-y": [{
        "skew-y": [skew]
      }],
      /**
       * Transform Origin
       * @see https://tailwindcss.com/docs/transform-origin
       */
      "transform-origin": [{
        origin: ["center", "top", "top-right", "right", "bottom-right", "bottom", "bottom-left", "left", "top-left", isArbitraryValue]
      }],
      // Interactivity
      /**
       * Accent Color
       * @see https://tailwindcss.com/docs/accent-color
       */
      accent: [{
        accent: ["auto", colors]
      }],
      /**
       * Appearance
       * @see https://tailwindcss.com/docs/appearance
       */
      appearance: [{
        appearance: ["none", "auto"]
      }],
      /**
       * Cursor
       * @see https://tailwindcss.com/docs/cursor
       */
      cursor: [{
        cursor: ["auto", "default", "pointer", "wait", "text", "move", "help", "not-allowed", "none", "context-menu", "progress", "cell", "crosshair", "vertical-text", "alias", "copy", "no-drop", "grab", "grabbing", "all-scroll", "col-resize", "row-resize", "n-resize", "e-resize", "s-resize", "w-resize", "ne-resize", "nw-resize", "se-resize", "sw-resize", "ew-resize", "ns-resize", "nesw-resize", "nwse-resize", "zoom-in", "zoom-out", isArbitraryValue]
      }],
      /**
       * Caret Color
       * @see https://tailwindcss.com/docs/just-in-time-mode#caret-color-utilities
       */
      "caret-color": [{
        caret: [colors]
      }],
      /**
       * Pointer Events
       * @see https://tailwindcss.com/docs/pointer-events
       */
      "pointer-events": [{
        "pointer-events": ["none", "auto"]
      }],
      /**
       * Resize
       * @see https://tailwindcss.com/docs/resize
       */
      resize: [{
        resize: ["none", "y", "x", ""]
      }],
      /**
       * Scroll Behavior
       * @see https://tailwindcss.com/docs/scroll-behavior
       */
      "scroll-behavior": [{
        scroll: ["auto", "smooth"]
      }],
      /**
       * Scroll Margin
       * @see https://tailwindcss.com/docs/scroll-margin
       */
      "scroll-m": [{
        "scroll-m": getSpacingWithArbitrary()
      }],
      /**
       * Scroll Margin X
       * @see https://tailwindcss.com/docs/scroll-margin
       */
      "scroll-mx": [{
        "scroll-mx": getSpacingWithArbitrary()
      }],
      /**
       * Scroll Margin Y
       * @see https://tailwindcss.com/docs/scroll-margin
       */
      "scroll-my": [{
        "scroll-my": getSpacingWithArbitrary()
      }],
      /**
       * Scroll Margin Start
       * @see https://tailwindcss.com/docs/scroll-margin
       */
      "scroll-ms": [{
        "scroll-ms": getSpacingWithArbitrary()
      }],
      /**
       * Scroll Margin End
       * @see https://tailwindcss.com/docs/scroll-margin
       */
      "scroll-me": [{
        "scroll-me": getSpacingWithArbitrary()
      }],
      /**
       * Scroll Margin Top
       * @see https://tailwindcss.com/docs/scroll-margin
       */
      "scroll-mt": [{
        "scroll-mt": getSpacingWithArbitrary()
      }],
      /**
       * Scroll Margin Right
       * @see https://tailwindcss.com/docs/scroll-margin
       */
      "scroll-mr": [{
        "scroll-mr": getSpacingWithArbitrary()
      }],
      /**
       * Scroll Margin Bottom
       * @see https://tailwindcss.com/docs/scroll-margin
       */
      "scroll-mb": [{
        "scroll-mb": getSpacingWithArbitrary()
      }],
      /**
       * Scroll Margin Left
       * @see https://tailwindcss.com/docs/scroll-margin
       */
      "scroll-ml": [{
        "scroll-ml": getSpacingWithArbitrary()
      }],
      /**
       * Scroll Padding
       * @see https://tailwindcss.com/docs/scroll-padding
       */
      "scroll-p": [{
        "scroll-p": getSpacingWithArbitrary()
      }],
      /**
       * Scroll Padding X
       * @see https://tailwindcss.com/docs/scroll-padding
       */
      "scroll-px": [{
        "scroll-px": getSpacingWithArbitrary()
      }],
      /**
       * Scroll Padding Y
       * @see https://tailwindcss.com/docs/scroll-padding
       */
      "scroll-py": [{
        "scroll-py": getSpacingWithArbitrary()
      }],
      /**
       * Scroll Padding Start
       * @see https://tailwindcss.com/docs/scroll-padding
       */
      "scroll-ps": [{
        "scroll-ps": getSpacingWithArbitrary()
      }],
      /**
       * Scroll Padding End
       * @see https://tailwindcss.com/docs/scroll-padding
       */
      "scroll-pe": [{
        "scroll-pe": getSpacingWithArbitrary()
      }],
      /**
       * Scroll Padding Top
       * @see https://tailwindcss.com/docs/scroll-padding
       */
      "scroll-pt": [{
        "scroll-pt": getSpacingWithArbitrary()
      }],
      /**
       * Scroll Padding Right
       * @see https://tailwindcss.com/docs/scroll-padding
       */
      "scroll-pr": [{
        "scroll-pr": getSpacingWithArbitrary()
      }],
      /**
       * Scroll Padding Bottom
       * @see https://tailwindcss.com/docs/scroll-padding
       */
      "scroll-pb": [{
        "scroll-pb": getSpacingWithArbitrary()
      }],
      /**
       * Scroll Padding Left
       * @see https://tailwindcss.com/docs/scroll-padding
       */
      "scroll-pl": [{
        "scroll-pl": getSpacingWithArbitrary()
      }],
      /**
       * Scroll Snap Align
       * @see https://tailwindcss.com/docs/scroll-snap-align
       */
      "snap-align": [{
        snap: ["start", "end", "center", "align-none"]
      }],
      /**
       * Scroll Snap Stop
       * @see https://tailwindcss.com/docs/scroll-snap-stop
       */
      "snap-stop": [{
        snap: ["normal", "always"]
      }],
      /**
       * Scroll Snap Type
       * @see https://tailwindcss.com/docs/scroll-snap-type
       */
      "snap-type": [{
        snap: ["none", "x", "y", "both"]
      }],
      /**
       * Scroll Snap Type Strictness
       * @see https://tailwindcss.com/docs/scroll-snap-type
       */
      "snap-strictness": [{
        snap: ["mandatory", "proximity"]
      }],
      /**
       * Touch Action
       * @see https://tailwindcss.com/docs/touch-action
       */
      touch: [{
        touch: ["auto", "none", "manipulation"]
      }],
      /**
       * Touch Action X
       * @see https://tailwindcss.com/docs/touch-action
       */
      "touch-x": [{
        "touch-pan": ["x", "left", "right"]
      }],
      /**
       * Touch Action Y
       * @see https://tailwindcss.com/docs/touch-action
       */
      "touch-y": [{
        "touch-pan": ["y", "up", "down"]
      }],
      /**
       * Touch Action Pinch Zoom
       * @see https://tailwindcss.com/docs/touch-action
       */
      "touch-pz": ["touch-pinch-zoom"],
      /**
       * User Select
       * @see https://tailwindcss.com/docs/user-select
       */
      select: [{
        select: ["none", "text", "all", "auto"]
      }],
      /**
       * Will Change
       * @see https://tailwindcss.com/docs/will-change
       */
      "will-change": [{
        "will-change": ["auto", "scroll", "contents", "transform", isArbitraryValue]
      }],
      // SVG
      /**
       * Fill
       * @see https://tailwindcss.com/docs/fill
       */
      fill: [{
        fill: [colors, "none"]
      }],
      /**
       * Stroke Width
       * @see https://tailwindcss.com/docs/stroke-width
       */
      "stroke-w": [{
        stroke: [isLength, isArbitraryLength, isArbitraryNumber]
      }],
      /**
       * Stroke
       * @see https://tailwindcss.com/docs/stroke
       */
      stroke: [{
        stroke: [colors, "none"]
      }],
      // Accessibility
      /**
       * Screen Readers
       * @see https://tailwindcss.com/docs/screen-readers
       */
      sr: ["sr-only", "not-sr-only"],
      /**
       * Forced Color Adjust
       * @see https://tailwindcss.com/docs/forced-color-adjust
       */
      "forced-color-adjust": [{
        "forced-color-adjust": ["auto", "none"]
      }]
    },
    conflictingClassGroups: {
      overflow: ["overflow-x", "overflow-y"],
      overscroll: ["overscroll-x", "overscroll-y"],
      inset: ["inset-x", "inset-y", "start", "end", "top", "right", "bottom", "left"],
      "inset-x": ["right", "left"],
      "inset-y": ["top", "bottom"],
      flex: ["basis", "grow", "shrink"],
      gap: ["gap-x", "gap-y"],
      p: ["px", "py", "ps", "pe", "pt", "pr", "pb", "pl"],
      px: ["pr", "pl"],
      py: ["pt", "pb"],
      m: ["mx", "my", "ms", "me", "mt", "mr", "mb", "ml"],
      mx: ["mr", "ml"],
      my: ["mt", "mb"],
      size: ["w", "h"],
      "font-size": ["leading"],
      "fvn-normal": ["fvn-ordinal", "fvn-slashed-zero", "fvn-figure", "fvn-spacing", "fvn-fraction"],
      "fvn-ordinal": ["fvn-normal"],
      "fvn-slashed-zero": ["fvn-normal"],
      "fvn-figure": ["fvn-normal"],
      "fvn-spacing": ["fvn-normal"],
      "fvn-fraction": ["fvn-normal"],
      "line-clamp": ["display", "overflow"],
      rounded: ["rounded-s", "rounded-e", "rounded-t", "rounded-r", "rounded-b", "rounded-l", "rounded-ss", "rounded-se", "rounded-ee", "rounded-es", "rounded-tl", "rounded-tr", "rounded-br", "rounded-bl"],
      "rounded-s": ["rounded-ss", "rounded-es"],
      "rounded-e": ["rounded-se", "rounded-ee"],
      "rounded-t": ["rounded-tl", "rounded-tr"],
      "rounded-r": ["rounded-tr", "rounded-br"],
      "rounded-b": ["rounded-br", "rounded-bl"],
      "rounded-l": ["rounded-tl", "rounded-bl"],
      "border-spacing": ["border-spacing-x", "border-spacing-y"],
      "border-w": ["border-w-s", "border-w-e", "border-w-t", "border-w-r", "border-w-b", "border-w-l"],
      "border-w-x": ["border-w-r", "border-w-l"],
      "border-w-y": ["border-w-t", "border-w-b"],
      "border-color": ["border-color-s", "border-color-e", "border-color-t", "border-color-r", "border-color-b", "border-color-l"],
      "border-color-x": ["border-color-r", "border-color-l"],
      "border-color-y": ["border-color-t", "border-color-b"],
      "scroll-m": ["scroll-mx", "scroll-my", "scroll-ms", "scroll-me", "scroll-mt", "scroll-mr", "scroll-mb", "scroll-ml"],
      "scroll-mx": ["scroll-mr", "scroll-ml"],
      "scroll-my": ["scroll-mt", "scroll-mb"],
      "scroll-p": ["scroll-px", "scroll-py", "scroll-ps", "scroll-pe", "scroll-pt", "scroll-pr", "scroll-pb", "scroll-pl"],
      "scroll-px": ["scroll-pr", "scroll-pl"],
      "scroll-py": ["scroll-pt", "scroll-pb"],
      touch: ["touch-x", "touch-y", "touch-pz"],
      "touch-x": ["touch"],
      "touch-y": ["touch"],
      "touch-pz": ["touch"]
    },
    conflictingClassGroupModifiers: {
      "font-size": ["leading"]
    }
  };
};
const mergeConfigs = (baseConfig, {
  cacheSize,
  prefix: prefix2,
  separator,
  experimentalParseClassName,
  extend = {},
  override = {}
}) => {
  overrideProperty(baseConfig, "cacheSize", cacheSize);
  overrideProperty(baseConfig, "prefix", prefix2);
  overrideProperty(baseConfig, "separator", separator);
  overrideProperty(baseConfig, "experimentalParseClassName", experimentalParseClassName);
  for (const configKey in override) {
    overrideConfigProperties(baseConfig[configKey], override[configKey]);
  }
  for (const key2 in extend) {
    mergeConfigProperties(baseConfig[key2], extend[key2]);
  }
  return baseConfig;
};
const overrideProperty = (baseObject, overrideKey, overrideValue) => {
  if (overrideValue !== void 0) {
    baseObject[overrideKey] = overrideValue;
  }
};
const overrideConfigProperties = (baseObject, overrideObject) => {
  if (overrideObject) {
    for (const key2 in overrideObject) {
      overrideProperty(baseObject, key2, overrideObject[key2]);
    }
  }
};
const mergeConfigProperties = (baseObject, mergeObject) => {
  if (mergeObject) {
    for (const key2 in mergeObject) {
      const mergeValue = mergeObject[key2];
      if (mergeValue !== void 0) {
        baseObject[key2] = (baseObject[key2] || []).concat(mergeValue);
      }
    }
  }
};
const extendTailwindMerge = (configExtension, ...createConfig) => typeof configExtension === "function" ? createTailwindMerge(getDefaultConfig, configExtension, ...createConfig) : createTailwindMerge(() => mergeConfigs(getDefaultConfig(), configExtension), ...createConfig);
const twMerge = /* @__PURE__ */ createTailwindMerge(getDefaultConfig);
var ie = { twMerge: true, twMergeConfig: {}, responsiveVariants: false }, x$1 = (s) => s || void 0, N = (...s) => x$1(y$1(s).filter(Boolean).join(" ")), R = null, v$2 = {}, q$1 = false, M = (...s) => (b$1) => b$1.twMerge ? ((!R || q$1) && (q$1 = false, R = u$1(v$2) ? twMerge : extendTailwindMerge({ ...v$2, extend: { theme: v$2.theme, classGroups: v$2.classGroups, conflictingClassGroupModifiers: v$2.conflictingClassGroupModifiers, conflictingClassGroups: v$2.conflictingClassGroups, ...v$2.extend } })), x$1(R(N(s)))) : N(s), _ = (s, b2) => {
  for (let e2 in b2) s.hasOwnProperty(e2) ? s[e2] = N(s[e2], b2[e2]) : s[e2] = b2[e2];
  return s;
}, ce = (s, b$1) => {
  let { extend: e2 = null, slots: O = {}, variants: U2 = {}, compoundVariants: W = [], compoundSlots: C = [], defaultVariants: z2 = {} } = s, m2 = { ...ie, ...b$1 }, k2 = e2 != null && e2.base ? N(e2.base, s == null ? void 0 : s.base) : s == null ? void 0 : s.base, g$1$1 = e2 != null && e2.variants && !u$1(e2.variants) ? p$1(U2, e2.variants) : U2, w2 = e2 != null && e2.defaultVariants && !u$1(e2.defaultVariants) ? { ...e2.defaultVariants, ...z2 } : z2;
  !u$1(m2.twMergeConfig) && !x$2(m2.twMergeConfig, v$2) && (q$1 = true, v$2 = m2.twMergeConfig);
  let S = u$1(e2 == null ? void 0 : e2.slots), T = u$1(O) ? {} : { base: N(s == null ? void 0 : s.base, S && (e2 == null ? void 0 : e2.base)), ...O }, j2 = S ? T : _({ ...e2 == null ? void 0 : e2.slots }, u$1(T) ? { base: s == null ? void 0 : s.base } : T), h$1 = u$1(e2 == null ? void 0 : e2.compoundVariants) ? W : a(e2 == null ? void 0 : e2.compoundVariants, W), V = (l2) => {
    if (u$1(g$1$1) && u$1(O) && S) return M(k2, l2 == null ? void 0 : l2.class, l2 == null ? void 0 : l2.className)(m2);
    if (h$1 && !Array.isArray(h$1)) throw new TypeError(`The "compoundVariants" prop must be an array. Received: ${typeof h$1}`);
    if (C && !Array.isArray(C)) throw new TypeError(`The "compoundSlots" prop must be an array. Received: ${typeof C}`);
    let P2 = (a2, n2, t2 = [], i2) => {
      let r2 = t2;
      if (typeof n2 == "string") r2 = r2.concat(g$1(n2).split(" ").map((o) => `${a2}:${o}`));
      else if (Array.isArray(n2)) r2 = r2.concat(n2.reduce((o, c2) => o.concat(`${a2}:${c2}`), []));
      else if (typeof n2 == "object" && typeof i2 == "string") {
        for (let o in n2) if (n2.hasOwnProperty(o) && o === i2) {
          let c2 = n2[o];
          if (c2 && typeof c2 == "string") {
            let u2 = g$1(c2);
            r2[i2] ? r2[i2] = r2[i2].concat(u2.split(" ").map((f2) => `${a2}:${f2}`)) : r2[i2] = u2.split(" ").map((f2) => `${a2}:${f2}`);
          } else Array.isArray(c2) && c2.length > 0 && (r2[i2] = c2.reduce((u2, f2) => u2.concat(`${a2}:${f2}`), []));
        }
      }
      return r2;
    }, D2 = (a$1, n2 = g$1$1, t2 = null, i2 = null) => {
      var L2;
      let r2 = n2[a$1];
      if (!r2 || u$1(r2)) return null;
      let o = (L2 = i2 == null ? void 0 : i2[a$1]) != null ? L2 : l2 == null ? void 0 : l2[a$1];
      if (o === null) return null;
      let c2 = l$1(o), u2 = Array.isArray(m2.responsiveVariants) && m2.responsiveVariants.length > 0 || m2.responsiveVariants === true, f2 = w2 == null ? void 0 : w2[a$1], d2 = [];
      if (typeof c2 == "object" && u2) for (let [E2, Q] of Object.entries(c2)) {
        let ne2 = r2[Q];
        if (E2 === "initial") {
          f2 = Q;
          continue;
        }
        Array.isArray(m2.responsiveVariants) && !m2.responsiveVariants.includes(E2) || (d2 = P2(E2, ne2, d2, t2));
      }
      let $ = c2 != null && typeof c2 != "object" ? c2 : l$1(f2), A2 = r2[$ || "false"];
      return typeof d2 == "object" && typeof t2 == "string" && d2[t2] ? _(d2, A2) : d2.length > 0 ? (d2.push(A2), t2 === "base" ? d2.join(" ") : d2) : A2;
    }, p2 = () => g$1$1 ? Object.keys(g$1$1).map((a2) => D2(a2, g$1$1)) : null, ee2 = (a2, n2) => {
      if (!g$1$1 || typeof g$1$1 != "object") return null;
      let t2 = new Array();
      for (let i2 in g$1$1) {
        let r2 = D2(i2, g$1$1, a2, n2), o = a2 === "base" && typeof r2 == "string" ? r2 : r2 && r2[a2];
        o && (t2[t2.length] = o);
      }
      return t2;
    }, H = {};
    for (let a2 in l2) l2[a2] !== void 0 && (H[a2] = l2[a2]);
    let I = (a2, n2) => {
      var i2;
      let t2 = typeof (l2 == null ? void 0 : l2[a2]) == "object" ? { [a2]: (i2 = l2[a2]) == null ? void 0 : i2.initial } : {};
      return { ...w2, ...H, ...t2, ...n2 };
    }, J = (a2 = [], n2) => {
      let t2 = [];
      for (let { class: i2, className: r2, ...o } of a2) {
        let c2 = true;
        for (let [u2, f2] of Object.entries(o)) {
          let d2 = I(u2, n2)[u2];
          if (Array.isArray(f2)) {
            if (!f2.includes(d2)) {
              c2 = false;
              break;
            }
          } else {
            let $ = (A2) => A2 == null || A2 === false;
            if ($(f2) && $(d2)) continue;
            if (d2 !== f2) {
              c2 = false;
              break;
            }
          }
        }
        c2 && (i2 && t2.push(i2), r2 && t2.push(r2));
      }
      return t2;
    }, te2 = (a2) => {
      let n2 = J(h$1, a2);
      if (!Array.isArray(n2)) return n2;
      let t2 = {};
      for (let i2 of n2) if (typeof i2 == "string" && (t2.base = M(t2.base, i2)(m2)), typeof i2 == "object") for (let [r2, o] of Object.entries(i2)) t2[r2] = M(t2[r2], o)(m2);
      return t2;
    }, ae2 = (a2) => {
      if (C.length < 1) return null;
      let n2 = {};
      for (let { slots: t2 = [], class: i2, className: r2, ...o } of C) {
        if (!u$1(o)) {
          let c2 = true;
          for (let u2 of Object.keys(o)) {
            let f2 = I(u2, a2)[u2];
            if (f2 === void 0 || (Array.isArray(o[u2]) ? !o[u2].includes(f2) : o[u2] !== f2)) {
              c2 = false;
              break;
            }
          }
          if (!c2) continue;
        }
        for (let c2 of t2) n2[c2] = n2[c2] || [], n2[c2].push([i2, r2]);
      }
      return n2;
    };
    if (!u$1(O) || !S) {
      let a2 = {};
      if (typeof j2 == "object" && !u$1(j2)) for (let n2 of Object.keys(j2)) a2[n2] = (t2) => {
        var i2, r2;
        return M(j2[n2], ee2(n2, t2), ((i2 = te2(t2)) != null ? i2 : [])[n2], ((r2 = ae2(t2)) != null ? r2 : [])[n2], t2 == null ? void 0 : t2.class, t2 == null ? void 0 : t2.className)(m2);
      };
      return a2;
    }
    return M(k2, p2(), J(h$1), l2 == null ? void 0 : l2.class, l2 == null ? void 0 : l2.className)(m2);
  }, K2 = () => {
    if (!(!g$1$1 || typeof g$1$1 != "object")) return Object.keys(g$1$1);
  };
  return V.variantKeys = K2(), V.extend = e2, V.base = k2, V.slots = j2, V.variants = g$1$1, V.defaultVariants = w2, V.compoundSlots = C, V.compoundVariants = h$1, V;
};
var tv = (options, config2) => {
  var _a2, _b2, _c2;
  return ce(options, {
    ...config2,
    twMerge: (_a2 = config2 == null ? void 0 : config2.twMerge) != null ? _a2 : true,
    twMergeConfig: {
      ...config2 == null ? void 0 : config2.twMergeConfig,
      theme: {
        ...(_b2 = config2 == null ? void 0 : config2.twMergeConfig) == null ? void 0 : _b2.theme,
        ...twMergeConfig.theme
      },
      classGroups: {
        ...(_c2 = config2 == null ? void 0 : config2.twMergeConfig) == null ? void 0 : _c2.classGroups,
        ...twMergeConfig.classGroups
      }
    }
  });
};
var spinner = tv({
  slots: {
    base: "relative inline-flex flex-col gap-2 items-center justify-center",
    wrapper: "relative flex",
    label: "text-foreground dark:text-foreground-dark font-regular",
    circle1: "absolute w-full h-full rounded-full",
    circle2: "absolute w-full h-full rounded-full",
    dots: "relative rounded-full mx-auto",
    spinnerBars: [
      "absolute",
      "animate-fade-out",
      "rounded-full",
      "w-[25%]",
      "h-[8%]",
      "left-[calc(37.5%)]",
      "top-[calc(46%)]",
      "spinner-bar-animation"
    ]
  },
  variants: {
    size: {
      sm: {
        wrapper: "w-5 h-5",
        circle1: "border-2",
        circle2: "border-2",
        dots: "size-1",
        label: "text-small"
      },
      md: {
        wrapper: "w-8 h-8",
        circle1: "border-3",
        circle2: "border-3",
        dots: "size-1.5",
        label: "text-medium"
      },
      lg: {
        wrapper: "w-10 h-10",
        circle1: "border-3",
        circle2: "border-3",
        dots: "size-2",
        label: "text-large"
      }
    },
    color: {
      current: {
        circle1: "border-b-current",
        circle2: "border-b-current",
        dots: "bg-current",
        spinnerBars: "bg-current"
      },
      white: {
        circle1: "border-b-white",
        circle2: "border-b-white",
        dots: "bg-white",
        spinnerBars: "bg-white"
      },
      default: {
        circle1: "border-b-default",
        circle2: "border-b-default",
        dots: "bg-default",
        spinnerBars: "bg-default"
      },
      primary: {
        circle1: "border-b-primary",
        circle2: "border-b-primary",
        dots: "bg-primary",
        spinnerBars: "bg-primary"
      },
      secondary: {
        circle1: "border-b-secondary",
        circle2: "border-b-secondary",
        dots: "bg-secondary",
        spinnerBars: "bg-secondary"
      },
      success: {
        circle1: "border-b-success",
        circle2: "border-b-success",
        dots: "bg-success",
        spinnerBars: "bg-success"
      },
      warning: {
        circle1: "border-b-warning",
        circle2: "border-b-warning",
        dots: "bg-warning",
        spinnerBars: "bg-warning"
      },
      danger: {
        circle1: "border-b-danger",
        circle2: "border-b-danger",
        dots: "bg-danger",
        spinnerBars: "bg-danger"
      }
    },
    labelColor: {
      foreground: {
        label: "text-foreground"
      },
      primary: {
        label: "text-primary"
      },
      secondary: {
        label: "text-secondary"
      },
      success: {
        label: "text-success"
      },
      warning: {
        label: "text-warning"
      },
      danger: {
        label: "text-danger"
      }
    },
    variant: {
      default: {
        circle1: [
          "animate-spinner-ease-spin",
          "border-solid",
          "border-t-transparent",
          "border-l-transparent",
          "border-r-transparent"
        ],
        circle2: [
          "opacity-75",
          "animate-spinner-linear-spin",
          "border-dotted",
          "border-t-transparent",
          "border-l-transparent",
          "border-r-transparent"
        ]
      },
      gradient: {
        circle1: [
          "border-0",
          "bg-gradient-to-b",
          "from-transparent",
          "via-transparent",
          "to-primary",
          "animate-spinner-linear-spin",
          "[animation-duration:1s]",
          "[-webkit-mask:radial-gradient(closest-side,rgba(0,0,0,0.0)calc(100%-3px),rgba(0,0,0,1)calc(100%-3px))]"
        ],
        circle2: ["hidden"]
      },
      wave: {
        wrapper: "translate-y-3/4",
        dots: ["animate-sway", "spinner-dot-animation"]
      },
      dots: {
        wrapper: "translate-y-2/4",
        dots: ["animate-blink", "spinner-dot-blink-animation"]
      },
      spinner: {},
      simple: {
        wrapper: "text-foreground h-5 w-5 animate-spin",
        circle1: "opacity-25",
        circle2: "opacity-75"
      }
    }
  },
  defaultVariants: {
    size: "md",
    color: "primary",
    labelColor: "foreground",
    variant: "default"
  },
  compoundVariants: [
    { variant: "gradient", color: "current", class: { circle1: "to-current" } },
    { variant: "gradient", color: "white", class: { circle1: "to-white" } },
    { variant: "gradient", color: "default", class: { circle1: "to-default" } },
    { variant: "gradient", color: "primary", class: { circle1: "to-primary" } },
    { variant: "gradient", color: "secondary", class: { circle1: "to-secondary" } },
    { variant: "gradient", color: "success", class: { circle1: "to-success" } },
    { variant: "gradient", color: "warning", class: { circle1: "to-warning" } },
    { variant: "gradient", color: "danger", class: { circle1: "to-danger" } },
    {
      variant: "wave",
      size: "sm",
      class: {
        wrapper: "w-5 h-5"
      }
    },
    {
      variant: "wave",
      size: "md",
      class: {
        wrapper: "w-8 h-8"
      }
    },
    {
      variant: "wave",
      size: "lg",
      class: {
        wrapper: "w-12 h-12"
      }
    },
    {
      variant: "dots",
      size: "sm",
      class: {
        wrapper: "w-5 h-5"
      }
    },
    {
      variant: "dots",
      size: "md",
      class: {
        wrapper: "w-8 h-8"
      }
    },
    {
      variant: "dots",
      size: "lg",
      class: {
        wrapper: "w-12 h-12"
      }
    },
    // Simple variants
    // Size
    {
      variant: "simple",
      size: "sm",
      class: {
        wrapper: "w-5 h-5"
      }
    },
    {
      variant: "simple",
      size: "md",
      class: {
        wrapper: "w-8 h-8"
      }
    },
    {
      variant: "simple",
      size: "lg",
      class: {
        wrapper: "w-12 h-12"
      }
    },
    // Color
    {
      variant: "simple",
      color: "current",
      class: {
        wrapper: "text-current"
      }
    },
    {
      variant: "simple",
      color: "white",
      class: {
        wrapper: "text-white"
      }
    },
    {
      variant: "simple",
      color: "default",
      class: {
        wrapper: "text-default"
      }
    },
    {
      variant: "simple",
      color: "primary",
      class: {
        wrapper: "text-primary"
      }
    },
    {
      variant: "simple",
      color: "secondary",
      class: {
        wrapper: "text-secondary"
      }
    },
    {
      variant: "simple",
      color: "success",
      class: {
        wrapper: "text-success"
      }
    },
    {
      variant: "simple",
      color: "warning",
      class: {
        wrapper: "text-warning"
      }
    },
    {
      variant: "simple",
      color: "danger",
      class: {
        wrapper: "text-danger"
      }
    }
  ]
});
var dataFocusVisibleClasses = [
  "outline-none",
  "data-[focus-visible=true]:z-10",
  "data-[focus-visible=true]:outline-2",
  "data-[focus-visible=true]:outline-focus",
  "data-[focus-visible=true]:outline-offset-2"
];
var collapseAdjacentVariantBorders = {
  default: ["[&+.border-medium.border-default]:ms-[calc(theme(borderWidth.medium)*-1)]"],
  primary: ["[&+.border-medium.border-primary]:ms-[calc(theme(borderWidth.medium)*-1)]"],
  secondary: ["[&+.border-medium.border-secondary]:ms-[calc(theme(borderWidth.medium)*-1)]"],
  success: ["[&+.border-medium.border-success]:ms-[calc(theme(borderWidth.medium)*-1)]"],
  warning: ["[&+.border-medium.border-warning]:ms-[calc(theme(borderWidth.medium)*-1)]"],
  danger: ["[&+.border-medium.border-danger]:ms-[calc(theme(borderWidth.medium)*-1)]"]
};
var button = tv({
  base: [
    "z-0",
    "group",
    "relative",
    "inline-flex",
    "items-center",
    "justify-center",
    "box-border",
    "appearance-none",
    "outline-none",
    "select-none",
    "whitespace-nowrap",
    "min-w-max",
    "font-normal",
    "subpixel-antialiased",
    "overflow-hidden",
    "tap-highlight-transparent",
    "transform-gpu data-[pressed=true]:scale-[0.97]",
    // focus ring
    ...dataFocusVisibleClasses
  ],
  variants: {
    variant: {
      solid: "",
      bordered: "border-medium bg-transparent",
      light: "bg-transparent",
      flat: "",
      faded: "border-medium",
      shadow: "",
      ghost: "border-medium bg-transparent"
    },
    size: {
      sm: "px-3 min-w-16 h-8 text-tiny gap-2 rounded-small",
      md: "px-4 min-w-20 h-10 text-small gap-2 rounded-medium",
      lg: "px-6 min-w-24 h-12 text-medium gap-3 rounded-large"
    },
    color: {
      default: "",
      primary: "",
      secondary: "",
      success: "",
      warning: "",
      danger: ""
    },
    radius: {
      none: "rounded-none",
      sm: "rounded-small",
      md: "rounded-medium",
      lg: "rounded-large",
      full: "rounded-full"
    },
    fullWidth: {
      true: "w-full"
    },
    isDisabled: {
      true: "opacity-disabled pointer-events-none"
    },
    isInGroup: {
      true: "[&:not(:first-child):not(:last-child)]:rounded-none"
    },
    isIconOnly: {
      true: "px-0 !gap-0",
      false: "[&>svg]:max-w-[theme(spacing.8)]"
    },
    disableAnimation: {
      true: "!transition-none data-[pressed=true]:scale-100",
      false: "transition-transform-colors-opacity motion-reduce:transition-none"
    }
  },
  defaultVariants: {
    size: "md",
    variant: "solid",
    color: "default",
    fullWidth: false,
    isDisabled: false,
    isInGroup: false
  },
  compoundVariants: [
    // solid / color
    {
      variant: "solid",
      color: "default",
      class: colorVariants.solid.default
    },
    {
      variant: "solid",
      color: "primary",
      class: colorVariants.solid.primary
    },
    {
      variant: "solid",
      color: "secondary",
      class: colorVariants.solid.secondary
    },
    {
      variant: "solid",
      color: "success",
      class: colorVariants.solid.success
    },
    {
      variant: "solid",
      color: "warning",
      class: colorVariants.solid.warning
    },
    {
      variant: "solid",
      color: "danger",
      class: colorVariants.solid.danger
    },
    // shadow / color
    {
      variant: "shadow",
      color: "default",
      class: colorVariants.shadow.default
    },
    {
      variant: "shadow",
      color: "primary",
      class: colorVariants.shadow.primary
    },
    {
      variant: "shadow",
      color: "secondary",
      class: colorVariants.shadow.secondary
    },
    {
      variant: "shadow",
      color: "success",
      class: colorVariants.shadow.success
    },
    {
      variant: "shadow",
      color: "warning",
      class: colorVariants.shadow.warning
    },
    {
      variant: "shadow",
      color: "danger",
      class: colorVariants.shadow.danger
    },
    // bordered / color
    {
      variant: "bordered",
      color: "default",
      class: colorVariants.bordered.default
    },
    {
      variant: "bordered",
      color: "primary",
      class: colorVariants.bordered.primary
    },
    {
      variant: "bordered",
      color: "secondary",
      class: colorVariants.bordered.secondary
    },
    {
      variant: "bordered",
      color: "success",
      class: colorVariants.bordered.success
    },
    {
      variant: "bordered",
      color: "warning",
      class: colorVariants.bordered.warning
    },
    {
      variant: "bordered",
      color: "danger",
      class: colorVariants.bordered.danger
    },
    // flat / color
    {
      variant: "flat",
      color: "default",
      class: colorVariants.flat.default
    },
    {
      variant: "flat",
      color: "primary",
      class: colorVariants.flat.primary
    },
    {
      variant: "flat",
      color: "secondary",
      class: colorVariants.flat.secondary
    },
    {
      variant: "flat",
      color: "success",
      class: colorVariants.flat.success
    },
    {
      variant: "flat",
      color: "warning",
      class: colorVariants.flat.warning
    },
    {
      variant: "flat",
      color: "danger",
      class: colorVariants.flat.danger
    },
    // faded / color
    {
      variant: "faded",
      color: "default",
      class: colorVariants.faded.default
    },
    {
      variant: "faded",
      color: "primary",
      class: colorVariants.faded.primary
    },
    {
      variant: "faded",
      color: "secondary",
      class: colorVariants.faded.secondary
    },
    {
      variant: "faded",
      color: "success",
      class: colorVariants.faded.success
    },
    {
      variant: "faded",
      color: "warning",
      class: colorVariants.faded.warning
    },
    {
      variant: "faded",
      color: "danger",
      class: colorVariants.faded.danger
    },
    // light / color
    {
      variant: "light",
      color: "default",
      class: [colorVariants.light.default, "data-[hover=true]:bg-default/40"]
    },
    {
      variant: "light",
      color: "primary",
      class: [colorVariants.light.primary, "data-[hover=true]:bg-primary/20"]
    },
    {
      variant: "light",
      color: "secondary",
      class: [colorVariants.light.secondary, "data-[hover=true]:bg-secondary/20"]
    },
    {
      variant: "light",
      color: "success",
      class: [colorVariants.light.success, "data-[hover=true]:bg-success/20"]
    },
    {
      variant: "light",
      color: "warning",
      class: [colorVariants.light.warning, "data-[hover=true]:bg-warning/20"]
    },
    {
      variant: "light",
      color: "danger",
      class: [colorVariants.light.danger, "data-[hover=true]:bg-danger/20"]
    },
    // ghost / color
    {
      variant: "ghost",
      color: "default",
      class: [colorVariants.ghost.default, "data-[hover=true]:!bg-default"]
    },
    {
      variant: "ghost",
      color: "primary",
      class: [
        colorVariants.ghost.primary,
        "data-[hover=true]:!bg-primary data-[hover=true]:!text-primary-foreground"
      ]
    },
    {
      variant: "ghost",
      color: "secondary",
      class: [
        colorVariants.ghost.secondary,
        "data-[hover=true]:!bg-secondary data-[hover=true]:!text-secondary-foreground"
      ]
    },
    {
      variant: "ghost",
      color: "success",
      class: [
        colorVariants.ghost.success,
        "data-[hover=true]:!bg-success data-[hover=true]:!text-success-foreground"
      ]
    },
    {
      variant: "ghost",
      color: "warning",
      class: [
        colorVariants.ghost.warning,
        "data-[hover=true]:!bg-warning data-[hover=true]:!text-warning-foreground"
      ]
    },
    {
      variant: "ghost",
      color: "danger",
      class: [
        colorVariants.ghost.danger,
        "data-[hover=true]:!bg-danger data-[hover=true]:!text-danger-foreground"
      ]
    },
    // isInGroup / radius / size <-- radius not provided
    {
      isInGroup: true,
      class: "rounded-none first:rounded-s-medium last:rounded-e-medium"
    },
    {
      isInGroup: true,
      size: "sm",
      class: "rounded-none first:rounded-s-small last:rounded-e-small"
    },
    {
      isInGroup: true,
      size: "md",
      class: "rounded-none first:rounded-s-medium last:rounded-e-medium"
    },
    {
      isInGroup: true,
      size: "lg",
      class: "rounded-none first:rounded-s-large last:rounded-e-large"
    },
    {
      isInGroup: true,
      isRounded: true,
      class: "rounded-none first:rounded-s-full last:rounded-e-full"
    },
    // isInGroup / radius <-- radius provided
    {
      isInGroup: true,
      radius: "none",
      class: "rounded-none first:rounded-s-none last:rounded-e-none"
    },
    {
      isInGroup: true,
      radius: "sm",
      class: "rounded-none first:rounded-s-small last:rounded-e-small"
    },
    {
      isInGroup: true,
      radius: "md",
      class: "rounded-none first:rounded-s-medium last:rounded-e-medium"
    },
    {
      isInGroup: true,
      radius: "lg",
      class: "rounded-none first:rounded-s-large last:rounded-e-large"
    },
    {
      isInGroup: true,
      radius: "full",
      class: "rounded-none first:rounded-s-full last:rounded-e-full"
    },
    // isInGroup / bordered / ghost
    {
      isInGroup: true,
      variant: ["ghost", "bordered"],
      color: "default",
      className: collapseAdjacentVariantBorders.default
    },
    {
      isInGroup: true,
      variant: ["ghost", "bordered"],
      color: "primary",
      className: collapseAdjacentVariantBorders.primary
    },
    {
      isInGroup: true,
      variant: ["ghost", "bordered"],
      color: "secondary",
      className: collapseAdjacentVariantBorders.secondary
    },
    {
      isInGroup: true,
      variant: ["ghost", "bordered"],
      color: "success",
      className: collapseAdjacentVariantBorders.success
    },
    {
      isInGroup: true,
      variant: ["ghost", "bordered"],
      color: "warning",
      className: collapseAdjacentVariantBorders.warning
    },
    {
      isInGroup: true,
      variant: ["ghost", "bordered"],
      color: "danger",
      className: collapseAdjacentVariantBorders.danger
    },
    {
      isIconOnly: true,
      size: "sm",
      class: "min-w-8 w-8 h-8"
    },
    {
      isIconOnly: true,
      size: "md",
      class: "min-w-10 w-10 h-10"
    },
    {
      isIconOnly: true,
      size: "lg",
      class: "min-w-12 w-12 h-12"
    },
    // variant / hover
    {
      variant: ["solid", "faded", "flat", "bordered", "shadow"],
      class: "data-[hover=true]:opacity-hover"
    }
  ]
});
tv({
  base: "inline-flex items-center justify-center h-auto",
  variants: {
    fullWidth: {
      true: "w-full"
    }
  },
  defaultVariants: {
    fullWidth: false
  }
});
var alert$1 = tv({
  slots: {
    base: "flex flex-grow flex-row w-full items-start py-3 px-4 gap-x-1",
    mainWrapper: "h-full flex-grow min-h-10 ms-2 flex flex-col box-border items-start text-inherit justify-center",
    title: "text-small w-full font-medium block text-inherit leading-5",
    description: "pl-[1px] text-small font-normal text-inherit",
    closeButton: "relative text-inherit translate-x-1 -translate-y-1",
    iconWrapper: "flex-none relative w-9 h-9 rounded-full grid place-items-center",
    alertIcon: "fill-current w-6 absolute top-1/2 left-1/2 -translate-x-1/2 -translate-y-1/2"
  },
  variants: {
    color: {
      default: {},
      primary: {},
      secondary: {},
      success: {},
      warning: {},
      danger: {}
    },
    variant: {
      solid: {},
      flat: {},
      faded: {
        base: "border-small"
      },
      bordered: {
        base: "border-small bg-transparent"
      }
    },
    radius: {
      none: {
        base: "rounded-none"
      },
      sm: {
        base: "rounded-small"
      },
      md: {
        base: "rounded-medium"
      },
      lg: {
        base: "rounded-large"
      },
      full: {
        base: "rounded-full"
      }
    },
    hideIcon: {
      true: {
        iconWrapper: "hidden"
      }
    },
    hideIconWrapper: {
      true: {
        base: "gap-x-0",
        iconWrapper: "!bg-transparent !shadow-none !border-none"
      }
    },
    hasContent: {
      false: {
        base: "items-start",
        mainWrapper: "justify-center items-center"
      }
    }
  },
  defaultVariants: {
    color: "default",
    variant: "flat",
    radius: "md",
    hideIcon: false,
    hideIconWrapper: false
  },
  compoundVariants: [
    // solid / color
    {
      variant: "solid",
      color: "default",
      class: {
        base: colorVariants.solid.default,
        closeButton: "data-[hover]:bg-default-100",
        alertIcon: "text-default-foreground"
      }
    },
    {
      variant: "solid",
      color: "primary",
      class: {
        base: colorVariants.solid.primary
      }
    },
    {
      variant: "solid",
      color: "secondary",
      class: {
        base: colorVariants.solid.secondary
      }
    },
    {
      variant: "solid",
      color: "success",
      class: {
        base: colorVariants.solid.success
      }
    },
    {
      variant: "solid",
      color: "warning",
      class: {
        base: colorVariants.solid.warning
      }
    },
    {
      variant: "solid",
      color: "danger",
      class: {
        base: colorVariants.solid.danger
      }
    },
    // flat & faded / color
    {
      variant: ["flat", "faded"],
      color: "default",
      class: {
        base: [
          colorVariants.flat.default,
          "bg-default-100 dark:bg-default-50/50",
          "text-default-foreground"
        ],
        description: "text-default-600",
        closeButton: "text-default-400",
        iconWrapper: "bg-default-50 dark:bg-default-100 border-default-200"
      }
    },
    {
      variant: ["flat", "faded"],
      color: "primary",
      class: {
        base: [colorVariants.flat.primary, "bg-primary-50 dark:bg-primary-50/50"],
        closeButton: "text-primary-500 data-[hover]:bg-primary-200",
        iconWrapper: "bg-primary-50 dark:bg-primary-100 border-primary-100"
      }
    },
    {
      variant: ["flat", "faded"],
      color: "secondary",
      class: {
        base: [colorVariants.flat.secondary, "bg-secondary-50 dark:bg-secondary-50/50"],
        closeButton: "text-secondary-500 data-[hover]:bg-secondary-200",
        iconWrapper: "bg-secondary-50 dark:bg-secondary-100 border-secondary-100"
      }
    },
    {
      variant: ["flat", "faded"],
      color: "success",
      class: {
        base: [colorVariants.flat.success, "bg-success-50 dark:bg-success-50/50"],
        closeButton: "text-success-500 data-[hover]:bg-success-200",
        iconWrapper: "bg-success-50 dark:bg-success-100 border-success-100"
      }
    },
    {
      variant: ["flat", "faded"],
      color: "warning",
      class: {
        base: [colorVariants.flat.warning, "bg-warning-50 dark:bg-warning-50/50"],
        closeButton: "text-warning-500 data-[hover]:bg-warning-200",
        iconWrapper: "bg-warning-50 dark:bg-warning-100 border-warning-100"
      }
    },
    {
      variant: ["flat", "faded"],
      color: "danger",
      class: {
        base: [colorVariants.flat.danger, "bg-danger-50 dark:bg-danger-50/50"],
        closeButton: "text-danger-500 data-[hover]:bg-danger-200",
        iconWrapper: "bg-danger-50 dark:bg-danger-100 border-danger-100"
      }
    },
    // faded / color
    {
      variant: "faded",
      color: "default",
      class: {
        base: "border-default-300 dark:border-default-200"
      }
    },
    {
      variant: "faded",
      color: "primary",
      class: {
        base: "border-primary-200 dark:border-primary-100"
      }
    },
    {
      variant: "faded",
      color: "secondary",
      class: {
        base: "border-secondary-200"
      }
    },
    {
      variant: "faded",
      color: "success",
      class: {
        base: "border-success-300 dark:border-success-100"
      }
    },
    {
      variant: "faded",
      color: "warning",
      class: {
        base: "border-warning-300 dark:border-warning-100"
      }
    },
    {
      variant: "faded",
      color: "danger",
      class: {
        base: "border-danger-200 dark:border-danger-100"
      }
    },
    // bordered / color
    {
      variant: "bordered",
      color: "default",
      class: {
        base: [colorVariants.bordered.default],
        description: "text-default-600",
        closeButton: "text-default-400"
      }
    },
    {
      variant: "bordered",
      color: "primary",
      class: {
        base: [colorVariants.bordered.primary],
        closeButton: "data-[hover]:bg-primary-50"
      }
    },
    {
      variant: "bordered",
      color: "secondary",
      class: {
        base: [colorVariants.bordered.secondary],
        closeButton: "data-[hover]:bg-secondary-50"
      }
    },
    {
      variant: "bordered",
      color: "success",
      class: {
        base: [colorVariants.bordered.success],
        closeButton: "data-[hover]:bg-success-50"
      }
    },
    {
      variant: "bordered",
      color: "warning",
      class: {
        base: [colorVariants.bordered.warning],
        closeButton: "data-[hover]:bg-warning-100"
      }
    },
    {
      variant: "bordered",
      color: "danger",
      class: {
        base: [colorVariants.bordered.danger],
        closeButton: "data-[hover]:bg-danger-50"
      }
    },
    // flat & bordered & faded
    {
      variant: ["flat", "bordered", "faded"],
      class: {
        iconWrapper: "shadow-small"
      }
    },
    // flat & faded
    {
      variant: ["flat", "faded"],
      class: {
        iconWrapper: "shadow-small border-1"
      }
    },
    // bordered & color
    {
      variant: "bordered",
      color: "default",
      class: {
        iconWrapper: "bg-default-200 dark:bg-default-100"
      }
    },
    {
      variant: "bordered",
      color: "primary",
      class: {
        iconWrapper: "bg-primary-100 dark:bg-primary-50"
      }
    },
    {
      variant: "bordered",
      color: "secondary",
      class: {
        iconWrapper: "bg-secondary-100 dark:bg-secondary-50"
      }
    },
    {
      variant: "bordered",
      color: "success",
      class: {
        iconWrapper: "bg-success-100 dark:bg-success-50"
      }
    },
    {
      variant: "bordered",
      color: "warning",
      class: {
        iconWrapper: "bg-warning-100 dark:bg-warning-50"
      }
    },
    {
      variant: "bordered",
      color: "danger",
      class: {
        iconWrapper: "bg-danger-100 dark:bg-danger-50"
      }
    }
  ]
});
var WarningIcon = (props) => {
  return /* @__PURE__ */ jsxRuntimeExports.jsx(
    "svg",
    {
      className: "fill-current",
      fill: "none",
      height: "24",
      viewBox: "0 0 24 24",
      width: "24",
      xmlns: "http://www.w3.org/2000/svg",
      ...props,
      children: /* @__PURE__ */ jsxRuntimeExports.jsx(
        "path",
        {
          clipRule: "evenodd",
          d: "M3 10.417C3 7.219 3 5.62 3.378 5.082C3.755 4.545 5.258 4.03 8.265 3.001L8.838 2.805C10.405 2.268 11.188 2 12 2C12.812 2 13.595 2.268 15.162 2.805L15.735 3.001C18.742 4.03 20.245 4.545 20.622 5.082C21 5.62 21 7.22 21 10.417V11.991C21 17.629 16.761 20.366 14.101 21.527C13.38 21.842 13.02 22 12 22C10.98 22 10.62 21.842 9.899 21.527C7.239 20.365 3 17.63 3 11.991V10.417ZM12 7.25C12.1989 7.25 12.3897 7.32902 12.5303 7.46967C12.671 7.61032 12.75 7.80109 12.75 8V12C12.75 12.1989 12.671 12.3897 12.5303 12.5303C12.3897 12.671 12.1989 12.75 12 12.75C11.8011 12.75 11.6103 12.671 11.4697 12.5303C11.329 12.3897 11.25 12.1989 11.25 12V8C11.25 7.80109 11.329 7.61032 11.4697 7.46967C11.6103 7.32902 11.8011 7.25 12 7.25ZM12 16C12.2652 16 12.5196 15.8946 12.7071 15.7071C12.8946 15.5196 13 15.2652 13 15C13 14.7348 12.8946 14.4804 12.7071 14.2929C12.5196 14.1054 12.2652 14 12 14C11.7348 14 11.4804 14.1054 11.2929 14.2929C11.1054 14.4804 11 14.7348 11 15C11 15.2652 11.1054 15.5196 11.2929 15.7071C11.4804 15.8946 11.7348 16 12 16Z",
          fill: "currentColor",
          fillRule: "evenodd"
        }
      )
    }
  );
};
var SuccessIcon = (props) => {
  return /* @__PURE__ */ jsxRuntimeExports.jsx(
    "svg",
    {
      fill: "none",
      height: "24",
      viewBox: "0 0 24 24",
      width: "24",
      xmlns: "http://www.w3.org/2000/svg",
      ...props,
      children: /* @__PURE__ */ jsxRuntimeExports.jsx(
        "path",
        {
          d: "\n          M12 2C6.49 2 2 6.49 2 12C2 17.51 6.49 22 12 22C17.51 22 22 17.51 22 12C22 6.49 17.51 2 12 2Z\n          M16.78 9.7L11.11 15.37C10.97 15.51 10.78 15.59 10.58 15.59C10.38 15.59 10.19 15.51 10.05 15.37L7.22 12.54\n          C6.93 12.25 6.93 11.77 7.22 11.48C7.51 11.19 7.99 11.19 8.28 11.48L10.58 13.78L15.72 8.64\n          C16.01 8.35 16.49 8.35 16.78 8.64C17.07 8.93 17.07 9.4 16.78 9.7Z\n        "
        }
      )
    }
  );
};
var InfoCircleIcon = (props) => {
  return /* @__PURE__ */ jsxRuntimeExports.jsx(
    "svg",
    {
      fill: "none",
      height: "24",
      viewBox: "0 0 24 24",
      width: "24",
      xmlns: "http://www.w3.org/2000/svg",
      ...props,
      children: /* @__PURE__ */ jsxRuntimeExports.jsx("path", { d: "M12 22C17.51 22 22 17.51 22 12C22 6.49 17.51 2 12 2C6.49 2 2 6.49 2 12C2 17.51 6.49 22 12 22ZM12.75 16C12.75 16.41 12.41 16.75 12 16.75C11.59 16.75 11.25 16.41 11.25 16L11.25 11C11.25 10.59 11.59 10.25 12 10.25C12.41 10.25 12.75 10.59 12.75 11L12.75 16ZM11.08 7.62C11.13 7.49 11.2 7.39 11.29 7.29C11.39 7.2 11.5 7.13 11.62 7.08C11.74 7.03 11.87 7 12 7C12.13 7 12.26 7.03 12.38 7.08C12.5 7.13 12.61 7.2 12.71 7.29C12.8 7.39 12.87 7.49 12.92 7.62C12.97 7.74 13 7.87 13 8C13 8.13 12.97 8.26 12.92 8.38C12.87 8.5 12.8 8.61 12.71 8.71C12.61 8.8 12.5 8.87 12.38 8.92C12.14 9.02 11.86 9.02 11.62 8.92C11.5 8.87 11.39 8.8 11.29 8.71C11.2 8.61 11.13 8.5 11.08 8.38C11.03 8.26 11 8.13 11 8C11 7.87 11.03 7.74 11.08 7.62Z" })
    }
  );
};
var CloseIcon = (props) => {
  const { isSelected, isIndeterminate, disableAnimation, ...otherProps } = props;
  return /* @__PURE__ */ jsxRuntimeExports.jsx(
    "svg",
    {
      "aria-hidden": "true",
      className: "fill-current",
      fill: "none",
      focusable: "false",
      height: "1em",
      role: "presentation",
      stroke: "currentColor",
      strokeLinecap: "round",
      strokeLinejoin: "round",
      strokeWidth: 2,
      viewBox: "0 0 24 24",
      width: "1em",
      ...otherProps,
      children: /* @__PURE__ */ jsxRuntimeExports.jsx("path", { d: "M18 6L6 18M6 6l12 12" })
    }
  );
};
var DangerIcon = (props) => {
  return /* @__PURE__ */ jsxRuntimeExports.jsx(
    "svg",
    {
      className: "fill-current",
      fill: "none",
      height: "20",
      viewBox: "0 0 20 20",
      width: "20",
      xmlns: "http://www.w3.org/2000/svg",
      ...props,
      children: /* @__PURE__ */ jsxRuntimeExports.jsx("path", { d: "M17.51 3.85L11.57 0.42C10.6 -0.14 9.4 -0.14 8.42 0.42L2.49 3.85C1.52 4.41 0.919998 5.45 0.919998 6.58V13.42C0.919998 14.54 1.52 15.58 2.49 16.15L8.43 19.58C9.4 20.14 10.6 20.14 11.58 19.58L17.52 16.15C18.49 15.59 19.09 14.55 19.09 13.42V6.58C19.08 5.45 18.48 4.42 17.51 3.85ZM9.25 5.75C9.25 5.34 9.59 5 10 5C10.41 5 10.75 5.34 10.75 5.75V11C10.75 11.41 10.41 11.75 10 11.75C9.59 11.75 9.25 11.41 9.25 11V5.75ZM10.92 14.63C10.87 14.75 10.8 14.86 10.71 14.96C10.52 15.15 10.27 15.25 10 15.25C9.87 15.25 9.74 15.22 9.62 15.17C9.49 15.12 9.39 15.05 9.29 14.96C9.2 14.86 9.13 14.75 9.07 14.63C9.02 14.51 9 14.38 9 14.25C9 13.99 9.1 13.73 9.29 13.54C9.39 13.45 9.49 13.38 9.62 13.33C9.99 13.17 10.43 13.26 10.71 13.54C10.8 13.64 10.87 13.74 10.92 13.87C10.97 13.99 11 14.12 11 14.25C11 14.38 10.97 14.51 10.92 14.63Z" })
    }
  );
};
var [ButtonGroupProvider, useButtonGroupContext] = createContext2$1({
  name: "ButtonGroupContext",
  strict: false
});
function useAriaButton(props, ref) {
  let {
    elementType = "button",
    isDisabled,
    onPress,
    onPressStart,
    onPressEnd,
    onPressChange,
    // @ts-ignore - undocumented
    preventFocusOnPress,
    // @ts-ignore - undocumented
    allowFocusWhenDisabled,
    onClick,
    href,
    target,
    rel,
    type = "button",
    allowTextSelectionOnPress
  } = props;
  let additionalProps;
  if (elementType === "button") {
    additionalProps = {
      type,
      disabled: isDisabled
    };
  } else {
    additionalProps = {
      role: "button",
      href: elementType === "a" && !isDisabled ? href : void 0,
      target: elementType === "a" ? target : void 0,
      type: elementType === "input" ? type : void 0,
      disabled: elementType === "input" ? isDisabled : void 0,
      "aria-disabled": !isDisabled || elementType === "input" ? void 0 : isDisabled,
      rel: elementType === "a" ? rel : void 0
    };
  }
  let { pressProps, isPressed } = $f6c31cce2adf654f$export$45712eceda6fad21({
    onClick,
    onPressStart,
    onPressEnd,
    onPressChange,
    onPress,
    isDisabled,
    preventFocusOnPress,
    allowTextSelectionOnPress,
    ref
  });
  let { focusableProps } = $f645667febf57a63$export$4c014de7c8940b4c(props, ref);
  if (allowFocusWhenDisabled) {
    focusableProps.tabIndex = isDisabled ? -1 : focusableProps.tabIndex;
  }
  let buttonProps = $3ef42575df84b30b$export$9d1611c77c2fe928(
    focusableProps,
    pressProps,
    $65484d02dcb7eb3e$export$457c3d6518dd4c6f(props, { labelable: true })
  );
  return {
    isPressed,
    // Used to indicate press state for visual
    buttonProps: $3ef42575df84b30b$export$9d1611c77c2fe928(additionalProps, buttonProps, {
      "aria-haspopup": props["aria-haspopup"],
      "aria-expanded": props["aria-expanded"],
      "aria-controls": props["aria-controls"],
      "aria-pressed": props["aria-pressed"],
      "aria-current": props["aria-current"]
    })
  };
}
var domAnimation = () => __vitePreload(() => import("./index-vzch8Vsw.js"), true ? __vite__mapDeps([0,1]) : void 0).then((res) => res.default);
var Ripple$1 = (props) => {
  const { ripples = [], motionProps, color: color2 = "currentColor", style: style2, onClear } = props;
  return /* @__PURE__ */ jsxRuntimeExports.jsx(jsxRuntimeExports.Fragment, { children: ripples.map((ripple) => {
    const duration2 = clamp$5(0.01 * ripple.size, 0.2, ripple.size > 100 ? 0.75 : 0.5);
    return /* @__PURE__ */ jsxRuntimeExports.jsx(LazyMotion, { features: domAnimation, children: /* @__PURE__ */ jsxRuntimeExports.jsx(AnimatePresence, { mode: "popLayout", children: /* @__PURE__ */ jsxRuntimeExports.jsx(
      m$1.span,
      {
        animate: { transform: "scale(2)", opacity: 0 },
        className: "heroui-ripple",
        exit: { opacity: 0 },
        initial: { transform: "scale(0)", opacity: 0.35 },
        style: {
          position: "absolute",
          backgroundColor: color2,
          borderRadius: "100%",
          transformOrigin: "center",
          pointerEvents: "none",
          overflow: "hidden",
          inset: 0,
          zIndex: 0,
          top: ripple.y,
          left: ripple.x,
          width: `${ripple.size}px`,
          height: `${ripple.size}px`,
          ...style2
        },
        transition: { duration: duration2 },
        onAnimationComplete: () => {
          onClear(ripple.key);
        },
        ...motionProps
      }
    ) }) }, ripple.key);
  }) });
};
Ripple$1.displayName = "HeroUI.Ripple";
var ripple_default = Ripple$1;
function useRipple(props = {}) {
  const [ripples, setRipples] = reactExports.useState([]);
  const onPress = reactExports.useCallback((event) => {
    const trigger = event.target;
    const size2 = Math.max(trigger.clientWidth, trigger.clientHeight);
    setRipples((prevRipples) => [
      ...prevRipples,
      {
        key: getUniqueID(prevRipples.length.toString()),
        size: size2,
        x: event.x - size2 / 2,
        y: event.y - size2 / 2
      }
    ]);
  }, []);
  const onClear = reactExports.useCallback((key2) => {
    setRipples((prevState) => prevState.filter((ripple) => ripple.key !== key2));
  }, []);
  return { ripples, onClear, onPress, ...props };
}
function useButton(props) {
  var _a2, _b2, _c2, _d2, _e2, _f2, _g2, _h2, _i2;
  const groupContext = useButtonGroupContext();
  const globalContext = useProviderContext();
  const isInGroup = !!groupContext;
  const {
    ref,
    as,
    children,
    startContent: startContentProp,
    endContent: endContentProp,
    autoFocus,
    className,
    spinner: spinner2,
    isLoading = false,
    disableRipple: disableRippleProp = false,
    fullWidth = (_a2 = groupContext == null ? void 0 : groupContext.fullWidth) != null ? _a2 : false,
    radius = groupContext == null ? void 0 : groupContext.radius,
    size: size2 = (_b2 = groupContext == null ? void 0 : groupContext.size) != null ? _b2 : "md",
    color: color2 = (_c2 = groupContext == null ? void 0 : groupContext.color) != null ? _c2 : "default",
    variant = (_d2 = groupContext == null ? void 0 : groupContext.variant) != null ? _d2 : "solid",
    disableAnimation = (_f2 = (_e2 = groupContext == null ? void 0 : groupContext.disableAnimation) != null ? _e2 : globalContext == null ? void 0 : globalContext.disableAnimation) != null ? _f2 : false,
    isDisabled: isDisabledProp = (_g2 = groupContext == null ? void 0 : groupContext.isDisabled) != null ? _g2 : false,
    isIconOnly = (_h2 = groupContext == null ? void 0 : groupContext.isIconOnly) != null ? _h2 : false,
    spinnerPlacement = "start",
    onPress,
    onClick,
    ...otherProps
  } = props;
  const Component = as || "button";
  const shouldFilterDOMProps = typeof Component === "string";
  const domRef = useDOMRef(ref);
  const disableRipple = (_i2 = disableRippleProp || (globalContext == null ? void 0 : globalContext.disableRipple)) != null ? _i2 : disableAnimation;
  const { isFocusVisible: isFocusVisible2, isFocused, focusProps } = $f7dceffc5ad7768b$export$4e328f61c538687f({
    autoFocus
  });
  const isDisabled = isDisabledProp || isLoading;
  const styles2 = reactExports.useMemo(
    () => button({
      size: size2,
      color: color2,
      variant,
      radius,
      fullWidth,
      isDisabled,
      isInGroup,
      disableAnimation,
      isIconOnly,
      className
    }),
    [
      size2,
      color2,
      variant,
      radius,
      fullWidth,
      isDisabled,
      isInGroup,
      isIconOnly,
      disableAnimation,
      className
    ]
  );
  const { onPress: onRipplePressHandler, onClear: onClearRipple, ripples } = useRipple();
  const handlePress = reactExports.useCallback(
    (e2) => {
      if (disableRipple || isDisabled || disableAnimation) return;
      domRef.current && onRipplePressHandler(e2);
    },
    [disableRipple, isDisabled, disableAnimation, domRef, onRipplePressHandler]
  );
  const { buttonProps: ariaButtonProps, isPressed } = useAriaButton(
    {
      elementType: as,
      isDisabled,
      onPress: $ff5963eb1fccf552$export$e08e3b67e392101e(onPress, handlePress),
      onClick,
      ...otherProps
    },
    domRef
  );
  const { isHovered, hoverProps } = $6179b936705e76d3$export$ae780daf29e6d456({ isDisabled });
  const getButtonProps = reactExports.useCallback(
    (props2 = {}) => ({
      "data-disabled": dataAttr(isDisabled),
      "data-focus": dataAttr(isFocused),
      "data-pressed": dataAttr(isPressed),
      "data-focus-visible": dataAttr(isFocusVisible2),
      "data-hover": dataAttr(isHovered),
      "data-loading": dataAttr(isLoading),
      ...$3ef42575df84b30b$export$9d1611c77c2fe928(
        ariaButtonProps,
        focusProps,
        hoverProps,
        filterDOMProps(otherProps, {
          enabled: shouldFilterDOMProps
        }),
        filterDOMProps(props2)
      ),
      className: styles2
    }),
    [
      isLoading,
      isDisabled,
      isFocused,
      isPressed,
      shouldFilterDOMProps,
      isFocusVisible2,
      isHovered,
      ariaButtonProps,
      focusProps,
      hoverProps,
      otherProps,
      styles2
    ]
  );
  const getIconClone = (icon) => reactExports.isValidElement(icon) ? reactExports.cloneElement(icon, {
    // @ts-ignore
    "aria-hidden": true,
    focusable: false
  }) : null;
  const startContent = getIconClone(startContentProp);
  const endContent = getIconClone(endContentProp);
  const spinnerSize = reactExports.useMemo(() => {
    const buttonSpinnerSizeMap = {
      sm: "sm",
      md: "sm",
      lg: "md"
    };
    return buttonSpinnerSizeMap[size2];
  }, [size2]);
  const getRippleProps = reactExports.useCallback(
    () => ({ ripples, onClear: onClearRipple }),
    [ripples, onClearRipple]
  );
  return {
    Component,
    children,
    domRef,
    spinner: spinner2,
    styles: styles2,
    startContent,
    endContent,
    isLoading,
    spinnerPlacement,
    spinnerSize,
    disableRipple,
    getButtonProps,
    getRippleProps,
    isIconOnly
  };
}
function useSpinner(originalProps) {
  var _a2, _b2;
  const [props, variantProps2] = mapPropsVariants(originalProps, spinner.variantKeys);
  const globalContext = useProviderContext();
  const variant = (_b2 = (_a2 = originalProps == null ? void 0 : originalProps.variant) != null ? _a2 : globalContext == null ? void 0 : globalContext.spinnerVariant) != null ? _b2 : "default";
  const { children, className, classNames, label: labelProp, ...otherProps } = props;
  const slots = reactExports.useMemo(() => spinner({ ...variantProps2 }), [objectToDeps(variantProps2)]);
  const baseStyles = clsx$1(classNames == null ? void 0 : classNames.base, className);
  const label = labelProp || children;
  const ariaLabel = reactExports.useMemo(() => {
    if (label && typeof label === "string") {
      return label;
    }
    return !otherProps["aria-label"] ? "Loading" : "";
  }, [children, label, otherProps["aria-label"]]);
  const getSpinnerProps = reactExports.useCallback(
    () => ({
      "aria-label": ariaLabel,
      className: slots.base({
        class: baseStyles
      }),
      ...otherProps
    }),
    [ariaLabel, slots, baseStyles, otherProps]
  );
  return { label, slots, classNames, variant, getSpinnerProps };
}
var Spinner = forwardRef((props, ref) => {
  const { slots, classNames, label, variant, getSpinnerProps } = useSpinner({ ...props });
  if (variant === "wave" || variant === "dots") {
    return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { ref, ...getSpinnerProps(), children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: slots.wrapper({ class: classNames == null ? void 0 : classNames.wrapper }), children: [...new Array(3)].map((_2, index2) => /* @__PURE__ */ jsxRuntimeExports.jsx(
        "i",
        {
          className: slots.dots({ class: classNames == null ? void 0 : classNames.dots }),
          style: {
            "--dot-index": index2
          }
        },
        `dot-${index2}`
      )) }),
      label && /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: slots.label({ class: classNames == null ? void 0 : classNames.label }), children: label })
    ] });
  }
  if (variant === "simple") {
    return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { ref, ...getSpinnerProps(), children: [
      /* @__PURE__ */ jsxRuntimeExports.jsxs(
        "svg",
        {
          className: slots.wrapper({ class: classNames == null ? void 0 : classNames.wrapper }),
          fill: "none",
          viewBox: "0 0 24 24",
          children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx(
              "circle",
              {
                className: slots.circle1({ class: classNames == null ? void 0 : classNames.circle1 }),
                cx: "12",
                cy: "12",
                r: "10",
                stroke: "currentColor",
                strokeWidth: "4"
              }
            ),
            /* @__PURE__ */ jsxRuntimeExports.jsx(
              "path",
              {
                className: slots.circle2({ class: classNames == null ? void 0 : classNames.circle2 }),
                d: "M4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4zm2 5.291A7.962 7.962 0 014 12H0c0 3.042 1.135 5.824 3 7.938l3-2.647z",
                fill: "currentColor"
              }
            )
          ]
        }
      ),
      label && /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: slots.label({ class: classNames == null ? void 0 : classNames.label }), children: label })
    ] });
  }
  if (variant === "spinner") {
    return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { ref, ...getSpinnerProps(), children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: slots.wrapper({ class: classNames == null ? void 0 : classNames.wrapper }), children: [...new Array(12)].map((_2, index2) => /* @__PURE__ */ jsxRuntimeExports.jsx(
        "i",
        {
          className: slots.spinnerBars({ class: classNames == null ? void 0 : classNames.spinnerBars }),
          style: {
            "--bar-index": index2
          }
        },
        `star-${index2}`
      )) }),
      label && /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: slots.label({ class: classNames == null ? void 0 : classNames.label }), children: label })
    ] });
  }
  return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { ref, ...getSpinnerProps(), children: [
    /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: slots.wrapper({ class: classNames == null ? void 0 : classNames.wrapper }), children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx("i", { className: slots.circle1({ class: classNames == null ? void 0 : classNames.circle1 }) }),
      /* @__PURE__ */ jsxRuntimeExports.jsx("i", { className: slots.circle2({ class: classNames == null ? void 0 : classNames.circle2 }) })
    ] }),
    label && /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: slots.label({ class: classNames == null ? void 0 : classNames.label }), children: label })
  ] });
});
Spinner.displayName = "HeroUI.Spinner";
var spinner_default = Spinner;
var Button$2 = forwardRef((props, ref) => {
  const {
    Component,
    domRef,
    children,
    spinnerSize,
    spinner: spinner2 = /* @__PURE__ */ jsxRuntimeExports.jsx(spinner_default, { color: "current", size: spinnerSize }),
    spinnerPlacement,
    startContent,
    endContent,
    isLoading,
    disableRipple,
    getButtonProps,
    getRippleProps,
    isIconOnly
  } = useButton({ ...props, ref });
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(Component, { ref: domRef, ...getButtonProps(), children: [
    startContent,
    isLoading && spinnerPlacement === "start" && spinner2,
    isLoading && isIconOnly ? null : children,
    isLoading && spinnerPlacement === "end" && spinner2,
    endContent,
    !disableRipple && /* @__PURE__ */ jsxRuntimeExports.jsx(ripple_default, { ...getRippleProps() })
  ] });
});
Button$2.displayName = "HeroUI.Button";
var button_default = Button$2;
function _extends() {
  return _extends = Object.assign ? Object.assign.bind() : function(n2) {
    for (var e2 = 1; e2 < arguments.length; e2++) {
      var t2 = arguments[e2];
      for (var r2 in t2) ({}).hasOwnProperty.call(t2, r2) && (n2[r2] = t2[r2]);
    }
    return n2;
  }, _extends.apply(null, arguments);
}
function _objectWithoutPropertiesLoose(r2, e2) {
  if (null == r2) return {};
  var t2 = {};
  for (var n2 in r2) if ({}.hasOwnProperty.call(r2, n2)) {
    if (-1 !== e2.indexOf(n2)) continue;
    t2[n2] = r2[n2];
  }
  return t2;
}
function useAlert(originalProps) {
  const [props, variantProps2] = mapPropsVariants(originalProps, alert$1.variantKeys);
  const {
    as,
    title,
    children,
    description,
    onClose,
    isClosable,
    ref,
    icon,
    startContent,
    endContent,
    isVisible: isVisibleProp,
    isDefaultVisible,
    onVisibleChange,
    closeButtonProps = {
      size: "sm"
    },
    className,
    classNames,
    ...otherProps
  } = props;
  const [isVisible, setIsVisible] = $458b0a5536c1a7cf$export$40bfa8c7b0832715(
    isVisibleProp,
    isDefaultVisible != null ? isDefaultVisible : true,
    onVisibleChange
  );
  const Component = as || "div";
  const shouldFilterDOMProps = typeof Component === "string";
  const domRef = useDOMRef(ref);
  const handleClose = reactExports.useCallback(() => {
    setIsVisible(false);
    onClose == null ? void 0 : onClose();
  }, [setIsVisible, onClose]);
  const baseStyles = clsx$1(classNames == null ? void 0 : classNames.base, className);
  const slots = reactExports.useMemo(
    () => alert$1({ hasContent: !isEmpty$1(description) || !isEmpty$1(children), ...variantProps2 }),
    [description, objectToDeps(variantProps2)]
  );
  const getBaseProps = reactExports.useCallback(() => {
    return {
      "data-visible": dataAttr(isVisible),
      "data-closeable": dataAttr(isClosable),
      "data-has-title": dataAttr(!isEmpty$1(title)),
      "data-has-description": dataAttr(!isEmpty$1(description)),
      ...$3ef42575df84b30b$export$9d1611c77c2fe928(
        filterDOMProps(otherProps, {
          enabled: shouldFilterDOMProps
        }),
        filterDOMProps(props)
      ),
      className: slots.base({ class: baseStyles })
    };
  }, [slots, baseStyles]);
  const getMainWrapperProps = reactExports.useCallback(() => {
    return {
      className: slots.mainWrapper({ class: classNames == null ? void 0 : classNames.mainWrapper })
    };
  }, [slots, classNames == null ? void 0 : classNames.mainWrapper]);
  const getDescriptionProps = reactExports.useCallback(() => {
    return {
      className: slots.description({ class: classNames == null ? void 0 : classNames.description })
    };
  }, [slots, classNames == null ? void 0 : classNames.description]);
  const getTitleProps = reactExports.useCallback(() => {
    return {
      className: slots.title({ class: classNames == null ? void 0 : classNames.title })
    };
  }, [slots, classNames == null ? void 0 : classNames.title]);
  const getCloseButtonProps = reactExports.useCallback(
    () => ({
      ...closeButtonProps,
      className: slots.closeButton({ class: classNames == null ? void 0 : classNames.closeButton })
    }),
    [slots, classNames == null ? void 0 : classNames.closeButton]
  );
  const getAlertIconProps = reactExports.useCallback(
    () => ({
      className: slots.alertIcon({ class: classNames == null ? void 0 : classNames.alertIcon })
    }),
    [slots, classNames == null ? void 0 : classNames.alertIcon]
  );
  const getIconWrapperProps = reactExports.useCallback(
    () => ({
      className: slots.iconWrapper({ class: classNames == null ? void 0 : classNames.iconWrapper })
    }),
    [slots, classNames == null ? void 0 : classNames.iconWrapper]
  );
  return {
    title,
    icon,
    children,
    description,
    isClosable,
    domRef,
    endContent,
    startContent,
    getBaseProps,
    getMainWrapperProps,
    getDescriptionProps,
    getTitleProps,
    color: variantProps2["color"],
    getCloseButtonProps,
    handleClose,
    isVisible,
    onClose,
    getAlertIconProps,
    getIconWrapperProps
  };
}
var iconMap = {
  primary: InfoCircleIcon,
  secondary: InfoCircleIcon,
  success: SuccessIcon,
  warning: WarningIcon,
  danger: DangerIcon
};
var Alert$1 = forwardRef((props, ref) => {
  const {
    title,
    icon,
    children,
    description,
    endContent,
    startContent,
    isClosable,
    domRef,
    handleClose,
    getBaseProps,
    getMainWrapperProps,
    getDescriptionProps,
    getTitleProps,
    getCloseButtonProps,
    color: color2,
    isVisible,
    onClose,
    getAlertIconProps,
    getIconWrapperProps
  } = useAlert({ ...props, ref });
  if (!isVisible) return null;
  const customIcon = icon && reactExports.isValidElement(icon) ? reactExports.cloneElement(icon, getAlertIconProps()) : null;
  const IconComponent = iconMap[color2] || iconMap.primary;
  return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { ref: domRef, role: "alert", ...getBaseProps(), children: [
    startContent,
    /* @__PURE__ */ jsxRuntimeExports.jsx("div", { ...getIconWrapperProps(), children: customIcon || /* @__PURE__ */ jsxRuntimeExports.jsx(IconComponent, { ...getAlertIconProps() }) }),
    /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { ...getMainWrapperProps(), children: [
      !isEmpty$1(title) && /* @__PURE__ */ jsxRuntimeExports.jsx("div", { ...getTitleProps(), children: title }),
      !isEmpty$1(description) && /* @__PURE__ */ jsxRuntimeExports.jsx("div", { ...getDescriptionProps(), children: description }),
      children
    ] }),
    endContent,
    (isClosable || onClose) && /* @__PURE__ */ jsxRuntimeExports.jsx(
      button_default,
      {
        isIconOnly: true,
        "aria-label": "Close",
        radius: "full",
        variant: "light",
        onPress: handleClose,
        ...getCloseButtonProps(),
        children: /* @__PURE__ */ jsxRuntimeExports.jsx(CloseIcon, { height: 20, width: 20 })
      }
    )
  ] });
});
Alert$1.displayName = "HeroUI.Alert";
var alert_default = Alert$1;
function cn(...inputs) {
  return twMerge(clsx(inputs));
}
const AUTO_CLOSE_MS = 4e3;
const ToastProvider = ({ children }) => /* @__PURE__ */ jsxRuntimeExports.jsx(jsxRuntimeExports.Fragment, { children });
const ToastViewport = reactExports.forwardRef(
  ({ className, ...props }, ref) => /* @__PURE__ */ jsxRuntimeExports.jsx(
    "div",
    {
      ref,
      className: cn(
        "fixed top-0 z-[100] flex max-h-screen w-full flex-col-reverse p-4 sm:bottom-0 sm:right-0 sm:top-auto sm:flex-col md:max-w-[420px]",
        className
      ),
      ...props
    }
  )
);
ToastViewport.displayName = "ToastViewport";
const variantToColor = {
  default: "default",
  destructive: "danger",
  success: "success",
  warning: "warning",
  info: "primary",
  primary: "primary",
  secondary: "secondary"
};
const Toast = reactExports.forwardRef(
  ({ className, title, description, variant = "default", color: color2, onOpenChange, open = true, ...props }, ref) => {
    const [visible, setVisible] = reactExports.useState(open);
    reactExports.useEffect(() => {
      if (visible) {
        const timer = setTimeout(() => {
          setVisible(false);
          if (onOpenChange) onOpenChange(false);
        }, AUTO_CLOSE_MS);
        return () => clearTimeout(timer);
      }
    }, [visible, onOpenChange]);
    if (!visible) return null;
    return /* @__PURE__ */ jsxRuntimeExports.jsx("div", { ref, className: cn("w-full flex items-center my-3", className), children: /* @__PURE__ */ jsxRuntimeExports.jsx(
      alert_default,
      {
        color: color2 || variantToColor[variant] || "default",
        title,
        description,
        className: "!bg-[#1e2327] !text-white",
        ...props
      }
    ) });
  }
);
Toast.displayName = "Toast";
const ToastClose = () => null;
const ToastTitle = ({ children }) => /* @__PURE__ */ jsxRuntimeExports.jsx(jsxRuntimeExports.Fragment, { children });
const ToastDescription = ({ children }) => /* @__PURE__ */ jsxRuntimeExports.jsx(jsxRuntimeExports.Fragment, { children });
function Toaster$1() {
  const { toasts } = useToast();
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(ToastProvider, { children: [
    toasts.map(function({ id: id2, title, description, action, ...props }) {
      return /* @__PURE__ */ jsxRuntimeExports.jsxs(Toast, { ...props, children: [
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "grid gap-1", children: [
          title && /* @__PURE__ */ jsxRuntimeExports.jsx(ToastTitle, { children: title }),
          description && /* @__PURE__ */ jsxRuntimeExports.jsx(ToastDescription, { children: description })
        ] }),
        action,
        /* @__PURE__ */ jsxRuntimeExports.jsx(ToastClose, {})
      ] }, id2);
    }),
    /* @__PURE__ */ jsxRuntimeExports.jsx(ToastViewport, {})
  ] });
}
var P = ["light", "dark"], E = "(prefers-color-scheme: dark)", L = reactExports.createContext(void 0), D$1 = { setTheme: (e2) => {
}, themes: [] }, j = () => {
  var e2;
  return (e2 = reactExports.useContext(L)) != null ? e2 : D$1;
};
reactExports.memo(({ forcedTheme: e2, storageKey: a2, attribute: n2, enableSystem: g2, enableColorScheme: m2, defaultTheme: c2, value: o, attrs: y2, nonce: h2 }) => {
  let k2 = c2 === "system", w2 = n2 === "class" ? `var d=document.documentElement,c=d.classList;${`c.remove(${y2.map((u2) => `'${u2}'`).join(",")})`};` : `var d=document.documentElement,n='${n2}',s='setAttribute';`, i2 = m2 ? (P.includes(c2) ? c2 : null) ? `if(e==='light'||e==='dark'||!e)d.style.colorScheme=e||'${c2}'` : "if(e==='light'||e==='dark')d.style.colorScheme=e" : "", d2 = (l2, u2 = false, R2 = true) => {
    let f2 = o ? o[l2] : l2, p2 = u2 ? l2 + "|| ''" : `'${f2}'`, $ = "";
    return m2 && R2 && !u2 && P.includes(l2) && ($ += `d.style.colorScheme = '${l2}';`), n2 === "class" ? u2 || f2 ? $ += `c.add(${p2})` : $ += "null" : f2 && ($ += `d[s](n,${p2})`), $;
  }, S = e2 ? `!function(){${w2}${d2(e2)}}()` : g2 ? `!function(){try{${w2}var e=localStorage.getItem('${a2}');if('system'===e||(!e&&${k2})){var t='${E}',m=window.matchMedia(t);if(m.media!==t||m.matches){${d2("dark")}}else{${d2("light")}}}else if(e){${o ? `var x=${JSON.stringify(o)};` : ""}${d2(o ? "x[e]" : "e", true)}}${k2 ? "" : "else{" + d2(c2, false, false) + "}"}${i2}}catch(e){}}()` : `!function(){try{${w2}var e=localStorage.getItem('${a2}');if(e){${o ? `var x=${JSON.stringify(o)};` : ""}${d2(o ? "x[e]" : "e", true)}}else{${d2(c2, false, false)};}${i2}}catch(t){}}();`;
  return reactExports.createElement("script", { nonce: h2, dangerouslySetInnerHTML: { __html: S } });
});
var Ct = (s) => {
  switch (s) {
    case "success":
      return $t;
    case "info":
      return _t;
    case "warning":
      return Wt;
    case "error":
      return Ut;
    default:
      return null;
  }
}, Ft = Array(12).fill(0), It = ({ visible: s }) => React.createElement("div", { className: "sonner-loading-wrapper", "data-visible": s }, React.createElement("div", { className: "sonner-spinner" }, Ft.map((o, t2) => React.createElement("div", { className: "sonner-loading-bar", key: `spinner-bar-${t2}` })))), $t = React.createElement("svg", { xmlns: "http://www.w3.org/2000/svg", viewBox: "0 0 20 20", fill: "currentColor", height: "20", width: "20" }, React.createElement("path", { fillRule: "evenodd", d: "M10 18a8 8 0 100-16 8 8 0 000 16zm3.857-9.809a.75.75 0 00-1.214-.882l-3.483 4.79-1.88-1.88a.75.75 0 10-1.06 1.061l2.5 2.5a.75.75 0 001.137-.089l4-5.5z", clipRule: "evenodd" })), Wt = React.createElement("svg", { xmlns: "http://www.w3.org/2000/svg", viewBox: "0 0 24 24", fill: "currentColor", height: "20", width: "20" }, React.createElement("path", { fillRule: "evenodd", d: "M9.401 3.003c1.155-2 4.043-2 5.197 0l7.355 12.748c1.154 2-.29 4.5-2.599 4.5H4.645c-2.309 0-3.752-2.5-2.598-4.5L9.4 3.003zM12 8.25a.75.75 0 01.75.75v3.75a.75.75 0 01-1.5 0V9a.75.75 0 01.75-.75zm0 8.25a.75.75 0 100-1.5.75.75 0 000 1.5z", clipRule: "evenodd" })), _t = React.createElement("svg", { xmlns: "http://www.w3.org/2000/svg", viewBox: "0 0 20 20", fill: "currentColor", height: "20", width: "20" }, React.createElement("path", { fillRule: "evenodd", d: "M18 10a8 8 0 11-16 0 8 8 0 0116 0zm-7-4a1 1 0 11-2 0 1 1 0 012 0zM9 9a.75.75 0 000 1.5h.253a.25.25 0 01.244.304l-.459 2.066A1.75 1.75 0 0010.747 15H11a.75.75 0 000-1.5h-.253a.25.25 0 01-.244-.304l.459-2.066A1.75 1.75 0 009.253 9H9z", clipRule: "evenodd" })), Ut = React.createElement("svg", { xmlns: "http://www.w3.org/2000/svg", viewBox: "0 0 20 20", fill: "currentColor", height: "20", width: "20" }, React.createElement("path", { fillRule: "evenodd", d: "M18 10a8 8 0 11-16 0 8 8 0 0116 0zm-8-5a.75.75 0 01.75.75v4.5a.75.75 0 01-1.5 0v-4.5A.75.75 0 0110 5zm0 10a1 1 0 100-2 1 1 0 000 2z", clipRule: "evenodd" }));
var Dt = () => {
  let [s, o] = React.useState(document.hidden);
  return React.useEffect(() => {
    let t2 = () => {
      o(document.hidden);
    };
    return document.addEventListener("visibilitychange", t2), () => window.removeEventListener("visibilitychange", t2);
  }, []), s;
};
var ct = 1, ut = class {
  constructor() {
    this.subscribe = (o) => (this.subscribers.push(o), () => {
      let t2 = this.subscribers.indexOf(o);
      this.subscribers.splice(t2, 1);
    });
    this.publish = (o) => {
      this.subscribers.forEach((t2) => t2(o));
    };
    this.addToast = (o) => {
      this.publish(o), this.toasts = [...this.toasts, o];
    };
    this.create = (o) => {
      var b2;
      let { message: t2, ...n2 } = o, h2 = typeof (o == null ? void 0 : o.id) == "number" || ((b2 = o.id) == null ? void 0 : b2.length) > 0 ? o.id : ct++, u2 = this.toasts.find((d2) => d2.id === h2), g2 = o.dismissible === void 0 ? true : o.dismissible;
      return u2 ? this.toasts = this.toasts.map((d2) => d2.id === h2 ? (this.publish({ ...d2, ...o, id: h2, title: t2 }), { ...d2, ...o, id: h2, dismissible: g2, title: t2 }) : d2) : this.addToast({ title: t2, ...n2, dismissible: g2, id: h2 }), h2;
    };
    this.dismiss = (o) => (o || this.toasts.forEach((t2) => {
      this.subscribers.forEach((n2) => n2({ id: t2.id, dismiss: true }));
    }), this.subscribers.forEach((t2) => t2({ id: o, dismiss: true })), o);
    this.message = (o, t2) => this.create({ ...t2, message: o });
    this.error = (o, t2) => this.create({ ...t2, message: o, type: "error" });
    this.success = (o, t2) => this.create({ ...t2, type: "success", message: o });
    this.info = (o, t2) => this.create({ ...t2, type: "info", message: o });
    this.warning = (o, t2) => this.create({ ...t2, type: "warning", message: o });
    this.loading = (o, t2) => this.create({ ...t2, type: "loading", message: o });
    this.promise = (o, t2) => {
      if (!t2) return;
      let n2;
      t2.loading !== void 0 && (n2 = this.create({ ...t2, promise: o, type: "loading", message: t2.loading, description: typeof t2.description != "function" ? t2.description : void 0 }));
      let h2 = o instanceof Promise ? o : o(), u2 = n2 !== void 0;
      return h2.then(async (g2) => {
        if (Ot(g2) && !g2.ok) {
          u2 = false;
          let b2 = typeof t2.error == "function" ? await t2.error(`HTTP error! status: ${g2.status}`) : t2.error, d2 = typeof t2.description == "function" ? await t2.description(`HTTP error! status: ${g2.status}`) : t2.description;
          this.create({ id: n2, type: "error", message: b2, description: d2 });
        } else if (t2.success !== void 0) {
          u2 = false;
          let b2 = typeof t2.success == "function" ? await t2.success(g2) : t2.success, d2 = typeof t2.description == "function" ? await t2.description(g2) : t2.description;
          this.create({ id: n2, type: "success", message: b2, description: d2 });
        }
      }).catch(async (g2) => {
        if (t2.error !== void 0) {
          u2 = false;
          let b2 = typeof t2.error == "function" ? await t2.error(g2) : t2.error, d2 = typeof t2.description == "function" ? await t2.description(g2) : t2.description;
          this.create({ id: n2, type: "error", message: b2, description: d2 });
        }
      }).finally(() => {
        var g2;
        u2 && (this.dismiss(n2), n2 = void 0), (g2 = t2.finally) == null || g2.call(t2);
      }), n2;
    };
    this.custom = (o, t2) => {
      let n2 = (t2 == null ? void 0 : t2.id) || ct++;
      return this.create({ jsx: o(n2), id: n2, ...t2 }), n2;
    };
    this.subscribers = [], this.toasts = [];
  }
}, v$1 = new ut(), Vt = (s, o) => {
  let t2 = (o == null ? void 0 : o.id) || ct++;
  return v$1.addToast({ title: s, ...o, id: t2 }), t2;
}, Ot = (s) => s && typeof s == "object" && "ok" in s && typeof s.ok == "boolean" && "status" in s && typeof s.status == "number", Kt = Vt, Xt = () => v$1.toasts, Jt = Object.assign(Kt, { success: v$1.success, info: v$1.info, warning: v$1.warning, error: v$1.error, custom: v$1.custom, message: v$1.message, promise: v$1.promise, dismiss: v$1.dismiss, loading: v$1.loading }, { getHistory: Xt });
function ft(s, { insertAt: o } = {}) {
  if (typeof document == "undefined") return;
  let t2 = document.head || document.getElementsByTagName("head")[0], n2 = document.createElement("style");
  n2.type = "text/css", o === "top" && t2.firstChild ? t2.insertBefore(n2, t2.firstChild) : t2.appendChild(n2), n2.styleSheet ? n2.styleSheet.cssText = s : n2.appendChild(document.createTextNode(s));
}
ft(`:where(html[dir="ltr"]),:where([data-sonner-toaster][dir="ltr"]){--toast-icon-margin-start: -3px;--toast-icon-margin-end: 4px;--toast-svg-margin-start: -1px;--toast-svg-margin-end: 0px;--toast-button-margin-start: auto;--toast-button-margin-end: 0;--toast-close-button-start: 0;--toast-close-button-end: unset;--toast-close-button-transform: translate(-35%, -35%)}:where(html[dir="rtl"]),:where([data-sonner-toaster][dir="rtl"]){--toast-icon-margin-start: 4px;--toast-icon-margin-end: -3px;--toast-svg-margin-start: 0px;--toast-svg-margin-end: -1px;--toast-button-margin-start: 0;--toast-button-margin-end: auto;--toast-close-button-start: unset;--toast-close-button-end: 0;--toast-close-button-transform: translate(35%, -35%)}:where([data-sonner-toaster]){position:fixed;width:var(--width);font-family:ui-sans-serif,system-ui,-apple-system,BlinkMacSystemFont,Segoe UI,Roboto,Helvetica Neue,Arial,Noto Sans,sans-serif,Apple Color Emoji,Segoe UI Emoji,Segoe UI Symbol,Noto Color Emoji;--gray1: hsl(0, 0%, 99%);--gray2: hsl(0, 0%, 97.3%);--gray3: hsl(0, 0%, 95.1%);--gray4: hsl(0, 0%, 93%);--gray5: hsl(0, 0%, 90.9%);--gray6: hsl(0, 0%, 88.7%);--gray7: hsl(0, 0%, 85.8%);--gray8: hsl(0, 0%, 78%);--gray9: hsl(0, 0%, 56.1%);--gray10: hsl(0, 0%, 52.3%);--gray11: hsl(0, 0%, 43.5%);--gray12: hsl(0, 0%, 9%);--border-radius: 8px;box-sizing:border-box;padding:0;margin:0;list-style:none;outline:none;z-index:999999999}:where([data-sonner-toaster][data-x-position="right"]){right:max(var(--offset),env(safe-area-inset-right))}:where([data-sonner-toaster][data-x-position="left"]){left:max(var(--offset),env(safe-area-inset-left))}:where([data-sonner-toaster][data-x-position="center"]){left:50%;transform:translate(-50%)}:where([data-sonner-toaster][data-y-position="top"]){top:max(var(--offset),env(safe-area-inset-top))}:where([data-sonner-toaster][data-y-position="bottom"]){bottom:max(var(--offset),env(safe-area-inset-bottom))}:where([data-sonner-toast]){--y: translateY(100%);--lift-amount: calc(var(--lift) * var(--gap));z-index:var(--z-index);position:absolute;opacity:0;transform:var(--y);filter:blur(0);touch-action:none;transition:transform .4s,opacity .4s,height .4s,box-shadow .2s;box-sizing:border-box;outline:none;overflow-wrap:anywhere}:where([data-sonner-toast][data-styled="true"]){padding:16px;background:var(--normal-bg);border:1px solid var(--normal-border);color:var(--normal-text);border-radius:var(--border-radius);box-shadow:0 4px 12px #0000001a;width:var(--width);font-size:13px;display:flex;align-items:center;gap:6px}:where([data-sonner-toast]:focus-visible){box-shadow:0 4px 12px #0000001a,0 0 0 2px #0003}:where([data-sonner-toast][data-y-position="top"]){top:0;--y: translateY(-100%);--lift: 1;--lift-amount: calc(1 * var(--gap))}:where([data-sonner-toast][data-y-position="bottom"]){bottom:0;--y: translateY(100%);--lift: -1;--lift-amount: calc(var(--lift) * var(--gap))}:where([data-sonner-toast]) :where([data-description]){font-weight:400;line-height:1.4;color:inherit}:where([data-sonner-toast]) :where([data-title]){font-weight:500;line-height:1.5;color:inherit}:where([data-sonner-toast]) :where([data-icon]){display:flex;height:16px;width:16px;position:relative;justify-content:flex-start;align-items:center;flex-shrink:0;margin-left:var(--toast-icon-margin-start);margin-right:var(--toast-icon-margin-end)}:where([data-sonner-toast][data-promise="true"]) :where([data-icon])>svg{opacity:0;transform:scale(.8);transform-origin:center;animation:sonner-fade-in .3s ease forwards}:where([data-sonner-toast]) :where([data-icon])>*{flex-shrink:0}:where([data-sonner-toast]) :where([data-icon]) svg{margin-left:var(--toast-svg-margin-start);margin-right:var(--toast-svg-margin-end)}:where([data-sonner-toast]) :where([data-content]){display:flex;flex-direction:column;gap:2px}[data-sonner-toast][data-styled=true] [data-button]{border-radius:4px;padding-left:8px;padding-right:8px;height:24px;font-size:12px;color:var(--normal-bg);background:var(--normal-text);margin-left:var(--toast-button-margin-start);margin-right:var(--toast-button-margin-end);border:none;cursor:pointer;outline:none;display:flex;align-items:center;flex-shrink:0;transition:opacity .4s,box-shadow .2s}:where([data-sonner-toast]) :where([data-button]):focus-visible{box-shadow:0 0 0 2px #0006}:where([data-sonner-toast]) :where([data-button]):first-of-type{margin-left:var(--toast-button-margin-start);margin-right:var(--toast-button-margin-end)}:where([data-sonner-toast]) :where([data-cancel]){color:var(--normal-text);background:rgba(0,0,0,.08)}:where([data-sonner-toast][data-theme="dark"]) :where([data-cancel]){background:rgba(255,255,255,.3)}:where([data-sonner-toast]) :where([data-close-button]){position:absolute;left:var(--toast-close-button-start);right:var(--toast-close-button-end);top:0;height:20px;width:20px;display:flex;justify-content:center;align-items:center;padding:0;background:var(--gray1);color:var(--gray12);border:1px solid var(--gray4);transform:var(--toast-close-button-transform);border-radius:50%;cursor:pointer;z-index:1;transition:opacity .1s,background .2s,border-color .2s}:where([data-sonner-toast]) :where([data-close-button]):focus-visible{box-shadow:0 4px 12px #0000001a,0 0 0 2px #0003}:where([data-sonner-toast]) :where([data-disabled="true"]){cursor:not-allowed}:where([data-sonner-toast]):hover :where([data-close-button]):hover{background:var(--gray2);border-color:var(--gray5)}:where([data-sonner-toast][data-swiping="true"]):before{content:"";position:absolute;left:0;right:0;height:100%;z-index:-1}:where([data-sonner-toast][data-y-position="top"][data-swiping="true"]):before{bottom:50%;transform:scaleY(3) translateY(50%)}:where([data-sonner-toast][data-y-position="bottom"][data-swiping="true"]):before{top:50%;transform:scaleY(3) translateY(-50%)}:where([data-sonner-toast][data-swiping="false"][data-removed="true"]):before{content:"";position:absolute;inset:0;transform:scaleY(2)}:where([data-sonner-toast]):after{content:"";position:absolute;left:0;height:calc(var(--gap) + 1px);bottom:100%;width:100%}:where([data-sonner-toast][data-mounted="true"]){--y: translateY(0);opacity:1}:where([data-sonner-toast][data-expanded="false"][data-front="false"]){--scale: var(--toasts-before) * .05 + 1;--y: translateY(calc(var(--lift-amount) * var(--toasts-before))) scale(calc(-1 * var(--scale)));height:var(--front-toast-height)}:where([data-sonner-toast])>*{transition:opacity .4s}:where([data-sonner-toast][data-expanded="false"][data-front="false"][data-styled="true"])>*{opacity:0}:where([data-sonner-toast][data-visible="false"]){opacity:0;pointer-events:none}:where([data-sonner-toast][data-mounted="true"][data-expanded="true"]){--y: translateY(calc(var(--lift) * var(--offset)));height:var(--initial-height)}:where([data-sonner-toast][data-removed="true"][data-front="true"][data-swipe-out="false"]){--y: translateY(calc(var(--lift) * -100%));opacity:0}:where([data-sonner-toast][data-removed="true"][data-front="false"][data-swipe-out="false"][data-expanded="true"]){--y: translateY(calc(var(--lift) * var(--offset) + var(--lift) * -100%));opacity:0}:where([data-sonner-toast][data-removed="true"][data-front="false"][data-swipe-out="false"][data-expanded="false"]){--y: translateY(40%);opacity:0;transition:transform .5s,opacity .2s}:where([data-sonner-toast][data-removed="true"][data-front="false"]):before{height:calc(var(--initial-height) + 20%)}[data-sonner-toast][data-swiping=true]{transform:var(--y) translateY(var(--swipe-amount, 0px));transition:none}[data-sonner-toast][data-swipe-out=true][data-y-position=bottom],[data-sonner-toast][data-swipe-out=true][data-y-position=top]{animation:swipe-out .2s ease-out forwards}@keyframes swipe-out{0%{transform:translateY(calc(var(--lift) * var(--offset) + var(--swipe-amount)));opacity:1}to{transform:translateY(calc(var(--lift) * var(--offset) + var(--swipe-amount) + var(--lift) * -100%));opacity:0}}@media (max-width: 600px){[data-sonner-toaster]{position:fixed;--mobile-offset: 16px;right:var(--mobile-offset);left:var(--mobile-offset);width:100%}[data-sonner-toaster] [data-sonner-toast]{left:0;right:0;width:calc(100% - var(--mobile-offset) * 2)}[data-sonner-toaster][data-x-position=left]{left:var(--mobile-offset)}[data-sonner-toaster][data-y-position=bottom]{bottom:20px}[data-sonner-toaster][data-y-position=top]{top:20px}[data-sonner-toaster][data-x-position=center]{left:var(--mobile-offset);right:var(--mobile-offset);transform:none}}[data-sonner-toaster][data-theme=light]{--normal-bg: #fff;--normal-border: var(--gray4);--normal-text: var(--gray12);--success-bg: hsl(143, 85%, 96%);--success-border: hsl(145, 92%, 91%);--success-text: hsl(140, 100%, 27%);--info-bg: hsl(208, 100%, 97%);--info-border: hsl(221, 91%, 91%);--info-text: hsl(210, 92%, 45%);--warning-bg: hsl(49, 100%, 97%);--warning-border: hsl(49, 91%, 91%);--warning-text: hsl(31, 92%, 45%);--error-bg: hsl(359, 100%, 97%);--error-border: hsl(359, 100%, 94%);--error-text: hsl(360, 100%, 45%)}[data-sonner-toaster][data-theme=light] [data-sonner-toast][data-invert=true]{--normal-bg: #000;--normal-border: hsl(0, 0%, 20%);--normal-text: var(--gray1)}[data-sonner-toaster][data-theme=dark] [data-sonner-toast][data-invert=true]{--normal-bg: #fff;--normal-border: var(--gray3);--normal-text: var(--gray12)}[data-sonner-toaster][data-theme=dark]{--normal-bg: #000;--normal-border: hsl(0, 0%, 20%);--normal-text: var(--gray1);--success-bg: hsl(150, 100%, 6%);--success-border: hsl(147, 100%, 12%);--success-text: hsl(150, 86%, 65%);--info-bg: hsl(215, 100%, 6%);--info-border: hsl(223, 100%, 12%);--info-text: hsl(216, 87%, 65%);--warning-bg: hsl(64, 100%, 6%);--warning-border: hsl(60, 100%, 12%);--warning-text: hsl(46, 87%, 65%);--error-bg: hsl(358, 76%, 10%);--error-border: hsl(357, 89%, 16%);--error-text: hsl(358, 100%, 81%)}[data-rich-colors=true][data-sonner-toast][data-type=success],[data-rich-colors=true][data-sonner-toast][data-type=success] [data-close-button]{background:var(--success-bg);border-color:var(--success-border);color:var(--success-text)}[data-rich-colors=true][data-sonner-toast][data-type=info],[data-rich-colors=true][data-sonner-toast][data-type=info] [data-close-button]{background:var(--info-bg);border-color:var(--info-border);color:var(--info-text)}[data-rich-colors=true][data-sonner-toast][data-type=warning],[data-rich-colors=true][data-sonner-toast][data-type=warning] [data-close-button]{background:var(--warning-bg);border-color:var(--warning-border);color:var(--warning-text)}[data-rich-colors=true][data-sonner-toast][data-type=error],[data-rich-colors=true][data-sonner-toast][data-type=error] [data-close-button]{background:var(--error-bg);border-color:var(--error-border);color:var(--error-text)}.sonner-loading-wrapper{--size: 16px;height:var(--size);width:var(--size);position:absolute;inset:0;z-index:10}.sonner-loading-wrapper[data-visible=false]{transform-origin:center;animation:sonner-fade-out .2s ease forwards}.sonner-spinner{position:relative;top:50%;left:50%;height:var(--size);width:var(--size)}.sonner-loading-bar{animation:sonner-spin 1.2s linear infinite;background:var(--gray11);border-radius:6px;height:8%;left:-10%;position:absolute;top:-3.9%;width:24%}.sonner-loading-bar:nth-child(1){animation-delay:-1.2s;transform:rotate(.0001deg) translate(146%)}.sonner-loading-bar:nth-child(2){animation-delay:-1.1s;transform:rotate(30deg) translate(146%)}.sonner-loading-bar:nth-child(3){animation-delay:-1s;transform:rotate(60deg) translate(146%)}.sonner-loading-bar:nth-child(4){animation-delay:-.9s;transform:rotate(90deg) translate(146%)}.sonner-loading-bar:nth-child(5){animation-delay:-.8s;transform:rotate(120deg) translate(146%)}.sonner-loading-bar:nth-child(6){animation-delay:-.7s;transform:rotate(150deg) translate(146%)}.sonner-loading-bar:nth-child(7){animation-delay:-.6s;transform:rotate(180deg) translate(146%)}.sonner-loading-bar:nth-child(8){animation-delay:-.5s;transform:rotate(210deg) translate(146%)}.sonner-loading-bar:nth-child(9){animation-delay:-.4s;transform:rotate(240deg) translate(146%)}.sonner-loading-bar:nth-child(10){animation-delay:-.3s;transform:rotate(270deg) translate(146%)}.sonner-loading-bar:nth-child(11){animation-delay:-.2s;transform:rotate(300deg) translate(146%)}.sonner-loading-bar:nth-child(12){animation-delay:-.1s;transform:rotate(330deg) translate(146%)}@keyframes sonner-fade-in{0%{opacity:0;transform:scale(.8)}to{opacity:1;transform:scale(1)}}@keyframes sonner-fade-out{0%{opacity:1;transform:scale(1)}to{opacity:0;transform:scale(.8)}}@keyframes sonner-spin{0%{opacity:1}to{opacity:.15}}@media (prefers-reduced-motion){[data-sonner-toast],[data-sonner-toast]>*,.sonner-loading-bar{transition:none!important;animation:none!important}}.sonner-loader{position:absolute;top:50%;left:50%;transform:translate(-50%,-50%);transform-origin:center;transition:opacity .2s,transform .2s}.sonner-loader[data-visible=false]{opacity:0;transform:scale(.8) translate(-50%,-50%)}
`);
function U(s) {
  return s.label !== void 0;
}
var qt = 3, Qt = "32px", Zt = 4e3, te = 356, ee = 14, oe = 20, ae = 200;
function ne(...s) {
  return s.filter(Boolean).join(" ");
}
var se = (s) => {
  var yt, xt, vt, wt, Tt, St, Rt, Et, Nt, Pt;
  let { invert: o, toast: t2, unstyled: n2, interacting: h2, setHeights: u2, visibleToasts: g2, heights: b2, index: d2, toasts: q2, expanded: $, removeToast: V, defaultRichColors: Q, closeButton: i2, style: O, cancelButtonStyle: K2, actionButtonStyle: Z, className: tt = "", descriptionClassName: et = "", duration: X2, position: ot, gap: w2, loadingIcon: j2, expandByDefault: W, classNames: r2, icons: I, closeButtonAriaLabel: at = "Close toast", pauseWhenPageIsHidden: k2, cn: T } = s, [z2, nt] = React.useState(false), [D2, H] = React.useState(false), [st, N2] = React.useState(false), [M2, rt] = React.useState(false), [c2, m2] = React.useState(0), [y2, S] = React.useState(0), A2 = React.useRef(null), l2 = React.useRef(null), _2 = d2 === 0, J = d2 + 1 <= g2, x2 = t2.type, P2 = t2.dismissible !== false, Mt = t2.className || "", At = t2.descriptionClassName || "", G = React.useMemo(() => b2.findIndex((a2) => a2.toastId === t2.id) || 0, [b2, t2.id]), Lt = React.useMemo(() => {
    var a2;
    return (a2 = t2.closeButton) != null ? a2 : i2;
  }, [t2.closeButton, i2]), mt = React.useMemo(() => t2.duration || X2 || Zt, [t2.duration, X2]), it = React.useRef(0), Y = React.useRef(0), pt = React.useRef(0), F = React.useRef(null), [gt, zt] = ot.split("-"), ht = React.useMemo(() => b2.reduce((a2, f2, p2) => p2 >= G ? a2 : a2 + f2.height, 0), [b2, G]), bt = Dt(), jt = t2.invert || o, lt = x2 === "loading";
  Y.current = React.useMemo(() => G * w2 + ht, [G, ht]), React.useEffect(() => {
    nt(true);
  }, []), React.useLayoutEffect(() => {
    if (!z2) return;
    let a2 = l2.current, f2 = a2.style.height;
    a2.style.height = "auto";
    let p2 = a2.getBoundingClientRect().height;
    a2.style.height = f2, S(p2), u2((B2) => B2.find((R2) => R2.toastId === t2.id) ? B2.map((R2) => R2.toastId === t2.id ? { ...R2, height: p2 } : R2) : [{ toastId: t2.id, height: p2, position: t2.position }, ...B2]);
  }, [z2, t2.title, t2.description, u2, t2.id]);
  let L2 = React.useCallback(() => {
    H(true), m2(Y.current), u2((a2) => a2.filter((f2) => f2.toastId !== t2.id)), setTimeout(() => {
      V(t2);
    }, ae);
  }, [t2, V, u2, Y]);
  React.useEffect(() => {
    if (t2.promise && x2 === "loading" || t2.duration === 1 / 0 || t2.type === "loading") return;
    let a2, f2 = mt;
    return $ || h2 || k2 && bt ? (() => {
      if (pt.current < it.current) {
        let C = (/* @__PURE__ */ new Date()).getTime() - it.current;
        f2 = f2 - C;
      }
      pt.current = (/* @__PURE__ */ new Date()).getTime();
    })() : (() => {
      f2 !== 1 / 0 && (it.current = (/* @__PURE__ */ new Date()).getTime(), a2 = setTimeout(() => {
        var C;
        (C = t2.onAutoClose) == null || C.call(t2, t2), L2();
      }, f2));
    })(), () => clearTimeout(a2);
  }, [$, h2, W, t2, mt, L2, t2.promise, x2, k2, bt]), React.useEffect(() => {
    let a2 = l2.current;
    if (a2) {
      let f2 = a2.getBoundingClientRect().height;
      return S(f2), u2((p2) => [{ toastId: t2.id, height: f2, position: t2.position }, ...p2]), () => u2((p2) => p2.filter((B2) => B2.toastId !== t2.id));
    }
  }, [u2, t2.id]), React.useEffect(() => {
    t2.delete && L2();
  }, [L2, t2.delete]);
  function Yt() {
    return I != null && I.loading ? React.createElement("div", { className: "sonner-loader", "data-visible": x2 === "loading" }, I.loading) : j2 ? React.createElement("div", { className: "sonner-loader", "data-visible": x2 === "loading" }, j2) : React.createElement(It, { visible: x2 === "loading" });
  }
  return React.createElement("li", { "aria-live": t2.important ? "assertive" : "polite", "aria-atomic": "true", role: "status", tabIndex: 0, ref: l2, className: T(tt, Mt, r2 == null ? void 0 : r2.toast, (yt = t2 == null ? void 0 : t2.classNames) == null ? void 0 : yt.toast, r2 == null ? void 0 : r2.default, r2 == null ? void 0 : r2[x2], (xt = t2 == null ? void 0 : t2.classNames) == null ? void 0 : xt[x2]), "data-sonner-toast": "", "data-rich-colors": (vt = t2.richColors) != null ? vt : Q, "data-styled": !(t2.jsx || t2.unstyled || n2), "data-mounted": z2, "data-promise": !!t2.promise, "data-removed": D2, "data-visible": J, "data-y-position": gt, "data-x-position": zt, "data-index": d2, "data-front": _2, "data-swiping": st, "data-dismissible": P2, "data-type": x2, "data-invert": jt, "data-swipe-out": M2, "data-expanded": !!($ || W && z2), style: { "--index": d2, "--toasts-before": d2, "--z-index": q2.length - d2, "--offset": `${D2 ? c2 : Y.current}px`, "--initial-height": W ? "auto" : `${y2}px`, ...O, ...t2.style }, onPointerDown: (a2) => {
    lt || !P2 || (A2.current = /* @__PURE__ */ new Date(), m2(Y.current), a2.target.setPointerCapture(a2.pointerId), a2.target.tagName !== "BUTTON" && (N2(true), F.current = { x: a2.clientX, y: a2.clientY }));
  }, onPointerUp: () => {
    var B2, C, R2, dt;
    if (M2 || !P2) return;
    F.current = null;
    let a2 = Number(((B2 = l2.current) == null ? void 0 : B2.style.getPropertyValue("--swipe-amount").replace("px", "")) || 0), f2 = (/* @__PURE__ */ new Date()).getTime() - ((C = A2.current) == null ? void 0 : C.getTime()), p2 = Math.abs(a2) / f2;
    if (Math.abs(a2) >= oe || p2 > 0.11) {
      m2(Y.current), (R2 = t2.onDismiss) == null || R2.call(t2, t2), L2(), rt(true);
      return;
    }
    (dt = l2.current) == null || dt.style.setProperty("--swipe-amount", "0px"), N2(false);
  }, onPointerMove: (a2) => {
    var Bt;
    if (!F.current || !P2) return;
    let f2 = a2.clientY - F.current.y, p2 = a2.clientX - F.current.x, C = (gt === "top" ? Math.min : Math.max)(0, f2), R2 = a2.pointerType === "touch" ? 10 : 2;
    Math.abs(C) > R2 ? (Bt = l2.current) == null || Bt.style.setProperty("--swipe-amount", `${f2}px`) : Math.abs(p2) > R2 && (F.current = null);
  } }, Lt && !t2.jsx ? React.createElement("button", { "aria-label": at, "data-disabled": lt, "data-close-button": true, onClick: lt || !P2 ? () => {
  } : () => {
    var a2;
    L2(), (a2 = t2.onDismiss) == null || a2.call(t2, t2);
  }, className: T(r2 == null ? void 0 : r2.closeButton, (wt = t2 == null ? void 0 : t2.classNames) == null ? void 0 : wt.closeButton) }, React.createElement("svg", { xmlns: "http://www.w3.org/2000/svg", width: "12", height: "12", viewBox: "0 0 24 24", fill: "none", stroke: "currentColor", strokeWidth: "1.5", strokeLinecap: "round", strokeLinejoin: "round" }, React.createElement("line", { x1: "18", y1: "6", x2: "6", y2: "18" }), React.createElement("line", { x1: "6", y1: "6", x2: "18", y2: "18" }))) : null, t2.jsx || React.isValidElement(t2.title) ? t2.jsx || t2.title : React.createElement(React.Fragment, null, x2 || t2.icon || t2.promise ? React.createElement("div", { "data-icon": "", className: T(r2 == null ? void 0 : r2.icon, (Tt = t2 == null ? void 0 : t2.classNames) == null ? void 0 : Tt.icon) }, t2.promise || t2.type === "loading" && !t2.icon ? t2.icon || Yt() : null, t2.type !== "loading" ? t2.icon || (I == null ? void 0 : I[x2]) || Ct(x2) : null) : null, React.createElement("div", { "data-content": "", className: T(r2 == null ? void 0 : r2.content, (St = t2 == null ? void 0 : t2.classNames) == null ? void 0 : St.content) }, React.createElement("div", { "data-title": "", className: T(r2 == null ? void 0 : r2.title, (Rt = t2 == null ? void 0 : t2.classNames) == null ? void 0 : Rt.title) }, t2.title), t2.description ? React.createElement("div", { "data-description": "", className: T(et, At, r2 == null ? void 0 : r2.description, (Et = t2 == null ? void 0 : t2.classNames) == null ? void 0 : Et.description) }, t2.description) : null), React.isValidElement(t2.cancel) ? t2.cancel : t2.cancel && U(t2.cancel) ? React.createElement("button", { "data-button": true, "data-cancel": true, style: t2.cancelButtonStyle || K2, onClick: (a2) => {
    var f2, p2;
    U(t2.cancel) && P2 && ((p2 = (f2 = t2.cancel).onClick) == null || p2.call(f2, a2), L2());
  }, className: T(r2 == null ? void 0 : r2.cancelButton, (Nt = t2 == null ? void 0 : t2.classNames) == null ? void 0 : Nt.cancelButton) }, t2.cancel.label) : null, React.isValidElement(t2.action) ? t2.action : t2.action && U(t2.action) ? React.createElement("button", { "data-button": true, "data-action": true, style: t2.actionButtonStyle || Z, onClick: (a2) => {
    var f2, p2;
    U(t2.action) && (a2.defaultPrevented || ((p2 = (f2 = t2.action).onClick) == null || p2.call(f2, a2), L2()));
  }, className: T(r2 == null ? void 0 : r2.actionButton, (Pt = t2 == null ? void 0 : t2.classNames) == null ? void 0 : Pt.actionButton) }, t2.action.label) : null));
};
function Ht() {
  if (typeof window == "undefined" || typeof document == "undefined") return "ltr";
  let s = document.documentElement.getAttribute("dir");
  return s === "auto" || !s ? window.getComputedStyle(document.documentElement).direction : s;
}
var Te = (s) => {
  let { invert: o, position: t2 = "bottom-right", hotkey: n2 = ["altKey", "KeyT"], expand: h2, closeButton: u2, className: g2, offset: b2, theme: d2 = "light", richColors: q2, duration: $, style: V, visibleToasts: Q = qt, toastOptions: i2, dir: O = Ht(), gap: K2 = ee, loadingIcon: Z, icons: tt, containerAriaLabel: et = "Notifications", pauseWhenPageIsHidden: X2, cn: ot = ne } = s, [w2, j2] = React.useState([]), W = React.useMemo(() => Array.from(new Set([t2].concat(w2.filter((c2) => c2.position).map((c2) => c2.position)))), [w2, t2]), [r2, I] = React.useState([]), [at, k2] = React.useState(false), [T, z2] = React.useState(false), [nt, D2] = React.useState(d2 !== "system" ? d2 : typeof window != "undefined" && window.matchMedia && window.matchMedia("(prefers-color-scheme: dark)").matches ? "dark" : "light"), H = React.useRef(null), st = n2.join("+").replace(/Key/g, "").replace(/Digit/g, ""), N2 = React.useRef(null), M2 = React.useRef(false), rt = React.useCallback((c2) => {
    var m2;
    (m2 = w2.find((y2) => y2.id === c2.id)) != null && m2.delete || v$1.dismiss(c2.id), j2((y2) => y2.filter(({ id: S }) => S !== c2.id));
  }, [w2]);
  return React.useEffect(() => v$1.subscribe((c2) => {
    if (c2.dismiss) {
      j2((m2) => m2.map((y2) => y2.id === c2.id ? { ...y2, delete: true } : y2));
      return;
    }
    setTimeout(() => {
      ReactDOM.flushSync(() => {
        j2((m2) => {
          let y2 = m2.findIndex((S) => S.id === c2.id);
          return y2 !== -1 ? [...m2.slice(0, y2), { ...m2[y2], ...c2 }, ...m2.slice(y2 + 1)] : [c2, ...m2];
        });
      });
    });
  }), []), React.useEffect(() => {
    if (d2 !== "system") {
      D2(d2);
      return;
    }
    d2 === "system" && (window.matchMedia && window.matchMedia("(prefers-color-scheme: dark)").matches ? D2("dark") : D2("light")), typeof window != "undefined" && window.matchMedia("(prefers-color-scheme: dark)").addEventListener("change", ({ matches: c2 }) => {
      D2(c2 ? "dark" : "light");
    });
  }, [d2]), React.useEffect(() => {
    w2.length <= 1 && k2(false);
  }, [w2]), React.useEffect(() => {
    let c2 = (m2) => {
      var S, A2;
      n2.every((l2) => m2[l2] || m2.code === l2) && (k2(true), (S = H.current) == null || S.focus()), m2.code === "Escape" && (document.activeElement === H.current || (A2 = H.current) != null && A2.contains(document.activeElement)) && k2(false);
    };
    return document.addEventListener("keydown", c2), () => document.removeEventListener("keydown", c2);
  }, [n2]), React.useEffect(() => {
    if (H.current) return () => {
      N2.current && (N2.current.focus({ preventScroll: true }), N2.current = null, M2.current = false);
    };
  }, [H.current]), w2.length ? React.createElement("section", { "aria-label": `${et} ${st}`, tabIndex: -1 }, W.map((c2, m2) => {
    var A2;
    let [y2, S] = c2.split("-");
    return React.createElement("ol", { key: c2, dir: O === "auto" ? Ht() : O, tabIndex: -1, ref: H, className: g2, "data-sonner-toaster": true, "data-theme": nt, "data-y-position": y2, "data-x-position": S, style: { "--front-toast-height": `${((A2 = r2[0]) == null ? void 0 : A2.height) || 0}px`, "--offset": typeof b2 == "number" ? `${b2}px` : b2 || Qt, "--width": `${te}px`, "--gap": `${K2}px`, ...V }, onBlur: (l2) => {
      M2.current && !l2.currentTarget.contains(l2.relatedTarget) && (M2.current = false, N2.current && (N2.current.focus({ preventScroll: true }), N2.current = null));
    }, onFocus: (l2) => {
      l2.target instanceof HTMLElement && l2.target.dataset.dismissible === "false" || M2.current || (M2.current = true, N2.current = l2.relatedTarget);
    }, onMouseEnter: () => k2(true), onMouseMove: () => k2(true), onMouseLeave: () => {
      T || k2(false);
    }, onPointerDown: (l2) => {
      l2.target instanceof HTMLElement && l2.target.dataset.dismissible === "false" || z2(true);
    }, onPointerUp: () => z2(false) }, w2.filter((l2) => !l2.position && m2 === 0 || l2.position === c2).map((l2, _2) => {
      var J, x2;
      return React.createElement(se, { key: l2.id, icons: tt, index: _2, toast: l2, defaultRichColors: q2, duration: (J = i2 == null ? void 0 : i2.duration) != null ? J : $, className: i2 == null ? void 0 : i2.className, descriptionClassName: i2 == null ? void 0 : i2.descriptionClassName, invert: o, visibleToasts: Q, closeButton: (x2 = i2 == null ? void 0 : i2.closeButton) != null ? x2 : u2, interacting: T, position: c2, style: i2 == null ? void 0 : i2.style, unstyled: i2 == null ? void 0 : i2.unstyled, classNames: i2 == null ? void 0 : i2.classNames, cancelButtonStyle: i2 == null ? void 0 : i2.cancelButtonStyle, actionButtonStyle: i2 == null ? void 0 : i2.actionButtonStyle, removeToast: rt, toasts: w2.filter((P2) => P2.position == l2.position), heights: r2.filter((P2) => P2.position == l2.position), setHeights: I, expandByDefault: h2, gap: K2, loadingIcon: Z, expanded: at, pauseWhenPageIsHidden: X2, cn: ot });
    }));
  })) : null;
};
const Toaster = ({ ...props }) => {
  const { theme = "system" } = j();
  return /* @__PURE__ */ jsxRuntimeExports.jsx(
    Te,
    {
      theme,
      className: "toaster group",
      toastOptions: {
        classNames: {
          toast: "group toast group-[.toaster]:bg-background group-[.toaster]:text-foreground group-[.toaster]:border-border group-[.toaster]:shadow-lg",
          description: "group-[.toast]:text-muted-foreground",
          actionButton: "group-[.toast]:bg-primary group-[.toast]:text-primary-foreground",
          cancelButton: "group-[.toast]:bg-muted group-[.toast]:text-muted-foreground"
        }
      },
      ...props
    }
  );
};
function composeEventHandlers(originalEventHandler, ourEventHandler, { checkForDefaultPrevented = true } = {}) {
  return function handleEvent(event) {
    originalEventHandler?.(event);
    if (checkForDefaultPrevented === false || !event.defaultPrevented) {
      return ourEventHandler?.(event);
    }
  };
}
function setRef(ref, value) {
  if (typeof ref === "function") {
    ref(value);
  } else if (ref !== null && ref !== void 0) {
    ref.current = value;
  }
}
function composeRefs(...refs) {
  return (node2) => refs.forEach((ref) => setRef(ref, node2));
}
function useComposedRefs(...refs) {
  return reactExports.useCallback(composeRefs(...refs), refs);
}
function createContext2(rootComponentName, defaultContext2) {
  const Context = reactExports.createContext(defaultContext2);
  const Provider2 = (props) => {
    const { children, ...context } = props;
    const value = reactExports.useMemo(() => context, Object.values(context));
    return /* @__PURE__ */ jsxRuntimeExports.jsx(Context.Provider, { value, children });
  };
  Provider2.displayName = rootComponentName + "Provider";
  function useContext2(consumerName) {
    const context = reactExports.useContext(Context);
    if (context) return context;
    if (defaultContext2 !== void 0) return defaultContext2;
    throw new Error(`\`${consumerName}\` must be used within \`${rootComponentName}\``);
  }
  return [Provider2, useContext2];
}
function createContextScope$3(scopeName, createContextScopeDeps = []) {
  let defaultContexts = [];
  function createContext3(rootComponentName, defaultContext2) {
    const BaseContext = reactExports.createContext(defaultContext2);
    const index2 = defaultContexts.length;
    defaultContexts = [...defaultContexts, defaultContext2];
    const Provider2 = (props) => {
      const { scope, children, ...context } = props;
      const Context = scope?.[scopeName]?.[index2] || BaseContext;
      const value = reactExports.useMemo(() => context, Object.values(context));
      return /* @__PURE__ */ jsxRuntimeExports.jsx(Context.Provider, { value, children });
    };
    Provider2.displayName = rootComponentName + "Provider";
    function useContext2(consumerName, scope) {
      const Context = scope?.[scopeName]?.[index2] || BaseContext;
      const context = reactExports.useContext(Context);
      if (context) return context;
      if (defaultContext2 !== void 0) return defaultContext2;
      throw new Error(`\`${consumerName}\` must be used within \`${rootComponentName}\``);
    }
    return [Provider2, useContext2];
  }
  const createScope = () => {
    const scopeContexts = defaultContexts.map((defaultContext2) => {
      return reactExports.createContext(defaultContext2);
    });
    return function useScope(scope) {
      const contexts = scope?.[scopeName] || scopeContexts;
      return reactExports.useMemo(
        () => ({ [`__scope${scopeName}`]: { ...scope, [scopeName]: contexts } }),
        [scope, contexts]
      );
    };
  };
  createScope.scopeName = scopeName;
  return [createContext3, composeContextScopes$3(createScope, ...createContextScopeDeps)];
}
function composeContextScopes$3(...scopes) {
  const baseScope = scopes[0];
  if (scopes.length === 1) return baseScope;
  const createScope = () => {
    const scopeHooks = scopes.map((createScope2) => ({
      useScope: createScope2(),
      scopeName: createScope2.scopeName
    }));
    return function useComposedScopes(overrideScopes) {
      const nextScopes = scopeHooks.reduce((nextScopes2, { useScope, scopeName }) => {
        const scopeProps = useScope(overrideScopes);
        const currentScope = scopeProps[`__scope${scopeName}`];
        return { ...nextScopes2, ...currentScope };
      }, {});
      return reactExports.useMemo(() => ({ [`__scope${baseScope.scopeName}`]: nextScopes }), [nextScopes]);
    };
  };
  createScope.scopeName = baseScope.scopeName;
  return createScope;
}
var Slot = reactExports.forwardRef((props, forwardedRef) => {
  const { children, ...slotProps } = props;
  const childrenArray = reactExports.Children.toArray(children);
  const slottable = childrenArray.find(isSlottable);
  if (slottable) {
    const newElement = slottable.props.children;
    const newChildren = childrenArray.map((child) => {
      if (child === slottable) {
        if (reactExports.Children.count(newElement) > 1) return reactExports.Children.only(null);
        return reactExports.isValidElement(newElement) ? newElement.props.children : null;
      } else {
        return child;
      }
    });
    return /* @__PURE__ */ jsxRuntimeExports.jsx(SlotClone, { ...slotProps, ref: forwardedRef, children: reactExports.isValidElement(newElement) ? reactExports.cloneElement(newElement, void 0, newChildren) : null });
  }
  return /* @__PURE__ */ jsxRuntimeExports.jsx(SlotClone, { ...slotProps, ref: forwardedRef, children });
});
Slot.displayName = "Slot";
var SlotClone = reactExports.forwardRef((props, forwardedRef) => {
  const { children, ...slotProps } = props;
  if (reactExports.isValidElement(children)) {
    const childrenRef = getElementRef$1(children);
    return reactExports.cloneElement(children, {
      ...mergeProps(slotProps, children.props),
      // @ts-ignore
      ref: forwardedRef ? composeRefs(forwardedRef, childrenRef) : childrenRef
    });
  }
  return reactExports.Children.count(children) > 1 ? reactExports.Children.only(null) : null;
});
SlotClone.displayName = "SlotClone";
var Slottable = ({ children }) => {
  return /* @__PURE__ */ jsxRuntimeExports.jsx(jsxRuntimeExports.Fragment, { children });
};
function isSlottable(child) {
  return reactExports.isValidElement(child) && child.type === Slottable;
}
function mergeProps(slotProps, childProps) {
  const overrideProps = { ...childProps };
  for (const propName in childProps) {
    const slotPropValue = slotProps[propName];
    const childPropValue = childProps[propName];
    const isHandler = /^on[A-Z]/.test(propName);
    if (isHandler) {
      if (slotPropValue && childPropValue) {
        overrideProps[propName] = (...args) => {
          childPropValue(...args);
          slotPropValue(...args);
        };
      } else if (slotPropValue) {
        overrideProps[propName] = slotPropValue;
      }
    } else if (propName === "style") {
      overrideProps[propName] = { ...slotPropValue, ...childPropValue };
    } else if (propName === "className") {
      overrideProps[propName] = [slotPropValue, childPropValue].filter(Boolean).join(" ");
    }
  }
  return { ...slotProps, ...overrideProps };
}
function getElementRef$1(element) {
  let getter = Object.getOwnPropertyDescriptor(element.props, "ref")?.get;
  let mayWarn = getter && "isReactWarning" in getter && getter.isReactWarning;
  if (mayWarn) {
    return element.ref;
  }
  getter = Object.getOwnPropertyDescriptor(element, "ref")?.get;
  mayWarn = getter && "isReactWarning" in getter && getter.isReactWarning;
  if (mayWarn) {
    return element.props.ref;
  }
  return element.props.ref || element.ref;
}
var NODES = [
  "a",
  "button",
  "div",
  "form",
  "h2",
  "h3",
  "img",
  "input",
  "label",
  "li",
  "nav",
  "ol",
  "p",
  "span",
  "svg",
  "ul"
];
var Primitive = NODES.reduce((primitive, node2) => {
  const Node2 = reactExports.forwardRef((props, forwardedRef) => {
    const { asChild, ...primitiveProps } = props;
    const Comp = asChild ? Slot : node2;
    if (typeof window !== "undefined") {
      window[Symbol.for("radix-ui")] = true;
    }
    return /* @__PURE__ */ jsxRuntimeExports.jsx(Comp, { ...primitiveProps, ref: forwardedRef });
  });
  Node2.displayName = `Primitive.${node2}`;
  return { ...primitive, [node2]: Node2 };
}, {});
function dispatchDiscreteCustomEvent(target, event) {
  if (target) reactDomExports.flushSync(() => target.dispatchEvent(event));
}
function useCallbackRef$1(callback) {
  const callbackRef = reactExports.useRef(callback);
  reactExports.useEffect(() => {
    callbackRef.current = callback;
  });
  return reactExports.useMemo(() => (...args) => callbackRef.current?.(...args), []);
}
function useEscapeKeydown(onEscapeKeyDownProp, ownerDocument2 = globalThis?.document) {
  const onEscapeKeyDown = useCallbackRef$1(onEscapeKeyDownProp);
  reactExports.useEffect(() => {
    const handleKeyDown = (event) => {
      if (event.key === "Escape") {
        onEscapeKeyDown(event);
      }
    };
    ownerDocument2.addEventListener("keydown", handleKeyDown, { capture: true });
    return () => ownerDocument2.removeEventListener("keydown", handleKeyDown, { capture: true });
  }, [onEscapeKeyDown, ownerDocument2]);
}
var DISMISSABLE_LAYER_NAME = "DismissableLayer";
var CONTEXT_UPDATE = "dismissableLayer.update";
var POINTER_DOWN_OUTSIDE = "dismissableLayer.pointerDownOutside";
var FOCUS_OUTSIDE = "dismissableLayer.focusOutside";
var originalBodyPointerEvents;
var DismissableLayerContext = reactExports.createContext({
  layers: /* @__PURE__ */ new Set(),
  layersWithOutsidePointerEventsDisabled: /* @__PURE__ */ new Set(),
  branches: /* @__PURE__ */ new Set()
});
var DismissableLayer = reactExports.forwardRef(
  (props, forwardedRef) => {
    const {
      disableOutsidePointerEvents = false,
      onEscapeKeyDown,
      onPointerDownOutside,
      onFocusOutside,
      onInteractOutside,
      onDismiss,
      ...layerProps
    } = props;
    const context = reactExports.useContext(DismissableLayerContext);
    const [node2, setNode] = reactExports.useState(null);
    const ownerDocument2 = node2?.ownerDocument ?? globalThis?.document;
    const [, force] = reactExports.useState({});
    const composedRefs = useComposedRefs(forwardedRef, (node22) => setNode(node22));
    const layers = Array.from(context.layers);
    const [highestLayerWithOutsidePointerEventsDisabled] = [...context.layersWithOutsidePointerEventsDisabled].slice(-1);
    const highestLayerWithOutsidePointerEventsDisabledIndex = layers.indexOf(highestLayerWithOutsidePointerEventsDisabled);
    const index2 = node2 ? layers.indexOf(node2) : -1;
    const isBodyPointerEventsDisabled = context.layersWithOutsidePointerEventsDisabled.size > 0;
    const isPointerEventsEnabled = index2 >= highestLayerWithOutsidePointerEventsDisabledIndex;
    const pointerDownOutside = usePointerDownOutside((event) => {
      const target = event.target;
      const isPointerDownOnBranch = [...context.branches].some((branch) => branch.contains(target));
      if (!isPointerEventsEnabled || isPointerDownOnBranch) return;
      onPointerDownOutside?.(event);
      onInteractOutside?.(event);
      if (!event.defaultPrevented) onDismiss?.();
    }, ownerDocument2);
    const focusOutside = useFocusOutside((event) => {
      const target = event.target;
      const isFocusInBranch = [...context.branches].some((branch) => branch.contains(target));
      if (isFocusInBranch) return;
      onFocusOutside?.(event);
      onInteractOutside?.(event);
      if (!event.defaultPrevented) onDismiss?.();
    }, ownerDocument2);
    useEscapeKeydown((event) => {
      const isHighestLayer = index2 === context.layers.size - 1;
      if (!isHighestLayer) return;
      onEscapeKeyDown?.(event);
      if (!event.defaultPrevented && onDismiss) {
        event.preventDefault();
        onDismiss();
      }
    }, ownerDocument2);
    reactExports.useEffect(() => {
      if (!node2) return;
      if (disableOutsidePointerEvents) {
        if (context.layersWithOutsidePointerEventsDisabled.size === 0) {
          originalBodyPointerEvents = ownerDocument2.body.style.pointerEvents;
          ownerDocument2.body.style.pointerEvents = "none";
        }
        context.layersWithOutsidePointerEventsDisabled.add(node2);
      }
      context.layers.add(node2);
      dispatchUpdate();
      return () => {
        if (disableOutsidePointerEvents && context.layersWithOutsidePointerEventsDisabled.size === 1) {
          ownerDocument2.body.style.pointerEvents = originalBodyPointerEvents;
        }
      };
    }, [node2, ownerDocument2, disableOutsidePointerEvents, context]);
    reactExports.useEffect(() => {
      return () => {
        if (!node2) return;
        context.layers.delete(node2);
        context.layersWithOutsidePointerEventsDisabled.delete(node2);
        dispatchUpdate();
      };
    }, [node2, context]);
    reactExports.useEffect(() => {
      const handleUpdate = () => force({});
      document.addEventListener(CONTEXT_UPDATE, handleUpdate);
      return () => document.removeEventListener(CONTEXT_UPDATE, handleUpdate);
    }, []);
    return /* @__PURE__ */ jsxRuntimeExports.jsx(
      Primitive.div,
      {
        ...layerProps,
        ref: composedRefs,
        style: {
          pointerEvents: isBodyPointerEventsDisabled ? isPointerEventsEnabled ? "auto" : "none" : void 0,
          ...props.style
        },
        onFocusCapture: composeEventHandlers(props.onFocusCapture, focusOutside.onFocusCapture),
        onBlurCapture: composeEventHandlers(props.onBlurCapture, focusOutside.onBlurCapture),
        onPointerDownCapture: composeEventHandlers(
          props.onPointerDownCapture,
          pointerDownOutside.onPointerDownCapture
        )
      }
    );
  }
);
DismissableLayer.displayName = DISMISSABLE_LAYER_NAME;
var BRANCH_NAME = "DismissableLayerBranch";
var DismissableLayerBranch = reactExports.forwardRef((props, forwardedRef) => {
  const context = reactExports.useContext(DismissableLayerContext);
  const ref = reactExports.useRef(null);
  const composedRefs = useComposedRefs(forwardedRef, ref);
  reactExports.useEffect(() => {
    const node2 = ref.current;
    if (node2) {
      context.branches.add(node2);
      return () => {
        context.branches.delete(node2);
      };
    }
  }, [context.branches]);
  return /* @__PURE__ */ jsxRuntimeExports.jsx(Primitive.div, { ...props, ref: composedRefs });
});
DismissableLayerBranch.displayName = BRANCH_NAME;
function usePointerDownOutside(onPointerDownOutside, ownerDocument2 = globalThis?.document) {
  const handlePointerDownOutside = useCallbackRef$1(onPointerDownOutside);
  const isPointerInsideReactTreeRef = reactExports.useRef(false);
  const handleClickRef = reactExports.useRef(() => {
  });
  reactExports.useEffect(() => {
    const handlePointerDown = (event) => {
      if (event.target && !isPointerInsideReactTreeRef.current) {
        let handleAndDispatchPointerDownOutsideEvent2 = function() {
          handleAndDispatchCustomEvent(
            POINTER_DOWN_OUTSIDE,
            handlePointerDownOutside,
            eventDetail,
            { discrete: true }
          );
        };
        const eventDetail = { originalEvent: event };
        if (event.pointerType === "touch") {
          ownerDocument2.removeEventListener("click", handleClickRef.current);
          handleClickRef.current = handleAndDispatchPointerDownOutsideEvent2;
          ownerDocument2.addEventListener("click", handleClickRef.current, { once: true });
        } else {
          handleAndDispatchPointerDownOutsideEvent2();
        }
      } else {
        ownerDocument2.removeEventListener("click", handleClickRef.current);
      }
      isPointerInsideReactTreeRef.current = false;
    };
    const timerId2 = window.setTimeout(() => {
      ownerDocument2.addEventListener("pointerdown", handlePointerDown);
    }, 0);
    return () => {
      window.clearTimeout(timerId2);
      ownerDocument2.removeEventListener("pointerdown", handlePointerDown);
      ownerDocument2.removeEventListener("click", handleClickRef.current);
    };
  }, [ownerDocument2, handlePointerDownOutside]);
  return {
    // ensures we check React component tree (not just DOM tree)
    onPointerDownCapture: () => isPointerInsideReactTreeRef.current = true
  };
}
function useFocusOutside(onFocusOutside, ownerDocument2 = globalThis?.document) {
  const handleFocusOutside = useCallbackRef$1(onFocusOutside);
  const isFocusInsideReactTreeRef = reactExports.useRef(false);
  reactExports.useEffect(() => {
    const handleFocus = (event) => {
      if (event.target && !isFocusInsideReactTreeRef.current) {
        const eventDetail = { originalEvent: event };
        handleAndDispatchCustomEvent(FOCUS_OUTSIDE, handleFocusOutside, eventDetail, {
          discrete: false
        });
      }
    };
    ownerDocument2.addEventListener("focusin", handleFocus);
    return () => ownerDocument2.removeEventListener("focusin", handleFocus);
  }, [ownerDocument2, handleFocusOutside]);
  return {
    onFocusCapture: () => isFocusInsideReactTreeRef.current = true,
    onBlurCapture: () => isFocusInsideReactTreeRef.current = false
  };
}
function dispatchUpdate() {
  const event = new CustomEvent(CONTEXT_UPDATE);
  document.dispatchEvent(event);
}
function handleAndDispatchCustomEvent(name, handler, detail, { discrete }) {
  const target = detail.originalEvent.target;
  const event = new CustomEvent(name, { bubbles: false, cancelable: true, detail });
  if (handler) target.addEventListener(name, handler, { once: true });
  if (discrete) {
    dispatchDiscreteCustomEvent(target, event);
  } else {
    target.dispatchEvent(event);
  }
}
var useLayoutEffect2 = Boolean(globalThis?.document) ? reactExports.useLayoutEffect : () => {
};
var useReactId = React$1["useId".toString()] || (() => void 0);
var count$1 = 0;
function useId$1(deterministicId) {
  const [id2, setId] = reactExports.useState(useReactId());
  useLayoutEffect2(() => {
    if (!deterministicId) setId((reactId) => reactId ?? String(count$1++));
  }, [deterministicId]);
  return deterministicId || (id2 ? `radix-${id2}` : "");
}
const sides = ["top", "right", "bottom", "left"];
const min = Math.min;
const max = Math.max;
const round$2 = Math.round;
const floor$1 = Math.floor;
const createCoords = (v2) => ({
  x: v2,
  y: v2
});
const oppositeSideMap = {
  left: "right",
  right: "left",
  bottom: "top",
  top: "bottom"
};
const oppositeAlignmentMap = {
  start: "end",
  end: "start"
};
function clamp$3(start, value, end) {
  return max(start, min(value, end));
}
function evaluate(value, param) {
  return typeof value === "function" ? value(param) : value;
}
function getSide(placement) {
  return placement.split("-")[0];
}
function getAlignment(placement) {
  return placement.split("-")[1];
}
function getOppositeAxis(axis) {
  return axis === "x" ? "y" : "x";
}
function getAxisLength(axis) {
  return axis === "y" ? "height" : "width";
}
function getSideAxis(placement) {
  return ["top", "bottom"].includes(getSide(placement)) ? "y" : "x";
}
function getAlignmentAxis(placement) {
  return getOppositeAxis(getSideAxis(placement));
}
function getAlignmentSides(placement, rects, rtl) {
  if (rtl === void 0) {
    rtl = false;
  }
  const alignment = getAlignment(placement);
  const alignmentAxis = getAlignmentAxis(placement);
  const length2 = getAxisLength(alignmentAxis);
  let mainAlignmentSide = alignmentAxis === "x" ? alignment === (rtl ? "end" : "start") ? "right" : "left" : alignment === "start" ? "bottom" : "top";
  if (rects.reference[length2] > rects.floating[length2]) {
    mainAlignmentSide = getOppositePlacement(mainAlignmentSide);
  }
  return [mainAlignmentSide, getOppositePlacement(mainAlignmentSide)];
}
function getExpandedPlacements(placement) {
  const oppositePlacement = getOppositePlacement(placement);
  return [getOppositeAlignmentPlacement(placement), oppositePlacement, getOppositeAlignmentPlacement(oppositePlacement)];
}
function getOppositeAlignmentPlacement(placement) {
  return placement.replace(/start|end/g, (alignment) => oppositeAlignmentMap[alignment]);
}
function getSideList(side, isStart, rtl) {
  const lr = ["left", "right"];
  const rl = ["right", "left"];
  const tb = ["top", "bottom"];
  const bt = ["bottom", "top"];
  switch (side) {
    case "top":
    case "bottom":
      if (rtl) return isStart ? rl : lr;
      return isStart ? lr : rl;
    case "left":
    case "right":
      return isStart ? tb : bt;
    default:
      return [];
  }
}
function getOppositeAxisPlacements(placement, flipAlignment, direction, rtl) {
  const alignment = getAlignment(placement);
  let list = getSideList(getSide(placement), direction === "start", rtl);
  if (alignment) {
    list = list.map((side) => side + "-" + alignment);
    if (flipAlignment) {
      list = list.concat(list.map(getOppositeAlignmentPlacement));
    }
  }
  return list;
}
function getOppositePlacement(placement) {
  return placement.replace(/left|right|bottom|top/g, (side) => oppositeSideMap[side]);
}
function expandPaddingObject(padding2) {
  return {
    top: 0,
    right: 0,
    bottom: 0,
    left: 0,
    ...padding2
  };
}
function getPaddingObject(padding2) {
  return typeof padding2 !== "number" ? expandPaddingObject(padding2) : {
    top: padding2,
    right: padding2,
    bottom: padding2,
    left: padding2
  };
}
function rectToClientRect(rect) {
  const {
    x: x2,
    y: y2,
    width: width2,
    height: height2
  } = rect;
  return {
    width: width2,
    height: height2,
    top: y2,
    left: x2,
    right: x2 + width2,
    bottom: y2 + height2,
    x: x2,
    y: y2
  };
}
function computeCoordsFromPlacement(_ref, placement, rtl) {
  let {
    reference,
    floating
  } = _ref;
  const sideAxis = getSideAxis(placement);
  const alignmentAxis = getAlignmentAxis(placement);
  const alignLength = getAxisLength(alignmentAxis);
  const side = getSide(placement);
  const isVertical = sideAxis === "y";
  const commonX = reference.x + reference.width / 2 - floating.width / 2;
  const commonY = reference.y + reference.height / 2 - floating.height / 2;
  const commonAlign = reference[alignLength] / 2 - floating[alignLength] / 2;
  let coords;
  switch (side) {
    case "top":
      coords = {
        x: commonX,
        y: reference.y - floating.height
      };
      break;
    case "bottom":
      coords = {
        x: commonX,
        y: reference.y + reference.height
      };
      break;
    case "right":
      coords = {
        x: reference.x + reference.width,
        y: commonY
      };
      break;
    case "left":
      coords = {
        x: reference.x - floating.width,
        y: commonY
      };
      break;
    default:
      coords = {
        x: reference.x,
        y: reference.y
      };
  }
  switch (getAlignment(placement)) {
    case "start":
      coords[alignmentAxis] -= commonAlign * (rtl && isVertical ? -1 : 1);
      break;
    case "end":
      coords[alignmentAxis] += commonAlign * (rtl && isVertical ? -1 : 1);
      break;
  }
  return coords;
}
const computePosition$1 = async (reference, floating, config2) => {
  const {
    placement = "bottom",
    strategy = "absolute",
    middleware: middleware2 = [],
    platform: platform2
  } = config2;
  const validMiddleware = middleware2.filter(Boolean);
  const rtl = await (platform2.isRTL == null ? void 0 : platform2.isRTL(floating));
  let rects = await platform2.getElementRects({
    reference,
    floating,
    strategy
  });
  let {
    x: x2,
    y: y2
  } = computeCoordsFromPlacement(rects, placement, rtl);
  let statefulPlacement = placement;
  let middlewareData = {};
  let resetCount = 0;
  for (let i2 = 0; i2 < validMiddleware.length; i2++) {
    const {
      name,
      fn
    } = validMiddleware[i2];
    const {
      x: nextX,
      y: nextY,
      data,
      reset
    } = await fn({
      x: x2,
      y: y2,
      initialPlacement: placement,
      placement: statefulPlacement,
      strategy,
      middlewareData,
      rects,
      platform: platform2,
      elements: {
        reference,
        floating
      }
    });
    x2 = nextX != null ? nextX : x2;
    y2 = nextY != null ? nextY : y2;
    middlewareData = {
      ...middlewareData,
      [name]: {
        ...middlewareData[name],
        ...data
      }
    };
    if (reset && resetCount <= 50) {
      resetCount++;
      if (typeof reset === "object") {
        if (reset.placement) {
          statefulPlacement = reset.placement;
        }
        if (reset.rects) {
          rects = reset.rects === true ? await platform2.getElementRects({
            reference,
            floating,
            strategy
          }) : reset.rects;
        }
        ({
          x: x2,
          y: y2
        } = computeCoordsFromPlacement(rects, statefulPlacement, rtl));
      }
      i2 = -1;
    }
  }
  return {
    x: x2,
    y: y2,
    placement: statefulPlacement,
    strategy,
    middlewareData
  };
};
async function detectOverflow(state, options) {
  var _await$platform$isEle;
  if (options === void 0) {
    options = {};
  }
  const {
    x: x2,
    y: y2,
    platform: platform2,
    rects,
    elements,
    strategy
  } = state;
  const {
    boundary = "clippingAncestors",
    rootBoundary = "viewport",
    elementContext = "floating",
    altBoundary = false,
    padding: padding2 = 0
  } = evaluate(options, state);
  const paddingObject = getPaddingObject(padding2);
  const altContext = elementContext === "floating" ? "reference" : "floating";
  const element = elements[altBoundary ? altContext : elementContext];
  const clippingClientRect = rectToClientRect(await platform2.getClippingRect({
    element: ((_await$platform$isEle = await (platform2.isElement == null ? void 0 : platform2.isElement(element))) != null ? _await$platform$isEle : true) ? element : element.contextElement || await (platform2.getDocumentElement == null ? void 0 : platform2.getDocumentElement(elements.floating)),
    boundary,
    rootBoundary,
    strategy
  }));
  const rect = elementContext === "floating" ? {
    x: x2,
    y: y2,
    width: rects.floating.width,
    height: rects.floating.height
  } : rects.reference;
  const offsetParent = await (platform2.getOffsetParent == null ? void 0 : platform2.getOffsetParent(elements.floating));
  const offsetScale = await (platform2.isElement == null ? void 0 : platform2.isElement(offsetParent)) ? await (platform2.getScale == null ? void 0 : platform2.getScale(offsetParent)) || {
    x: 1,
    y: 1
  } : {
    x: 1,
    y: 1
  };
  const elementClientRect = rectToClientRect(platform2.convertOffsetParentRelativeRectToViewportRelativeRect ? await platform2.convertOffsetParentRelativeRectToViewportRelativeRect({
    elements,
    rect,
    offsetParent,
    strategy
  }) : rect);
  return {
    top: (clippingClientRect.top - elementClientRect.top + paddingObject.top) / offsetScale.y,
    bottom: (elementClientRect.bottom - clippingClientRect.bottom + paddingObject.bottom) / offsetScale.y,
    left: (clippingClientRect.left - elementClientRect.left + paddingObject.left) / offsetScale.x,
    right: (elementClientRect.right - clippingClientRect.right + paddingObject.right) / offsetScale.x
  };
}
const arrow$3 = (options) => ({
  name: "arrow",
  options,
  async fn(state) {
    const {
      x: x2,
      y: y2,
      placement,
      rects,
      platform: platform2,
      elements,
      middlewareData
    } = state;
    const {
      element,
      padding: padding2 = 0
    } = evaluate(options, state) || {};
    if (element == null) {
      return {};
    }
    const paddingObject = getPaddingObject(padding2);
    const coords = {
      x: x2,
      y: y2
    };
    const axis = getAlignmentAxis(placement);
    const length2 = getAxisLength(axis);
    const arrowDimensions = await platform2.getDimensions(element);
    const isYAxis = axis === "y";
    const minProp = isYAxis ? "top" : "left";
    const maxProp = isYAxis ? "bottom" : "right";
    const clientProp = isYAxis ? "clientHeight" : "clientWidth";
    const endDiff = rects.reference[length2] + rects.reference[axis] - coords[axis] - rects.floating[length2];
    const startDiff = coords[axis] - rects.reference[axis];
    const arrowOffsetParent = await (platform2.getOffsetParent == null ? void 0 : platform2.getOffsetParent(element));
    let clientSize = arrowOffsetParent ? arrowOffsetParent[clientProp] : 0;
    if (!clientSize || !await (platform2.isElement == null ? void 0 : platform2.isElement(arrowOffsetParent))) {
      clientSize = elements.floating[clientProp] || rects.floating[length2];
    }
    const centerToReference = endDiff / 2 - startDiff / 2;
    const largestPossiblePadding = clientSize / 2 - arrowDimensions[length2] / 2 - 1;
    const minPadding = min(paddingObject[minProp], largestPossiblePadding);
    const maxPadding = min(paddingObject[maxProp], largestPossiblePadding);
    const min$1 = minPadding;
    const max2 = clientSize - arrowDimensions[length2] - maxPadding;
    const center = clientSize / 2 - arrowDimensions[length2] / 2 + centerToReference;
    const offset2 = clamp$3(min$1, center, max2);
    const shouldAddOffset = !middlewareData.arrow && getAlignment(placement) != null && center !== offset2 && rects.reference[length2] / 2 - (center < min$1 ? minPadding : maxPadding) - arrowDimensions[length2] / 2 < 0;
    const alignmentOffset = shouldAddOffset ? center < min$1 ? center - min$1 : center - max2 : 0;
    return {
      [axis]: coords[axis] + alignmentOffset,
      data: {
        [axis]: offset2,
        centerOffset: center - offset2 - alignmentOffset,
        ...shouldAddOffset && {
          alignmentOffset
        }
      },
      reset: shouldAddOffset
    };
  }
});
const flip$2 = function(options) {
  if (options === void 0) {
    options = {};
  }
  return {
    name: "flip",
    options,
    async fn(state) {
      var _middlewareData$arrow, _middlewareData$flip;
      const {
        placement,
        middlewareData,
        rects,
        initialPlacement,
        platform: platform2,
        elements
      } = state;
      const {
        mainAxis: checkMainAxis = true,
        crossAxis: checkCrossAxis = true,
        fallbackPlacements: specifiedFallbackPlacements,
        fallbackStrategy = "bestFit",
        fallbackAxisSideDirection = "none",
        flipAlignment = true,
        ...detectOverflowOptions
      } = evaluate(options, state);
      if ((_middlewareData$arrow = middlewareData.arrow) != null && _middlewareData$arrow.alignmentOffset) {
        return {};
      }
      const side = getSide(placement);
      const initialSideAxis = getSideAxis(initialPlacement);
      const isBasePlacement = getSide(initialPlacement) === initialPlacement;
      const rtl = await (platform2.isRTL == null ? void 0 : platform2.isRTL(elements.floating));
      const fallbackPlacements = specifiedFallbackPlacements || (isBasePlacement || !flipAlignment ? [getOppositePlacement(initialPlacement)] : getExpandedPlacements(initialPlacement));
      const hasFallbackAxisSideDirection = fallbackAxisSideDirection !== "none";
      if (!specifiedFallbackPlacements && hasFallbackAxisSideDirection) {
        fallbackPlacements.push(...getOppositeAxisPlacements(initialPlacement, flipAlignment, fallbackAxisSideDirection, rtl));
      }
      const placements = [initialPlacement, ...fallbackPlacements];
      const overflow = await detectOverflow(state, detectOverflowOptions);
      const overflows = [];
      let overflowsData = ((_middlewareData$flip = middlewareData.flip) == null ? void 0 : _middlewareData$flip.overflows) || [];
      if (checkMainAxis) {
        overflows.push(overflow[side]);
      }
      if (checkCrossAxis) {
        const sides2 = getAlignmentSides(placement, rects, rtl);
        overflows.push(overflow[sides2[0]], overflow[sides2[1]]);
      }
      overflowsData = [...overflowsData, {
        placement,
        overflows
      }];
      if (!overflows.every((side2) => side2 <= 0)) {
        var _middlewareData$flip2, _overflowsData$filter;
        const nextIndex = (((_middlewareData$flip2 = middlewareData.flip) == null ? void 0 : _middlewareData$flip2.index) || 0) + 1;
        const nextPlacement = placements[nextIndex];
        if (nextPlacement) {
          const ignoreCrossAxisOverflow = checkCrossAxis === "alignment" ? initialSideAxis !== getSideAxis(nextPlacement) : false;
          if (!ignoreCrossAxisOverflow || // We leave the current main axis only if every placement on that axis
          // overflows the main axis.
          overflowsData.every((d2) => d2.overflows[0] > 0 && getSideAxis(d2.placement) === initialSideAxis)) {
            return {
              data: {
                index: nextIndex,
                overflows: overflowsData
              },
              reset: {
                placement: nextPlacement
              }
            };
          }
        }
        let resetPlacement = (_overflowsData$filter = overflowsData.filter((d2) => d2.overflows[0] <= 0).sort((a2, b2) => a2.overflows[1] - b2.overflows[1])[0]) == null ? void 0 : _overflowsData$filter.placement;
        if (!resetPlacement) {
          switch (fallbackStrategy) {
            case "bestFit": {
              var _overflowsData$filter2;
              const placement2 = (_overflowsData$filter2 = overflowsData.filter((d2) => {
                if (hasFallbackAxisSideDirection) {
                  const currentSideAxis = getSideAxis(d2.placement);
                  return currentSideAxis === initialSideAxis || // Create a bias to the `y` side axis due to horizontal
                  // reading directions favoring greater width.
                  currentSideAxis === "y";
                }
                return true;
              }).map((d2) => [d2.placement, d2.overflows.filter((overflow2) => overflow2 > 0).reduce((acc, overflow2) => acc + overflow2, 0)]).sort((a2, b2) => a2[1] - b2[1])[0]) == null ? void 0 : _overflowsData$filter2[0];
              if (placement2) {
                resetPlacement = placement2;
              }
              break;
            }
            case "initialPlacement":
              resetPlacement = initialPlacement;
              break;
          }
        }
        if (placement !== resetPlacement) {
          return {
            reset: {
              placement: resetPlacement
            }
          };
        }
      }
      return {};
    }
  };
};
function getSideOffsets(overflow, rect) {
  return {
    top: overflow.top - rect.height,
    right: overflow.right - rect.width,
    bottom: overflow.bottom - rect.height,
    left: overflow.left - rect.width
  };
}
function isAnySideFullyClipped(overflow) {
  return sides.some((side) => overflow[side] >= 0);
}
const hide$2 = function(options) {
  if (options === void 0) {
    options = {};
  }
  return {
    name: "hide",
    options,
    async fn(state) {
      const {
        rects
      } = state;
      const {
        strategy = "referenceHidden",
        ...detectOverflowOptions
      } = evaluate(options, state);
      switch (strategy) {
        case "referenceHidden": {
          const overflow = await detectOverflow(state, {
            ...detectOverflowOptions,
            elementContext: "reference"
          });
          const offsets = getSideOffsets(overflow, rects.reference);
          return {
            data: {
              referenceHiddenOffsets: offsets,
              referenceHidden: isAnySideFullyClipped(offsets)
            }
          };
        }
        case "escaped": {
          const overflow = await detectOverflow(state, {
            ...detectOverflowOptions,
            altBoundary: true
          });
          const offsets = getSideOffsets(overflow, rects.floating);
          return {
            data: {
              escapedOffsets: offsets,
              escaped: isAnySideFullyClipped(offsets)
            }
          };
        }
        default: {
          return {};
        }
      }
    }
  };
};
async function convertValueToCoords(state, options) {
  const {
    placement,
    platform: platform2,
    elements
  } = state;
  const rtl = await (platform2.isRTL == null ? void 0 : platform2.isRTL(elements.floating));
  const side = getSide(placement);
  const alignment = getAlignment(placement);
  const isVertical = getSideAxis(placement) === "y";
  const mainAxisMulti = ["left", "top"].includes(side) ? -1 : 1;
  const crossAxisMulti = rtl && isVertical ? -1 : 1;
  const rawValue = evaluate(options, state);
  let {
    mainAxis,
    crossAxis,
    alignmentAxis
  } = typeof rawValue === "number" ? {
    mainAxis: rawValue,
    crossAxis: 0,
    alignmentAxis: null
  } : {
    mainAxis: rawValue.mainAxis || 0,
    crossAxis: rawValue.crossAxis || 0,
    alignmentAxis: rawValue.alignmentAxis
  };
  if (alignment && typeof alignmentAxis === "number") {
    crossAxis = alignment === "end" ? alignmentAxis * -1 : alignmentAxis;
  }
  return isVertical ? {
    x: crossAxis * crossAxisMulti,
    y: mainAxis * mainAxisMulti
  } : {
    x: mainAxis * mainAxisMulti,
    y: crossAxis * crossAxisMulti
  };
}
const offset$2 = function(options) {
  if (options === void 0) {
    options = 0;
  }
  return {
    name: "offset",
    options,
    async fn(state) {
      var _middlewareData$offse, _middlewareData$arrow;
      const {
        x: x2,
        y: y2,
        placement,
        middlewareData
      } = state;
      const diffCoords = await convertValueToCoords(state, options);
      if (placement === ((_middlewareData$offse = middlewareData.offset) == null ? void 0 : _middlewareData$offse.placement) && (_middlewareData$arrow = middlewareData.arrow) != null && _middlewareData$arrow.alignmentOffset) {
        return {};
      }
      return {
        x: x2 + diffCoords.x,
        y: y2 + diffCoords.y,
        data: {
          ...diffCoords,
          placement
        }
      };
    }
  };
};
const shift$2 = function(options) {
  if (options === void 0) {
    options = {};
  }
  return {
    name: "shift",
    options,
    async fn(state) {
      const {
        x: x2,
        y: y2,
        placement
      } = state;
      const {
        mainAxis: checkMainAxis = true,
        crossAxis: checkCrossAxis = false,
        limiter = {
          fn: (_ref) => {
            let {
              x: x3,
              y: y3
            } = _ref;
            return {
              x: x3,
              y: y3
            };
          }
        },
        ...detectOverflowOptions
      } = evaluate(options, state);
      const coords = {
        x: x2,
        y: y2
      };
      const overflow = await detectOverflow(state, detectOverflowOptions);
      const crossAxis = getSideAxis(getSide(placement));
      const mainAxis = getOppositeAxis(crossAxis);
      let mainAxisCoord = coords[mainAxis];
      let crossAxisCoord = coords[crossAxis];
      if (checkMainAxis) {
        const minSide = mainAxis === "y" ? "top" : "left";
        const maxSide = mainAxis === "y" ? "bottom" : "right";
        const min2 = mainAxisCoord + overflow[minSide];
        const max2 = mainAxisCoord - overflow[maxSide];
        mainAxisCoord = clamp$3(min2, mainAxisCoord, max2);
      }
      if (checkCrossAxis) {
        const minSide = crossAxis === "y" ? "top" : "left";
        const maxSide = crossAxis === "y" ? "bottom" : "right";
        const min2 = crossAxisCoord + overflow[minSide];
        const max2 = crossAxisCoord - overflow[maxSide];
        crossAxisCoord = clamp$3(min2, crossAxisCoord, max2);
      }
      const limitedCoords = limiter.fn({
        ...state,
        [mainAxis]: mainAxisCoord,
        [crossAxis]: crossAxisCoord
      });
      return {
        ...limitedCoords,
        data: {
          x: limitedCoords.x - x2,
          y: limitedCoords.y - y2,
          enabled: {
            [mainAxis]: checkMainAxis,
            [crossAxis]: checkCrossAxis
          }
        }
      };
    }
  };
};
const limitShift$2 = function(options) {
  if (options === void 0) {
    options = {};
  }
  return {
    options,
    fn(state) {
      const {
        x: x2,
        y: y2,
        placement,
        rects,
        middlewareData
      } = state;
      const {
        offset: offset2 = 0,
        mainAxis: checkMainAxis = true,
        crossAxis: checkCrossAxis = true
      } = evaluate(options, state);
      const coords = {
        x: x2,
        y: y2
      };
      const crossAxis = getSideAxis(placement);
      const mainAxis = getOppositeAxis(crossAxis);
      let mainAxisCoord = coords[mainAxis];
      let crossAxisCoord = coords[crossAxis];
      const rawOffset = evaluate(offset2, state);
      const computedOffset = typeof rawOffset === "number" ? {
        mainAxis: rawOffset,
        crossAxis: 0
      } : {
        mainAxis: 0,
        crossAxis: 0,
        ...rawOffset
      };
      if (checkMainAxis) {
        const len = mainAxis === "y" ? "height" : "width";
        const limitMin = rects.reference[mainAxis] - rects.floating[len] + computedOffset.mainAxis;
        const limitMax = rects.reference[mainAxis] + rects.reference[len] - computedOffset.mainAxis;
        if (mainAxisCoord < limitMin) {
          mainAxisCoord = limitMin;
        } else if (mainAxisCoord > limitMax) {
          mainAxisCoord = limitMax;
        }
      }
      if (checkCrossAxis) {
        var _middlewareData$offse, _middlewareData$offse2;
        const len = mainAxis === "y" ? "width" : "height";
        const isOriginSide = ["top", "left"].includes(getSide(placement));
        const limitMin = rects.reference[crossAxis] - rects.floating[len] + (isOriginSide ? ((_middlewareData$offse = middlewareData.offset) == null ? void 0 : _middlewareData$offse[crossAxis]) || 0 : 0) + (isOriginSide ? 0 : computedOffset.crossAxis);
        const limitMax = rects.reference[crossAxis] + rects.reference[len] + (isOriginSide ? 0 : ((_middlewareData$offse2 = middlewareData.offset) == null ? void 0 : _middlewareData$offse2[crossAxis]) || 0) - (isOriginSide ? computedOffset.crossAxis : 0);
        if (crossAxisCoord < limitMin) {
          crossAxisCoord = limitMin;
        } else if (crossAxisCoord > limitMax) {
          crossAxisCoord = limitMax;
        }
      }
      return {
        [mainAxis]: mainAxisCoord,
        [crossAxis]: crossAxisCoord
      };
    }
  };
};
const size$2 = function(options) {
  if (options === void 0) {
    options = {};
  }
  return {
    name: "size",
    options,
    async fn(state) {
      var _state$middlewareData, _state$middlewareData2;
      const {
        placement,
        rects,
        platform: platform2,
        elements
      } = state;
      const {
        apply = () => {
        },
        ...detectOverflowOptions
      } = evaluate(options, state);
      const overflow = await detectOverflow(state, detectOverflowOptions);
      const side = getSide(placement);
      const alignment = getAlignment(placement);
      const isYAxis = getSideAxis(placement) === "y";
      const {
        width: width2,
        height: height2
      } = rects.floating;
      let heightSide;
      let widthSide;
      if (side === "top" || side === "bottom") {
        heightSide = side;
        widthSide = alignment === (await (platform2.isRTL == null ? void 0 : platform2.isRTL(elements.floating)) ? "start" : "end") ? "left" : "right";
      } else {
        widthSide = side;
        heightSide = alignment === "end" ? "top" : "bottom";
      }
      const maximumClippingHeight = height2 - overflow.top - overflow.bottom;
      const maximumClippingWidth = width2 - overflow.left - overflow.right;
      const overflowAvailableHeight = min(height2 - overflow[heightSide], maximumClippingHeight);
      const overflowAvailableWidth = min(width2 - overflow[widthSide], maximumClippingWidth);
      const noShift = !state.middlewareData.shift;
      let availableHeight = overflowAvailableHeight;
      let availableWidth = overflowAvailableWidth;
      if ((_state$middlewareData = state.middlewareData.shift) != null && _state$middlewareData.enabled.x) {
        availableWidth = maximumClippingWidth;
      }
      if ((_state$middlewareData2 = state.middlewareData.shift) != null && _state$middlewareData2.enabled.y) {
        availableHeight = maximumClippingHeight;
      }
      if (noShift && !alignment) {
        const xMin = max(overflow.left, 0);
        const xMax = max(overflow.right, 0);
        const yMin = max(overflow.top, 0);
        const yMax = max(overflow.bottom, 0);
        if (isYAxis) {
          availableWidth = width2 - 2 * (xMin !== 0 || xMax !== 0 ? xMin + xMax : max(overflow.left, overflow.right));
        } else {
          availableHeight = height2 - 2 * (yMin !== 0 || yMax !== 0 ? yMin + yMax : max(overflow.top, overflow.bottom));
        }
      }
      await apply({
        ...state,
        availableWidth,
        availableHeight
      });
      const nextDimensions = await platform2.getDimensions(elements.floating);
      if (width2 !== nextDimensions.width || height2 !== nextDimensions.height) {
        return {
          reset: {
            rects: true
          }
        };
      }
      return {};
    }
  };
};
function hasWindow() {
  return typeof window !== "undefined";
}
function getNodeName(node2) {
  if (isNode(node2)) {
    return (node2.nodeName || "").toLowerCase();
  }
  return "#document";
}
function getWindow(node2) {
  var _node$ownerDocument;
  return (node2 == null || (_node$ownerDocument = node2.ownerDocument) == null ? void 0 : _node$ownerDocument.defaultView) || window;
}
function getDocumentElement(node2) {
  var _ref;
  return (_ref = (isNode(node2) ? node2.ownerDocument : node2.document) || window.document) == null ? void 0 : _ref.documentElement;
}
function isNode(value) {
  if (!hasWindow()) {
    return false;
  }
  return value instanceof Node || value instanceof getWindow(value).Node;
}
function isElement(value) {
  if (!hasWindow()) {
    return false;
  }
  return value instanceof Element || value instanceof getWindow(value).Element;
}
function isHTMLElement(value) {
  if (!hasWindow()) {
    return false;
  }
  return value instanceof HTMLElement || value instanceof getWindow(value).HTMLElement;
}
function isShadowRoot(value) {
  if (!hasWindow() || typeof ShadowRoot === "undefined") {
    return false;
  }
  return value instanceof ShadowRoot || value instanceof getWindow(value).ShadowRoot;
}
function isOverflowElement(element) {
  const {
    overflow,
    overflowX,
    overflowY,
    display
  } = getComputedStyle$1(element);
  return /auto|scroll|overlay|hidden|clip/.test(overflow + overflowY + overflowX) && !["inline", "contents"].includes(display);
}
function isTableElement(element) {
  return ["table", "td", "th"].includes(getNodeName(element));
}
function isTopLayer(element) {
  return [":popover-open", ":modal"].some((selector) => {
    try {
      return element.matches(selector);
    } catch (e2) {
      return false;
    }
  });
}
function isContainingBlock(elementOrCss) {
  const webkit = isWebKit();
  const css2 = isElement(elementOrCss) ? getComputedStyle$1(elementOrCss) : elementOrCss;
  return ["transform", "translate", "scale", "rotate", "perspective"].some((value) => css2[value] ? css2[value] !== "none" : false) || (css2.containerType ? css2.containerType !== "normal" : false) || !webkit && (css2.backdropFilter ? css2.backdropFilter !== "none" : false) || !webkit && (css2.filter ? css2.filter !== "none" : false) || ["transform", "translate", "scale", "rotate", "perspective", "filter"].some((value) => (css2.willChange || "").includes(value)) || ["paint", "layout", "strict", "content"].some((value) => (css2.contain || "").includes(value));
}
function getContainingBlock(element) {
  let currentNode = getParentNode(element);
  while (isHTMLElement(currentNode) && !isLastTraversableNode(currentNode)) {
    if (isContainingBlock(currentNode)) {
      return currentNode;
    } else if (isTopLayer(currentNode)) {
      return null;
    }
    currentNode = getParentNode(currentNode);
  }
  return null;
}
function isWebKit() {
  if (typeof CSS === "undefined" || !CSS.supports) return false;
  return CSS.supports("-webkit-backdrop-filter", "none");
}
function isLastTraversableNode(node2) {
  return ["html", "body", "#document"].includes(getNodeName(node2));
}
function getComputedStyle$1(element) {
  return getWindow(element).getComputedStyle(element);
}
function getNodeScroll(element) {
  if (isElement(element)) {
    return {
      scrollLeft: element.scrollLeft,
      scrollTop: element.scrollTop
    };
  }
  return {
    scrollLeft: element.scrollX,
    scrollTop: element.scrollY
  };
}
function getParentNode(node2) {
  if (getNodeName(node2) === "html") {
    return node2;
  }
  const result = (
    // Step into the shadow DOM of the parent of a slotted node.
    node2.assignedSlot || // DOM Element detected.
    node2.parentNode || // ShadowRoot detected.
    isShadowRoot(node2) && node2.host || // Fallback.
    getDocumentElement(node2)
  );
  return isShadowRoot(result) ? result.host : result;
}
function getNearestOverflowAncestor(node2) {
  const parentNode = getParentNode(node2);
  if (isLastTraversableNode(parentNode)) {
    return node2.ownerDocument ? node2.ownerDocument.body : node2.body;
  }
  if (isHTMLElement(parentNode) && isOverflowElement(parentNode)) {
    return parentNode;
  }
  return getNearestOverflowAncestor(parentNode);
}
function getOverflowAncestors(node2, list, traverseIframes) {
  var _node$ownerDocument2;
  if (list === void 0) {
    list = [];
  }
  if (traverseIframes === void 0) {
    traverseIframes = true;
  }
  const scrollableAncestor = getNearestOverflowAncestor(node2);
  const isBody = scrollableAncestor === ((_node$ownerDocument2 = node2.ownerDocument) == null ? void 0 : _node$ownerDocument2.body);
  const win2 = getWindow(scrollableAncestor);
  if (isBody) {
    const frameElement = getFrameElement(win2);
    return list.concat(win2, win2.visualViewport || [], isOverflowElement(scrollableAncestor) ? scrollableAncestor : [], frameElement && traverseIframes ? getOverflowAncestors(frameElement) : []);
  }
  return list.concat(scrollableAncestor, getOverflowAncestors(scrollableAncestor, [], traverseIframes));
}
function getFrameElement(win2) {
  return win2.parent && Object.getPrototypeOf(win2.parent) ? win2.frameElement : null;
}
function getCssDimensions(element) {
  const css2 = getComputedStyle$1(element);
  let width2 = parseFloat(css2.width) || 0;
  let height2 = parseFloat(css2.height) || 0;
  const hasOffset = isHTMLElement(element);
  const offsetWidth = hasOffset ? element.offsetWidth : width2;
  const offsetHeight = hasOffset ? element.offsetHeight : height2;
  const shouldFallback = round$2(width2) !== offsetWidth || round$2(height2) !== offsetHeight;
  if (shouldFallback) {
    width2 = offsetWidth;
    height2 = offsetHeight;
  }
  return {
    width: width2,
    height: height2,
    $: shouldFallback
  };
}
function unwrapElement(element) {
  return !isElement(element) ? element.contextElement : element;
}
function getScale$1(element) {
  const domElement = unwrapElement(element);
  if (!isHTMLElement(domElement)) {
    return createCoords(1);
  }
  const rect = domElement.getBoundingClientRect();
  const {
    width: width2,
    height: height2,
    $
  } = getCssDimensions(domElement);
  let x2 = ($ ? round$2(rect.width) : rect.width) / width2;
  let y2 = ($ ? round$2(rect.height) : rect.height) / height2;
  if (!x2 || !Number.isFinite(x2)) {
    x2 = 1;
  }
  if (!y2 || !Number.isFinite(y2)) {
    y2 = 1;
  }
  return {
    x: x2,
    y: y2
  };
}
const noOffsets = /* @__PURE__ */ createCoords(0);
function getVisualOffsets(element) {
  const win2 = getWindow(element);
  if (!isWebKit() || !win2.visualViewport) {
    return noOffsets;
  }
  return {
    x: win2.visualViewport.offsetLeft,
    y: win2.visualViewport.offsetTop
  };
}
function shouldAddVisualOffsets(element, isFixed, floatingOffsetParent) {
  if (isFixed === void 0) {
    isFixed = false;
  }
  if (!floatingOffsetParent || isFixed && floatingOffsetParent !== getWindow(element)) {
    return false;
  }
  return isFixed;
}
function getBoundingClientRect(element, includeScale, isFixedStrategy, offsetParent) {
  if (includeScale === void 0) {
    includeScale = false;
  }
  if (isFixedStrategy === void 0) {
    isFixedStrategy = false;
  }
  const clientRect = element.getBoundingClientRect();
  const domElement = unwrapElement(element);
  let scale2 = createCoords(1);
  if (includeScale) {
    if (offsetParent) {
      if (isElement(offsetParent)) {
        scale2 = getScale$1(offsetParent);
      }
    } else {
      scale2 = getScale$1(element);
    }
  }
  const visualOffsets = shouldAddVisualOffsets(domElement, isFixedStrategy, offsetParent) ? getVisualOffsets(domElement) : createCoords(0);
  let x2 = (clientRect.left + visualOffsets.x) / scale2.x;
  let y2 = (clientRect.top + visualOffsets.y) / scale2.y;
  let width2 = clientRect.width / scale2.x;
  let height2 = clientRect.height / scale2.y;
  if (domElement) {
    const win2 = getWindow(domElement);
    const offsetWin = offsetParent && isElement(offsetParent) ? getWindow(offsetParent) : offsetParent;
    let currentWin = win2;
    let currentIFrame = getFrameElement(currentWin);
    while (currentIFrame && offsetParent && offsetWin !== currentWin) {
      const iframeScale = getScale$1(currentIFrame);
      const iframeRect = currentIFrame.getBoundingClientRect();
      const css2 = getComputedStyle$1(currentIFrame);
      const left = iframeRect.left + (currentIFrame.clientLeft + parseFloat(css2.paddingLeft)) * iframeScale.x;
      const top = iframeRect.top + (currentIFrame.clientTop + parseFloat(css2.paddingTop)) * iframeScale.y;
      x2 *= iframeScale.x;
      y2 *= iframeScale.y;
      width2 *= iframeScale.x;
      height2 *= iframeScale.y;
      x2 += left;
      y2 += top;
      currentWin = getWindow(currentIFrame);
      currentIFrame = getFrameElement(currentWin);
    }
  }
  return rectToClientRect({
    width: width2,
    height: height2,
    x: x2,
    y: y2
  });
}
function getWindowScrollBarX(element, rect) {
  const leftScroll = getNodeScroll(element).scrollLeft;
  if (!rect) {
    return getBoundingClientRect(getDocumentElement(element)).left + leftScroll;
  }
  return rect.left + leftScroll;
}
function getHTMLOffset(documentElement, scroll, ignoreScrollbarX) {
  if (ignoreScrollbarX === void 0) {
    ignoreScrollbarX = false;
  }
  const htmlRect = documentElement.getBoundingClientRect();
  const x2 = htmlRect.left + scroll.scrollLeft - (ignoreScrollbarX ? 0 : (
    // RTL <body> scrollbar.
    getWindowScrollBarX(documentElement, htmlRect)
  ));
  const y2 = htmlRect.top + scroll.scrollTop;
  return {
    x: x2,
    y: y2
  };
}
function convertOffsetParentRelativeRectToViewportRelativeRect(_ref) {
  let {
    elements,
    rect,
    offsetParent,
    strategy
  } = _ref;
  const isFixed = strategy === "fixed";
  const documentElement = getDocumentElement(offsetParent);
  const topLayer = elements ? isTopLayer(elements.floating) : false;
  if (offsetParent === documentElement || topLayer && isFixed) {
    return rect;
  }
  let scroll = {
    scrollLeft: 0,
    scrollTop: 0
  };
  let scale2 = createCoords(1);
  const offsets = createCoords(0);
  const isOffsetParentAnElement = isHTMLElement(offsetParent);
  if (isOffsetParentAnElement || !isOffsetParentAnElement && !isFixed) {
    if (getNodeName(offsetParent) !== "body" || isOverflowElement(documentElement)) {
      scroll = getNodeScroll(offsetParent);
    }
    if (isHTMLElement(offsetParent)) {
      const offsetRect = getBoundingClientRect(offsetParent);
      scale2 = getScale$1(offsetParent);
      offsets.x = offsetRect.x + offsetParent.clientLeft;
      offsets.y = offsetRect.y + offsetParent.clientTop;
    }
  }
  const htmlOffset = documentElement && !isOffsetParentAnElement && !isFixed ? getHTMLOffset(documentElement, scroll, true) : createCoords(0);
  return {
    width: rect.width * scale2.x,
    height: rect.height * scale2.y,
    x: rect.x * scale2.x - scroll.scrollLeft * scale2.x + offsets.x + htmlOffset.x,
    y: rect.y * scale2.y - scroll.scrollTop * scale2.y + offsets.y + htmlOffset.y
  };
}
function getClientRects(element) {
  return Array.from(element.getClientRects());
}
function getDocumentRect(element) {
  const html = getDocumentElement(element);
  const scroll = getNodeScroll(element);
  const body = element.ownerDocument.body;
  const width2 = max(html.scrollWidth, html.clientWidth, body.scrollWidth, body.clientWidth);
  const height2 = max(html.scrollHeight, html.clientHeight, body.scrollHeight, body.clientHeight);
  let x2 = -scroll.scrollLeft + getWindowScrollBarX(element);
  const y2 = -scroll.scrollTop;
  if (getComputedStyle$1(body).direction === "rtl") {
    x2 += max(html.clientWidth, body.clientWidth) - width2;
  }
  return {
    width: width2,
    height: height2,
    x: x2,
    y: y2
  };
}
function getViewportRect(element, strategy) {
  const win2 = getWindow(element);
  const html = getDocumentElement(element);
  const visualViewport = win2.visualViewport;
  let width2 = html.clientWidth;
  let height2 = html.clientHeight;
  let x2 = 0;
  let y2 = 0;
  if (visualViewport) {
    width2 = visualViewport.width;
    height2 = visualViewport.height;
    const visualViewportBased = isWebKit();
    if (!visualViewportBased || visualViewportBased && strategy === "fixed") {
      x2 = visualViewport.offsetLeft;
      y2 = visualViewport.offsetTop;
    }
  }
  return {
    width: width2,
    height: height2,
    x: x2,
    y: y2
  };
}
function getInnerBoundingClientRect(element, strategy) {
  const clientRect = getBoundingClientRect(element, true, strategy === "fixed");
  const top = clientRect.top + element.clientTop;
  const left = clientRect.left + element.clientLeft;
  const scale2 = isHTMLElement(element) ? getScale$1(element) : createCoords(1);
  const width2 = element.clientWidth * scale2.x;
  const height2 = element.clientHeight * scale2.y;
  const x2 = left * scale2.x;
  const y2 = top * scale2.y;
  return {
    width: width2,
    height: height2,
    x: x2,
    y: y2
  };
}
function getClientRectFromClippingAncestor(element, clippingAncestor, strategy) {
  let rect;
  if (clippingAncestor === "viewport") {
    rect = getViewportRect(element, strategy);
  } else if (clippingAncestor === "document") {
    rect = getDocumentRect(getDocumentElement(element));
  } else if (isElement(clippingAncestor)) {
    rect = getInnerBoundingClientRect(clippingAncestor, strategy);
  } else {
    const visualOffsets = getVisualOffsets(element);
    rect = {
      x: clippingAncestor.x - visualOffsets.x,
      y: clippingAncestor.y - visualOffsets.y,
      width: clippingAncestor.width,
      height: clippingAncestor.height
    };
  }
  return rectToClientRect(rect);
}
function hasFixedPositionAncestor(element, stopNode) {
  const parentNode = getParentNode(element);
  if (parentNode === stopNode || !isElement(parentNode) || isLastTraversableNode(parentNode)) {
    return false;
  }
  return getComputedStyle$1(parentNode).position === "fixed" || hasFixedPositionAncestor(parentNode, stopNode);
}
function getClippingElementAncestors(element, cache) {
  const cachedResult = cache.get(element);
  if (cachedResult) {
    return cachedResult;
  }
  let result = getOverflowAncestors(element, [], false).filter((el) => isElement(el) && getNodeName(el) !== "body");
  let currentContainingBlockComputedStyle = null;
  const elementIsFixed = getComputedStyle$1(element).position === "fixed";
  let currentNode = elementIsFixed ? getParentNode(element) : element;
  while (isElement(currentNode) && !isLastTraversableNode(currentNode)) {
    const computedStyle = getComputedStyle$1(currentNode);
    const currentNodeIsContaining = isContainingBlock(currentNode);
    if (!currentNodeIsContaining && computedStyle.position === "fixed") {
      currentContainingBlockComputedStyle = null;
    }
    const shouldDropCurrentNode = elementIsFixed ? !currentNodeIsContaining && !currentContainingBlockComputedStyle : !currentNodeIsContaining && computedStyle.position === "static" && !!currentContainingBlockComputedStyle && ["absolute", "fixed"].includes(currentContainingBlockComputedStyle.position) || isOverflowElement(currentNode) && !currentNodeIsContaining && hasFixedPositionAncestor(element, currentNode);
    if (shouldDropCurrentNode) {
      result = result.filter((ancestor) => ancestor !== currentNode);
    } else {
      currentContainingBlockComputedStyle = computedStyle;
    }
    currentNode = getParentNode(currentNode);
  }
  cache.set(element, result);
  return result;
}
function getClippingRect(_ref) {
  let {
    element,
    boundary,
    rootBoundary,
    strategy
  } = _ref;
  const elementClippingAncestors = boundary === "clippingAncestors" ? isTopLayer(element) ? [] : getClippingElementAncestors(element, this._c) : [].concat(boundary);
  const clippingAncestors = [...elementClippingAncestors, rootBoundary];
  const firstClippingAncestor = clippingAncestors[0];
  const clippingRect = clippingAncestors.reduce((accRect, clippingAncestor) => {
    const rect = getClientRectFromClippingAncestor(element, clippingAncestor, strategy);
    accRect.top = max(rect.top, accRect.top);
    accRect.right = min(rect.right, accRect.right);
    accRect.bottom = min(rect.bottom, accRect.bottom);
    accRect.left = max(rect.left, accRect.left);
    return accRect;
  }, getClientRectFromClippingAncestor(element, firstClippingAncestor, strategy));
  return {
    width: clippingRect.right - clippingRect.left,
    height: clippingRect.bottom - clippingRect.top,
    x: clippingRect.left,
    y: clippingRect.top
  };
}
function getDimensions(element) {
  const {
    width: width2,
    height: height2
  } = getCssDimensions(element);
  return {
    width: width2,
    height: height2
  };
}
function getRectRelativeToOffsetParent(element, offsetParent, strategy) {
  const isOffsetParentAnElement = isHTMLElement(offsetParent);
  const documentElement = getDocumentElement(offsetParent);
  const isFixed = strategy === "fixed";
  const rect = getBoundingClientRect(element, true, isFixed, offsetParent);
  let scroll = {
    scrollLeft: 0,
    scrollTop: 0
  };
  const offsets = createCoords(0);
  function setLeftRTLScrollbarOffset() {
    offsets.x = getWindowScrollBarX(documentElement);
  }
  if (isOffsetParentAnElement || !isOffsetParentAnElement && !isFixed) {
    if (getNodeName(offsetParent) !== "body" || isOverflowElement(documentElement)) {
      scroll = getNodeScroll(offsetParent);
    }
    if (isOffsetParentAnElement) {
      const offsetRect = getBoundingClientRect(offsetParent, true, isFixed, offsetParent);
      offsets.x = offsetRect.x + offsetParent.clientLeft;
      offsets.y = offsetRect.y + offsetParent.clientTop;
    } else if (documentElement) {
      setLeftRTLScrollbarOffset();
    }
  }
  if (isFixed && !isOffsetParentAnElement && documentElement) {
    setLeftRTLScrollbarOffset();
  }
  const htmlOffset = documentElement && !isOffsetParentAnElement && !isFixed ? getHTMLOffset(documentElement, scroll) : createCoords(0);
  const x2 = rect.left + scroll.scrollLeft - offsets.x - htmlOffset.x;
  const y2 = rect.top + scroll.scrollTop - offsets.y - htmlOffset.y;
  return {
    x: x2,
    y: y2,
    width: rect.width,
    height: rect.height
  };
}
function isStaticPositioned(element) {
  return getComputedStyle$1(element).position === "static";
}
function getTrueOffsetParent(element, polyfill2) {
  if (!isHTMLElement(element) || getComputedStyle$1(element).position === "fixed") {
    return null;
  }
  if (polyfill2) {
    return polyfill2(element);
  }
  let rawOffsetParent = element.offsetParent;
  if (getDocumentElement(element) === rawOffsetParent) {
    rawOffsetParent = rawOffsetParent.ownerDocument.body;
  }
  return rawOffsetParent;
}
function getOffsetParent(element, polyfill2) {
  const win2 = getWindow(element);
  if (isTopLayer(element)) {
    return win2;
  }
  if (!isHTMLElement(element)) {
    let svgOffsetParent = getParentNode(element);
    while (svgOffsetParent && !isLastTraversableNode(svgOffsetParent)) {
      if (isElement(svgOffsetParent) && !isStaticPositioned(svgOffsetParent)) {
        return svgOffsetParent;
      }
      svgOffsetParent = getParentNode(svgOffsetParent);
    }
    return win2;
  }
  let offsetParent = getTrueOffsetParent(element, polyfill2);
  while (offsetParent && isTableElement(offsetParent) && isStaticPositioned(offsetParent)) {
    offsetParent = getTrueOffsetParent(offsetParent, polyfill2);
  }
  if (offsetParent && isLastTraversableNode(offsetParent) && isStaticPositioned(offsetParent) && !isContainingBlock(offsetParent)) {
    return win2;
  }
  return offsetParent || getContainingBlock(element) || win2;
}
const getElementRects = async function(data) {
  const getOffsetParentFn = this.getOffsetParent || getOffsetParent;
  const getDimensionsFn = this.getDimensions;
  const floatingDimensions = await getDimensionsFn(data.floating);
  return {
    reference: getRectRelativeToOffsetParent(data.reference, await getOffsetParentFn(data.floating), data.strategy),
    floating: {
      x: 0,
      y: 0,
      width: floatingDimensions.width,
      height: floatingDimensions.height
    }
  };
};
function isRTL(element) {
  return getComputedStyle$1(element).direction === "rtl";
}
const platform = {
  convertOffsetParentRelativeRectToViewportRelativeRect,
  getDocumentElement,
  getClippingRect,
  getOffsetParent,
  getElementRects,
  getClientRects,
  getDimensions,
  getScale: getScale$1,
  isElement,
  isRTL
};
function rectsAreEqual(a2, b2) {
  return a2.x === b2.x && a2.y === b2.y && a2.width === b2.width && a2.height === b2.height;
}
function observeMove(element, onMove) {
  let io = null;
  let timeoutId;
  const root = getDocumentElement(element);
  function cleanup() {
    var _io;
    clearTimeout(timeoutId);
    (_io = io) == null || _io.disconnect();
    io = null;
  }
  function refresh(skip, threshold) {
    if (skip === void 0) {
      skip = false;
    }
    if (threshold === void 0) {
      threshold = 1;
    }
    cleanup();
    const elementRectForRootMargin = element.getBoundingClientRect();
    const {
      left,
      top,
      width: width2,
      height: height2
    } = elementRectForRootMargin;
    if (!skip) {
      onMove();
    }
    if (!width2 || !height2) {
      return;
    }
    const insetTop = floor$1(top);
    const insetRight = floor$1(root.clientWidth - (left + width2));
    const insetBottom = floor$1(root.clientHeight - (top + height2));
    const insetLeft = floor$1(left);
    const rootMargin = -insetTop + "px " + -insetRight + "px " + -insetBottom + "px " + -insetLeft + "px";
    const options = {
      rootMargin,
      threshold: max(0, min(1, threshold)) || 1
    };
    let isFirstUpdate = true;
    function handleObserve(entries) {
      const ratio = entries[0].intersectionRatio;
      if (ratio !== threshold) {
        if (!isFirstUpdate) {
          return refresh();
        }
        if (!ratio) {
          timeoutId = setTimeout(() => {
            refresh(false, 1e-7);
          }, 1e3);
        } else {
          refresh(false, ratio);
        }
      }
      if (ratio === 1 && !rectsAreEqual(elementRectForRootMargin, element.getBoundingClientRect())) {
        refresh();
      }
      isFirstUpdate = false;
    }
    try {
      io = new IntersectionObserver(handleObserve, {
        ...options,
        // Handle <iframe>s
        root: root.ownerDocument
      });
    } catch (_e2) {
      io = new IntersectionObserver(handleObserve, options);
    }
    io.observe(element);
  }
  refresh(true);
  return cleanup;
}
function autoUpdate(reference, floating, update, options) {
  if (options === void 0) {
    options = {};
  }
  const {
    ancestorScroll = true,
    ancestorResize = true,
    elementResize = typeof ResizeObserver === "function",
    layoutShift = typeof IntersectionObserver === "function",
    animationFrame = false
  } = options;
  const referenceEl = unwrapElement(reference);
  const ancestors = ancestorScroll || ancestorResize ? [...referenceEl ? getOverflowAncestors(referenceEl) : [], ...getOverflowAncestors(floating)] : [];
  ancestors.forEach((ancestor) => {
    ancestorScroll && ancestor.addEventListener("scroll", update, {
      passive: true
    });
    ancestorResize && ancestor.addEventListener("resize", update);
  });
  const cleanupIo = referenceEl && layoutShift ? observeMove(referenceEl, update) : null;
  let reobserveFrame = -1;
  let resizeObserver = null;
  if (elementResize) {
    resizeObserver = new ResizeObserver((_ref) => {
      let [firstEntry] = _ref;
      if (firstEntry && firstEntry.target === referenceEl && resizeObserver) {
        resizeObserver.unobserve(floating);
        cancelAnimationFrame(reobserveFrame);
        reobserveFrame = requestAnimationFrame(() => {
          var _resizeObserver;
          (_resizeObserver = resizeObserver) == null || _resizeObserver.observe(floating);
        });
      }
      update();
    });
    if (referenceEl && !animationFrame) {
      resizeObserver.observe(referenceEl);
    }
    resizeObserver.observe(floating);
  }
  let frameId;
  let prevRefRect = animationFrame ? getBoundingClientRect(reference) : null;
  if (animationFrame) {
    frameLoop();
  }
  function frameLoop() {
    const nextRefRect = getBoundingClientRect(reference);
    if (prevRefRect && !rectsAreEqual(prevRefRect, nextRefRect)) {
      update();
    }
    prevRefRect = nextRefRect;
    frameId = requestAnimationFrame(frameLoop);
  }
  update();
  return () => {
    var _resizeObserver2;
    ancestors.forEach((ancestor) => {
      ancestorScroll && ancestor.removeEventListener("scroll", update);
      ancestorResize && ancestor.removeEventListener("resize", update);
    });
    cleanupIo == null || cleanupIo();
    (_resizeObserver2 = resizeObserver) == null || _resizeObserver2.disconnect();
    resizeObserver = null;
    if (animationFrame) {
      cancelAnimationFrame(frameId);
    }
  };
}
const offset$1 = offset$2;
const shift$1 = shift$2;
const flip$1 = flip$2;
const size$1 = size$2;
const hide$1 = hide$2;
const arrow$2 = arrow$3;
const limitShift$1 = limitShift$2;
const computePosition = (reference, floating, options) => {
  const cache = /* @__PURE__ */ new Map();
  const mergedOptions = {
    platform,
    ...options
  };
  const platformWithCache = {
    ...mergedOptions.platform,
    _c: cache
  };
  return computePosition$1(reference, floating, {
    ...mergedOptions,
    platform: platformWithCache
  });
};
var index$1 = typeof document !== "undefined" ? reactExports.useLayoutEffect : reactExports.useEffect;
function deepEqual(a2, b2) {
  if (a2 === b2) {
    return true;
  }
  if (typeof a2 !== typeof b2) {
    return false;
  }
  if (typeof a2 === "function" && a2.toString() === b2.toString()) {
    return true;
  }
  let length2;
  let i2;
  let keys;
  if (a2 && b2 && typeof a2 === "object") {
    if (Array.isArray(a2)) {
      length2 = a2.length;
      if (length2 !== b2.length) return false;
      for (i2 = length2; i2-- !== 0; ) {
        if (!deepEqual(a2[i2], b2[i2])) {
          return false;
        }
      }
      return true;
    }
    keys = Object.keys(a2);
    length2 = keys.length;
    if (length2 !== Object.keys(b2).length) {
      return false;
    }
    for (i2 = length2; i2-- !== 0; ) {
      if (!{}.hasOwnProperty.call(b2, keys[i2])) {
        return false;
      }
    }
    for (i2 = length2; i2-- !== 0; ) {
      const key2 = keys[i2];
      if (key2 === "_owner" && a2.$$typeof) {
        continue;
      }
      if (!deepEqual(a2[key2], b2[key2])) {
        return false;
      }
    }
    return true;
  }
  return a2 !== a2 && b2 !== b2;
}
function getDPR(element) {
  if (typeof window === "undefined") {
    return 1;
  }
  const win2 = element.ownerDocument.defaultView || window;
  return win2.devicePixelRatio || 1;
}
function roundByDPR(element, value) {
  const dpr = getDPR(element);
  return Math.round(value * dpr) / dpr;
}
function useLatestRef(value) {
  const ref = reactExports.useRef(value);
  index$1(() => {
    ref.current = value;
  });
  return ref;
}
function useFloating(options) {
  if (options === void 0) {
    options = {};
  }
  const {
    placement = "bottom",
    strategy = "absolute",
    middleware: middleware2 = [],
    platform: platform2,
    elements: {
      reference: externalReference,
      floating: externalFloating
    } = {},
    transform: transform2 = true,
    whileElementsMounted,
    open
  } = options;
  const [data, setData] = reactExports.useState({
    x: 0,
    y: 0,
    strategy,
    placement,
    middlewareData: {},
    isPositioned: false
  });
  const [latestMiddleware, setLatestMiddleware] = reactExports.useState(middleware2);
  if (!deepEqual(latestMiddleware, middleware2)) {
    setLatestMiddleware(middleware2);
  }
  const [_reference, _setReference] = reactExports.useState(null);
  const [_floating, _setFloating] = reactExports.useState(null);
  const setReference = reactExports.useCallback((node2) => {
    if (node2 !== referenceRef.current) {
      referenceRef.current = node2;
      _setReference(node2);
    }
  }, []);
  const setFloating = reactExports.useCallback((node2) => {
    if (node2 !== floatingRef.current) {
      floatingRef.current = node2;
      _setFloating(node2);
    }
  }, []);
  const referenceEl = externalReference || _reference;
  const floatingEl = externalFloating || _floating;
  const referenceRef = reactExports.useRef(null);
  const floatingRef = reactExports.useRef(null);
  const dataRef = reactExports.useRef(data);
  const hasWhileElementsMounted = whileElementsMounted != null;
  const whileElementsMountedRef = useLatestRef(whileElementsMounted);
  const platformRef = useLatestRef(platform2);
  const openRef = useLatestRef(open);
  const update = reactExports.useCallback(() => {
    if (!referenceRef.current || !floatingRef.current) {
      return;
    }
    const config2 = {
      placement,
      strategy,
      middleware: latestMiddleware
    };
    if (platformRef.current) {
      config2.platform = platformRef.current;
    }
    computePosition(referenceRef.current, floatingRef.current, config2).then((data2) => {
      const fullData = {
        ...data2,
        // The floating element's position may be recomputed while it's closed
        // but still mounted (such as when transitioning out). To ensure
        // `isPositioned` will be `false` initially on the next open, avoid
        // setting it to `true` when `open === false` (must be specified).
        isPositioned: openRef.current !== false
      };
      if (isMountedRef.current && !deepEqual(dataRef.current, fullData)) {
        dataRef.current = fullData;
        reactDomExports.flushSync(() => {
          setData(fullData);
        });
      }
    });
  }, [latestMiddleware, placement, strategy, platformRef, openRef]);
  index$1(() => {
    if (open === false && dataRef.current.isPositioned) {
      dataRef.current.isPositioned = false;
      setData((data2) => ({
        ...data2,
        isPositioned: false
      }));
    }
  }, [open]);
  const isMountedRef = reactExports.useRef(false);
  index$1(() => {
    isMountedRef.current = true;
    return () => {
      isMountedRef.current = false;
    };
  }, []);
  index$1(() => {
    if (referenceEl) referenceRef.current = referenceEl;
    if (floatingEl) floatingRef.current = floatingEl;
    if (referenceEl && floatingEl) {
      if (whileElementsMountedRef.current) {
        return whileElementsMountedRef.current(referenceEl, floatingEl, update);
      }
      update();
    }
  }, [referenceEl, floatingEl, update, whileElementsMountedRef, hasWhileElementsMounted]);
  const refs = reactExports.useMemo(() => ({
    reference: referenceRef,
    floating: floatingRef,
    setReference,
    setFloating
  }), [setReference, setFloating]);
  const elements = reactExports.useMemo(() => ({
    reference: referenceEl,
    floating: floatingEl
  }), [referenceEl, floatingEl]);
  const floatingStyles = reactExports.useMemo(() => {
    const initialStyles = {
      position: strategy,
      left: 0,
      top: 0
    };
    if (!elements.floating) {
      return initialStyles;
    }
    const x2 = roundByDPR(elements.floating, data.x);
    const y2 = roundByDPR(elements.floating, data.y);
    if (transform2) {
      return {
        ...initialStyles,
        transform: "translate(" + x2 + "px, " + y2 + "px)",
        ...getDPR(elements.floating) >= 1.5 && {
          willChange: "transform"
        }
      };
    }
    return {
      position: strategy,
      left: x2,
      top: y2
    };
  }, [strategy, transform2, elements.floating, data.x, data.y]);
  return reactExports.useMemo(() => ({
    ...data,
    update,
    refs,
    elements,
    floatingStyles
  }), [data, update, refs, elements, floatingStyles]);
}
const arrow$1 = (options) => {
  function isRef(value) {
    return {}.hasOwnProperty.call(value, "current");
  }
  return {
    name: "arrow",
    options,
    fn(state) {
      const {
        element,
        padding: padding2
      } = typeof options === "function" ? options(state) : options;
      if (element && isRef(element)) {
        if (element.current != null) {
          return arrow$2({
            element: element.current,
            padding: padding2
          }).fn(state);
        }
        return {};
      }
      if (element) {
        return arrow$2({
          element,
          padding: padding2
        }).fn(state);
      }
      return {};
    }
  };
};
const offset = (options, deps) => ({
  ...offset$1(options),
  options: [options, deps]
});
const shift = (options, deps) => ({
  ...shift$1(options),
  options: [options, deps]
});
const limitShift = (options, deps) => ({
  ...limitShift$1(options),
  options: [options, deps]
});
const flip = (options, deps) => ({
  ...flip$1(options),
  options: [options, deps]
});
const size = (options, deps) => ({
  ...size$1(options),
  options: [options, deps]
});
const hide = (options, deps) => ({
  ...hide$1(options),
  options: [options, deps]
});
const arrow = (options, deps) => ({
  ...arrow$1(options),
  options: [options, deps]
});
var NAME$2 = "Arrow";
var Arrow$1 = reactExports.forwardRef((props, forwardedRef) => {
  const { children, width: width2 = 10, height: height2 = 5, ...arrowProps } = props;
  return /* @__PURE__ */ jsxRuntimeExports.jsx(
    Primitive.svg,
    {
      ...arrowProps,
      ref: forwardedRef,
      width: width2,
      height: height2,
      viewBox: "0 0 30 10",
      preserveAspectRatio: "none",
      children: props.asChild ? children : /* @__PURE__ */ jsxRuntimeExports.jsx("polygon", { points: "0,0 30,0 15,10" })
    }
  );
});
Arrow$1.displayName = NAME$2;
var Root$7 = Arrow$1;
function createContextScope$2(scopeName, createContextScopeDeps = []) {
  let defaultContexts = [];
  function createContext3(rootComponentName, defaultContext2) {
    const BaseContext = reactExports.createContext(defaultContext2);
    const index2 = defaultContexts.length;
    defaultContexts = [...defaultContexts, defaultContext2];
    function Provider2(props) {
      const { scope, children, ...context } = props;
      const Context = scope?.[scopeName][index2] || BaseContext;
      const value = reactExports.useMemo(() => context, Object.values(context));
      return /* @__PURE__ */ jsxRuntimeExports.jsx(Context.Provider, { value, children });
    }
    function useContext2(consumerName, scope) {
      const Context = scope?.[scopeName][index2] || BaseContext;
      const context = reactExports.useContext(Context);
      if (context) return context;
      if (defaultContext2 !== void 0) return defaultContext2;
      throw new Error(`\`${consumerName}\` must be used within \`${rootComponentName}\``);
    }
    Provider2.displayName = rootComponentName + "Provider";
    return [Provider2, useContext2];
  }
  const createScope = () => {
    const scopeContexts = defaultContexts.map((defaultContext2) => {
      return reactExports.createContext(defaultContext2);
    });
    return function useScope(scope) {
      const contexts = scope?.[scopeName] || scopeContexts;
      return reactExports.useMemo(
        () => ({ [`__scope${scopeName}`]: { ...scope, [scopeName]: contexts } }),
        [scope, contexts]
      );
    };
  };
  createScope.scopeName = scopeName;
  return [createContext3, composeContextScopes$2(createScope, ...createContextScopeDeps)];
}
function composeContextScopes$2(...scopes) {
  const baseScope = scopes[0];
  if (scopes.length === 1) return baseScope;
  const createScope = () => {
    const scopeHooks = scopes.map((createScope2) => ({
      useScope: createScope2(),
      scopeName: createScope2.scopeName
    }));
    return function useComposedScopes(overrideScopes) {
      const nextScopes = scopeHooks.reduce((nextScopes2, { useScope, scopeName }) => {
        const scopeProps = useScope(overrideScopes);
        const currentScope = scopeProps[`__scope${scopeName}`];
        return { ...nextScopes2, ...currentScope };
      }, {});
      return reactExports.useMemo(() => ({ [`__scope${baseScope.scopeName}`]: nextScopes }), [nextScopes]);
    };
  };
  createScope.scopeName = baseScope.scopeName;
  return createScope;
}
function useSize(element) {
  const [size2, setSize] = reactExports.useState(void 0);
  useLayoutEffect2(() => {
    if (element) {
      setSize({ width: element.offsetWidth, height: element.offsetHeight });
      const resizeObserver = new ResizeObserver((entries) => {
        if (!Array.isArray(entries)) {
          return;
        }
        if (!entries.length) {
          return;
        }
        const entry = entries[0];
        let width2;
        let height2;
        if ("borderBoxSize" in entry) {
          const borderSizeEntry = entry["borderBoxSize"];
          const borderSize = Array.isArray(borderSizeEntry) ? borderSizeEntry[0] : borderSizeEntry;
          width2 = borderSize["inlineSize"];
          height2 = borderSize["blockSize"];
        } else {
          width2 = element.offsetWidth;
          height2 = element.offsetHeight;
        }
        setSize({ width: width2, height: height2 });
      });
      resizeObserver.observe(element, { box: "border-box" });
      return () => resizeObserver.unobserve(element);
    } else {
      setSize(void 0);
    }
  }, [element]);
  return size2;
}
var POPPER_NAME = "Popper";
var [createPopperContext, createPopperScope] = createContextScope$2(POPPER_NAME);
var [PopperProvider, usePopperContext] = createPopperContext(POPPER_NAME);
var Popper = (props) => {
  const { __scopePopper, children } = props;
  const [anchor, setAnchor] = reactExports.useState(null);
  return /* @__PURE__ */ jsxRuntimeExports.jsx(PopperProvider, { scope: __scopePopper, anchor, onAnchorChange: setAnchor, children });
};
Popper.displayName = POPPER_NAME;
var ANCHOR_NAME = "PopperAnchor";
var PopperAnchor = reactExports.forwardRef(
  (props, forwardedRef) => {
    const { __scopePopper, virtualRef, ...anchorProps } = props;
    const context = usePopperContext(ANCHOR_NAME, __scopePopper);
    const ref = reactExports.useRef(null);
    const composedRefs = useComposedRefs(forwardedRef, ref);
    reactExports.useEffect(() => {
      context.onAnchorChange(virtualRef?.current || ref.current);
    });
    return virtualRef ? null : /* @__PURE__ */ jsxRuntimeExports.jsx(Primitive.div, { ...anchorProps, ref: composedRefs });
  }
);
PopperAnchor.displayName = ANCHOR_NAME;
var CONTENT_NAME$3 = "PopperContent";
var [PopperContentProvider, useContentContext] = createPopperContext(CONTENT_NAME$3);
var PopperContent = reactExports.forwardRef(
  (props, forwardedRef) => {
    const {
      __scopePopper,
      side = "bottom",
      sideOffset = 0,
      align = "center",
      alignOffset = 0,
      arrowPadding = 0,
      avoidCollisions = true,
      collisionBoundary = [],
      collisionPadding: collisionPaddingProp = 0,
      sticky = "partial",
      hideWhenDetached = false,
      updatePositionStrategy = "optimized",
      onPlaced,
      ...contentProps
    } = props;
    const context = usePopperContext(CONTENT_NAME$3, __scopePopper);
    const [content, setContent] = reactExports.useState(null);
    const composedRefs = useComposedRefs(forwardedRef, (node2) => setContent(node2));
    const [arrow$12, setArrow] = reactExports.useState(null);
    const arrowSize = useSize(arrow$12);
    const arrowWidth = arrowSize?.width ?? 0;
    const arrowHeight = arrowSize?.height ?? 0;
    const desiredPlacement = side + (align !== "center" ? "-" + align : "");
    const collisionPadding = typeof collisionPaddingProp === "number" ? collisionPaddingProp : { top: 0, right: 0, bottom: 0, left: 0, ...collisionPaddingProp };
    const boundary = Array.isArray(collisionBoundary) ? collisionBoundary : [collisionBoundary];
    const hasExplicitBoundaries = boundary.length > 0;
    const detectOverflowOptions = {
      padding: collisionPadding,
      boundary: boundary.filter(isNotNull),
      // with `strategy: 'fixed'`, this is the only way to get it to respect boundaries
      altBoundary: hasExplicitBoundaries
    };
    const { refs, floatingStyles, placement, isPositioned, middlewareData } = useFloating({
      // default to `fixed` strategy so users don't have to pick and we also avoid focus scroll issues
      strategy: "fixed",
      placement: desiredPlacement,
      whileElementsMounted: (...args) => {
        const cleanup = autoUpdate(...args, {
          animationFrame: updatePositionStrategy === "always"
        });
        return cleanup;
      },
      elements: {
        reference: context.anchor
      },
      middleware: [
        offset({ mainAxis: sideOffset + arrowHeight, alignmentAxis: alignOffset }),
        avoidCollisions && shift({
          mainAxis: true,
          crossAxis: false,
          limiter: sticky === "partial" ? limitShift() : void 0,
          ...detectOverflowOptions
        }),
        avoidCollisions && flip({ ...detectOverflowOptions }),
        size({
          ...detectOverflowOptions,
          apply: ({ elements, rects, availableWidth, availableHeight }) => {
            const { width: anchorWidth, height: anchorHeight } = rects.reference;
            const contentStyle = elements.floating.style;
            contentStyle.setProperty("--radix-popper-available-width", `${availableWidth}px`);
            contentStyle.setProperty("--radix-popper-available-height", `${availableHeight}px`);
            contentStyle.setProperty("--radix-popper-anchor-width", `${anchorWidth}px`);
            contentStyle.setProperty("--radix-popper-anchor-height", `${anchorHeight}px`);
          }
        }),
        arrow$12 && arrow({ element: arrow$12, padding: arrowPadding }),
        transformOrigin({ arrowWidth, arrowHeight }),
        hideWhenDetached && hide({ strategy: "referenceHidden", ...detectOverflowOptions })
      ]
    });
    const [placedSide, placedAlign] = getSideAndAlignFromPlacement(placement);
    const handlePlaced = useCallbackRef$1(onPlaced);
    useLayoutEffect2(() => {
      if (isPositioned) {
        handlePlaced?.();
      }
    }, [isPositioned, handlePlaced]);
    const arrowX = middlewareData.arrow?.x;
    const arrowY = middlewareData.arrow?.y;
    const cannotCenterArrow = middlewareData.arrow?.centerOffset !== 0;
    const [contentZIndex, setContentZIndex] = reactExports.useState();
    useLayoutEffect2(() => {
      if (content) setContentZIndex(window.getComputedStyle(content).zIndex);
    }, [content]);
    return /* @__PURE__ */ jsxRuntimeExports.jsx(
      "div",
      {
        ref: refs.setFloating,
        "data-radix-popper-content-wrapper": "",
        style: {
          ...floatingStyles,
          transform: isPositioned ? floatingStyles.transform : "translate(0, -200%)",
          // keep off the page when measuring
          minWidth: "max-content",
          zIndex: contentZIndex,
          ["--radix-popper-transform-origin"]: [
            middlewareData.transformOrigin?.x,
            middlewareData.transformOrigin?.y
          ].join(" "),
          // hide the content if using the hide middleware and should be hidden
          // set visibility to hidden and disable pointer events so the UI behaves
          // as if the PopperContent isn't there at all
          ...middlewareData.hide?.referenceHidden && {
            visibility: "hidden",
            pointerEvents: "none"
          }
        },
        dir: props.dir,
        children: /* @__PURE__ */ jsxRuntimeExports.jsx(
          PopperContentProvider,
          {
            scope: __scopePopper,
            placedSide,
            onArrowChange: setArrow,
            arrowX,
            arrowY,
            shouldHideArrow: cannotCenterArrow,
            children: /* @__PURE__ */ jsxRuntimeExports.jsx(
              Primitive.div,
              {
                "data-side": placedSide,
                "data-align": placedAlign,
                ...contentProps,
                ref: composedRefs,
                style: {
                  ...contentProps.style,
                  // if the PopperContent hasn't been placed yet (not all measurements done)
                  // we prevent animations so that users's animation don't kick in too early referring wrong sides
                  animation: !isPositioned ? "none" : void 0
                }
              }
            )
          }
        )
      }
    );
  }
);
PopperContent.displayName = CONTENT_NAME$3;
var ARROW_NAME$1 = "PopperArrow";
var OPPOSITE_SIDE = {
  top: "bottom",
  right: "left",
  bottom: "top",
  left: "right"
};
var PopperArrow = reactExports.forwardRef(function PopperArrow2(props, forwardedRef) {
  const { __scopePopper, ...arrowProps } = props;
  const contentContext = useContentContext(ARROW_NAME$1, __scopePopper);
  const baseSide = OPPOSITE_SIDE[contentContext.placedSide];
  return (
    // we have to use an extra wrapper because `ResizeObserver` (used by `useSize`)
    // doesn't report size as we'd expect on SVG elements.
    // it reports their bounding box which is effectively the largest path inside the SVG.
    /* @__PURE__ */ jsxRuntimeExports.jsx(
      "span",
      {
        ref: contentContext.onArrowChange,
        style: {
          position: "absolute",
          left: contentContext.arrowX,
          top: contentContext.arrowY,
          [baseSide]: 0,
          transformOrigin: {
            top: "",
            right: "0 0",
            bottom: "center 0",
            left: "100% 0"
          }[contentContext.placedSide],
          transform: {
            top: "translateY(100%)",
            right: "translateY(50%) rotate(90deg) translateX(-50%)",
            bottom: `rotate(180deg)`,
            left: "translateY(50%) rotate(-90deg) translateX(50%)"
          }[contentContext.placedSide],
          visibility: contentContext.shouldHideArrow ? "hidden" : void 0
        },
        children: /* @__PURE__ */ jsxRuntimeExports.jsx(
          Root$7,
          {
            ...arrowProps,
            ref: forwardedRef,
            style: {
              ...arrowProps.style,
              // ensures the element can be measured correctly (mostly for if SVG)
              display: "block"
            }
          }
        )
      }
    )
  );
});
PopperArrow.displayName = ARROW_NAME$1;
function isNotNull(value) {
  return value !== null;
}
var transformOrigin = (options) => ({
  name: "transformOrigin",
  options,
  fn(data) {
    const { placement, rects, middlewareData } = data;
    const cannotCenterArrow = middlewareData.arrow?.centerOffset !== 0;
    const isArrowHidden = cannotCenterArrow;
    const arrowWidth = isArrowHidden ? 0 : options.arrowWidth;
    const arrowHeight = isArrowHidden ? 0 : options.arrowHeight;
    const [placedSide, placedAlign] = getSideAndAlignFromPlacement(placement);
    const noArrowAlign = { start: "0%", center: "50%", end: "100%" }[placedAlign];
    const arrowXCenter = (middlewareData.arrow?.x ?? 0) + arrowWidth / 2;
    const arrowYCenter = (middlewareData.arrow?.y ?? 0) + arrowHeight / 2;
    let x2 = "";
    let y2 = "";
    if (placedSide === "bottom") {
      x2 = isArrowHidden ? noArrowAlign : `${arrowXCenter}px`;
      y2 = `${-arrowHeight}px`;
    } else if (placedSide === "top") {
      x2 = isArrowHidden ? noArrowAlign : `${arrowXCenter}px`;
      y2 = `${rects.floating.height + arrowHeight}px`;
    } else if (placedSide === "right") {
      x2 = `${-arrowHeight}px`;
      y2 = isArrowHidden ? noArrowAlign : `${arrowYCenter}px`;
    } else if (placedSide === "left") {
      x2 = `${rects.floating.width + arrowHeight}px`;
      y2 = isArrowHidden ? noArrowAlign : `${arrowYCenter}px`;
    }
    return { data: { x: x2, y: y2 } };
  }
});
function getSideAndAlignFromPlacement(placement) {
  const [side, align = "center"] = placement.split("-");
  return [side, align];
}
var Root2$1 = Popper;
var Anchor = PopperAnchor;
var Content$2 = PopperContent;
var Arrow = PopperArrow;
var PORTAL_NAME$2 = "Portal";
var Portal$1 = reactExports.forwardRef((props, forwardedRef) => {
  const { container: containerProp, ...portalProps } = props;
  const [mounted, setMounted] = reactExports.useState(false);
  useLayoutEffect2(() => setMounted(true), []);
  const container = containerProp || mounted && globalThis?.document?.body;
  return container ? ReactDOM.createPortal(/* @__PURE__ */ jsxRuntimeExports.jsx(Primitive.div, { ...portalProps, ref: forwardedRef }), container) : null;
});
Portal$1.displayName = PORTAL_NAME$2;
function useStateMachine$1(initialState, machine) {
  return reactExports.useReducer((state, event) => {
    const nextState = machine[state][event];
    return nextState ?? state;
  }, initialState);
}
var Presence = (props) => {
  const { present, children } = props;
  const presence = usePresence(present);
  const child = typeof children === "function" ? children({ present: presence.isPresent }) : reactExports.Children.only(children);
  const ref = useComposedRefs(presence.ref, getElementRef(child));
  const forceMount = typeof children === "function";
  return forceMount || presence.isPresent ? reactExports.cloneElement(child, { ref }) : null;
};
Presence.displayName = "Presence";
function usePresence(present) {
  const [node2, setNode] = reactExports.useState();
  const stylesRef = reactExports.useRef({});
  const prevPresentRef = reactExports.useRef(present);
  const prevAnimationNameRef = reactExports.useRef("none");
  const initialState = present ? "mounted" : "unmounted";
  const [state, send] = useStateMachine$1(initialState, {
    mounted: {
      UNMOUNT: "unmounted",
      ANIMATION_OUT: "unmountSuspended"
    },
    unmountSuspended: {
      MOUNT: "mounted",
      ANIMATION_END: "unmounted"
    },
    unmounted: {
      MOUNT: "mounted"
    }
  });
  reactExports.useEffect(() => {
    const currentAnimationName = getAnimationName(stylesRef.current);
    prevAnimationNameRef.current = state === "mounted" ? currentAnimationName : "none";
  }, [state]);
  useLayoutEffect2(() => {
    const styles2 = stylesRef.current;
    const wasPresent = prevPresentRef.current;
    const hasPresentChanged = wasPresent !== present;
    if (hasPresentChanged) {
      const prevAnimationName = prevAnimationNameRef.current;
      const currentAnimationName = getAnimationName(styles2);
      if (present) {
        send("MOUNT");
      } else if (currentAnimationName === "none" || styles2?.display === "none") {
        send("UNMOUNT");
      } else {
        const isAnimating = prevAnimationName !== currentAnimationName;
        if (wasPresent && isAnimating) {
          send("ANIMATION_OUT");
        } else {
          send("UNMOUNT");
        }
      }
      prevPresentRef.current = present;
    }
  }, [present, send]);
  useLayoutEffect2(() => {
    if (node2) {
      let timeoutId;
      const ownerWindow = node2.ownerDocument.defaultView ?? window;
      const handleAnimationEnd = (event) => {
        const currentAnimationName = getAnimationName(stylesRef.current);
        const isCurrentAnimation = currentAnimationName.includes(event.animationName);
        if (event.target === node2 && isCurrentAnimation) {
          send("ANIMATION_END");
          if (!prevPresentRef.current) {
            const currentFillMode = node2.style.animationFillMode;
            node2.style.animationFillMode = "forwards";
            timeoutId = ownerWindow.setTimeout(() => {
              if (node2.style.animationFillMode === "forwards") {
                node2.style.animationFillMode = currentFillMode;
              }
            });
          }
        }
      };
      const handleAnimationStart = (event) => {
        if (event.target === node2) {
          prevAnimationNameRef.current = getAnimationName(stylesRef.current);
        }
      };
      node2.addEventListener("animationstart", handleAnimationStart);
      node2.addEventListener("animationcancel", handleAnimationEnd);
      node2.addEventListener("animationend", handleAnimationEnd);
      return () => {
        ownerWindow.clearTimeout(timeoutId);
        node2.removeEventListener("animationstart", handleAnimationStart);
        node2.removeEventListener("animationcancel", handleAnimationEnd);
        node2.removeEventListener("animationend", handleAnimationEnd);
      };
    } else {
      send("ANIMATION_END");
    }
  }, [node2, send]);
  return {
    isPresent: ["mounted", "unmountSuspended"].includes(state),
    ref: reactExports.useCallback((node22) => {
      if (node22) stylesRef.current = getComputedStyle(node22);
      setNode(node22);
    }, [])
  };
}
function getAnimationName(styles2) {
  return styles2?.animationName || "none";
}
function getElementRef(element) {
  let getter = Object.getOwnPropertyDescriptor(element.props, "ref")?.get;
  let mayWarn = getter && "isReactWarning" in getter && getter.isReactWarning;
  if (mayWarn) {
    return element.ref;
  }
  getter = Object.getOwnPropertyDescriptor(element, "ref")?.get;
  mayWarn = getter && "isReactWarning" in getter && getter.isReactWarning;
  if (mayWarn) {
    return element.props.ref;
  }
  return element.props.ref || element.ref;
}
function useControllableState({
  prop,
  defaultProp,
  onChange = () => {
  }
}) {
  const [uncontrolledProp, setUncontrolledProp] = useUncontrolledState({ defaultProp, onChange });
  const isControlled = prop !== void 0;
  const value = isControlled ? prop : uncontrolledProp;
  const handleChange = useCallbackRef$1(onChange);
  const setValue2 = reactExports.useCallback(
    (nextValue) => {
      if (isControlled) {
        const setter = nextValue;
        const value2 = typeof nextValue === "function" ? setter(prop) : nextValue;
        if (value2 !== prop) handleChange(value2);
      } else {
        setUncontrolledProp(nextValue);
      }
    },
    [isControlled, prop, setUncontrolledProp, handleChange]
  );
  return [value, setValue2];
}
function useUncontrolledState({
  defaultProp,
  onChange
}) {
  const uncontrolledState = reactExports.useState(defaultProp);
  const [value] = uncontrolledState;
  const prevValueRef = reactExports.useRef(value);
  const handleChange = useCallbackRef$1(onChange);
  reactExports.useEffect(() => {
    if (prevValueRef.current !== value) {
      handleChange(value);
      prevValueRef.current = value;
    }
  }, [value, prevValueRef, handleChange]);
  return uncontrolledState;
}
var NAME$1 = "VisuallyHidden";
var VisuallyHidden = reactExports.forwardRef(
  (props, forwardedRef) => {
    return /* @__PURE__ */ jsxRuntimeExports.jsx(
      Primitive.span,
      {
        ...props,
        ref: forwardedRef,
        style: {
          // See: https://github.com/twbs/bootstrap/blob/master/scss/mixins/_screen-reader.scss
          position: "absolute",
          border: 0,
          width: 1,
          height: 1,
          padding: 0,
          margin: -1,
          overflow: "hidden",
          clip: "rect(0, 0, 0, 0)",
          whiteSpace: "nowrap",
          wordWrap: "normal",
          ...props.style
        }
      }
    );
  }
);
VisuallyHidden.displayName = NAME$1;
var Root$6 = VisuallyHidden;
var [createTooltipContext, createTooltipScope] = createContextScope$3("Tooltip", [
  createPopperScope
]);
var usePopperScope = createPopperScope();
var PROVIDER_NAME = "TooltipProvider";
var DEFAULT_DELAY_DURATION = 700;
var TOOLTIP_OPEN = "tooltip.open";
var [TooltipProviderContextProvider, useTooltipProviderContext] = createTooltipContext(PROVIDER_NAME);
var TooltipProvider$1 = (props) => {
  const {
    __scopeTooltip,
    delayDuration = DEFAULT_DELAY_DURATION,
    skipDelayDuration = 300,
    disableHoverableContent = false,
    children
  } = props;
  const [isOpenDelayed, setIsOpenDelayed] = reactExports.useState(true);
  const isPointerInTransitRef = reactExports.useRef(false);
  const skipDelayTimerRef = reactExports.useRef(0);
  reactExports.useEffect(() => {
    const skipDelayTimer = skipDelayTimerRef.current;
    return () => window.clearTimeout(skipDelayTimer);
  }, []);
  return /* @__PURE__ */ jsxRuntimeExports.jsx(
    TooltipProviderContextProvider,
    {
      scope: __scopeTooltip,
      isOpenDelayed,
      delayDuration,
      onOpen: reactExports.useCallback(() => {
        window.clearTimeout(skipDelayTimerRef.current);
        setIsOpenDelayed(false);
      }, []),
      onClose: reactExports.useCallback(() => {
        window.clearTimeout(skipDelayTimerRef.current);
        skipDelayTimerRef.current = window.setTimeout(
          () => setIsOpenDelayed(true),
          skipDelayDuration
        );
      }, [skipDelayDuration]),
      isPointerInTransitRef,
      onPointerInTransitChange: reactExports.useCallback((inTransit) => {
        isPointerInTransitRef.current = inTransit;
      }, []),
      disableHoverableContent,
      children
    }
  );
};
TooltipProvider$1.displayName = PROVIDER_NAME;
var TOOLTIP_NAME = "Tooltip";
var [TooltipContextProvider, useTooltipContext] = createTooltipContext(TOOLTIP_NAME);
var TRIGGER_NAME$2 = "TooltipTrigger";
var TooltipTrigger = reactExports.forwardRef(
  (props, forwardedRef) => {
    const { __scopeTooltip, ...triggerProps } = props;
    const context = useTooltipContext(TRIGGER_NAME$2, __scopeTooltip);
    const providerContext = useTooltipProviderContext(TRIGGER_NAME$2, __scopeTooltip);
    const popperScope = usePopperScope(__scopeTooltip);
    const ref = reactExports.useRef(null);
    const composedRefs = useComposedRefs(forwardedRef, ref, context.onTriggerChange);
    const isPointerDownRef = reactExports.useRef(false);
    const hasPointerMoveOpenedRef = reactExports.useRef(false);
    const handlePointerUp = reactExports.useCallback(() => isPointerDownRef.current = false, []);
    reactExports.useEffect(() => {
      return () => document.removeEventListener("pointerup", handlePointerUp);
    }, [handlePointerUp]);
    return /* @__PURE__ */ jsxRuntimeExports.jsx(Anchor, { asChild: true, ...popperScope, children: /* @__PURE__ */ jsxRuntimeExports.jsx(
      Primitive.button,
      {
        "aria-describedby": context.open ? context.contentId : void 0,
        "data-state": context.stateAttribute,
        ...triggerProps,
        ref: composedRefs,
        onPointerMove: composeEventHandlers(props.onPointerMove, (event) => {
          if (event.pointerType === "touch") return;
          if (!hasPointerMoveOpenedRef.current && !providerContext.isPointerInTransitRef.current) {
            context.onTriggerEnter();
            hasPointerMoveOpenedRef.current = true;
          }
        }),
        onPointerLeave: composeEventHandlers(props.onPointerLeave, () => {
          context.onTriggerLeave();
          hasPointerMoveOpenedRef.current = false;
        }),
        onPointerDown: composeEventHandlers(props.onPointerDown, () => {
          isPointerDownRef.current = true;
          document.addEventListener("pointerup", handlePointerUp, { once: true });
        }),
        onFocus: composeEventHandlers(props.onFocus, () => {
          if (!isPointerDownRef.current) context.onOpen();
        }),
        onBlur: composeEventHandlers(props.onBlur, context.onClose),
        onClick: composeEventHandlers(props.onClick, context.onClose)
      }
    ) });
  }
);
TooltipTrigger.displayName = TRIGGER_NAME$2;
var PORTAL_NAME$1 = "TooltipPortal";
var [PortalProvider$1, usePortalContext$1] = createTooltipContext(PORTAL_NAME$1, {
  forceMount: void 0
});
var CONTENT_NAME$2 = "TooltipContent";
var TooltipContent$1 = reactExports.forwardRef(
  (props, forwardedRef) => {
    const portalContext = usePortalContext$1(CONTENT_NAME$2, props.__scopeTooltip);
    const { forceMount = portalContext.forceMount, side = "top", ...contentProps } = props;
    const context = useTooltipContext(CONTENT_NAME$2, props.__scopeTooltip);
    return /* @__PURE__ */ jsxRuntimeExports.jsx(Presence, { present: forceMount || context.open, children: context.disableHoverableContent ? /* @__PURE__ */ jsxRuntimeExports.jsx(TooltipContentImpl, { side, ...contentProps, ref: forwardedRef }) : /* @__PURE__ */ jsxRuntimeExports.jsx(TooltipContentHoverable, { side, ...contentProps, ref: forwardedRef }) });
  }
);
var TooltipContentHoverable = reactExports.forwardRef((props, forwardedRef) => {
  const context = useTooltipContext(CONTENT_NAME$2, props.__scopeTooltip);
  const providerContext = useTooltipProviderContext(CONTENT_NAME$2, props.__scopeTooltip);
  const ref = reactExports.useRef(null);
  const composedRefs = useComposedRefs(forwardedRef, ref);
  const [pointerGraceArea, setPointerGraceArea] = reactExports.useState(null);
  const { trigger, onClose } = context;
  const content = ref.current;
  const { onPointerInTransitChange } = providerContext;
  const handleRemoveGraceArea = reactExports.useCallback(() => {
    setPointerGraceArea(null);
    onPointerInTransitChange(false);
  }, [onPointerInTransitChange]);
  const handleCreateGraceArea = reactExports.useCallback(
    (event, hoverTarget) => {
      const currentTarget = event.currentTarget;
      const exitPoint = { x: event.clientX, y: event.clientY };
      const exitSide = getExitSideFromRect(exitPoint, currentTarget.getBoundingClientRect());
      const paddedExitPoints = getPaddedExitPoints(exitPoint, exitSide);
      const hoverTargetPoints = getPointsFromRect(hoverTarget.getBoundingClientRect());
      const graceArea = getHull([...paddedExitPoints, ...hoverTargetPoints]);
      setPointerGraceArea(graceArea);
      onPointerInTransitChange(true);
    },
    [onPointerInTransitChange]
  );
  reactExports.useEffect(() => {
    return () => handleRemoveGraceArea();
  }, [handleRemoveGraceArea]);
  reactExports.useEffect(() => {
    if (trigger && content) {
      const handleTriggerLeave = (event) => handleCreateGraceArea(event, content);
      const handleContentLeave = (event) => handleCreateGraceArea(event, trigger);
      trigger.addEventListener("pointerleave", handleTriggerLeave);
      content.addEventListener("pointerleave", handleContentLeave);
      return () => {
        trigger.removeEventListener("pointerleave", handleTriggerLeave);
        content.removeEventListener("pointerleave", handleContentLeave);
      };
    }
  }, [trigger, content, handleCreateGraceArea, handleRemoveGraceArea]);
  reactExports.useEffect(() => {
    if (pointerGraceArea) {
      const handleTrackPointerGrace = (event) => {
        const target = event.target;
        const pointerPosition = { x: event.clientX, y: event.clientY };
        const hasEnteredTarget = trigger?.contains(target) || content?.contains(target);
        const isPointerOutsideGraceArea = !isPointInPolygon(pointerPosition, pointerGraceArea);
        if (hasEnteredTarget) {
          handleRemoveGraceArea();
        } else if (isPointerOutsideGraceArea) {
          handleRemoveGraceArea();
          onClose();
        }
      };
      document.addEventListener("pointermove", handleTrackPointerGrace);
      return () => document.removeEventListener("pointermove", handleTrackPointerGrace);
    }
  }, [trigger, content, pointerGraceArea, onClose, handleRemoveGraceArea]);
  return /* @__PURE__ */ jsxRuntimeExports.jsx(TooltipContentImpl, { ...props, ref: composedRefs });
});
var [VisuallyHiddenContentContextProvider, useVisuallyHiddenContentContext] = createTooltipContext(TOOLTIP_NAME, { isInside: false });
var TooltipContentImpl = reactExports.forwardRef(
  (props, forwardedRef) => {
    const {
      __scopeTooltip,
      children,
      "aria-label": ariaLabel,
      onEscapeKeyDown,
      onPointerDownOutside,
      ...contentProps
    } = props;
    const context = useTooltipContext(CONTENT_NAME$2, __scopeTooltip);
    const popperScope = usePopperScope(__scopeTooltip);
    const { onClose } = context;
    reactExports.useEffect(() => {
      document.addEventListener(TOOLTIP_OPEN, onClose);
      return () => document.removeEventListener(TOOLTIP_OPEN, onClose);
    }, [onClose]);
    reactExports.useEffect(() => {
      if (context.trigger) {
        const handleScroll2 = (event) => {
          const target = event.target;
          if (target?.contains(context.trigger)) onClose();
        };
        window.addEventListener("scroll", handleScroll2, { capture: true });
        return () => window.removeEventListener("scroll", handleScroll2, { capture: true });
      }
    }, [context.trigger, onClose]);
    return /* @__PURE__ */ jsxRuntimeExports.jsx(
      DismissableLayer,
      {
        asChild: true,
        disableOutsidePointerEvents: false,
        onEscapeKeyDown,
        onPointerDownOutside,
        onFocusOutside: (event) => event.preventDefault(),
        onDismiss: onClose,
        children: /* @__PURE__ */ jsxRuntimeExports.jsxs(
          Content$2,
          {
            "data-state": context.stateAttribute,
            ...popperScope,
            ...contentProps,
            ref: forwardedRef,
            style: {
              ...contentProps.style,
              // re-namespace exposed content custom properties
              ...{
                "--radix-tooltip-content-transform-origin": "var(--radix-popper-transform-origin)",
                "--radix-tooltip-content-available-width": "var(--radix-popper-available-width)",
                "--radix-tooltip-content-available-height": "var(--radix-popper-available-height)",
                "--radix-tooltip-trigger-width": "var(--radix-popper-anchor-width)",
                "--radix-tooltip-trigger-height": "var(--radix-popper-anchor-height)"
              }
            },
            children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx(Slottable, { children }),
              /* @__PURE__ */ jsxRuntimeExports.jsx(VisuallyHiddenContentContextProvider, { scope: __scopeTooltip, isInside: true, children: /* @__PURE__ */ jsxRuntimeExports.jsx(Root$6, { id: context.contentId, role: "tooltip", children: ariaLabel || children }) })
            ]
          }
        )
      }
    );
  }
);
TooltipContent$1.displayName = CONTENT_NAME$2;
var ARROW_NAME = "TooltipArrow";
var TooltipArrow = reactExports.forwardRef(
  (props, forwardedRef) => {
    const { __scopeTooltip, ...arrowProps } = props;
    const popperScope = usePopperScope(__scopeTooltip);
    const visuallyHiddenContentContext = useVisuallyHiddenContentContext(
      ARROW_NAME,
      __scopeTooltip
    );
    return visuallyHiddenContentContext.isInside ? null : /* @__PURE__ */ jsxRuntimeExports.jsx(Arrow, { ...popperScope, ...arrowProps, ref: forwardedRef });
  }
);
TooltipArrow.displayName = ARROW_NAME;
function getExitSideFromRect(point2, rect) {
  const top = Math.abs(rect.top - point2.y);
  const bottom = Math.abs(rect.bottom - point2.y);
  const right = Math.abs(rect.right - point2.x);
  const left = Math.abs(rect.left - point2.x);
  switch (Math.min(top, bottom, right, left)) {
    case left:
      return "left";
    case right:
      return "right";
    case top:
      return "top";
    case bottom:
      return "bottom";
    default:
      throw new Error("unreachable");
  }
}
function getPaddedExitPoints(exitPoint, exitSide, padding2 = 5) {
  const paddedExitPoints = [];
  switch (exitSide) {
    case "top":
      paddedExitPoints.push(
        { x: exitPoint.x - padding2, y: exitPoint.y + padding2 },
        { x: exitPoint.x + padding2, y: exitPoint.y + padding2 }
      );
      break;
    case "bottom":
      paddedExitPoints.push(
        { x: exitPoint.x - padding2, y: exitPoint.y - padding2 },
        { x: exitPoint.x + padding2, y: exitPoint.y - padding2 }
      );
      break;
    case "left":
      paddedExitPoints.push(
        { x: exitPoint.x + padding2, y: exitPoint.y - padding2 },
        { x: exitPoint.x + padding2, y: exitPoint.y + padding2 }
      );
      break;
    case "right":
      paddedExitPoints.push(
        { x: exitPoint.x - padding2, y: exitPoint.y - padding2 },
        { x: exitPoint.x - padding2, y: exitPoint.y + padding2 }
      );
      break;
  }
  return paddedExitPoints;
}
function getPointsFromRect(rect) {
  const { top, right, bottom, left } = rect;
  return [
    { x: left, y: top },
    { x: right, y: top },
    { x: right, y: bottom },
    { x: left, y: bottom }
  ];
}
function isPointInPolygon(point2, polygon2) {
  const { x: x2, y: y2 } = point2;
  let inside = false;
  for (let i2 = 0, j2 = polygon2.length - 1; i2 < polygon2.length; j2 = i2++) {
    const xi = polygon2[i2].x;
    const yi = polygon2[i2].y;
    const xj = polygon2[j2].x;
    const yj = polygon2[j2].y;
    const intersect = yi > y2 !== yj > y2 && x2 < (xj - xi) * (y2 - yi) / (yj - yi) + xi;
    if (intersect) inside = !inside;
  }
  return inside;
}
function getHull(points) {
  const newPoints = points.slice();
  newPoints.sort((a2, b2) => {
    if (a2.x < b2.x) return -1;
    else if (a2.x > b2.x) return 1;
    else if (a2.y < b2.y) return -1;
    else if (a2.y > b2.y) return 1;
    else return 0;
  });
  return getHullPresorted(newPoints);
}
function getHullPresorted(points) {
  if (points.length <= 1) return points.slice();
  const upperHull = [];
  for (let i2 = 0; i2 < points.length; i2++) {
    const p2 = points[i2];
    while (upperHull.length >= 2) {
      const q2 = upperHull[upperHull.length - 1];
      const r2 = upperHull[upperHull.length - 2];
      if ((q2.x - r2.x) * (p2.y - r2.y) >= (q2.y - r2.y) * (p2.x - r2.x)) upperHull.pop();
      else break;
    }
    upperHull.push(p2);
  }
  upperHull.pop();
  const lowerHull = [];
  for (let i2 = points.length - 1; i2 >= 0; i2--) {
    const p2 = points[i2];
    while (lowerHull.length >= 2) {
      const q2 = lowerHull[lowerHull.length - 1];
      const r2 = lowerHull[lowerHull.length - 2];
      if ((q2.x - r2.x) * (p2.y - r2.y) >= (q2.y - r2.y) * (p2.x - r2.x)) lowerHull.pop();
      else break;
    }
    lowerHull.push(p2);
  }
  lowerHull.pop();
  if (upperHull.length === 1 && lowerHull.length === 1 && upperHull[0].x === lowerHull[0].x && upperHull[0].y === lowerHull[0].y) {
    return upperHull;
  } else {
    return upperHull.concat(lowerHull);
  }
}
var Provider = TooltipProvider$1;
var Content2 = TooltipContent$1;
const TooltipProvider = Provider;
const TooltipContent = reactExports.forwardRef(({ className, sideOffset = 4, ...props }, ref) => /* @__PURE__ */ jsxRuntimeExports.jsx(
  Content2,
  {
    ref,
    sideOffset,
    className: cn(
      "z-50 overflow-hidden rounded-md border bg-popover px-3 py-1.5 text-sm text-popover-foreground shadow-md animate-in fade-in-0 zoom-in-95 data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=closed]:zoom-out-95 data-[side=bottom]:slide-in-from-top-2 data-[side=left]:slide-in-from-right-2 data-[side=right]:slide-in-from-left-2 data-[side=top]:slide-in-from-bottom-2",
      className
    ),
    ...props
  }
));
TooltipContent.displayName = Content2.displayName;
var Subscribable = class {
  constructor() {
    this.listeners = /* @__PURE__ */ new Set();
    this.subscribe = this.subscribe.bind(this);
  }
  subscribe(listener) {
    this.listeners.add(listener);
    this.onSubscribe();
    return () => {
      this.listeners.delete(listener);
      this.onUnsubscribe();
    };
  }
  hasListeners() {
    return this.listeners.size > 0;
  }
  onSubscribe() {
  }
  onUnsubscribe() {
  }
};
var isServer = typeof window === "undefined" || "Deno" in globalThis;
function noop$5() {
  return void 0;
}
function functionalUpdate(updater, input) {
  return typeof updater === "function" ? updater(input) : updater;
}
function isValidTimeout(value) {
  return typeof value === "number" && value >= 0 && value !== Infinity;
}
function timeUntilStale(updatedAt, staleTime) {
  return Math.max(updatedAt + (staleTime || 0) - Date.now(), 0);
}
function resolveStaleTime(staleTime, query) {
  return typeof staleTime === "function" ? staleTime(query) : staleTime;
}
function resolveEnabled(enabled, query) {
  return typeof enabled === "function" ? enabled(query) : enabled;
}
function matchQuery(filters, query) {
  const {
    type = "all",
    exact,
    fetchStatus,
    predicate,
    queryKey,
    stale
  } = filters;
  if (queryKey) {
    if (exact) {
      if (query.queryHash !== hashQueryKeyByOptions(queryKey, query.options)) {
        return false;
      }
    } else if (!partialMatchKey(query.queryKey, queryKey)) {
      return false;
    }
  }
  if (type !== "all") {
    const isActive = query.isActive();
    if (type === "active" && !isActive) {
      return false;
    }
    if (type === "inactive" && isActive) {
      return false;
    }
  }
  if (typeof stale === "boolean" && query.isStale() !== stale) {
    return false;
  }
  if (fetchStatus && fetchStatus !== query.state.fetchStatus) {
    return false;
  }
  if (predicate && !predicate(query)) {
    return false;
  }
  return true;
}
function matchMutation(filters, mutation) {
  const { exact, status, predicate, mutationKey } = filters;
  if (mutationKey) {
    if (!mutation.options.mutationKey) {
      return false;
    }
    if (exact) {
      if (hashKey(mutation.options.mutationKey) !== hashKey(mutationKey)) {
        return false;
      }
    } else if (!partialMatchKey(mutation.options.mutationKey, mutationKey)) {
      return false;
    }
  }
  if (status && mutation.state.status !== status) {
    return false;
  }
  if (predicate && !predicate(mutation)) {
    return false;
  }
  return true;
}
function hashQueryKeyByOptions(queryKey, options) {
  const hashFn = options?.queryKeyHashFn || hashKey;
  return hashFn(queryKey);
}
function hashKey(queryKey) {
  return JSON.stringify(
    queryKey,
    (_2, val) => isPlainObject$1(val) ? Object.keys(val).sort().reduce((result, key2) => {
      result[key2] = val[key2];
      return result;
    }, {}) : val
  );
}
function partialMatchKey(a2, b2) {
  if (a2 === b2) {
    return true;
  }
  if (typeof a2 !== typeof b2) {
    return false;
  }
  if (a2 && b2 && typeof a2 === "object" && typeof b2 === "object") {
    return !Object.keys(b2).some((key2) => !partialMatchKey(a2[key2], b2[key2]));
  }
  return false;
}
function replaceEqualDeep(a2, b2) {
  if (a2 === b2) {
    return a2;
  }
  const array = isPlainArray(a2) && isPlainArray(b2);
  if (array || isPlainObject$1(a2) && isPlainObject$1(b2)) {
    const aItems = array ? a2 : Object.keys(a2);
    const aSize = aItems.length;
    const bItems = array ? b2 : Object.keys(b2);
    const bSize = bItems.length;
    const copy2 = array ? [] : {};
    let equalItems = 0;
    for (let i2 = 0; i2 < bSize; i2++) {
      const key2 = array ? i2 : bItems[i2];
      if ((!array && aItems.includes(key2) || array) && a2[key2] === void 0 && b2[key2] === void 0) {
        copy2[key2] = void 0;
        equalItems++;
      } else {
        copy2[key2] = replaceEqualDeep(a2[key2], b2[key2]);
        if (copy2[key2] === a2[key2] && a2[key2] !== void 0) {
          equalItems++;
        }
      }
    }
    return aSize === bSize && equalItems === aSize ? a2 : copy2;
  }
  return b2;
}
function shallowEqualObjects(a2, b2) {
  if (!b2 || Object.keys(a2).length !== Object.keys(b2).length) {
    return false;
  }
  for (const key2 in a2) {
    if (a2[key2] !== b2[key2]) {
      return false;
    }
  }
  return true;
}
function isPlainArray(value) {
  return Array.isArray(value) && value.length === Object.keys(value).length;
}
function isPlainObject$1(o) {
  if (!hasObjectPrototype(o)) {
    return false;
  }
  const ctor = o.constructor;
  if (ctor === void 0) {
    return true;
  }
  const prot = ctor.prototype;
  if (!hasObjectPrototype(prot)) {
    return false;
  }
  if (!prot.hasOwnProperty("isPrototypeOf")) {
    return false;
  }
  if (Object.getPrototypeOf(o) !== Object.prototype) {
    return false;
  }
  return true;
}
function hasObjectPrototype(o) {
  return Object.prototype.toString.call(o) === "[object Object]";
}
function sleep(timeout) {
  return new Promise((resolve) => {
    setTimeout(resolve, timeout);
  });
}
function replaceData(prevData, data, options) {
  if (typeof options.structuralSharing === "function") {
    return options.structuralSharing(prevData, data);
  } else if (options.structuralSharing !== false) {
    return replaceEqualDeep(prevData, data);
  }
  return data;
}
function addToEnd(items, item, max2 = 0) {
  const newItems = [...items, item];
  return max2 && newItems.length > max2 ? newItems.slice(1) : newItems;
}
function addToStart(items, item, max2 = 0) {
  const newItems = [item, ...items];
  return max2 && newItems.length > max2 ? newItems.slice(0, -1) : newItems;
}
var skipToken = Symbol();
function ensureQueryFn(options, fetchOptions) {
  if (!options.queryFn && fetchOptions?.initialPromise) {
    return () => fetchOptions.initialPromise;
  }
  if (!options.queryFn || options.queryFn === skipToken) {
    return () => Promise.reject(new Error(`Missing queryFn: '${options.queryHash}'`));
  }
  return options.queryFn;
}
var FocusManager = (_a = class extends Subscribable {
  constructor() {
    super();
    __privateAdd(this, _focused);
    __privateAdd(this, _cleanup);
    __privateAdd(this, _setup);
    __privateSet(this, _setup, (onFocus) => {
      if (!isServer && window.addEventListener) {
        const listener = () => onFocus();
        window.addEventListener("visibilitychange", listener, false);
        return () => {
          window.removeEventListener("visibilitychange", listener);
        };
      }
      return;
    });
  }
  onSubscribe() {
    if (!__privateGet(this, _cleanup)) {
      this.setEventListener(__privateGet(this, _setup));
    }
  }
  onUnsubscribe() {
    var _a2;
    if (!this.hasListeners()) {
      (_a2 = __privateGet(this, _cleanup)) == null ? void 0 : _a2.call(this);
      __privateSet(this, _cleanup, void 0);
    }
  }
  setEventListener(setup) {
    var _a2;
    __privateSet(this, _setup, setup);
    (_a2 = __privateGet(this, _cleanup)) == null ? void 0 : _a2.call(this);
    __privateSet(this, _cleanup, setup((focused) => {
      if (typeof focused === "boolean") {
        this.setFocused(focused);
      } else {
        this.onFocus();
      }
    }));
  }
  setFocused(focused) {
    const changed = __privateGet(this, _focused) !== focused;
    if (changed) {
      __privateSet(this, _focused, focused);
      this.onFocus();
    }
  }
  onFocus() {
    const isFocused = this.isFocused();
    this.listeners.forEach((listener) => {
      listener(isFocused);
    });
  }
  isFocused() {
    if (typeof __privateGet(this, _focused) === "boolean") {
      return __privateGet(this, _focused);
    }
    return globalThis.document?.visibilityState !== "hidden";
  }
}, _focused = new WeakMap(), _cleanup = new WeakMap(), _setup = new WeakMap(), _a);
var focusManager = new FocusManager();
var OnlineManager = (_b = class extends Subscribable {
  constructor() {
    super();
    __privateAdd(this, _online, true);
    __privateAdd(this, _cleanup2);
    __privateAdd(this, _setup2);
    __privateSet(this, _setup2, (onOnline) => {
      if (!isServer && window.addEventListener) {
        const onlineListener = () => onOnline(true);
        const offlineListener = () => onOnline(false);
        window.addEventListener("online", onlineListener, false);
        window.addEventListener("offline", offlineListener, false);
        return () => {
          window.removeEventListener("online", onlineListener);
          window.removeEventListener("offline", offlineListener);
        };
      }
      return;
    });
  }
  onSubscribe() {
    if (!__privateGet(this, _cleanup2)) {
      this.setEventListener(__privateGet(this, _setup2));
    }
  }
  onUnsubscribe() {
    var _a2;
    if (!this.hasListeners()) {
      (_a2 = __privateGet(this, _cleanup2)) == null ? void 0 : _a2.call(this);
      __privateSet(this, _cleanup2, void 0);
    }
  }
  setEventListener(setup) {
    var _a2;
    __privateSet(this, _setup2, setup);
    (_a2 = __privateGet(this, _cleanup2)) == null ? void 0 : _a2.call(this);
    __privateSet(this, _cleanup2, setup(this.setOnline.bind(this)));
  }
  setOnline(online) {
    const changed = __privateGet(this, _online) !== online;
    if (changed) {
      __privateSet(this, _online, online);
      this.listeners.forEach((listener) => {
        listener(online);
      });
    }
  }
  isOnline() {
    return __privateGet(this, _online);
  }
}, _online = new WeakMap(), _cleanup2 = new WeakMap(), _setup2 = new WeakMap(), _b);
var onlineManager = new OnlineManager();
function pendingThenable() {
  let resolve;
  let reject;
  const thenable = new Promise((_resolve, _reject) => {
    resolve = _resolve;
    reject = _reject;
  });
  thenable.status = "pending";
  thenable.catch(() => {
  });
  function finalize(data) {
    Object.assign(thenable, data);
    delete thenable.resolve;
    delete thenable.reject;
  }
  thenable.resolve = (value) => {
    finalize({
      status: "fulfilled",
      value
    });
    resolve(value);
  };
  thenable.reject = (reason) => {
    finalize({
      status: "rejected",
      reason
    });
    reject(reason);
  };
  return thenable;
}
function defaultRetryDelay(failureCount) {
  return Math.min(1e3 * 2 ** failureCount, 3e4);
}
function canFetch(networkMode) {
  return (networkMode ?? "online") === "online" ? onlineManager.isOnline() : true;
}
var CancelledError = class extends Error {
  constructor(options) {
    super("CancelledError");
    this.revert = options?.revert;
    this.silent = options?.silent;
  }
};
function isCancelledError(value) {
  return value instanceof CancelledError;
}
function createRetryer(config2) {
  let isRetryCancelled = false;
  let failureCount = 0;
  let isResolved = false;
  let continueFn;
  const thenable = pendingThenable();
  const cancel = (cancelOptions) => {
    if (!isResolved) {
      reject(new CancelledError(cancelOptions));
      config2.abort?.();
    }
  };
  const cancelRetry = () => {
    isRetryCancelled = true;
  };
  const continueRetry = () => {
    isRetryCancelled = false;
  };
  const canContinue = () => focusManager.isFocused() && (config2.networkMode === "always" || onlineManager.isOnline()) && config2.canRun();
  const canStart = () => canFetch(config2.networkMode) && config2.canRun();
  const resolve = (value) => {
    if (!isResolved) {
      isResolved = true;
      config2.onSuccess?.(value);
      continueFn?.();
      thenable.resolve(value);
    }
  };
  const reject = (value) => {
    if (!isResolved) {
      isResolved = true;
      config2.onError?.(value);
      continueFn?.();
      thenable.reject(value);
    }
  };
  const pause = () => {
    return new Promise((continueResolve) => {
      continueFn = (value) => {
        if (isResolved || canContinue()) {
          continueResolve(value);
        }
      };
      config2.onPause?.();
    }).then(() => {
      continueFn = void 0;
      if (!isResolved) {
        config2.onContinue?.();
      }
    });
  };
  const run = () => {
    if (isResolved) {
      return;
    }
    let promiseOrValue;
    const initialPromise = failureCount === 0 ? config2.initialPromise : void 0;
    try {
      promiseOrValue = initialPromise ?? config2.fn();
    } catch (error) {
      promiseOrValue = Promise.reject(error);
    }
    Promise.resolve(promiseOrValue).then(resolve).catch((error) => {
      if (isResolved) {
        return;
      }
      const retry = config2.retry ?? (isServer ? 0 : 3);
      const retryDelay = config2.retryDelay ?? defaultRetryDelay;
      const delay2 = typeof retryDelay === "function" ? retryDelay(failureCount, error) : retryDelay;
      const shouldRetry = retry === true || typeof retry === "number" && failureCount < retry || typeof retry === "function" && retry(failureCount, error);
      if (isRetryCancelled || !shouldRetry) {
        reject(error);
        return;
      }
      failureCount++;
      config2.onFail?.(failureCount, error);
      sleep(delay2).then(() => {
        return canContinue() ? void 0 : pause();
      }).then(() => {
        if (isRetryCancelled) {
          reject(error);
        } else {
          run();
        }
      });
    });
  };
  return {
    promise: thenable,
    cancel,
    continue: () => {
      continueFn?.();
      return thenable;
    },
    cancelRetry,
    continueRetry,
    canStart,
    start: () => {
      if (canStart()) {
        run();
      } else {
        pause().then(run);
      }
      return thenable;
    }
  };
}
function createNotifyManager() {
  let queue = [];
  let transactions = 0;
  let notifyFn = (callback) => {
    callback();
  };
  let batchNotifyFn = (callback) => {
    callback();
  };
  let scheduleFn = (cb) => setTimeout(cb, 0);
  const schedule = (callback) => {
    if (transactions) {
      queue.push(callback);
    } else {
      scheduleFn(() => {
        notifyFn(callback);
      });
    }
  };
  const flush = () => {
    const originalQueue = queue;
    queue = [];
    if (originalQueue.length) {
      scheduleFn(() => {
        batchNotifyFn(() => {
          originalQueue.forEach((callback) => {
            notifyFn(callback);
          });
        });
      });
    }
  };
  return {
    batch: (callback) => {
      let result;
      transactions++;
      try {
        result = callback();
      } finally {
        transactions--;
        if (!transactions) {
          flush();
        }
      }
      return result;
    },
    /**
     * All calls to the wrapped function will be batched.
     */
    batchCalls: (callback) => {
      return (...args) => {
        schedule(() => {
          callback(...args);
        });
      };
    },
    schedule,
    /**
     * Use this method to set a custom notify function.
     * This can be used to for example wrap notifications with `React.act` while running tests.
     */
    setNotifyFunction: (fn) => {
      notifyFn = fn;
    },
    /**
     * Use this method to set a custom function to batch notifications together into a single tick.
     * By default React Query will use the batch function provided by ReactDOM or React Native.
     */
    setBatchNotifyFunction: (fn) => {
      batchNotifyFn = fn;
    },
    setScheduler: (fn) => {
      scheduleFn = fn;
    }
  };
}
var notifyManager = createNotifyManager();
var Removable = (_c = class {
  constructor() {
    __privateAdd(this, _gcTimeout);
  }
  destroy() {
    this.clearGcTimeout();
  }
  scheduleGc() {
    this.clearGcTimeout();
    if (isValidTimeout(this.gcTime)) {
      __privateSet(this, _gcTimeout, setTimeout(() => {
        this.optionalRemove();
      }, this.gcTime));
    }
  }
  updateGcTime(newGcTime) {
    this.gcTime = Math.max(
      this.gcTime || 0,
      newGcTime ?? (isServer ? Infinity : 5 * 60 * 1e3)
    );
  }
  clearGcTimeout() {
    if (__privateGet(this, _gcTimeout)) {
      clearTimeout(__privateGet(this, _gcTimeout));
      __privateSet(this, _gcTimeout, void 0);
    }
  }
}, _gcTimeout = new WeakMap(), _c);
var Query = (_d = class extends Removable {
  constructor(config2) {
    super();
    __privateAdd(this, _Query_instances);
    __privateAdd(this, _initialState);
    __privateAdd(this, _revertState);
    __privateAdd(this, _cache);
    __privateAdd(this, _retryer);
    __privateAdd(this, _defaultOptions);
    __privateAdd(this, _abortSignalConsumed);
    __privateSet(this, _abortSignalConsumed, false);
    __privateSet(this, _defaultOptions, config2.defaultOptions);
    this.setOptions(config2.options);
    this.observers = [];
    __privateSet(this, _cache, config2.cache);
    this.queryKey = config2.queryKey;
    this.queryHash = config2.queryHash;
    __privateSet(this, _initialState, getDefaultState$1(this.options));
    this.state = config2.state ?? __privateGet(this, _initialState);
    this.scheduleGc();
  }
  get meta() {
    return this.options.meta;
  }
  get promise() {
    return __privateGet(this, _retryer)?.promise;
  }
  setOptions(options) {
    this.options = { ...__privateGet(this, _defaultOptions), ...options };
    this.updateGcTime(this.options.gcTime);
  }
  optionalRemove() {
    if (!this.observers.length && this.state.fetchStatus === "idle") {
      __privateGet(this, _cache).remove(this);
    }
  }
  setData(newData, options) {
    const data = replaceData(this.state.data, newData, this.options);
    __privateMethod(this, _Query_instances, dispatch_fn).call(this, {
      data,
      type: "success",
      dataUpdatedAt: options?.updatedAt,
      manual: options?.manual
    });
    return data;
  }
  setState(state, setStateOptions) {
    __privateMethod(this, _Query_instances, dispatch_fn).call(this, { type: "setState", state, setStateOptions });
  }
  cancel(options) {
    const promise = __privateGet(this, _retryer)?.promise;
    __privateGet(this, _retryer)?.cancel(options);
    return promise ? promise.then(noop$5).catch(noop$5) : Promise.resolve();
  }
  destroy() {
    super.destroy();
    this.cancel({ silent: true });
  }
  reset() {
    this.destroy();
    this.setState(__privateGet(this, _initialState));
  }
  isActive() {
    return this.observers.some(
      (observer) => resolveEnabled(observer.options.enabled, this) !== false
    );
  }
  isDisabled() {
    if (this.getObserversCount() > 0) {
      return !this.isActive();
    }
    return this.options.queryFn === skipToken || this.state.dataUpdateCount + this.state.errorUpdateCount === 0;
  }
  isStale() {
    if (this.state.isInvalidated) {
      return true;
    }
    if (this.getObserversCount() > 0) {
      return this.observers.some(
        (observer) => observer.getCurrentResult().isStale
      );
    }
    return this.state.data === void 0;
  }
  isStaleByTime(staleTime = 0) {
    return this.state.isInvalidated || this.state.data === void 0 || !timeUntilStale(this.state.dataUpdatedAt, staleTime);
  }
  onFocus() {
    const observer = this.observers.find((x2) => x2.shouldFetchOnWindowFocus());
    observer?.refetch({ cancelRefetch: false });
    __privateGet(this, _retryer)?.continue();
  }
  onOnline() {
    const observer = this.observers.find((x2) => x2.shouldFetchOnReconnect());
    observer?.refetch({ cancelRefetch: false });
    __privateGet(this, _retryer)?.continue();
  }
  addObserver(observer) {
    if (!this.observers.includes(observer)) {
      this.observers.push(observer);
      this.clearGcTimeout();
      __privateGet(this, _cache).notify({ type: "observerAdded", query: this, observer });
    }
  }
  removeObserver(observer) {
    if (this.observers.includes(observer)) {
      this.observers = this.observers.filter((x2) => x2 !== observer);
      if (!this.observers.length) {
        if (__privateGet(this, _retryer)) {
          if (__privateGet(this, _abortSignalConsumed)) {
            __privateGet(this, _retryer).cancel({ revert: true });
          } else {
            __privateGet(this, _retryer).cancelRetry();
          }
        }
        this.scheduleGc();
      }
      __privateGet(this, _cache).notify({ type: "observerRemoved", query: this, observer });
    }
  }
  getObserversCount() {
    return this.observers.length;
  }
  invalidate() {
    if (!this.state.isInvalidated) {
      __privateMethod(this, _Query_instances, dispatch_fn).call(this, { type: "invalidate" });
    }
  }
  fetch(options, fetchOptions) {
    if (this.state.fetchStatus !== "idle") {
      if (this.state.data !== void 0 && fetchOptions?.cancelRefetch) {
        this.cancel({ silent: true });
      } else if (__privateGet(this, _retryer)) {
        __privateGet(this, _retryer).continueRetry();
        return __privateGet(this, _retryer).promise;
      }
    }
    if (options) {
      this.setOptions(options);
    }
    if (!this.options.queryFn) {
      const observer = this.observers.find((x2) => x2.options.queryFn);
      if (observer) {
        this.setOptions(observer.options);
      }
    }
    const abortController = new AbortController();
    const addSignalProperty = (object) => {
      Object.defineProperty(object, "signal", {
        enumerable: true,
        get: () => {
          __privateSet(this, _abortSignalConsumed, true);
          return abortController.signal;
        }
      });
    };
    const fetchFn = () => {
      const queryFn = ensureQueryFn(this.options, fetchOptions);
      const queryFnContext = {
        queryKey: this.queryKey,
        meta: this.meta
      };
      addSignalProperty(queryFnContext);
      __privateSet(this, _abortSignalConsumed, false);
      if (this.options.persister) {
        return this.options.persister(
          queryFn,
          queryFnContext,
          this
        );
      }
      return queryFn(queryFnContext);
    };
    const context = {
      fetchOptions,
      options: this.options,
      queryKey: this.queryKey,
      state: this.state,
      fetchFn
    };
    addSignalProperty(context);
    this.options.behavior?.onFetch(
      context,
      this
    );
    __privateSet(this, _revertState, this.state);
    if (this.state.fetchStatus === "idle" || this.state.fetchMeta !== context.fetchOptions?.meta) {
      __privateMethod(this, _Query_instances, dispatch_fn).call(this, { type: "fetch", meta: context.fetchOptions?.meta });
    }
    const onError = (error) => {
      if (!(isCancelledError(error) && error.silent)) {
        __privateMethod(this, _Query_instances, dispatch_fn).call(this, {
          type: "error",
          error
        });
      }
      if (!isCancelledError(error)) {
        __privateGet(this, _cache).config.onError?.(
          error,
          this
        );
        __privateGet(this, _cache).config.onSettled?.(
          this.state.data,
          error,
          this
        );
      }
      this.scheduleGc();
    };
    __privateSet(this, _retryer, createRetryer({
      initialPromise: fetchOptions?.initialPromise,
      fn: context.fetchFn,
      abort: abortController.abort.bind(abortController),
      onSuccess: (data) => {
        if (data === void 0) {
          onError(new Error(`${this.queryHash} data is undefined`));
          return;
        }
        try {
          this.setData(data);
        } catch (error) {
          onError(error);
          return;
        }
        __privateGet(this, _cache).config.onSuccess?.(data, this);
        __privateGet(this, _cache).config.onSettled?.(
          data,
          this.state.error,
          this
        );
        this.scheduleGc();
      },
      onError,
      onFail: (failureCount, error) => {
        __privateMethod(this, _Query_instances, dispatch_fn).call(this, { type: "failed", failureCount, error });
      },
      onPause: () => {
        __privateMethod(this, _Query_instances, dispatch_fn).call(this, { type: "pause" });
      },
      onContinue: () => {
        __privateMethod(this, _Query_instances, dispatch_fn).call(this, { type: "continue" });
      },
      retry: context.options.retry,
      retryDelay: context.options.retryDelay,
      networkMode: context.options.networkMode,
      canRun: () => true
    }));
    return __privateGet(this, _retryer).start();
  }
}, _initialState = new WeakMap(), _revertState = new WeakMap(), _cache = new WeakMap(), _retryer = new WeakMap(), _defaultOptions = new WeakMap(), _abortSignalConsumed = new WeakMap(), _Query_instances = new WeakSet(), dispatch_fn = function(action) {
  const reducer2 = (state) => {
    switch (action.type) {
      case "failed":
        return {
          ...state,
          fetchFailureCount: action.failureCount,
          fetchFailureReason: action.error
        };
      case "pause":
        return {
          ...state,
          fetchStatus: "paused"
        };
      case "continue":
        return {
          ...state,
          fetchStatus: "fetching"
        };
      case "fetch":
        return {
          ...state,
          ...fetchState(state.data, this.options),
          fetchMeta: action.meta ?? null
        };
      case "success":
        return {
          ...state,
          data: action.data,
          dataUpdateCount: state.dataUpdateCount + 1,
          dataUpdatedAt: action.dataUpdatedAt ?? Date.now(),
          error: null,
          isInvalidated: false,
          status: "success",
          ...!action.manual && {
            fetchStatus: "idle",
            fetchFailureCount: 0,
            fetchFailureReason: null
          }
        };
      case "error":
        const error = action.error;
        if (isCancelledError(error) && error.revert && __privateGet(this, _revertState)) {
          return { ...__privateGet(this, _revertState), fetchStatus: "idle" };
        }
        return {
          ...state,
          error,
          errorUpdateCount: state.errorUpdateCount + 1,
          errorUpdatedAt: Date.now(),
          fetchFailureCount: state.fetchFailureCount + 1,
          fetchFailureReason: error,
          fetchStatus: "idle",
          status: "error"
        };
      case "invalidate":
        return {
          ...state,
          isInvalidated: true
        };
      case "setState":
        return {
          ...state,
          ...action.state
        };
    }
  };
  this.state = reducer2(this.state);
  notifyManager.batch(() => {
    this.observers.forEach((observer) => {
      observer.onQueryUpdate();
    });
    __privateGet(this, _cache).notify({ query: this, type: "updated", action });
  });
}, _d);
function fetchState(data, options) {
  return {
    fetchFailureCount: 0,
    fetchFailureReason: null,
    fetchStatus: canFetch(options.networkMode) ? "fetching" : "paused",
    ...data === void 0 && {
      error: null,
      status: "pending"
    }
  };
}
function getDefaultState$1(options) {
  const data = typeof options.initialData === "function" ? options.initialData() : options.initialData;
  const hasData = data !== void 0;
  const initialDataUpdatedAt = hasData ? typeof options.initialDataUpdatedAt === "function" ? options.initialDataUpdatedAt() : options.initialDataUpdatedAt : 0;
  return {
    data,
    dataUpdateCount: 0,
    dataUpdatedAt: hasData ? initialDataUpdatedAt ?? Date.now() : 0,
    error: null,
    errorUpdateCount: 0,
    errorUpdatedAt: 0,
    fetchFailureCount: 0,
    fetchFailureReason: null,
    fetchMeta: null,
    isInvalidated: false,
    status: hasData ? "success" : "pending",
    fetchStatus: "idle"
  };
}
var QueryCache = (_e = class extends Subscribable {
  constructor(config2 = {}) {
    super();
    __privateAdd(this, _queries);
    this.config = config2;
    __privateSet(this, _queries, /* @__PURE__ */ new Map());
  }
  build(client, options, state) {
    const queryKey = options.queryKey;
    const queryHash = options.queryHash ?? hashQueryKeyByOptions(queryKey, options);
    let query = this.get(queryHash);
    if (!query) {
      query = new Query({
        cache: this,
        queryKey,
        queryHash,
        options: client.defaultQueryOptions(options),
        state,
        defaultOptions: client.getQueryDefaults(queryKey)
      });
      this.add(query);
    }
    return query;
  }
  add(query) {
    if (!__privateGet(this, _queries).has(query.queryHash)) {
      __privateGet(this, _queries).set(query.queryHash, query);
      this.notify({
        type: "added",
        query
      });
    }
  }
  remove(query) {
    const queryInMap = __privateGet(this, _queries).get(query.queryHash);
    if (queryInMap) {
      query.destroy();
      if (queryInMap === query) {
        __privateGet(this, _queries).delete(query.queryHash);
      }
      this.notify({ type: "removed", query });
    }
  }
  clear() {
    notifyManager.batch(() => {
      this.getAll().forEach((query) => {
        this.remove(query);
      });
    });
  }
  get(queryHash) {
    return __privateGet(this, _queries).get(queryHash);
  }
  getAll() {
    return [...__privateGet(this, _queries).values()];
  }
  find(filters) {
    const defaultedFilters = { exact: true, ...filters };
    return this.getAll().find(
      (query) => matchQuery(defaultedFilters, query)
    );
  }
  findAll(filters = {}) {
    const queries = this.getAll();
    return Object.keys(filters).length > 0 ? queries.filter((query) => matchQuery(filters, query)) : queries;
  }
  notify(event) {
    notifyManager.batch(() => {
      this.listeners.forEach((listener) => {
        listener(event);
      });
    });
  }
  onFocus() {
    notifyManager.batch(() => {
      this.getAll().forEach((query) => {
        query.onFocus();
      });
    });
  }
  onOnline() {
    notifyManager.batch(() => {
      this.getAll().forEach((query) => {
        query.onOnline();
      });
    });
  }
}, _queries = new WeakMap(), _e);
var Mutation = (_f = class extends Removable {
  constructor(config2) {
    super();
    __privateAdd(this, _Mutation_instances);
    __privateAdd(this, _observers);
    __privateAdd(this, _mutationCache);
    __privateAdd(this, _retryer2);
    this.mutationId = config2.mutationId;
    __privateSet(this, _mutationCache, config2.mutationCache);
    __privateSet(this, _observers, []);
    this.state = config2.state || getDefaultState();
    this.setOptions(config2.options);
    this.scheduleGc();
  }
  setOptions(options) {
    this.options = options;
    this.updateGcTime(this.options.gcTime);
  }
  get meta() {
    return this.options.meta;
  }
  addObserver(observer) {
    if (!__privateGet(this, _observers).includes(observer)) {
      __privateGet(this, _observers).push(observer);
      this.clearGcTimeout();
      __privateGet(this, _mutationCache).notify({
        type: "observerAdded",
        mutation: this,
        observer
      });
    }
  }
  removeObserver(observer) {
    __privateSet(this, _observers, __privateGet(this, _observers).filter((x2) => x2 !== observer));
    this.scheduleGc();
    __privateGet(this, _mutationCache).notify({
      type: "observerRemoved",
      mutation: this,
      observer
    });
  }
  optionalRemove() {
    if (!__privateGet(this, _observers).length) {
      if (this.state.status === "pending") {
        this.scheduleGc();
      } else {
        __privateGet(this, _mutationCache).remove(this);
      }
    }
  }
  continue() {
    return __privateGet(this, _retryer2)?.continue() ?? // continuing a mutation assumes that variables are set, mutation must have been dehydrated before
    this.execute(this.state.variables);
  }
  async execute(variables) {
    __privateSet(this, _retryer2, createRetryer({
      fn: () => {
        if (!this.options.mutationFn) {
          return Promise.reject(new Error("No mutationFn found"));
        }
        return this.options.mutationFn(variables);
      },
      onFail: (failureCount, error) => {
        __privateMethod(this, _Mutation_instances, dispatch_fn2).call(this, { type: "failed", failureCount, error });
      },
      onPause: () => {
        __privateMethod(this, _Mutation_instances, dispatch_fn2).call(this, { type: "pause" });
      },
      onContinue: () => {
        __privateMethod(this, _Mutation_instances, dispatch_fn2).call(this, { type: "continue" });
      },
      retry: this.options.retry ?? 0,
      retryDelay: this.options.retryDelay,
      networkMode: this.options.networkMode,
      canRun: () => __privateGet(this, _mutationCache).canRun(this)
    }));
    const restored = this.state.status === "pending";
    const isPaused = !__privateGet(this, _retryer2).canStart();
    try {
      if (!restored) {
        __privateMethod(this, _Mutation_instances, dispatch_fn2).call(this, { type: "pending", variables, isPaused });
        await __privateGet(this, _mutationCache).config.onMutate?.(
          variables,
          this
        );
        const context = await this.options.onMutate?.(variables);
        if (context !== this.state.context) {
          __privateMethod(this, _Mutation_instances, dispatch_fn2).call(this, {
            type: "pending",
            context,
            variables,
            isPaused
          });
        }
      }
      const data = await __privateGet(this, _retryer2).start();
      await __privateGet(this, _mutationCache).config.onSuccess?.(
        data,
        variables,
        this.state.context,
        this
      );
      await this.options.onSuccess?.(data, variables, this.state.context);
      await __privateGet(this, _mutationCache).config.onSettled?.(
        data,
        null,
        this.state.variables,
        this.state.context,
        this
      );
      await this.options.onSettled?.(data, null, variables, this.state.context);
      __privateMethod(this, _Mutation_instances, dispatch_fn2).call(this, { type: "success", data });
      return data;
    } catch (error) {
      try {
        await __privateGet(this, _mutationCache).config.onError?.(
          error,
          variables,
          this.state.context,
          this
        );
        await this.options.onError?.(
          error,
          variables,
          this.state.context
        );
        await __privateGet(this, _mutationCache).config.onSettled?.(
          void 0,
          error,
          this.state.variables,
          this.state.context,
          this
        );
        await this.options.onSettled?.(
          void 0,
          error,
          variables,
          this.state.context
        );
        throw error;
      } finally {
        __privateMethod(this, _Mutation_instances, dispatch_fn2).call(this, { type: "error", error });
      }
    } finally {
      __privateGet(this, _mutationCache).runNext(this);
    }
  }
}, _observers = new WeakMap(), _mutationCache = new WeakMap(), _retryer2 = new WeakMap(), _Mutation_instances = new WeakSet(), dispatch_fn2 = function(action) {
  const reducer2 = (state) => {
    switch (action.type) {
      case "failed":
        return {
          ...state,
          failureCount: action.failureCount,
          failureReason: action.error
        };
      case "pause":
        return {
          ...state,
          isPaused: true
        };
      case "continue":
        return {
          ...state,
          isPaused: false
        };
      case "pending":
        return {
          ...state,
          context: action.context,
          data: void 0,
          failureCount: 0,
          failureReason: null,
          error: null,
          isPaused: action.isPaused,
          status: "pending",
          variables: action.variables,
          submittedAt: Date.now()
        };
      case "success":
        return {
          ...state,
          data: action.data,
          failureCount: 0,
          failureReason: null,
          error: null,
          status: "success",
          isPaused: false
        };
      case "error":
        return {
          ...state,
          data: void 0,
          error: action.error,
          failureCount: state.failureCount + 1,
          failureReason: action.error,
          isPaused: false,
          status: "error"
        };
    }
  };
  this.state = reducer2(this.state);
  notifyManager.batch(() => {
    __privateGet(this, _observers).forEach((observer) => {
      observer.onMutationUpdate(action);
    });
    __privateGet(this, _mutationCache).notify({
      mutation: this,
      type: "updated",
      action
    });
  });
}, _f);
function getDefaultState() {
  return {
    context: void 0,
    data: void 0,
    error: null,
    failureCount: 0,
    failureReason: null,
    isPaused: false,
    status: "idle",
    variables: void 0,
    submittedAt: 0
  };
}
var MutationCache = (_g = class extends Subscribable {
  constructor(config2 = {}) {
    super();
    __privateAdd(this, _mutations);
    __privateAdd(this, _mutationId);
    this.config = config2;
    __privateSet(this, _mutations, /* @__PURE__ */ new Map());
    __privateSet(this, _mutationId, Date.now());
  }
  build(client, options, state) {
    const mutation = new Mutation({
      mutationCache: this,
      mutationId: ++__privateWrapper(this, _mutationId)._,
      options: client.defaultMutationOptions(options),
      state
    });
    this.add(mutation);
    return mutation;
  }
  add(mutation) {
    const scope = scopeFor(mutation);
    const mutations = __privateGet(this, _mutations).get(scope) ?? [];
    mutations.push(mutation);
    __privateGet(this, _mutations).set(scope, mutations);
    this.notify({ type: "added", mutation });
  }
  remove(mutation) {
    const scope = scopeFor(mutation);
    if (__privateGet(this, _mutations).has(scope)) {
      const mutations = __privateGet(this, _mutations).get(scope)?.filter((x2) => x2 !== mutation);
      if (mutations) {
        if (mutations.length === 0) {
          __privateGet(this, _mutations).delete(scope);
        } else {
          __privateGet(this, _mutations).set(scope, mutations);
        }
      }
    }
    this.notify({ type: "removed", mutation });
  }
  canRun(mutation) {
    const firstPendingMutation = __privateGet(this, _mutations).get(scopeFor(mutation))?.find((m2) => m2.state.status === "pending");
    return !firstPendingMutation || firstPendingMutation === mutation;
  }
  runNext(mutation) {
    const foundMutation = __privateGet(this, _mutations).get(scopeFor(mutation))?.find((m2) => m2 !== mutation && m2.state.isPaused);
    return foundMutation?.continue() ?? Promise.resolve();
  }
  clear() {
    notifyManager.batch(() => {
      this.getAll().forEach((mutation) => {
        this.remove(mutation);
      });
    });
  }
  getAll() {
    return [...__privateGet(this, _mutations).values()].flat();
  }
  find(filters) {
    const defaultedFilters = { exact: true, ...filters };
    return this.getAll().find(
      (mutation) => matchMutation(defaultedFilters, mutation)
    );
  }
  findAll(filters = {}) {
    return this.getAll().filter((mutation) => matchMutation(filters, mutation));
  }
  notify(event) {
    notifyManager.batch(() => {
      this.listeners.forEach((listener) => {
        listener(event);
      });
    });
  }
  resumePausedMutations() {
    const pausedMutations = this.getAll().filter((x2) => x2.state.isPaused);
    return notifyManager.batch(
      () => Promise.all(
        pausedMutations.map((mutation) => mutation.continue().catch(noop$5))
      )
    );
  }
}, _mutations = new WeakMap(), _mutationId = new WeakMap(), _g);
function scopeFor(mutation) {
  return mutation.options.scope?.id ?? String(mutation.mutationId);
}
function infiniteQueryBehavior(pages) {
  return {
    onFetch: (context, query) => {
      const options = context.options;
      const direction = context.fetchOptions?.meta?.fetchMore?.direction;
      const oldPages = context.state.data?.pages || [];
      const oldPageParams = context.state.data?.pageParams || [];
      let result = { pages: [], pageParams: [] };
      let currentPage = 0;
      const fetchFn = async () => {
        let cancelled = false;
        const addSignalProperty = (object) => {
          Object.defineProperty(object, "signal", {
            enumerable: true,
            get: () => {
              if (context.signal.aborted) {
                cancelled = true;
              } else {
                context.signal.addEventListener("abort", () => {
                  cancelled = true;
                });
              }
              return context.signal;
            }
          });
        };
        const queryFn = ensureQueryFn(context.options, context.fetchOptions);
        const fetchPage = async (data, param, previous) => {
          if (cancelled) {
            return Promise.reject();
          }
          if (param == null && data.pages.length) {
            return Promise.resolve(data);
          }
          const queryFnContext = {
            queryKey: context.queryKey,
            pageParam: param,
            direction: previous ? "backward" : "forward",
            meta: context.options.meta
          };
          addSignalProperty(queryFnContext);
          const page = await queryFn(
            queryFnContext
          );
          const { maxPages } = context.options;
          const addTo = previous ? addToStart : addToEnd;
          return {
            pages: addTo(data.pages, page, maxPages),
            pageParams: addTo(data.pageParams, param, maxPages)
          };
        };
        if (direction && oldPages.length) {
          const previous = direction === "backward";
          const pageParamFn = previous ? getPreviousPageParam : getNextPageParam;
          const oldData = {
            pages: oldPages,
            pageParams: oldPageParams
          };
          const param = pageParamFn(options, oldData);
          result = await fetchPage(oldData, param, previous);
        } else {
          const remainingPages = pages ?? oldPages.length;
          do {
            const param = currentPage === 0 ? oldPageParams[0] ?? options.initialPageParam : getNextPageParam(options, result);
            if (currentPage > 0 && param == null) {
              break;
            }
            result = await fetchPage(result, param);
            currentPage++;
          } while (currentPage < remainingPages);
        }
        return result;
      };
      if (context.options.persister) {
        context.fetchFn = () => {
          return context.options.persister?.(
            fetchFn,
            {
              queryKey: context.queryKey,
              meta: context.options.meta,
              signal: context.signal
            },
            query
          );
        };
      } else {
        context.fetchFn = fetchFn;
      }
    }
  };
}
function getNextPageParam(options, { pages, pageParams }) {
  const lastIndex = pages.length - 1;
  return pages.length > 0 ? options.getNextPageParam(
    pages[lastIndex],
    pages,
    pageParams[lastIndex],
    pageParams
  ) : void 0;
}
function getPreviousPageParam(options, { pages, pageParams }) {
  return pages.length > 0 ? options.getPreviousPageParam?.(pages[0], pages, pageParams[0], pageParams) : void 0;
}
var QueryClient = (_h = class {
  constructor(config2 = {}) {
    __privateAdd(this, _queryCache);
    __privateAdd(this, _mutationCache2);
    __privateAdd(this, _defaultOptions2);
    __privateAdd(this, _queryDefaults);
    __privateAdd(this, _mutationDefaults);
    __privateAdd(this, _mountCount);
    __privateAdd(this, _unsubscribeFocus);
    __privateAdd(this, _unsubscribeOnline);
    __privateSet(this, _queryCache, config2.queryCache || new QueryCache());
    __privateSet(this, _mutationCache2, config2.mutationCache || new MutationCache());
    __privateSet(this, _defaultOptions2, config2.defaultOptions || {});
    __privateSet(this, _queryDefaults, /* @__PURE__ */ new Map());
    __privateSet(this, _mutationDefaults, /* @__PURE__ */ new Map());
    __privateSet(this, _mountCount, 0);
  }
  mount() {
    __privateWrapper(this, _mountCount)._++;
    if (__privateGet(this, _mountCount) !== 1)
      return;
    __privateSet(this, _unsubscribeFocus, focusManager.subscribe(async (focused) => {
      if (focused) {
        await this.resumePausedMutations();
        __privateGet(this, _queryCache).onFocus();
      }
    }));
    __privateSet(this, _unsubscribeOnline, onlineManager.subscribe(async (online) => {
      if (online) {
        await this.resumePausedMutations();
        __privateGet(this, _queryCache).onOnline();
      }
    }));
  }
  unmount() {
    var _a2, _b2;
    __privateWrapper(this, _mountCount)._--;
    if (__privateGet(this, _mountCount) !== 0)
      return;
    (_a2 = __privateGet(this, _unsubscribeFocus)) == null ? void 0 : _a2.call(this);
    __privateSet(this, _unsubscribeFocus, void 0);
    (_b2 = __privateGet(this, _unsubscribeOnline)) == null ? void 0 : _b2.call(this);
    __privateSet(this, _unsubscribeOnline, void 0);
  }
  isFetching(filters) {
    return __privateGet(this, _queryCache).findAll({ ...filters, fetchStatus: "fetching" }).length;
  }
  isMutating(filters) {
    return __privateGet(this, _mutationCache2).findAll({ ...filters, status: "pending" }).length;
  }
  getQueryData(queryKey) {
    const options = this.defaultQueryOptions({ queryKey });
    return __privateGet(this, _queryCache).get(options.queryHash)?.state.data;
  }
  ensureQueryData(options) {
    const cachedData = this.getQueryData(options.queryKey);
    if (cachedData === void 0)
      return this.fetchQuery(options);
    else {
      const defaultedOptions = this.defaultQueryOptions(options);
      const query = __privateGet(this, _queryCache).build(this, defaultedOptions);
      if (options.revalidateIfStale && query.isStaleByTime(resolveStaleTime(defaultedOptions.staleTime, query))) {
        void this.prefetchQuery(defaultedOptions);
      }
      return Promise.resolve(cachedData);
    }
  }
  getQueriesData(filters) {
    return __privateGet(this, _queryCache).findAll(filters).map(({ queryKey, state }) => {
      const data = state.data;
      return [queryKey, data];
    });
  }
  setQueryData(queryKey, updater, options) {
    const defaultedOptions = this.defaultQueryOptions({ queryKey });
    const query = __privateGet(this, _queryCache).get(
      defaultedOptions.queryHash
    );
    const prevData = query?.state.data;
    const data = functionalUpdate(updater, prevData);
    if (data === void 0) {
      return void 0;
    }
    return __privateGet(this, _queryCache).build(this, defaultedOptions).setData(data, { ...options, manual: true });
  }
  setQueriesData(filters, updater, options) {
    return notifyManager.batch(
      () => __privateGet(this, _queryCache).findAll(filters).map(({ queryKey }) => [
        queryKey,
        this.setQueryData(queryKey, updater, options)
      ])
    );
  }
  getQueryState(queryKey) {
    const options = this.defaultQueryOptions({ queryKey });
    return __privateGet(this, _queryCache).get(options.queryHash)?.state;
  }
  removeQueries(filters) {
    const queryCache = __privateGet(this, _queryCache);
    notifyManager.batch(() => {
      queryCache.findAll(filters).forEach((query) => {
        queryCache.remove(query);
      });
    });
  }
  resetQueries(filters, options) {
    const queryCache = __privateGet(this, _queryCache);
    const refetchFilters = {
      type: "active",
      ...filters
    };
    return notifyManager.batch(() => {
      queryCache.findAll(filters).forEach((query) => {
        query.reset();
      });
      return this.refetchQueries(refetchFilters, options);
    });
  }
  cancelQueries(filters = {}, cancelOptions = {}) {
    const defaultedCancelOptions = { revert: true, ...cancelOptions };
    const promises = notifyManager.batch(
      () => __privateGet(this, _queryCache).findAll(filters).map((query) => query.cancel(defaultedCancelOptions))
    );
    return Promise.all(promises).then(noop$5).catch(noop$5);
  }
  invalidateQueries(filters = {}, options = {}) {
    return notifyManager.batch(() => {
      __privateGet(this, _queryCache).findAll(filters).forEach((query) => {
        query.invalidate();
      });
      if (filters.refetchType === "none") {
        return Promise.resolve();
      }
      const refetchFilters = {
        ...filters,
        type: filters.refetchType ?? filters.type ?? "active"
      };
      return this.refetchQueries(refetchFilters, options);
    });
  }
  refetchQueries(filters = {}, options) {
    const fetchOptions = {
      ...options,
      cancelRefetch: options?.cancelRefetch ?? true
    };
    const promises = notifyManager.batch(
      () => __privateGet(this, _queryCache).findAll(filters).filter((query) => !query.isDisabled()).map((query) => {
        let promise = query.fetch(void 0, fetchOptions);
        if (!fetchOptions.throwOnError) {
          promise = promise.catch(noop$5);
        }
        return query.state.fetchStatus === "paused" ? Promise.resolve() : promise;
      })
    );
    return Promise.all(promises).then(noop$5);
  }
  fetchQuery(options) {
    const defaultedOptions = this.defaultQueryOptions(options);
    if (defaultedOptions.retry === void 0) {
      defaultedOptions.retry = false;
    }
    const query = __privateGet(this, _queryCache).build(this, defaultedOptions);
    return query.isStaleByTime(
      resolveStaleTime(defaultedOptions.staleTime, query)
    ) ? query.fetch(defaultedOptions) : Promise.resolve(query.state.data);
  }
  prefetchQuery(options) {
    return this.fetchQuery(options).then(noop$5).catch(noop$5);
  }
  fetchInfiniteQuery(options) {
    options.behavior = infiniteQueryBehavior(options.pages);
    return this.fetchQuery(options);
  }
  prefetchInfiniteQuery(options) {
    return this.fetchInfiniteQuery(options).then(noop$5).catch(noop$5);
  }
  ensureInfiniteQueryData(options) {
    options.behavior = infiniteQueryBehavior(options.pages);
    return this.ensureQueryData(options);
  }
  resumePausedMutations() {
    if (onlineManager.isOnline()) {
      return __privateGet(this, _mutationCache2).resumePausedMutations();
    }
    return Promise.resolve();
  }
  getQueryCache() {
    return __privateGet(this, _queryCache);
  }
  getMutationCache() {
    return __privateGet(this, _mutationCache2);
  }
  getDefaultOptions() {
    return __privateGet(this, _defaultOptions2);
  }
  setDefaultOptions(options) {
    __privateSet(this, _defaultOptions2, options);
  }
  setQueryDefaults(queryKey, options) {
    __privateGet(this, _queryDefaults).set(hashKey(queryKey), {
      queryKey,
      defaultOptions: options
    });
  }
  getQueryDefaults(queryKey) {
    const defaults2 = [...__privateGet(this, _queryDefaults).values()];
    let result = {};
    defaults2.forEach((queryDefault) => {
      if (partialMatchKey(queryKey, queryDefault.queryKey)) {
        result = { ...result, ...queryDefault.defaultOptions };
      }
    });
    return result;
  }
  setMutationDefaults(mutationKey, options) {
    __privateGet(this, _mutationDefaults).set(hashKey(mutationKey), {
      mutationKey,
      defaultOptions: options
    });
  }
  getMutationDefaults(mutationKey) {
    const defaults2 = [...__privateGet(this, _mutationDefaults).values()];
    let result = {};
    defaults2.forEach((queryDefault) => {
      if (partialMatchKey(mutationKey, queryDefault.mutationKey)) {
        result = { ...result, ...queryDefault.defaultOptions };
      }
    });
    return result;
  }
  defaultQueryOptions(options) {
    if (options._defaulted) {
      return options;
    }
    const defaultedOptions = {
      ...__privateGet(this, _defaultOptions2).queries,
      ...this.getQueryDefaults(options.queryKey),
      ...options,
      _defaulted: true
    };
    if (!defaultedOptions.queryHash) {
      defaultedOptions.queryHash = hashQueryKeyByOptions(
        defaultedOptions.queryKey,
        defaultedOptions
      );
    }
    if (defaultedOptions.refetchOnReconnect === void 0) {
      defaultedOptions.refetchOnReconnect = defaultedOptions.networkMode !== "always";
    }
    if (defaultedOptions.throwOnError === void 0) {
      defaultedOptions.throwOnError = !!defaultedOptions.suspense;
    }
    if (!defaultedOptions.networkMode && defaultedOptions.persister) {
      defaultedOptions.networkMode = "offlineFirst";
    }
    if (defaultedOptions.enabled !== true && defaultedOptions.queryFn === skipToken) {
      defaultedOptions.enabled = false;
    }
    return defaultedOptions;
  }
  defaultMutationOptions(options) {
    if (options?._defaulted) {
      return options;
    }
    return {
      ...__privateGet(this, _defaultOptions2).mutations,
      ...options?.mutationKey && this.getMutationDefaults(options.mutationKey),
      ...options,
      _defaulted: true
    };
  }
  clear() {
    __privateGet(this, _queryCache).clear();
    __privateGet(this, _mutationCache2).clear();
  }
}, _queryCache = new WeakMap(), _mutationCache2 = new WeakMap(), _defaultOptions2 = new WeakMap(), _queryDefaults = new WeakMap(), _mutationDefaults = new WeakMap(), _mountCount = new WeakMap(), _unsubscribeFocus = new WeakMap(), _unsubscribeOnline = new WeakMap(), _h);
var MutationObserver$1 = (_i = class extends Subscribable {
  constructor(client, options) {
    super();
    __privateAdd(this, _MutationObserver_instances);
    __privateAdd(this, _client);
    __privateAdd(this, _currentResult);
    __privateAdd(this, _currentMutation);
    __privateAdd(this, _mutateOptions);
    __privateSet(this, _client, client);
    this.setOptions(options);
    this.bindMethods();
    __privateMethod(this, _MutationObserver_instances, updateResult_fn).call(this);
  }
  bindMethods() {
    this.mutate = this.mutate.bind(this);
    this.reset = this.reset.bind(this);
  }
  setOptions(options) {
    const prevOptions = this.options;
    this.options = __privateGet(this, _client).defaultMutationOptions(options);
    if (!shallowEqualObjects(this.options, prevOptions)) {
      __privateGet(this, _client).getMutationCache().notify({
        type: "observerOptionsUpdated",
        mutation: __privateGet(this, _currentMutation),
        observer: this
      });
    }
    if (prevOptions?.mutationKey && this.options.mutationKey && hashKey(prevOptions.mutationKey) !== hashKey(this.options.mutationKey)) {
      this.reset();
    } else if (__privateGet(this, _currentMutation)?.state.status === "pending") {
      __privateGet(this, _currentMutation).setOptions(this.options);
    }
  }
  onUnsubscribe() {
    if (!this.hasListeners()) {
      __privateGet(this, _currentMutation)?.removeObserver(this);
    }
  }
  onMutationUpdate(action) {
    __privateMethod(this, _MutationObserver_instances, updateResult_fn).call(this);
    __privateMethod(this, _MutationObserver_instances, notify_fn).call(this, action);
  }
  getCurrentResult() {
    return __privateGet(this, _currentResult);
  }
  reset() {
    __privateGet(this, _currentMutation)?.removeObserver(this);
    __privateSet(this, _currentMutation, void 0);
    __privateMethod(this, _MutationObserver_instances, updateResult_fn).call(this);
    __privateMethod(this, _MutationObserver_instances, notify_fn).call(this);
  }
  mutate(variables, options) {
    __privateSet(this, _mutateOptions, options);
    __privateGet(this, _currentMutation)?.removeObserver(this);
    __privateSet(this, _currentMutation, __privateGet(this, _client).getMutationCache().build(__privateGet(this, _client), this.options));
    __privateGet(this, _currentMutation).addObserver(this);
    return __privateGet(this, _currentMutation).execute(variables);
  }
}, _client = new WeakMap(), _currentResult = new WeakMap(), _currentMutation = new WeakMap(), _mutateOptions = new WeakMap(), _MutationObserver_instances = new WeakSet(), updateResult_fn = function() {
  const state = __privateGet(this, _currentMutation)?.state ?? getDefaultState();
  __privateSet(this, _currentResult, {
    ...state,
    isPending: state.status === "pending",
    isSuccess: state.status === "success",
    isError: state.status === "error",
    isIdle: state.status === "idle",
    mutate: this.mutate,
    reset: this.reset
  });
}, notify_fn = function(action) {
  notifyManager.batch(() => {
    if (__privateGet(this, _mutateOptions) && this.hasListeners()) {
      const variables = __privateGet(this, _currentResult).variables;
      const context = __privateGet(this, _currentResult).context;
      if (action?.type === "success") {
        __privateGet(this, _mutateOptions).onSuccess?.(action.data, variables, context);
        __privateGet(this, _mutateOptions).onSettled?.(action.data, null, variables, context);
      } else if (action?.type === "error") {
        __privateGet(this, _mutateOptions).onError?.(action.error, variables, context);
        __privateGet(this, _mutateOptions).onSettled?.(
          void 0,
          action.error,
          variables,
          context
        );
      }
    }
    this.listeners.forEach((listener) => {
      listener(__privateGet(this, _currentResult));
    });
  });
}, _i);
var QueryClientContext = reactExports.createContext(
  void 0
);
var useQueryClient = (queryClient) => {
  const client = reactExports.useContext(QueryClientContext);
  if (!client) {
    throw new Error("No QueryClient set, use QueryClientProvider to set one");
  }
  return client;
};
var QueryClientProvider = ({
  client,
  children
}) => {
  reactExports.useEffect(() => {
    client.mount();
    return () => {
      client.unmount();
    };
  }, [client]);
  return /* @__PURE__ */ jsxRuntimeExports.jsx(QueryClientContext.Provider, { value: client, children });
};
function shouldThrowError(throwError, params) {
  if (typeof throwError === "function") {
    return throwError(...params);
  }
  return !!throwError;
}
function noop$4() {
}
function useMutation(options, queryClient) {
  const client = useQueryClient();
  const [observer] = reactExports.useState(
    () => new MutationObserver$1(
      client,
      options
    )
  );
  reactExports.useEffect(() => {
    observer.setOptions(options);
  }, [observer, options]);
  const result = reactExports.useSyncExternalStore(
    reactExports.useCallback(
      (onStoreChange) => observer.subscribe(notifyManager.batchCalls(onStoreChange)),
      [observer]
    ),
    () => observer.getCurrentResult(),
    () => observer.getCurrentResult()
  );
  const mutate = reactExports.useCallback(
    (variables, mutateOptions) => {
      observer.mutate(variables, mutateOptions).catch(noop$4);
    },
    [observer]
  );
  if (result.error && shouldThrowError(observer.options.throwOnError, [result.error])) {
    throw result.error;
  }
  return { ...result, mutate, mutateAsync: result.mutate };
}
const LanguageContext = reactExports.createContext(void 0);
function useLanguage$1() {
  const context = reactExports.useContext(LanguageContext);
  if (!context) {
    throw new Error("useLanguage must be used within a LanguageProvider");
  }
  return context;
}
const translations$3 = {
  en: {
    // Authentication
    signIn: "Sign In",
    signUp: "Sign Up",
    email: "Email",
    password: "Password",
    confirmPassword: "Confirm Password",
    fullName: "Full Name",
    fullNamePlaceholder: "Enter your full name",
    nickname: "Nickname",
    nicknamePlaceholder: "Enter your nickname",
    signInWithGoogle: "Sign in with Google",
    signUpWithGoogle: "Sign up with Google",
    loginWithGoogle: "Continue with Google",
    orContinueWith: "Or continue with",
    alreadyHaveAccount: "Already have an account?",
    dontHaveAccount: "Don't have an account?",
    welcomeBack: "Welcome back!",
    createAccountTitle: "Create an account",
    loginDescription: "Enter your credentials to access your account",
    registerDescription: "Enter your information to create a new account",
    loginButton: "Sign In",
    registerButton: "Create Account",
    noAccount: "Don't have an account?",
    hasAccount: "Already have an account?",
    forgotPassword: "Forgot password?",
    resetPassword: "Reset password",
    resetPasswordDesc: "Enter your email to reset your password",
    resetPasswordSent: "Password reset email sent",
    checkEmail: "Check your email for password reset instructions",
    authError: "Authentication error",
    invalidCredentials: "Invalid email or password",
    accountCreated: "Account created successfully",
    signedInSuccessfully: "Signed in successfully",
    signedOutSuccessfully: "Signed out successfully",
    loading: "Loading...",
    termsText: "By clicking continue, you agree to our",
    termsOfService: "Terms of Service",
    and: "and",
    privacyPolicy: "Privacy Policy",
    // Navigation
    map: "Map",
    community: "Community",
    notifications: "Notifications",
    report: "Report",
    wanted: "Wanted",
    profile: "Profile",
    // Main Screen
    neighborhood: "Neighborhood",
    activity: "Activity",
    quickActions: "Quick Actions",
    reportIncident: "Report Incident",
    viewReports: "View Reports",
    communityChat: "Community Chat",
    wantedPersons: "Wanted Persons",
    recentActivity: "Recent Activity",
    safetyScore: "Safety Score",
    // Community
    communityTitle: "Community",
    yourNeighborhood: "Your Neighborhood",
    downtownArea: "Downtown Area",
    neighborhoodChat: "Neighborhood Chat",
    observations: "Observations",
    somethingStrange: "Something Strange",
    quickReport: "Quick Report",
    whatNoticed: "What did you notice?",
    addPhoto: "Add Photo",
    changePhoto: "Change Photo",
    sendAnonymously: "Send Anonymously",
    warn: "Warn Community",
    confirm: "Confirm",
    confirmations: "confirmations",
    confirmed: "Confirmed",
    reject: "Reject",
    rejections: "rejections",
    rejected: "Rejected",
    confirmTitle: "Report Confirmed",
    confirmDesc: "Thank you for confirming this report.",
    confirmRemovedTitle: "Confirmation Removed",
    confirmRemovedDesc: "Your confirmation has been removed from this report.",
    rejectTitle: "Report Rejected",
    rejectDesc: "Thank you for your feedback on this report.",
    rejectRemovedTitle: "Rejection Removed",
    rejectRemovedDesc: "Your rejection has been removed from this report.",
    confirmOverrideTitle: "Report Confirmed",
    confirmOverrideDesc: "Your previous rejection has been removed and the report confirmed.",
    rejectOverrideTitle: "Report Rejected",
    rejectOverrideDesc: "Your previous confirmation has been removed and the report rejected.",
    reportTitle: "Report Sent",
    reportDesc: "Your report has been sent to the community.",
    deleteReport: "Delete Report",
    reportDeleted: "Report Deleted",
    reportDeletedDesc: "The report has been successfully deleted.",
    deleteConfirm: "Are you sure you want to delete this report?",
    deleteMessage: "Delete Message",
    messageDeleted: "Message Deleted",
    messageDeletedDesc: "The message has been successfully deleted.",
    deleteMessageConfirm: "Are you sure you want to delete this message?",
    noPermissionDelete: "You don't have permission to delete this message",
    errorDeletingMessage: "Error deleting message",
    editThread: "Edit Thread",
    threadUpdated: "Thread Updated",
    threadUpdatedMessage: "The thread has been successfully updated",
    deleteThreadConfirm: "Are you sure you want to delete this thread?",
    updating: "Updating...",
    // Community Chat
    createThread: "Create Thread",
    createNewThread: "Create New Thread",
    threadTitle: "Thread Title",
    threadDescription: "Thread Description (optional)",
    creating: "Creating...",
    create: "Create",
    threadCreated: "Thread Created",
    threadCreatedMessage: "Your thread has been successfully created.",
    userAlreadyHasThread: "You can only create one thread per user.",
    noThreadsYet: "No threads yet",
    createFirstThread: "Be the first to start a discussion!",
    mainThread: "Main",
    createdByYou: "Your thread",
    messages: "messages",
    noMessages: "No messages yet",
    beFirstToMessage: "Be the first to send a message!",
    writeMessage: "Write a message...",
    searchInChat: "Search in chat...",
    noSearchResults: "No messages found",
    tryDifferentKeywords: "Try different keywords",
    messageTitle: "Message Sent",
    messageDesc: "Your message has been published.",
    anonymously: "Anonymously",
    you: "You",
    unknownUser: "Unknown User",
    comments: "Comments",
    noCommentsYet: "No comments yet",
    beFirstToComment: "Be the first to comment!",
    writeComment: "Write a comment...",
    commentAnonymously: "Comment anonymously",
    commentAdded: "Comment Added",
    commentAddedDesc: "Your comment has been published.",
    commentDeleted: "Comment Deleted",
    commentDeletedDesc: "The comment has been deleted.",
    deleteCommentConfirm: "Are you sure you want to delete this comment?",
    // Wanted Persons
    addWantedPerson: "Add Wanted Person",
    personName: "Person Name",
    age: "Age",
    years: "years",
    yearsOld: "years old",
    description: "Description",
    lastSeenLocation: "Last Seen Location",
    lastSeenDate: "Last Seen Date",
    contactInfo: "Contact Information",
    personAdded: "Person Added",
    personAddedDesc: "The wanted person information has been successfully added.",
    searchPerson: "Search person...",
    noWantedPersons: "No wanted persons reported",
    active: "Active",
    caught: "Caught",
    inactive: "Inactive",
    noPhotoAvailable: "No photo available",
    noPhotoDescription: "No photos have been uploaded",
    addedBy: "Added by",
    addedOn: "Added on",
    wanted_no_photo: "No photo available",
    wanted_no_photo_desc: "No photos have been uploaded",
    wanted_status_active: "Active",
    wanted_status_caught: "Caught",
    wanted_status_inactive: "Inactive",
    person_age: "{age} years old",
    last_seen_location: "Last seen location",
    last_seen_date: "Last seen date",
    contact_info: "Contact information",
    added_by: "Added by",
    added_on: "Added on",
    // Profile
    editProfile: "Edit Profile",
    changePassword: "Change Password",
    signOut: "Sign Out",
    currentPassword: "Current Password",
    newPassword: "New Password",
    confirmNewPassword: "Confirm New Password",
    save: "Save",
    update: "Update",
    profileUpdated: "Profile Updated",
    profileUpdatedMessage: "Your profile has been successfully updated.",
    passwordChanged: "Password Changed",
    passwordChangedMessage: "Your password has been successfully changed.",
    statistics: "Statistics",
    days: "Days",
    nearbyIncidents: "Nearby Incidents",
    nearbyIncidentsDesc: "Get notified about nearby incidents",
    emergencySituations: "Emergency Situations",
    emergencySituationsDesc: "Critical safety alerts",
    updates: "Updates",
    updatesDesc: "App updates and announcements",
    location: "Location",
    tracking: "Location Tracking",
    trackingDesc: "Allow location access for better safety features",
    enabled: "Enabled",
    alertRadius: "Alert Radius",
    alertRadiusDesc: "Distance for incident notifications",
    currentRadius: "Current radius",
    meters: "meters",
    settings: "Settings",
    contactSupport: "Contact Support",
    aboutApp: "About App",
    logout: "Logout",
    logoutSuccess: "Session Ended",
    logoutMessage: "You have successfully signed out",
    logoutError: "Error signing out",
    // Cache management
    cacheManagement: "Cache Management",
    cacheManagementDesc: "Clear temporary location data",
    clearCache: "Clear Cache",
    cacheCleared: "Cache Cleared",
    cacheCleanedDesc: "Temporary location data has been successfully cleared",
    // Avatar management
    avatarUploaded: "Avatar Uploaded",
    avatarUploadedDesc: "Your avatar has been successfully uploaded.",
    avatarError: "Avatar Error",
    avatarSizeError: "File size must be less than 5MB",
    avatarTypeError: "Please select an image file",
    saving: "Saving...",
    settingsUpdated: "Settings Updated",
    notificationsEnabled: "enabled",
    notificationsDisabled: "disabled",
    profileNotFound: "Profile not found",
    name: "Name",
    namePlaceholder: "Enter your name",
    selectFromGallery: "Select from Gallery",
    saveChanges: "Save Changes",
    profileUpdateMessage: "Your profile information has been updated",
    // Reports/Map
    mapTitle: "Safety Map",
    incidentTypes: "Incident Types",
    allIncidents: "All Incidents",
    theft: "Theft",
    assault: "Assault",
    vandalism: "Vandalism",
    suspicious: "Suspicious Activity",
    emergency: "Emergency",
    other: "Other",
    filterByType: "Filter by Type",
    showMyReports: "Show My Reports",
    reportDetails: "Report Details",
    reportedBy: "Reported by",
    reportTime: "Report Time",
    incidentLocation: "Incident Location",
    filterAll: "All",
    filterMine: "My Reports",
    filterTheft: "Theft",
    filterAssault: "Assault",
    filterVandalism: "Vandalism",
    filterSuspicious: "Suspicious",
    filterEmergency: "Emergency",
    filterOther: "Other",
    filterAccident: "Accident",
    traffic_accident: "Traffic Accident",
    recentIncidents: "Recent Incidents",
    filters: "Filters",
    heatmap: "Heatmap",
    traffic: "Traffic",
    reportButton: "Report",
    noIncidents: "No incidents reported in this area",
    beFirstToReport: "Be the first to report an incident!",
    // Severity levels
    low: "Low",
    medium: "Medium",
    high: "High",
    // Report Incident
    reportIncidentTitle: "Report Incident",
    incidentType: "Incident Type",
    selectIncidentType: "Select Incident Type",
    selectIncidentTypeDesc: "Please select an incident type first",
    firstSelectIncidentType: "First select an incident type",
    incidentDescription: "Incident Description",
    detailedDescription: "Detailed Description",
    describeSituation: "Describe what happened",
    descriptionPlaceholder: "Describe the incident in detail...",
    selectLocation: "Select location on map",
    currentLocation: "Use current location",
    useMyGeolocation: "Use My Geolocation",
    selectOnMap: "Select on Map",
    accident: "Accident",
    uploadPhotos: "Upload Photos",
    selectPhotos: "Select Photos (optional)",
    photos: "Photos",
    photo: "Photo",
    clickToViewGallery: "Click on photos to view in gallery",
    viewInGallery: "View in Gallery",
    downloadPhoto: "Download Photo",
    zoomIn: "Zoom In",
    zoomOut: "Zoom Out",
    close: "Close",
    navigate: "Navigate",
    zoom: "Zoom",
    previousPhoto: "Previous Photo",
    nextPhoto: "Next Photo",
    takePhoto: "Take Photo",
    anonymousReport: "Anonymous Report",
    submitReport: "Submit Report",
    sendReport: "Send Report",
    reportSubmitted: "Report Submitted",
    reportSubmittedDesc: "Your incident report has been successfully submitted",
    reportSent: "Report sent successfully",
    reportSentDesc: "Your incident report has been sent and is now visible to the community",
    title: "Title",
    titlePlaceholder: "Enter incident title...",
    // Common
    submit: "Submit",
    cancel: "Cancel",
    uploading: "Uploading...",
    errorTitle: "Error",
    connectionError: "Connection error. Please try again.",
    validationError: "Validation Error",
    fillAllFields: "Please fill in all required fields.",
    fillAllFieldsDesc: "All required fields must be filled.",
    yourLocation: "Your Location",
    mapView: "Map",
    filterAlerts: "Filter Alerts",
    allAlerts: "All Alerts",
    nearbyAlerts: "Nearby Alerts",
    radiusSettings: "Radius Settings",
    setAlertRadius: "Set Alert Radius",
    radiusInMeters: "Radius in meters",
    // Time indicators for incidents
    expired: "Expired",
    minutesShort: "min",
    hoursShort: "h",
    daysShort: "d",
    remainingTime: "Remaining time",
    timeRemaining: "Time remaining",
    expiresIn: "Expires in",
    incidentDuration: "Incident duration",
    autoRemovalInfo: "Incident will be automatically removed after this time",
    // User Roles
    user: "User",
    admin: "Admin",
    masterAdmin: "Master Admin",
    adminActions: "Admin Actions",
    deleteAnyContent: "Can delete any content",
    manageUsers: "Can manage users",
    manageAdmins: "Can manage admins",
    // Time and creation info
    createdBy: "Created by",
    createdAt: "Created at",
    expiresAfter: "Expires after",
    daysText: "days",
    // Missing persons moderation actions
    markAsActive: "Mark as Active",
    markAsFound: "Mark as Found",
    markAsClosed: "Mark as Closed",
    activate: "Activate",
    delete: "Delete",
    // Message status
    delivered: "Delivered",
    accessDenied: "Access Denied",
    accountBlocked: "Account Blocked",
    blockedUntil: "Blocked until",
    blockedPermanently: "Blocked permanently",
    cannotPerformAction: "You cannot perform this action while blocked",
    clickToSelectLocation: "Click to select location",
    // Traffic Push Notifications
    trafficPushEnabled: "Traffic push notifications enabled",
    trafficPushDisabled: "Traffic push notifications disabled",
    trafficPushEnabledDesc: "You will receive push notifications about traffic ahead",
    trafficPushDisabledDesc: "Traffic push notifications are disabled",
    trafficAhead: "Traffic ahead",
    heavyTrafficAhead: "Heavy traffic ahead",
    severeJamAhead: "Severe jam ahead",
    trafficDetected: "Traffic detected",
    estimatedDelay: "Estimated delay",
    minutes: "minutes",
    considerAlternativeRoute: "Consider alternative route",
    slowDown: "Slow down",
    keepDistance: "Keep distance",
    bePatient: "Be patient",
    usePublicTransport: "Use public transport",
    postponeTrip: "Postpone trip by 15-20 minutes",
    // Traffic notification titles
    trafficSevereTitle: "Severe traffic ahead",
    trafficHeavyTitle: "Heavy traffic ahead",
    trafficModerateTitle: "Moderate traffic ahead",
    trafficLowTitle: "Light traffic ahead",
    trafficDefaultTitle: "Traffic ahead",
    // Traffic notification messages
    trafficSevereMessage: "Severe traffic in {distance}. Estimated delay: {delay} min.",
    trafficHeavyMessage: "Heavy traffic in {distance}. Possible delay: {delay} min.",
    trafficModerateMessage: "Moderate traffic in {distance}. Delay: {delay} min.",
    trafficLowMessage: "Light traffic in {distance}.",
    trafficDefaultMessage: "Traffic detected in {distance}.",
    // Traffic suggestions
    trafficSuggestionAlternative: "Consider alternative route",
    trafficSuggestionDelay: "Postpone trip by 15-20 minutes",
    trafficSuggestionPublic: "Use public transport",
    trafficSuggestionSlowDown: "Slow down",
    trafficSuggestionDistance: "Keep distance",
    trafficSuggestionDetour: "Consider detour",
    trafficSuggestionPatient: "Be patient",
    trafficSuggestionCaution: "Be cautious",
    // Units
    km: "km",
    m: "m",
    // Radar Pro Premium Subscription
    radarPro: "Radar Pro",
    premiumSubscription: "Premium Subscription",
    upgradeToRadarPro: "Upgrade to Radar Pro",
    radarProDesc: "Unlock advanced safety features and premium tools",
    radarProFeatures: "Premium Features",
    trafficAlerts: "Real-time Traffic Alerts",
    trafficAlertsDesc: "Get push notifications about traffic ahead on your route",
    advancedHeatmap: "Advanced Incident Heatmap",
    advancedHeatmapDesc: "Visual incident density map with vibration alerts",
    smartNotifications: "Smart AI Notifications",
    smartNotificationsDesc: "Intelligent alerts based on your location and movement",
    communityFeatures: "Enhanced Community Features",
    communityFeaturesDesc: "Advanced community chat, threads, and reporting tools",
    adminTools: "Admin Tools",
    adminToolsDesc: "User management, content moderation, and analytics dashboard",
    multiLanguage: "Multi-language Support",
    multiLanguageDesc: "Full support for English, Spanish, and Russian languages",
    premiumSupport: "24/7 Premium Support",
    premiumSupportDesc: "Priority customer support and technical assistance",
    noAds: "No Ads",
    noAdsDesc: "Enjoy the app without ads and interruptions",
    subscribeNow: "Subscribe Now",
    monthlyPrice: "$14.99/month",
    yearlyPrice: "$149.99/year",
    freeTrial: "7 days free",
    // Badges
    earned: "Earned",
    recently: "Recently",
    badgesEarned: "badges earned",
    // XP System
    howToEarnXP: "How to Earn XP",
    xpGuideTitle: "How to Earn XP and Level Up",
    whatIsXP: "What is XP?",
    xpExplanation: "XP (Experience Points) are points you earn for various actions in the app. By accumulating XP, you level up and gain access to new features.",
    whyLevels: "Why Levels?",
    whyLevelsDesc: "A high level shows your activity and reliability in the community. Users with high levels get more trust and additional privileges.",
    levelSystem: "Level System",
    howToEarnXPSection: "How to Earn XP",
    badgeSystem: "Badge System",
    badgeSystemDesc: "Badges are rewards for special achievements. They are automatically awarded when you meet certain conditions.",
    tipsForProgress: "Tips for Fast Progress",
    dailyActivity: "Daily Activity",
    qualityReports: "Quality Reports",
    communityHelp: "Community Help",
    quickResponse: "Quick Response",
    startNow: "Start Now!",
    startNowDesc: "Every action you take makes the community safer and helps other users. Start by creating your first report and earn your first XP!",
    goodLuck: "Good luck reaching new levels! 🚀",
    maxLevelReached: "🏆 Maximum level reached!",
    tips: "Tips",
    toNextLevel: "to next level",
    // XP Activities
    createReport: "Create Report",
    createReportDesc: "Report an incident or danger in your area",
    createReportTip: "Add detailed description and precise location",
    addPhotoToReport: "Add Photo to Report",
    addPhotoDesc: "Attach photos or videos to your report",
    addPhotoTip: "Photos help other users better understand the situation",
    confirmReport: "Confirm Report",
    confirmReportDesc: "Confirm another user's report if you also saw the incident",
    confirmReportTip: "Only confirm reports you actually witnessed",
    chatParticipation: "Community Chat Participation",
    chatParticipationDesc: "Communicate with other users in community chat",
    chatParticipationTip: "Share useful information and help others",
    quickResponseTitle: "Quick Response",
    quickResponseDesc: "Be first to respond to emergency situations",
    quickResponseTip: "Quickly react to critical situations in your area",
    dailyLogin: "Daily Login",
    dailyLoginDesc: "Visit the app every day",
    dailyLoginTip: "Regular app usage helps stay informed about events",
    profileUpdate: "Profile Update",
    profileUpdateDesc: "Fill out and update your profile information",
    profileUpdateTip: "A complete profile increases trust from other users",
    communityParticipation: "Community Participation",
    communityParticipationDesc: "Participate actively in community life",
    communityParticipationTip: "Help newcomers and share experience",
    // Activity tips
    dailyActivityTips: "• Visit the app every day\n• Check the map for new incidents\n• Participate in community chat",
    qualityReportsTips: "• Always add photos to reports\n• Write detailed descriptions\n• Specify exact location",
    communityHelpTips: "• Confirm other users' reports\n• Answer questions in chat\n• Share useful information",
    quickResponseTips: "• Enable push notifications\n• React quickly to emergency situations\n• Be first to help",
    // Badges
    firstReportBadge: "First Report",
    firstReportCondition: "Create your first report",
    dangerHunterBadge: "Danger Hunter",
    dangerHunterCondition: "Report 3 incidents",
    urbanExplorerBadge: "Urban Explorer",
    urbanExplorerCondition: "Reports from 3+ different areas",
    communityVoiceBadge: "Community Voice",
    communityVoiceCondition: "Get 10+ confirmations",
    visualEyeBadge: "Visual Eye",
    visualEyeCondition: "Add 5+ photos/videos",
    localProtectorBadge: "Local Protector",
    localProtectorCondition: "Be first on scene",
    consistentBadge: "Consistent",
    consistentCondition: "Active 7 days in a row",
    advisorBadge: "Advisor",
    advisorCondition: "Approved suggestion",
    radarEliteBadge: "Radar Elite",
    radarEliteCondition: "Reach Commander level",
    // Level names
    observador: "Observer",
    reportero: "Reporter",
    radarCiudadano: "Radar Citizen",
    vigilante: "Vigilant",
    patrullero: "Patrullero",
    comandante: "Commander",
    replyingTo: "Reply to",
    swipeToReply: "Swipe right to reply",
    // Reactions
    confirmAction: "Confirm",
    rejectAction: "Reject",
    incidentPendingDeletion: "This incident will be deleted in 30 minutes due to high rejection rate",
    errorSavingReaction: "Error saving your reaction",
    incidentDeleted: "Incident Deleted",
    incidentDeletedMessage: "The incident has been successfully deleted.",
    // Comments
    addCommentPlaceholder: "Add your comment...",
    postAnonymously: "Post anonymously",
    send: "Send",
    anonymous: "Anonymous",
    errorAddingComment: "Error adding comment",
    // Onboarding
    allowLocationAccess: "Allow Location Access",
    locationPermissionDesc: "We use geolocation to send you alerts about incidents nearby. Data is deleted after 30 days.",
    allowNotifications: "Allow Notifications",
    notificationPermissionDesc: "To receive real-time alerts about incidents",
    continue: "Continue",
    demoIncidents: "0.3 km from you — Armed robbery at Main St. Avoid area.\n0.15 km from you — Car accident on Highway 101. Traffic delays.\n0.8 km from you — Suspicious activity near Central Park. Stay alert.\n0.5 km from you — Fire emergency on Oak Avenue. Emergency services responding.",
    // Historical incident popup labels
    typeLabel: "Type",
    dateLabel: "Date",
    // Notification Settings
    notificationSettings: "Notification Settings",
    proximityNotifications: "Safety & Incidents",
    proximityNotificationsDesc: "Notifications about nearby incidents, emergency alerts and activity",
    incidentNearby: "Incidents Nearby",
    incidentNearbyDesc: "Alert when dangerous incidents are reported near you",
    friendNearby: "Friends Nearby",
    friendNearbyDesc: "Notify when friends are in your vicinity",
    areaActivity: "Area Activity",
    areaActivityDesc: "Updates about high incident activity in your area",
    adminNotifications: "Administration",
    adminNotificationsDesc: "System and administrative notifications",
    adminAction: "Admin Actions",
    adminActionDesc: "Notifications about administrative actions and updates",
    emergencyAlert: "Emergency Alerts",
    emergencyAlertDesc: "Critical emergency notifications and warnings",
    socialNotifications: "Social & Community",
    socialNotificationsDesc: "Notifications about friends and community interactions",
    friendRequest: "Friend Requests",
    friendRequestDesc: "Notifications when someone sends you a friend request",
    messageReceived: "Messages Received",
    messageReceivedDesc: "Notifications when you receive a new message",
    notificationSettingsUpdated: "Settings Updated",
    notificationSettingsSaved: "Notification settings saved successfully",
    notificationSettingsError: "Error updating notification settings",
    // Profile section missing translations (only unique ones)
    permissionStatus: "Permission Status",
    geolocationPermission: "Location Access",
    geolocationDesc: "Required for incident alerts and safety features",
    geolocationActive: "Active",
    geolocationInactive: "Not Active",
    pushNotificationPermission: "Push Notifications",
    pushNotificationDesc: "Required to receive safety alerts and updates",
    pushNotificationActive: "Active",
    pushNotificationInactive: "Not Active",
    notificationTypes: "Notification Types",
    notificationSettingsDesc: "Configure detailed notification preferences by categories"
  },
  es: {
    // Authentication
    signIn: "Iniciar Sesión",
    signUp: "Registrarse",
    email: "Correo Electrónico",
    password: "Contraseña",
    confirmPassword: "Confirmar Contraseña",
    fullName: "Nombre Completo",
    fullNamePlaceholder: "Ingresa tu nombre completo",
    nickname: "Apodo",
    nicknamePlaceholder: "Ingresa tu apodo",
    signInWithGoogle: "Iniciar sesión con Google",
    signUpWithGoogle: "Registrarse con Google",
    loginWithGoogle: "Continuar con Google",
    orContinueWith: "O continuar con",
    alreadyHaveAccount: "¿Ya tienes una cuenta?",
    dontHaveAccount: "¿No tienes una cuenta?",
    welcomeBack: "¡Bienvenido de vuelta!",
    createAccountTitle: "Crear una cuenta",
    loginDescription: "Ingresa tus credenciales para acceder a tu cuenta",
    registerDescription: "Ingresa tu información para crear una nueva cuenta",
    loginButton: "Iniciar Sesión",
    registerButton: "Crear Cuenta",
    noAccount: "¿No tienes una cuenta?",
    hasAccount: "¿Ya tienes una cuenta?",
    forgotPassword: "¿Olvidaste tu contraseña?",
    resetPassword: "Restablecer contraseña",
    resetPasswordDesc: "Ingresa tu correo para restablecer tu contraseña",
    resetPasswordSent: "Correo de restablecimiento enviado",
    checkEmail: "Revisa tu correo para las instrucciones de restablecimiento",
    authError: "Error de autenticación",
    invalidCredentials: "Correo o contraseña inválidos",
    accountCreated: "Cuenta creada exitosamente",
    signedInSuccessfully: "Sesión iniciada exitosamente",
    signedOutSuccessfully: "Sesión cerrada exitosamente",
    loading: "Cargando...",
    termsText: "Al hacer clic en continuar, aceptas nuestros",
    termsOfService: "Términos de Servicio",
    and: "y",
    privacyPolicy: "Política de Privacidad",
    // Navigation
    map: "Mapa",
    community: "Comunidad",
    report: "Reportar",
    wanted: "Buscados",
    profile: "Perfil",
    // Main Screen
    neighborhood: "Barrio",
    activity: "Actividad",
    quickActions: "Acciones Rápidas",
    reportIncident: "Reportar Incidente",
    viewReports: "Ver Reportes",
    communityChat: "Chat de Comunidad",
    wantedPersons: "Personas Buscadas",
    recentActivity: "Actividad Reciente",
    safetyScore: "Índice de Seguridad",
    // Community
    communityTitle: "Comunidad",
    yourNeighborhood: "Tu Barrio",
    downtownArea: "Área Céntrica",
    neighborhoodChat: "Chat del Barrio",
    observations: "Observaciones",
    somethingStrange: "Algo Extraño",
    quickReport: "Reporte Rápido",
    whatNoticed: "¿Qué notaste?",
    addPhoto: "Agregar Foto",
    changePhoto: "Cambiar Foto",
    sendAnonymously: "Enviar Anónimamente",
    warn: "Advertir a la Comunidad",
    confirm: "Confirmar",
    confirmations: "confirmaciones",
    confirmed: "Confirmado",
    reject: "Rechazar",
    rejections: "rechazos",
    rejected: "Rechazado",
    confirmTitle: "Reporte Confirmado",
    confirmDesc: "Gracias por confirmar este reporte.",
    confirmRemovedTitle: "Confirmación Eliminada",
    confirmRemovedDesc: "Tu confirmación ha sido eliminada de este reporte.",
    rejectTitle: "Reporte Rechazado",
    rejectDesc: "Gracias por tu retroalimentación sobre este reporte.",
    rejectRemovedTitle: "Rechazo Eliminado",
    rejectRemovedDesc: "Tu rechazo ha sido eliminado de este reporte.",
    confirmOverrideTitle: "Reporte Confirmado",
    confirmOverrideDesc: "Tu rechazo anterior ha sido eliminado y el reporte confirmado.",
    rejectOverrideTitle: "Reporte Rechazado",
    rejectOverrideDesc: "Tu confirmación anterior ha sido eliminada y el reporte rechazado.",
    reportTitle: "Reporte Enviado",
    reportDesc: "Tu reporte ha sido enviado a la comunidad.",
    deleteReport: "Eliminar Reporte",
    reportDeleted: "Reporte Eliminado",
    reportDeletedDesc: "El reporte ha sido eliminado exitosamente.",
    deleteConfirm: "¿Estás seguro de que quieres eliminar este reporte?",
    deleteMessage: "Eliminar Mensaje",
    messageDeleted: "Mensaje Eliminado",
    messageDeletedDesc: "El mensaje ha sido eliminado exitosamente.",
    deleteMessageConfirm: "¿Estás seguro de que quieres eliminar este mensaje?",
    noPermissionDelete: "No tienes permiso para eliminar este mensaje",
    errorDeletingMessage: "Error al eliminar el mensaje",
    editThread: "Editar Hilo",
    threadUpdated: "Hilo Actualizado",
    threadUpdatedMessage: "El hilo ha sido actualizado exitosamente",
    deleteThreadConfirm: "¿Estás seguro de que quieres eliminar este hilo?",
    updating: "Actualizando...",
    // Community Chat
    createThread: "Crear Hilo",
    createNewThread: "Crear Nuevo Hilo",
    threadTitle: "Título del Hilo",
    threadDescription: "Descripción del Hilo (opcional)",
    creating: "Creando...",
    create: "Crear",
    threadCreated: "Hilo Creado",
    threadCreatedMessage: "Tu hilo ha sido creado exitosamente.",
    userAlreadyHasThread: "Solo puedes crear un hilo por usuario.",
    noThreadsYet: "No hay hilos aún",
    createFirstThread: "¡Sé el primero en comenzar una discusión!",
    mainThread: "Principal",
    createdByYou: "Tu hilo",
    messages: "mensajes",
    noMessages: "No hay mensajes aún",
    beFirstToMessage: "¡Sé el primero en enviar un mensaje!",
    writeMessage: "Escribe un mensaje...",
    searchInChat: "Buscar en el chat...",
    noSearchResults: "No se encontraron mensajes",
    tryDifferentKeywords: "Prueba con palabras clave diferentes",
    messageTitle: "Mensaje Enviado",
    messageDesc: "Tu mensaje ha sido publicado.",
    anonymously: "Anónimamente",
    you: "Tú",
    unknownUser: "Usuario Desconocido",
    comments: "Comentarios",
    noCommentsYet: "No hay comentarios aún",
    beFirstToComment: "¡Sé el primero en comentar!",
    writeComment: "Escribe un comentario...",
    commentAnonymously: "Comentar anónimamente",
    commentAdded: "Comentario Agregado",
    commentAddedDesc: "Tu comentario ha sido publicado.",
    commentDeleted: "Comentario Eliminado",
    commentDeletedDesc: "El comentario ha sido eliminado.",
    deleteCommentConfirm: "¿Estás seguro de que quieres eliminar este comentario?",
    // Wanted Persons
    addWantedPerson: "Agregar Persona Buscada",
    personName: "Nombre de la Persona",
    age: "Edad",
    years: "años",
    yearsOld: "años",
    description: "Descripción",
    lastSeenLocation: "Última Ubicación Vista",
    lastSeenDate: "Última Fecha Vista",
    contactInfo: "Información de Contacto",
    personAdded: "Persona Agregada",
    personAddedDesc: "La información de la persona buscada ha sido agregada exitosamente.",
    searchPerson: "Buscar persona...",
    noWantedPersons: "No hay personas buscadas reportadas",
    active: "Activo",
    caught: "Capturado",
    inactive: "Inactivo",
    noPhotoAvailable: "No hay foto disponible",
    noPhotoDescription: "No se han subido fotos",
    addedBy: "Agregado por",
    addedOn: "Agregado el",
    wanted_no_photo: "No hay foto disponible",
    wanted_no_photo_desc: "No se han subido fotos",
    wanted_status_active: "Activo",
    wanted_status_caught: "Capturado",
    wanted_status_inactive: "Inactivo",
    person_age: "{age} años",
    last_seen_location: "Última ubicación vista",
    last_seen_date: "Última fecha vista",
    contact_info: "Información de contacto",
    added_by: "Agregado por",
    added_on: "Agregado el",
    // Profile
    editProfile: "Editar Perfil",
    changePassword: "Cambiar Contraseña",
    signOut: "Cerrar Sesión",
    currentPassword: "Contraseña Actual",
    newPassword: "Nueva Contraseña",
    confirmNewPassword: "Confirmar Nueva Contraseña",
    save: "Guardar",
    update: "Actualizar",
    profileUpdated: "Perfil Actualizado",
    profileUpdatedMessage: "Tu perfil ha sido actualizado exitosamente.",
    passwordChanged: "Contraseña Cambiada",
    passwordChangedMessage: "Tu contraseña ha sido cambiada exitosamente.",
    statistics: "Estadísticas",
    notifications: "Notificaciones",
    days: "Días",
    nearbyIncidents: "Incidentes Cercanos",
    nearbyIncidentsDesc: "Recibe notificaciones sobre incidentes cercanos",
    emergencySituations: "Situaciones de Emergencia",
    emergencySituationsDesc: "Alertas críticas de seguridad",
    updates: "Actualizaciones",
    updatesDesc: "Actualizaciones de la app y anuncios",
    location: "Ubicación",
    tracking: "Seguimiento de Ubicación",
    trackingDesc: "Permitir acceso a ubicación para mejores características de seguridad",
    enabled: "Habilitado",
    alertRadius: "Radio de Alerta",
    alertRadiusDesc: "Distancia para notificaciones de incidentes",
    currentRadius: "Radio actual",
    meters: "metros",
    settings: "Configuraciones",
    contactSupport: "Contactar Soporte",
    aboutApp: "Acerca de la App",
    logout: "Cerrar Sesión",
    logoutSuccess: "Sesión Terminada",
    logoutMessage: "Has cerrado sesión exitosamente",
    logoutError: "Error al cerrar sesión",
    // Cache management
    cacheManagement: "Gestión de Caché",
    cacheManagementDesc: "Limpiar datos temporales de ubicación",
    clearCache: "Limpiar Caché",
    cacheCleared: "Caché Limpiado",
    cacheCleanedDesc: "Los datos temporales de ubicación han sido limpiados exitosamente",
    // Avatar management
    avatarUploaded: "Avatar Subido",
    avatarUploadedDesc: "Tu avatar ha sido subido exitosamente.",
    avatarError: "Error de Avatar",
    avatarSizeError: "El tamaño del archivo debe ser menor a 5MB",
    avatarTypeError: "Por favor selecciona un archivo de imagen",
    saving: "Guardando...",
    settingsUpdated: "Configuraciones Actualizadas",
    notificationsEnabled: "habilitadas",
    notificationsDisabled: "deshabilitadas",
    profileNotFound: "Perfil no encontrado",
    name: "Nombre",
    namePlaceholder: "Ingresa tu nombre",
    selectFromGallery: "Seleccionar de la Galería",
    saveChanges: "Guardar Cambios",
    profileUpdateMessage: "Tu información de perfil ha sido actualizada",
    // Reports/Map
    mapTitle: "Mapa de Seguridad",
    incidentTypes: "Tipos de Incidentes",
    allIncidents: "Todos los Incidentes",
    theft: "Robo",
    assault: "Asalto",
    vandalism: "Vandalismo",
    suspicious: "Actividad Sospechosa",
    emergency: "Emergencia",
    other: "Otro",
    filterByType: "Filtrar por Tipo",
    showMyReports: "Mostrar Mis Reportes",
    reportDetails: "Detalles del Reporte",
    reportedBy: "Reportado por",
    reportTime: "Hora del Reporte",
    incidentLocation: "Ubicación del Incidente",
    filterAll: "Todos",
    filterMine: "Mis Reportes",
    filterTheft: "Robo",
    filterAssault: "Asalto",
    filterVandalism: "Vandalismo",
    filterSuspicious: "Sospechoso",
    filterEmergency: "Emergencia",
    filterOther: "Otro",
    filterAccident: "Accidente",
    traffic_accident: "Accidente de Tráfico",
    recentIncidents: "Incidentes Recientes",
    filters: "Filtros",
    heatmap: "Mapa de Calor",
    traffic: "Tráfico",
    reportButton: "Reportar",
    noIncidents: "No hay incidentes reportados en esta área",
    beFirstToReport: "¡Sé el primero en reportar un incidente!",
    // Severity levels
    low: "Bajo",
    medium: "Medio",
    high: "Alto",
    // Report Incident
    reportIncidentTitle: "Reportar Incidente",
    incidentType: "Tipo de Incidente",
    selectIncidentType: "Seleccionar Tipo de Incidente",
    selectIncidentTypeDesc: "Por favor, selecciona primero el tipo de incidente",
    firstSelectIncidentType: "Primero selecciona un tipo de incidente",
    incidentDescription: "Descripción del Incidente",
    detailedDescription: "Descripción Detallada",
    describeSituation: "Describe lo que pasó",
    descriptionPlaceholder: "Describe el incidente en detalle...",
    selectLocation: "Seleccionar ubicación en el mapa",
    currentLocation: "Usar ubicación actual",
    useMyGeolocation: "Usar Mi Geolocalización",
    selectOnMap: "Seleccionar en el Mapa",
    accident: "Accidente",
    uploadPhotos: "Subir Fotos",
    selectPhotos: "Seleccionar Fotos (opcional)",
    photos: "Fotos",
    photo: "Foto",
    clickToViewGallery: "Haz clic en las fotos para ver en la galería",
    viewInGallery: "Ver en Galería",
    downloadPhoto: "Descargar Foto",
    zoomIn: "Acercar",
    zoomOut: "Alejar",
    close: "Cerrar",
    navigate: "Navegar",
    zoom: "Zoom",
    previousPhoto: "Foto Anterior",
    nextPhoto: "Foto Siguiente",
    takePhoto: "Tomar Foto",
    anonymousReport: "Reporte Anónimo",
    submitReport: "Enviar Reporte",
    sendReport: "Enviar Reporte",
    reportSubmitted: "Reporte Enviado",
    reportSubmittedDesc: "Tu reporte de incidente ha sido enviado exitosamente",
    reportSent: "Reporte enviado exitosamente",
    reportSentDesc: "Tu reporte de incidente ha sido enviado y ahora es visible para la comunidad",
    title: "Título",
    titlePlaceholder: "Ingresa el título del incidente...",
    // Common
    submit: "Enviar",
    cancel: "Cancelar",
    uploading: "Subiendo...",
    errorTitle: "Error",
    connectionError: "Error de conexión. Por favor, intenta de nuevo.",
    validationError: "Error de Validación",
    fillAllFields: "Por favor, completa todos los campos requeridos.",
    fillAllFieldsDesc: "Todos los campos requeridos deben ser completados.",
    yourLocation: "Tu Ubicación",
    mapView: "Mapa",
    filterAlerts: "Filtrar Alertas",
    allAlerts: "Todas las Alertas",
    nearbyAlerts: "Alertas Cercanas",
    radiusSettings: "Configuraciones de Radio",
    setAlertRadius: "Establecer Radio de Alerta",
    radiusInMeters: "Radio en metros",
    // Time indicators for incidents
    expired: "Expirado",
    minutesShort: "min",
    hoursShort: "h",
    daysShort: "d",
    remainingTime: "Tiempo restante",
    timeRemaining: "Tiempo restante",
    expiresIn: "Expira en",
    incidentDuration: "Duración del incidente",
    autoRemovalInfo: "El incidente será eliminado automáticamente después de este tiempo",
    // User Roles
    user: "Usuario",
    admin: "Administrador",
    masterAdmin: "Administrador Maestro",
    adminActions: "Acciones de Administrador",
    deleteAnyContent: "Puede eliminar cualquier contenido",
    manageUsers: "Puede gestionar usuarios",
    manageAdmins: "Puede gestionar administradores",
    // Time and creation info
    createdBy: "Creado por",
    createdAt: "Creado el",
    expiresAfter: "Expira después de",
    daysText: "días",
    // Missing persons moderation actions
    markAsActive: "Marcar como Activo",
    markAsFound: "Marcar como Encontrado",
    markAsClosed: "Marcar como Cerrado",
    activate: "Activar",
    delete: "Eliminar",
    // Message status
    delivered: "Entregado",
    accessDenied: "Access Denied",
    accountBlocked: "Cuenta Bloqueada",
    blockedUntil: "Bloqueado hasta",
    blockedPermanently: "Bloqueado permanentemente",
    cannotPerformAction: "No puedes realizar esta acción mientras estés bloqueado",
    clickToSelectLocation: "Haz clic para seleccionar ubicación",
    // Traffic Push Notifications
    trafficPushEnabled: "Notificaciones push de tráfico habilitadas",
    trafficPushDisabled: "Notificaciones push de tráfico deshabilitadas",
    trafficPushEnabledDesc: "Recibirás notificaciones push sobre el tráfico adelante",
    trafficPushDisabledDesc: "Las notificaciones push de tráfico están deshabilitadas",
    trafficAhead: "Tráfico adelante",
    heavyTrafficAhead: "Tráfico pesado adelante",
    severeJamAhead: "Embotellamiento severo adelante",
    trafficDetected: "Tráfico detectado",
    estimatedDelay: "Retraso estimado",
    minutes: "minutos",
    considerAlternativeRoute: "Considera ruta alternativa",
    slowDown: "Reduce la velocidad",
    keepDistance: "Mantén la distancia",
    bePatient: "Sé paciente",
    usePublicTransport: "Usa transporte público",
    postponeTrip: "Pospón el viaje por 15-20 minutos",
    // Traffic notification titles
    trafficSevereTitle: "Tráfico severo adelante",
    trafficHeavyTitle: "Tráfico pesado adelante",
    trafficModerateTitle: "Tráfico moderado adelante",
    trafficLowTitle: "Tráfico ligero adelante",
    trafficDefaultTitle: "Tráfico adelante",
    // Traffic notification messages
    trafficSevereMessage: "Tráfico severo en {distance}. Retraso estimado: {delay} min.",
    trafficHeavyMessage: "Tráfico pesado en {distance}. Posible retraso: {delay} min.",
    trafficModerateMessage: "Tráfico moderado en {distance}. Retraso: {delay} min.",
    trafficLowMessage: "Tráfico ligero en {distance}.",
    trafficDefaultMessage: "Tráfico detectado en {distance}.",
    // Traffic suggestions
    trafficSuggestionAlternative: "Considera ruta alternativa",
    trafficSuggestionDelay: "Pospón el viaje por 15-20 minutos",
    trafficSuggestionPublic: "Usa transporte público",
    trafficSuggestionSlowDown: "Reduce la velocidad",
    trafficSuggestionDistance: "Mantén la distancia",
    trafficSuggestionDetour: "Considera desvío",
    trafficSuggestionPatient: "Sé paciente",
    trafficSuggestionCaution: "Sé cauteloso",
    // Units
    km: "km",
    m: "m",
    // Radar Pro Premium Subscription
    radarPro: "Radar Pro",
    premiumSubscription: "Suscripción Premium",
    upgradeToRadarPro: "Actualizar a Radar Pro",
    radarProDesc: "Desbloquea características avanzadas de seguridad y herramientas premium",
    radarProFeatures: "Características Premium",
    trafficAlerts: "Alertas de Tráfico en Tiempo Real",
    trafficAlertsDesc: "Recibe notificaciones push sobre el tráfico adelante en tu ruta",
    advancedHeatmap: "Mapa de Calor Avanzado de Incidentes",
    advancedHeatmapDesc: "Mapa visual de densidad de incidentes con alertas de vibración",
    smartNotifications: "Notificaciones Inteligentes AI",
    smartNotificationsDesc: "Alertas inteligentes basadas en tu ubicación y movimiento",
    communityFeatures: "Características Mejoradas de Comunidad",
    communityFeaturesDesc: "Chat avanzado de comunidad, hilos y herramientas de reporte",
    adminTools: "Herramientas de Administrador",
    adminToolsDesc: "Gestión de usuarios, moderación de contenido y panel de analíticas",
    multiLanguage: "Soporte Multi-idioma",
    multiLanguageDesc: "Soporte completo para idiomas inglés, español y ruso",
    premiumSupport: "Soporte Premium 24/7",
    premiumSupportDesc: "Soporte prioritario al cliente y asistencia técnica",
    noAds: "Sin Anuncios",
    noAdsDesc: "Disfruta la app sin anuncios e interrupciones",
    subscribeNow: "Suscribirse Ahora",
    monthlyPrice: "$14.99/mes",
    yearlyPrice: "$149.99/año",
    freeTrial: "7 días gratis",
    // Badges
    earned: "Obtenido",
    recently: "Recientemente",
    badgesEarned: "insignias obtenidas",
    // XP System
    howToEarnXP: "Cómo Ganar XP",
    xpGuideTitle: "Cómo Ganar XP y Subir de Nivel",
    whatIsXP: "¿Qué es XP?",
    xpExplanation: "XP (Puntos de Experiencia) son puntos que ganas por varias acciones en la app. Al acumular XP, subes de nivel y obtienes acceso a nuevas características.",
    whyLevels: "¿Por qué Niveles?",
    whyLevelsDesc: "Un nivel alto muestra tu actividad y confiabilidad en la comunidad. Los usuarios con niveles altos obtienen más confianza y privilegios adicionales.",
    levelSystem: "Sistema de Niveles",
    howToEarnXPSection: "Cómo Ganar XP",
    badgeSystem: "Sistema de Insignias",
    badgeSystemDesc: "Las insignias son recompensas por logros especiales. Se otorgan automáticamente cuando cumples ciertas condiciones.",
    tipsForProgress: "Consejos para Progreso Rápido",
    dailyActivity: "Actividad Diaria",
    qualityReports: "Reportes de Calidad",
    communityHelp: "Ayuda a la Comunidad",
    quickResponse: "Respuesta Rápida",
    startNow: "¡Comienza Ahora!",
    startNowDesc: "Cada acción que tomas hace que la comunidad sea más segura y ayuda a otros usuarios. ¡Comienza creando tu primer reporte y gana tu primer XP!",
    goodLuck: "¡Buena suerte alcanzando nuevos niveles! 🚀",
    maxLevelReached: "🏆 ¡Nivel máximo alcanzado!",
    tips: "Consejos",
    toNextLevel: "al siguiente nivel",
    // XP Activities
    createReport: "Crear Reporte",
    createReportDesc: "Reporta un incidente o peligro en tu área",
    createReportTip: "Agrega descripción detallada y ubicación precisa",
    addPhotoToReport: "Agregar Foto al Reporte",
    addPhotoDesc: "Adjunta fotos o videos a tu reporte",
    addPhotoTip: "Las fotos ayudan a otros usuarios a entender mejor la situación",
    confirmReport: "Confirmar Reporte",
    confirmReportDesc: "Confirma el reporte de otro usuario si también viste el incidente",
    confirmReportTip: "Solo confirma reportes que realmente presenciaste",
    chatParticipation: "Participación en Chat de Comunidad",
    chatParticipationDesc: "Comunícate con otros usuarios en el chat de comunidad",
    chatParticipationTip: "Comparte información útil y ayuda a otros",
    quickResponseTitle: "Respuesta Rápida",
    quickResponseDesc: "Sé el primero en responder a situaciones de emergencia",
    quickResponseTip: "Quickly react to critical situations in your area",
    dailyLogin: "Inicio de Sesión Diario",
    dailyLoginDesc: "Visita la app todos los días",
    dailyLoginTip: "El uso regular de la app ayuda a mantenerse informado sobre eventos",
    profileUpdate: "Actualización de Perfil",
    profileUpdateDesc: "Completa y actualiza tu información de perfil",
    profileUpdateTip: "Un perfil completo aumenta la confianza de otros usuarios",
    communityParticipation: "Participación en la Comunidad",
    communityParticipationDesc: "Participa activamente en la vida de la comunidad",
    communityParticipationTip: "Ayuda a los nuevos usuarios y comparte experiencia",
    // Activity tips
    dailyActivityTips: "• Visita la app todos los días\n• Revisa el mapa para nuevos incidentes\n• Participa en el chat de comunidad",
    qualityReportsTips: "• Siempre agrega fotos a los reportes\n• Escribe descripciones detalladas\n• Especifica la ubicación exacta",
    communityHelpTips: "• Confirma reportes de otros usuarios\n• Responde preguntas en el chat\n• Comparte información útil",
    quickResponseTips: "• Habilita notificaciones push\n• Reacciona rápidamente a situaciones de emergencia\n• Sé el primero en ayudar",
    // Badges
    firstReportBadge: "Primer Reporte",
    firstReportCondition: "Crea tu primer reporte",
    dangerHunterBadge: "Cazador de Peligros",
    dangerHunterCondition: "Reporta 3 incidentes",
    urbanExplorerBadge: "Explorador Urbano",
    urbanExplorerCondition: "Reportes de 3+ áreas diferentes",
    communityVoiceBadge: "Voz de la Comunidad",
    communityVoiceCondition: "Obtén 10+ confirmaciones",
    visualEyeBadge: "Ojo Visual",
    visualEyeCondition: "Agrega 5+ fotos/videos",
    localProtectorBadge: "Protector Local",
    localProtectorCondition: "Sé el primero en el lugar",
    consistentBadge: "Consistente",
    consistentCondition: "Activo 7 días seguidos",
    advisorBadge: "Consejero",
    advisorCondition: "Sugerencia aprobada",
    radarEliteBadge: "Radar Elite",
    radarEliteCondition: "Alcanza nivel Comandante",
    // Level names
    observador: "Observador",
    reportero: "Reportero",
    radarCiudadano: "Radar Ciudadano",
    vigilante: "Vigilante",
    patrullero: "Patrullero",
    comandante: "Comandante",
    replyingTo: "Responder a",
    swipeToReply: "Desliza a la derecha para responder",
    // Reactions
    confirmAction: "Confirmar",
    rejectAction: "Rechazar",
    incidentPendingDeletion: "Este incidente será eliminado en 30 minutos debido a la alta tasa de rechazo",
    errorSavingReaction: "Error al guardar tu reacción",
    incidentDeleted: "Incidente Eliminado",
    incidentDeletedMessage: "El incidente ha sido eliminado exitosamente.",
    // Comments
    addCommentPlaceholder: "Agrega tu comentario...",
    postAnonymously: "Publicar anónimamente",
    send: "Enviar",
    anonymous: "Anónimo",
    errorAddingComment: "Error al agregar comentario",
    // Onboarding
    allowLocationAccess: "Permitir Acceso a Ubicación",
    locationPermissionDesc: "Usamos geolocalización para enviarte alertas sobre incidentes cercanos. Los datos se eliminan después de 30 días.",
    allowNotifications: "Permitir Notificaciones",
    notificationPermissionDesc: "Para recibir alertas en tiempo real sobre incidentes",
    continue: "Continuar",
    demoIncidents: "0.3 km de ti — Robo a mano armada en Main St. Evita el área.\n0.15 km de ti — Accidente de auto en Highway 101. Retrasos de tráfico.\n0.8 km de ti — Actividad sospechosa cerca de Central Park. Mantente alerta.\n0.5 km de ti — Emergencia de incendio en Oak Avenue. Servicios de emergencia respondiendo.",
    // Historical incident popup labels
    typeLabel: "Tipo",
    dateLabel: "Fecha",
    // Notification Settings
    notificationSettings: "Configuración de Notificaciones",
    proximityNotifications: "Seguridad e Incidentes",
    proximityNotificationsDesc: "Notificaciones sobre incidentes cercanos, alertas de emergencia y actividad",
    incidentNearby: "Incidentes Cercanos",
    incidentNearbyDesc: "Alertar cuando se reporten incidentes peligrosos cerca de ti",
    friendNearby: "Amigos Cercanos",
    friendNearbyDesc: "Notificar cuando amigos estén en tu proximidad",
    areaActivity: "Actividad del Área",
    areaActivityDesc: "Actualizaciones sobre alta actividad de incidentes en tu área",
    adminNotifications: "Administración",
    adminNotificationsDesc: "Notificaciones del sistema y administrativas",
    adminAction: "Acciones de Admin",
    adminActionDesc: "Notificaciones sobre acciones administrativas y actualizaciones",
    emergencyAlert: "Alertas de Emergencia",
    emergencyAlertDesc: "Notificaciones críticas de emergencia y advertencias",
    socialNotifications: "Social y Comunidad",
    socialNotificationsDesc: "Notificaciones sobre amigos e interacciones de la comunidad",
    friendRequest: "Solicitudes de Amistad",
    friendRequestDesc: "Notificaciones cuando alguien te envía una solicitud de amistad",
    messageReceived: "Mensajes Recibidos",
    messageReceivedDesc: "Notificaciones cuando recibes un nuevo mensaje",
    notificationSettingsUpdated: "Configuración Actualizada",
    notificationSettingsSaved: "Configuración de notificaciones guardada exitosamente",
    notificationSettingsError: "Error al actualizar configuración de notificaciones",
    // Profile section missing translations (only unique ones)
    permissionStatus: "Estado de Permisos",
    geolocationPermission: "Acceso a Ubicación",
    geolocationDesc: "Requerido para alertas de incidentes y funciones de seguridad",
    geolocationActive: "Activo",
    geolocationInactive: "No Activo",
    pushNotificationPermission: "Notificaciones Push",
    pushNotificationDesc: "Requerido para recibir alertas de seguridad y actualizaciones",
    pushNotificationActive: "Activo",
    pushNotificationInactive: "No Activo",
    notificationTypes: "Tipos de Notificaciones",
    notificationSettingsDesc: "Configurar preferencias detalladas de notificaciones por categorías"
  }
};
const LanguageProvider = ({ children }) => {
  console.log("LanguageProvider initializing...");
  const [language, setLanguage] = reactExports.useState("en");
  reactExports.useEffect(() => {
    console.log("LanguageProvider useEffect running...");
    const savedLanguage = localStorage.getItem("language");
    if (savedLanguage && (savedLanguage === "en" || savedLanguage === "es")) {
      setLanguage(savedLanguage);
    }
  }, []);
  const handleSetLanguage = (newLanguage) => {
    setLanguage(newLanguage);
    localStorage.setItem("language", newLanguage);
  };
  const t2 = (key2, options) => {
    const lang = translations$3[language] || translations$3.en;
    let translation = lang[key2] || key2;
    if (options) {
      Object.keys(options).forEach((optionKey) => {
        translation = translation.replace(`{{${optionKey}}}`, String(options[optionKey]));
      });
    }
    return translation;
  };
  return /* @__PURE__ */ jsxRuntimeExports.jsx(LanguageContext.Provider, { value: { language, setLanguage: handleSetLanguage, t: t2 }, children });
};
const SUPABASE_URL = "https://vqxdqcqseawmvfmayoib.supabase.co";
const SUPABASE_PUBLISHABLE_KEY = "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6InZxeGRxY3FzZWF3bXZmbWF5b2liIiwicm9sZSI6ImFub24iLCJpYXQiOjE3NTAwOTkxMDksImV4cCI6MjA2NTY3NTEwOX0.ao4bWJhCUUKUpHt7sLFFfUWqzgscuGlCa-kueEmIjKY";
const supabase = createClient(SUPABASE_URL, SUPABASE_PUBLISHABLE_KEY);
/*! Capacitor: https://capacitorjs.com/ - MIT License */
const createCapacitorPlatforms = (win2) => {
  const defaultPlatformMap = /* @__PURE__ */ new Map();
  defaultPlatformMap.set("web", { name: "web" });
  const capPlatforms = win2.CapacitorPlatforms || {
    currentPlatform: { name: "web" },
    platforms: defaultPlatformMap
  };
  const addPlatform2 = (name, platform2) => {
    capPlatforms.platforms.set(name, platform2);
  };
  const setPlatform2 = (name) => {
    if (capPlatforms.platforms.has(name)) {
      capPlatforms.currentPlatform = capPlatforms.platforms.get(name);
    }
  };
  capPlatforms.addPlatform = addPlatform2;
  capPlatforms.setPlatform = setPlatform2;
  return capPlatforms;
};
const initPlatforms = (win2) => win2.CapacitorPlatforms = createCapacitorPlatforms(win2);
const CapacitorPlatforms = /* @__PURE__ */ initPlatforms(typeof globalThis !== "undefined" ? globalThis : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : typeof globalThis !== "undefined" ? globalThis : {});
CapacitorPlatforms.addPlatform;
CapacitorPlatforms.setPlatform;
var ExceptionCode;
(function(ExceptionCode2) {
  ExceptionCode2["Unimplemented"] = "UNIMPLEMENTED";
  ExceptionCode2["Unavailable"] = "UNAVAILABLE";
})(ExceptionCode || (ExceptionCode = {}));
class CapacitorException extends Error {
  constructor(message, code, data) {
    super(message);
    this.message = message;
    this.code = code;
    this.data = data;
  }
}
const getPlatformId = (win2) => {
  var _a2, _b2;
  if (win2 === null || win2 === void 0 ? void 0 : win2.androidBridge) {
    return "android";
  } else if ((_b2 = (_a2 = win2 === null || win2 === void 0 ? void 0 : win2.webkit) === null || _a2 === void 0 ? void 0 : _a2.messageHandlers) === null || _b2 === void 0 ? void 0 : _b2.bridge) {
    return "ios";
  } else {
    return "web";
  }
};
const createCapacitor = (win2) => {
  var _a2, _b2, _c2, _d2, _e2;
  const capCustomPlatform = win2.CapacitorCustomPlatform || null;
  const cap = win2.Capacitor || {};
  const Plugins2 = cap.Plugins = cap.Plugins || {};
  const capPlatforms = win2.CapacitorPlatforms;
  const defaultGetPlatform = () => {
    return capCustomPlatform !== null ? capCustomPlatform.name : getPlatformId(win2);
  };
  const getPlatform = ((_a2 = capPlatforms === null || capPlatforms === void 0 ? void 0 : capPlatforms.currentPlatform) === null || _a2 === void 0 ? void 0 : _a2.getPlatform) || defaultGetPlatform;
  const defaultIsNativePlatform = () => getPlatform() !== "web";
  const isNativePlatform = ((_b2 = capPlatforms === null || capPlatforms === void 0 ? void 0 : capPlatforms.currentPlatform) === null || _b2 === void 0 ? void 0 : _b2.isNativePlatform) || defaultIsNativePlatform;
  const defaultIsPluginAvailable = (pluginName) => {
    const plugin = registeredPlugins.get(pluginName);
    if (plugin === null || plugin === void 0 ? void 0 : plugin.platforms.has(getPlatform())) {
      return true;
    }
    if (getPluginHeader(pluginName)) {
      return true;
    }
    return false;
  };
  const isPluginAvailable = ((_c2 = capPlatforms === null || capPlatforms === void 0 ? void 0 : capPlatforms.currentPlatform) === null || _c2 === void 0 ? void 0 : _c2.isPluginAvailable) || defaultIsPluginAvailable;
  const defaultGetPluginHeader = (pluginName) => {
    var _a22;
    return (_a22 = cap.PluginHeaders) === null || _a22 === void 0 ? void 0 : _a22.find((h2) => h2.name === pluginName);
  };
  const getPluginHeader = ((_d2 = capPlatforms === null || capPlatforms === void 0 ? void 0 : capPlatforms.currentPlatform) === null || _d2 === void 0 ? void 0 : _d2.getPluginHeader) || defaultGetPluginHeader;
  const handleError = (err) => win2.console.error(err);
  const pluginMethodNoop = (_target, prop, pluginName) => {
    return Promise.reject(`${pluginName} does not have an implementation of "${prop}".`);
  };
  const registeredPlugins = /* @__PURE__ */ new Map();
  const defaultRegisterPlugin = (pluginName, jsImplementations = {}) => {
    const registeredPlugin = registeredPlugins.get(pluginName);
    if (registeredPlugin) {
      console.warn(`Capacitor plugin "${pluginName}" already registered. Cannot register plugins twice.`);
      return registeredPlugin.proxy;
    }
    const platform2 = getPlatform();
    const pluginHeader = getPluginHeader(pluginName);
    let jsImplementation;
    const loadPluginImplementation = async () => {
      if (!jsImplementation && platform2 in jsImplementations) {
        jsImplementation = typeof jsImplementations[platform2] === "function" ? jsImplementation = await jsImplementations[platform2]() : jsImplementation = jsImplementations[platform2];
      } else if (capCustomPlatform !== null && !jsImplementation && "web" in jsImplementations) {
        jsImplementation = typeof jsImplementations["web"] === "function" ? jsImplementation = await jsImplementations["web"]() : jsImplementation = jsImplementations["web"];
      }
      return jsImplementation;
    };
    const createPluginMethod = (impl, prop) => {
      var _a22, _b22;
      if (pluginHeader) {
        const methodHeader = pluginHeader === null || pluginHeader === void 0 ? void 0 : pluginHeader.methods.find((m2) => prop === m2.name);
        if (methodHeader) {
          if (methodHeader.rtype === "promise") {
            return (options) => cap.nativePromise(pluginName, prop.toString(), options);
          } else {
            return (options, callback) => cap.nativeCallback(pluginName, prop.toString(), options, callback);
          }
        } else if (impl) {
          return (_a22 = impl[prop]) === null || _a22 === void 0 ? void 0 : _a22.bind(impl);
        }
      } else if (impl) {
        return (_b22 = impl[prop]) === null || _b22 === void 0 ? void 0 : _b22.bind(impl);
      } else {
        throw new CapacitorException(`"${pluginName}" plugin is not implemented on ${platform2}`, ExceptionCode.Unimplemented);
      }
    };
    const createPluginMethodWrapper = (prop) => {
      let remove;
      const wrapper2 = (...args) => {
        const p2 = loadPluginImplementation().then((impl) => {
          const fn = createPluginMethod(impl, prop);
          if (fn) {
            const p22 = fn(...args);
            remove = p22 === null || p22 === void 0 ? void 0 : p22.remove;
            return p22;
          } else {
            throw new CapacitorException(`"${pluginName}.${prop}()" is not implemented on ${platform2}`, ExceptionCode.Unimplemented);
          }
        });
        if (prop === "addListener") {
          p2.remove = async () => remove();
        }
        return p2;
      };
      wrapper2.toString = () => `${prop.toString()}() { [capacitor code] }`;
      Object.defineProperty(wrapper2, "name", {
        value: prop,
        writable: false,
        configurable: false
      });
      return wrapper2;
    };
    const addListener = createPluginMethodWrapper("addListener");
    const removeListener = createPluginMethodWrapper("removeListener");
    const addListenerNative = (eventName, callback) => {
      const call = addListener({ eventName }, callback);
      const remove = async () => {
        const callbackId = await call;
        removeListener({
          eventName,
          callbackId
        }, callback);
      };
      const p2 = new Promise((resolve) => call.then(() => resolve({ remove })));
      p2.remove = async () => {
        console.warn(`Using addListener() without 'await' is deprecated.`);
        await remove();
      };
      return p2;
    };
    const proxy = new Proxy({}, {
      get(_2, prop) {
        switch (prop) {
          case "$$typeof":
            return void 0;
          case "toJSON":
            return () => ({});
          case "addListener":
            return pluginHeader ? addListenerNative : addListener;
          case "removeListener":
            return removeListener;
          default:
            return createPluginMethodWrapper(prop);
        }
      }
    });
    Plugins2[pluginName] = proxy;
    registeredPlugins.set(pluginName, {
      name: pluginName,
      proxy,
      platforms: /* @__PURE__ */ new Set([
        ...Object.keys(jsImplementations),
        ...pluginHeader ? [platform2] : []
      ])
    });
    return proxy;
  };
  const registerPlugin2 = ((_e2 = capPlatforms === null || capPlatforms === void 0 ? void 0 : capPlatforms.currentPlatform) === null || _e2 === void 0 ? void 0 : _e2.registerPlugin) || defaultRegisterPlugin;
  if (!cap.convertFileSrc) {
    cap.convertFileSrc = (filePath) => filePath;
  }
  cap.getPlatform = getPlatform;
  cap.handleError = handleError;
  cap.isNativePlatform = isNativePlatform;
  cap.isPluginAvailable = isPluginAvailable;
  cap.pluginMethodNoop = pluginMethodNoop;
  cap.registerPlugin = registerPlugin2;
  cap.Exception = CapacitorException;
  cap.DEBUG = !!cap.DEBUG;
  cap.isLoggingEnabled = !!cap.isLoggingEnabled;
  cap.platform = cap.getPlatform();
  cap.isNative = cap.isNativePlatform();
  return cap;
};
const initCapacitorGlobal = (win2) => win2.Capacitor = createCapacitor(win2);
const Capacitor = /* @__PURE__ */ initCapacitorGlobal(typeof globalThis !== "undefined" ? globalThis : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : typeof globalThis !== "undefined" ? globalThis : {});
const registerPlugin = Capacitor.registerPlugin;
Capacitor.Plugins;
class WebPlugin {
  constructor(config2) {
    this.listeners = {};
    this.retainedEventArguments = {};
    this.windowListeners = {};
    if (config2) {
      console.warn(`Capacitor WebPlugin "${config2.name}" config object was deprecated in v3 and will be removed in v4.`);
      this.config = config2;
    }
  }
  addListener(eventName, listenerFunc) {
    let firstListener = false;
    const listeners2 = this.listeners[eventName];
    if (!listeners2) {
      this.listeners[eventName] = [];
      firstListener = true;
    }
    this.listeners[eventName].push(listenerFunc);
    const windowListener = this.windowListeners[eventName];
    if (windowListener && !windowListener.registered) {
      this.addWindowListener(windowListener);
    }
    if (firstListener) {
      this.sendRetainedArgumentsForEvent(eventName);
    }
    const remove = async () => this.removeListener(eventName, listenerFunc);
    const p2 = Promise.resolve({ remove });
    return p2;
  }
  async removeAllListeners() {
    this.listeners = {};
    for (const listener in this.windowListeners) {
      this.removeWindowListener(this.windowListeners[listener]);
    }
    this.windowListeners = {};
  }
  notifyListeners(eventName, data, retainUntilConsumed) {
    const listeners2 = this.listeners[eventName];
    if (!listeners2) {
      if (retainUntilConsumed) {
        let args = this.retainedEventArguments[eventName];
        if (!args) {
          args = [];
        }
        args.push(data);
        this.retainedEventArguments[eventName] = args;
      }
      return;
    }
    listeners2.forEach((listener) => listener(data));
  }
  hasListeners(eventName) {
    return !!this.listeners[eventName].length;
  }
  registerWindowListener(windowEventName, pluginEventName) {
    this.windowListeners[pluginEventName] = {
      registered: false,
      windowEventName,
      pluginEventName,
      handler: (event) => {
        this.notifyListeners(pluginEventName, event);
      }
    };
  }
  unimplemented(msg = "not implemented") {
    return new Capacitor.Exception(msg, ExceptionCode.Unimplemented);
  }
  unavailable(msg = "not available") {
    return new Capacitor.Exception(msg, ExceptionCode.Unavailable);
  }
  async removeListener(eventName, listenerFunc) {
    const listeners2 = this.listeners[eventName];
    if (!listeners2) {
      return;
    }
    const index2 = listeners2.indexOf(listenerFunc);
    this.listeners[eventName].splice(index2, 1);
    if (!this.listeners[eventName].length) {
      this.removeWindowListener(this.windowListeners[eventName]);
    }
  }
  addWindowListener(handle) {
    window.addEventListener(handle.windowEventName, handle.handler);
    handle.registered = true;
  }
  removeWindowListener(handle) {
    if (!handle) {
      return;
    }
    window.removeEventListener(handle.windowEventName, handle.handler);
    handle.registered = false;
  }
  sendRetainedArgumentsForEvent(eventName) {
    const args = this.retainedEventArguments[eventName];
    if (!args) {
      return;
    }
    delete this.retainedEventArguments[eventName];
    args.forEach((arg2) => {
      this.notifyListeners(eventName, arg2);
    });
  }
}
const encode = (str) => encodeURIComponent(str).replace(/%(2[346B]|5E|60|7C)/g, decodeURIComponent).replace(/[()]/g, escape);
const decode = (str) => str.replace(/(%[\dA-F]{2})+/gi, decodeURIComponent);
class CapacitorCookiesPluginWeb extends WebPlugin {
  async getCookies() {
    const cookies = document.cookie;
    const cookieMap = {};
    cookies.split(";").forEach((cookie) => {
      if (cookie.length <= 0)
        return;
      let [key2, value] = cookie.replace(/=/, "CAP_COOKIE").split("CAP_COOKIE");
      key2 = decode(key2).trim();
      value = decode(value).trim();
      cookieMap[key2] = value;
    });
    return cookieMap;
  }
  async setCookie(options) {
    try {
      const encodedKey = encode(options.key);
      const encodedValue = encode(options.value);
      const expires = `; expires=${(options.expires || "").replace("expires=", "")}`;
      const path = (options.path || "/").replace("path=", "");
      const domain = options.url != null && options.url.length > 0 ? `domain=${options.url}` : "";
      document.cookie = `${encodedKey}=${encodedValue || ""}${expires}; path=${path}; ${domain};`;
    } catch (error) {
      return Promise.reject(error);
    }
  }
  async deleteCookie(options) {
    try {
      document.cookie = `${options.key}=; Max-Age=0`;
    } catch (error) {
      return Promise.reject(error);
    }
  }
  async clearCookies() {
    try {
      const cookies = document.cookie.split(";") || [];
      for (const cookie of cookies) {
        document.cookie = cookie.replace(/^ +/, "").replace(/=.*/, `=;expires=${(/* @__PURE__ */ new Date()).toUTCString()};path=/`);
      }
    } catch (error) {
      return Promise.reject(error);
    }
  }
  async clearAllCookies() {
    try {
      await this.clearCookies();
    } catch (error) {
      return Promise.reject(error);
    }
  }
}
registerPlugin("CapacitorCookies", {
  web: () => new CapacitorCookiesPluginWeb()
});
const readBlobAsBase64 = async (blob) => new Promise((resolve, reject) => {
  const reader = new FileReader();
  reader.onload = () => {
    const base64String = reader.result;
    resolve(base64String.indexOf(",") >= 0 ? base64String.split(",")[1] : base64String);
  };
  reader.onerror = (error) => reject(error);
  reader.readAsDataURL(blob);
});
const normalizeHttpHeaders = (headers = {}) => {
  const originalKeys = Object.keys(headers);
  const loweredKeys = Object.keys(headers).map((k2) => k2.toLocaleLowerCase());
  const normalized = loweredKeys.reduce((acc, key2, index2) => {
    acc[key2] = headers[originalKeys[index2]];
    return acc;
  }, {});
  return normalized;
};
const buildUrlParams = (params, shouldEncode = true) => {
  if (!params)
    return null;
  const output = Object.entries(params).reduce((accumulator, entry) => {
    const [key2, value] = entry;
    let encodedValue;
    let item;
    if (Array.isArray(value)) {
      item = "";
      value.forEach((str) => {
        encodedValue = shouldEncode ? encodeURIComponent(str) : str;
        item += `${key2}=${encodedValue}&`;
      });
      item.slice(0, -1);
    } else {
      encodedValue = shouldEncode ? encodeURIComponent(value) : value;
      item = `${key2}=${encodedValue}`;
    }
    return `${accumulator}&${item}`;
  }, "");
  return output.substr(1);
};
const buildRequestInit = (options, extra = {}) => {
  const output = Object.assign({ method: options.method || "GET", headers: options.headers }, extra);
  const headers = normalizeHttpHeaders(options.headers);
  const type = headers["content-type"] || "";
  if (typeof options.data === "string") {
    output.body = options.data;
  } else if (type.includes("application/x-www-form-urlencoded")) {
    const params = new URLSearchParams();
    for (const [key2, value] of Object.entries(options.data || {})) {
      params.set(key2, value);
    }
    output.body = params.toString();
  } else if (type.includes("multipart/form-data") || options.data instanceof FormData) {
    const form = new FormData();
    if (options.data instanceof FormData) {
      options.data.forEach((value, key2) => {
        form.append(key2, value);
      });
    } else {
      for (const key2 of Object.keys(options.data)) {
        form.append(key2, options.data[key2]);
      }
    }
    output.body = form;
    const headers2 = new Headers(output.headers);
    headers2.delete("content-type");
    output.headers = headers2;
  } else if (type.includes("application/json") || typeof options.data === "object") {
    output.body = JSON.stringify(options.data);
  }
  return output;
};
class CapacitorHttpPluginWeb extends WebPlugin {
  /**
   * Perform an Http request given a set of options
   * @param options Options to build the HTTP request
   */
  async request(options) {
    const requestInit = buildRequestInit(options, options.webFetchExtra);
    const urlParams = buildUrlParams(options.params, options.shouldEncodeUrlParams);
    const url = urlParams ? `${options.url}?${urlParams}` : options.url;
    const response = await fetch(url, requestInit);
    const contentType = response.headers.get("content-type") || "";
    let { responseType = "text" } = response.ok ? options : {};
    if (contentType.includes("application/json")) {
      responseType = "json";
    }
    let data;
    let blob;
    switch (responseType) {
      case "arraybuffer":
      case "blob":
        blob = await response.blob();
        data = await readBlobAsBase64(blob);
        break;
      case "json":
        data = await response.json();
        break;
      case "document":
      case "text":
      default:
        data = await response.text();
    }
    const headers = {};
    response.headers.forEach((value, key2) => {
      headers[key2] = value;
    });
    return {
      data,
      headers,
      status: response.status,
      url: response.url
    };
  }
  /**
   * Perform an Http GET request given a set of options
   * @param options Options to build the HTTP request
   */
  async get(options) {
    return this.request(Object.assign(Object.assign({}, options), { method: "GET" }));
  }
  /**
   * Perform an Http POST request given a set of options
   * @param options Options to build the HTTP request
   */
  async post(options) {
    return this.request(Object.assign(Object.assign({}, options), { method: "POST" }));
  }
  /**
   * Perform an Http PUT request given a set of options
   * @param options Options to build the HTTP request
   */
  async put(options) {
    return this.request(Object.assign(Object.assign({}, options), { method: "PUT" }));
  }
  /**
   * Perform an Http PATCH request given a set of options
   * @param options Options to build the HTTP request
   */
  async patch(options) {
    return this.request(Object.assign(Object.assign({}, options), { method: "PATCH" }));
  }
  /**
   * Perform an Http DELETE request given a set of options
   * @param options Options to build the HTTP request
   */
  async delete(options) {
    return this.request(Object.assign(Object.assign({}, options), { method: "DELETE" }));
  }
}
registerPlugin("CapacitorHttp", {
  web: () => new CapacitorHttpPluginWeb()
});
const Preferences = registerPlugin("Preferences", {
  web: () => __vitePreload(() => import("./web-DC9BkHtD.js"), true ? __vite__mapDeps([2,1]) : void 0).then((m2) => new m2.PreferencesWeb())
});
const isNative = Capacitor.isNativePlatform();
const storage = {
  async setItem(key2, value) {
    if (isNative) {
      await Preferences.set({ key: key2, value });
    } else {
      localStorage.setItem(key2, value);
    }
  },
  async getItem(key2) {
    if (isNative) {
      const { value } = await Preferences.get({ key: key2 });
      return value;
    } else {
      return localStorage.getItem(key2);
    }
  },
  async removeItem(key2) {
    if (isNative) {
      await Preferences.remove({ key: key2 });
    } else {
      localStorage.removeItem(key2);
    }
  },
  async clear() {
    if (isNative) {
      await Preferences.clear();
    } else {
      localStorage.clear();
    }
  }
};
const PushNotifications = registerPlugin("PushNotifications", {});
const index = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  PushNotifications
}, Symbol.toStringTag, { value: "Module" }));
async function getCurrentUserId() {
  try {
    const { data: { user }, error } = await supabase.auth.getUser();
    if (error) {
      console.error("Error getting user:", error);
      return null;
    }
    return user?.id ?? null;
  } catch (error) {
    console.error("Unexpected error in getCurrentUserId:", error);
    return null;
  }
}
const APP_INSTALL_KEY = "app_installation_id";
const APP_INSTALL_TIMESTAMP = "app_installation_timestamp";
const _AppInstallationDetector = class _AppInstallationDetector {
  static getInstance() {
    if (!_AppInstallationDetector.instance) {
      _AppInstallationDetector.instance = new _AppInstallationDetector();
    }
    return _AppInstallationDetector.instance;
  }
  /**
   * Checks if this is a fresh installation or reinstallation
   * Returns true if the app was reinstalled
   */
  async checkAndUpdateInstallation() {
    try {
      if (!Capacitor.isNativePlatform()) {
        return false;
      }
      const currentInstallId = `${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
      const storedInstallId = localStorage.getItem(APP_INSTALL_KEY);
      const storedTimestamp = localStorage.getItem(APP_INSTALL_TIMESTAMP);
      if (!storedInstallId) {
        console.log("🔄 Fresh installation detected");
        localStorage.setItem(APP_INSTALL_KEY, currentInstallId);
        localStorage.setItem(APP_INSTALL_TIMESTAMP, Date.now().toString());
        return true;
      }
      const indicators = {
        hasUserData: localStorage.getItem("user_id") !== null,
        hasAuthToken: localStorage.getItem("supabase.auth.token") !== null,
        hasOnboardingData: this.hasAnyOnboardingData(),
        hasPushToken: localStorage.getItem("last_fcm_token") !== null
      };
      const isReinstall = !indicators.hasUserData && !indicators.hasAuthToken && !indicators.hasOnboardingData && !indicators.hasPushToken;
      if (isReinstall) {
        console.log("🔄 App reinstallation detected - clearing old data");
        localStorage.setItem(APP_INSTALL_KEY, currentInstallId);
        localStorage.setItem(APP_INSTALL_TIMESTAMP, Date.now().toString());
        return true;
      }
      return false;
    } catch (error) {
      console.error("Error checking app installation:", error);
      return false;
    }
  }
  /**
   * Clears all user-specific data on reinstallation
   */
  clearUserDataOnReinstall(userId) {
    console.log("🧹 Clearing user data for reinstallation");
    const keysToRemove = [
      "last_fcm_token",
      "push_token_timestamp",
      "geolocation_granted",
      "notifications_granted",
      "user_location",
      "app_features_initialized"
    ];
    if (userId) {
      const userKeys = [
        `${userId}_onboarding_completed`,
        `${userId}_onboarding_skipped`,
        `${userId}_onboarding_shown`,
        `${userId}_geolocation_permission_status`,
        `${userId}_notification_permission_status`
      ];
      keysToRemove.push(...userKeys);
    }
    keysToRemove.forEach((key2) => {
      localStorage.removeItem(key2);
    });
    const allKeys = Object.keys(localStorage);
    allKeys.forEach((key2) => {
      if (key2.includes("_onboarding_") || key2.includes("_permission_") || key2.includes("fcm_token") || key2.includes("push_token")) {
        localStorage.removeItem(key2);
      }
    });
  }
  /**
   * Marks that push token needs regeneration
   */
  markTokenForRegeneration() {
    localStorage.setItem("force_token_regeneration", "true");
    localStorage.removeItem("last_fcm_token");
    localStorage.removeItem("push_token_timestamp");
  }
  /**
   * Checks if token regeneration is needed
   */
  needsTokenRegeneration() {
    return localStorage.getItem("force_token_regeneration") === "true";
  }
  /**
   * Clears token regeneration flag
   */
  clearTokenRegenerationFlag() {
    localStorage.removeItem("force_token_regeneration");
  }
  /**
   * Saves the current FCM token for comparison
   */
  saveCurrentToken(token2) {
    localStorage.setItem("last_fcm_token", token2);
    localStorage.setItem("push_token_timestamp", Date.now().toString());
  }
  /**
   * Gets the last saved FCM token
   */
  getLastToken() {
    return localStorage.getItem("last_fcm_token");
  }
  hasAnyOnboardingData() {
    const keys = Object.keys(localStorage);
    return keys.some(
      (key2) => key2.includes("onboarding_completed") || key2.includes("onboarding_skipped") || key2.includes("onboarding_shown")
    );
  }
};
__publicField(_AppInstallationDetector, "instance");
let AppInstallationDetector = _AppInstallationDetector;
const _PushNotificationService = class _PushNotificationService {
  constructor() {
    __publicField(this, "isInitialized", false);
    __publicField(this, "t", (key2) => key2);
  }
  static getInstance() {
    if (!_PushNotificationService.instance) {
      _PushNotificationService.instance = new _PushNotificationService();
    }
    return _PushNotificationService.instance;
  }
  setTranslationFunction(translateFunction) {
    this.t = translateFunction;
  }
  async initialize() {
    if (this.isInitialized) return;
    try {
      if (!Capacitor.isNativePlatform()) {
        console.log("Push notifications not available in browser");
        this.isInitialized = true;
        return;
      }
      const permissionResult = await PushNotifications.checkPermissions();
      if (permissionResult.receive !== "granted") {
        console.log("Push notifications not granted yet - waiting for user consent");
        return;
      }
      await PushNotifications.register();
      PushNotifications.addListener("registration", async (token2) => {
        console.log("Push registration success, token: " + token2.value);
        try {
          await this.saveFCMToken(token2.value);
        } catch (error) {
          console.error("Ошибка при сохранении FCM токена:", error);
        }
      });
      PushNotifications.addListener("registrationError", (error) => {
        console.error("Error on registration: " + JSON.stringify(error));
      });
      PushNotifications.addListener("pushNotificationReceived", (notification) => {
        console.log("Push received: " + JSON.stringify(notification));
        this.handleReceivedNotification(notification);
      });
      PushNotifications.addListener("pushNotificationActionPerformed", (notification) => {
        console.log("Push action performed: " + JSON.stringify(notification));
        this.handleNotificationAction(notification);
      });
      this.isInitialized = true;
      console.log("✅ PushNotificationService initialized successfully");
    } catch (error) {
      console.error("❌ Ошибка инициализации push-уведомлений:", error);
    }
  }
  // Новый метод для запроса разрешений и инициализации
  async requestPermissionsAndInitialize() {
    try {
      if (!Capacitor.isNativePlatform()) {
        console.log("Push notifications not available in browser");
        return false;
      }
      const detector = AppInstallationDetector.getInstance();
      const needsRegeneration = detector.needsTokenRegeneration();
      if (needsRegeneration) {
        console.log("🔄 Detected app reinstallation - will request new token");
      }
      console.log("🔐 Requesting push notification permissions...");
      const permissionResult = await PushNotifications.requestPermissions();
      if (permissionResult.receive !== "granted") {
        console.warn("❌ Push notification permissions denied");
        return false;
      }
      console.log("✅ Push notification permissions granted");
      if (!this.isInitialized) {
        console.log("🔧 Setting up push notification listeners...");
        PushNotifications.addListener("registration", async (token2) => {
          console.log("🎫 Push registration success, token: " + token2.value);
          try {
            await this.saveFCMToken(token2.value);
            console.log("✅ FCM token saved successfully during onboarding");
          } catch (error) {
            console.error("❌ Error saving FCM token during onboarding:", error);
          }
        });
        PushNotifications.addListener("registrationError", (error) => {
          console.error("❌ Push registration error:", JSON.stringify(error));
        });
        PushNotifications.addListener("pushNotificationReceived", (notification) => {
          console.log("📱 Push notification received:", notification);
          this.handleReceivedNotification(notification);
        });
        PushNotifications.addListener("pushNotificationActionPerformed", (notification) => {
          console.log("👆 Push notification action performed:", notification);
          this.handleNotificationAction(notification);
        });
        this.isInitialized = true;
        console.log("✅ Push notification listeners configured");
      }
      console.log("📝 Registering for push notifications...");
      await PushNotifications.register();
      console.log("✅ Push notifications setup completed - waiting for token generation");
      return true;
    } catch (error) {
      console.error("❌ Error in requestPermissionsAndInitialize:", error);
      return false;
    }
  }
  // Метод для автоматической инициализации при входе в приложение
  async initializeOnUserLogin() {
    try {
      if (this.isInitialized) return true;
      if (!Capacitor.isNativePlatform()) {
        console.log("Push notifications not available in browser");
        this.isInitialized = true;
        return false;
      }
      const permissionResult = await PushNotifications.checkPermissions();
      if (permissionResult.receive !== "granted") {
        console.log("Push notifications not granted yet - waiting for user consent");
        return false;
      }
      await this.initialize();
      await PushNotifications.register();
      return true;
    } catch (error) {
      console.error("❌ Ошибка автоматической инициализации push-уведомлений:", error);
      return false;
    }
  }
  async saveFCMToken(token2) {
    try {
      const userId = await getCurrentUserId();
      if (!userId) {
        console.error("❌ No user ID available for FCM token save");
        throw new Error("No user ID");
      }
      const deviceType = Capacitor.getPlatform();
      console.log(`💾 Saving FCM token for user ${userId} on ${deviceType} device...`);
      const detector = AppInstallationDetector.getInstance();
      const needsRegeneration = detector.needsTokenRegeneration();
      if (needsRegeneration) {
        console.log("🔄 Forcing token regeneration due to app reinstallation");
        detector.clearTokenRegenerationFlag();
        console.log("🗑️ Deactivating all old tokens due to reinstallation...");
        await supabase.from("push_notification_tokens").update({ is_active: false }).eq("user_id", userId).eq("device_type", deviceType);
      } else {
        console.log("🔍 Checking for existing active token...");
        const { data: existingTokens, error: checkError } = await supabase.from("push_notification_tokens").select("id, fcm_token").eq("user_id", userId).eq("device_type", deviceType).eq("fcm_token", token2).eq("is_active", true);
        if (checkError) {
          console.error("❌ Error checking existing tokens:", checkError);
          return;
        }
        if (existingTokens && existingTokens.length > 0) {
          console.log(`✅ ${deviceType} FCM token already registered and active`);
          detector.saveCurrentToken(token2);
          return;
        }
        console.log("🆕 No existing active token found, will create new one");
      }
      console.log("🗑️ Deactivating old tokens for this device...");
      await supabase.from("push_notification_tokens").update({ is_active: false }).eq("user_id", userId).eq("device_type", deviceType).eq("is_active", true);
      console.log("💾 Inserting new FCM token into database...");
      const { error: pushTokenError } = await supabase.from("push_notification_tokens").insert({
        user_id: userId,
        fcm_token: token2,
        device_type: deviceType,
        is_active: true
      });
      if (pushTokenError) {
        console.error("❌ Error inserting FCM token:", pushTokenError);
        throw pushTokenError;
      }
      detector.saveCurrentToken(token2);
      console.log(`✅ FCM token saved successfully in database for ${deviceType} device`);
      console.log(`🎫 Token preview: ${token2.substring(0, 20)}...`);
    } catch (error) {
      console.error("❌ Error saving FCM token:", error);
    }
  }
  handleReceivedNotification(notification) {
    console.log("📱 Notification received in foreground:", notification);
  }
  handleNotificationAction(notification) {
    console.log("👆 Notification action performed:", notification);
  }
  async sendLocalNotification(notification) {
    if (!this.isInitialized) {
      await this.initialize();
    }
    try {
      console.log("📤 Local notification would be sent:", notification);
    } catch (error) {
      console.error("❌ Error sending local notification:", error);
    }
  }
  async sendPushNotification(userId, title, body, data, notificationType = "general", priority = "medium") {
    try {
      const { data: shouldSend, error: settingsError } = await supabase.rpc("should_send_notification", {
        target_user_id: userId,
        notification_type: notificationType,
        notification_priority: priority
      });
      if (settingsError) throw settingsError;
      if (!shouldSend) {
        console.log("🔇 Notification blocked by user settings");
        return;
      }
      const { error } = await supabase.functions.invoke("send_danger_zone_push", {
        body: {
          user_id: userId,
          title,
          body,
          data: data || {},
          notification_type: notificationType,
          priority
        }
      });
      if (error) throw error;
      console.log("✅ Push notification sent successfully");
    } catch (error) {
      console.error("❌ Error sending push notification:", error);
    }
  }
  async sendDangerZoneAlert(userId, zoneName, tier, riskLevel) {
    try {
      const { getCurrentLanguage: getCurrentLanguage2 } = await __vitePreload(async () => {
        const { getCurrentLanguage: getCurrentLanguage3 } = await Promise.resolve().then(() => translations$1);
        return { getCurrentLanguage: getCurrentLanguage3 };
      }, true ? void 0 : void 0);
      const userLanguage = getCurrentLanguage2();
      const { error } = await supabase.functions.invoke("send_danger_zone_push", {
        body: {
          user_id: userId,
          tier,
          zone_name: zoneName,
          risk_level: riskLevel,
          language: userLanguage
          // Добавляем язык пользователя
        }
      });
      if (error) throw error;
      console.log("✅ Danger zone push notification sent successfully");
    } catch (error) {
      console.error("❌ Error sending danger zone push notification:", error);
    }
  }
  getDangerZoneTitle(tier, riskLevel) {
    const emoji = riskLevel >= 4 ? "🚨" : riskLevel >= 3 ? "⚠️" : "⚡";
    switch (tier) {
      case "approaching":
        return `${emoji} ${this.t("approachingDangerZone")}`;
      case "closer":
        return `${emoji} ${this.t("gettingCloser")}`;
      case "warning":
        return `${emoji} ${this.t("dangerZoneWarning")}`;
      case "critical":
        return `🚨 ${this.t("criticalDangerZone")}`;
      case "inside":
        return `🚨 ${this.t("insideDangerZone")}`;
      default:
        return `${emoji} ${this.t("dangerZoneAlert")}`;
    }
  }
  getDangerZoneMessage(zoneName, tier, riskLevel) {
    switch (tier) {
      case "approaching":
        return this.t("approachingDangerZoneMessage").replace("{zone}", zoneName);
      case "closer":
        return this.t("gettingCloserMessage").replace("{zone}", zoneName);
      case "warning":
        return this.t("dangerZoneWarningMessage").replace("{zone}", zoneName);
      case "critical":
        return this.t("criticalDangerZoneMessage").replace("{zone}", zoneName);
      case "inside":
        return this.t("insideDangerZoneMessage").replace("{zone}", zoneName);
      default:
        return this.t("dangerZoneAlertMessage").replace("{zone}", zoneName);
    }
  }
  getDangerZonePriority(riskLevel) {
    if (riskLevel >= 4) return "urgent";
    if (riskLevel >= 3) return "high";
    return "medium";
  }
  async updateNotificationSettings(settings) {
    try {
      const userId = await getCurrentUserId();
      if (!userId) throw new Error("No user ID");
      const { error } = await supabase.from("notification_settings").upsert({
        user_id: userId,
        ...settings,
        updated_at: (/* @__PURE__ */ new Date()).toISOString()
      }, {
        onConflict: "user_id"
      });
      if (error) throw error;
      console.log("✅ Notification settings updated");
    } catch (error) {
      console.error("❌ Error updating notification settings:", error);
    }
  }
  async getNotificationSettings() {
    try {
      const userId = await getCurrentUserId();
      if (!userId) throw new Error("No user ID");
      const { data, error } = await supabase.from("notification_settings").select("*").eq("user_id", userId).single();
      if (error && error.code === "PGRST116") {
        const defaultSettings = {
          user_id: userId,
          enabled: true,
          push_enabled: true,
          sound_enabled: true,
          vibration_enabled: true,
          danger_zone_alerts: true,
          incident_alerts: true,
          friend_requests: true,
          community_posts: true,
          emergency_broadcasts: true,
          traffic_alerts: false
        };
        const { data: newSettings, error: createError } = await supabase.from("notification_settings").insert(defaultSettings).select().single();
        if (createError) throw createError;
        return newSettings;
      }
      if (error) throw error;
      return data;
    } catch (error) {
      console.error("❌ Error getting notification settings:", error);
      return null;
    }
  }
};
__publicField(_PushNotificationService, "instance");
let PushNotificationService = _PushNotificationService;
async function getFCMToken$1() {
  console.log("FCM token will be handled automatically");
  return null;
}
const uploadFCMTokenToSupabase = async (token2) => {
  PushNotificationService.getInstance();
  console.log("FCM token will be saved automatically");
};
const setupForegroundHandler = (callback) => {
  if (!Capacitor.isNativePlatform()) {
    console.log("Foreground handler setup skipped on web platform");
    return () => {
    };
  }
  PushNotifications.addListener("pushNotificationReceived", (notification) => {
    console.log("Push notification received in foreground:", notification);
    callback(notification);
  });
  return () => {
    PushNotifications.removeAllListeners();
  };
};
const pushNotificationService = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  PushNotificationService,
  getFCMToken: getFCMToken$1,
  setupForegroundHandler,
  uploadFCMTokenToSupabase
}, Symbol.toStringTag, { value: "Module" }));
const defaultContext = {
  user: null,
  loading: true,
  needsOnboarding: false,
  signOut: async () => {
  },
  completeOnboarding: () => {
  }
};
const AuthContext = reactExports.createContext(defaultContext);
const AuthProvider = ({ children }) => {
  console.log("AuthProvider initializing...");
  const [user, setUser] = reactExports.useState(null);
  const [loading, setLoading] = reactExports.useState(true);
  const [needsOnboarding, setNeedsOnboarding] = reactExports.useState(false);
  reactExports.useEffect(() => {
    console.log("AuthProvider useEffect running...");
    const checkReinstallation = async () => {
      const detector = AppInstallationDetector.getInstance();
      const isReinstalled = await detector.checkAndUpdateInstallation();
      if (isReinstalled) {
        console.log("🔄 App reinstallation detected - clearing data and forcing onboarding");
        detector.clearUserDataOnReinstall();
        detector.markTokenForRegeneration();
        setNeedsOnboarding(true);
      }
    };
    checkReinstallation();
    const timeoutId = setTimeout(() => {
      console.log("Auth timeout reached, setting loading to false");
      setLoading(false);
    }, 5e3);
    supabase.auth.getSession().then(({ data: { session }, error }) => {
      clearTimeout(timeoutId);
      if (error) {
        console.error("Error getting session:", error);
      }
      setUser(session?.user ?? null);
      setLoading(false);
    }).catch((error) => {
      clearTimeout(timeoutId);
      console.error("Error in getSession:", error);
      setLoading(false);
    });
    const { data: { subscription } } = supabase.auth.onAuthStateChange(
      async (event, session) => {
        console.log("Auth state changed:", event, session?.user?.email);
        setUser(session?.user ?? null);
        setLoading(false);
        if (event === "SIGNED_IN" && session?.user) {
          try {
            const userData = session.user.user_metadata;
            if (userData.full_name) {
              await storage.setItem("userName", userData.full_name);
            }
            if (userData.nickname) {
              await storage.setItem("userNickname", userData.nickname);
            }
            if (session.user.email) {
              await storage.setItem("userEmail", session.user.email);
            }
            const detector = AppInstallationDetector.getInstance();
            const needsTokenRegeneration = detector.needsTokenRegeneration();
            const hasCompletedOnboarding = localStorage.getItem(`${session.user.id}_onboarding_completed`) === "true";
            if (needsTokenRegeneration || !hasCompletedOnboarding) {
              console.log("🔄 Forcing onboarding due to reinstallation or first login");
              setNeedsOnboarding(true);
              detector.clearUserDataOnReinstall(session.user.id);
              return;
            }
            try {
              console.log("🔔 Auto-initializing push notifications for user:", session.user.email);
              const pushService = PushNotificationService.getInstance();
              const success = await pushService.initializeOnUserLogin();
              if (success) {
                console.log("✅ Push notifications auto-initialized successfully");
              } else {
                console.log("⚠️ Push notifications not initialized (permissions not granted)");
              }
            } catch (pushError) {
              console.warn("⚠️ Push notifications auto-initialization failed:", pushError);
            }
          } catch (error) {
            console.error("Error saving user data:", error);
          }
        }
        if (event === "SIGNED_OUT") {
          setNeedsOnboarding(false);
        }
      }
    );
    return () => {
      clearTimeout(timeoutId);
      subscription.unsubscribe();
    };
  }, []);
  const completeOnboarding = () => {
    setNeedsOnboarding(false);
    localStorage.setItem("onboarding_completed", "true");
  };
  const signOut = async () => {
    const currentUser = user;
    const { error } = await supabase.auth.signOut();
    if (!error) {
      await storage.removeItem("userName");
      await storage.removeItem("userNickname");
      await storage.removeItem("userEmail");
      await storage.removeItem("userAvatar");
      if (currentUser) {
        const userId = currentUser.id;
        localStorage.removeItem(`${userId}_onboarding_completed`);
        localStorage.removeItem(`${userId}_onboarding_skipped`);
        localStorage.removeItem(`${userId}_onboarding_shown`);
        localStorage.removeItem(`${userId}_geolocation_permission_status`);
        localStorage.removeItem(`${userId}_notification_permission_status`);
      }
      localStorage.removeItem("onboarding_completed");
      localStorage.removeItem("geolocation_granted");
      localStorage.removeItem("notifications_granted");
      localStorage.removeItem("user_location");
      localStorage.removeItem("app_features_initialized");
    }
  };
  return /* @__PURE__ */ jsxRuntimeExports.jsx(AuthContext.Provider, { value: { user, loading, needsOnboarding, signOut, completeOnboarding }, children });
};
function useAuth() {
  const context = reactExports.useContext(AuthContext);
  if (!context) {
    throw new Error("useAuth must be used within an AuthProvider");
  }
  return context;
}
const AppStateContext = reactExports.createContext(void 0);
const defaultState = {
  isTrafficAnalysisEnabled: false,
  isTrafficVisible: false,
  isHeatmapVisible: false,
  isGeolocationEnabled: false,
  userLocation: null
};
const AppStateProvider = ({ children }) => {
  const [appState, setAppState] = reactExports.useState(defaultState);
  const [isLoaded, setIsLoaded] = reactExports.useState(false);
  const isNative2 = Capacitor.isNativePlatform();
  const saveState = reactExports.useCallback(async (newState) => {
    if (!isLoaded) return;
    const stateToSave = {
      isTrafficAnalysisEnabled: newState.isTrafficAnalysisEnabled,
      isTrafficVisible: newState.isTrafficVisible,
      isHeatmapVisible: newState.isHeatmapVisible,
      isGeolocationEnabled: newState.isGeolocationEnabled
      // userLocation не сохраняем
    };
    try {
      if (isNative2) {
        await Preferences.set({
          key: "appState",
          value: JSON.stringify(stateToSave)
        });
        console.log("🔄 App state saved to Capacitor Preferences:", stateToSave);
      } else {
        localStorage.setItem("appState", JSON.stringify(stateToSave));
        console.log("🔄 App state saved to localStorage:", stateToSave);
      }
    } catch (error) {
      console.error("❌ Failed to save app state:", error);
    }
  }, [isLoaded, isNative2]);
  const loadState = reactExports.useCallback(async () => {
    try {
      let savedStateStr = null;
      if (isNative2) {
        const result = await Preferences.get({ key: "appState" });
        savedStateStr = result.value;
        console.log("📱 Loading from Capacitor Preferences:", savedStateStr);
      } else {
        savedStateStr = localStorage.getItem("appState");
        console.log("🌐 Loading from localStorage:", savedStateStr);
      }
      if (savedStateStr) {
        const savedState = JSON.parse(savedStateStr);
        const loadedState = {
          ...defaultState,
          ...savedState,
          userLocation: null
          // Всегда сбрасываем userLocation
        };
        setAppState(loadedState);
        console.log("✅ App state loaded:", loadedState);
      } else {
        console.log("📝 No saved state found, using defaults");
      }
      setIsLoaded(true);
    } catch (error) {
      console.error("❌ Failed to load app state:", error);
      setIsLoaded(true);
    }
  }, [isNative2]);
  reactExports.useEffect(() => {
    console.log("🚀 AppStateProvider initializing, isNative:", isNative2);
    loadState();
  }, [loadState]);
  reactExports.useEffect(() => {
    if (isLoaded) {
      console.log("💾 Auto-saving state:", appState);
      saveState(appState);
    }
  }, [appState, saveState, isLoaded]);
  const setTrafficAnalysisEnabled = reactExports.useCallback((enabled) => {
    console.log("🚗 Setting traffic analysis enabled:", enabled);
    setAppState((prevState) => ({ ...prevState, isTrafficAnalysisEnabled: enabled }));
  }, []);
  const setTrafficVisible = reactExports.useCallback((visible) => {
    console.log("🚦 Setting traffic visible:", visible);
    setAppState((prevState) => ({ ...prevState, isTrafficVisible: visible }));
  }, []);
  const setHeatmapVisible = reactExports.useCallback((visible) => {
    console.log("🔥 Setting heatmap visible:", visible);
    setAppState((prevState) => ({ ...prevState, isHeatmapVisible: visible }));
  }, []);
  const setGeolocationEnabled = reactExports.useCallback((enabled) => {
    console.log("📍 Setting geolocation enabled:", enabled);
    setAppState((prevState) => ({ ...prevState, isGeolocationEnabled: enabled }));
  }, []);
  const setUserLocation = reactExports.useCallback((location2) => {
    console.log("🌍 Setting user location:", location2);
    setAppState((prevState) => ({ ...prevState, userLocation: location2 }));
  }, []);
  return /* @__PURE__ */ jsxRuntimeExports.jsx(
    AppStateContext.Provider,
    {
      value: {
        appState,
        setTrafficAnalysisEnabled,
        setTrafficVisible,
        setHeatmapVisible,
        setGeolocationEnabled,
        setUserLocation
      },
      children
    }
  );
};
const useAppState = () => {
  const context = reactExports.useContext(AppStateContext);
  if (context === void 0) {
    throw new Error("useAppState must be used within an AppStateProvider");
  }
  return context;
};
const TransitionSpinner = ({ className = "" }) => {
  return /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: `fixed inset-0 flex items-center justify-center bg-black/80 backdrop-blur-sm z-50 ${className}`, children: /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "semipolar-spinner", children: [
    /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "ring" }),
    /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "ring" }),
    /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "ring" }),
    /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "ring" }),
    /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "ring" })
  ] }) });
};
const SplashScreen = () => {
  const navigate = useNavigate();
  reactExports.useEffect(() => {
    navigate("/auth");
  }, [navigate]);
  return null;
};
const falsyToString = (value) => typeof value === "boolean" ? `${value}` : value === 0 ? "0" : value;
const cx = clsx;
const cva = (base, config2) => (props) => {
  var _config_compoundVariants;
  if ((config2 === null || config2 === void 0 ? void 0 : config2.variants) == null) return cx(base, props === null || props === void 0 ? void 0 : props.class, props === null || props === void 0 ? void 0 : props.className);
  const { variants, defaultVariants } = config2;
  const getVariantClassNames = Object.keys(variants).map((variant) => {
    const variantProp = props === null || props === void 0 ? void 0 : props[variant];
    const defaultVariantProp = defaultVariants === null || defaultVariants === void 0 ? void 0 : defaultVariants[variant];
    if (variantProp === null) return null;
    const variantKey = falsyToString(variantProp) || falsyToString(defaultVariantProp);
    return variants[variant][variantKey];
  });
  const propsWithoutUndefined = props && Object.entries(props).reduce((acc, param) => {
    let [key2, value] = param;
    if (value === void 0) {
      return acc;
    }
    acc[key2] = value;
    return acc;
  }, {});
  const getCompoundVariantClassNames = config2 === null || config2 === void 0 ? void 0 : (_config_compoundVariants = config2.compoundVariants) === null || _config_compoundVariants === void 0 ? void 0 : _config_compoundVariants.reduce((acc, param) => {
    let { class: cvClass, className: cvClassName, ...compoundVariantOptions } = param;
    return Object.entries(compoundVariantOptions).every((param2) => {
      let [key2, value] = param2;
      return Array.isArray(value) ? value.includes({
        ...defaultVariants,
        ...propsWithoutUndefined
      }[key2]) : {
        ...defaultVariants,
        ...propsWithoutUndefined
      }[key2] === value;
    }) ? [
      ...acc,
      cvClass,
      cvClassName
    ] : acc;
  }, []);
  return cx(base, getVariantClassNames, getCompoundVariantClassNames, props === null || props === void 0 ? void 0 : props.class, props === null || props === void 0 ? void 0 : props.className);
};
const buttonVariants = cva(
  "inline-flex items-center justify-center gap-2 whitespace-nowrap rounded-md text-sm font-medium ring-offset-background transition-colors focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2 disabled:pointer-events-none disabled:opacity-50 [&_svg]:pointer-events-none [&_svg]:size-4 [&_svg]:shrink-0",
  {
    variants: {
      variant: {
        default: "bg-primary text-primary-foreground hover:bg-primary/90",
        destructive: "bg-[#f3533b] text-white hover:bg-[#f3533b]/90",
        outline: "border border-input bg-background hover:bg-accent hover:text-accent-foreground",
        secondary: "bg-secondary text-secondary-foreground hover:bg-secondary/80",
        ghost: "hover:bg-accent hover:text-accent-foreground",
        link: "text-primary underline-offset-4 hover:underline"
      },
      size: {
        default: "h-10 px-4 py-2",
        sm: "h-9 rounded-md px-3",
        lg: "h-11 rounded-md px-8",
        icon: "h-10 w-10"
      }
    },
    defaultVariants: {
      variant: "default",
      size: "default"
    }
  }
);
const Button$1 = reactExports.forwardRef(
  ({ className, variant, size: size2, asChild = false, ...props }, ref) => {
    const Comp = asChild ? Slot : "button";
    return /* @__PURE__ */ jsxRuntimeExports.jsx(
      Comp,
      {
        className: cn(buttonVariants({ variant, size: size2, className })),
        ref,
        ...props
      }
    );
  }
);
Button$1.displayName = "Button";
const Card = reactExports.forwardRef(({ className, ...props }, ref) => /* @__PURE__ */ jsxRuntimeExports.jsx(
  "div",
  {
    ref,
    className: cn(
      "rounded-lg border bg-card text-card-foreground shadow-sm",
      className
    ),
    ...props
  }
));
Card.displayName = "Card";
const CardHeader = reactExports.forwardRef(({ className, ...props }, ref) => /* @__PURE__ */ jsxRuntimeExports.jsx(
  "div",
  {
    ref,
    className: cn("flex flex-col space-y-1.5 p-6", className),
    ...props
  }
));
CardHeader.displayName = "CardHeader";
const CardTitle = reactExports.forwardRef(({ className, ...props }, ref) => /* @__PURE__ */ jsxRuntimeExports.jsx(
  "h3",
  {
    ref,
    className: cn(
      "text-2xl font-semibold leading-none tracking-tight",
      className
    ),
    ...props
  }
));
CardTitle.displayName = "CardTitle";
const CardDescription = reactExports.forwardRef(({ className, ...props }, ref) => /* @__PURE__ */ jsxRuntimeExports.jsx(
  "p",
  {
    ref,
    className: cn("text-sm text-muted-foreground", className),
    ...props
  }
));
CardDescription.displayName = "CardDescription";
const CardContent = reactExports.forwardRef(({ className, ...props }, ref) => /* @__PURE__ */ jsxRuntimeExports.jsx("div", { ref, className: cn("p-6 pt-0", className), ...props }));
CardContent.displayName = "CardContent";
const CardFooter = reactExports.forwardRef(({ className, ...props }, ref) => /* @__PURE__ */ jsxRuntimeExports.jsx(
  "div",
  {
    ref,
    className: cn("flex items-center p-6 pt-0", className),
    ...props
  }
));
CardFooter.displayName = "CardFooter";
const OptimizedInput = reactExports.memo(
  reactExports.forwardRef(
    ({ className, type, enableMobileFeatures, textType, ...props }, ref) => {
      const handleChange = reactExports.useCallback((e2) => {
        props.onChange?.(e2);
      }, [props.onChange]);
      const getMobileSettings = () => {
        if (enableMobileFeatures !== void 0) {
          return {
            autoCorrect: enableMobileFeatures ? "on" : "off",
            autoCapitalize: enableMobileFeatures ? "sentences" : "off",
            spellCheck: enableMobileFeatures
          };
        }
        const fieldType = textType || type;
        switch (fieldType) {
          case "email":
          case "password":
          case "username":
            return {
              autoCorrect: "off",
              autoCapitalize: "off",
              spellCheck: false
            };
          case "name":
            return {
              autoCorrect: "on",
              autoCapitalize: "words",
              spellCheck: true
            };
          case "search":
            return {
              autoCorrect: "on",
              autoCapitalize: "off",
              spellCheck: false
            };
          case "text":
          default:
            return {
              autoCorrect: "on",
              autoCapitalize: "sentences",
              spellCheck: true
            };
        }
      };
      const mobileSettings = getMobileSettings();
      return /* @__PURE__ */ jsxRuntimeExports.jsx(
        "input",
        {
          type,
          className: cn(
            "flex h-10 w-full rounded-md border border-input bg-background px-3 py-2 text-base ring-offset-background file:border-0 file:bg-transparent file:text-sm file:font-medium file:text-foreground placeholder:text-muted-foreground focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2 disabled:cursor-not-allowed disabled:opacity-50 md:text-sm",
            "touch-manipulation will-change-auto",
            className
          ),
          ref,
          onChange: handleChange,
          autoComplete: props.autoComplete || (type === "email" ? "email" : type === "password" ? "current-password" : "on"),
          autoCorrect: mobileSettings.autoCorrect,
          autoCapitalize: mobileSettings.autoCapitalize,
          spellCheck: mobileSettings.spellCheck,
          inputMode: type === "email" ? "email" : type === "tel" ? "tel" : type === "number" ? "numeric" : type === "search" ? "search" : "text",
          style: {
            WebkitTapHighlightColor: "transparent",
            WebkitAppearance: "none",
            transform: "translateZ(0)",
            // Улучшения для мобильного удаления текста
            WebkitUserSelect: "text",
            userSelect: "text",
            ...props.style
          },
          ...props
        }
      );
    }
  )
);
OptimizedInput.displayName = "OptimizedInput";
var NAME = "Label";
var Label$1 = reactExports.forwardRef((props, forwardedRef) => {
  return /* @__PURE__ */ jsxRuntimeExports.jsx(
    Primitive.label,
    {
      ...props,
      ref: forwardedRef,
      onMouseDown: (event) => {
        const target = event.target;
        if (target.closest("button, input, select, textarea")) return;
        props.onMouseDown?.(event);
        if (!event.defaultPrevented && event.detail > 1) event.preventDefault();
      }
    }
  );
});
Label$1.displayName = NAME;
var Root$5 = Label$1;
const labelVariants = cva(
  "text-sm font-medium leading-none peer-disabled:cursor-not-allowed peer-disabled:opacity-70"
);
const Label = reactExports.forwardRef(({ className, ...props }, ref) => /* @__PURE__ */ jsxRuntimeExports.jsx(
  Root$5,
  {
    ref,
    className: cn(labelVariants(), className),
    ...props
  }
));
Label.displayName = Root$5.displayName;
/**
 * @license lucide-react v0.462.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */
const toKebabCase = (string) => string.replace(/([a-z0-9])([A-Z])/g, "$1-$2").toLowerCase();
const mergeClasses = (...classes) => classes.filter((className, index2, array) => {
  return Boolean(className) && className.trim() !== "" && array.indexOf(className) === index2;
}).join(" ").trim();
/**
 * @license lucide-react v0.462.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */
var defaultAttributes = {
  xmlns: "http://www.w3.org/2000/svg",
  width: 24,
  height: 24,
  viewBox: "0 0 24 24",
  fill: "none",
  stroke: "currentColor",
  strokeWidth: 2,
  strokeLinecap: "round",
  strokeLinejoin: "round"
};
/**
 * @license lucide-react v0.462.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */
const Icon = reactExports.forwardRef(
  ({
    color: color2 = "currentColor",
    size: size2 = 24,
    strokeWidth = 2,
    absoluteStrokeWidth,
    className = "",
    children,
    iconNode,
    ...rest
  }, ref) => {
    return reactExports.createElement(
      "svg",
      {
        ref,
        ...defaultAttributes,
        width: size2,
        height: size2,
        stroke: color2,
        strokeWidth: absoluteStrokeWidth ? Number(strokeWidth) * 24 / Number(size2) : strokeWidth,
        className: mergeClasses("lucide", className),
        ...rest
      },
      [
        ...iconNode.map(([tag, attrs]) => reactExports.createElement(tag, attrs)),
        ...Array.isArray(children) ? children : [children]
      ]
    );
  }
);
/**
 * @license lucide-react v0.462.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */
const createLucideIcon = (iconName, iconNode) => {
  const Component = reactExports.forwardRef(
    ({ className, ...props }, ref) => reactExports.createElement(Icon, {
      ref,
      iconNode,
      className: mergeClasses(`lucide-${toKebabCase(iconName)}`, className),
      ...props
    })
  );
  Component.displayName = `${iconName}`;
  return Component;
};
/**
 * @license lucide-react v0.462.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */
const Ban = createLucideIcon("Ban", [
  ["circle", { cx: "12", cy: "12", r: "10", key: "1mglay" }],
  ["path", { d: "m4.9 4.9 14.2 14.2", key: "1m5liu" }]
]);
/**
 * @license lucide-react v0.462.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */
const Bell = createLucideIcon("Bell", [
  ["path", { d: "M6 8a6 6 0 0 1 12 0c0 7 3 9 3 9H3s3-2 3-9", key: "1qo2s2" }],
  ["path", { d: "M10.3 21a1.94 1.94 0 0 0 3.4 0", key: "qgo35s" }]
]);
/**
 * @license lucide-react v0.462.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */
const ChevronLeft = createLucideIcon("ChevronLeft", [
  ["path", { d: "m15 18-6-6 6-6", key: "1wnfg3" }]
]);
/**
 * @license lucide-react v0.462.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */
const ChevronRight = createLucideIcon("ChevronRight", [
  ["path", { d: "m9 18 6-6-6-6", key: "mthhwq" }]
]);
/**
 * @license lucide-react v0.462.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */
const CircleCheckBig = createLucideIcon("CircleCheckBig", [
  ["path", { d: "M21.801 10A10 10 0 1 1 17 3.335", key: "yps3ct" }],
  ["path", { d: "m9 11 3 3L22 4", key: "1pflzl" }]
]);
/**
 * @license lucide-react v0.462.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */
const Clock$1 = createLucideIcon("Clock", [
  ["circle", { cx: "12", cy: "12", r: "10", key: "1mglay" }],
  ["polyline", { points: "12 6 12 12 16 14", key: "68esgv" }]
]);
/**
 * @license lucide-react v0.462.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */
const Crown = createLucideIcon("Crown", [
  [
    "path",
    {
      d: "M11.562 3.266a.5.5 0 0 1 .876 0L15.39 8.87a1 1 0 0 0 1.516.294L21.183 5.5a.5.5 0 0 1 .798.519l-2.834 10.246a1 1 0 0 1-.956.734H5.81a1 1 0 0 1-.957-.734L2.02 6.02a.5.5 0 0 1 .798-.519l4.276 3.664a1 1 0 0 0 1.516-.294z",
      key: "1vdc57"
    }
  ],
  ["path", { d: "M5 21h14", key: "11awu3" }]
]);
/**
 * @license lucide-react v0.462.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */
const Database = createLucideIcon("Database", [
  ["ellipse", { cx: "12", cy: "5", rx: "9", ry: "3", key: "msslwz" }],
  ["path", { d: "M3 5V19A9 3 0 0 0 21 19V5", key: "1wlel7" }],
  ["path", { d: "M3 12A9 3 0 0 0 21 12", key: "mv7ke4" }]
]);
/**
 * @license lucide-react v0.462.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */
const Download = createLucideIcon("Download", [
  ["path", { d: "M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4", key: "ih7n3h" }],
  ["polyline", { points: "7 10 12 15 17 10", key: "2ggqvy" }],
  ["line", { x1: "12", x2: "12", y1: "15", y2: "3", key: "1vk2je" }]
]);
/**
 * @license lucide-react v0.462.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */
const EyeOff = createLucideIcon("EyeOff", [
  [
    "path",
    {
      d: "M10.733 5.076a10.744 10.744 0 0 1 11.205 6.575 1 1 0 0 1 0 .696 10.747 10.747 0 0 1-1.444 2.49",
      key: "ct8e1f"
    }
  ],
  ["path", { d: "M14.084 14.158a3 3 0 0 1-4.242-4.242", key: "151rxh" }],
  [
    "path",
    {
      d: "M17.479 17.499a10.75 10.75 0 0 1-15.417-5.151 1 1 0 0 1 0-.696 10.75 10.75 0 0 1 4.446-5.143",
      key: "13bj9a"
    }
  ],
  ["path", { d: "m2 2 20 20", key: "1ooewy" }]
]);
/**
 * @license lucide-react v0.462.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */
const Eye = createLucideIcon("Eye", [
  [
    "path",
    {
      d: "M2.062 12.348a1 1 0 0 1 0-.696 10.75 10.75 0 0 1 19.876 0 1 1 0 0 1 0 .696 10.75 10.75 0 0 1-19.876 0",
      key: "1nclc0"
    }
  ],
  ["circle", { cx: "12", cy: "12", r: "3", key: "1v7zrd" }]
]);
/**
 * @license lucide-react v0.462.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */
const FileText = createLucideIcon("FileText", [
  ["path", { d: "M15 2H6a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V7Z", key: "1rqfz7" }],
  ["path", { d: "M14 2v4a2 2 0 0 0 2 2h4", key: "tnqrlb" }],
  ["path", { d: "M10 9H8", key: "b1mrlr" }],
  ["path", { d: "M16 13H8", key: "t4e002" }],
  ["path", { d: "M16 17H8", key: "z1uh3a" }]
]);
/**
 * @license lucide-react v0.462.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */
const Filter = createLucideIcon("Filter", [
  ["polygon", { points: "22 3 2 3 10 12.46 10 19 14 21 14 12.46 22 3", key: "1yg77f" }]
]);
/**
 * @license lucide-react v0.462.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */
const Info$1 = createLucideIcon("Info", [
  ["circle", { cx: "12", cy: "12", r: "10", key: "1mglay" }],
  ["path", { d: "M12 16v-4", key: "1dtifu" }],
  ["path", { d: "M12 8h.01", key: "e9boi3" }]
]);
/**
 * @license lucide-react v0.462.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */
const Languages = createLucideIcon("Languages", [
  ["path", { d: "m5 8 6 6", key: "1wu5hv" }],
  ["path", { d: "m4 14 6-6 2-3", key: "1k1g8d" }],
  ["path", { d: "M2 5h12", key: "or177f" }],
  ["path", { d: "M7 2h1", key: "1t2jsx" }],
  ["path", { d: "m22 22-5-10-5 10", key: "don7ne" }],
  ["path", { d: "M14 18h6", key: "1m8k6r" }]
]);
/**
 * @license lucide-react v0.462.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */
const LoaderCircle = createLucideIcon("LoaderCircle", [
  ["path", { d: "M21 12a9 9 0 1 1-6.219-8.56", key: "13zald" }]
]);
/**
 * @license lucide-react v0.462.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */
const Lock = createLucideIcon("Lock", [
  ["rect", { width: "18", height: "11", x: "3", y: "11", rx: "2", ry: "2", key: "1w4ew1" }],
  ["path", { d: "M7 11V7a5 5 0 0 1 10 0v4", key: "fwvmzm" }]
]);
/**
 * @license lucide-react v0.462.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */
const MapPin = createLucideIcon("MapPin", [
  [
    "path",
    {
      d: "M20 10c0 4.993-5.539 10.193-7.399 11.799a1 1 0 0 1-1.202 0C9.539 20.193 4 14.993 4 10a8 8 0 0 1 16 0",
      key: "1r0f0z"
    }
  ],
  ["circle", { cx: "12", cy: "10", r: "3", key: "ilqhr7" }]
]);
/**
 * @license lucide-react v0.462.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */
const MessageCircle = createLucideIcon("MessageCircle", [
  ["path", { d: "M7.9 20A9 9 0 1 0 4 16.1L2 22Z", key: "vv11sd" }]
]);
/**
 * @license lucide-react v0.462.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */
const MessageSquare = createLucideIcon("MessageSquare", [
  ["path", { d: "M21 15a2 2 0 0 1-2 2H7l-4 4V5a2 2 0 0 1 2-2h14a2 2 0 0 1 2 2z", key: "1lielz" }]
]);
/**
 * @license lucide-react v0.462.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */
const RefreshCw = createLucideIcon("RefreshCw", [
  ["path", { d: "M3 12a9 9 0 0 1 9-9 9.75 9.75 0 0 1 6.74 2.74L21 8", key: "v9h5vc" }],
  ["path", { d: "M21 3v5h-5", key: "1q7to0" }],
  ["path", { d: "M21 12a9 9 0 0 1-9 9 9.75 9.75 0 0 1-6.74-2.74L3 16", key: "3uifl3" }],
  ["path", { d: "M8 16H3v5", key: "1cv678" }]
]);
/**
 * @license lucide-react v0.462.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */
const Search = createLucideIcon("Search", [
  ["circle", { cx: "11", cy: "11", r: "8", key: "4ej97u" }],
  ["path", { d: "m21 21-4.3-4.3", key: "1qie3q" }]
]);
/**
 * @license lucide-react v0.462.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */
const Send = createLucideIcon("Send", [
  [
    "path",
    {
      d: "M14.536 21.686a.5.5 0 0 0 .937-.024l6.5-19a.496.496 0 0 0-.635-.635l-19 6.5a.5.5 0 0 0-.024.937l7.93 3.18a2 2 0 0 1 1.112 1.11z",
      key: "1ffxy3"
    }
  ],
  ["path", { d: "m21.854 2.147-10.94 10.939", key: "12cjpa" }]
]);
/**
 * @license lucide-react v0.462.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */
const Server = createLucideIcon("Server", [
  ["rect", { width: "20", height: "8", x: "2", y: "2", rx: "2", ry: "2", key: "ngkwjq" }],
  ["rect", { width: "20", height: "8", x: "2", y: "14", rx: "2", ry: "2", key: "iecqi9" }],
  ["line", { x1: "6", x2: "6.01", y1: "6", y2: "6", key: "16zg32" }],
  ["line", { x1: "6", x2: "6.01", y1: "18", y2: "18", key: "nzw8ys" }]
]);
/**
 * @license lucide-react v0.462.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */
const Settings = createLucideIcon("Settings", [
  [
    "path",
    {
      d: "M12.22 2h-.44a2 2 0 0 0-2 2v.18a2 2 0 0 1-1 1.73l-.43.25a2 2 0 0 1-2 0l-.15-.08a2 2 0 0 0-2.73.73l-.22.38a2 2 0 0 0 .73 2.73l.15.1a2 2 0 0 1 1 1.72v.51a2 2 0 0 1-1 1.74l-.15.09a2 2 0 0 0-.73 2.73l.22.38a2 2 0 0 0 2.73.73l.15-.08a2 2 0 0 1 2 0l.43.25a2 2 0 0 1 1 1.73V20a2 2 0 0 0 2 2h.44a2 2 0 0 0 2-2v-.18a2 2 0 0 1 1-1.73l.43-.25a2 2 0 0 1 2 0l.15.08a2 2 0 0 0 2.73-.73l.22-.39a2 2 0 0 0-.73-2.73l-.15-.08a2 2 0 0 1-1-1.74v-.5a2 2 0 0 1 1-1.74l.15-.09a2 2 0 0 0 .73-2.73l-.22-.38a2 2 0 0 0-2.73-.73l-.15.08a2 2 0 0 1-2 0l-.43-.25a2 2 0 0 1-1-1.73V4a2 2 0 0 0-2-2z",
      key: "1qme2f"
    }
  ],
  ["circle", { cx: "12", cy: "12", r: "3", key: "1v7zrd" }]
]);
/**
 * @license lucide-react v0.462.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */
const Share2 = createLucideIcon("Share2", [
  ["circle", { cx: "18", cy: "5", r: "3", key: "gq8acd" }],
  ["circle", { cx: "6", cy: "12", r: "3", key: "w7nqdw" }],
  ["circle", { cx: "18", cy: "19", r: "3", key: "1xt0gg" }],
  ["line", { x1: "8.59", x2: "15.42", y1: "13.51", y2: "17.49", key: "47mynk" }],
  ["line", { x1: "15.41", x2: "8.59", y1: "6.51", y2: "10.49", key: "1n3mei" }]
]);
/**
 * @license lucide-react v0.462.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */
const Shield = createLucideIcon("Shield", [
  [
    "path",
    {
      d: "M20 13c0 5-3.5 7.5-7.66 8.95a1 1 0 0 1-.67-.01C7.5 20.5 4 18 4 13V6a1 1 0 0 1 1-1c2 0 4.5-1.2 6.24-2.72a1.17 1.17 0 0 1 1.52 0C14.51 3.81 17 5 19 5a1 1 0 0 1 1 1z",
      key: "oel41y"
    }
  ]
]);
/**
 * @license lucide-react v0.462.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */
const Target = createLucideIcon("Target", [
  ["circle", { cx: "12", cy: "12", r: "10", key: "1mglay" }],
  ["circle", { cx: "12", cy: "12", r: "6", key: "1vlfrh" }],
  ["circle", { cx: "12", cy: "12", r: "2", key: "1c9p78" }]
]);
/**
 * @license lucide-react v0.462.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */
const ThumbsDown = createLucideIcon("ThumbsDown", [
  ["path", { d: "M17 14V2", key: "8ymqnk" }],
  [
    "path",
    {
      d: "M9 18.12 10 14H4.17a2 2 0 0 1-1.92-2.56l2.33-8A2 2 0 0 1 6.5 2H20a2 2 0 0 1 2 2v8a2 2 0 0 1-2 2h-2.76a2 2 0 0 0-1.79 1.11L12 22a3.13 3.13 0 0 1-3-3.88Z",
      key: "m61m77"
    }
  ]
]);
/**
 * @license lucide-react v0.462.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */
const ThumbsUp = createLucideIcon("ThumbsUp", [
  ["path", { d: "M7 10v12", key: "1qc93n" }],
  [
    "path",
    {
      d: "M15 5.88 14 10h5.83a2 2 0 0 1 1.92 2.56l-2.33 8A2 2 0 0 1 17.5 22H4a2 2 0 0 1-2-2v-8a2 2 0 0 1 2-2h2.76a2 2 0 0 0 1.79-1.11L12 2a3.13 3.13 0 0 1 3 3.88Z",
      key: "emmmcr"
    }
  ]
]);
/**
 * @license lucide-react v0.462.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */
const Trash2 = createLucideIcon("Trash2", [
  ["path", { d: "M3 6h18", key: "d0wm0j" }],
  ["path", { d: "M19 6v14c0 1-1 2-2 2H7c-1 0-2-1-2-2V6", key: "4alrt4" }],
  ["path", { d: "M8 6V4c0-1 1-2 2-2h4c1 0 2 1 2 2v2", key: "v07s0e" }],
  ["line", { x1: "10", x2: "10", y1: "11", y2: "17", key: "1uufr5" }],
  ["line", { x1: "14", x2: "14", y1: "11", y2: "17", key: "xtxkd" }]
]);
/**
 * @license lucide-react v0.462.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */
const TriangleAlert = createLucideIcon("TriangleAlert", [
  [
    "path",
    {
      d: "m21.73 18-8-14a2 2 0 0 0-3.48 0l-8 14A2 2 0 0 0 4 21h16a2 2 0 0 0 1.73-3",
      key: "wmoenq"
    }
  ],
  ["path", { d: "M12 9v4", key: "juzpu7" }],
  ["path", { d: "M12 17h.01", key: "p32p05" }]
]);
/**
 * @license lucide-react v0.462.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */
const UserCheck = createLucideIcon("UserCheck", [
  ["path", { d: "M16 21v-2a4 4 0 0 0-4-4H6a4 4 0 0 0-4 4v2", key: "1yyitq" }],
  ["circle", { cx: "9", cy: "7", r: "4", key: "nufk8" }],
  ["polyline", { points: "16 11 18 13 22 9", key: "1pwet4" }]
]);
/**
 * @license lucide-react v0.462.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */
const UserMinus = createLucideIcon("UserMinus", [
  ["path", { d: "M16 21v-2a4 4 0 0 0-4-4H6a4 4 0 0 0-4 4v2", key: "1yyitq" }],
  ["circle", { cx: "9", cy: "7", r: "4", key: "nufk8" }],
  ["line", { x1: "22", x2: "16", y1: "11", y2: "11", key: "1shjgl" }]
]);
/**
 * @license lucide-react v0.462.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */
const UserPlus = createLucideIcon("UserPlus", [
  ["path", { d: "M16 21v-2a4 4 0 0 0-4-4H6a4 4 0 0 0-4 4v2", key: "1yyitq" }],
  ["circle", { cx: "9", cy: "7", r: "4", key: "nufk8" }],
  ["line", { x1: "19", x2: "19", y1: "8", y2: "14", key: "1bvyxn" }],
  ["line", { x1: "22", x2: "16", y1: "11", y2: "11", key: "1shjgl" }]
]);
/**
 * @license lucide-react v0.462.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */
const UserX = createLucideIcon("UserX", [
  ["path", { d: "M16 21v-2a4 4 0 0 0-4-4H6a4 4 0 0 0-4 4v2", key: "1yyitq" }],
  ["circle", { cx: "9", cy: "7", r: "4", key: "nufk8" }],
  ["line", { x1: "17", x2: "22", y1: "8", y2: "13", key: "3nzzx3" }],
  ["line", { x1: "22", x2: "17", y1: "8", y2: "13", key: "1swrse" }]
]);
/**
 * @license lucide-react v0.462.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */
const User = createLucideIcon("User", [
  ["path", { d: "M19 21v-2a4 4 0 0 0-4-4H9a4 4 0 0 0-4 4v2", key: "975kel" }],
  ["circle", { cx: "12", cy: "7", r: "4", key: "17ys0d" }]
]);
/**
 * @license lucide-react v0.462.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */
const Users = createLucideIcon("Users", [
  ["path", { d: "M16 21v-2a4 4 0 0 0-4-4H6a4 4 0 0 0-4 4v2", key: "1yyitq" }],
  ["circle", { cx: "9", cy: "7", r: "4", key: "nufk8" }],
  ["path", { d: "M22 21v-2a4 4 0 0 0-3-3.87", key: "kshegd" }],
  ["path", { d: "M16 3.13a4 4 0 0 1 0 7.75", key: "1da9ce" }]
]);
/**
 * @license lucide-react v0.462.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */
const X = createLucideIcon("X", [
  ["path", { d: "M18 6 6 18", key: "1bl5f8" }],
  ["path", { d: "m6 6 12 12", key: "d8bk6v" }]
]);
/**
 * @license lucide-react v0.462.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */
const ZoomIn = createLucideIcon("ZoomIn", [
  ["circle", { cx: "11", cy: "11", r: "8", key: "4ej97u" }],
  ["line", { x1: "21", x2: "16.65", y1: "21", y2: "16.65", key: "13gj7c" }],
  ["line", { x1: "11", x2: "11", y1: "8", y2: "14", key: "1vmskp" }],
  ["line", { x1: "8", x2: "14", y1: "11", y2: "11", key: "durymu" }]
]);
/**
 * @license lucide-react v0.462.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */
const ZoomOut = createLucideIcon("ZoomOut", [
  ["circle", { cx: "11", cy: "11", r: "8", key: "4ej97u" }],
  ["line", { x1: "21", x2: "16.65", y1: "21", y2: "16.65", key: "13gj7c" }],
  ["line", { x1: "8", x2: "14", y1: "11", y2: "11", key: "durymu" }]
]);
const LanguageToggle = () => {
  const { language, setLanguage } = useLanguage$1();
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(
    Button$1,
    {
      variant: "ghost",
      size: "icon",
      onClick: () => setLanguage(language === "es" ? "en" : "es"),
      className: "text-white hover:bg-dark-light relative",
      children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx(Languages, { className: "w-5 h-5" }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "absolute -bottom-1 -right-1 text-xs font-bold bg-danger rounded px-1 py-0.5 min-w-[16px] h-4 flex items-center justify-center", children: language === "en" ? "EN" : "ES" })
      ]
    }
  );
};
var AUTOFOCUS_ON_MOUNT = "focusScope.autoFocusOnMount";
var AUTOFOCUS_ON_UNMOUNT = "focusScope.autoFocusOnUnmount";
var EVENT_OPTIONS$1 = { bubbles: false, cancelable: true };
var FOCUS_SCOPE_NAME = "FocusScope";
var FocusScope = reactExports.forwardRef((props, forwardedRef) => {
  const {
    loop = false,
    trapped = false,
    onMountAutoFocus: onMountAutoFocusProp,
    onUnmountAutoFocus: onUnmountAutoFocusProp,
    ...scopeProps
  } = props;
  const [container, setContainer] = reactExports.useState(null);
  const onMountAutoFocus = useCallbackRef$1(onMountAutoFocusProp);
  const onUnmountAutoFocus = useCallbackRef$1(onUnmountAutoFocusProp);
  const lastFocusedElementRef = reactExports.useRef(null);
  const composedRefs = useComposedRefs(forwardedRef, (node2) => setContainer(node2));
  const focusScope = reactExports.useRef({
    paused: false,
    pause() {
      this.paused = true;
    },
    resume() {
      this.paused = false;
    }
  }).current;
  reactExports.useEffect(() => {
    if (trapped) {
      let handleFocusIn2 = function(event) {
        if (focusScope.paused || !container) return;
        const target = event.target;
        if (container.contains(target)) {
          lastFocusedElementRef.current = target;
        } else {
          focus(lastFocusedElementRef.current, { select: true });
        }
      }, handleFocusOut2 = function(event) {
        if (focusScope.paused || !container) return;
        const relatedTarget = event.relatedTarget;
        if (relatedTarget === null) return;
        if (!container.contains(relatedTarget)) {
          focus(lastFocusedElementRef.current, { select: true });
        }
      }, handleMutations2 = function(mutations) {
        const focusedElement = document.activeElement;
        if (focusedElement !== document.body) return;
        for (const mutation of mutations) {
          if (mutation.removedNodes.length > 0) focus(container);
        }
      };
      document.addEventListener("focusin", handleFocusIn2);
      document.addEventListener("focusout", handleFocusOut2);
      const mutationObserver = new MutationObserver(handleMutations2);
      if (container) mutationObserver.observe(container, { childList: true, subtree: true });
      return () => {
        document.removeEventListener("focusin", handleFocusIn2);
        document.removeEventListener("focusout", handleFocusOut2);
        mutationObserver.disconnect();
      };
    }
  }, [trapped, container, focusScope.paused]);
  reactExports.useEffect(() => {
    if (container) {
      focusScopesStack.add(focusScope);
      const previouslyFocusedElement = document.activeElement;
      const hasFocusedCandidate = container.contains(previouslyFocusedElement);
      if (!hasFocusedCandidate) {
        const mountEvent = new CustomEvent(AUTOFOCUS_ON_MOUNT, EVENT_OPTIONS$1);
        container.addEventListener(AUTOFOCUS_ON_MOUNT, onMountAutoFocus);
        container.dispatchEvent(mountEvent);
        if (!mountEvent.defaultPrevented) {
          focusFirst$1(removeLinks(getTabbableCandidates(container)), { select: true });
          if (document.activeElement === previouslyFocusedElement) {
            focus(container);
          }
        }
      }
      return () => {
        container.removeEventListener(AUTOFOCUS_ON_MOUNT, onMountAutoFocus);
        setTimeout(() => {
          const unmountEvent = new CustomEvent(AUTOFOCUS_ON_UNMOUNT, EVENT_OPTIONS$1);
          container.addEventListener(AUTOFOCUS_ON_UNMOUNT, onUnmountAutoFocus);
          container.dispatchEvent(unmountEvent);
          if (!unmountEvent.defaultPrevented) {
            focus(previouslyFocusedElement ?? document.body, { select: true });
          }
          container.removeEventListener(AUTOFOCUS_ON_UNMOUNT, onUnmountAutoFocus);
          focusScopesStack.remove(focusScope);
        }, 0);
      };
    }
  }, [container, onMountAutoFocus, onUnmountAutoFocus, focusScope]);
  const handleKeyDown = reactExports.useCallback(
    (event) => {
      if (!loop && !trapped) return;
      if (focusScope.paused) return;
      const isTabKey = event.key === "Tab" && !event.altKey && !event.ctrlKey && !event.metaKey;
      const focusedElement = document.activeElement;
      if (isTabKey && focusedElement) {
        const container2 = event.currentTarget;
        const [first, last] = getTabbableEdges(container2);
        const hasTabbableElementsInside = first && last;
        if (!hasTabbableElementsInside) {
          if (focusedElement === container2) event.preventDefault();
        } else {
          if (!event.shiftKey && focusedElement === last) {
            event.preventDefault();
            if (loop) focus(first, { select: true });
          } else if (event.shiftKey && focusedElement === first) {
            event.preventDefault();
            if (loop) focus(last, { select: true });
          }
        }
      }
    },
    [loop, trapped, focusScope.paused]
  );
  return /* @__PURE__ */ jsxRuntimeExports.jsx(Primitive.div, { tabIndex: -1, ...scopeProps, ref: composedRefs, onKeyDown: handleKeyDown });
});
FocusScope.displayName = FOCUS_SCOPE_NAME;
function focusFirst$1(candidates, { select = false } = {}) {
  const previouslyFocusedElement = document.activeElement;
  for (const candidate of candidates) {
    focus(candidate, { select });
    if (document.activeElement !== previouslyFocusedElement) return;
  }
}
function getTabbableEdges(container) {
  const candidates = getTabbableCandidates(container);
  const first = findVisible(candidates, container);
  const last = findVisible(candidates.reverse(), container);
  return [first, last];
}
function getTabbableCandidates(container) {
  const nodes = [];
  const walker = document.createTreeWalker(container, NodeFilter.SHOW_ELEMENT, {
    acceptNode: (node2) => {
      const isHiddenInput = node2.tagName === "INPUT" && node2.type === "hidden";
      if (node2.disabled || node2.hidden || isHiddenInput) return NodeFilter.FILTER_SKIP;
      return node2.tabIndex >= 0 ? NodeFilter.FILTER_ACCEPT : NodeFilter.FILTER_SKIP;
    }
  });
  while (walker.nextNode()) nodes.push(walker.currentNode);
  return nodes;
}
function findVisible(elements, container) {
  for (const element of elements) {
    if (!isHidden(element, { upTo: container })) return element;
  }
}
function isHidden(node2, { upTo }) {
  if (getComputedStyle(node2).visibility === "hidden") return true;
  while (node2) {
    if (upTo !== void 0 && node2 === upTo) return false;
    if (getComputedStyle(node2).display === "none") return true;
    node2 = node2.parentElement;
  }
  return false;
}
function isSelectableInput(element) {
  return element instanceof HTMLInputElement && "select" in element;
}
function focus(element, { select = false } = {}) {
  if (element && element.focus) {
    const previouslyFocusedElement = document.activeElement;
    element.focus({ preventScroll: true });
    if (element !== previouslyFocusedElement && isSelectableInput(element) && select)
      element.select();
  }
}
var focusScopesStack = createFocusScopesStack();
function createFocusScopesStack() {
  let stack = [];
  return {
    add(focusScope) {
      const activeFocusScope = stack[0];
      if (focusScope !== activeFocusScope) {
        activeFocusScope?.pause();
      }
      stack = arrayRemove(stack, focusScope);
      stack.unshift(focusScope);
    },
    remove(focusScope) {
      stack = arrayRemove(stack, focusScope);
      stack[0]?.resume();
    }
  };
}
function arrayRemove(array, item) {
  const updatedArray = [...array];
  const index2 = updatedArray.indexOf(item);
  if (index2 !== -1) {
    updatedArray.splice(index2, 1);
  }
  return updatedArray;
}
function removeLinks(items) {
  return items.filter((item) => item.tagName !== "A");
}
var count = 0;
function useFocusGuards() {
  reactExports.useEffect(() => {
    const edgeGuards = document.querySelectorAll("[data-radix-focus-guard]");
    document.body.insertAdjacentElement("afterbegin", edgeGuards[0] ?? createFocusGuard());
    document.body.insertAdjacentElement("beforeend", edgeGuards[1] ?? createFocusGuard());
    count++;
    return () => {
      if (count === 1) {
        document.querySelectorAll("[data-radix-focus-guard]").forEach((node2) => node2.remove());
      }
      count--;
    };
  }, []);
}
function createFocusGuard() {
  const element = document.createElement("span");
  element.setAttribute("data-radix-focus-guard", "");
  element.tabIndex = 0;
  element.style.outline = "none";
  element.style.opacity = "0";
  element.style.position = "fixed";
  element.style.pointerEvents = "none";
  return element;
}
var zeroRightClassName = "right-scroll-bar-position";
var fullWidthClassName = "width-before-scroll-bar";
var noScrollbarsClassName = "with-scroll-bars-hidden";
var removedBarSizeVariable = "--removed-body-scroll-bar-size";
function assignRef(ref, value) {
  if (typeof ref === "function") {
    ref(value);
  } else if (ref) {
    ref.current = value;
  }
  return ref;
}
function useCallbackRef(initialValue, callback) {
  var ref = reactExports.useState(function() {
    return {
      // value
      value: initialValue,
      // last callback
      callback,
      // "memoized" public interface
      facade: {
        get current() {
          return ref.value;
        },
        set current(value) {
          var last = ref.value;
          if (last !== value) {
            ref.value = value;
            ref.callback(value, last);
          }
        }
      }
    };
  })[0];
  ref.callback = callback;
  return ref.facade;
}
var useIsomorphicLayoutEffect = typeof window !== "undefined" ? reactExports.useLayoutEffect : reactExports.useEffect;
var currentValues = /* @__PURE__ */ new WeakMap();
function useMergeRefs(refs, defaultValue) {
  var callbackRef = useCallbackRef(null, function(newValue) {
    return refs.forEach(function(ref) {
      return assignRef(ref, newValue);
    });
  });
  useIsomorphicLayoutEffect(function() {
    var oldValue = currentValues.get(callbackRef);
    if (oldValue) {
      var prevRefs_1 = new Set(oldValue);
      var nextRefs_1 = new Set(refs);
      var current_1 = callbackRef.current;
      prevRefs_1.forEach(function(ref) {
        if (!nextRefs_1.has(ref)) {
          assignRef(ref, null);
        }
      });
      nextRefs_1.forEach(function(ref) {
        if (!prevRefs_1.has(ref)) {
          assignRef(ref, current_1);
        }
      });
    }
    currentValues.set(callbackRef, refs);
  }, [refs]);
  return callbackRef;
}
function ItoI(a2) {
  return a2;
}
function innerCreateMedium(defaults2, middleware2) {
  if (middleware2 === void 0) {
    middleware2 = ItoI;
  }
  var buffer = [];
  var assigned = false;
  var medium = {
    read: function() {
      if (assigned) {
        throw new Error("Sidecar: could not `read` from an `assigned` medium. `read` could be used only with `useMedium`.");
      }
      if (buffer.length) {
        return buffer[buffer.length - 1];
      }
      return defaults2;
    },
    useMedium: function(data) {
      var item = middleware2(data, assigned);
      buffer.push(item);
      return function() {
        buffer = buffer.filter(function(x2) {
          return x2 !== item;
        });
      };
    },
    assignSyncMedium: function(cb) {
      assigned = true;
      while (buffer.length) {
        var cbs = buffer;
        buffer = [];
        cbs.forEach(cb);
      }
      buffer = {
        push: function(x2) {
          return cb(x2);
        },
        filter: function() {
          return buffer;
        }
      };
    },
    assignMedium: function(cb) {
      assigned = true;
      var pendingQueue = [];
      if (buffer.length) {
        var cbs = buffer;
        buffer = [];
        cbs.forEach(cb);
        pendingQueue = buffer;
      }
      var executeQueue = function() {
        var cbs2 = pendingQueue;
        pendingQueue = [];
        cbs2.forEach(cb);
      };
      var cycle = function() {
        return Promise.resolve().then(executeQueue);
      };
      cycle();
      buffer = {
        push: function(x2) {
          pendingQueue.push(x2);
          cycle();
        },
        filter: function(filter2) {
          pendingQueue = pendingQueue.filter(filter2);
          return buffer;
        }
      };
    }
  };
  return medium;
}
function createSidecarMedium(options) {
  if (options === void 0) {
    options = {};
  }
  var medium = innerCreateMedium(null);
  medium.options = __assign({ async: true, ssr: false }, options);
  return medium;
}
var SideCar$1 = function(_a2) {
  var sideCar = _a2.sideCar, rest = __rest(_a2, ["sideCar"]);
  if (!sideCar) {
    throw new Error("Sidecar: please provide `sideCar` property to import the right car");
  }
  var Target2 = sideCar.read();
  if (!Target2) {
    throw new Error("Sidecar medium not found");
  }
  return reactExports.createElement(Target2, __assign({}, rest));
};
SideCar$1.isSideCarExport = true;
function exportSidecar(medium, exported) {
  medium.useMedium(exported);
  return SideCar$1;
}
var effectCar = createSidecarMedium();
var nothing = function() {
  return;
};
var RemoveScroll = reactExports.forwardRef(function(props, parentRef) {
  var ref = reactExports.useRef(null);
  var _a2 = reactExports.useState({
    onScrollCapture: nothing,
    onWheelCapture: nothing,
    onTouchMoveCapture: nothing
  }), callbacks = _a2[0], setCallbacks = _a2[1];
  var forwardProps = props.forwardProps, children = props.children, className = props.className, removeScrollBar = props.removeScrollBar, enabled = props.enabled, shards = props.shards, sideCar = props.sideCar, noIsolation = props.noIsolation, inert = props.inert, allowPinchZoom = props.allowPinchZoom, _b2 = props.as, Container2 = _b2 === void 0 ? "div" : _b2, gapMode = props.gapMode, rest = __rest(props, ["forwardProps", "children", "className", "removeScrollBar", "enabled", "shards", "sideCar", "noIsolation", "inert", "allowPinchZoom", "as", "gapMode"]);
  var SideCar2 = sideCar;
  var containerRef = useMergeRefs([ref, parentRef]);
  var containerProps = __assign(__assign({}, rest), callbacks);
  return reactExports.createElement(
    reactExports.Fragment,
    null,
    enabled && reactExports.createElement(SideCar2, { sideCar: effectCar, removeScrollBar, shards, noIsolation, inert, setCallbacks, allowPinchZoom: !!allowPinchZoom, lockRef: ref, gapMode }),
    forwardProps ? reactExports.cloneElement(reactExports.Children.only(children), __assign(__assign({}, containerProps), { ref: containerRef })) : reactExports.createElement(Container2, __assign({}, containerProps, { className, ref: containerRef }), children)
  );
});
RemoveScroll.defaultProps = {
  enabled: true,
  removeScrollBar: true,
  inert: false
};
RemoveScroll.classNames = {
  fullWidth: fullWidthClassName,
  zeroRight: zeroRightClassName
};
var getNonce = function() {
  if (typeof __webpack_nonce__ !== "undefined") {
    return __webpack_nonce__;
  }
  return void 0;
};
function makeStyleTag() {
  if (!document)
    return null;
  var tag = document.createElement("style");
  tag.type = "text/css";
  var nonce = getNonce();
  if (nonce) {
    tag.setAttribute("nonce", nonce);
  }
  return tag;
}
function injectStyles(tag, css2) {
  if (tag.styleSheet) {
    tag.styleSheet.cssText = css2;
  } else {
    tag.appendChild(document.createTextNode(css2));
  }
}
function insertStyleTag(tag) {
  var head = document.head || document.getElementsByTagName("head")[0];
  head.appendChild(tag);
}
var stylesheetSingleton = function() {
  var counter = 0;
  var stylesheet = null;
  return {
    add: function(style2) {
      if (counter == 0) {
        if (stylesheet = makeStyleTag()) {
          injectStyles(stylesheet, style2);
          insertStyleTag(stylesheet);
        }
      }
      counter++;
    },
    remove: function() {
      counter--;
      if (!counter && stylesheet) {
        stylesheet.parentNode && stylesheet.parentNode.removeChild(stylesheet);
        stylesheet = null;
      }
    }
  };
};
var styleHookSingleton = function() {
  var sheet = stylesheetSingleton();
  return function(styles2, isDynamic) {
    reactExports.useEffect(function() {
      sheet.add(styles2);
      return function() {
        sheet.remove();
      };
    }, [styles2 && isDynamic]);
  };
};
var styleSingleton = function() {
  var useStyle2 = styleHookSingleton();
  var Sheet = function(_a2) {
    var styles2 = _a2.styles, dynamic = _a2.dynamic;
    useStyle2(styles2, dynamic);
    return null;
  };
  return Sheet;
};
var zeroGap = {
  left: 0,
  top: 0,
  right: 0,
  gap: 0
};
var parse$1 = function(x2) {
  return parseInt(x2 || "", 10) || 0;
};
var getOffset = function(gapMode) {
  var cs = window.getComputedStyle(document.body);
  var left = cs[gapMode === "padding" ? "paddingLeft" : "marginLeft"];
  var top = cs[gapMode === "padding" ? "paddingTop" : "marginTop"];
  var right = cs[gapMode === "padding" ? "paddingRight" : "marginRight"];
  return [parse$1(left), parse$1(top), parse$1(right)];
};
var getGapWidth = function(gapMode) {
  if (gapMode === void 0) {
    gapMode = "margin";
  }
  if (typeof window === "undefined") {
    return zeroGap;
  }
  var offsets = getOffset(gapMode);
  var documentWidth = document.documentElement.clientWidth;
  var windowWidth = window.innerWidth;
  return {
    left: offsets[0],
    top: offsets[1],
    right: offsets[2],
    gap: Math.max(0, windowWidth - documentWidth + offsets[2] - offsets[0])
  };
};
var Style = styleSingleton();
var lockAttribute = "data-scroll-locked";
var getStyles = function(_a2, allowRelative, gapMode, important) {
  var left = _a2.left, top = _a2.top, right = _a2.right, gap2 = _a2.gap;
  if (gapMode === void 0) {
    gapMode = "margin";
  }
  return "\n  .".concat(noScrollbarsClassName, " {\n   overflow: hidden ").concat(important, ";\n   padding-right: ").concat(gap2, "px ").concat(important, ";\n  }\n  body[").concat(lockAttribute, "] {\n    overflow: hidden ").concat(important, ";\n    overscroll-behavior: contain;\n    ").concat([
    allowRelative && "position: relative ".concat(important, ";"),
    gapMode === "margin" && "\n    padding-left: ".concat(left, "px;\n    padding-top: ").concat(top, "px;\n    padding-right: ").concat(right, "px;\n    margin-left:0;\n    margin-top:0;\n    margin-right: ").concat(gap2, "px ").concat(important, ";\n    "),
    gapMode === "padding" && "padding-right: ".concat(gap2, "px ").concat(important, ";")
  ].filter(Boolean).join(""), "\n  }\n  \n  .").concat(zeroRightClassName, " {\n    right: ").concat(gap2, "px ").concat(important, ";\n  }\n  \n  .").concat(fullWidthClassName, " {\n    margin-right: ").concat(gap2, "px ").concat(important, ";\n  }\n  \n  .").concat(zeroRightClassName, " .").concat(zeroRightClassName, " {\n    right: 0 ").concat(important, ";\n  }\n  \n  .").concat(fullWidthClassName, " .").concat(fullWidthClassName, " {\n    margin-right: 0 ").concat(important, ";\n  }\n  \n  body[").concat(lockAttribute, "] {\n    ").concat(removedBarSizeVariable, ": ").concat(gap2, "px;\n  }\n");
};
var getCurrentUseCounter = function() {
  var counter = parseInt(document.body.getAttribute(lockAttribute) || "0", 10);
  return isFinite(counter) ? counter : 0;
};
var useLockAttribute = function() {
  reactExports.useEffect(function() {
    document.body.setAttribute(lockAttribute, (getCurrentUseCounter() + 1).toString());
    return function() {
      var newCounter = getCurrentUseCounter() - 1;
      if (newCounter <= 0) {
        document.body.removeAttribute(lockAttribute);
      } else {
        document.body.setAttribute(lockAttribute, newCounter.toString());
      }
    };
  }, []);
};
var RemoveScrollBar = function(_a2) {
  var noRelative = _a2.noRelative, noImportant = _a2.noImportant, _b2 = _a2.gapMode, gapMode = _b2 === void 0 ? "margin" : _b2;
  useLockAttribute();
  var gap2 = reactExports.useMemo(function() {
    return getGapWidth(gapMode);
  }, [gapMode]);
  return reactExports.createElement(Style, { styles: getStyles(gap2, !noRelative, gapMode, !noImportant ? "!important" : "") });
};
var passiveSupported = false;
if (typeof window !== "undefined") {
  try {
    var options = Object.defineProperty({}, "passive", {
      get: function() {
        passiveSupported = true;
        return true;
      }
    });
    window.addEventListener("test", options, options);
    window.removeEventListener("test", options, options);
  } catch (err) {
    passiveSupported = false;
  }
}
var nonPassive = passiveSupported ? { passive: false } : false;
var alwaysContainsScroll = function(node2) {
  return node2.tagName === "TEXTAREA";
};
var elementCanBeScrolled = function(node2, overflow) {
  if (!(node2 instanceof Element)) {
    return false;
  }
  var styles2 = window.getComputedStyle(node2);
  return (
    // not-not-scrollable
    styles2[overflow] !== "hidden" && // contains scroll inside self
    !(styles2.overflowY === styles2.overflowX && !alwaysContainsScroll(node2) && styles2[overflow] === "visible")
  );
};
var elementCouldBeVScrolled = function(node2) {
  return elementCanBeScrolled(node2, "overflowY");
};
var elementCouldBeHScrolled = function(node2) {
  return elementCanBeScrolled(node2, "overflowX");
};
var locationCouldBeScrolled = function(axis, node2) {
  var ownerDocument2 = node2.ownerDocument;
  var current = node2;
  do {
    if (typeof ShadowRoot !== "undefined" && current instanceof ShadowRoot) {
      current = current.host;
    }
    var isScrollable = elementCouldBeScrolled(axis, current);
    if (isScrollable) {
      var _a2 = getScrollVariables(axis, current), scrollHeight = _a2[1], clientHeight = _a2[2];
      if (scrollHeight > clientHeight) {
        return true;
      }
    }
    current = current.parentNode;
  } while (current && current !== ownerDocument2.body);
  return false;
};
var getVScrollVariables = function(_a2) {
  var scrollTop = _a2.scrollTop, scrollHeight = _a2.scrollHeight, clientHeight = _a2.clientHeight;
  return [
    scrollTop,
    scrollHeight,
    clientHeight
  ];
};
var getHScrollVariables = function(_a2) {
  var scrollLeft = _a2.scrollLeft, scrollWidth = _a2.scrollWidth, clientWidth = _a2.clientWidth;
  return [
    scrollLeft,
    scrollWidth,
    clientWidth
  ];
};
var elementCouldBeScrolled = function(axis, node2) {
  return axis === "v" ? elementCouldBeVScrolled(node2) : elementCouldBeHScrolled(node2);
};
var getScrollVariables = function(axis, node2) {
  return axis === "v" ? getVScrollVariables(node2) : getHScrollVariables(node2);
};
var getDirectionFactor = function(axis, direction) {
  return axis === "h" && direction === "rtl" ? -1 : 1;
};
var handleScroll = function(axis, endTarget, event, sourceDelta, noOverscroll) {
  var directionFactor = getDirectionFactor(axis, window.getComputedStyle(endTarget).direction);
  var delta = directionFactor * sourceDelta;
  var target = event.target;
  var targetInLock = endTarget.contains(target);
  var shouldCancelScroll = false;
  var isDeltaPositive = delta > 0;
  var availableScroll = 0;
  var availableScrollTop = 0;
  do {
    var _a2 = getScrollVariables(axis, target), position2 = _a2[0], scroll_1 = _a2[1], capacity = _a2[2];
    var elementScroll = scroll_1 - capacity - directionFactor * position2;
    if (position2 || elementScroll) {
      if (elementCouldBeScrolled(axis, target)) {
        availableScroll += elementScroll;
        availableScrollTop += position2;
      }
    }
    if (target instanceof ShadowRoot) {
      target = target.host;
    } else {
      target = target.parentNode;
    }
  } while (
    // portaled content
    !targetInLock && target !== document.body || // self content
    targetInLock && (endTarget.contains(target) || endTarget === target)
  );
  if (isDeltaPositive && (Math.abs(availableScroll) < 1 || !noOverscroll)) {
    shouldCancelScroll = true;
  } else if (!isDeltaPositive && (Math.abs(availableScrollTop) < 1 || !noOverscroll)) {
    shouldCancelScroll = true;
  }
  return shouldCancelScroll;
};
var getTouchXY = function(event) {
  return "changedTouches" in event ? [event.changedTouches[0].clientX, event.changedTouches[0].clientY] : [0, 0];
};
var getDeltaXY = function(event) {
  return [event.deltaX, event.deltaY];
};
var extractRef = function(ref) {
  return ref && "current" in ref ? ref.current : ref;
};
var deltaCompare = function(x2, y2) {
  return x2[0] === y2[0] && x2[1] === y2[1];
};
var generateStyle = function(id2) {
  return "\n  .block-interactivity-".concat(id2, " {pointer-events: none;}\n  .allow-interactivity-").concat(id2, " {pointer-events: all;}\n");
};
var idCounter = 0;
var lockStack = [];
function RemoveScrollSideCar(props) {
  var shouldPreventQueue = reactExports.useRef([]);
  var touchStartRef = reactExports.useRef([0, 0]);
  var activeAxis = reactExports.useRef();
  var id2 = reactExports.useState(idCounter++)[0];
  var Style2 = reactExports.useState(styleSingleton)[0];
  var lastProps = reactExports.useRef(props);
  reactExports.useEffect(function() {
    lastProps.current = props;
  }, [props]);
  reactExports.useEffect(function() {
    if (props.inert) {
      document.body.classList.add("block-interactivity-".concat(id2));
      var allow_1 = __spreadArray([props.lockRef.current], (props.shards || []).map(extractRef), true).filter(Boolean);
      allow_1.forEach(function(el) {
        return el.classList.add("allow-interactivity-".concat(id2));
      });
      return function() {
        document.body.classList.remove("block-interactivity-".concat(id2));
        allow_1.forEach(function(el) {
          return el.classList.remove("allow-interactivity-".concat(id2));
        });
      };
    }
    return;
  }, [props.inert, props.lockRef.current, props.shards]);
  var shouldCancelEvent = reactExports.useCallback(function(event, parent2) {
    if ("touches" in event && event.touches.length === 2 || event.type === "wheel" && event.ctrlKey) {
      return !lastProps.current.allowPinchZoom;
    }
    var touch = getTouchXY(event);
    var touchStart = touchStartRef.current;
    var deltaX = "deltaX" in event ? event.deltaX : touchStart[0] - touch[0];
    var deltaY = "deltaY" in event ? event.deltaY : touchStart[1] - touch[1];
    var currentAxis;
    var target = event.target;
    var moveDirection = Math.abs(deltaX) > Math.abs(deltaY) ? "h" : "v";
    if ("touches" in event && moveDirection === "h" && target.type === "range") {
      return false;
    }
    var canBeScrolledInMainDirection = locationCouldBeScrolled(moveDirection, target);
    if (!canBeScrolledInMainDirection) {
      return true;
    }
    if (canBeScrolledInMainDirection) {
      currentAxis = moveDirection;
    } else {
      currentAxis = moveDirection === "v" ? "h" : "v";
      canBeScrolledInMainDirection = locationCouldBeScrolled(moveDirection, target);
    }
    if (!canBeScrolledInMainDirection) {
      return false;
    }
    if (!activeAxis.current && "changedTouches" in event && (deltaX || deltaY)) {
      activeAxis.current = currentAxis;
    }
    if (!currentAxis) {
      return true;
    }
    var cancelingAxis = activeAxis.current || currentAxis;
    return handleScroll(cancelingAxis, parent2, event, cancelingAxis === "h" ? deltaX : deltaY, true);
  }, []);
  var shouldPrevent = reactExports.useCallback(function(_event) {
    var event = _event;
    if (!lockStack.length || lockStack[lockStack.length - 1] !== Style2) {
      return;
    }
    var delta = "deltaY" in event ? getDeltaXY(event) : getTouchXY(event);
    var sourceEvent = shouldPreventQueue.current.filter(function(e2) {
      return e2.name === event.type && (e2.target === event.target || event.target === e2.shadowParent) && deltaCompare(e2.delta, delta);
    })[0];
    if (sourceEvent && sourceEvent.should) {
      if (event.cancelable) {
        event.preventDefault();
      }
      return;
    }
    if (!sourceEvent) {
      var shardNodes = (lastProps.current.shards || []).map(extractRef).filter(Boolean).filter(function(node2) {
        return node2.contains(event.target);
      });
      var shouldStop = shardNodes.length > 0 ? shouldCancelEvent(event, shardNodes[0]) : !lastProps.current.noIsolation;
      if (shouldStop) {
        if (event.cancelable) {
          event.preventDefault();
        }
      }
    }
  }, []);
  var shouldCancel = reactExports.useCallback(function(name, delta, target, should) {
    var event = { name, delta, target, should, shadowParent: getOutermostShadowParent(target) };
    shouldPreventQueue.current.push(event);
    setTimeout(function() {
      shouldPreventQueue.current = shouldPreventQueue.current.filter(function(e2) {
        return e2 !== event;
      });
    }, 1);
  }, []);
  var scrollTouchStart = reactExports.useCallback(function(event) {
    touchStartRef.current = getTouchXY(event);
    activeAxis.current = void 0;
  }, []);
  var scrollWheel = reactExports.useCallback(function(event) {
    shouldCancel(event.type, getDeltaXY(event), event.target, shouldCancelEvent(event, props.lockRef.current));
  }, []);
  var scrollTouchMove = reactExports.useCallback(function(event) {
    shouldCancel(event.type, getTouchXY(event), event.target, shouldCancelEvent(event, props.lockRef.current));
  }, []);
  reactExports.useEffect(function() {
    lockStack.push(Style2);
    props.setCallbacks({
      onScrollCapture: scrollWheel,
      onWheelCapture: scrollWheel,
      onTouchMoveCapture: scrollTouchMove
    });
    document.addEventListener("wheel", shouldPrevent, nonPassive);
    document.addEventListener("touchmove", shouldPrevent, nonPassive);
    document.addEventListener("touchstart", scrollTouchStart, nonPassive);
    return function() {
      lockStack = lockStack.filter(function(inst) {
        return inst !== Style2;
      });
      document.removeEventListener("wheel", shouldPrevent, nonPassive);
      document.removeEventListener("touchmove", shouldPrevent, nonPassive);
      document.removeEventListener("touchstart", scrollTouchStart, nonPassive);
    };
  }, []);
  var removeScrollBar = props.removeScrollBar, inert = props.inert;
  return reactExports.createElement(
    reactExports.Fragment,
    null,
    inert ? reactExports.createElement(Style2, { styles: generateStyle(id2) }) : null,
    removeScrollBar ? reactExports.createElement(RemoveScrollBar, { gapMode: props.gapMode }) : null
  );
}
function getOutermostShadowParent(node2) {
  var shadowParent = null;
  while (node2 !== null) {
    if (node2 instanceof ShadowRoot) {
      shadowParent = node2.host;
      node2 = node2.host;
    }
    node2 = node2.parentNode;
  }
  return shadowParent;
}
const SideCar = exportSidecar(effectCar, RemoveScrollSideCar);
var ReactRemoveScroll = reactExports.forwardRef(function(props, ref) {
  return reactExports.createElement(RemoveScroll, __assign({}, props, { ref, sideCar: SideCar }));
});
ReactRemoveScroll.classNames = RemoveScroll.classNames;
var getDefaultParent = function(originalTarget) {
  if (typeof document === "undefined") {
    return null;
  }
  var sampleTarget = Array.isArray(originalTarget) ? originalTarget[0] : originalTarget;
  return sampleTarget.ownerDocument.body;
};
var counterMap = /* @__PURE__ */ new WeakMap();
var uncontrolledNodes = /* @__PURE__ */ new WeakMap();
var markerMap = {};
var lockCount = 0;
var unwrapHost = function(node2) {
  return node2 && (node2.host || unwrapHost(node2.parentNode));
};
var correctTargets = function(parent2, targets) {
  return targets.map(function(target) {
    if (parent2.contains(target)) {
      return target;
    }
    var correctedTarget = unwrapHost(target);
    if (correctedTarget && parent2.contains(correctedTarget)) {
      return correctedTarget;
    }
    console.error("aria-hidden", target, "in not contained inside", parent2, ". Doing nothing");
    return null;
  }).filter(function(x2) {
    return Boolean(x2);
  });
};
var applyAttributeToOthers = function(originalTarget, parentNode, markerName, controlAttribute) {
  var targets = correctTargets(parentNode, Array.isArray(originalTarget) ? originalTarget : [originalTarget]);
  if (!markerMap[markerName]) {
    markerMap[markerName] = /* @__PURE__ */ new WeakMap();
  }
  var markerCounter = markerMap[markerName];
  var hiddenNodes = [];
  var elementsToKeep = /* @__PURE__ */ new Set();
  var elementsToStop = new Set(targets);
  var keep = function(el) {
    if (!el || elementsToKeep.has(el)) {
      return;
    }
    elementsToKeep.add(el);
    keep(el.parentNode);
  };
  targets.forEach(keep);
  var deep = function(parent2) {
    if (!parent2 || elementsToStop.has(parent2)) {
      return;
    }
    Array.prototype.forEach.call(parent2.children, function(node2) {
      if (elementsToKeep.has(node2)) {
        deep(node2);
      } else {
        try {
          var attr = node2.getAttribute(controlAttribute);
          var alreadyHidden = attr !== null && attr !== "false";
          var counterValue = (counterMap.get(node2) || 0) + 1;
          var markerValue = (markerCounter.get(node2) || 0) + 1;
          counterMap.set(node2, counterValue);
          markerCounter.set(node2, markerValue);
          hiddenNodes.push(node2);
          if (counterValue === 1 && alreadyHidden) {
            uncontrolledNodes.set(node2, true);
          }
          if (markerValue === 1) {
            node2.setAttribute(markerName, "true");
          }
          if (!alreadyHidden) {
            node2.setAttribute(controlAttribute, "true");
          }
        } catch (e2) {
          console.error("aria-hidden: cannot operate on ", node2, e2);
        }
      }
    });
  };
  deep(parentNode);
  elementsToKeep.clear();
  lockCount++;
  return function() {
    hiddenNodes.forEach(function(node2) {
      var counterValue = counterMap.get(node2) - 1;
      var markerValue = markerCounter.get(node2) - 1;
      counterMap.set(node2, counterValue);
      markerCounter.set(node2, markerValue);
      if (!counterValue) {
        if (!uncontrolledNodes.has(node2)) {
          node2.removeAttribute(controlAttribute);
        }
        uncontrolledNodes.delete(node2);
      }
      if (!markerValue) {
        node2.removeAttribute(markerName);
      }
    });
    lockCount--;
    if (!lockCount) {
      counterMap = /* @__PURE__ */ new WeakMap();
      counterMap = /* @__PURE__ */ new WeakMap();
      uncontrolledNodes = /* @__PURE__ */ new WeakMap();
      markerMap = {};
    }
  };
};
var hideOthers = function(originalTarget, parentNode, markerName) {
  if (markerName === void 0) {
    markerName = "data-aria-hidden";
  }
  var targets = Array.from(Array.isArray(originalTarget) ? originalTarget : [originalTarget]);
  var activeParentNode = getDefaultParent(originalTarget);
  if (!activeParentNode) {
    return function() {
      return null;
    };
  }
  targets.push.apply(targets, Array.from(activeParentNode.querySelectorAll("[aria-live]")));
  return applyAttributeToOthers(targets, activeParentNode, markerName, "aria-hidden");
};
var DIALOG_NAME = "Dialog";
var [createDialogContext, createDialogScope] = createContextScope$3(DIALOG_NAME);
var [DialogProvider, useDialogContext] = createDialogContext(DIALOG_NAME);
var Dialog$1 = (props) => {
  const {
    __scopeDialog,
    children,
    open: openProp,
    defaultOpen,
    onOpenChange,
    modal = true
  } = props;
  const triggerRef = reactExports.useRef(null);
  const contentRef = reactExports.useRef(null);
  const [open = false, setOpen] = useControllableState({
    prop: openProp,
    defaultProp: defaultOpen,
    onChange: onOpenChange
  });
  return /* @__PURE__ */ jsxRuntimeExports.jsx(
    DialogProvider,
    {
      scope: __scopeDialog,
      triggerRef,
      contentRef,
      contentId: useId$1(),
      titleId: useId$1(),
      descriptionId: useId$1(),
      open,
      onOpenChange: setOpen,
      onOpenToggle: reactExports.useCallback(() => setOpen((prevOpen) => !prevOpen), [setOpen]),
      modal,
      children
    }
  );
};
Dialog$1.displayName = DIALOG_NAME;
var TRIGGER_NAME$1 = "DialogTrigger";
var DialogTrigger$1 = reactExports.forwardRef(
  (props, forwardedRef) => {
    const { __scopeDialog, ...triggerProps } = props;
    const context = useDialogContext(TRIGGER_NAME$1, __scopeDialog);
    const composedTriggerRef = useComposedRefs(forwardedRef, context.triggerRef);
    return /* @__PURE__ */ jsxRuntimeExports.jsx(
      Primitive.button,
      {
        type: "button",
        "aria-haspopup": "dialog",
        "aria-expanded": context.open,
        "aria-controls": context.contentId,
        "data-state": getState(context.open),
        ...triggerProps,
        ref: composedTriggerRef,
        onClick: composeEventHandlers(props.onClick, context.onOpenToggle)
      }
    );
  }
);
DialogTrigger$1.displayName = TRIGGER_NAME$1;
var PORTAL_NAME = "DialogPortal";
var [PortalProvider, usePortalContext] = createDialogContext(PORTAL_NAME, {
  forceMount: void 0
});
var DialogPortal$1 = (props) => {
  const { __scopeDialog, forceMount, children, container } = props;
  const context = useDialogContext(PORTAL_NAME, __scopeDialog);
  return /* @__PURE__ */ jsxRuntimeExports.jsx(PortalProvider, { scope: __scopeDialog, forceMount, children: reactExports.Children.map(children, (child) => /* @__PURE__ */ jsxRuntimeExports.jsx(Presence, { present: forceMount || context.open, children: /* @__PURE__ */ jsxRuntimeExports.jsx(Portal$1, { asChild: true, container, children: child }) })) });
};
DialogPortal$1.displayName = PORTAL_NAME;
var OVERLAY_NAME = "DialogOverlay";
var DialogOverlay$1 = reactExports.forwardRef(
  (props, forwardedRef) => {
    const portalContext = usePortalContext(OVERLAY_NAME, props.__scopeDialog);
    const { forceMount = portalContext.forceMount, ...overlayProps } = props;
    const context = useDialogContext(OVERLAY_NAME, props.__scopeDialog);
    return context.modal ? /* @__PURE__ */ jsxRuntimeExports.jsx(Presence, { present: forceMount || context.open, children: /* @__PURE__ */ jsxRuntimeExports.jsx(DialogOverlayImpl, { ...overlayProps, ref: forwardedRef }) }) : null;
  }
);
DialogOverlay$1.displayName = OVERLAY_NAME;
var DialogOverlayImpl = reactExports.forwardRef(
  (props, forwardedRef) => {
    const { __scopeDialog, ...overlayProps } = props;
    const context = useDialogContext(OVERLAY_NAME, __scopeDialog);
    return (
      // Make sure `Content` is scrollable even when it doesn't live inside `RemoveScroll`
      // ie. when `Overlay` and `Content` are siblings
      /* @__PURE__ */ jsxRuntimeExports.jsx(ReactRemoveScroll, { as: Slot, allowPinchZoom: true, shards: [context.contentRef], children: /* @__PURE__ */ jsxRuntimeExports.jsx(
        Primitive.div,
        {
          "data-state": getState(context.open),
          ...overlayProps,
          ref: forwardedRef,
          style: { pointerEvents: "auto", ...overlayProps.style }
        }
      ) })
    );
  }
);
var CONTENT_NAME$1 = "DialogContent";
var DialogContent$1 = reactExports.forwardRef(
  (props, forwardedRef) => {
    const portalContext = usePortalContext(CONTENT_NAME$1, props.__scopeDialog);
    const { forceMount = portalContext.forceMount, ...contentProps } = props;
    const context = useDialogContext(CONTENT_NAME$1, props.__scopeDialog);
    return /* @__PURE__ */ jsxRuntimeExports.jsx(Presence, { present: forceMount || context.open, children: context.modal ? /* @__PURE__ */ jsxRuntimeExports.jsx(DialogContentModal, { ...contentProps, ref: forwardedRef }) : /* @__PURE__ */ jsxRuntimeExports.jsx(DialogContentNonModal, { ...contentProps, ref: forwardedRef }) });
  }
);
DialogContent$1.displayName = CONTENT_NAME$1;
var DialogContentModal = reactExports.forwardRef(
  (props, forwardedRef) => {
    const context = useDialogContext(CONTENT_NAME$1, props.__scopeDialog);
    const contentRef = reactExports.useRef(null);
    const composedRefs = useComposedRefs(forwardedRef, context.contentRef, contentRef);
    reactExports.useEffect(() => {
      const content = contentRef.current;
      if (content) return hideOthers(content);
    }, []);
    return /* @__PURE__ */ jsxRuntimeExports.jsx(
      DialogContentImpl,
      {
        ...props,
        ref: composedRefs,
        trapFocus: context.open,
        disableOutsidePointerEvents: true,
        onCloseAutoFocus: composeEventHandlers(props.onCloseAutoFocus, (event) => {
          event.preventDefault();
          context.triggerRef.current?.focus();
        }),
        onPointerDownOutside: composeEventHandlers(props.onPointerDownOutside, (event) => {
          const originalEvent = event.detail.originalEvent;
          const ctrlLeftClick = originalEvent.button === 0 && originalEvent.ctrlKey === true;
          const isRightClick = originalEvent.button === 2 || ctrlLeftClick;
          if (isRightClick) event.preventDefault();
        }),
        onFocusOutside: composeEventHandlers(
          props.onFocusOutside,
          (event) => event.preventDefault()
        )
      }
    );
  }
);
var DialogContentNonModal = reactExports.forwardRef(
  (props, forwardedRef) => {
    const context = useDialogContext(CONTENT_NAME$1, props.__scopeDialog);
    const hasInteractedOutsideRef = reactExports.useRef(false);
    const hasPointerDownOutsideRef = reactExports.useRef(false);
    return /* @__PURE__ */ jsxRuntimeExports.jsx(
      DialogContentImpl,
      {
        ...props,
        ref: forwardedRef,
        trapFocus: false,
        disableOutsidePointerEvents: false,
        onCloseAutoFocus: (event) => {
          props.onCloseAutoFocus?.(event);
          if (!event.defaultPrevented) {
            if (!hasInteractedOutsideRef.current) context.triggerRef.current?.focus();
            event.preventDefault();
          }
          hasInteractedOutsideRef.current = false;
          hasPointerDownOutsideRef.current = false;
        },
        onInteractOutside: (event) => {
          props.onInteractOutside?.(event);
          if (!event.defaultPrevented) {
            hasInteractedOutsideRef.current = true;
            if (event.detail.originalEvent.type === "pointerdown") {
              hasPointerDownOutsideRef.current = true;
            }
          }
          const target = event.target;
          const targetIsTrigger = context.triggerRef.current?.contains(target);
          if (targetIsTrigger) event.preventDefault();
          if (event.detail.originalEvent.type === "focusin" && hasPointerDownOutsideRef.current) {
            event.preventDefault();
          }
        }
      }
    );
  }
);
var DialogContentImpl = reactExports.forwardRef(
  (props, forwardedRef) => {
    const { __scopeDialog, trapFocus, onOpenAutoFocus, onCloseAutoFocus, ...contentProps } = props;
    const context = useDialogContext(CONTENT_NAME$1, __scopeDialog);
    const contentRef = reactExports.useRef(null);
    const composedRefs = useComposedRefs(forwardedRef, contentRef);
    useFocusGuards();
    return /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx(
        FocusScope,
        {
          asChild: true,
          loop: true,
          trapped: trapFocus,
          onMountAutoFocus: onOpenAutoFocus,
          onUnmountAutoFocus: onCloseAutoFocus,
          children: /* @__PURE__ */ jsxRuntimeExports.jsx(
            DismissableLayer,
            {
              role: "dialog",
              id: context.contentId,
              "aria-describedby": context.descriptionId,
              "aria-labelledby": context.titleId,
              "data-state": getState(context.open),
              ...contentProps,
              ref: composedRefs,
              onDismiss: () => context.onOpenChange(false)
            }
          )
        }
      ),
      /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx(TitleWarning, { titleId: context.titleId }),
        /* @__PURE__ */ jsxRuntimeExports.jsx(DescriptionWarning, { contentRef, descriptionId: context.descriptionId })
      ] })
    ] });
  }
);
var TITLE_NAME = "DialogTitle";
var DialogTitle$1 = reactExports.forwardRef(
  (props, forwardedRef) => {
    const { __scopeDialog, ...titleProps } = props;
    const context = useDialogContext(TITLE_NAME, __scopeDialog);
    return /* @__PURE__ */ jsxRuntimeExports.jsx(Primitive.h2, { id: context.titleId, ...titleProps, ref: forwardedRef });
  }
);
DialogTitle$1.displayName = TITLE_NAME;
var DESCRIPTION_NAME = "DialogDescription";
var DialogDescription$1 = reactExports.forwardRef(
  (props, forwardedRef) => {
    const { __scopeDialog, ...descriptionProps } = props;
    const context = useDialogContext(DESCRIPTION_NAME, __scopeDialog);
    return /* @__PURE__ */ jsxRuntimeExports.jsx(Primitive.p, { id: context.descriptionId, ...descriptionProps, ref: forwardedRef });
  }
);
DialogDescription$1.displayName = DESCRIPTION_NAME;
var CLOSE_NAME = "DialogClose";
var DialogClose = reactExports.forwardRef(
  (props, forwardedRef) => {
    const { __scopeDialog, ...closeProps } = props;
    const context = useDialogContext(CLOSE_NAME, __scopeDialog);
    return /* @__PURE__ */ jsxRuntimeExports.jsx(
      Primitive.button,
      {
        type: "button",
        ...closeProps,
        ref: forwardedRef,
        onClick: composeEventHandlers(props.onClick, () => context.onOpenChange(false))
      }
    );
  }
);
DialogClose.displayName = CLOSE_NAME;
function getState(open) {
  return open ? "open" : "closed";
}
var TITLE_WARNING_NAME = "DialogTitleWarning";
var [WarningProvider, useWarningContext] = createContext2(TITLE_WARNING_NAME, {
  contentName: CONTENT_NAME$1,
  titleName: TITLE_NAME,
  docsSlug: "dialog"
});
var TitleWarning = ({ titleId }) => {
  const titleWarningContext = useWarningContext(TITLE_WARNING_NAME);
  const MESSAGE = `\`${titleWarningContext.contentName}\` requires a \`${titleWarningContext.titleName}\` for the component to be accessible for screen reader users.

If you want to hide the \`${titleWarningContext.titleName}\`, you can wrap it with our VisuallyHidden component.

For more information, see https://radix-ui.com/primitives/docs/components/${titleWarningContext.docsSlug}`;
  reactExports.useEffect(() => {
    if (titleId) {
      const hasTitle = document.getElementById(titleId);
      if (!hasTitle) console.error(MESSAGE);
    }
  }, [MESSAGE, titleId]);
  return null;
};
var DESCRIPTION_WARNING_NAME = "DialogDescriptionWarning";
var DescriptionWarning = ({ contentRef, descriptionId }) => {
  const descriptionWarningContext = useWarningContext(DESCRIPTION_WARNING_NAME);
  const MESSAGE = `Warning: Missing \`Description\` or \`aria-describedby={undefined}\` for {${descriptionWarningContext.contentName}}.`;
  reactExports.useEffect(() => {
    const describedById = contentRef.current?.getAttribute("aria-describedby");
    if (descriptionId && describedById) {
      const hasDescription = document.getElementById(descriptionId);
      if (!hasDescription) console.warn(MESSAGE);
    }
  }, [MESSAGE, contentRef, descriptionId]);
  return null;
};
var Root$4 = Dialog$1;
var Trigger$1 = DialogTrigger$1;
var Portal = DialogPortal$1;
var Overlay = DialogOverlay$1;
var Content$1 = DialogContent$1;
var Title = DialogTitle$1;
var Description = DialogDescription$1;
var Close = DialogClose;
const Dialog = Root$4;
const DialogTrigger = Trigger$1;
const DialogPortal = Portal;
const DialogOverlay = reactExports.forwardRef(({ className, ...props }, ref) => /* @__PURE__ */ jsxRuntimeExports.jsx(
  Overlay,
  {
    ref,
    className: cn(
      "fixed inset-0 z-50 bg-black/80  data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0",
      className
    ),
    ...props
  }
));
DialogOverlay.displayName = Overlay.displayName;
const DialogContent = reactExports.forwardRef(({ className, children, ...props }, ref) => /* @__PURE__ */ jsxRuntimeExports.jsxs(DialogPortal, { children: [
  /* @__PURE__ */ jsxRuntimeExports.jsx(DialogOverlay, {}),
  /* @__PURE__ */ jsxRuntimeExports.jsxs(
    Content$1,
    {
      ref,
      className: cn(
        "fixed left-[50%] top-[50%] z-50 grid w-full max-w-lg translate-x-[-50%] translate-y-[-50%] gap-4 border bg-background p-6 shadow-lg duration-200 data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 data-[state=closed]:slide-out-to-left-1/2 data-[state=closed]:slide-out-to-top-[48%] data-[state=open]:slide-in-from-left-1/2 data-[state=open]:slide-in-from-top-[48%] sm:rounded-lg",
        className
      ),
      ...props,
      children: [
        children,
        /* @__PURE__ */ jsxRuntimeExports.jsxs(Close, { className: "absolute right-4 top-4 rounded-sm opacity-70 ring-offset-background transition-opacity hover:opacity-100 focus:outline-none focus:ring-2 focus:ring-ring focus:ring-offset-2 disabled:pointer-events-none data-[state=open]:bg-accent data-[state=open]:text-muted-foreground", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx(X, { className: "h-4 w-4" }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "sr-only", children: "Close" })
        ] })
      ]
    }
  )
] }));
DialogContent.displayName = Content$1.displayName;
const DialogHeader = ({
  className,
  ...props
}) => /* @__PURE__ */ jsxRuntimeExports.jsx(
  "div",
  {
    className: cn(
      "flex flex-col space-y-1.5 text-center sm:text-left",
      className
    ),
    ...props
  }
);
DialogHeader.displayName = "DialogHeader";
const DialogFooter = ({
  className,
  ...props
}) => /* @__PURE__ */ jsxRuntimeExports.jsx(
  "div",
  {
    className: cn(
      "flex flex-col-reverse sm:flex-row sm:justify-end sm:space-x-2",
      className
    ),
    ...props
  }
);
DialogFooter.displayName = "DialogFooter";
const DialogTitle = reactExports.forwardRef(({ className, ...props }, ref) => /* @__PURE__ */ jsxRuntimeExports.jsx(
  Title,
  {
    ref,
    className: cn(
      "text-lg font-semibold leading-none tracking-tight",
      className
    ),
    ...props
  }
));
DialogTitle.displayName = Title.displayName;
const DialogDescription = reactExports.forwardRef(({ className, ...props }, ref) => /* @__PURE__ */ jsxRuntimeExports.jsx(
  Description,
  {
    ref,
    className: cn("text-sm text-muted-foreground", className),
    ...props
  }
));
DialogDescription.displayName = Description.displayName;
var DirectionContext = reactExports.createContext(void 0);
function useDirection(localDir) {
  const globalDir = reactExports.useContext(DirectionContext);
  return localDir || globalDir || "ltr";
}
function clamp$2(value, [min2, max2]) {
  return Math.min(max2, Math.max(min2, value));
}
function useStateMachine(initialState, machine) {
  return reactExports.useReducer((state, event) => {
    const nextState = machine[state][event];
    return nextState ?? state;
  }, initialState);
}
var SCROLL_AREA_NAME = "ScrollArea";
var [createScrollAreaContext, createScrollAreaScope] = createContextScope$3(SCROLL_AREA_NAME);
var [ScrollAreaProvider, useScrollAreaContext] = createScrollAreaContext(SCROLL_AREA_NAME);
var ScrollArea$1 = reactExports.forwardRef(
  (props, forwardedRef) => {
    const {
      __scopeScrollArea,
      type = "hover",
      dir,
      scrollHideDelay = 600,
      ...scrollAreaProps
    } = props;
    const [scrollArea, setScrollArea] = reactExports.useState(null);
    const [viewport, setViewport] = reactExports.useState(null);
    const [content, setContent] = reactExports.useState(null);
    const [scrollbarX, setScrollbarX] = reactExports.useState(null);
    const [scrollbarY, setScrollbarY] = reactExports.useState(null);
    const [cornerWidth, setCornerWidth] = reactExports.useState(0);
    const [cornerHeight, setCornerHeight] = reactExports.useState(0);
    const [scrollbarXEnabled, setScrollbarXEnabled] = reactExports.useState(false);
    const [scrollbarYEnabled, setScrollbarYEnabled] = reactExports.useState(false);
    const composedRefs = useComposedRefs(forwardedRef, (node2) => setScrollArea(node2));
    const direction = useDirection(dir);
    return /* @__PURE__ */ jsxRuntimeExports.jsx(
      ScrollAreaProvider,
      {
        scope: __scopeScrollArea,
        type,
        dir: direction,
        scrollHideDelay,
        scrollArea,
        viewport,
        onViewportChange: setViewport,
        content,
        onContentChange: setContent,
        scrollbarX,
        onScrollbarXChange: setScrollbarX,
        scrollbarXEnabled,
        onScrollbarXEnabledChange: setScrollbarXEnabled,
        scrollbarY,
        onScrollbarYChange: setScrollbarY,
        scrollbarYEnabled,
        onScrollbarYEnabledChange: setScrollbarYEnabled,
        onCornerWidthChange: setCornerWidth,
        onCornerHeightChange: setCornerHeight,
        children: /* @__PURE__ */ jsxRuntimeExports.jsx(
          Primitive.div,
          {
            dir: direction,
            ...scrollAreaProps,
            ref: composedRefs,
            style: {
              position: "relative",
              // Pass corner sizes as CSS vars to reduce re-renders of context consumers
              ["--radix-scroll-area-corner-width"]: cornerWidth + "px",
              ["--radix-scroll-area-corner-height"]: cornerHeight + "px",
              ...props.style
            }
          }
        )
      }
    );
  }
);
ScrollArea$1.displayName = SCROLL_AREA_NAME;
var VIEWPORT_NAME = "ScrollAreaViewport";
var ScrollAreaViewport = reactExports.forwardRef(
  (props, forwardedRef) => {
    const { __scopeScrollArea, children, asChild, nonce, ...viewportProps } = props;
    const context = useScrollAreaContext(VIEWPORT_NAME, __scopeScrollArea);
    const ref = reactExports.useRef(null);
    const composedRefs = useComposedRefs(forwardedRef, ref, context.onViewportChange);
    return /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx(
        "style",
        {
          dangerouslySetInnerHTML: {
            __html: `
[data-radix-scroll-area-viewport] {
  scrollbar-width: none;
  -ms-overflow-style: none;
  -webkit-overflow-scrolling: touch;
}
[data-radix-scroll-area-viewport]::-webkit-scrollbar {
  display: none;
}
:where([data-radix-scroll-area-viewport]) {
  display: flex;
  flex-direction: column;
  align-items: stretch;
}
:where([data-radix-scroll-area-content]) {
  flex-grow: 1;
}
`
          },
          nonce
        }
      ),
      /* @__PURE__ */ jsxRuntimeExports.jsx(
        Primitive.div,
        {
          "data-radix-scroll-area-viewport": "",
          ...viewportProps,
          asChild,
          ref: composedRefs,
          style: {
            /**
             * We don't support `visible` because the intention is to have at least one scrollbar
             * if this component is used and `visible` will behave like `auto` in that case
             * https://developer.mozilla.org/en-US/docs/Web/CSS/overflow#description
             *
             * We don't handle `auto` because the intention is for the native implementation
             * to be hidden if using this component. We just want to ensure the node is scrollable
             * so could have used either `scroll` or `auto` here. We picked `scroll` to prevent
             * the browser from having to work out whether to render native scrollbars or not,
             * we tell it to with the intention of hiding them in CSS.
             */
            overflowX: context.scrollbarXEnabled ? "scroll" : "hidden",
            overflowY: context.scrollbarYEnabled ? "scroll" : "hidden",
            ...props.style
          },
          children: getSubtree({ asChild, children }, (children2) => /* @__PURE__ */ jsxRuntimeExports.jsx(
            "div",
            {
              "data-radix-scroll-area-content": "",
              ref: context.onContentChange,
              style: { minWidth: context.scrollbarXEnabled ? "fit-content" : void 0 },
              children: children2
            }
          ))
        }
      )
    ] });
  }
);
ScrollAreaViewport.displayName = VIEWPORT_NAME;
var SCROLLBAR_NAME = "ScrollAreaScrollbar";
var ScrollAreaScrollbar = reactExports.forwardRef(
  (props, forwardedRef) => {
    const { forceMount, ...scrollbarProps } = props;
    const context = useScrollAreaContext(SCROLLBAR_NAME, props.__scopeScrollArea);
    const { onScrollbarXEnabledChange, onScrollbarYEnabledChange } = context;
    const isHorizontal = props.orientation === "horizontal";
    reactExports.useEffect(() => {
      isHorizontal ? onScrollbarXEnabledChange(true) : onScrollbarYEnabledChange(true);
      return () => {
        isHorizontal ? onScrollbarXEnabledChange(false) : onScrollbarYEnabledChange(false);
      };
    }, [isHorizontal, onScrollbarXEnabledChange, onScrollbarYEnabledChange]);
    return context.type === "hover" ? /* @__PURE__ */ jsxRuntimeExports.jsx(ScrollAreaScrollbarHover, { ...scrollbarProps, ref: forwardedRef, forceMount }) : context.type === "scroll" ? /* @__PURE__ */ jsxRuntimeExports.jsx(ScrollAreaScrollbarScroll, { ...scrollbarProps, ref: forwardedRef, forceMount }) : context.type === "auto" ? /* @__PURE__ */ jsxRuntimeExports.jsx(ScrollAreaScrollbarAuto, { ...scrollbarProps, ref: forwardedRef, forceMount }) : context.type === "always" ? /* @__PURE__ */ jsxRuntimeExports.jsx(ScrollAreaScrollbarVisible, { ...scrollbarProps, ref: forwardedRef }) : null;
  }
);
ScrollAreaScrollbar.displayName = SCROLLBAR_NAME;
var ScrollAreaScrollbarHover = reactExports.forwardRef((props, forwardedRef) => {
  const { forceMount, ...scrollbarProps } = props;
  const context = useScrollAreaContext(SCROLLBAR_NAME, props.__scopeScrollArea);
  const [visible, setVisible] = reactExports.useState(false);
  reactExports.useEffect(() => {
    const scrollArea = context.scrollArea;
    let hideTimer = 0;
    if (scrollArea) {
      const handlePointerEnter = () => {
        window.clearTimeout(hideTimer);
        setVisible(true);
      };
      const handlePointerLeave = () => {
        hideTimer = window.setTimeout(() => setVisible(false), context.scrollHideDelay);
      };
      scrollArea.addEventListener("pointerenter", handlePointerEnter);
      scrollArea.addEventListener("pointerleave", handlePointerLeave);
      return () => {
        window.clearTimeout(hideTimer);
        scrollArea.removeEventListener("pointerenter", handlePointerEnter);
        scrollArea.removeEventListener("pointerleave", handlePointerLeave);
      };
    }
  }, [context.scrollArea, context.scrollHideDelay]);
  return /* @__PURE__ */ jsxRuntimeExports.jsx(Presence, { present: forceMount || visible, children: /* @__PURE__ */ jsxRuntimeExports.jsx(
    ScrollAreaScrollbarAuto,
    {
      "data-state": visible ? "visible" : "hidden",
      ...scrollbarProps,
      ref: forwardedRef
    }
  ) });
});
var ScrollAreaScrollbarScroll = reactExports.forwardRef((props, forwardedRef) => {
  const { forceMount, ...scrollbarProps } = props;
  const context = useScrollAreaContext(SCROLLBAR_NAME, props.__scopeScrollArea);
  const isHorizontal = props.orientation === "horizontal";
  const debounceScrollEnd = useDebounceCallback(() => send("SCROLL_END"), 100);
  const [state, send] = useStateMachine("hidden", {
    hidden: {
      SCROLL: "scrolling"
    },
    scrolling: {
      SCROLL_END: "idle",
      POINTER_ENTER: "interacting"
    },
    interacting: {
      SCROLL: "interacting",
      POINTER_LEAVE: "idle"
    },
    idle: {
      HIDE: "hidden",
      SCROLL: "scrolling",
      POINTER_ENTER: "interacting"
    }
  });
  reactExports.useEffect(() => {
    if (state === "idle") {
      const hideTimer = window.setTimeout(() => send("HIDE"), context.scrollHideDelay);
      return () => window.clearTimeout(hideTimer);
    }
  }, [state, context.scrollHideDelay, send]);
  reactExports.useEffect(() => {
    const viewport = context.viewport;
    const scrollDirection = isHorizontal ? "scrollLeft" : "scrollTop";
    if (viewport) {
      let prevScrollPos = viewport[scrollDirection];
      const handleScroll2 = () => {
        const scrollPos = viewport[scrollDirection];
        const hasScrollInDirectionChanged = prevScrollPos !== scrollPos;
        if (hasScrollInDirectionChanged) {
          send("SCROLL");
          debounceScrollEnd();
        }
        prevScrollPos = scrollPos;
      };
      viewport.addEventListener("scroll", handleScroll2);
      return () => viewport.removeEventListener("scroll", handleScroll2);
    }
  }, [context.viewport, isHorizontal, send, debounceScrollEnd]);
  return /* @__PURE__ */ jsxRuntimeExports.jsx(Presence, { present: forceMount || state !== "hidden", children: /* @__PURE__ */ jsxRuntimeExports.jsx(
    ScrollAreaScrollbarVisible,
    {
      "data-state": state === "hidden" ? "hidden" : "visible",
      ...scrollbarProps,
      ref: forwardedRef,
      onPointerEnter: composeEventHandlers(props.onPointerEnter, () => send("POINTER_ENTER")),
      onPointerLeave: composeEventHandlers(props.onPointerLeave, () => send("POINTER_LEAVE"))
    }
  ) });
});
var ScrollAreaScrollbarAuto = reactExports.forwardRef((props, forwardedRef) => {
  const context = useScrollAreaContext(SCROLLBAR_NAME, props.__scopeScrollArea);
  const { forceMount, ...scrollbarProps } = props;
  const [visible, setVisible] = reactExports.useState(false);
  const isHorizontal = props.orientation === "horizontal";
  const handleResize = useDebounceCallback(() => {
    if (context.viewport) {
      const isOverflowX = context.viewport.offsetWidth < context.viewport.scrollWidth;
      const isOverflowY = context.viewport.offsetHeight < context.viewport.scrollHeight;
      setVisible(isHorizontal ? isOverflowX : isOverflowY);
    }
  }, 10);
  useResizeObserver(context.viewport, handleResize);
  useResizeObserver(context.content, handleResize);
  return /* @__PURE__ */ jsxRuntimeExports.jsx(Presence, { present: forceMount || visible, children: /* @__PURE__ */ jsxRuntimeExports.jsx(
    ScrollAreaScrollbarVisible,
    {
      "data-state": visible ? "visible" : "hidden",
      ...scrollbarProps,
      ref: forwardedRef
    }
  ) });
});
var ScrollAreaScrollbarVisible = reactExports.forwardRef((props, forwardedRef) => {
  const { orientation = "vertical", ...scrollbarProps } = props;
  const context = useScrollAreaContext(SCROLLBAR_NAME, props.__scopeScrollArea);
  const thumbRef = reactExports.useRef(null);
  const pointerOffsetRef = reactExports.useRef(0);
  const [sizes, setSizes] = reactExports.useState({
    content: 0,
    viewport: 0,
    scrollbar: { size: 0, paddingStart: 0, paddingEnd: 0 }
  });
  const thumbRatio = getThumbRatio(sizes.viewport, sizes.content);
  const commonProps = {
    ...scrollbarProps,
    sizes,
    onSizesChange: setSizes,
    hasThumb: Boolean(thumbRatio > 0 && thumbRatio < 1),
    onThumbChange: (thumb) => thumbRef.current = thumb,
    onThumbPointerUp: () => pointerOffsetRef.current = 0,
    onThumbPointerDown: (pointerPos) => pointerOffsetRef.current = pointerPos
  };
  function getScrollPosition(pointerPos, dir) {
    return getScrollPositionFromPointer(pointerPos, pointerOffsetRef.current, sizes, dir);
  }
  if (orientation === "horizontal") {
    return /* @__PURE__ */ jsxRuntimeExports.jsx(
      ScrollAreaScrollbarX,
      {
        ...commonProps,
        ref: forwardedRef,
        onThumbPositionChange: () => {
          if (context.viewport && thumbRef.current) {
            const scrollPos = context.viewport.scrollLeft;
            const offset2 = getThumbOffsetFromScroll(scrollPos, sizes, context.dir);
            thumbRef.current.style.transform = `translate3d(${offset2}px, 0, 0)`;
          }
        },
        onWheelScroll: (scrollPos) => {
          if (context.viewport) context.viewport.scrollLeft = scrollPos;
        },
        onDragScroll: (pointerPos) => {
          if (context.viewport) {
            context.viewport.scrollLeft = getScrollPosition(pointerPos, context.dir);
          }
        }
      }
    );
  }
  if (orientation === "vertical") {
    return /* @__PURE__ */ jsxRuntimeExports.jsx(
      ScrollAreaScrollbarY,
      {
        ...commonProps,
        ref: forwardedRef,
        onThumbPositionChange: () => {
          if (context.viewport && thumbRef.current) {
            const scrollPos = context.viewport.scrollTop;
            const offset2 = getThumbOffsetFromScroll(scrollPos, sizes);
            thumbRef.current.style.transform = `translate3d(0, ${offset2}px, 0)`;
          }
        },
        onWheelScroll: (scrollPos) => {
          if (context.viewport) context.viewport.scrollTop = scrollPos;
        },
        onDragScroll: (pointerPos) => {
          if (context.viewport) context.viewport.scrollTop = getScrollPosition(pointerPos);
        }
      }
    );
  }
  return null;
});
var ScrollAreaScrollbarX = reactExports.forwardRef((props, forwardedRef) => {
  const { sizes, onSizesChange, ...scrollbarProps } = props;
  const context = useScrollAreaContext(SCROLLBAR_NAME, props.__scopeScrollArea);
  const [computedStyle, setComputedStyle] = reactExports.useState();
  const ref = reactExports.useRef(null);
  const composeRefs2 = useComposedRefs(forwardedRef, ref, context.onScrollbarXChange);
  reactExports.useEffect(() => {
    if (ref.current) setComputedStyle(getComputedStyle(ref.current));
  }, [ref]);
  return /* @__PURE__ */ jsxRuntimeExports.jsx(
    ScrollAreaScrollbarImpl,
    {
      "data-orientation": "horizontal",
      ...scrollbarProps,
      ref: composeRefs2,
      sizes,
      style: {
        bottom: 0,
        left: context.dir === "rtl" ? "var(--radix-scroll-area-corner-width)" : 0,
        right: context.dir === "ltr" ? "var(--radix-scroll-area-corner-width)" : 0,
        ["--radix-scroll-area-thumb-width"]: getThumbSize(sizes) + "px",
        ...props.style
      },
      onThumbPointerDown: (pointerPos) => props.onThumbPointerDown(pointerPos.x),
      onDragScroll: (pointerPos) => props.onDragScroll(pointerPos.x),
      onWheelScroll: (event, maxScrollPos) => {
        if (context.viewport) {
          const scrollPos = context.viewport.scrollLeft + event.deltaX;
          props.onWheelScroll(scrollPos);
          if (isScrollingWithinScrollbarBounds(scrollPos, maxScrollPos)) {
            event.preventDefault();
          }
        }
      },
      onResize: () => {
        if (ref.current && context.viewport && computedStyle) {
          onSizesChange({
            content: context.viewport.scrollWidth,
            viewport: context.viewport.offsetWidth,
            scrollbar: {
              size: ref.current.clientWidth,
              paddingStart: toInt(computedStyle.paddingLeft),
              paddingEnd: toInt(computedStyle.paddingRight)
            }
          });
        }
      }
    }
  );
});
var ScrollAreaScrollbarY = reactExports.forwardRef((props, forwardedRef) => {
  const { sizes, onSizesChange, ...scrollbarProps } = props;
  const context = useScrollAreaContext(SCROLLBAR_NAME, props.__scopeScrollArea);
  const [computedStyle, setComputedStyle] = reactExports.useState();
  const ref = reactExports.useRef(null);
  const composeRefs2 = useComposedRefs(forwardedRef, ref, context.onScrollbarYChange);
  reactExports.useEffect(() => {
    if (ref.current) setComputedStyle(getComputedStyle(ref.current));
  }, [ref]);
  return /* @__PURE__ */ jsxRuntimeExports.jsx(
    ScrollAreaScrollbarImpl,
    {
      "data-orientation": "vertical",
      ...scrollbarProps,
      ref: composeRefs2,
      sizes,
      style: {
        top: 0,
        right: context.dir === "ltr" ? 0 : void 0,
        left: context.dir === "rtl" ? 0 : void 0,
        bottom: "var(--radix-scroll-area-corner-height)",
        ["--radix-scroll-area-thumb-height"]: getThumbSize(sizes) + "px",
        ...props.style
      },
      onThumbPointerDown: (pointerPos) => props.onThumbPointerDown(pointerPos.y),
      onDragScroll: (pointerPos) => props.onDragScroll(pointerPos.y),
      onWheelScroll: (event, maxScrollPos) => {
        if (context.viewport) {
          const scrollPos = context.viewport.scrollTop + event.deltaY;
          props.onWheelScroll(scrollPos);
          if (isScrollingWithinScrollbarBounds(scrollPos, maxScrollPos)) {
            event.preventDefault();
          }
        }
      },
      onResize: () => {
        if (ref.current && context.viewport && computedStyle) {
          onSizesChange({
            content: context.viewport.scrollHeight,
            viewport: context.viewport.offsetHeight,
            scrollbar: {
              size: ref.current.clientHeight,
              paddingStart: toInt(computedStyle.paddingTop),
              paddingEnd: toInt(computedStyle.paddingBottom)
            }
          });
        }
      }
    }
  );
});
var [ScrollbarProvider, useScrollbarContext] = createScrollAreaContext(SCROLLBAR_NAME);
var ScrollAreaScrollbarImpl = reactExports.forwardRef((props, forwardedRef) => {
  const {
    __scopeScrollArea,
    sizes,
    hasThumb,
    onThumbChange,
    onThumbPointerUp,
    onThumbPointerDown,
    onThumbPositionChange,
    onDragScroll,
    onWheelScroll,
    onResize,
    ...scrollbarProps
  } = props;
  const context = useScrollAreaContext(SCROLLBAR_NAME, __scopeScrollArea);
  const [scrollbar, setScrollbar] = reactExports.useState(null);
  const composeRefs2 = useComposedRefs(forwardedRef, (node2) => setScrollbar(node2));
  const rectRef = reactExports.useRef(null);
  const prevWebkitUserSelectRef = reactExports.useRef("");
  const viewport = context.viewport;
  const maxScrollPos = sizes.content - sizes.viewport;
  const handleWheelScroll = useCallbackRef$1(onWheelScroll);
  const handleThumbPositionChange = useCallbackRef$1(onThumbPositionChange);
  const handleResize = useDebounceCallback(onResize, 10);
  function handleDragScroll(event) {
    if (rectRef.current) {
      const x2 = event.clientX - rectRef.current.left;
      const y2 = event.clientY - rectRef.current.top;
      onDragScroll({ x: x2, y: y2 });
    }
  }
  reactExports.useEffect(() => {
    const handleWheel = (event) => {
      const element = event.target;
      const isScrollbarWheel = scrollbar?.contains(element);
      if (isScrollbarWheel) handleWheelScroll(event, maxScrollPos);
    };
    document.addEventListener("wheel", handleWheel, { passive: false });
    return () => document.removeEventListener("wheel", handleWheel, { passive: false });
  }, [viewport, scrollbar, maxScrollPos, handleWheelScroll]);
  reactExports.useEffect(handleThumbPositionChange, [sizes, handleThumbPositionChange]);
  useResizeObserver(scrollbar, handleResize);
  useResizeObserver(context.content, handleResize);
  return /* @__PURE__ */ jsxRuntimeExports.jsx(
    ScrollbarProvider,
    {
      scope: __scopeScrollArea,
      scrollbar,
      hasThumb,
      onThumbChange: useCallbackRef$1(onThumbChange),
      onThumbPointerUp: useCallbackRef$1(onThumbPointerUp),
      onThumbPositionChange: handleThumbPositionChange,
      onThumbPointerDown: useCallbackRef$1(onThumbPointerDown),
      children: /* @__PURE__ */ jsxRuntimeExports.jsx(
        Primitive.div,
        {
          ...scrollbarProps,
          ref: composeRefs2,
          style: { position: "absolute", ...scrollbarProps.style },
          onPointerDown: composeEventHandlers(props.onPointerDown, (event) => {
            const mainPointer = 0;
            if (event.button === mainPointer) {
              const element = event.target;
              element.setPointerCapture(event.pointerId);
              rectRef.current = scrollbar.getBoundingClientRect();
              prevWebkitUserSelectRef.current = document.body.style.webkitUserSelect;
              document.body.style.webkitUserSelect = "none";
              if (context.viewport) context.viewport.style.scrollBehavior = "auto";
              handleDragScroll(event);
            }
          }),
          onPointerMove: composeEventHandlers(props.onPointerMove, handleDragScroll),
          onPointerUp: composeEventHandlers(props.onPointerUp, (event) => {
            const element = event.target;
            if (element.hasPointerCapture(event.pointerId)) {
              element.releasePointerCapture(event.pointerId);
            }
            document.body.style.webkitUserSelect = prevWebkitUserSelectRef.current;
            if (context.viewport) context.viewport.style.scrollBehavior = "";
            rectRef.current = null;
          })
        }
      )
    }
  );
});
var THUMB_NAME$1 = "ScrollAreaThumb";
var ScrollAreaThumb = reactExports.forwardRef(
  (props, forwardedRef) => {
    const { forceMount, ...thumbProps } = props;
    const scrollbarContext = useScrollbarContext(THUMB_NAME$1, props.__scopeScrollArea);
    return /* @__PURE__ */ jsxRuntimeExports.jsx(Presence, { present: forceMount || scrollbarContext.hasThumb, children: /* @__PURE__ */ jsxRuntimeExports.jsx(ScrollAreaThumbImpl, { ref: forwardedRef, ...thumbProps }) });
  }
);
var ScrollAreaThumbImpl = reactExports.forwardRef(
  (props, forwardedRef) => {
    const { __scopeScrollArea, style: style2, ...thumbProps } = props;
    const scrollAreaContext = useScrollAreaContext(THUMB_NAME$1, __scopeScrollArea);
    const scrollbarContext = useScrollbarContext(THUMB_NAME$1, __scopeScrollArea);
    const { onThumbPositionChange } = scrollbarContext;
    const composedRef = useComposedRefs(
      forwardedRef,
      (node2) => scrollbarContext.onThumbChange(node2)
    );
    const removeUnlinkedScrollListenerRef = reactExports.useRef();
    const debounceScrollEnd = useDebounceCallback(() => {
      if (removeUnlinkedScrollListenerRef.current) {
        removeUnlinkedScrollListenerRef.current();
        removeUnlinkedScrollListenerRef.current = void 0;
      }
    }, 100);
    reactExports.useEffect(() => {
      const viewport = scrollAreaContext.viewport;
      if (viewport) {
        const handleScroll2 = () => {
          debounceScrollEnd();
          if (!removeUnlinkedScrollListenerRef.current) {
            const listener = addUnlinkedScrollListener(viewport, onThumbPositionChange);
            removeUnlinkedScrollListenerRef.current = listener;
            onThumbPositionChange();
          }
        };
        onThumbPositionChange();
        viewport.addEventListener("scroll", handleScroll2);
        return () => viewport.removeEventListener("scroll", handleScroll2);
      }
    }, [scrollAreaContext.viewport, debounceScrollEnd, onThumbPositionChange]);
    return /* @__PURE__ */ jsxRuntimeExports.jsx(
      Primitive.div,
      {
        "data-state": scrollbarContext.hasThumb ? "visible" : "hidden",
        ...thumbProps,
        ref: composedRef,
        style: {
          width: "var(--radix-scroll-area-thumb-width)",
          height: "var(--radix-scroll-area-thumb-height)",
          ...style2
        },
        onPointerDownCapture: composeEventHandlers(props.onPointerDownCapture, (event) => {
          const thumb = event.target;
          const thumbRect = thumb.getBoundingClientRect();
          const x2 = event.clientX - thumbRect.left;
          const y2 = event.clientY - thumbRect.top;
          scrollbarContext.onThumbPointerDown({ x: x2, y: y2 });
        }),
        onPointerUp: composeEventHandlers(props.onPointerUp, scrollbarContext.onThumbPointerUp)
      }
    );
  }
);
ScrollAreaThumb.displayName = THUMB_NAME$1;
var CORNER_NAME = "ScrollAreaCorner";
var ScrollAreaCorner = reactExports.forwardRef(
  (props, forwardedRef) => {
    const context = useScrollAreaContext(CORNER_NAME, props.__scopeScrollArea);
    const hasBothScrollbarsVisible = Boolean(context.scrollbarX && context.scrollbarY);
    const hasCorner = context.type !== "scroll" && hasBothScrollbarsVisible;
    return hasCorner ? /* @__PURE__ */ jsxRuntimeExports.jsx(ScrollAreaCornerImpl, { ...props, ref: forwardedRef }) : null;
  }
);
ScrollAreaCorner.displayName = CORNER_NAME;
var ScrollAreaCornerImpl = reactExports.forwardRef((props, forwardedRef) => {
  const { __scopeScrollArea, ...cornerProps } = props;
  const context = useScrollAreaContext(CORNER_NAME, __scopeScrollArea);
  const [width2, setWidth] = reactExports.useState(0);
  const [height2, setHeight] = reactExports.useState(0);
  const hasSize = Boolean(width2 && height2);
  useResizeObserver(context.scrollbarX, () => {
    const height22 = context.scrollbarX?.offsetHeight || 0;
    context.onCornerHeightChange(height22);
    setHeight(height22);
  });
  useResizeObserver(context.scrollbarY, () => {
    const width22 = context.scrollbarY?.offsetWidth || 0;
    context.onCornerWidthChange(width22);
    setWidth(width22);
  });
  return hasSize ? /* @__PURE__ */ jsxRuntimeExports.jsx(
    Primitive.div,
    {
      ...cornerProps,
      ref: forwardedRef,
      style: {
        width: width2,
        height: height2,
        position: "absolute",
        right: context.dir === "ltr" ? 0 : void 0,
        left: context.dir === "rtl" ? 0 : void 0,
        bottom: 0,
        ...props.style
      }
    }
  ) : null;
});
function toInt(value) {
  return value ? parseInt(value, 10) : 0;
}
function getThumbRatio(viewportSize, contentSize) {
  const ratio = viewportSize / contentSize;
  return isNaN(ratio) ? 0 : ratio;
}
function getThumbSize(sizes) {
  const ratio = getThumbRatio(sizes.viewport, sizes.content);
  const scrollbarPadding = sizes.scrollbar.paddingStart + sizes.scrollbar.paddingEnd;
  const thumbSize = (sizes.scrollbar.size - scrollbarPadding) * ratio;
  return Math.max(thumbSize, 18);
}
function getScrollPositionFromPointer(pointerPos, pointerOffset, sizes, dir = "ltr") {
  const thumbSizePx = getThumbSize(sizes);
  const thumbCenter = thumbSizePx / 2;
  const offset2 = pointerOffset || thumbCenter;
  const thumbOffsetFromEnd = thumbSizePx - offset2;
  const minPointerPos = sizes.scrollbar.paddingStart + offset2;
  const maxPointerPos = sizes.scrollbar.size - sizes.scrollbar.paddingEnd - thumbOffsetFromEnd;
  const maxScrollPos = sizes.content - sizes.viewport;
  const scrollRange = dir === "ltr" ? [0, maxScrollPos] : [maxScrollPos * -1, 0];
  const interpolate2 = linearScale$1([minPointerPos, maxPointerPos], scrollRange);
  return interpolate2(pointerPos);
}
function getThumbOffsetFromScroll(scrollPos, sizes, dir = "ltr") {
  const thumbSizePx = getThumbSize(sizes);
  const scrollbarPadding = sizes.scrollbar.paddingStart + sizes.scrollbar.paddingEnd;
  const scrollbar = sizes.scrollbar.size - scrollbarPadding;
  const maxScrollPos = sizes.content - sizes.viewport;
  const maxThumbPos = scrollbar - thumbSizePx;
  const scrollClampRange = dir === "ltr" ? [0, maxScrollPos] : [maxScrollPos * -1, 0];
  const scrollWithoutMomentum = clamp$2(scrollPos, scrollClampRange);
  const interpolate2 = linearScale$1([0, maxScrollPos], [0, maxThumbPos]);
  return interpolate2(scrollWithoutMomentum);
}
function linearScale$1(input, output) {
  return (value) => {
    if (input[0] === input[1] || output[0] === output[1]) return output[0];
    const ratio = (output[1] - output[0]) / (input[1] - input[0]);
    return output[0] + ratio * (value - input[0]);
  };
}
function isScrollingWithinScrollbarBounds(scrollPos, maxScrollPos) {
  return scrollPos > 0 && scrollPos < maxScrollPos;
}
var addUnlinkedScrollListener = (node2, handler = () => {
}) => {
  let prevPosition = { left: node2.scrollLeft, top: node2.scrollTop };
  let rAF = 0;
  (function loop() {
    const position2 = { left: node2.scrollLeft, top: node2.scrollTop };
    const isHorizontalScroll = prevPosition.left !== position2.left;
    const isVerticalScroll = prevPosition.top !== position2.top;
    if (isHorizontalScroll || isVerticalScroll) handler();
    prevPosition = position2;
    rAF = window.requestAnimationFrame(loop);
  })();
  return () => window.cancelAnimationFrame(rAF);
};
function useDebounceCallback(callback, delay2) {
  const handleCallback = useCallbackRef$1(callback);
  const debounceTimerRef = reactExports.useRef(0);
  reactExports.useEffect(() => () => window.clearTimeout(debounceTimerRef.current), []);
  return reactExports.useCallback(() => {
    window.clearTimeout(debounceTimerRef.current);
    debounceTimerRef.current = window.setTimeout(handleCallback, delay2);
  }, [handleCallback, delay2]);
}
function useResizeObserver(element, onResize) {
  const handleResize = useCallbackRef$1(onResize);
  useLayoutEffect2(() => {
    let rAF = 0;
    if (element) {
      const resizeObserver = new ResizeObserver(() => {
        cancelAnimationFrame(rAF);
        rAF = window.requestAnimationFrame(handleResize);
      });
      resizeObserver.observe(element);
      return () => {
        window.cancelAnimationFrame(rAF);
        resizeObserver.unobserve(element);
      };
    }
  }, [element, handleResize]);
}
function getSubtree(options, content) {
  const { asChild, children } = options;
  if (!asChild) return typeof content === "function" ? content(children) : content;
  const firstChild = reactExports.Children.only(children);
  return reactExports.cloneElement(firstChild, {
    children: typeof content === "function" ? content(firstChild.props.children) : content
  });
}
var Root$3 = ScrollArea$1;
var Viewport = ScrollAreaViewport;
var Corner = ScrollAreaCorner;
const ScrollArea = reactExports.forwardRef(({ className, children, ...props }, ref) => /* @__PURE__ */ jsxRuntimeExports.jsxs(
  Root$3,
  {
    ref,
    className: cn("relative overflow-hidden", className),
    ...props,
    children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx(Viewport, { className: "h-full w-full rounded-[inherit]", children }),
      /* @__PURE__ */ jsxRuntimeExports.jsx(ScrollBar, {}),
      /* @__PURE__ */ jsxRuntimeExports.jsx(Corner, {})
    ]
  }
));
ScrollArea.displayName = Root$3.displayName;
const ScrollBar = reactExports.forwardRef(({ className, orientation = "vertical", ...props }, ref) => /* @__PURE__ */ jsxRuntimeExports.jsx(
  ScrollAreaScrollbar,
  {
    ref,
    orientation,
    className: cn(
      "flex touch-none select-none transition-colors",
      orientation === "vertical" && "h-full w-2.5 border-l border-l-transparent p-[1px]",
      orientation === "horizontal" && "h-2.5 flex-col border-t border-t-transparent p-[1px]",
      className
    ),
    ...props,
    children: /* @__PURE__ */ jsxRuntimeExports.jsx(ScrollAreaThumb, { className: "relative flex-1 rounded-full bg-border" })
  }
));
ScrollBar.displayName = ScrollAreaScrollbar.displayName;
const authEn = {
  // Main auth
  welcome: "Welcome to Radar",
  signIn: "Sign In",
  signUp: "Sign Up",
  email: "Email",
  password: "Password",
  confirmPassword: "Confirm Password",
  fullName: "Full Name",
  phone: "Phone",
  // Auth screens
  signInToAccount: "Sign in to your account",
  createNewAccount: "Create a new account",
  alreadyHaveAccount: "Already have an account?",
  dontHaveAccount: "Don't have an account?",
  welcomeBack: "Welcome back",
  createAccountTitle: "Create an account",
  loginDescription: "Enter your credentials to access your account",
  registerDescription: "Enter your information to create a new account",
  // Social auth
  loginWithGoogle: "Continue with Google",
  orContinueWith: "Or continue with",
  // Form placeholders
  fullNamePlaceholder: "Enter your full name",
  nickname: "Nickname",
  nicknamePlaceholder: "Enter your nickname",
  emailPlaceholder: "Enter your email",
  passwordPlaceholder: "Create a strong password",
  confirmPasswordPlaceholder: "Confirm your password",
  // Auth actions
  forgotPassword: "Forgot password?",
  loginButton: "Sign In",
  registerButton: "Create Account",
  noAccount: "Don't have an account?",
  hasAccount: "Already have an account?",
  // Terms
  termsText: "By clicking continue, you agree to our",
  termsOfService: "Terms of Service",
  and: "and",
  privacyPolicy: "Privacy Policy",
  // Status messages
  accountCreated: "Account Created",
  checkEmail: "Please check your email to verify your account",
  loginSuccess: "Successfully logged in!",
  // Password validation
  passwordMinLength: "Password must be at least 8 characters",
  passwordUppercase: "Password must contain an uppercase letter",
  passwordLowercase: "Password must contain a lowercase letter",
  passwordNumber: "Password must contain a number",
  passwordSpecial: "Password must contain a special character",
  passwordsNotMatch: "Passwords do not match"
};
const navigationEn = {
  home: "Home",
  reports: "Reports",
  community: "Community",
  wanted: "Missing",
  profile: "Profile",
  back: "Back"
};
const communityEn = {
  communityTitle: "Community",
  social: "Social",
  socialFeedTitle: "Social Feed",
  socialFeedDescription: "Twitter-style social feed for RADAR Community",
  socialFeedSubtitle: "Here user posts with categories, likes and comments will be displayed",
  createFirstPost: "Create first post",
  filterByCategory: "Filter by category",
  categoryAll: "All",
  categorySafety: "Safety",
  categoryObservation: "Observation",
  categoryQuestion: "Question",
  categoryDiscussion: "Discussion",
  yourNeighborhood: "Your Neighborhood",
  downtownArea: "Downtown Area",
  neighborhoodChat: "Neighborhood Chat",
  observations: "Observations",
  somethingStrange: "Report Something Unusual",
  quickReport: "Quick Report",
  whatNoticed: "What did you notice?",
  changePhoto: "Change Photo",
  sendAnonymously: "Send Anonymously",
  warn: "Alert Community",
  confirmations: "confirmations",
  confirmed: "Confirmed",
  rejections: "rejections",
  rejected: "Rejected",
  confirmTitle: "Report Confirmed",
  confirmDesc: "Thank you for confirming this report.",
  reportTitle: "Report Submitted",
  reportDesc: "Your report has been submitted to the community.",
  deleteReport: "Delete Report",
  createThread: "Create Thread",
  threadTitle: "Thread Title",
  messages: "messages",
  writeMessage: "Write a message...",
  comments: "Comments",
  writeComment: "Write a comment...",
  anonymously: "Anonymous",
  you: "You",
  unknownUser: "Unknown User"
};
const incidentsEn = {
  // Main screen
  neighborhood: "Neighborhood",
  activity: "Activity",
  quickActions: "Quick Actions",
  reportIncident: "Report Incident",
  viewReports: "View Reports",
  recentActivity: "Recent Activity",
  safetyScore: "Safety Score",
  // Incident types
  typeLabel: "Type",
  dateLabel: "Date",
  other: "Other",
  theft: "Theft",
  assault: "Assault",
  vandalism: "Vandalism",
  suspicious: "Suspicious Activity",
  traffic_accident: "Traffic Accident",
  // Incident status
  incidentPendingDeletion: "This incident will be deleted in 30 minutes due to high rejection rate",
  errorSavingReaction: "Error saving your reaction",
  incidentDeleted: "Incident Deleted",
  incidentDeletedMessage: "The incident has been deleted successfully.",
  // Comments
  addCommentPlaceholder: "Add your comment...",
  postAnonymously: "Post anonymously",
  anonymous: "Anonymous",
  errorAddingComment: "Error adding comment",
  // Historical markers
  historyMarkersEnabled: "Historical Markers",
  historyMarkersEnabledDesc: "Show historical incident markers on the map",
  // Demo incidents for onboarding
  demoIncidents: [
    "0.3 km from you — Armed robbery at Main St. Avoid area.",
    "0.15 km from you — Car accident on Highway 101. Traffic delays.",
    "0.8 km from you — Suspicious activity near Central Park. Stay alert.",
    "0.5 km from you — Fire emergency on Oak Avenue. Emergency services responding."
  ],
  // Severity levels
  low: "Low",
  medium: "Medium",
  high: "High"
};
const wantedEn = {
  // Main
  wantedPersons: "Missing Persons",
  addWantedPerson: "Add Missing Person",
  searchPerson: "Search person...",
  noWantedPersons: "No missing persons reported",
  // Person details
  personName: "Person Name",
  age: "Age",
  years: "years",
  yearsOld: "years old",
  person_age: "{age} years old",
  description: "Description",
  lastSeenLocation: "Last Seen Location",
  lastSeenDate: "Last Seen Date",
  contactInfo: "Contact Information",
  last_seen_location: "Last Seen Location",
  last_seen_date: "Last Seen Date",
  contact_info: "Contact Information",
  // Status
  active: "Missing",
  caught: "Found",
  inactive: "Case Closed",
  wanted_status_active: "Missing",
  wanted_status_caught: "Found",
  wanted_status_inactive: "Case Closed",
  // Photo handling
  noPhotoAvailable: "No Photo Available",
  noPhotoDescription: "No photographs have been uploaded for this person",
  wanted_no_photo: "No Photo Available",
  wanted_no_photo_desc: "No photographs have been uploaded for this person",
  // Meta info
  addedBy: "Added by",
  addedOn: "Added on",
  added_by: "Added by",
  added_on: "Added on",
  // Actions
  personAdded: "Person Added",
  personAddedDesc: "Missing person has been added successfully."
};
const profileEn = {
  // Profile main
  profile: "Profile",
  settings: "Settings",
  preferences: "Preferences",
  // XP System
  level: "Level",
  xp: "XP",
  experience: "Experience",
  howToEarnXP: "How to Earn XP",
  xpGuideTitle: "How to Earn XP and Level Up",
  whatIsXP: "What is XP?",
  xpExplanation: "XP (Experience Points) are points you earn for various actions in the app. By accumulating XP, you level up and gain access to new features.",
  whyLevels: "Why levels?",
  whyLevelsDesc: "A high level shows your activity and reliability in the community. High-level users gain more trust and additional privileges.",
  levelSystem: "Level System",
  howToEarnXPSection: "How to Earn XP",
  badgeSystem: "Badge System",
  badgeSystemDesc: "Badges are rewards for special achievements. They are automatically awarded when certain conditions are met.",
  tipsForProgress: "Tips for Fast Progress",
  dailyActivity: "Daily Activity",
  qualityReports: "Quality Reports",
  communityHelp: "Community Help",
  quickResponse: "Quick Response",
  startNow: "Start Now!",
  startNowDesc: "Every action you take makes the community safer and helps other users. Start by creating your first report and earn your first XP!",
  goodLuck: "Good luck achieving new levels! 🚀",
  maxLevelReached: "🏆 Maximum level reached!",
  tips: "Tip",
  toNextLevel: "to next level",
  // XP Activities
  createReport: "Create Report",
  createReportDesc: "Report an incident or danger in your area",
  createReportTip: "Add detailed description and accurate location",
  addPhoto: "Add Photo to Report",
  addPhotoDesc: "Attach photo or video to your report",
  addPhotoTip: "Photos help other users better understand the situation",
  confirmReport: "Confirm Report",
  confirmReportDesc: "Confirm another user's report if you also saw the incident",
  confirmReportTip: "Only confirm reports you actually witnessed",
  chatParticipation: "Community Chat Participation",
  chatParticipationDesc: "Communicate with other users in community chat",
  chatParticipationTip: "Share useful information and help others",
  quickResponseTitle: "Quick Response",
  quickResponseDesc: "Be the first to respond to an emergency situation",
  quickResponseTip: "Respond quickly to critical situations in your area",
  dailyLogin: "Daily Login",
  dailyLoginDesc: "Log into the app every day",
  dailyLoginTip: "Regular app usage helps stay informed about events",
  profileUpdate: "Profile Update",
  profileUpdateDesc: "Fill out and update your profile information",
  profileUpdateTip: "A complete profile increases trust from other users",
  communityParticipation: "Community Participation",
  communityParticipationDesc: "Actively participate in community life",
  communityParticipationTip: "Help newcomers and share experience",
  // Levels
  observador: "Observer",
  reportero: "Reporter",
  radarCiudadano: "Radar Citizen",
  vigilante: "Vigilante",
  patrullero: "Patroller",
  comandante: "Commander",
  // Badges
  earned: "Earned",
  badgesEarned: "badges earned",
  firstReportBadge: "First Report",
  firstReportCondition: "Create your first report",
  dangerHunterBadge: "Danger Hunter",
  dangerHunterCondition: "Report 3 incidents",
  urbanExplorerBadge: "Urban Explorer",
  urbanExplorerCondition: "Reports from 3+ different areas",
  communityVoiceBadge: "Community Voice",
  communityVoiceCondition: "Get 10+ confirmations",
  visualEyeBadge: "Visual Eye",
  visualEyeCondition: "Add 5+ photos/videos",
  localProtectorBadge: "Local Protector",
  localProtectorCondition: "Be first on scene",
  consistentBadge: "Consistent",
  consistentCondition: "7 days activity streak",
  advisorBadge: "Advisor",
  advisorCondition: "Approved suggestion",
  radarEliteBadge: "Radar Elite",
  radarEliteCondition: "Reach Commander level",
  // Radar Pro
  premiumSubscription: "Premium Subscription",
  upgradeToRadarPro: "Upgrade to Radar Pro",
  radarProDesc: "Unlock advanced safety features and premium tools",
  radarProFeatures: "Premium Features",
  trafficAlerts: "Real-time Traffic Alerts",
  trafficAlertsDesc: "Get push notifications about traffic jams ahead on your route",
  advancedHeatmap: "Advanced Incident Heatmap",
  advancedHeatmapDesc: "Visual incident density map with vibration alerts",
  smartNotifications: "Smart AI Notifications",
  smartNotificationsDesc: "Intelligent alerts based on your location and movement",
  communityFeatures: "Extended Community Features",
  communityFeaturesDesc: "Advanced community chat, threads and reporting tools",
  adminTools: "Administrative Tools",
  adminToolsDesc: "User management, content moderation and analytics panel",
  multiLanguage: "Multi-language Support",
  multiLanguageDesc: "Full support for English, Spanish and Russian",
  premiumSupport: "24/7 Premium Support",
  premiumSupportDesc: "Priority customer support and technical assistance",
  noAds: "No Ads",
  noAdsDesc: "Enjoy the app without ads and interruptions",
  subscribeNow: "Subscribe Now",
  monthlyPrice: "$4.99/month",
  yearlyPrice: "$49.99/year",
  freeTrial: "7 days free",
  // Username
  username: "Username",
  usernameEdit: "Edit Username",
  usernameEditTitle: "Change Username",
  usernameEditDescription: "Choose a unique username (3-20 characters, letters, numbers, underscore only)",
  usernameLabel: "Username",
  usernamePlaceholder: "Enter username...",
  usernameAlreadyTaken: "Username already taken. Please choose another.",
  usernameInvalid: "Invalid username format. Use letters, numbers, and underscore only.",
  usernameUpdated: "Username updated successfully!",
  usernameSave: "Save",
  usernameCancel: "Cancel",
  noBioYet: "No bio added yet...",
  // Statistics
  statistics: "Statistics",
  days: "days",
  reports: "Reports",
  // Notification settings
  nearbyIncidents: "Nearby Incidents",
  nearbyIncidentsDesc: "Get alerts when security incidents are reported near your location",
  emergencySituations: "Emergency Situations",
  emergencySituationsDesc: "Receive critical emergency notifications and official warnings",
  updates: "App Updates",
  updatesDesc: "Get notifications about app updates and system maintenance",
  // Notification settings integration
  notificationSettingsDesc: "Configure detailed notification preferences by categories",
  // Permission status
  permissionStatus: "Permission Status",
  geolocationPermission: "Location Access",
  geolocationActive: "Active",
  geolocationInactive: "Not Active",
  geolocationDesc: "Required for incident alerts and safety features",
  geolocationGranted: "Location access granted",
  geolocationDenied: "Location access denied",
  geolocationMessage: "Location access is required for safety features",
  geolocationError: "Error requesting location access",
  geolocationUnavailable: "Location services unavailable",
  pushNotificationPermission: "Push Notifications",
  pushNotificationActive: "Active",
  pushNotificationInactive: "Not Active",
  pushNotificationDesc: "Required to receive safety alerts and updates",
  pushNotificationGranted: "Push notifications enabled",
  pushNotificationDenied: "Push notifications disabled",
  pushNotificationMessage: "Push notifications are required for safety alerts",
  pushNotificationError: "Error requesting notification permission",
  // Notification types
  notificationTypes: "Notification Types",
  errorTitle: "Error",
  // Location settings
  location: "Location",
  // Notifications section
  notifications: "Notifications",
  // Missing translations
  logoutSuccess: "Logout Successful",
  logoutMessage: "You have been logged out successfully",
  logoutError: "Error during logout",
  settingsUpdated: "Settings Updated",
  notificationsEnabled: "Notifications enabled",
  notificationsDisabled: "Notifications disabled",
  meters: "meters",
  cacheCleared: "Cache Cleared",
  cacheCleanedDesc: "Application cache has been cleared successfully"
};
const notificationsEn = {
  // Notification Center
  notifications: "Notifications",
  noNotifications: "No notifications",
  markAllAsRead: "Mark all as read",
  deleteAll: "Delete all",
  // Tabs
  all: "All",
  unread: "Unread",
  archive: "Archive",
  // Empty states
  empty: {
    all: "No notifications yet",
    unread: "No unread notifications",
    archive: "No archived notifications"
  },
  // Notification Settings
  notificationSettings: "Notification Settings",
  // Proximity Notifications Group
  proximityNotifications: "Safety & Incidents",
  proximityNotificationsDesc: "Notifications about nearby incidents, emergency alerts and activity",
  incidentNearby: "Incidents Nearby",
  incidentNearbyDesc: "Alert when dangerous incidents are reported near you",
  friendNearby: "Friends Nearby",
  friendNearbyDesc: "Notify when friends are in your vicinity",
  areaActivity: "Area Activity",
  areaActivityDesc: "Updates about high incident activity in your area",
  // Admin Notifications Group
  adminNotifications: "Administration",
  adminNotificationsDesc: "System and administrative notifications",
  adminAction: "Admin Actions",
  adminActionDesc: "Notifications about administrative actions and updates",
  emergencyAlert: "Emergency Alerts",
  emergencyAlertDesc: "Critical emergency notifications and warnings",
  // Social Notifications Group
  socialNotifications: "Social & Community",
  socialNotificationsDesc: "Notifications about friends and community interactions",
  friendRequest: "Friend Requests",
  friendRequestDesc: "Notifications when someone sends you a friend request",
  messageReceived: "Messages Received",
  messageReceivedDesc: "Notifications when you receive a new message",
  // Notification Types
  dangerZoneEntry: "Danger Zone Entry",
  friendLocationUpdate: "Friend Location Update",
  incidentReport: "Incident Report",
  systemUpdate: "System Update",
  emergencyBroadcast: "Emergency Broadcast",
  // Push Notification Messages
  incidentNearbyMessage: "Incident reported near your location. Stay alert.",
  friendNearbyMessage: "{friendName} is nearby",
  emergencyMessage: "Emergency alert in your area. Check the app for details.",
  // Actions
  viewDetails: "View Details",
  dismiss: "Dismiss",
  openMap: "Open Map",
  // Status
  delivered: "Delivered",
  read: "Read",
  // Time
  justNow: "Just now",
  minutesAgo: "{minutes}m ago",
  hoursAgo: "{hours}h ago",
  daysAgo: "{days}d ago",
  // Settings Status
  enabled: "Enabled",
  disabled: "Disabled",
  settingsUpdated: "Settings Updated",
  settingsSaved: "Notification settings saved successfully",
  settingsError: "Failed to update notification settings",
  // Danger Zone notifications - UNIFIED SIMPLIFIED MESSAGES
  dangerZone: {
    // Simplified unified titles
    insideTitle: "Zone Alert",
    nearTitle: "Zone Alert",
    exitTitle: "Safety Update",
    // Simplified unified messages with call-to-action
    insideMessage: "You are inside a risk zone. Open RADAR to see more information and decide your next step.",
    nearMessage: "You are near a risk zone. Open RADAR for more details and stay aware.",
    exitMessage: "You have left the risk zone. Stay safe and keep RADAR open for continued monitoring.",
    // Call to action text
    callToAction: "Open RADAR for details"
  },
  // UNIFIED NOTIFICATION MESSAGES FOR ALL TYPES
  unified: {
    // Incident notifications
    incidentNearby: {
      title: "Security Alert",
      message: "An incident has been reported in your area. Open RADAR to stay informed and take precautions.",
      callToAction: "Open RADAR for details"
    },
    // Friend notifications  
    friendRequest: {
      title: "Friend Request",
      message: "Someone wants to connect with you on RADAR. Open the app to accept or decline.",
      callToAction: "Open RADAR to respond"
    },
    friendAccepted: {
      title: "Friend Added",
      message: "You have a new friend on RADAR. Open the app to see their updates.",
      callToAction: "Open RADAR to view"
    },
    // Community notifications
    communityPost: {
      title: "Community Update",
      message: "There's new activity in your community. Open RADAR to see what's happening.",
      callToAction: "Open RADAR to view"
    },
    communityComment: {
      title: "New Comment",
      message: "Someone commented on community content. Open RADAR to join the conversation.",
      callToAction: "Open RADAR to reply"
    },
    // Emergency notifications
    emergency: {
      title: "Emergency Alert",
      message: "Emergency services are active in your area. Open RADAR for safety information.",
      callToAction: "Open RADAR immediately"
    },
    // Traffic notifications
    traffic: {
      title: "Traffic Update",
      message: "Traffic conditions have changed on your route. Open RADAR for current information.",
      callToAction: "Open RADAR for routes"
    },
    // Admin notifications
    admin: {
      title: "System Update",
      message: "There's an important update from RADAR administration. Open the app to learn more.",
      callToAction: "Open RADAR for info"
    },
    // Wanted person notifications
    wantedPerson: {
      title: "Person Alert",
      message: "A person of interest has been reported in your area. Open RADAR for safety information.",
      callToAction: "Open RADAR for details"
    },
    // System notifications
    system: {
      title: "RADAR Update",
      message: "There's a system update or maintenance notice. Open RADAR for more information.",
      callToAction: "Open RADAR for info"
    }
  }
};
const friendsEn = {
  // Header
  title: "Friends",
  addFriend: "Add Friend",
  search: "Search",
  // Tabs
  allFriends: "All Friends",
  requests: "Requests",
  suggestions: "Suggestions",
  blocked: "Blocked",
  // Stats
  friendsCount: (count2) => `${count2} friends`,
  mutualFriends: (count2) => `${count2} mutual friends`,
  // Status
  online: "Online",
  offline: "Offline",
  lastSeen: (time2) => `Last seen ${time2}`,
  // Actions
  accept: "Accept",
  decline: "Decline",
  cancel: "Cancel",
  remove: "Remove",
  removeFriend: "Remove Friend",
  block: "Block",
  unblock: "Unblock",
  sendRequest: "Send Request",
  requestSent: "Request Sent",
  cancelRequest: "Cancel Request",
  viewProfile: "View Profile",
  // Search & User Menu
  searchUsers: "Search users...",
  searchPlaceholder: "Search by username or name...",
  noSearchResults: "No users found",
  userMenu: "User Menu",
  sendMessage: "Send Message",
  // Friend Request
  friendRequest: "Friend Request",
  requestReceived: "Request Received",
  addFriendMessage: "Add a message (optional)",
  sendFriendRequest: "Send Friend Request",
  // Messages
  friendRequestSent: "Friend request sent",
  friendRequestAccepted: "Friend request accepted",
  friendRequestDeclined: "Friend request declined",
  friendRequestCanceled: "Friend request canceled",
  friendRemoved: "Friend removed",
  userBlocked: "User blocked",
  userUnblocked: "User unblocked",
  // Empty states
  noFriends: "No friends yet",
  noRequests: "No friend requests",
  noSuggestions: "No suggestions",
  noBlocked: "No blocked users",
  // Notifications
  notifications: {
    friendRequest: (name) => `${name} sent you a friend request`,
    friendAccepted: (name) => `${name} accepted your friend request`,
    friendDeclined: (name) => `${name} declined your friend request`
  },
  // Errors
  errors: {
    loadFailed: "Failed to load friends",
    requestFailed: "Failed to send friend request",
    actionFailed: "Action failed. Please try again.",
    userNotFound: "User not found",
    alreadyFriends: "Already friends with this user",
    cannotAddSelf: "Cannot add yourself as a friend"
  },
  // Confirmation
  confirmations: {
    removeFriend: "Are you sure you want to remove this friend?",
    blockUser: "Are you sure you want to block this user?",
    unblockUser: "Are you sure you want to unblock this user?"
  }
};
const commonEn = {
  // App info
  appName: "RADAR",
  tagline: "Community Safety Network",
  loadingText: "Initializing security system...",
  // Common actions
  loading: "Loading...",
  saving: "Saving...",
  save: "Save",
  cancel: "Cancel",
  delete: "Delete",
  edit: "Edit",
  create: "Create",
  update: "Update",
  confirm: "Confirm",
  reject: "Reject",
  send: "Send",
  submit: "Submit",
  continue: "Continue",
  next: "Next",
  previous: "Previous",
  finish: "Finish",
  close: "Close",
  open: "Open",
  reportIncident: "Report Incident",
  settings: "Settings",
  toggleDangerZones_title: "Toggle Danger Zones",
  // Common labels
  name: "Name",
  title: "Title",
  description: "Description",
  location: "Location",
  date: "Date",
  time: "Time",
  status: "Status",
  type: "Type",
  category: "Category",
  // Status indicators
  active: "Active",
  inactive: "Inactive",
  pending: "Pending",
  approved: "Approved",
  rejected: "Rejected",
  completed: "Completed",
  // Common messages
  success: "Success",
  error: "Error",
  warning: "Warning",
  info: "Information",
  // Time and dates
  today: "Today",
  yesterday: "Yesterday",
  tomorrow: "Tomorrow",
  now: "Now",
  recently: "Recently",
  // Measurements
  km: "km",
  meters: "m",
  minutes: "minutes",
  hours: "hours",
  days: "days",
  // Numbers
  zero: "zero",
  one: "one",
  two: "two",
  few: "few",
  many: "many",
  other: "other",
  // Navigation
  map: "Map",
  community: "Community",
  notifications: "Notifications",
  report: "Report",
  wanted: "Wanted",
  profile: "Profile",
  // Filters
  filters: "Filters"
};
const errorsEn = {
  // Generic errors
  error: "Error",
  errorOccurred: "An error occurred",
  tryAgain: "Try again",
  somethingWentWrong: "Something went wrong",
  // Network errors
  networkError: "Network error",
  connectionLost: "Connection lost",
  serverError: "Server error",
  // Permission errors
  permissionDenied: "Permission denied",
  locationPermissionDenied: "Location permission denied",
  notificationPermissionDenied: "Notification permission denied",
  // Validation errors
  fieldRequired: "This field is required",
  invalidEmail: "Invalid email address",
  invalidPassword: "Invalid password",
  passwordTooShort: "Password too short",
  // Specific feature errors
  errorSavingReport: "Error saving report",
  errorLoadingData: "Error loading data",
  errorUploadingPhoto: "Error uploading photo",
  errorSendingMessage: "Error sending message"
};
const onboarding$1 = {
  // Steps
  stepLocation: "Location Access",
  stepNotifications: "Notifications",
  stepWelcome: "Welcome",
  // Location Screen
  locationTitle: "Enable Location Access",
  locationDescription: "To receive alerts about incidents near you and ensure accurate safety updates in real time.",
  locationButton: "Allow Location",
  // Notifications Screen  
  notificationsTitle: "Enable Notifications",
  notificationsDescription: "Stay informed instantly about important incidents, community updates, and emergency alerts.",
  notificationsButton: "Enable Notifications",
  // Welcome Screen
  welcomeTitle: "Welcome to RADAR",
  welcomeDescription: "Your safety is in your hands. You're ready to receive real-time alerts and join your community.",
  welcomeButton: "Get Started",
  // Navigation
  skip: "Skip",
  later: "Maybe Later",
  // Progress
  stepProgress: "Step {{current}} of {{total}}",
  // Success Messages
  locationSuccess: "✓ Location detected and geolocation is active!",
  notificationsSuccess: "✓ Notifications enabled! You'll receive real-time safety alerts."
};
const en = {
  auth: authEn,
  navigation: navigationEn,
  community: communityEn,
  incidents: incidentsEn,
  wanted: wantedEn,
  profile: profileEn,
  notifications: notificationsEn,
  friends: friendsEn,
  common: commonEn,
  errors: errorsEn,
  onboarding: onboarding$1
};
const auth$1 = {
  signIn: {
    title: "Iniciar sesión",
    withGoogle: "Iniciar sesión con Google",
    withEmail: "Iniciar sesión con Email",
    noAccount: "¿No tienes cuenta?",
    createAccount: "Crear cuenta"
  },
  signUp: {
    title: "Registrarse",
    withGoogle: "Registrarse con Google",
    withEmail: "Registrarse con Email",
    haveAccount: "¿Ya tienes cuenta?",
    signIn: "Iniciar sesión"
  },
  form: {
    email: "Email",
    password: "Contraseña",
    confirmPassword: "Confirmar contraseña",
    submit: "Enviar",
    forgotPassword: "¿Olvidaste tu contraseña?",
    username: "Usuario",
    usernamePlaceholder: "Ingresa su usuario"
  },
  errors: {
    invalidEmail: "Email inválido",
    passwordTooShort: "La contraseña debe tener al menos 6 caracteres",
    passwordsDontMatch: "Las contraseñas no coinciden",
    emailInUse: "Este email ya está en uso",
    invalidCredentials: "Email o contraseña incorrectos",
    userNotFound: "Usuario no encontrado",
    weakPassword: "Contraseña demasiado débil",
    unknown: "Ha ocurrido un error desconocido"
  },
  resetPassword: {
    title: "Restablecer contraseña",
    description: "Ingresa tu email para recibir instrucciones",
    success: "Se han enviado las instrucciones a tu email",
    button: "Enviar instrucciones"
  },
  verification: {
    emailSent: "Se ha enviado un email de verificación",
    checkEmail: "Por favor, revisa tu email",
    resend: "Reenviar"
  }
};
const navigation$1 = {
  home: "Inicio",
  map: "Mapa",
  community: "Comunidad",
  profile: "Perfil",
  settings: "Ajustes"
};
const community$1 = {
  title: "Comunidad",
  social: "Social",
  socialFeedTitle: "Feed Social",
  socialFeedDescription: "Feed social estilo Twitter para RADAR Community",
  socialFeedSubtitle: "Aquí se mostrarán publicaciones de usuarios con categorías, likes y comentarios",
  createFirstPost: "Crear primera publicación",
  filterByCategory: "Filtrar por categoría",
  categoryAll: "Todos",
  categorySafety: "Seguridad",
  categoryObservation: "Observación",
  categoryQuestion: "Pregunta",
  categoryDiscussion: "Discusión",
  chat: {
    placeholder: "Escribe un mensaje...",
    send: "Enviar",
    loading: "Cargando mensajes...",
    error: "Error al cargar mensajes",
    empty: "No hay mensajes"
  },
  thread: {
    create: "Crear tema",
    reply: "Responder",
    delete: "Eliminar",
    edit: "Editar",
    report: "Reportar",
    anonymous: "Anónimo"
  },
  moderation: {
    report: "Reporte enviado",
    block: "Bloquear usuario",
    unblock: "Desbloquear usuario",
    delete: "Eliminar mensaje",
    warn: "Advertir usuario"
  },
  notifications: {
    newMessage: "Nuevo mensaje",
    newThread: "Nuevo tema",
    mention: "Te han mencionado",
    reply: "Respuesta a tu mensaje"
  }
};
const incidents = {
  title: "Incidentes",
  create: {
    title: "Reportar incidente",
    location: "Ubicación",
    description: "Descripción",
    type: "Tipo",
    severity: "Severidad",
    submit: "Enviar reporte"
  },
  types: {
    accident: "Accidente",
    crime: "Crimen",
    fire: "Incendio",
    medical: "Emergencia médica",
    other: "Otro"
  },
  severity: {
    low: "Baja",
    medium: "Media",
    high: "Alta",
    critical: "Crítica"
  },
  status: {
    active: "Activo",
    resolved: "Resuelto",
    pending: "Pendiente",
    investigating: "Investigando"
  },
  actions: {
    report: "Reportar",
    update: "Actualizar",
    resolve: "Resolver",
    delete: "Eliminar",
    share: "Compartir"
  },
  filters: {
    all: "Todos",
    nearby: "Cercanos",
    recent: "Recientes",
    resolved: "Resueltos"
  },
  notifications: {
    new: "Nuevo incidente reportado",
    update: "Incidente actualizado",
    resolved: "Incidente resuelto"
  },
  validation: {
    locationRequired: "Ubicación requerida",
    descriptionRequired: "Descripción requerida",
    typeRequired: "Tipo requerido"
  }
};
const wanted = {
  title: "Personas Buscadas",
  create: {
    title: "Reportar Persona Buscada",
    description: "Descripción",
    lastSeen: "Visto por última vez",
    submit: "Enviar Reporte"
  },
  status: {
    active: "Activo",
    found: "Encontrado",
    investigating: "Investigando",
    closed: "Cerrado"
  },
  filters: {
    all: "Todos",
    active: "Activos",
    recent: "Recientes",
    resolved: "Resueltos"
  },
  actions: {
    report: "Reportar",
    update: "Actualizar",
    resolve: "Resolver",
    delete: "Eliminar",
    share: "Compartir"
  },
  notifications: {
    new: "Nueva persona buscada reportada",
    update: "Reporte actualizado",
    found: "Persona encontrada"
  },
  validation: {
    descriptionRequired: "Descripción requerida",
    lastSeenRequired: "Última vez visto requerido",
    photoRequired: "Foto requerida"
  },
  details: {
    age: "Edad",
    height: "Altura",
    weight: "Peso",
    characteristics: "Características",
    clothing: "Vestimenta",
    contacts: "Contactos"
  }
};
const profileEs = {
  // Profile main
  profile: "Perfil",
  settings: "Configuración",
  preferences: "Preferencias",
  // XP System
  level: "Nivel",
  xp: "XP",
  experience: "Experiencia",
  howToEarnXP: "Cómo Ganar XP",
  xpGuideTitle: "Cómo Ganar XP y Subir de Nivel",
  whatIsXP: "¿Qué es XP?",
  xpExplanation: "XP (Puntos de Experiencia) son puntos que ganas por varias acciones en la app. Al acumular XP, subes de nivel y obtienes acceso a nuevas funciones.",
  whyLevels: "¿Por qué niveles?",
  whyLevelsDesc: "Un nivel alto muestra tu actividad y confiabilidad en la comunidad. Los usuarios de alto nivel obtienen más confianza y privilegios adicionales.",
  levelSystem: "Sistema de Niveles",
  howToEarnXPSection: "Cómo Ganar XP",
  // Profile editing
  editProfile: "Editar Perfil",
  editUsername: "Editar Nombre de Usuario",
  usernameEdit: "Editar",
  usernameUpdate: "Actualizar Nombre de Usuario",
  usernameSave: "Guardar",
  usernameCancel: "Cancelar",
  noBioYet: "Aún no se agregó biografía...",
  // Statistics
  statistics: "Estadísticas",
  days: "días",
  reports: "Reportes",
  // Notification settings
  nearbyIncidents: "Incidentes Cercanos",
  nearbyIncidentsDesc: "Recibir alertas cuando se reporten incidentes de seguridad cerca de tu ubicación",
  emergencySituations: "Situaciones de Emergencia",
  emergencySituationsDesc: "Recibir notificaciones críticas de emergencia y advertencias oficiales",
  updates: "Actualizaciones de la App",
  updatesDesc: "Recibir notificaciones sobre actualizaciones de la app y mantenimiento del sistema",
  // Notification settings integration
  notificationSettingsDesc: "Configurar preferencias detalladas de notificaciones por categorías",
  // Permission status
  permissionStatus: "Estado de Permisos",
  geolocationPermission: "Acceso a Ubicación",
  geolocationActive: "Activo",
  geolocationInactive: "No Activo",
  geolocationDesc: "Requerido para alertas de incidentes y funciones de seguridad",
  geolocationGranted: "Acceso a ubicación concedido",
  geolocationDenied: "Acceso a ubicación denegado",
  geolocationMessage: "El acceso a ubicación es requerido para las funciones de seguridad",
  geolocationError: "Error al solicitar acceso a ubicación",
  geolocationUnavailable: "Servicios de ubicación no disponibles",
  pushNotificationPermission: "Notificaciones Push",
  pushNotificationActive: "Activo",
  pushNotificationInactive: "No Activo",
  pushNotificationDesc: "Requerido para recibir alertas de seguridad y actualizaciones",
  pushNotificationGranted: "Notificaciones push habilitadas",
  pushNotificationDenied: "Notificaciones push deshabilitadas",
  pushNotificationMessage: "Las notificaciones push son requeridas para alertas de seguridad",
  pushNotificationError: "Error al solicitar permiso de notificación",
  // Notification types
  notificationTypes: "Tipos de Notificaciones",
  errorTitle: "Error",
  // Location settings
  location: "Ubicación",
  // Notifications section
  notifications: "Notificaciones",
  smartNotifications: "Notificaciones Inteligentes",
  // Missing translations
  logoutSuccess: "Cierre de Sesión Exitoso",
  logoutMessage: "Has cerrado sesión exitosamente",
  logoutError: "Error durante el cierre de sesión",
  settingsUpdated: "Configuración Actualizada",
  notificationsEnabled: "Notificaciones habilitadas",
  notificationsDisabled: "Notificaciones deshabilitadas",
  meters: "metros",
  cacheCleared: "Caché Limpiado",
  cacheCleanedDesc: "El caché de la aplicación ha sido limpiado exitosamente"
};
const notificationsEs = {
  // Actions
  viewDetails: "Ver Detalles",
  dismiss: "Descartar",
  openMap: "Abrir Mapa",
  // Notification Center
  notifications: "Notificaciones",
  noNotifications: "No hay notificaciones",
  markAllAsRead: "Marcar todas como leídas",
  deleteAll: "Eliminar todas",
  // Tabs
  all: "Todas",
  unread: "Sin leer",
  archive: "Archivo",
  // Empty states
  empty: {
    all: "No hay notificaciones aún",
    unread: "No hay notificaciones sin leer",
    archive: "No hay notificaciones archivadas"
  },
  // Notification Settings
  notificationSettings: "Configuración de Notificaciones",
  // Proximity Notifications Group
  proximityNotifications: "Seguridad e Incidentes",
  proximityNotificationsDesc: "Notificaciones sobre incidentes cercanos, alertas de emergencia y actividad",
  incidentNearby: "Incidentes Cercanos",
  incidentNearbyDesc: "Alertar cuando se reporten incidentes peligrosos cerca de ti",
  friendNearby: "Amigos Cercanos",
  friendNearbyDesc: "Notificar cuando amigos estén en tu proximidad",
  areaActivity: "Actividad del Área",
  areaActivityDesc: "Actualizaciones sobre alta actividad de incidentes en tu área",
  // Admin Notifications Group
  adminNotifications: "Administración",
  adminNotificationsDesc: "Notificaciones del sistema y administrativas",
  adminAction: "Acciones de Admin",
  adminActionDesc: "Notificaciones sobre acciones administrativas y actualizaciones",
  emergencyAlert: "Alertas de Emergencia",
  emergencyAlertDesc: "Notificaciones críticas de emergencia y advertencias",
  // Social Notifications Group  
  socialNotifications: "Social y Comunidad",
  socialNotificationsDesc: "Notificaciones sobre amigos e interacciones de la comunidad",
  friendRequest: "Solicitudes de Amistad",
  friendRequestDesc: "Notificaciones cuando alguien te envía una solicitud de amistad",
  messageReceived: "Mensajes Recibidos",
  messageReceivedDesc: "Notificaciones cuando recibes un nuevo mensaje",
  // Notification Types
  dangerZoneEntry: "Entrada a Zona Peligrosa",
  friendLocationUpdate: "Actualización de Ubicación de Amigo",
  incidentReport: "Reporte de Incidente",
  systemUpdate: "Actualización del Sistema",
  emergencyBroadcast: "Transmisión de Emergencia",
  // Push Notification Messages
  incidentNearbyMessage: "Incidente reportado cerca de tu ubicación. Mantente alerta.",
  friendNearbyMessage: "{friendName} está cerca",
  emergencyMessage: "Alerta de emergencia en tu área. Revisa la app para más detalles.",
  // Status
  delivered: "Entregada",
  read: "Leída",
  // Time
  justNow: "Ahora mismo",
  minutesAgo: "Hace {minutes}m",
  hoursAgo: "Hace {hours}h",
  daysAgo: "Hace {days}d",
  // Settings Status
  enabled: "Habilitado",
  disabled: "Deshabilitado",
  settingsUpdated: "Configuración Actualizada",
  settingsSaved: "Configuración de notificaciones guardada exitosamente",
  settingsError: "Error al actualizar la configuración de notificaciones",
  // Danger Zone notifications - UNIFIED SIMPLIFIED MESSAGES
  dangerZone: {
    // Simplified unified titles
    insideTitle: "Alerta de Zona",
    nearTitle: "Alerta de Zona",
    exitTitle: "Actualización de Seguridad",
    // Simplified unified messages with call-to-action
    insideMessage: "Te encuentras dentro de una zona de riesgo. Abre RADAR para ver más información y tomar decisiones.",
    nearMessage: "Estás cerca de una zona de riesgo. Abre RADAR para ver más detalles y tomar precauciones.",
    exitMessage: "Has salido de la zona de riesgo. Mantente seguro y mantén RADAR abierto para monitoreo continuo.",
    // Call to action text
    callToAction: "Abrir RADAR para detalles"
  },
  // UNIFIED NOTIFICATION MESSAGES FOR ALL TYPES
  unified: {
    // Incident notifications
    incidentNearby: {
      title: "Alerta de Seguridad",
      message: "Se ha reportado un incidente en tu área. Abre RADAR para mantenerte informado y tomar precauciones.",
      callToAction: "Abrir RADAR para detalles"
    },
    // Friend notifications  
    friendRequest: {
      title: "Solicitud de Amistad",
      message: "Alguien quiere conectar contigo en RADAR. Abre la app para aceptar o rechazar.",
      callToAction: "Abrir RADAR para responder"
    },
    friendAccepted: {
      title: "Amigo Agregado",
      message: "Tienes un nuevo amigo en RADAR. Abre la app para ver sus actualizaciones.",
      callToAction: "Abrir RADAR para ver"
    },
    // Community notifications
    communityPost: {
      title: "Actualización de Comunidad",
      message: "Hay nueva actividad en tu comunidad. Abre RADAR para ver qué está pasando.",
      callToAction: "Abrir RADAR para ver"
    },
    communityComment: {
      title: "Nuevo Comentario",
      message: "Alguien comentó en contenido de la comunidad. Abre RADAR para unirte a la conversación.",
      callToAction: "Abrir RADAR para responder"
    },
    // Emergency notifications
    emergency: {
      title: "Alerta de Emergencia",
      message: "Los servicios de emergencia están activos en tu área. Abre RADAR para información de seguridad.",
      callToAction: "Abrir RADAR inmediatamente"
    },
    // Traffic notifications
    traffic: {
      title: "Actualización de Tráfico",
      message: "Las condiciones del tráfico han cambiado en tu ruta. Abre RADAR para información actual.",
      callToAction: "Abrir RADAR para rutas"
    },
    // Admin notifications
    admin: {
      title: "Actualización del Sistema",
      message: "Hay una actualización importante de la administración de RADAR. Abre la app para obtener más información.",
      callToAction: "Abrir RADAR para info"
    },
    // Wanted person notifications
    wantedPerson: {
      title: "Alerta de Persona",
      message: "Se ha reportado una persona de interés en tu área. Abre RADAR para información de seguridad.",
      callToAction: "Abrir RADAR para detalles"
    },
    // System notifications
    system: {
      title: "Actualización de RADAR",
      message: "Hay una actualización del sistema o aviso de mantenimiento. Abre RADAR para más información.",
      callToAction: "Abrir RADAR para info"
    }
  }
};
const friendsEs = {
  // Header
  title: "Amigos",
  addFriend: "Agregar Amigo",
  search: "Buscar",
  // Tabs
  allFriends: "Amigos",
  requests: "Solicitudes",
  suggestions: "Sugerencias",
  blocked: "Bloqueados",
  // Stats
  friendsCount: (count2) => `${count2} amigos`,
  mutualFriends: (count2) => `${count2} amigos en común`,
  // Status
  online: "En línea",
  offline: "Desconectado",
  lastSeen: (time2) => `Visto por última vez ${time2}`,
  // Actions
  accept: "Aceptar",
  decline: "Rechazar",
  cancel: "Cancelar",
  remove: "Eliminar",
  removeFriend: "Eliminar Amigo",
  block: "Bloquear",
  unblock: "Desbloquear",
  sendRequest: "Enviar Solicitud",
  requestSent: "Solicitud Enviada",
  cancelRequest: "Cancelar Solicitud",
  viewProfile: "Ver Perfil",
  // Search & User Menu
  searchUsers: "Buscar usuarios...",
  searchPlaceholder: "Buscar por nombre de usuario o nombre...",
  noSearchResults: "No se encontraron usuarios",
  userMenu: "Menú de Usuario",
  sendMessage: "Enviar Mensaje",
  // Friend Request
  friendRequest: "Solicitud de Amistad",
  requestReceived: "Solicitud Recibida",
  addFriendMessage: "Agregar un mensaje (opcional)",
  sendFriendRequest: "Enviar Solicitud de Amistad",
  // Messages
  friendRequestSent: "Solicitud de amistad enviada",
  friendRequestAccepted: "Solicitud de amistad aceptada",
  friendRequestDeclined: "Solicitud de amistad rechazada",
  friendRequestCanceled: "Solicitud de amistad cancelada",
  friendRemoved: "Amigo eliminado",
  userBlocked: "Usuario bloqueado",
  userUnblocked: "Usuario desbloqueado",
  // Empty states
  noFriends: "Aún no tienes amigos",
  noRequests: "No hay solicitudes de amistad",
  noSuggestions: "No hay sugerencias",
  noBlocked: "No hay usuarios bloqueados",
  // Notifications
  notifications: {
    friendRequest: (name) => `${name} te envió una solicitud de amistad`,
    friendAccepted: (name) => `${name} aceptó tu solicitud de amistad`,
    friendDeclined: (name) => `${name} rechazó tu solicitud de amistad`
  },
  // Errors
  errors: {
    loadFailed: "Error al cargar amigos",
    requestFailed: "Error al enviar solicitud de amistad",
    actionFailed: "Acción fallida. Inténtalo de nuevo.",
    userNotFound: "Usuario no encontrado",
    alreadyFriends: "Ya eres amigo de este usuario",
    cannotAddSelf: "No puedes agregarte a ti mismo como amigo"
  },
  // Confirmation
  confirmations: {
    removeFriend: "¿Estás seguro de que quieres eliminar a este amigo?",
    blockUser: "¿Estás seguro de que quieres bloquear a este usuario?",
    unblockUser: "¿Estás seguro de que quieres desbloquear a este usuario?"
  }
};
const common$2 = {
  app: {
    name: "RADAR",
    description: "Sistema de Alerta de Seguridad"
  },
  actions: {
    save: "Guardar",
    cancel: "Cancelar",
    delete: "Eliminar",
    edit: "Editar",
    close: "Cerrar",
    confirm: "Confirmar",
    back: "Atrás",
    next: "Siguiente",
    retry: "Reintentar",
    search: "Buscar",
    filter: "Filtrar",
    clear: "Limpiar",
    refresh: "Actualizar",
    more: "Más",
    less: "Menos",
    view: "Ver",
    share: "Compartir"
  },
  status: {
    loading: "Cargando...",
    error: "Error",
    success: "Éxito",
    warning: "Advertencia",
    info: "Información"
  },
  errors: {
    general: "Algo salió mal",
    network: "Error de red",
    notFound: "No encontrado",
    unauthorized: "No autorizado",
    forbidden: "Acceso denegado",
    validation: "Error de validación"
  },
  time: {
    now: "Ahora",
    today: "Hoy",
    yesterday: "Ayer",
    tomorrow: "Mañana",
    minutes: "min",
    hours: "h",
    days: "d",
    weeks: "sem",
    months: "mes",
    years: "año"
  },
  notifications: {
    success: "Operación exitosa",
    error: "Ha ocurrido un error",
    info: "Información",
    warning: "Advertencia"
  },
  reportIncident: "Reportar Incidente",
  settings: "Configuración",
  toggleDangerZones_title: "Alternar Zonas de Peligro",
  // Navigation
  map: "Mapa",
  community: "Comunidad",
  report: "Reportar",
  wanted: "Buscados",
  profile: "Perfil",
  // Filters
  filters: "Filtros"
};
const errors$1 = {
  general: {
    unknown: "Ha ocurrido un error desconocido",
    network: "Error de red",
    timeout: "Tiempo de espera agotado",
    server: "Error del servidor",
    validation: "Error de validación de datos"
  },
  auth: {
    notAuthenticated: "Autenticación requerida",
    sessionExpired: "Sesión expirada",
    invalidToken: "Token inválido",
    accessDenied: "Acceso denegado"
  },
  data: {
    notFound: "Datos no encontrados",
    invalidFormat: "Formato de datos inválido",
    saveFailed: "Error al guardar",
    deleteFailed: "Error al eliminar",
    updateFailed: "Error al actualizar"
  },
  location: {
    unavailable: "Geolocalización no disponible",
    permissionDenied: "Permiso de geolocalización denegado",
    timeout: "Tiempo de espera de geolocalización agotado"
  },
  app: {
    initialization: "Error de inicialización de la aplicación",
    configuration: "Error de configuración",
    version: "Versión incompatible"
  }
};
const onboarding = {
  // Steps
  stepLocation: "Acceso a Ubicación",
  stepNotifications: "Notificaciones",
  stepWelcome: "Bienvenido",
  // Location Screen
  locationTitle: "Habilitar Acceso a Ubicación",
  locationDescription: "Para recibir alertas sobre incidentes cerca de ti y asegurar actualizaciones de seguridad precisas en tiempo real.",
  locationButton: "Permitir Ubicación",
  // Notifications Screen  
  notificationsTitle: "Habilitar Notificaciones",
  notificationsDescription: "Mantente informado al instante sobre incidentes importantes, actualizaciones de la comunidad y alertas de emergencia.",
  notificationsButton: "Habilitar Notificaciones",
  // Welcome Screen
  welcomeTitle: "Bienvenido a RADAR",
  welcomeDescription: "Tu seguridad está en tus manos. Estás listo para recibir alertas en tiempo real y unirte a tu comunidad.",
  welcomeButton: "Comenzar",
  // Navigation
  skip: "Omitir",
  later: "Tal vez Después",
  // Progress
  stepProgress: "Paso {{current}} de {{total}}",
  // Success Messages
  locationSuccess: "✓ Ubicación detectada y geolocalización activa!",
  notificationsSuccess: "✓ Notificaciones habilitadas! Recibirás alertas de seguridad en tiempo real."
};
const es = {
  auth: auth$1,
  navigation: navigation$1,
  community: community$1,
  incidents,
  wanted,
  profile: profileEs,
  notifications: notificationsEs,
  friends: friendsEs,
  common: common$2,
  errors: errors$1,
  onboarding
};
const auth = {
  signIn: {
    title: "Вход в систему",
    withGoogle: "Войти через Google",
    withEmail: "Войти через Email",
    noAccount: "Нет аккаунта?",
    createAccount: "Создать аккаунт"
  },
  signUp: {
    title: "Регистрация",
    withGoogle: "Зарегистрироваться через Google",
    withEmail: "Зарегистрироваться через Email",
    haveAccount: "Уже есть аккаунт?",
    signIn: "Войти"
  },
  form: {
    email: "Email",
    password: "Пароль",
    confirmPassword: "Подтвердите пароль",
    submit: "Подтвердить",
    forgotPassword: "Забыли пароль?"
  },
  errors: {
    invalidEmail: "Неверный формат email",
    passwordTooShort: "Пароль должен быть не менее 6 символов",
    passwordsDontMatch: "Пароли не совпадают",
    emailInUse: "Этот email уже используется",
    invalidCredentials: "Неверный email или пароль",
    userNotFound: "Пользователь не найден",
    weakPassword: "Слишком простой пароль",
    unknown: "Произошла неизвестная ошибка"
  },
  resetPassword: {
    title: "Сброс пароля",
    description: "Введите ваш email для получения инструкций по сбросу пароля",
    success: "Инструкции по сбросу пароля отправлены на ваш email",
    button: "Отправить инструкции"
  },
  verification: {
    emailSent: "Письмо с подтверждением отправлено на ваш email",
    checkEmail: "Пожалуйста, проверьте вашу почту",
    resend: "Отправить повторно"
  }
};
const common$1 = {
  app: {
    name: "RADAR",
    description: "Система оповещения о безопасности"
  },
  actions: {
    save: "Сохранить",
    cancel: "Отмена",
    delete: "Удалить",
    edit: "Редактировать",
    close: "Закрыть",
    confirm: "Подтвердить",
    back: "Назад",
    next: "Далее",
    retry: "Повторить",
    search: "Поиск",
    filter: "Фильтр",
    clear: "Очистить",
    refresh: "Обновить",
    more: "Ещё",
    less: "Меньше",
    view: "Просмотр",
    share: "Поделиться"
  },
  status: {
    loading: "Загрузка...",
    error: "Ошибка",
    success: "Успешно",
    warning: "Предупреждение",
    info: "Информация"
  },
  errors: {
    general: "Что-то пошло не так",
    network: "Ошибка сети",
    notFound: "Не найдено",
    unauthorized: "Нет доступа",
    forbidden: "Доступ запрещен",
    validation: "Ошибка валидации"
  },
  time: {
    now: "Сейчас",
    today: "Сегодня",
    yesterday: "Вчера",
    tomorrow: "Завтра",
    minutes: "мин.",
    hours: "ч.",
    days: "дн.",
    weeks: "нед.",
    months: "мес.",
    years: "г."
  },
  notifications: {
    success: "Успешно выполнено",
    error: "Произошла ошибка",
    info: "Информация",
    warning: "Предупреждение"
  }
};
const community = {
  title: "Сообщество",
  social: "Лента",
  socialFeedTitle: "Социальная лента",
  socialFeedDescription: "Социальный фид в стиле Twitter для RADAR Community",
  socialFeedSubtitle: "Здесь будут отображаться посты пользователей с категориями, лайками и комментариями",
  createFirstPost: "Создать первый пост",
  filterByCategory: "Фильтр по категории",
  categoryAll: "Все",
  categorySafety: "Безопасность",
  categoryObservation: "Наблюдение",
  categoryQuestion: "Вопрос",
  categoryDiscussion: "Обсуждение",
  chat: {
    placeholder: "Написать сообщение...",
    send: "Отправить",
    loading: "Загрузка сообщений...",
    error: "Ошибка загрузки сообщений",
    empty: "Нет сообщений"
  },
  thread: {
    create: "Создать тему",
    reply: "Ответить",
    delete: "Удалить",
    edit: "Редактировать",
    report: "Пожаловаться",
    anonymous: "Анонимно"
  },
  moderation: {
    report: "Жалоба отправлена",
    block: "Заблокировать пользователя",
    unblock: "Разблокировать пользователя",
    delete: "Удалить сообщение",
    warn: "Предупредить пользователя"
  },
  notifications: {
    newMessage: "Новое сообщение",
    newThread: "Новая тема",
    mention: "Вас упомянули",
    reply: "Ответ на ваше сообщение"
  }
};
const errors = {
  general: {
    unknown: "Произошла неизвестная ошибка",
    network: "Ошибка сети",
    timeout: "Превышено время ожидания",
    server: "Ошибка сервера",
    validation: "Ошибка валидации данных"
  },
  auth: {
    notAuthenticated: "Необходима авторизация",
    sessionExpired: "Сессия истекла",
    invalidToken: "Недействительный токен",
    accessDenied: "Доступ запрещен"
  },
  data: {
    notFound: "Данные не найдены",
    invalidFormat: "Неверный формат данных",
    saveFailed: "Ошибка сохранения",
    deleteFailed: "Ошибка удаления",
    updateFailed: "Ошибка обновления"
  },
  location: {
    unavailable: "Геолокация недоступна",
    permissionDenied: "Доступ к геолокации запрещен",
    timeout: "Превышено время определения местоположения"
  },
  app: {
    initialization: "Ошибка инициализации приложения",
    configuration: "Ошибка конфигурации",
    version: "Несовместимая версия"
  }
};
const incidentsRu = {
  // Main screen
  neighborhood: "Район",
  activity: "Активность",
  quickActions: "Быстрые действия",
  reportIncident: "Сообщить об инциденте",
  viewReports: "Просмотр отчетов",
  recentActivity: "Недавняя активность",
  safetyScore: "Индекс безопасности",
  // Incident types
  typeLabel: "Тип",
  dateLabel: "Дата",
  other: "Другое",
  theft: "Кража",
  assault: "Нападение",
  vandalism: "Вандализм",
  suspicious: "Подозрительная активность",
  traffic_accident: "ДТП",
  // Incident status
  incidentPendingDeletion: "Этот инцидент будет удален через 30 минут из-за высокого процента отклонений",
  errorSavingReaction: "Ошибка сохранения вашей реакции",
  incidentDeleted: "Инцидент удален",
  incidentDeletedMessage: "Инцидент был успешно удален.",
  // Comments
  addCommentPlaceholder: "Добавьте ваш комментарий...",
  postAnonymously: "Опубликовать анонимно",
  anonymous: "Анонимно",
  errorAddingComment: "Ошибка добавления комментария",
  // Historical markers
  historyMarkersEnabled: "Исторические метки",
  historyMarkersEnabledDesc: "Показывать метки исторических инцидентов на карте",
  // Demo incidents for onboarding
  demoIncidents: [
    "0.3 км от вас — Вооруженное ограбление на ул. Главная. Избегайте район.",
    "0.15 км от вас — ДТП на шоссе 101. Пробки.",
    "0.8 км от вас — Подозрительная активность у Центрального парка. Будьте бдительны.",
    "0.5 км от вас — Пожарная ситуация на ул. Дубовая. Экстренные службы реагируют."
  ],
  // Severity levels
  low: "Низкий",
  medium: "Средний",
  high: "Высокий"
};
const navigation = {
  home: "Главная",
  map: "Карта",
  community: "Сообщество",
  profile: "Профиль",
  settings: "Настройки"
};
const notificationsRu = {
  // Onboarding permissions
  allowLocationAccess: "Разрешить доступ к геолокации",
  locationPermissionDesc: "Мы используем геолокацию для отправки уведомлений об инцидентах поблизости. Данные удаляются через 30 дней.",
  allowNotifications: "Разрешить уведомления",
  notificationPermissionDesc: "Для получения уведомлений об инцидентах в реальном времени",
  // General notification settings
  notifications: "Уведомления",
  pushNotifications: "Push-уведомления",
  enable: "Включить",
  disable: "Отключить",
  settings: "Настройки",
  // Reply functionality
  replyingTo: "Ответ на",
  swipeToReply: "Свайп вправо для ответа",
  // General notifications
  "general.newAlert": "Новое предупреждение",
  "general.updateAvailable": "Доступно обновление",
  "general.systemMessage": "Системное сообщение",
  // Incident notifications
  "incidents.new": "Новый инцидент поблизости",
  "incidents.update": "Обновление инцидента",
  "incidents.resolved": "Инцидент разрешен",
  "incidents.nearby": "Инцидент в вашем районе",
  // Community notifications
  "community.newMessage": "Новое сообщение в сообществе",
  "community.mention": "Вас упомянули",
  "community.reply": "Ответ на ваше сообщение",
  "community.threadUpdate": "Обновление треда",
  // Settings notifications
  "settings.enabled": "Уведомления включены",
  "settings.disabled": "Уведомления отключены",
  "settings.permission": "Разрешить уведомления",
  // HeroUI Alert notification types
  "zone_entry.title": "🚨 Оповещение об Опасной Зоне",
  "zone_entry.message": "Вы вошли в зону повышенного риска. Будьте внимательны и следуйте рекомендациям безопасности.",
  "zone_entry.action": "Советы Безопасности",
  "time_risk.title": "⚠️ Временное Предупреждение",
  "time_risk.message": "Текущее время повышает риски безопасности в данной области. Рекомендуется дополнительная осторожность.",
  "time_risk.action": "Показать Альтернативы",
  "incident_nearby.title": "🔔 Инцидент Рядом",
  "incident_nearby.message": "В вашей близости зарегистрирован инцидент безопасности.",
  "incident_nearby.action": "Подробнее",
  "weather_risk.title": "🌧️ Погодный Риск",
  "weather_risk.message": "Текущие погодные условия могут повлиять на безопасность в этой области.",
  "weather_risk.action": "Прогноз Погоды",
  "crowd_density.title": "👥 Скопление Людей",
  "crowd_density.message": "Обнаружена высокая плотность толпы. Рассмотрите альтернативные маршруты.",
  "crowd_density.action": "Найти Маршрут",
  "ai_prediction.title": "🧠 ИИ Прогноз Безопасности",
  "ai_prediction.message": "Наша система ИИ предсказывает повышение риска на основе текущих паттернов.",
  "ai_prediction.action": "Узнать Больше",
  "traffic_alert.title": "🚗 Дорожная Информация",
  "traffic_alert.message": "Обновлена информация о дорожных условиях для вашего маршрута.",
  "traffic_alert.action": "Посмотреть Маршрут",
  "success.title": "✅ Успешно",
  "success.message": "Действие выполнено успешно.",
  "success.action": "Продолжить",
  "error.title": "❌ Ошибка",
  "error.message": "Произошла ошибка. Пожалуйста, попробуйте снова.",
  "error.action": "Повторить",
  "info.title": "ℹ️ Информация",
  "info.message": "Доступна новая информация.",
  "info.action": "Посмотреть",
  "warning.title": "⚠️ Предупреждение",
  "warning.message": "Пожалуйста, обратите внимание на это важное уведомление.",
  "warning.action": "Понятно",
  "default.title": "🔔 Уведомление",
  "default.message": "У вас есть новое уведомление.",
  "default.action": "Посмотреть",
  // Danger Zone notifications
  "dangerZone.entryTitle.level5": "🚨 ВНУТРИ: Зона Крайне Высокого Риска",
  "dangerZone.entryTitle.level4": "🚨 ВНУТРИ: Зона Высокого Риска",
  "dangerZone.entryTitle.level3": "🚨 ВНУТРИ: Зона Повышенного Риска",
  "dangerZone.entryTitle.level2": "🚨 ВНУТРИ: Зона Умеренного Риска",
  "dangerZone.entryTitle.level1": "🚨 ВНУТРИ: Зона Внимания",
  "dangerZone.entryMessage": 'Вы находитесь в зоне повышенного риска "{zoneName}"',
  "dangerZone.proximityTitle.level5": "⚠️ ПРИБЛИЖЕНИЕ: Зона Крайне Высокого Риска",
  "dangerZone.proximityTitle.level4": "⚠️ ПРИБЛИЖЕНИЕ: Зона Высокого Риска",
  "dangerZone.proximityTitle.level3": "⚠️ ПРИБЛИЖЕНИЕ: Зона Повышенного Риска",
  "dangerZone.proximityTitle.level2": "⚠️ ПРИБЛИЖЕНИЕ: Зона Умеренного Риска",
  "dangerZone.proximityTitle.level1": "⚠️ ПРИБЛИЖЕНИЕ: Зона Внимания",
  "dangerZone.proximityMessage": 'Вы приближаетесь к зоне повышенного риска "{zoneName}" ({distance}м)',
  "dangerZone.predictiveTitle": "🔮 ПРЕДУПРЕЖДЕНИЕ: Движение к опасной зоне",
  "dangerZone.predictiveMessage": 'Основываясь на вашем текущем направлении, вы приближаетесь к области "{zoneName}" (риск: {riskLevel}/5). Рассмотрите изменение маршрута.',
  "dangerZone.nearBy": "Рядом с {zoneName}",
  "dangerZone.directionTo": "Направление к {zoneName}",
  // Suggested actions - flattened for TranslationModule compatibility
  "dangerZone.actions.basic.0": "Будьте внимательны",
  "dangerZone.actions.basic.1": "Не демонстрируйте ценные вещи",
  "dangerZone.actions.basic.2": "Избегайте использования телефона на улице",
  "dangerZone.actions.highRisk.inside.0": "НЕМЕДЛЕННО покиньте эту область",
  "dangerZone.actions.highRisk.inside.1": "Переместитесь в людные места",
  "dangerZone.actions.highRisk.inside.2": "Вызовите такси, если возможно",
  "dangerZone.actions.highRisk.inside.3": "Уведомите семью о вашем местоположении",
  "dangerZone.actions.highRisk.approaching.0": "Избегайте входа в эту область",
  "dangerZone.actions.highRisk.approaching.1": "Выберите альтернативный маршрут",
  "dangerZone.actions.highRisk.approaching.2": "Если необходимо пройти - делайте это быстро",
  "dangerZone.actions.moderate.0": "Будьте особенно осторожны",
  "dangerZone.actions.moderate.1": "Предпочитайте людные улицы",
  "dangerZone.actions.moderate.2": "Не задерживайтесь в этой области",
  "dangerZone.actions.predictive.0": "Измените маршрут",
  "dangerZone.actions.predictive.1": "Выберите альтернативный путь",
  "dangerZone.actions.predictive.2": "Рассмотрите использование общественного транспорта",
  "dangerZone.actions.predictive.3": "Уведомите семью о вашем маршруте",
  "dangerZone.actions.timeSpecific.night.0": "Избегайте ходить в одиночку ночью",
  "dangerZone.actions.timeSpecific.night.1": "Используйте хорошо освещенные улицы",
  "dangerZone.actions.timeSpecific.night.2": "Старайтесь находиться в группах",
  "dangerZone.actions.timeSpecific.evening.0": "Будьте особенно бдительны",
  "dangerZone.actions.timeSpecific.evening.1": "Избегайте изолированных областей",
  "dangerZone.actions.timeSpecific.evening.2": "Держите экстренные контакты под рукой"
};
const profile = {
  title: "Профиль",
  personalInfo: {
    name: "Имя",
    email: "Email",
    phone: "Телефон",
    location: "Местоположение",
    bio: "О себе"
  },
  settings: {
    title: "Настройки",
    notifications: "Уведомления",
    language: "Язык",
    theme: "Тема",
    privacy: "Конфиденциальность"
  },
  security: {
    title: "Безопасность",
    changePassword: "Изменить пароль",
    twoFactor: "Двухфакторная аутентификация",
    sessions: "Активные сессии"
  },
  preferences: {
    title: "Предпочтения",
    radius: "Радиус оповещений",
    units: "Единицы измерения",
    autoLocation: "Автоматическое определение местоположения"
  },
  stats: {
    title: "Статистика",
    reportsCreated: "Созданные отчеты",
    reportsVerified: "Подтвержденные отчеты",
    reputation: "Репутация",
    level: "Уровень"
  },
  actions: {
    edit: "Редактировать профиль",
    save: "Сохранить изменения",
    cancel: "Отменить",
    logout: "Выйти",
    delete: "Удалить аккаунт"
  },
  validation: {
    nameRequired: "Имя обязательно",
    emailInvalid: "Неверный формат email",
    phoneInvalid: "Неверный формат телефона",
    bioTooLong: "Описание слишком длинное"
  },
  badges: {
    title: "Значки",
    new: "Новый",
    verified: "Проверенный",
    trusted: "Надежный",
    expert: "Эксперт",
    moderator: "Модератор",
    admin: "Администратор"
  },
  roles: {
    user: "Пользователь",
    moderator: "Модератор",
    admin: "Администратор",
    superAdmin: "Супер-администратор"
  },
  // Username
  username: "Имя пользователя",
  usernameEdit: "Редактировать имя пользователя",
  usernameEditTitle: "Изменить имя пользователя",
  usernameEditDescription: "Выберите уникальное имя пользователя (3-20 символов, только буквы, цифры и подчёркивание)",
  usernameLabel: "Имя пользователя",
  usernamePlaceholder: "Введите имя пользователя...",
  usernameAlreadyTaken: "Имя пользователя уже занято. Пожалуйста, выберите другое.",
  usernameInvalid: "Неверный формат имени пользователя. Используйте только буквы, цифры и подчёркивание.",
  usernameUpdated: "Имя пользователя успешно обновлено!",
  usernameSave: "Сохранить",
  usernameCancel: "Отменить",
  noBioYet: "Биография пока не добавлена..."
};
const wantedRu = {
  // Main
  wantedPersons: "Пропавшие люди",
  addWantedPerson: "Добавить пропавшего",
  searchPerson: "Поиск человека...",
  noWantedPersons: "Нет сообщений о пропавших",
  // Person details
  personName: "Имя человека",
  age: "Возраст",
  years: "лет",
  yearsOld: "лет",
  person_age: "{age} лет",
  description: "Описание",
  lastSeenLocation: "Место последнего появления",
  lastSeenDate: "Дата последнего появления",
  contactInfo: "Контактная информация",
  last_seen_location: "Место последнего появления",
  last_seen_date: "Дата последнего появления",
  contact_info: "Контактная информация",
  // Status
  active: "В розыске",
  caught: "Найден",
  inactive: "Дело закрыто",
  wanted_status_active: "В розыске",
  wanted_status_caught: "Найден",
  wanted_status_inactive: "Дело закрыто",
  // Photo handling
  noPhotoAvailable: "Нет фотографии",
  noPhotoDescription: "Фотографии не были загружены для этого человека",
  wanted_no_photo: "Нет фотографии",
  wanted_no_photo_desc: "Фотографии не были загружены для этого человека",
  // Meta info
  addedBy: "Добавил",
  addedOn: "Добавлено",
  added_by: "Добавил",
  added_on: "Добавлено",
  // Actions
  personAdded: "Человек добавлен",
  personAddedDesc: "Сообщение о пропавшем человеке успешно добавлено."
};
const ru = {
  auth,
  common: common$1,
  community,
  errors,
  incidents: incidentsRu,
  navigation,
  notifications: notificationsRu,
  profile,
  wanted: wantedRu
};
const interpolate$1 = (template, options) => {
  if (!options) return template;
  let result = template;
  Object.keys(options).forEach((key2) => {
    const value = String(options[key2]);
    result = result.replace(new RegExp(`\\{${key2}\\}`, "g"), value);
    result = result.replace(new RegExp(`\\{\\{${key2}\\}\\}`, "g"), value);
  });
  return result;
};
const mapLegacyKey = (legacyKey) => {
  const authKeys = ["welcome", "signIn", "signUp", "email", "password", "confirmPassword", "fullName", "phone", "login", "register", "forgot"];
  const navigationKeys = ["home", "reports", "community", "wanted", "profile", "back"];
  const communityKeys = ["communityTitle", "yourNeighborhood", "neighborhoodChat", "observations", "createThread", "threadTitle", "messages"];
  const incidentKeys = ["reportIncident", "quickReport", "confirm", "reject", "incident", "comments", "addComment"];
  const wantedKeys = ["addWantedPerson", "personName", "age", "description", "lastSeenLocation", "wanted", "missing", "found"];
  const profileKeys = ["profile", "editProfile", "changePassword", "settings", "notifications", "language"];
  const notificationKeys = ["notification", "alert", "push", "enable", "disable"];
  const errorKeys = ["error", "loading", "failed", "success", "warning"];
  if (authKeys.some((key2) => legacyKey.toLowerCase().includes(key2))) {
    return `auth.${legacyKey}`;
  }
  if (navigationKeys.some((key2) => legacyKey.toLowerCase().includes(key2))) {
    return `navigation.${legacyKey}`;
  }
  if (communityKeys.some((key2) => legacyKey.toLowerCase().includes(key2))) {
    return `community.${legacyKey}`;
  }
  if (incidentKeys.some((key2) => legacyKey.toLowerCase().includes(key2))) {
    return `incidents.${legacyKey}`;
  }
  if (wantedKeys.some((key2) => legacyKey.toLowerCase().includes(key2))) {
    return `wanted.${legacyKey}`;
  }
  if (profileKeys.some((key2) => legacyKey.toLowerCase().includes(key2))) {
    return `profile.${legacyKey}`;
  }
  if (notificationKeys.some((key2) => legacyKey.toLowerCase().includes(key2))) {
    return `notifications.${legacyKey}`;
  }
  if (errorKeys.some((key2) => legacyKey.toLowerCase().includes(key2))) {
    return `errors.${legacyKey}`;
  }
  return `common.${legacyKey}`;
};
const legacyKeyMapping = {
  // Auth keys
  "welcome": "auth.welcome",
  "signIn": "auth.signIn",
  "signUp": "auth.signUp",
  "email": "auth.email",
  "password": "auth.password",
  "confirmPassword": "auth.confirmPassword",
  "fullName": "auth.fullName",
  "phone": "auth.phone",
  "loginWithGoogle": "auth.loginWithGoogle",
  "forgotPassword": "auth.forgotPassword",
  "loginButton": "auth.loginButton",
  "registerButton": "auth.registerButton",
  // Navigation keys
  "home": "navigation.home",
  "reports": "navigation.reports",
  "community": "navigation.community",
  "wanted": "navigation.wanted",
  "profile": "navigation.profile",
  "back": "navigation.back",
  // Community keys
  "communityTitle": "community.communityTitle",
  "yourNeighborhood": "community.yourNeighborhood",
  "neighborhoodChat": "community.neighborhoodChat",
  "observations": "community.observations",
  "quickReport": "community.quickReport",
  "createThread": "community.createThread",
  "threadTitle": "community.threadTitle",
  "messages": "community.messages",
  "comments": "community.comments",
  "anonymously": "community.anonymously",
  "you": "community.you",
  "confirmed": "community.confirmed",
  "rejected": "community.rejected",
  // Incident keys
  "reportIncident": "incidents.reportIncident",
  "recentActivity": "incidents.recentActivity",
  "safetyScore": "incidents.safetyScore",
  "typeLabel": "incidents.typeLabel",
  "dateLabel": "incidents.dateLabel",
  "other": "incidents.other",
  "theft": "incidents.theft",
  "assault": "incidents.assault",
  "vandalism": "incidents.vandalism",
  "suspicious": "incidents.suspicious",
  "traffic_accident": "incidents.traffic_accident",
  // Wanted keys
  "wantedPersons": "wanted.wantedPersons",
  "addWantedPerson": "wanted.addWantedPerson",
  "personName": "wanted.personName",
  "age": "wanted.age",
  "years": "wanted.years",
  "yearsOld": "wanted.yearsOld",
  "description": "wanted.description",
  "lastSeenLocation": "wanted.lastSeenLocation",
  "lastSeenDate": "wanted.lastSeenDate",
  "contactInfo": "wanted.contactInfo",
  "active": "wanted.active",
  "caught": "wanted.caught",
  "inactive": "wanted.inactive",
  "noPhotoAvailable": "wanted.noPhotoAvailable",
  "addedBy": "wanted.addedBy",
  "addedOn": "wanted.addedOn",
  // Profile keys
  "settings": "profile.settings",
  "level": "profile.level",
  "xp": "profile.xp",
  "badges": "profile.badges",
  "earned": "profile.earned",
  // Common keys
  "appName": "common.appName",
  "tagline": "common.tagline",
  "loadingText": "common.loadingText",
  "loading": "common.loading",
  "saving": "common.saving",
  "save": "common.save",
  "cancel": "common.cancel",
  "delete": "common.delete",
  "edit": "common.edit",
  "create": "common.create",
  "confirm": "common.confirm",
  "reject": "common.reject",
  "send": "common.send",
  "continue": "common.continue",
  "close": "common.close",
  "name": "common.name",
  "title": "common.title",
  "date": "common.date",
  "time": "common.time",
  "status": "common.status",
  "type": "common.type",
  "success": "common.success",
  "error": "common.error",
  "warning": "common.warning",
  // Notification keys
  "allowLocationAccess": "notifications.allowLocationAccess",
  "allowNotifications": "notifications.allowNotifications",
  "notifications": "notifications.notifications",
  "pushNotifications": "notifications.pushNotifications",
  // Error keys
  "errorOccurred": "errors.errorOccurred",
  "tryAgain": "errors.tryAgain",
  "networkError": "errors.networkError",
  "permissionDenied": "errors.permissionDenied",
  "fieldRequired": "errors.fieldRequired",
  "invalidEmail": "errors.invalidEmail",
  "invalidPassword": "errors.invalidPassword"
};
const translations$2 = {
  en,
  es,
  // Правильные испанские переводы
  ru
  // Полная поддержка русского языка
};
const useLanguage = () => {
  const [language, setLanguage] = reactExports.useState("en");
  reactExports.useEffect(() => {
    const savedLanguage = localStorage.getItem("language");
    if (savedLanguage && ["en", "es", "ru"].includes(savedLanguage)) {
      setLanguage(savedLanguage);
    }
  }, []);
  const handleSetLanguage = reactExports.useCallback((newLanguage) => {
    if (["en", "es", "ru"].includes(newLanguage)) {
      setLanguage(newLanguage);
      localStorage.setItem("language", newLanguage);
    }
  }, []);
  const t2 = reactExports.useCallback((key2, options) => {
    const locale = translations$2[language];
    if (legacyKeyMapping[key2]) {
      const mappedKey = legacyKeyMapping[key2];
      const [moduleName, moduleKey] = mappedKey.split(".");
      const module = locale[moduleName];
      if (module && module[moduleKey]) {
        return interpolate$1(module[moduleKey], options);
      }
    }
    if (key2.includes(".")) {
      const [moduleName, ...keyParts] = key2.split(".");
      const moduleKey = keyParts.join(".");
      const module = locale[moduleName];
      if (module && module[moduleKey]) {
        return interpolate$1(module[moduleKey], options);
      }
    }
    const autoMappedKey = mapLegacyKey(key2);
    if (autoMappedKey !== `common.${key2}`) {
      const [moduleName, moduleKey] = autoMappedKey.split(".");
      const module = locale[moduleName];
      if (module && module[moduleKey]) {
        return interpolate$1(module[moduleKey], options);
      }
    }
    if (locale.common[key2]) {
      return interpolate$1(locale.common[key2], options);
    }
    for (const moduleName of Object.keys(locale)) {
      const module = locale[moduleName];
      if (module && module[key2]) {
        return interpolate$1(module[key2], options);
      }
    }
    return key2;
  }, [language]);
  return {
    language,
    setLanguage: handleSetLanguage,
    t: t2
  };
};
function useTypedLanguage() {
  const { language, setLanguage, t: t2 } = useLanguage();
  const typedT = (key2, options) => {
    return t2(key2, options);
  };
  return {
    language,
    setLanguage,
    t: typedT
  };
}
const TermsOfServiceDialog = ({ open, onOpenChange }) => {
  const { language } = useTypedLanguage();
  const translations2 = {
    en: {
      title: "Terms of Service",
      lastUpdated: "Last Updated: January 25, 2025",
      sections: {
        generalProvisions: {
          title: "General Provisions",
          content: "RADAR provides a service for displaying danger zones, incidents, and sharing information between users. By using the application, you agree to comply with these terms."
        },
        registrationAndAccount: {
          title: "Registration and Account",
          content: "Registration is required to access main features. Users are obligated to provide accurate information and maintain account security."
        },
        userContent: {
          title: "User Content",
          content: "You are responsible for published content (incidents, comments, videos). It is prohibited to post false, offensive, or illegal information."
        },
        geolocation: {
          title: "Geolocation",
          content: "The application uses your geodata to display relevant information. You can disable geolocation in settings at any time."
        },
        limitationOfLiability: {
          title: "Limitation of Liability",
          content: "RADAR does not guarantee absolute data accuracy and is not responsible for user actions or consequences of using the service."
        },
        termsChanges: {
          title: "Terms Changes",
          content: "We may update these terms. By continuing to use the service, you agree to the changes. Significant changes will be announced in the app."
        },
        dataUsage: {
          title: "Data Usage",
          content: "User-generated content may be used to improve safety analytics and community features, always in accordance with our Privacy Policy."
        },
        prohibition: {
          title: "Prohibited Activities",
          content: "Users may not spam, harass others, share false emergencies, attempt to hack the system, or violate local laws."
        }
      }
    },
    es: {
      title: "Términos de Servicio",
      lastUpdated: "Última actualización: 25 de enero de 2025",
      sections: {
        generalProvisions: {
          title: "Disposiciones Generales",
          content: "RADAR proporciona un servicio para mostrar zonas peligrosas, incidentes e intercambio de información entre usuarios. Al usar la aplicación, aceptas cumplir con estos términos."
        },
        registrationAndAccount: {
          title: "Registro y Cuenta",
          content: "Es necesario registrarse para acceder a las funciones principales. Los usuarios están obligados a proporcionar información precisa y mantener la seguridad de la cuenta."
        },
        userContent: {
          title: "Contenido del Usuario",
          content: "Eres responsable del contenido publicado (incidentes, comentarios, videos). Está prohibido publicar información falsa, ofensiva o ilegal."
        },
        geolocation: {
          title: "Geolocalización",
          content: "La aplicación utiliza tus datos de geolocalización para mostrar información relevante. Puedes desactivar la geolocalización en la configuración en cualquier momento."
        },
        limitationOfLiability: {
          title: "Limitación de Responsabilidad",
          content: "RADAR no garantiza la precisión absoluta de los datos y no es responsable de las acciones de los usuarios o las consecuencias del uso del servicio."
        },
        termsChanges: {
          title: "Cambios en los Términos",
          content: "Podemos actualizar estos términos. Al continuar usando el servicio, aceptas los cambios. Los cambios significativos se anunciarán en la aplicación."
        },
        dataUsage: {
          title: "Uso de Datos",
          content: "El contenido generado por usuarios puede usarse para mejorar el análisis de seguridad y las funciones comunitarias, siempre de acuerdo con nuestra Política de Privacidad."
        },
        prohibition: {
          title: "Actividades Prohibidas",
          content: "Los usuarios no pueden hacer spam, acosar a otros, compartir emergencias falsas, intentar hackear el sistema o violar las leyes locales."
        }
      }
    }
  };
  const currentLanguage = language === "es" ? "es" : "en";
  const t2 = translations2[currentLanguage];
  const sectionIcons = {
    generalProvisions: Shield,
    registrationAndAccount: UserCheck,
    userContent: FileText,
    geolocation: MapPin,
    limitationOfLiability: TriangleAlert,
    termsChanges: RefreshCw,
    dataUsage: Database,
    prohibition: Ban
  };
  return /* @__PURE__ */ jsxRuntimeExports.jsx(Dialog, { open, onOpenChange, children: /* @__PURE__ */ jsxRuntimeExports.jsxs(DialogContent, { className: "bg-card border-border max-w-2xl max-h-[90vh]", children: [
    /* @__PURE__ */ jsxRuntimeExports.jsx(DialogHeader, { children: /* @__PURE__ */ jsxRuntimeExports.jsxs(DialogTitle, { className: "text-white flex items-center gap-2", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx(FileText, { className: "w-5 h-5" }),
      t2.title
    ] }) }),
    /* @__PURE__ */ jsxRuntimeExports.jsx(ScrollArea, { className: "h-[60vh] pr-4", children: /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "space-y-6 pb-4", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "text-sm text-gray-400 italic border-b border-gray-700 pb-2", children: t2.lastUpdated }),
      Object.entries(t2.sections).map(([key2, section]) => {
        const IconComponent = sectionIcons[key2];
        return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "space-y-3", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsxs("h4", { className: "text-lg font-medium text-white flex items-center gap-2", children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx(IconComponent, { className: "w-4 h-4 text-blue-400" }),
            section.title
          ] }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: "text-gray-300 text-sm leading-relaxed pl-6", children: section.content })
        ] }, key2);
      }),
      /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "mt-8 p-4 bg-gray-800/50 rounded-lg border border-gray-700", children: /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: "text-xs text-gray-400 text-center", children: currentLanguage === "es" ? "Al usar RADAR, aceptas estos términos de servicio. Para preguntas, contacta a nuestro equipo de soporte." : "By using RADAR, you accept these terms of service. For questions, contact our support team." }) })
    ] }) })
  ] }) });
};
const EnhancedPrivacyPolicyDialog = ({ open, onOpenChange }) => {
  const { language } = useTypedLanguage();
  const translations2 = {
    en: {
      title: "Privacy Policy",
      lastUpdated: "Last Updated: January 25, 2025",
      introduction: "At RADAR App, we take your privacy seriously. This Privacy Policy explains how we collect, use, and protect your personal information.",
      sections: {
        dataCollection: {
          title: "Data Collection",
          items: [
            "Account information (email, name, username)",
            "Location data when using the app",
            "Device information and technical specifications",
            "Usage statistics and app interactions",
            "Community reports and user-generated content",
            "Push notification preferences"
          ]
        },
        dataUsage: {
          title: "How We Use Your Data",
          items: [
            "Provide safety alerts and real-time notifications",
            "Display relevant safety information on the map",
            "Improve our services and user experience",
            "Maintain community features and moderation",
            "Ensure platform security and prevent abuse",
            "Analyze usage patterns for app optimization"
          ]
        },
        locationServices: {
          title: "Location Services",
          items: [
            "Location data is used only when the app is active",
            "Background location for danger zone monitoring (if enabled)",
            "You can disable location services at any time",
            "Location history is not stored permanently",
            "Anonymous reporting hides your location from other users"
          ]
        },
        dataSharing: {
          title: "Data Sharing",
          items: [
            "We never sell your personal data to third parties",
            "Data is shared only for essential app functionality",
            "Anonymous reports protect your identity",
            "Third-party services (Supabase, Firebase) are carefully vetted",
            "Government requests only with valid legal process"
          ]
        },
        userRights: {
          title: "Your Rights",
          items: [
            "Access and download your personal data",
            "Request correction of inaccurate information",
            "Delete your account and associated data",
            "Control privacy and notification settings",
            "Opt-out of non-essential features",
            "Data portability upon request"
          ]
        },
        dataSecurity: {
          title: "Data Security",
          items: [
            "Industry-standard encryption for data transmission",
            "Secure cloud storage with access controls",
            "Regular security audits and updates",
            "Two-factor authentication available",
            "Incident response procedures in place"
          ]
        },
        dataRetention: {
          title: "Data Retention",
          content: "We retain your data only as long as necessary for service provision. Account deletion removes personal data within 30 days, though some anonymized data may be retained for analytics."
        },
        policyUpdates: {
          title: "Policy Updates",
          content: "We may update this Privacy Policy periodically. Significant changes will be announced in the app with a 30-day notice period."
        }
      }
    },
    es: {
      title: "Política de Privacidad",
      lastUpdated: "Última actualización: 25 de enero de 2025",
      introduction: "En la aplicación RADAR, tomamos tu privacidad en serio. Esta Política de Privacidad explica cómo recopilamos, usamos y protegemos tu información personal.",
      sections: {
        dataCollection: {
          title: "Recopilación de Datos",
          items: [
            "Información de cuenta (email, nombre, nombre de usuario)",
            "Datos de ubicación al usar la aplicación",
            "Información del dispositivo y especificaciones técnicas",
            "Estadísticas de uso e interacciones en la aplicación",
            "Reportes comunitarios y contenido generado por usuarios",
            "Preferencias de notificaciones push"
          ]
        },
        dataUsage: {
          title: "Cómo Usamos Tus Datos",
          items: [
            "Proporcionar alertas de seguridad y notificaciones en tiempo real",
            "Mostrar información de seguridad relevante en el mapa",
            "Mejorar nuestros servicios y experiencia del usuario",
            "Mantener funciones comunitarias y moderación",
            "Asegurar la seguridad de la plataforma y prevenir abusos",
            "Analizar patrones de uso para optimización de la aplicación"
          ]
        },
        locationServices: {
          title: "Servicios de Localización",
          items: [
            "Los datos de ubicación se usan solo cuando la aplicación está activa",
            "Ubicación en segundo plano para monitoreo de zonas peligrosas (si está habilitado)",
            "Puedes desactivar los servicios de ubicación en cualquier momento",
            "El historial de ubicación no se almacena permanentemente",
            "Los reportes anónimos ocultan tu ubicación de otros usuarios"
          ]
        },
        dataSharing: {
          title: "Compartir Datos",
          items: [
            "Nunca vendemos tus datos personales a terceros",
            "Los datos se comparten solo para funcionalidad esencial de la aplicación",
            "Los reportes anónimos protegen tu identidad",
            "Servicios de terceros (Supabase, Firebase) son cuidadosamente evaluados",
            "Solicitudes gubernamentales solo con proceso legal válido"
          ]
        },
        userRights: {
          title: "Tus Derechos",
          items: [
            "Acceder y descargar tus datos personales",
            "Solicitar corrección de información inexacta",
            "Eliminar tu cuenta y datos asociados",
            "Controlar configuraciones de privacidad y notificaciones",
            "Excluirte de funciones no esenciales",
            "Portabilidad de datos bajo solicitud"
          ]
        },
        dataSecurity: {
          title: "Seguridad de Datos",
          items: [
            "Cifrado estándar de la industria para transmisión de datos",
            "Almacenamiento en nube seguro con controles de acceso",
            "Auditorías de seguridad y actualizaciones regulares",
            "Autenticación de dos factores disponible",
            "Procedimientos de respuesta a incidentes implementados"
          ]
        },
        dataRetention: {
          title: "Retención de Datos",
          content: "Conservamos tus datos solo el tiempo necesario para proporcionar el servicio. La eliminación de cuenta elimina datos personales en 30 días, aunque algunos datos anonimizados pueden conservarse para análisis."
        },
        policyUpdates: {
          title: "Actualizaciones de Política",
          content: "Podemos actualizar esta Política de Privacidad periódicamente. Los cambios significativos se anunciarán en la aplicación con un período de aviso de 30 días."
        }
      }
    }
  };
  const currentLanguage = language === "es" ? "es" : "en";
  const t2 = translations2[currentLanguage];
  const sectionIcons = {
    dataCollection: Eye,
    dataUsage: Database,
    locationServices: MapPin,
    dataSharing: Share2,
    userRights: UserCheck,
    dataSecurity: Shield,
    dataRetention: Clock$1,
    policyUpdates: Bell
  };
  return /* @__PURE__ */ jsxRuntimeExports.jsx(Dialog, { open, onOpenChange, children: /* @__PURE__ */ jsxRuntimeExports.jsxs(DialogContent, { className: "bg-card border-border max-w-2xl max-h-[90vh]", children: [
    /* @__PURE__ */ jsxRuntimeExports.jsx(DialogHeader, { children: /* @__PURE__ */ jsxRuntimeExports.jsxs(DialogTitle, { className: "text-white flex items-center gap-2", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx(Lock, { className: "w-5 h-5 text-green-400" }),
      t2.title
    ] }) }),
    /* @__PURE__ */ jsxRuntimeExports.jsx(ScrollArea, { className: "h-[60vh] pr-4", children: /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "space-y-6 pb-4", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "text-sm text-gray-400 italic border-b border-gray-700 pb-2", children: t2.lastUpdated }),
      /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "p-4 bg-blue-900/20 rounded-lg border border-blue-800/30", children: /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: "text-gray-300 text-sm leading-relaxed", children: t2.introduction }) }),
      Object.entries(t2.sections).map(([key2, section]) => {
        const IconComponent = sectionIcons[key2];
        return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "space-y-3", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsxs("h4", { className: "text-lg font-medium text-white flex items-center gap-2", children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx(IconComponent, { className: "w-4 h-4 text-green-400" }),
            section.title
          ] }),
          "items" in section ? /* @__PURE__ */ jsxRuntimeExports.jsx("ul", { className: "space-y-2 pl-6", children: section.items.map((item, index2) => /* @__PURE__ */ jsxRuntimeExports.jsxs("li", { className: "text-gray-300 text-sm leading-relaxed flex items-start gap-2", children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "text-green-400 text-xs mt-2", children: "•" }),
            /* @__PURE__ */ jsxRuntimeExports.jsx("span", { children: item })
          ] }, index2)) }) : /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: "text-gray-300 text-sm leading-relaxed pl-6", children: section.content })
        ] }, key2);
      }),
      /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "mt-8 p-4 bg-green-900/20 rounded-lg border border-green-800/30", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex items-center gap-2 mb-2", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx(Server, { className: "w-4 h-4 text-green-400" }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "text-sm font-medium text-white", children: currentLanguage === "es" ? "Contacto" : "Contact" })
        ] }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: "text-xs text-gray-400", children: currentLanguage === "es" ? "Si tienes preguntas sobre esta política de privacidad o deseas ejercer tus derechos, contáctanos a través del soporte en la aplicación." : "If you have questions about this privacy policy or wish to exercise your rights, contact us through in-app support." })
      ] })
    ] }) })
  ] }) });
};
class ErrorLogger {
  static async logError(error, component) {
    try {
      const errorLog = {
        timestamp: (/* @__PURE__ */ new Date()).toISOString(),
        error: error.message,
        stack: error.stack,
        component,
        userAgent: navigator.userAgent
      };
      console.error("Error logged:", errorLog);
      const existingLogs = await this.getLogs();
      existingLogs.unshift(errorLog);
      if (existingLogs.length > this.MAX_LOGS) {
        existingLogs.splice(this.MAX_LOGS);
      }
      await Preferences.set({
        key: this.LOG_KEY,
        value: JSON.stringify(existingLogs)
      });
    } catch (logError) {
      console.error("Failed to log error:", logError);
    }
  }
  static async getLogs() {
    try {
      const { value } = await Preferences.get({ key: this.LOG_KEY });
      return value ? JSON.parse(value) : [];
    } catch {
      return [];
    }
  }
  static async clearLogs() {
    try {
      await Preferences.remove({ key: this.LOG_KEY });
    } catch (error) {
      console.error("Failed to clear logs:", error);
    }
  }
}
__publicField(ErrorLogger, "LOG_KEY", "app_error_logs");
__publicField(ErrorLogger, "MAX_LOGS", 50);
window.addEventListener("error", (event) => {
  ErrorLogger.logError(new Error(event.message), "Global Error Handler");
});
window.addEventListener("unhandledrejection", (event) => {
  ErrorLogger.logError(new Error(event.reason), "Unhandled Promise Rejection");
});
function LoginForm({
  className,
  ...props
}) {
  useNavigate();
  useAuth();
  const { t: t2 } = useLanguage$1();
  const [isLogin, setIsLogin] = reactExports.useState(true);
  const [loading, setLoading] = reactExports.useState(false);
  const [showPassword, setShowPassword] = reactExports.useState(false);
  const [showConfirmPassword, setShowConfirmPassword] = reactExports.useState(false);
  const [passwordErrors, setPasswordErrors] = reactExports.useState([]);
  const [openTerms, setOpenTerms] = reactExports.useState(false);
  const [openPrivacy, setOpenPrivacy] = reactExports.useState(false);
  const [email, setEmail] = reactExports.useState("");
  const [password, setPassword] = reactExports.useState("");
  const [confirmPassword, setConfirmPassword] = reactExports.useState("");
  const [fullName, setFullName] = reactExports.useState("");
  const [nickname, setNickname] = reactExports.useState("");
  const [inputEmail, setInputEmail] = reactExports.useState("");
  const [inputPassword, setInputPassword] = reactExports.useState("");
  const [inputConfirmPassword, setInputConfirmPassword] = reactExports.useState("");
  const [inputFullName, setInputFullName] = reactExports.useState("");
  const [inputNickname, setInputNickname] = reactExports.useState("");
  reactExports.useEffect(() => {
    const handler = setTimeout(() => setEmail(inputEmail), 300);
    return () => clearTimeout(handler);
  }, [inputEmail]);
  reactExports.useEffect(() => {
    const handler = setTimeout(() => handlePasswordChange(inputPassword), 300);
    return () => clearTimeout(handler);
  }, [inputPassword]);
  reactExports.useEffect(() => {
    const handler = setTimeout(() => setConfirmPassword(inputConfirmPassword), 300);
    return () => clearTimeout(handler);
  }, [inputConfirmPassword]);
  reactExports.useEffect(() => {
    const handler = setTimeout(() => setFullName(inputFullName), 300);
    return () => clearTimeout(handler);
  }, [inputFullName]);
  reactExports.useEffect(() => {
    const handler = setTimeout(() => setNickname(inputNickname), 300);
    return () => clearTimeout(handler);
  }, [inputNickname]);
  const validatePassword = (password2) => {
    const errors2 = [];
    if (password2.length < 8) {
      errors2.push(t2("passwordMinLength"));
    }
    if (!/[A-Z]/.test(password2)) {
      errors2.push(t2("passwordUppercase"));
    }
    if (!/[a-z]/.test(password2)) {
      errors2.push(t2("passwordLowercase"));
    }
    if (!/[0-9]/.test(password2)) {
      errors2.push(t2("passwordNumber"));
    }
    if (!/[!@#$%^&*(),.?":{}|<>]/.test(password2)) {
      errors2.push(t2("passwordSpecial"));
    }
    return errors2;
  };
  const handlePasswordChange = (value) => {
    setPassword(value);
    if (!isLogin) {
      setPasswordErrors(validatePassword(value));
    }
  };
  const handleAuth = async (e2) => {
    e2.preventDefault();
    setLoading(true);
    try {
      if (isLogin) {
        console.log("🔍 Attempting login with:", { email });
        if (!email || !password) {
          throw new Error("Email and password are required");
        }
        const { data, error } = await supabase.auth.signInWithPassword({
          email,
          password
        });
        console.log("📊 Login result:", { data, error });
        if (error) {
          console.error("❌ Login error:", error);
          await ErrorLogger.logError(new Error(`Login failed: ${error.message}`), "LoginForm.handleAuth");
          let errorMessage = error.message;
          if (error.message?.includes("Invalid login credentials")) {
            errorMessage = t2("invalidCredentials") || "Неверный email или пароль";
          } else if (error.message?.includes("Email not confirmed")) {
            errorMessage = t2("emailNotConfirmed") || "Подтвердите email";
          } else if (error.message?.includes("Too many requests")) {
            errorMessage = t2("tooManyRequests") || "Слишком много попыток. Попробуйте позже";
          }
          toast({
            title: t2("errorTitle"),
            description: `${errorMessage} (Code: ${error.status || "unknown"})`,
            variant: "destructive"
          });
        } else {
          console.log("✅ Login successful:", data);
          toast({
            title: t2("welcome"),
            description: t2("loginSuccess")
          });
        }
      } else {
        const errors2 = validatePassword(password);
        if (errors2.length > 0) {
          toast({
            title: t2("validationError"),
            description: errors2.join(". "),
            variant: "destructive"
          });
          return;
        }
        if (password !== confirmPassword) {
          toast({
            title: t2("validationError"),
            description: t2("passwordsNotMatch"),
            variant: "destructive"
          });
          return;
        }
        if (!fullName.trim()) {
          toast({
            title: t2("validationError"),
            description: t2("fillAllFields"),
            variant: "destructive"
          });
          return;
        }
        if (!nickname.trim()) {
          toast({
            title: t2("validationError"),
            description: t2("fillAllFields"),
            variant: "destructive"
          });
          return;
        }
        const { error } = await supabase.auth.signUp({
          email,
          password,
          options: {
            emailRedirectTo: `${window.location.origin}/`,
            data: {
              full_name: fullName,
              nickname
            }
          }
        });
        if (error) {
          toast({
            title: t2("errorTitle"),
            description: error.message,
            variant: "destructive"
          });
        } else {
          toast({
            title: t2("accountCreated"),
            description: t2("checkEmail")
          });
        }
      }
    } catch (error) {
      console.error("❌ Auth error:", error);
      await ErrorLogger.logError(error, "LoginForm.handleAuth.catch");
      const errorMessage = error instanceof Error ? error.message : "Unknown error";
      toast({
        title: t2("errorTitle"),
        description: `${t2("connectionError")}: ${errorMessage}`,
        variant: "destructive"
      });
    } finally {
      setLoading(false);
    }
  };
  const handleGoogleAuth = async () => {
    try {
      const { error } = await supabase.auth.signInWithOAuth({
        provider: "google",
        options: {
          redirectTo: `${window.location.origin}/`
        }
      });
      if (error) {
        toast({
          title: t2("errorTitle"),
          description: error.message,
          variant: "destructive"
        });
      }
    } catch (error) {
      toast({
        title: t2("errorTitle"),
        description: t2("connectionError"),
        variant: "destructive"
      });
    }
  };
  return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: cn("flex flex-col gap-6", className), ...props, children: [
    /* @__PURE__ */ jsxRuntimeExports.jsxs(Card, { className: "relative", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "absolute top-2 right-2 z-10", children: /* @__PURE__ */ jsxRuntimeExports.jsx(LanguageToggle, {}) }),
      /* @__PURE__ */ jsxRuntimeExports.jsxs(CardHeader, { className: "text-center", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "flex justify-center mb-6", children: /* @__PURE__ */ jsxRuntimeExports.jsx("img", { src: "https://i.ibb.co/Cs02JMtj/A-20250622-231910-0000.png", alt: "Logo", className: "w-24 h-auto" }) }),
        /* @__PURE__ */ jsxRuntimeExports.jsx(CardTitle, { className: "text-xl", children: isLogin ? t2("welcomeBack") : t2("createAccountTitle") }),
        /* @__PURE__ */ jsxRuntimeExports.jsx(CardDescription, { children: isLogin ? t2("loginDescription") : t2("registerDescription") })
      ] }),
      /* @__PURE__ */ jsxRuntimeExports.jsx(CardContent, { children: /* @__PURE__ */ jsxRuntimeExports.jsx("form", { onSubmit: handleAuth, children: /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "grid gap-6", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "flex flex-col gap-4", children: /* @__PURE__ */ jsxRuntimeExports.jsxs(
          Button$1,
          {
            onClick: handleGoogleAuth,
            variant: "outline",
            className: "w-full",
            disabled: loading,
            type: "button",
            children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx("svg", { xmlns: "http://www.w3.org/2000/svg", viewBox: "0 0 24 24", className: "w-5 h-5 mr-2", children: /* @__PURE__ */ jsxRuntimeExports.jsx(
                "path",
                {
                  d: "M12.48 10.92v3.28h7.84c-.24 1.84-.853 3.187-1.787 4.133-1.147 1.147-2.933 2.4-6.053 2.4-4.827 0-8.6-3.893-8.6-8.72s3.773-8.72 8.6-8.72c2.6 0 4.507 1.027 5.907 2.347l2.307-2.307C18.747 1.44 16.133 0 12.48 0 5.867 0 .307 5.387.307 12s5.56 12 12.173 12c3.573 0 6.267-1.173 8.373-3.36 2.16-2.16 2.84-5.213 2.84-7.667 0-.76-.053-1.467-.173-2.053H12.48z",
                  fill: "currentColor"
                }
              ) }),
              t2("loginWithGoogle")
            ]
          }
        ) }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "after:border-border relative text-center text-sm after:absolute after:inset-0 after:top-1/2 after:z-0 after:flex after:items-center after:border-t", children: /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "bg-card text-muted-foreground relative z-10 px-2", children: t2("orContinueWith") }) }),
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "grid gap-6", children: [
          !isLogin && /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
            /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "grid gap-3", children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx(Label, { htmlFor: "fullName", children: t2("fullName") }),
              /* @__PURE__ */ jsxRuntimeExports.jsx(
                OptimizedInput,
                {
                  id: "fullName",
                  type: "text",
                  placeholder: t2("fullNamePlaceholder"),
                  value: fullName,
                  onChange: (e2) => setFullName(e2.target.value),
                  required: !isLogin
                }
              )
            ] }),
            /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "grid gap-3", children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx(Label, { htmlFor: "nickname", children: t2("nickname") }),
              /* @__PURE__ */ jsxRuntimeExports.jsx(
                OptimizedInput,
                {
                  id: "nickname",
                  type: "text",
                  placeholder: t2("nicknamePlaceholder"),
                  value: nickname,
                  onChange: (e2) => setNickname(e2.target.value),
                  required: !isLogin
                }
              )
            ] })
          ] }),
          /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "grid gap-2", children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx(Label, { htmlFor: "email", children: t2("email") }),
            /* @__PURE__ */ jsxRuntimeExports.jsx(
              OptimizedInput,
              {
                id: "email",
                placeholder: "name@example.com",
                type: "email",
                autoCapitalize: "none",
                autoComplete: "email",
                autoCorrect: "off",
                value: inputEmail,
                onChange: (e2) => setInputEmail(e2.target.value),
                disabled: loading
              }
            )
          ] }),
          /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "grid gap-2", children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "flex items-center", children: /* @__PURE__ */ jsxRuntimeExports.jsx(Label, { htmlFor: "password", children: t2("password") }) }),
            /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "relative", children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx(
                OptimizedInput,
                {
                  id: "password",
                  type: showPassword ? "text" : "password",
                  value: inputPassword,
                  onChange: (e2) => setInputPassword(e2.target.value),
                  disabled: loading
                }
              ),
              /* @__PURE__ */ jsxRuntimeExports.jsx(
                Button$1,
                {
                  type: "button",
                  variant: "ghost",
                  size: "icon",
                  className: "absolute right-1 top-1/2 h-7 w-7 -translate-y-1/2 text-muted-foreground",
                  onClick: () => setShowPassword(!showPassword),
                  children: showPassword ? /* @__PURE__ */ jsxRuntimeExports.jsx(EyeOff, { className: "h-4 w-4" }) : /* @__PURE__ */ jsxRuntimeExports.jsx(Eye, { className: "h-4 w-4" })
                }
              )
            ] })
          ] }),
          !isLogin && /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
            /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "grid gap-2", children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx(Label, { htmlFor: "confirmPassword", children: t2("confirmPassword") }),
              /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "relative", children: [
                /* @__PURE__ */ jsxRuntimeExports.jsx(
                  OptimizedInput,
                  {
                    id: "confirmPassword",
                    type: showConfirmPassword ? "text" : "password",
                    value: inputConfirmPassword,
                    onChange: (e2) => setInputConfirmPassword(e2.target.value),
                    disabled: loading
                  }
                ),
                /* @__PURE__ */ jsxRuntimeExports.jsx(
                  Button$1,
                  {
                    type: "button",
                    variant: "ghost",
                    size: "icon",
                    className: "absolute right-1 top-1/2 h-7 w-7 -translate-y-1/2 text-muted-foreground",
                    onClick: () => setShowConfirmPassword(!showConfirmPassword),
                    children: showConfirmPassword ? /* @__PURE__ */ jsxRuntimeExports.jsx(EyeOff, { className: "h-4 w-4" }) : /* @__PURE__ */ jsxRuntimeExports.jsx(Eye, { className: "h-4 w-4" })
                  }
                )
              ] })
            ] }),
            passwordErrors.length > 0 && /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "text-destructive text-sm", children: /* @__PURE__ */ jsxRuntimeExports.jsx("ul", { children: passwordErrors.map((error, index2) => /* @__PURE__ */ jsxRuntimeExports.jsx("li", { children: error }, index2)) }) })
          ] }),
          /* @__PURE__ */ jsxRuntimeExports.jsx(Button$1, { type: "submit", className: "w-full", disabled: loading, children: loading ? t2("loading") : isLogin ? t2("loginButton") : t2("registerButton") })
        ] }),
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "text-center text-sm", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "text-muted-foreground", children: isLogin ? t2("noAccount") : t2("hasAccount") }),
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            "button",
            {
              onClick: () => setIsLogin(!isLogin),
              className: "underline underline-offset-4 ml-1",
              disabled: loading,
              type: "button",
              children: isLogin ? t2("signUp") : t2("signIn")
            }
          )
        ] })
      ] }) }) })
    ] }),
    /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "text-muted-foreground text-center text-xs text-balance", children: [
      t2("termsText"),
      " ",
      " ",
      /* @__PURE__ */ jsxRuntimeExports.jsx("button", { className: "underline underline-offset-4", type: "button", onClick: () => setOpenTerms(true), children: t2("termsOfService") }),
      " ",
      t2("and"),
      " ",
      " ",
      /* @__PURE__ */ jsxRuntimeExports.jsx("button", { className: "underline underline-offset-4", type: "button", onClick: () => setOpenPrivacy(true), children: t2("privacyPolicy") }),
      "."
    ] }),
    /* @__PURE__ */ jsxRuntimeExports.jsx(
      TermsOfServiceDialog,
      {
        open: openTerms,
        onOpenChange: setOpenTerms
      }
    ),
    /* @__PURE__ */ jsxRuntimeExports.jsx(
      EnhancedPrivacyPolicyDialog,
      {
        open: openPrivacy,
        onOpenChange: setOpenPrivacy
      }
    )
  ] });
}
const SemipolarSpinner = ({
  size: size2 = 65,
  color: color2 = "#ff1d5e",
  className
}) => {
  const rings = Array(5).fill(null);
  return /* @__PURE__ */ jsxRuntimeExports.jsx(
    "div",
    {
      className: cn("relative", className),
      style: {
        height: size2,
        width: size2
      },
      children: rings.map((_2, index2) => /* @__PURE__ */ jsxRuntimeExports.jsx(
        "div",
        {
          className: "absolute rounded-full",
          style: {
            height: `calc(${size2}px - ${size2}px * 0.2 * ${index2})`,
            width: `calc(${size2}px - ${size2}px * 0.2 * ${index2})`,
            top: `calc(${size2}px * 0.1 * ${index2})`,
            left: `calc(${size2}px * 0.1 * ${index2})`,
            border: `calc(${size2}px * 0.05) solid transparent`,
            borderTopColor: color2,
            borderLeftColor: color2,
            animation: "semipolar-spinner-animation 2s infinite",
            animationDelay: `calc(2000ms * 0.1 * ${4 - index2})`,
            zIndex: 5 - index2
          }
        },
        index2
      ))
    }
  );
};
const AuthScreen = () => {
  const navigate = useNavigate();
  const { t: t2 } = useLanguage$1();
  const [loading, setLoading] = React.useState(true);
  reactExports.useEffect(() => {
    const checkUser = async () => {
      const { data: { session } } = await supabase.auth.getSession();
      if (session) {
        navigate("/main");
      }
      setLoading(false);
    };
    checkUser();
    const { data: { subscription } } = supabase.auth.onAuthStateChange((event, session) => {
      if (session) {
        navigate("/main");
      }
      setLoading(false);
    });
    return () => subscription.unsubscribe();
  }, [navigate]);
  return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "min-h-svh bg-gradient-to-br from-dark to-dark-light flex flex-col items-center justify-center gap-6 p-6 md:p-10", children: [
    loading && /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "absolute inset-0 bg-black/50 backdrop-blur-sm flex items-center justify-center z-50", children: /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "text-center", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx(SemipolarSpinner, { size: 60, color: "#ff1d5e", className: "mb-4" }),
      /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: "text-white text-sm", children: t2("auth.authenticating") })
    ] }) }),
    /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "flex w-full max-w-sm flex-col gap-6", children: /* @__PURE__ */ jsxRuntimeExports.jsx(LoginForm, {}) })
  ] });
};
const NotFound = () => {
  const location2 = useLocation();
  reactExports.useEffect(() => {
    console.error(
      "404 Error: User attempted to access non-existent route:",
      location2.pathname
    );
  }, [location2.pathname]);
  return /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "min-h-screen flex items-center justify-center bg-gray-100", children: /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "text-center", children: [
    /* @__PURE__ */ jsxRuntimeExports.jsx("h1", { className: "text-4xl font-bold mb-4", children: "404" }),
    /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: "text-xl text-gray-600 mb-4", children: "Oops! Page not found" }),
    /* @__PURE__ */ jsxRuntimeExports.jsx("a", { href: "/", className: "text-blue-500 hover:text-blue-700 underline", children: "Return to Home" })
  ] }) });
};
/**
 * anime.js - ESM
 * @version v4.0.2
 * @author Julian Garnier
 * @license MIT
 * @copyright (c) 2025 Julian Garnier
 * @see https://animejs.com
 */
const isBrowser$1 = typeof window !== "undefined";
const win = isBrowser$1 ? window : null;
const doc = isBrowser$1 ? document : null;
const tweenTypes = {
  OBJECT: 0,
  ATTRIBUTE: 1,
  CSS: 2,
  TRANSFORM: 3,
  CSS_VAR: 4
};
const valueTypes = {
  NUMBER: 0,
  UNIT: 1,
  COLOR: 2,
  COMPLEX: 3
};
const tickModes = {
  NONE: 0,
  AUTO: 1,
  FORCE: 2
};
const compositionTypes = {
  replace: 0,
  none: 1,
  blend: 2
};
const isRegisteredTargetSymbol = Symbol();
const isDomSymbol = Symbol();
const isSvgSymbol = Symbol();
const transformsSymbol = Symbol();
const proxyTargetSymbol = Symbol();
const minValue = 1e-11;
const maxValue = 1e12;
const K = 1e3;
const maxFps = 120;
const emptyString = "";
const shortTransforms = /* @__PURE__ */ new Map();
shortTransforms.set("x", "translateX");
shortTransforms.set("y", "translateY");
shortTransforms.set("z", "translateZ");
const validTransforms = [
  "translateX",
  "translateY",
  "translateZ",
  "rotate",
  "rotateX",
  "rotateY",
  "rotateZ",
  "scale",
  "scaleX",
  "scaleY",
  "scaleZ",
  "skew",
  "skewX",
  "skewY",
  "perspective",
  "matrix",
  "matrix3d"
];
const transformsFragmentStrings = validTransforms.reduce((a2, v2) => ({ ...a2, [v2]: v2 + "(" }), {});
const noop$3 = () => {
};
const hexTestRgx = /(^#([\da-f]{3}){1,2}$)|(^#([\da-f]{4}){1,2}$)/i;
const rgbExecRgx = /rgb\(\s*(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*\)/i;
const rgbaExecRgx = /rgba\(\s*(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*,\s*(-?\d+|-?\d*.\d+)\s*\)/i;
const hslExecRgx = /hsl\(\s*(-?\d+|-?\d*.\d+)\s*,\s*(-?\d+|-?\d*.\d+)%\s*,\s*(-?\d+|-?\d*.\d+)%\s*\)/i;
const hslaExecRgx = /hsla\(\s*(-?\d+|-?\d*.\d+)\s*,\s*(-?\d+|-?\d*.\d+)%\s*,\s*(-?\d+|-?\d*.\d+)%\s*,\s*(-?\d+|-?\d*.\d+)\s*\)/i;
const digitWithExponentRgx = /[-+]?\d*\.?\d+(?:e[-+]?\d)?/gi;
const unitsExecRgx = /^([-+]?\d*\.?\d+(?:e[-+]?\d+)?)([a-z]+|%)$/i;
const lowerCaseRgx = /([a-z])([A-Z])/g;
const transformsExecRgx = /(\w+)(\([^)]+\)+)/g;
const defaults = {
  id: null,
  keyframes: null,
  playbackEase: null,
  playbackRate: 1,
  frameRate: maxFps,
  loop: 0,
  reversed: false,
  alternate: false,
  autoplay: true,
  duration: K,
  delay: 0,
  loopDelay: 0,
  ease: "out(2)",
  composition: compositionTypes.replace,
  modifier: (v2) => v2,
  onBegin: noop$3,
  onBeforeUpdate: noop$3,
  onUpdate: noop$3,
  onLoop: noop$3,
  onPause: noop$3,
  onComplete: noop$3,
  onRender: noop$3
};
const globals = {
  /** @type {DefaultsParams} */
  defaults,
  /** @type {Document|DOMTarget} */
  root: doc,
  /** @type {Scope} */
  scope: null,
  /** @type {Number} */
  precision: 4,
  /** @type {Number} */
  timeScale: 1,
  /** @type {Number} */
  tickThreshold: 200
};
const globalVersions = { version: "4.0.2", engine: null };
if (isBrowser$1) {
  if (!win.AnimeJS) win.AnimeJS = [];
  win.AnimeJS.push(globalVersions);
}
const toLowerCase = (str) => str.replace(lowerCaseRgx, "$1-$2").toLowerCase();
const stringStartsWith = (str, sub) => str.indexOf(sub) === 0;
const now = Date.now;
const isArr = Array.isArray;
const isObj = (a2) => a2 && a2.constructor === Object;
const isNum = (a2) => typeof a2 === "number" && !isNaN(a2);
const isStr = (a2) => typeof a2 === "string";
const isFnc = (a2) => typeof a2 === "function";
const isUnd = (a2) => typeof a2 === "undefined";
const isNil = (a2) => isUnd(a2) || a2 === null;
const isSvg = (a2) => isBrowser$1 && a2 instanceof SVGElement;
const isHex = (a2) => hexTestRgx.test(a2);
const isRgb = (a2) => stringStartsWith(a2, "rgb");
const isHsl = (a2) => stringStartsWith(a2, "hsl");
const isCol = (a2) => isHex(a2) || isRgb(a2) || isHsl(a2);
const isKey = (a2) => !globals.defaults.hasOwnProperty(a2);
const parseNumber = (str) => isStr(str) ? parseFloat(
  /** @type {String} */
  str
) : (
  /** @type {Number} */
  str
);
const pow = Math.pow;
const sqrt = Math.sqrt;
const sin = Math.sin;
const cos = Math.cos;
const abs$1 = Math.abs;
const ceil = Math.ceil;
const floor = Math.floor;
const asin = Math.asin;
const PI = Math.PI;
const _round = Math.round;
const clamp$1 = (v2, min2, max2) => v2 < min2 ? min2 : v2 > max2 ? max2 : v2;
const powCache = {};
const round$1 = (v2, decimalLength) => {
  if (decimalLength < 0) return v2;
  if (!decimalLength) return _round(v2);
  let p2 = powCache[decimalLength];
  if (!p2) p2 = powCache[decimalLength] = 10 ** decimalLength;
  return _round(v2 * p2) / p2;
};
const interpolate = (start, end, progress2) => start + (end - start) * progress2;
const clampInfinity = (v2) => v2 === Infinity ? maxValue : v2 === -Infinity ? -1e12 : v2;
const normalizeTime = (v2) => v2 <= minValue ? minValue : clampInfinity(round$1(v2, 11));
const cloneArray = (a2) => isArr(a2) ? [...a2] : a2;
const mergeObjects = (o1, o2) => {
  const merged = (
    /** @type {T & U} */
    { ...o1 }
  );
  for (let p2 in o2) {
    const o1p = (
      /** @type {T & U} */
      o1[p2]
    );
    merged[p2] = isUnd(o1p) ? (
      /** @type {T & U} */
      o2[p2]
    ) : o1p;
  }
  return merged;
};
const forEachChildren = (parent2, callback, reverse, prevProp = "_prev", nextProp = "_next") => {
  let next2 = parent2._head;
  let adjustedNextProp = nextProp;
  if (reverse) {
    next2 = parent2._tail;
    adjustedNextProp = prevProp;
  }
  while (next2) {
    const currentNext = next2[adjustedNextProp];
    callback(next2);
    next2 = currentNext;
  }
};
const removeChild = (parent2, child, prevProp = "_prev", nextProp = "_next") => {
  const prev2 = child[prevProp];
  const next2 = child[nextProp];
  prev2 ? prev2[nextProp] = next2 : parent2._head = next2;
  next2 ? next2[prevProp] = prev2 : parent2._tail = prev2;
  child[prevProp] = null;
  child[nextProp] = null;
};
const addChild = (parent2, child, sortMethod, prevProp = "_prev", nextProp = "_next") => {
  let prev2 = parent2._tail;
  while (prev2 && sortMethod && sortMethod(prev2, child)) prev2 = prev2[prevProp];
  const next2 = prev2 ? prev2[nextProp] : parent2._head;
  prev2 ? prev2[nextProp] = child : parent2._head = child;
  next2 ? next2[prevProp] = child : parent2._tail = child;
  child[prevProp] = prev2;
  child[nextProp] = next2;
};
class Clock {
  /** @param {Number} [initTime] */
  constructor(initTime = 0) {
    this.deltaTime = 0;
    this._currentTime = initTime;
    this._elapsedTime = initTime;
    this._startTime = initTime;
    this._lastTime = initTime;
    this._scheduledTime = 0;
    this._frameDuration = round$1(K / maxFps, 0);
    this._fps = maxFps;
    this._speed = 1;
    this._hasChildren = false;
    this._head = null;
    this._tail = null;
  }
  get fps() {
    return this._fps;
  }
  set fps(frameRate) {
    const previousFrameDuration = this._frameDuration;
    const fr = +frameRate;
    const fps = fr < minValue ? minValue : fr;
    const frameDuration = round$1(K / fps, 0);
    this._fps = fps;
    this._frameDuration = frameDuration;
    this._scheduledTime += frameDuration - previousFrameDuration;
  }
  get speed() {
    return this._speed;
  }
  set speed(playbackRate) {
    const pbr = +playbackRate;
    this._speed = pbr < minValue ? minValue : pbr;
  }
  /**
   * @param  {Number} time
   * @return {tickModes}
   */
  requestTick(time2) {
    const scheduledTime = this._scheduledTime;
    const elapsedTime = this._elapsedTime;
    this._elapsedTime += time2 - elapsedTime;
    if (elapsedTime < scheduledTime) return tickModes.NONE;
    const frameDuration = this._frameDuration;
    const frameDelta = elapsedTime - scheduledTime;
    this._scheduledTime += frameDelta < frameDuration ? frameDuration : frameDelta;
    return tickModes.AUTO;
  }
  /**
   * @param  {Number} time
   * @return {Number}
   */
  computeDeltaTime(time2) {
    const delta = time2 - this._lastTime;
    this.deltaTime = delta;
    this._lastTime = time2;
    return delta;
  }
}
const render = (tickable, time2, muteCallbacks, internalRender, tickMode) => {
  const parent2 = tickable.parent;
  const duration2 = tickable.duration;
  const completed = tickable.completed;
  const iterationDuration = tickable.iterationDuration;
  const iterationCount = tickable.iterationCount;
  const _currentIteration = tickable._currentIteration;
  const _loopDelay = tickable._loopDelay;
  const _reversed = tickable._reversed;
  const _alternate = tickable._alternate;
  const _hasChildren = tickable._hasChildren;
  const tickableDelay = tickable._delay;
  const tickablePrevAbsoluteTime = tickable._currentTime;
  const tickableEndTime = tickableDelay + iterationDuration;
  const tickableAbsoluteTime = time2 - tickableDelay;
  const tickablePrevTime = clamp$1(tickablePrevAbsoluteTime, -tickableDelay, duration2);
  const tickableCurrentTime = clamp$1(tickableAbsoluteTime, -tickableDelay, duration2);
  const deltaTime = tickableAbsoluteTime - tickablePrevAbsoluteTime;
  const isCurrentTimeAboveZero = tickableCurrentTime > 0;
  const isCurrentTimeEqualOrAboveDuration = tickableCurrentTime >= duration2;
  const isSetter = duration2 <= minValue;
  const forcedTick = tickMode === tickModes.FORCE;
  let isOdd = 0;
  let iterationElapsedTime = tickableAbsoluteTime;
  let hasRendered = 0;
  if (iterationCount > 1) {
    const currentIteration = ~~(tickableCurrentTime / (iterationDuration + (isCurrentTimeEqualOrAboveDuration ? 0 : _loopDelay)));
    tickable._currentIteration = clamp$1(currentIteration, 0, iterationCount);
    if (isCurrentTimeEqualOrAboveDuration) tickable._currentIteration--;
    isOdd = tickable._currentIteration % 2;
    iterationElapsedTime = tickableCurrentTime % (iterationDuration + _loopDelay) || 0;
  }
  const isReversed = _reversed ^ (_alternate && isOdd);
  const _ease = (
    /** @type {Renderable} */
    tickable._ease
  );
  let iterationTime = isCurrentTimeEqualOrAboveDuration ? isReversed ? 0 : duration2 : isReversed ? iterationDuration - iterationElapsedTime : iterationElapsedTime;
  if (_ease) iterationTime = iterationDuration * _ease(iterationTime / iterationDuration) || 0;
  const isRunningBackwards = (parent2 ? parent2.backwards : tickableAbsoluteTime < tickablePrevAbsoluteTime) ? !isReversed : !!isReversed;
  tickable._currentTime = tickableAbsoluteTime;
  tickable._iterationTime = iterationTime;
  tickable.backwards = isRunningBackwards;
  if (isCurrentTimeAboveZero && !tickable.began) {
    tickable.began = true;
    if (!muteCallbacks && !(parent2 && (isRunningBackwards || !parent2.began))) {
      tickable.onBegin(
        /** @type {CallbackArgument} */
        tickable
      );
    }
  } else if (tickableAbsoluteTime <= 0) {
    tickable.began = false;
  }
  if (!muteCallbacks && !_hasChildren && isCurrentTimeAboveZero && tickable._currentIteration !== _currentIteration) {
    tickable.onLoop(
      /** @type {CallbackArgument} */
      tickable
    );
  }
  if (forcedTick || tickMode === tickModes.AUTO && (time2 >= tickableDelay && time2 <= tickableEndTime || // Normal render
  time2 <= tickableDelay && tickablePrevTime > tickableDelay || // Playhead is before the animation start time so make sure the animation is at its initial state
  time2 >= tickableEndTime && tickablePrevTime !== duration2) || iterationTime >= tickableEndTime && tickablePrevTime !== duration2 || iterationTime <= tickableDelay && tickablePrevTime > 0 || time2 <= tickablePrevTime && tickablePrevTime === duration2 && completed || // Force a render if a seek occurs on an completed animation
  isCurrentTimeEqualOrAboveDuration && !completed && isSetter) {
    if (isCurrentTimeAboveZero) {
      tickable.computeDeltaTime(tickablePrevTime);
      if (!muteCallbacks) tickable.onBeforeUpdate(
        /** @type {CallbackArgument} */
        tickable
      );
    }
    if (!_hasChildren) {
      const forcedRender = forcedTick || (isRunningBackwards ? deltaTime * -1 : deltaTime) >= globals.tickThreshold;
      const absoluteTime = tickable._offset + (parent2 ? parent2._offset : 0) + tickableDelay + iterationTime;
      let tween = (
        /** @type {Tween} */
        /** @type {JSAnimation} */
        tickable._head
      );
      let tweenTarget;
      let tweenStyle;
      let tweenTargetTransforms;
      let tweenTargetTransformsProperties;
      let tweenTransformsNeedUpdate = 0;
      while (tween) {
        const tweenComposition = tween._composition;
        const tweenCurrentTime = tween._currentTime;
        const tweenChangeDuration = tween._changeDuration;
        const tweenAbsEndTime = tween._absoluteStartTime + tween._changeDuration;
        const tweenNextRep = tween._nextRep;
        const tweenPrevRep = tween._prevRep;
        const tweenHasComposition = tweenComposition !== compositionTypes.none;
        if ((forcedRender || (tweenCurrentTime !== tweenChangeDuration || absoluteTime <= tweenAbsEndTime + (tweenNextRep ? tweenNextRep._delay : 0)) && (tweenCurrentTime !== 0 || absoluteTime >= tween._absoluteStartTime)) && (!tweenHasComposition || !tween._isOverridden && (!tween._isOverlapped || absoluteTime <= tweenAbsEndTime) && (!tweenNextRep || (tweenNextRep._isOverridden || absoluteTime <= tweenNextRep._absoluteStartTime)) && (!tweenPrevRep || (tweenPrevRep._isOverridden || absoluteTime >= tweenPrevRep._absoluteStartTime + tweenPrevRep._changeDuration + tween._delay)))) {
          const tweenNewTime = tween._currentTime = clamp$1(iterationTime - tween._startTime, 0, tweenChangeDuration);
          const tweenProgress = tween._ease(tweenNewTime / tween._updateDuration);
          const tweenModifier = tween._modifier;
          const tweenValueType = tween._valueType;
          const tweenType = tween._tweenType;
          const tweenIsObject = tweenType === tweenTypes.OBJECT;
          const tweenIsNumber = tweenValueType === valueTypes.NUMBER;
          const tweenPrecision = tweenIsNumber && tweenIsObject || tweenProgress === 0 || tweenProgress === 1 ? -1 : globals.precision;
          let value;
          let number2;
          if (tweenIsNumber) {
            value = number2 = /** @type {Number} */
            tweenModifier(round$1(interpolate(tween._fromNumber, tween._toNumber, tweenProgress), tweenPrecision));
          } else if (tweenValueType === valueTypes.UNIT) {
            number2 = /** @type {Number} */
            tweenModifier(round$1(interpolate(tween._fromNumber, tween._toNumber, tweenProgress), tweenPrecision));
            value = `${number2}${tween._unit}`;
          } else if (tweenValueType === valueTypes.COLOR) {
            const fn = tween._fromNumbers;
            const tn = tween._toNumbers;
            const r2 = round$1(clamp$1(
              /** @type {Number} */
              tweenModifier(interpolate(fn[0], tn[0], tweenProgress)),
              0,
              255
            ), 0);
            const g2 = round$1(clamp$1(
              /** @type {Number} */
              tweenModifier(interpolate(fn[1], tn[1], tweenProgress)),
              0,
              255
            ), 0);
            const b2 = round$1(clamp$1(
              /** @type {Number} */
              tweenModifier(interpolate(fn[2], tn[2], tweenProgress)),
              0,
              255
            ), 0);
            const a2 = clamp$1(
              /** @type {Number} */
              tweenModifier(round$1(interpolate(fn[3], tn[3], tweenProgress), tweenPrecision)),
              0,
              1
            );
            value = `rgba(${r2},${g2},${b2},${a2})`;
            if (tweenHasComposition) {
              const ns = tween._numbers;
              ns[0] = r2;
              ns[1] = g2;
              ns[2] = b2;
              ns[3] = a2;
            }
          } else if (tweenValueType === valueTypes.COMPLEX) {
            value = tween._strings[0];
            for (let j2 = 0, l2 = tween._toNumbers.length; j2 < l2; j2++) {
              const n2 = (
                /** @type {Number} */
                tweenModifier(round$1(interpolate(tween._fromNumbers[j2], tween._toNumbers[j2], tweenProgress), tweenPrecision))
              );
              const s = tween._strings[j2 + 1];
              value += `${s ? n2 + s : n2}`;
              if (tweenHasComposition) {
                tween._numbers[j2] = n2;
              }
            }
          }
          if (tweenHasComposition) {
            tween._number = number2;
          }
          if (!internalRender && tweenComposition !== compositionTypes.blend) {
            const tweenProperty = tween.property;
            tweenTarget = tween.target;
            if (tweenIsObject) {
              tweenTarget[tweenProperty] = value;
            } else if (tweenType === tweenTypes.ATTRIBUTE) {
              tweenTarget.setAttribute(
                tweenProperty,
                /** @type {String} */
                value
              );
            } else {
              tweenStyle = /** @type {DOMTarget} */
              tweenTarget.style;
              if (tweenType === tweenTypes.TRANSFORM) {
                if (tweenTarget !== tweenTargetTransforms) {
                  tweenTargetTransforms = tweenTarget;
                  tweenTargetTransformsProperties = tweenTarget[transformsSymbol];
                }
                tweenTargetTransformsProperties[tweenProperty] = value;
                tweenTransformsNeedUpdate = 1;
              } else if (tweenType === tweenTypes.CSS) {
                tweenStyle[tweenProperty] = value;
              } else if (tweenType === tweenTypes.CSS_VAR) {
                tweenStyle.setProperty(
                  tweenProperty,
                  /** @type {String} */
                  value
                );
              }
            }
            if (isCurrentTimeAboveZero) hasRendered = 1;
          } else {
            tween._value = value;
          }
        }
        if (tweenTransformsNeedUpdate && tween._renderTransforms) {
          let str = emptyString;
          for (let key2 in tweenTargetTransformsProperties) {
            str += `${transformsFragmentStrings[key2]}${tweenTargetTransformsProperties[key2]}) `;
          }
          tweenStyle.transform = str;
          tweenTransformsNeedUpdate = 0;
        }
        tween = tween._next;
      }
      if (!muteCallbacks && hasRendered) {
        tickable.onRender(
          /** @type {JSAnimation} */
          tickable
        );
      }
    }
    if (!muteCallbacks && isCurrentTimeAboveZero) {
      tickable.onUpdate(
        /** @type {CallbackArgument} */
        tickable
      );
    }
  }
  if (parent2 && isSetter) {
    if (!muteCallbacks && (parent2.began && !isRunningBackwards && tickableAbsoluteTime >= duration2 && !completed || isRunningBackwards && tickableAbsoluteTime <= minValue && completed)) {
      tickable.onComplete(
        /** @type {CallbackArgument} */
        tickable
      );
      tickable.completed = !isRunningBackwards;
    }
  } else if (isCurrentTimeAboveZero && isCurrentTimeEqualOrAboveDuration) {
    if (iterationCount === Infinity) {
      tickable._startTime += tickable.duration;
    } else if (tickable._currentIteration >= iterationCount - 1) {
      tickable.paused = true;
      if (!completed && !_hasChildren) {
        tickable.completed = true;
        if (!muteCallbacks && !(parent2 && (isRunningBackwards || !parent2.began))) {
          tickable.onComplete(
            /** @type {CallbackArgument} */
            tickable
          );
          tickable._resolve(
            /** @type {CallbackArgument} */
            tickable
          );
        }
      }
    }
  } else {
    tickable.completed = false;
  }
  return hasRendered;
};
const tick = (tickable, time2, muteCallbacks, internalRender, tickMode) => {
  const _currentIteration = tickable._currentIteration;
  render(tickable, time2, muteCallbacks, internalRender, tickMode);
  if (tickable._hasChildren) {
    const tl = (
      /** @type {Timeline} */
      tickable
    );
    const tlIsRunningBackwards = tl.backwards;
    const tlChildrenTime = internalRender ? time2 : tl._iterationTime;
    const tlCildrenTickTime = now();
    let tlChildrenHasRendered = 0;
    let tlChildrenHaveCompleted = true;
    if (!internalRender && tl._currentIteration !== _currentIteration) {
      const tlIterationDuration = tl.iterationDuration;
      forEachChildren(tl, (child) => {
        if (!tlIsRunningBackwards) {
          if (!child.completed && !child.backwards && child._currentTime < child.iterationDuration) {
            render(child, tlIterationDuration, muteCallbacks, 1, tickModes.FORCE);
          }
          child.began = false;
          child.completed = false;
        } else {
          const childDuration = child.duration;
          const childStartTime = child._offset + child._delay;
          const childEndTime = childStartTime + childDuration;
          if (!muteCallbacks && childDuration <= minValue && (!childStartTime || childEndTime === tlIterationDuration)) {
            child.onComplete(child);
          }
        }
      });
      if (!muteCallbacks) tl.onLoop(
        /** @type {CallbackArgument} */
        tl
      );
    }
    forEachChildren(tl, (child) => {
      const childTime = round$1((tlChildrenTime - child._offset) * child._speed, 12);
      const childTickMode = child._fps < tl._fps ? child.requestTick(tlCildrenTickTime) : tickMode;
      tlChildrenHasRendered += render(child, childTime, muteCallbacks, internalRender, childTickMode);
      if (!child.completed && tlChildrenHaveCompleted) tlChildrenHaveCompleted = false;
    }, tlIsRunningBackwards);
    if (!muteCallbacks && tlChildrenHasRendered) tl.onRender(
      /** @type {CallbackArgument} */
      tl
    );
    if (tlChildrenHaveCompleted && tl._currentTime >= tl.duration) {
      tl.paused = true;
      if (!tl.completed) {
        tl.completed = true;
        if (!muteCallbacks) {
          tl.onComplete(
            /** @type {CallbackArgument} */
            tl
          );
          tl._resolve(
            /** @type {CallbackArgument} */
            tl
          );
        }
      }
    }
  }
};
const additive = {
  animation: null,
  update: noop$3
};
const addAdditiveAnimation = (lookups2) => {
  let animation = additive.animation;
  if (!animation) {
    animation = {
      duration: minValue,
      computeDeltaTime: noop$3,
      _offset: 0,
      _delay: 0,
      _head: null,
      _tail: null
    };
    additive.animation = animation;
    additive.update = () => {
      lookups2.forEach((propertyAnimation) => {
        for (let propertyName in propertyAnimation) {
          const tweens = propertyAnimation[propertyName];
          const lookupTween = tweens._head;
          if (lookupTween) {
            const valueType = lookupTween._valueType;
            const additiveValues = valueType === valueTypes.COMPLEX || valueType === valueTypes.COLOR ? cloneArray(lookupTween._fromNumbers) : null;
            let additiveValue = lookupTween._fromNumber;
            let tween = tweens._tail;
            while (tween && tween !== lookupTween) {
              if (additiveValues) {
                for (let i2 = 0, l2 = tween._numbers.length; i2 < l2; i2++) additiveValues[i2] += tween._numbers[i2];
              } else {
                additiveValue += tween._number;
              }
              tween = tween._prevAdd;
            }
            lookupTween._toNumber = additiveValue;
            lookupTween._toNumbers = additiveValues;
          }
        }
      });
      render(animation, 1, 1, 0, tickModes.FORCE);
    };
  }
  return animation;
};
const engineTickMethod = isBrowser$1 ? requestAnimationFrame : setImmediate;
const engineCancelMethod = isBrowser$1 ? cancelAnimationFrame : clearImmediate;
class Engine extends Clock {
  /** @param {Number} [initTime] */
  constructor(initTime) {
    super(initTime);
    this.useDefaultMainLoop = true;
    this.pauseOnDocumentHidden = true;
    this.defaults = defaults;
    this.paused = isBrowser$1 && doc.hidden ? true : false;
    this.reqId = null;
  }
  update() {
    const time2 = this._currentTime = now();
    if (this.requestTick(time2)) {
      this.computeDeltaTime(time2);
      const engineSpeed = this._speed;
      const engineFps = this._fps;
      let activeTickable = (
        /** @type {Tickable} */
        this._head
      );
      while (activeTickable) {
        const nextTickable = activeTickable._next;
        if (!activeTickable.paused) {
          tick(
            activeTickable,
            (time2 - activeTickable._startTime) * activeTickable._speed * engineSpeed,
            0,
            // !muteCallbacks
            0,
            // !internalRender
            activeTickable._fps < engineFps ? activeTickable.requestTick(time2) : tickModes.AUTO
          );
        } else {
          removeChild(this, activeTickable);
          this._hasChildren = !!this._tail;
          activeTickable._running = false;
          if (activeTickable.completed && !activeTickable._cancelled) {
            activeTickable.cancel();
          }
        }
        activeTickable = nextTickable;
      }
      additive.update();
    }
  }
  wake() {
    if (this.useDefaultMainLoop && !this.reqId && !this.paused) {
      this.reqId = engineTickMethod(tickEngine);
    }
    return this;
  }
  pause() {
    this.paused = true;
    return killEngine();
  }
  resume() {
    if (!this.paused) return;
    this.paused = false;
    forEachChildren(this, (child) => child.resetTime());
    return this.wake();
  }
  // Getter and setter for speed
  get speed() {
    return this._speed * (globals.timeScale === 1 ? 1 : K);
  }
  set speed(playbackRate) {
    this._speed = playbackRate * globals.timeScale;
    forEachChildren(this, (child) => child.speed = child._speed);
  }
  // Getter and setter for timeUnit
  get timeUnit() {
    return globals.timeScale === 1 ? "ms" : "s";
  }
  set timeUnit(unit) {
    const secondsScale = 1e-3;
    const isSecond = unit === "s";
    const newScale = isSecond ? secondsScale : 1;
    if (globals.timeScale !== newScale) {
      globals.timeScale = newScale;
      globals.tickThreshold = 200 * newScale;
      const scaleFactor = isSecond ? secondsScale : K;
      this.defaults.duration *= scaleFactor;
      this._speed *= scaleFactor;
    }
  }
  // Getter and setter for precision
  get precision() {
    return globals.precision;
  }
  set precision(precision) {
    globals.precision = precision;
  }
}
const engine = /* @__PURE__ */ (() => {
  const engine2 = new Engine(now());
  if (isBrowser$1) {
    globalVersions.engine = engine2;
    doc.addEventListener("visibilitychange", () => {
      if (!engine2.pauseOnDocumentHidden) return;
      doc.hidden ? engine2.pause() : engine2.resume();
    });
  }
  return engine2;
})();
const tickEngine = () => {
  if (engine._head) {
    engine.reqId = engineTickMethod(tickEngine);
    engine.update();
  } else {
    engine.reqId = 0;
  }
};
const killEngine = () => {
  engineCancelMethod(
    /** @type {NodeJS.Immediate & Number} */
    engine.reqId
  );
  engine.reqId = 0;
  return engine;
};
const parseInlineTransforms = (target, propName, animationInlineStyles) => {
  const inlineTransforms = target.style.transform;
  let inlinedStylesPropertyValue;
  if (inlineTransforms) {
    const cachedTransforms = target[transformsSymbol];
    let t2;
    while (t2 = transformsExecRgx.exec(inlineTransforms)) {
      const inlinePropertyName = t2[1];
      const inlinePropertyValue = t2[2].slice(1, -1);
      cachedTransforms[inlinePropertyName] = inlinePropertyValue;
      if (inlinePropertyName === propName) {
        inlinedStylesPropertyValue = inlinePropertyValue;
        if (animationInlineStyles) {
          animationInlineStyles[propName] = inlinePropertyValue;
        }
      }
    }
  }
  return inlineTransforms && !isUnd(inlinedStylesPropertyValue) ? inlinedStylesPropertyValue : stringStartsWith(propName, "scale") ? "1" : stringStartsWith(propName, "rotate") || stringStartsWith(propName, "skew") ? "0deg" : "0px";
};
function getNodeList(v2) {
  const n2 = isStr(v2) ? globals.root.querySelectorAll(v2) : v2;
  if (n2 instanceof NodeList || n2 instanceof HTMLCollection) return n2;
}
function parseTargets(targets) {
  if (isNil(targets)) return (
    /** @type {TargetsArray} */
    []
  );
  if (isArr(targets)) {
    const flattened = targets.flat(Infinity);
    const parsed = [];
    for (let i2 = 0, l2 = flattened.length; i2 < l2; i2++) {
      const item = flattened[i2];
      if (!isNil(item)) {
        const nodeList2 = getNodeList(item);
        if (nodeList2) {
          for (let j2 = 0, jl = nodeList2.length; j2 < jl; j2++) {
            const subItem = nodeList2[j2];
            if (!isNil(subItem)) {
              let isDuplicate = false;
              for (let k2 = 0, kl = parsed.length; k2 < kl; k2++) {
                if (parsed[k2] === subItem) {
                  isDuplicate = true;
                  break;
                }
              }
              if (!isDuplicate) {
                parsed.push(subItem);
              }
            }
          }
        } else {
          let isDuplicate = false;
          for (let j2 = 0, jl = parsed.length; j2 < jl; j2++) {
            if (parsed[j2] === item) {
              isDuplicate = true;
              break;
            }
          }
          if (!isDuplicate) {
            parsed.push(item);
          }
        }
      }
    }
    return parsed;
  }
  if (!isBrowser$1) return (
    /** @type {JSTargetsArray} */
    [targets]
  );
  const nodeList = getNodeList(targets);
  if (nodeList) return (
    /** @type {DOMTargetsArray} */
    Array.from(nodeList)
  );
  return (
    /** @type {TargetsArray} */
    [targets]
  );
}
function registerTargets(targets) {
  const parsedTargetsArray = parseTargets(targets);
  const parsedTargetsLength = parsedTargetsArray.length;
  if (parsedTargetsLength) {
    for (let i2 = 0; i2 < parsedTargetsLength; i2++) {
      const target = parsedTargetsArray[i2];
      if (!target[isRegisteredTargetSymbol]) {
        target[isRegisteredTargetSymbol] = true;
        const isSvgType = isSvg(target);
        const isDom = (
          /** @type {DOMTarget} */
          target.nodeType || isSvgType
        );
        if (isDom) {
          target[isDomSymbol] = true;
          target[isSvgSymbol] = isSvgType;
          target[transformsSymbol] = {};
        }
      }
    }
  }
  return parsedTargetsArray;
}
const cssReservedProperties = ["opacity", "rotate", "overflow", "color"];
const isValidSVGAttribute = (el, propertyName) => {
  if (cssReservedProperties.includes(propertyName)) return false;
  if (el.getAttribute(propertyName) || propertyName in el) {
    if (propertyName === "scale") {
      const elParentNode = (
        /** @type {SVGGeometryElement} */
        /** @type {DOMTarget} */
        el.parentNode
      );
      return elParentNode && elParentNode.tagName === "filter";
    }
    return true;
  }
};
const rgbToRgba = (rgbValue) => {
  const rgba2 = rgbExecRgx.exec(rgbValue) || rgbaExecRgx.exec(rgbValue);
  const a2 = !isUnd(rgba2[4]) ? +rgba2[4] : 1;
  return [
    +rgba2[1],
    +rgba2[2],
    +rgba2[3],
    a2
  ];
};
const hexToRgba = (hexValue) => {
  const hexLength = hexValue.length;
  const isShort = hexLength === 4 || hexLength === 5;
  return [
    +("0x" + hexValue[1] + hexValue[isShort ? 1 : 2]),
    +("0x" + hexValue[isShort ? 2 : 3] + hexValue[isShort ? 2 : 4]),
    +("0x" + hexValue[isShort ? 3 : 5] + hexValue[isShort ? 3 : 6]),
    hexLength === 5 || hexLength === 9 ? +(+("0x" + hexValue[isShort ? 4 : 7] + hexValue[isShort ? 4 : 8]) / 255).toFixed(3) : 1
  ];
};
const hue2rgb = (p2, q2, t2) => {
  if (t2 < 0) t2 += 1;
  if (t2 > 1) t2 -= 1;
  return t2 < 1 / 6 ? p2 + (q2 - p2) * 6 * t2 : t2 < 1 / 2 ? q2 : t2 < 2 / 3 ? p2 + (q2 - p2) * (2 / 3 - t2) * 6 : p2;
};
const hslToRgba = (hslValue) => {
  const hsla2 = hslExecRgx.exec(hslValue) || hslaExecRgx.exec(hslValue);
  const h2 = +hsla2[1] / 360;
  const s = +hsla2[2] / 100;
  const l2 = +hsla2[3] / 100;
  const a2 = !isUnd(hsla2[4]) ? +hsla2[4] : 1;
  let r2, g2, b2;
  if (s === 0) {
    r2 = g2 = b2 = l2;
  } else {
    const q2 = l2 < 0.5 ? l2 * (1 + s) : l2 + s - l2 * s;
    const p2 = 2 * l2 - q2;
    r2 = round$1(hue2rgb(p2, q2, h2 + 1 / 3) * 255, 0);
    g2 = round$1(hue2rgb(p2, q2, h2) * 255, 0);
    b2 = round$1(hue2rgb(p2, q2, h2 - 1 / 3) * 255, 0);
  }
  return [r2, g2, b2, a2];
};
const convertColorStringValuesToRgbaArray = (colorString) => {
  return isRgb(colorString) ? rgbToRgba(colorString) : isHex(colorString) ? hexToRgba(colorString) : isHsl(colorString) ? hslToRgba(colorString) : [0, 0, 0, 1];
};
const setValue = (targetValue, defaultValue) => {
  return isUnd(targetValue) ? defaultValue : targetValue;
};
const getFunctionValue = (value, target, index2, total, store) => {
  if (isFnc(value)) {
    const func = () => {
      const computed = (
        /** @type {Function} */
        value(target, index2, total)
      );
      return !isNaN(+computed) ? +computed : computed || 0;
    };
    if (store) {
      store.func = func;
    }
    return func();
  } else {
    return value;
  }
};
const getTweenType = (target, prop) => {
  return !target[isDomSymbol] ? tweenTypes.OBJECT : (
    // Handle SVG attributes
    target[isSvgSymbol] && isValidSVGAttribute(target, prop) ? tweenTypes.ATTRIBUTE : (
      // Handle CSS Transform properties differently than CSS to allow individual animations
      validTransforms.includes(prop) || shortTransforms.get(prop) ? tweenTypes.TRANSFORM : (
        // CSS variables
        stringStartsWith(prop, "--") ? tweenTypes.CSS_VAR : (
          // All other CSS properties
          prop in /** @type {DOMTarget} */
          target.style ? tweenTypes.CSS : (
            // Handle other DOM Attributes
            prop in target ? tweenTypes.OBJECT : tweenTypes.ATTRIBUTE
          )
        )
      )
    )
  );
};
const getCSSValue = (target, propName, animationInlineStyles) => {
  const inlineStyles = target.style[propName];
  if (inlineStyles && animationInlineStyles) {
    animationInlineStyles[propName] = inlineStyles;
  }
  const value = inlineStyles || getComputedStyle(target[proxyTargetSymbol] || target).getPropertyValue(propName);
  return value === "auto" ? "0" : value;
};
const getOriginalAnimatableValue = (target, propName, tweenType, animationInlineStyles) => {
  const type = !isUnd(tweenType) ? tweenType : getTweenType(target, propName);
  return type === tweenTypes.OBJECT ? target[propName] || 0 : type === tweenTypes.ATTRIBUTE ? (
    /** @type {DOMTarget} */
    target.getAttribute(propName)
  ) : type === tweenTypes.TRANSFORM ? parseInlineTransforms(
    /** @type {DOMTarget} */
    target,
    propName,
    animationInlineStyles
  ) : type === tweenTypes.CSS_VAR ? getCSSValue(
    /** @type {DOMTarget} */
    target,
    propName,
    animationInlineStyles
  ).trimStart() : getCSSValue(
    /** @type {DOMTarget} */
    target,
    propName,
    animationInlineStyles
  );
};
const getRelativeValue = (x2, y2, operator) => {
  return operator === "-" ? x2 - y2 : operator === "+" ? x2 + y2 : x2 * y2;
};
const createDecomposedValueTargetObject = () => {
  return {
    /** @type {valueTypes} */
    t: valueTypes.NUMBER,
    n: 0,
    u: null,
    o: null,
    d: null,
    s: null
  };
};
const decomposeRawValue = (rawValue, targetObject) => {
  targetObject.t = valueTypes.NUMBER;
  targetObject.n = 0;
  targetObject.u = null;
  targetObject.o = null;
  targetObject.d = null;
  targetObject.s = null;
  if (!rawValue) return targetObject;
  const num = +rawValue;
  if (!isNaN(num)) {
    targetObject.n = num;
    return targetObject;
  } else {
    let str = (
      /** @type {String} */
      rawValue
    );
    if (str[1] === "=") {
      targetObject.o = str[0];
      str = str.slice(2);
    }
    const unitMatch = str.includes(" ") ? false : unitsExecRgx.exec(str);
    if (unitMatch) {
      targetObject.t = valueTypes.UNIT;
      targetObject.n = +unitMatch[1];
      targetObject.u = unitMatch[2];
      return targetObject;
    } else if (targetObject.o) {
      targetObject.n = +str;
      return targetObject;
    } else if (isCol(str)) {
      targetObject.t = valueTypes.COLOR;
      targetObject.d = convertColorStringValuesToRgbaArray(str);
      return targetObject;
    } else {
      const matchedNumbers = str.match(digitWithExponentRgx);
      targetObject.t = valueTypes.COMPLEX;
      targetObject.d = matchedNumbers ? matchedNumbers.map(Number) : [];
      targetObject.s = str.split(digitWithExponentRgx) || [];
      return targetObject;
    }
  }
};
const decomposeTweenValue = (tween, targetObject) => {
  targetObject.t = tween._valueType;
  targetObject.n = tween._toNumber;
  targetObject.u = tween._unit;
  targetObject.o = null;
  targetObject.d = cloneArray(tween._toNumbers);
  targetObject.s = cloneArray(tween._strings);
  return targetObject;
};
const decomposedOriginalValue = createDecomposedValueTargetObject();
const lookups = {
  /** @type {TweenReplaceLookups} */
  _rep: /* @__PURE__ */ new WeakMap(),
  /** @type {TweenAdditiveLookups} */
  _add: /* @__PURE__ */ new Map()
};
const getTweenSiblings = (target, property, lookup = "_rep") => {
  const lookupMap = lookups[lookup];
  let targetLookup = lookupMap.get(target);
  if (!targetLookup) {
    targetLookup = {};
    lookupMap.set(target, targetLookup);
  }
  return targetLookup[property] ? targetLookup[property] : targetLookup[property] = {
    _head: null,
    _tail: null
  };
};
const addTweenSortMethod = (p2, c2) => {
  return p2._isOverridden || p2._absoluteStartTime > c2._absoluteStartTime;
};
const overrideTween = (tween) => {
  tween._isOverlapped = 1;
  tween._isOverridden = 1;
  tween._changeDuration = minValue;
  tween._currentTime = minValue;
};
const composeTween = (tween, siblings) => {
  const tweenCompositionType = tween._composition;
  if (tweenCompositionType === compositionTypes.replace) {
    const tweenAbsStartTime = tween._absoluteStartTime;
    addChild(siblings, tween, addTweenSortMethod, "_prevRep", "_nextRep");
    const prevSibling = tween._prevRep;
    if (prevSibling) {
      const prevParent = prevSibling.parent;
      const prevAbsEndTime = prevSibling._absoluteStartTime + prevSibling._changeDuration;
      if (
        // Check if the previous tween is from a different animation
        tween.parent.id !== prevParent.id && // Check if the animation has loops
        prevParent.iterationCount > 1 && // Check if _absoluteChangeEndTime of last loop overlaps the current tween
        prevAbsEndTime + (prevParent.duration - prevParent.iterationDuration) > tweenAbsStartTime
      ) {
        overrideTween(prevSibling);
        let prevPrevSibling = prevSibling._prevRep;
        while (prevPrevSibling && prevPrevSibling.parent.id === prevParent.id) {
          overrideTween(prevPrevSibling);
          prevPrevSibling = prevPrevSibling._prevRep;
        }
      }
      const absoluteUpdateStartTime = tweenAbsStartTime - tween._delay;
      if (prevAbsEndTime > absoluteUpdateStartTime) {
        const prevChangeStartTime = prevSibling._startTime;
        const prevTLOffset = prevAbsEndTime - (prevChangeStartTime + prevSibling._updateDuration);
        prevSibling._changeDuration = absoluteUpdateStartTime - prevTLOffset - prevChangeStartTime;
        prevSibling._currentTime = prevSibling._changeDuration;
        prevSibling._isOverlapped = 1;
        if (prevSibling._changeDuration < minValue) {
          overrideTween(prevSibling);
        }
      }
      let pausePrevParentAnimation = true;
      forEachChildren(prevParent, (t2) => {
        if (!t2._isOverlapped) pausePrevParentAnimation = false;
      });
      if (pausePrevParentAnimation) {
        const prevParentTL = prevParent.parent;
        if (prevParentTL) {
          let pausePrevParentTL = true;
          forEachChildren(prevParentTL, (a2) => {
            if (a2 !== prevParent) {
              forEachChildren(a2, (t2) => {
                if (!t2._isOverlapped) pausePrevParentTL = false;
              });
            }
          });
          if (pausePrevParentTL) {
            prevParentTL.cancel();
          }
        } else {
          prevParent.cancel();
        }
      }
    }
  } else if (tweenCompositionType === compositionTypes.blend) {
    const additiveTweenSiblings = getTweenSiblings(tween.target, tween.property, "_add");
    const additiveAnimation = addAdditiveAnimation(lookups._add);
    let lookupTween = additiveTweenSiblings._head;
    if (!lookupTween) {
      lookupTween = { ...tween };
      lookupTween._composition = compositionTypes.replace;
      lookupTween._updateDuration = minValue;
      lookupTween._startTime = 0;
      lookupTween._numbers = cloneArray(tween._fromNumbers);
      lookupTween._number = 0;
      lookupTween._next = null;
      lookupTween._prev = null;
      addChild(additiveTweenSiblings, lookupTween);
      addChild(additiveAnimation, lookupTween);
    }
    const toNumber = tween._toNumber;
    tween._fromNumber = lookupTween._fromNumber - toNumber;
    tween._toNumber = 0;
    tween._numbers = cloneArray(tween._fromNumbers);
    tween._number = 0;
    lookupTween._fromNumber = toNumber;
    if (tween._toNumbers) {
      const toNumbers = cloneArray(tween._toNumbers);
      if (toNumbers) {
        toNumbers.forEach((value, i2) => {
          tween._fromNumbers[i2] = lookupTween._fromNumbers[i2] - value;
          tween._toNumbers[i2] = 0;
        });
      }
      lookupTween._fromNumbers = toNumbers;
    }
    addChild(additiveTweenSiblings, tween, null, "_prevAdd", "_nextAdd");
  }
  return tween;
};
const removeTweenSliblings = (tween) => {
  const tweenComposition = tween._composition;
  if (tweenComposition !== compositionTypes.none) {
    const tweenTarget = tween.target;
    const tweenProperty = tween.property;
    const replaceTweensLookup = lookups._rep;
    const replaceTargetProps = replaceTweensLookup.get(tweenTarget);
    const tweenReplaceSiblings = replaceTargetProps[tweenProperty];
    removeChild(tweenReplaceSiblings, tween, "_prevRep", "_nextRep");
    if (tweenComposition === compositionTypes.blend) {
      const addTweensLookup = lookups._add;
      const addTargetProps = addTweensLookup.get(tweenTarget);
      if (!addTargetProps) return;
      const additiveTweenSiblings = addTargetProps[tweenProperty];
      const additiveAnimation = additive.animation;
      removeChild(additiveTweenSiblings, tween, "_prevAdd", "_nextAdd");
      const lookupTween = additiveTweenSiblings._head;
      if (lookupTween && lookupTween === additiveTweenSiblings._tail) {
        removeChild(additiveTweenSiblings, lookupTween, "_prevAdd", "_nextAdd");
        removeChild(additiveAnimation, lookupTween);
        let shouldClean = true;
        for (let prop in addTargetProps) {
          if (addTargetProps[prop]._head) {
            shouldClean = false;
            break;
          }
        }
        if (shouldClean) {
          addTweensLookup.delete(tweenTarget);
        }
      }
    }
  }
  return tween;
};
const resetTimerProperties = (timer) => {
  timer.paused = true;
  timer.began = false;
  timer.completed = false;
  return timer;
};
const reviveTimer = (timer) => {
  if (!timer._cancelled) return timer;
  if (timer._hasChildren) {
    forEachChildren(timer, reviveTimer);
  } else {
    forEachChildren(timer, (tween) => {
      if (tween._composition !== compositionTypes.none) {
        composeTween(tween, getTweenSiblings(tween.target, tween.property));
      }
    });
  }
  timer._cancelled = 0;
  return timer;
};
let timerId = 0;
class Timer extends Clock {
  /**
   * @param {TimerParams} [parameters]
   * @param {Timeline} [parent]
   * @param {Number} [parentPosition]
   */
  constructor(parameters = {}, parent2 = null, parentPosition = 0) {
    super(0);
    const {
      id: id2,
      delay: delay2,
      duration: duration2,
      reversed,
      alternate,
      loop,
      loopDelay,
      autoplay,
      frameRate,
      playbackRate,
      onComplete,
      onLoop,
      onPause,
      onBegin,
      onBeforeUpdate,
      onUpdate
    } = parameters;
    const timerInitTime = parent2 ? 0 : engine._elapsedTime;
    const timerDefaults = parent2 ? parent2.defaults : globals.defaults;
    const timerDelay = (
      /** @type {Number} */
      isFnc(delay2) || isUnd(delay2) ? timerDefaults.delay : +delay2
    );
    const timerDuration = isFnc(duration2) || isUnd(duration2) ? Infinity : +duration2;
    const timerLoop = setValue(loop, timerDefaults.loop);
    const timerLoopDelay = setValue(loopDelay, timerDefaults.loopDelay);
    const timerIterationCount = timerLoop === true || timerLoop === Infinity || /** @type {Number} */
    timerLoop < 0 ? Infinity : (
      /** @type {Number} */
      timerLoop + 1
    );
    let offsetPosition = 0;
    if (parent2) {
      offsetPosition = parentPosition;
    } else {
      let startTime = now();
      if (engine.paused) {
        engine.requestTick(startTime);
        startTime = engine._elapsedTime;
      }
      offsetPosition = startTime - engine._startTime;
    }
    this.id = !isUnd(id2) ? id2 : ++timerId;
    this.parent = parent2;
    this.duration = clampInfinity((timerDuration + timerLoopDelay) * timerIterationCount - timerLoopDelay) || minValue;
    this.backwards = false;
    this.paused = true;
    this.began = false;
    this.completed = false;
    this.onBegin = onBegin || timerDefaults.onBegin;
    this.onBeforeUpdate = onBeforeUpdate || timerDefaults.onBeforeUpdate;
    this.onUpdate = onUpdate || timerDefaults.onUpdate;
    this.onLoop = onLoop || timerDefaults.onLoop;
    this.onPause = onPause || timerDefaults.onPause;
    this.onComplete = onComplete || timerDefaults.onComplete;
    this.iterationDuration = timerDuration;
    this.iterationCount = timerIterationCount;
    this._autoplay = parent2 ? false : setValue(autoplay, timerDefaults.autoplay);
    this._offset = offsetPosition;
    this._delay = timerDelay;
    this._loopDelay = timerLoopDelay;
    this._iterationTime = 0;
    this._currentIteration = 0;
    this._resolve = noop$3;
    this._running = false;
    this._reversed = +setValue(reversed, timerDefaults.reversed);
    this._reverse = this._reversed;
    this._cancelled = 0;
    this._alternate = setValue(alternate, timerDefaults.alternate);
    this._prev = null;
    this._next = null;
    this._elapsedTime = timerInitTime;
    this._startTime = timerInitTime;
    this._lastTime = timerInitTime;
    this._fps = setValue(frameRate, timerDefaults.frameRate);
    this._speed = setValue(playbackRate, timerDefaults.playbackRate);
  }
  get cancelled() {
    return !!this._cancelled;
  }
  /** @param {Boolean} cancelled  */
  set cancelled(cancelled) {
    cancelled ? this.cancel() : this.reset(1).play();
  }
  get currentTime() {
    return clamp$1(round$1(this._currentTime, globals.precision), -this._delay, this.duration);
  }
  /** @param {Number} time  */
  set currentTime(time2) {
    const paused = this.paused;
    this.pause().seek(+time2);
    if (!paused) this.resume();
  }
  get iterationCurrentTime() {
    return round$1(this._iterationTime, globals.precision);
  }
  /** @param {Number} time  */
  set iterationCurrentTime(time2) {
    this.currentTime = this.iterationDuration * this._currentIteration + time2;
  }
  get progress() {
    return clamp$1(round$1(this._currentTime / this.duration, 5), 0, 1);
  }
  /** @param {Number} progress  */
  set progress(progress2) {
    this.currentTime = this.duration * progress2;
  }
  get iterationProgress() {
    return clamp$1(round$1(this._iterationTime / this.iterationDuration, 5), 0, 1);
  }
  /** @param {Number} progress  */
  set iterationProgress(progress2) {
    const iterationDuration = this.iterationDuration;
    this.currentTime = iterationDuration * this._currentIteration + iterationDuration * progress2;
  }
  get currentIteration() {
    return this._currentIteration;
  }
  /** @param {Number} iterationCount  */
  set currentIteration(iterationCount) {
    this.currentTime = this.iterationDuration * clamp$1(+iterationCount, 0, this.iterationCount - 1);
  }
  get reversed() {
    return !!this._reversed;
  }
  /** @param {Boolean} reverse  */
  set reversed(reverse) {
    reverse ? this.reverse() : this.play();
  }
  get speed() {
    return super.speed;
  }
  /** @param {Number} playbackRate  */
  set speed(playbackRate) {
    super.speed = playbackRate;
    this.resetTime();
  }
  /**
   * @param  {Number} internalRender
   * @return {this}
   */
  reset(internalRender = 0) {
    reviveTimer(this);
    if (this._reversed && !this._reverse) this.reversed = false;
    this._iterationTime = this.iterationDuration;
    tick(this, 0, 1, internalRender, tickModes.FORCE);
    resetTimerProperties(this);
    if (this._hasChildren) {
      forEachChildren(this, resetTimerProperties);
    }
    return this;
  }
  /**
   * @param  {Number} internalRender
   * @return {this}
   */
  init(internalRender = 0) {
    this.fps = this._fps;
    this.speed = this._speed;
    if (!internalRender && this._hasChildren) {
      tick(this, this.duration, 1, internalRender, tickModes.FORCE);
    }
    this.reset(internalRender);
    const autoplay = this._autoplay;
    if (autoplay === true) {
      this.resume();
    } else if (autoplay && !isUnd(
      /** @type {ScrollObserver} */
      autoplay.linked
    )) {
      autoplay.link(this);
    }
    return this;
  }
  /** @return {this} */
  resetTime() {
    const timeScale = 1 / (this._speed * engine._speed);
    this._startTime = now() - (this._currentTime + this._delay) * timeScale;
    return this;
  }
  /** @return {this} */
  pause() {
    if (this.paused) return this;
    this.paused = true;
    this.onPause(this);
    return this;
  }
  /** @return {this} */
  resume() {
    if (!this.paused) return this;
    this.paused = false;
    if (this.duration <= minValue && !this._hasChildren) {
      tick(this, minValue, 0, 0, tickModes.FORCE);
    } else {
      if (!this._running) {
        addChild(engine, this);
        engine._hasChildren = true;
        this._running = true;
      }
      this.resetTime();
      this._startTime -= 12;
      engine.wake();
    }
    return this;
  }
  /** @return {this} */
  restart() {
    return this.reset(0).resume();
  }
  /**
   * @param  {Number} time
   * @param  {Boolean|Number} [muteCallbacks]
   * @param  {Boolean|Number} [internalRender]
   * @return {this}
   */
  seek(time2, muteCallbacks = 0, internalRender = 0) {
    reviveTimer(this);
    this.completed = false;
    const isPaused = this.paused;
    this.paused = true;
    tick(this, time2 + this._delay, ~~muteCallbacks, ~~internalRender, tickModes.AUTO);
    return isPaused ? this : this.resume();
  }
  /** @return {this} */
  alternate() {
    const reversed = this._reversed;
    const count2 = this.iterationCount;
    const duration2 = this.iterationDuration;
    const iterations = count2 === Infinity ? floor(maxValue / duration2) : count2;
    this._reversed = +(this._alternate && !(iterations % 2) ? reversed : !reversed);
    if (count2 === Infinity) {
      this.iterationProgress = this._reversed ? 1 - this.iterationProgress : this.iterationProgress;
    } else {
      this.seek(duration2 * iterations - this._currentTime);
    }
    this.resetTime();
    return this;
  }
  /** @return {this} */
  play() {
    if (this._reversed) this.alternate();
    return this.resume();
  }
  /** @return {this} */
  reverse() {
    if (!this._reversed) this.alternate();
    return this.resume();
  }
  // TODO: Move all the animation / tweens / children related code to Animation / Timeline
  /** @return {this} */
  cancel() {
    if (this._hasChildren) {
      forEachChildren(this, (child) => child.cancel(), true);
    } else {
      forEachChildren(this, removeTweenSliblings);
    }
    this._cancelled = 1;
    return this.pause();
  }
  /**
   * @param  {Number} newDuration
   * @return {this}
   */
  stretch(newDuration) {
    const currentDuration = this.duration;
    const normlizedDuration = normalizeTime(newDuration);
    if (currentDuration === normlizedDuration) return this;
    const timeScale = newDuration / currentDuration;
    const isSetter = newDuration <= minValue;
    this.duration = isSetter ? minValue : normlizedDuration;
    this.iterationDuration = isSetter ? minValue : normalizeTime(this.iterationDuration * timeScale);
    this._offset *= timeScale;
    this._delay *= timeScale;
    this._loopDelay *= timeScale;
    return this;
  }
  /**
    * Cancels the timer by seeking it back to 0 and reverting the attached scroller if necessary
    * @return {this}
    */
  revert() {
    tick(this, 0, 1, 0, tickModes.AUTO);
    const ap = (
      /** @type {ScrollObserver} */
      this._autoplay
    );
    if (ap && ap.linked && ap.linked === this) ap.revert();
    return this.cancel();
  }
  /**
    * Imediatly completes the timer, cancels it and triggers the onComplete callback
    * @return {this}
    */
  complete() {
    return this.seek(this.duration).cancel();
  }
  /**
   * @param  {Callback<this>} [callback]
   * @return {Promise}
   */
  then(callback = noop$3) {
    const then = this.then;
    const onResolve = () => {
      this.then = null;
      callback(this);
      this.then = then;
      this._resolve = noop$3;
    };
    return new Promise((r2) => {
      this._resolve = () => r2(onResolve());
      if (this.completed) this._resolve();
      return this;
    });
  }
}
const none = (t2) => t2;
const calcBezier = (aT, aA1, aA2) => (((1 - 3 * aA2 + 3 * aA1) * aT + (3 * aA2 - 6 * aA1)) * aT + 3 * aA1) * aT;
const binarySubdivide = (aX, mX1, mX2) => {
  let aA = 0, aB = 1, currentX, currentT, i2 = 0;
  do {
    currentT = aA + (aB - aA) / 2;
    currentX = calcBezier(currentT, mX1, mX2) - aX;
    if (currentX > 0) {
      aB = currentT;
    } else {
      aA = currentT;
    }
  } while (abs$1(currentX) > 1e-7 && ++i2 < 100);
  return currentT;
};
const cubicBezier = (mX1 = 0.5, mY1 = 0, mX2 = 0.5, mY2 = 1) => mX1 === mY1 && mX2 === mY2 ? none : (t2) => t2 === 0 || t2 === 1 ? t2 : calcBezier(binarySubdivide(t2, mX1, mX2), mY1, mY2);
const steps = (steps2 = 10, fromStart) => {
  const roundMethod = fromStart ? ceil : floor;
  return (t2) => roundMethod(clamp$1(t2, 0, 1) * steps2) * (1 / steps2);
};
const linear = (...args) => {
  const argsLength = args.length;
  if (!argsLength) return none;
  const totalPoints = argsLength - 1;
  const firstArg = args[0];
  const lastArg = args[totalPoints];
  const xPoints = [0];
  const yPoints = [parseNumber(firstArg)];
  for (let i2 = 1; i2 < totalPoints; i2++) {
    const arg2 = args[i2];
    const splitValue = isStr(arg2) ? (
      /** @type {String} */
      arg2.trim().split(" ")
    ) : [arg2];
    const value = splitValue[0];
    const percent2 = splitValue[1];
    xPoints.push(!isUnd(percent2) ? parseNumber(percent2) / 100 : i2 / totalPoints);
    yPoints.push(parseNumber(value));
  }
  yPoints.push(parseNumber(lastArg));
  xPoints.push(1);
  return function easeLinear(t2) {
    for (let i2 = 1, l2 = xPoints.length; i2 < l2; i2++) {
      const currentX = xPoints[i2];
      if (t2 <= currentX) {
        const prevX = xPoints[i2 - 1];
        const prevY = yPoints[i2 - 1];
        return prevY + (yPoints[i2] - prevY) * (t2 - prevX) / (currentX - prevX);
      }
    }
    return yPoints[yPoints.length - 1];
  };
};
const irregular = (length2 = 10, randomness = 1) => {
  const values2 = [0];
  const total = length2 - 1;
  for (let i2 = 1; i2 < total; i2++) {
    const previousValue = values2[i2 - 1];
    const spacing = i2 / total;
    const segmentEnd = (i2 + 1) / total;
    const randomVariation = spacing + (segmentEnd - spacing) * Math.random();
    const randomValue = spacing * (1 - randomness) + randomVariation * randomness;
    values2.push(clamp$1(randomValue, previousValue, 1));
  }
  values2.push(1);
  return linear(...values2);
};
const halfPI = PI / 2;
const doublePI = PI * 2;
const easeInPower = (p2 = 1.68) => (t2) => pow(t2, +p2);
const easeInFunctions = {
  [emptyString]: easeInPower,
  Quad: easeInPower(2),
  Cubic: easeInPower(3),
  Quart: easeInPower(4),
  Quint: easeInPower(5),
  /** @type {EasingFunction} */
  Sine: (t2) => 1 - cos(t2 * halfPI),
  /** @type {EasingFunction} */
  Circ: (t2) => 1 - sqrt(1 - t2 * t2),
  /** @type {EasingFunction} */
  Expo: (t2) => t2 ? pow(2, 10 * t2 - 10) : 0,
  /** @type {EasingFunction} */
  Bounce: (t2) => {
    let pow2, b2 = 4;
    while (t2 < ((pow2 = pow(2, --b2)) - 1) / 11) ;
    return 1 / pow(4, 3 - b2) - 7.5625 * pow((pow2 * 3 - 2) / 22 - t2, 2);
  },
  /** @type {BackEasing} */
  Back: (overshoot = 1.70158) => (t2) => (+overshoot + 1) * t2 * t2 * t2 - +overshoot * t2 * t2,
  /** @type {ElasticEasing} */
  Elastic: (amplitude = 1, period = 0.3) => {
    const a2 = clamp$1(+amplitude, 1, 10);
    const p2 = clamp$1(+period, minValue, 2);
    const s = p2 / doublePI * asin(1 / a2);
    const e2 = doublePI / p2;
    return (t2) => t2 === 0 || t2 === 1 ? t2 : -a2 * pow(2, -10 * (1 - t2)) * sin((1 - t2 - s) * e2);
  }
};
const easeTypes = {
  in: (easeIn2) => (t2) => easeIn2(t2),
  out: (easeIn2) => (t2) => 1 - easeIn2(1 - t2),
  inOut: (easeIn2) => (t2) => t2 < 0.5 ? easeIn2(t2 * 2) / 2 : 1 - easeIn2(t2 * -2 + 2) / 2,
  outIn: (easeIn2) => (t2) => t2 < 0.5 ? (1 - easeIn2(1 - t2 * 2)) / 2 : (easeIn2(t2 * 2 - 1) + 1) / 2
};
const parseEaseString = (string, easesFunctions, easesLookups) => {
  if (easesLookups[string]) return easesLookups[string];
  if (string.indexOf("(") <= -1) {
    const hasParams = easeTypes[string] || string.includes("Back") || string.includes("Elastic");
    const parsedFn = (
      /** @type {EasingFunction} */
      hasParams ? (
        /** @type {EasesFactory} */
        easesFunctions[string]()
      ) : easesFunctions[string]
    );
    return parsedFn ? easesLookups[string] = parsedFn : none;
  } else {
    const split = string.slice(0, -1).split("(");
    const parsedFn = (
      /** @type {EasesFactory} */
      easesFunctions[split[0]]
    );
    return parsedFn ? easesLookups[string] = parsedFn(...split[1].split(",")) : none;
  }
};
const eases = /* @__PURE__ */ (() => {
  const list = { linear, irregular, steps, cubicBezier };
  for (let type in easeTypes) {
    for (let name in easeInFunctions) {
      const easeIn2 = easeInFunctions[name];
      const easeType = easeTypes[type];
      list[type + name] = /** @type {EasesFactory|EasingFunction} */
      name === emptyString || name === "Back" || name === "Elastic" ? (a2, b2) => easeType(
        /** @type {EasesFactory} */
        easeIn2(a2, b2)
      ) : easeType(
        /** @type {EasingFunction} */
        easeIn2
      );
    }
  }
  return (
    /** @type {EasesFunctions} */
    list
  );
})();
const JSEasesLookups = { linear: none };
const parseEasings = (ease2) => isFnc(ease2) ? ease2 : isStr(ease2) ? parseEaseString(
  /** @type {String} */
  ease2,
  eases,
  JSEasesLookups
) : none;
const propertyNamesCache = {};
const sanitizePropertyName = (propertyName, target, tweenType) => {
  if (tweenType === tweenTypes.TRANSFORM) {
    const t2 = shortTransforms.get(propertyName);
    return t2 ? t2 : propertyName;
  } else if (tweenType === tweenTypes.CSS || // Handle special cases where properties like "strokeDashoffset" needs to be set as "stroke-dashoffset"
  // but properties like "baseFrequency" should stay in lowerCamelCase
  tweenType === tweenTypes.ATTRIBUTE && (isSvg(target) && propertyName in /** @type {DOMTarget} */
  target.style)) {
    const cachedPropertyName = propertyNamesCache[propertyName];
    if (cachedPropertyName) {
      return cachedPropertyName;
    } else {
      const lowerCaseName = propertyName ? toLowerCase(propertyName) : propertyName;
      propertyNamesCache[propertyName] = lowerCaseName;
      return lowerCaseName;
    }
  } else {
    return propertyName;
  }
};
const angleUnitsMap = { "deg": 1, "rad": 180 / PI, "turn": 360 };
const convertedValuesCache = {};
const convertValueUnit = (el, decomposedValue, unit, force = false) => {
  const currentUnit = decomposedValue.u;
  const currentNumber = decomposedValue.n;
  if (decomposedValue.t === valueTypes.UNIT && currentUnit === unit) {
    return decomposedValue;
  }
  const cachedKey = currentNumber + currentUnit + unit;
  const cached = convertedValuesCache[cachedKey];
  if (!isUnd(cached) && !force) {
    decomposedValue.n = cached;
  } else {
    let convertedValue;
    if (currentUnit in angleUnitsMap) {
      convertedValue = currentNumber * angleUnitsMap[currentUnit] / angleUnitsMap[unit];
    } else {
      const baseline = 100;
      const tempEl = (
        /** @type {DOMTarget} */
        el.cloneNode()
      );
      const parentNode = el.parentNode;
      const parentEl = parentNode && parentNode !== doc ? parentNode : doc.body;
      parentEl.appendChild(tempEl);
      const elStyle = tempEl.style;
      elStyle.width = baseline + currentUnit;
      const currentUnitWidth = (
        /** @type {HTMLElement} */
        tempEl.offsetWidth || baseline
      );
      elStyle.width = baseline + unit;
      const newUnitWidth = (
        /** @type {HTMLElement} */
        tempEl.offsetWidth || baseline
      );
      const factor = currentUnitWidth / newUnitWidth;
      parentEl.removeChild(tempEl);
      convertedValue = factor * currentNumber;
    }
    decomposedValue.n = convertedValue;
    convertedValuesCache[cachedKey] = convertedValue;
  }
  decomposedValue.t === valueTypes.UNIT;
  decomposedValue.u = unit;
  return decomposedValue;
};
const cleanInlineStyles = (renderable) => {
  if (renderable._hasChildren) {
    forEachChildren(renderable, cleanInlineStyles, true);
  } else {
    const animation = (
      /** @type {JSAnimation} */
      renderable
    );
    animation.pause();
    forEachChildren(animation, (tween) => {
      const tweenProperty = tween.property;
      const tweenTarget = tween.target;
      if (tweenTarget[isDomSymbol]) {
        const targetStyle = (
          /** @type {DOMTarget} */
          tweenTarget.style
        );
        const originalInlinedValue = animation._inlineStyles[tweenProperty];
        if (tween._tweenType === tweenTypes.TRANSFORM) {
          const cachedTransforms = tweenTarget[transformsSymbol];
          if (isUnd(originalInlinedValue) || originalInlinedValue === emptyString) {
            delete cachedTransforms[tweenProperty];
          } else {
            cachedTransforms[tweenProperty] = originalInlinedValue;
          }
          if (tween._renderTransforms) {
            if (!Object.keys(cachedTransforms).length) {
              targetStyle.removeProperty("transform");
            } else {
              let str = emptyString;
              for (let key2 in cachedTransforms) {
                str += transformsFragmentStrings[key2] + cachedTransforms[key2] + ") ";
              }
              targetStyle.transform = str;
            }
          }
        } else {
          if (isUnd(originalInlinedValue) || originalInlinedValue === emptyString) {
            targetStyle.removeProperty(tweenProperty);
          } else {
            targetStyle[tweenProperty] = originalInlinedValue;
          }
        }
        if (animation._tail === tween) {
          animation.targets.forEach((t2) => {
            if (t2.getAttribute && t2.getAttribute("style") === emptyString) {
              t2.removeAttribute("style");
            }
          });
        }
      }
    });
  }
  return renderable;
};
const fromTargetObject = createDecomposedValueTargetObject();
const toTargetObject = createDecomposedValueTargetObject();
const toFunctionStore = { func: null };
const keyframesTargetArray = [null];
const fastSetValuesArray = [null, null];
const keyObjectTarget = { to: null };
let tweenId = 0;
let keyframes$1;
let key;
const generateKeyframes = (keyframes2, parameters) => {
  const properties2 = {};
  if (isArr(keyframes2)) {
    const propertyNames = [].concat(.../** @type {DurationKeyframes} */
    keyframes2.map((key2) => Object.keys(key2))).filter(isKey);
    for (let i2 = 0, l2 = propertyNames.length; i2 < l2; i2++) {
      const propName = propertyNames[i2];
      const propArray = (
        /** @type {DurationKeyframes} */
        keyframes2.map((key2) => {
          const newKey = {};
          for (let p2 in key2) {
            const keyValue = (
              /** @type {TweenPropValue} */
              key2[p2]
            );
            if (isKey(p2)) {
              if (p2 === propName) {
                newKey.to = keyValue;
              }
            } else {
              newKey[p2] = keyValue;
            }
          }
          return newKey;
        })
      );
      properties2[propName] = /** @type {ArraySyntaxValue} */
      propArray;
    }
  } else {
    const totalDuration = (
      /** @type {Number} */
      setValue(parameters.duration, globals.defaults.duration)
    );
    const keys = Object.keys(keyframes2).map((key2) => {
      return { o: parseFloat(key2) / 100, p: keyframes2[key2] };
    }).sort((a2, b2) => a2.o - b2.o);
    keys.forEach((key2) => {
      const offset2 = key2.o;
      const prop = key2.p;
      for (let name in prop) {
        if (isKey(name)) {
          let propArray = (
            /** @type {Array} */
            properties2[name]
          );
          if (!propArray) propArray = properties2[name] = [];
          const duration2 = offset2 * totalDuration;
          let length2 = propArray.length;
          let prevKey = propArray[length2 - 1];
          const keyObj = { to: prop[name] };
          let durProgress = 0;
          for (let i2 = 0; i2 < length2; i2++) {
            durProgress += propArray[i2].duration;
          }
          if (length2 === 1) {
            keyObj.from = prevKey.to;
          }
          if (prop.ease) {
            keyObj.ease = prop.ease;
          }
          keyObj.duration = duration2 - (length2 ? durProgress : 0);
          propArray.push(keyObj);
        }
      }
      return key2;
    });
    for (let name in properties2) {
      const propArray = (
        /** @type {Array} */
        properties2[name]
      );
      let prevEase;
      for (let i2 = 0, l2 = propArray.length; i2 < l2; i2++) {
        const prop = propArray[i2];
        const currentEase = prop.ease;
        prop.ease = prevEase ? prevEase : void 0;
        prevEase = currentEase;
      }
      if (!propArray[0].duration) {
        propArray.shift();
      }
    }
  }
  return properties2;
};
class JSAnimation2 extends Timer {
  /**
   * @param {TargetsParam} targets
   * @param {AnimationParams} parameters
   * @param {Timeline} [parent]
   * @param {Number} [parentPosition]
   * @param {Boolean} [fastSet=false]
   * @param {Number} [index=0]
   * @param {Number} [length=0]
   */
  constructor(targets, parameters, parent2, parentPosition, fastSet = false, index2 = 0, length2 = 0) {
    super(
      /** @type {TimerParams&AnimationParams} */
      parameters,
      parent2,
      parentPosition
    );
    const parsedTargets = registerTargets(targets);
    const targetsLength = parsedTargets.length;
    const kfParams = (
      /** @type {AnimationParams} */
      parameters.keyframes
    );
    const params = (
      /** @type {AnimationParams} */
      kfParams ? mergeObjects(generateKeyframes(
        /** @type {DurationKeyframes} */
        kfParams,
        parameters
      ), parameters) : parameters
    );
    const {
      delay: delay2,
      duration: duration2,
      ease: ease2,
      playbackEase,
      modifier,
      composition,
      onRender
    } = params;
    const animDefaults = parent2 ? parent2.defaults : globals.defaults;
    const animaPlaybackEase = setValue(playbackEase, animDefaults.playbackEase);
    const animEase = animaPlaybackEase ? parseEasings(animaPlaybackEase) : null;
    const hasSpring = !isUnd(ease2) && !isUnd(
      /** @type {Spring} */
      ease2.ease
    );
    const tEasing = hasSpring ? (
      /** @type {Spring} */
      ease2.ease
    ) : setValue(ease2, animEase ? "linear" : animDefaults.ease);
    const tDuration = hasSpring ? (
      /** @type {Spring} */
      ease2.duration
    ) : setValue(duration2, animDefaults.duration);
    const tDelay = setValue(delay2, animDefaults.delay);
    const tModifier = modifier || animDefaults.modifier;
    const tComposition = isUnd(composition) && targetsLength >= K ? compositionTypes.none : !isUnd(composition) ? composition : animDefaults.composition;
    const animInlineStyles = {};
    const absoluteOffsetTime = this._offset + (parent2 ? parent2._offset : 0);
    let iterationDuration = NaN;
    let iterationDelay = NaN;
    let animationAnimationLength = 0;
    let shouldTriggerRender = 0;
    for (let targetIndex = 0; targetIndex < targetsLength; targetIndex++) {
      const target = parsedTargets[targetIndex];
      const ti = index2 || targetIndex;
      const tl = length2 || targetsLength;
      let lastTransformGroupIndex = NaN;
      let lastTransformGroupLength = NaN;
      for (let p2 in params) {
        if (isKey(p2)) {
          const tweenType = getTweenType(target, p2);
          const propName = sanitizePropertyName(p2, target, tweenType);
          let propValue = params[p2];
          const isPropValueArray = isArr(propValue);
          if (fastSet && !isPropValueArray) {
            fastSetValuesArray[0] = propValue;
            fastSetValuesArray[1] = propValue;
            propValue = fastSetValuesArray;
          }
          if (isPropValueArray) {
            const arrayLength = (
              /** @type {Array} */
              propValue.length
            );
            const isNotObjectValue = !isObj(propValue[0]);
            if (arrayLength === 2 && isNotObjectValue) {
              keyObjectTarget.to = /** @type {TweenParamValue} */
              /** @type {unknown} */
              propValue;
              keyframesTargetArray[0] = keyObjectTarget;
              keyframes$1 = keyframesTargetArray;
            } else if (arrayLength > 2 && isNotObjectValue) {
              keyframes$1 = [];
              propValue.forEach((v2, i2) => {
                if (!i2) {
                  fastSetValuesArray[0] = v2;
                } else if (i2 === 1) {
                  fastSetValuesArray[1] = v2;
                  keyframes$1.push(fastSetValuesArray);
                } else {
                  keyframes$1.push(v2);
                }
              });
            } else {
              keyframes$1 = /** @type {Array.<TweenKeyValue>} */
              propValue;
            }
          } else {
            keyframesTargetArray[0] = propValue;
            keyframes$1 = keyframesTargetArray;
          }
          let siblings = null;
          let prevTween = null;
          let firstTweenChangeStartTime = NaN;
          let lastTweenChangeEndTime = 0;
          let tweenIndex = 0;
          for (let l2 = keyframes$1.length; tweenIndex < l2; tweenIndex++) {
            const keyframe = keyframes$1[tweenIndex];
            if (isObj(keyframe)) {
              key = keyframe;
            } else {
              keyObjectTarget.to = /** @type {TweenParamValue} */
              keyframe;
              key = keyObjectTarget;
            }
            toFunctionStore.func = null;
            const computedToValue = getFunctionValue(key.to, target, ti, tl, toFunctionStore);
            let tweenToValue;
            if (isObj(computedToValue) && !isUnd(computedToValue.to)) {
              key = computedToValue;
              tweenToValue = computedToValue.to;
            } else {
              tweenToValue = computedToValue;
            }
            const tweenFromValue = getFunctionValue(key.from, target, ti, tl);
            const keyEasing = key.ease;
            const hasSpring2 = !isUnd(keyEasing) && !isUnd(
              /** @type {Spring} */
              keyEasing.ease
            );
            const tweenEasing = hasSpring2 ? (
              /** @type {Spring} */
              keyEasing.ease
            ) : keyEasing || tEasing;
            const tweenDuration = hasSpring2 ? (
              /** @type {Spring} */
              keyEasing.duration
            ) : getFunctionValue(setValue(key.duration, l2 > 1 ? getFunctionValue(tDuration, target, ti, tl) / l2 : tDuration), target, ti, tl);
            const tweenDelay = getFunctionValue(setValue(key.delay, !tweenIndex ? tDelay : 0), target, ti, tl);
            const computedComposition = getFunctionValue(setValue(key.composition, tComposition), target, ti, tl);
            const tweenComposition = isNum(computedComposition) ? computedComposition : compositionTypes[computedComposition];
            const tweenModifier = key.modifier || tModifier;
            const hasFromvalue = !isUnd(tweenFromValue);
            const hasToValue = !isUnd(tweenToValue);
            const isFromToArray = isArr(tweenToValue);
            const isFromToValue = isFromToArray || hasFromvalue && hasToValue;
            const tweenStartTime = prevTween ? lastTweenChangeEndTime + tweenDelay : tweenDelay;
            const absoluteStartTime = absoluteOffsetTime + tweenStartTime;
            if (!shouldTriggerRender && (hasFromvalue || isFromToArray)) shouldTriggerRender = 1;
            let prevSibling = prevTween;
            if (tweenComposition !== compositionTypes.none) {
              if (!siblings) siblings = getTweenSiblings(target, propName);
              let nextSibling = siblings._head;
              while (nextSibling && !nextSibling._isOverridden && nextSibling._absoluteStartTime <= absoluteStartTime) {
                prevSibling = nextSibling;
                nextSibling = nextSibling._nextRep;
                if (nextSibling && nextSibling._absoluteStartTime >= absoluteStartTime) {
                  while (nextSibling) {
                    overrideTween(nextSibling);
                    nextSibling = nextSibling._nextRep;
                  }
                }
              }
            }
            if (isFromToValue) {
              decomposeRawValue(isFromToArray ? getFunctionValue(tweenToValue[0], target, ti, tl) : tweenFromValue, fromTargetObject);
              decomposeRawValue(isFromToArray ? getFunctionValue(tweenToValue[1], target, ti, tl, toFunctionStore) : tweenToValue, toTargetObject);
              if (fromTargetObject.t === valueTypes.NUMBER) {
                if (prevSibling) {
                  if (prevSibling._valueType === valueTypes.UNIT) {
                    fromTargetObject.t = valueTypes.UNIT;
                    fromTargetObject.u = prevSibling._unit;
                  }
                } else {
                  decomposeRawValue(
                    getOriginalAnimatableValue(target, propName, tweenType, animInlineStyles),
                    decomposedOriginalValue
                  );
                  if (decomposedOriginalValue.t === valueTypes.UNIT) {
                    fromTargetObject.t = valueTypes.UNIT;
                    fromTargetObject.u = decomposedOriginalValue.u;
                  }
                }
              }
            } else {
              if (hasToValue) {
                decomposeRawValue(tweenToValue, toTargetObject);
              } else {
                if (prevTween) {
                  decomposeTweenValue(prevTween, toTargetObject);
                } else {
                  decomposeRawValue(parent2 && prevSibling && prevSibling.parent.parent === parent2 ? prevSibling._value : getOriginalAnimatableValue(target, propName, tweenType, animInlineStyles), toTargetObject);
                }
              }
              if (hasFromvalue) {
                decomposeRawValue(tweenFromValue, fromTargetObject);
              } else {
                if (prevTween) {
                  decomposeTweenValue(prevTween, fromTargetObject);
                } else {
                  decomposeRawValue(parent2 && prevSibling && prevSibling.parent.parent === parent2 ? prevSibling._value : (
                    // No need to get and parse the original value if the tween is part of a timeline and has a previous sibling part of the same timeline
                    getOriginalAnimatableValue(target, propName, tweenType, animInlineStyles)
                  ), fromTargetObject);
                }
              }
            }
            if (fromTargetObject.o) {
              fromTargetObject.n = getRelativeValue(
                !prevSibling ? decomposeRawValue(
                  getOriginalAnimatableValue(target, propName, tweenType, animInlineStyles),
                  decomposedOriginalValue
                ).n : prevSibling._toNumber,
                fromTargetObject.n,
                fromTargetObject.o
              );
            }
            if (toTargetObject.o) {
              toTargetObject.n = getRelativeValue(fromTargetObject.n, toTargetObject.n, toTargetObject.o);
            }
            if (fromTargetObject.t !== toTargetObject.t) {
              if (fromTargetObject.t === valueTypes.COMPLEX || toTargetObject.t === valueTypes.COMPLEX) {
                const complexValue = fromTargetObject.t === valueTypes.COMPLEX ? fromTargetObject : toTargetObject;
                const notComplexValue = fromTargetObject.t === valueTypes.COMPLEX ? toTargetObject : fromTargetObject;
                notComplexValue.t = valueTypes.COMPLEX;
                notComplexValue.s = cloneArray(complexValue.s);
                notComplexValue.d = complexValue.d.map(() => notComplexValue.n);
              } else if (fromTargetObject.t === valueTypes.UNIT || toTargetObject.t === valueTypes.UNIT) {
                const unitValue = fromTargetObject.t === valueTypes.UNIT ? fromTargetObject : toTargetObject;
                const notUnitValue = fromTargetObject.t === valueTypes.UNIT ? toTargetObject : fromTargetObject;
                notUnitValue.t = valueTypes.UNIT;
                notUnitValue.u = unitValue.u;
              } else if (fromTargetObject.t === valueTypes.COLOR || toTargetObject.t === valueTypes.COLOR) {
                const colorValue = fromTargetObject.t === valueTypes.COLOR ? fromTargetObject : toTargetObject;
                const notColorValue = fromTargetObject.t === valueTypes.COLOR ? toTargetObject : fromTargetObject;
                notColorValue.t = valueTypes.COLOR;
                notColorValue.s = colorValue.s;
                notColorValue.d = [0, 0, 0, 1];
              }
            }
            if (fromTargetObject.u !== toTargetObject.u) {
              let valueToConvert = toTargetObject.u ? fromTargetObject : toTargetObject;
              valueToConvert = convertValueUnit(
                /** @type {DOMTarget} */
                target,
                valueToConvert,
                toTargetObject.u ? toTargetObject.u : fromTargetObject.u,
                false
              );
            }
            if (toTargetObject.d && fromTargetObject.d && toTargetObject.d.length !== fromTargetObject.d.length) {
              const longestValue = fromTargetObject.d.length > toTargetObject.d.length ? fromTargetObject : toTargetObject;
              const shortestValue = longestValue === fromTargetObject ? toTargetObject : fromTargetObject;
              shortestValue.d = longestValue.d.map((_2, i2) => isUnd(shortestValue.d[i2]) ? 0 : shortestValue.d[i2]);
              shortestValue.s = cloneArray(longestValue.s);
            }
            const tweenUpdateDuration = round$1(+tweenDuration || minValue, 12);
            const tween = {
              parent: this,
              id: tweenId++,
              property: propName,
              target,
              _value: null,
              _func: toFunctionStore.func,
              _ease: parseEasings(tweenEasing),
              _fromNumbers: cloneArray(fromTargetObject.d),
              _toNumbers: cloneArray(toTargetObject.d),
              _strings: cloneArray(toTargetObject.s),
              _fromNumber: fromTargetObject.n,
              _toNumber: toTargetObject.n,
              _numbers: cloneArray(fromTargetObject.d),
              // For additive tween and animatables
              _number: fromTargetObject.n,
              // For additive tween and animatables
              _unit: toTargetObject.u,
              _modifier: tweenModifier,
              _currentTime: 0,
              _startTime: tweenStartTime,
              _delay: +tweenDelay,
              _updateDuration: tweenUpdateDuration,
              _changeDuration: tweenUpdateDuration,
              _absoluteStartTime: absoluteStartTime,
              // NOTE: Investigate bit packing to stores ENUM / BOOL
              _tweenType: tweenType,
              _valueType: toTargetObject.t,
              _composition: tweenComposition,
              _isOverlapped: 0,
              _isOverridden: 0,
              _renderTransforms: 0,
              _prevRep: null,
              // For replaced tween
              _nextRep: null,
              // For replaced tween
              _prevAdd: null,
              // For additive tween
              _nextAdd: null,
              // For additive tween
              _prev: null,
              _next: null
            };
            if (tweenComposition !== compositionTypes.none) {
              composeTween(tween, siblings);
            }
            if (isNaN(firstTweenChangeStartTime)) {
              firstTweenChangeStartTime = tween._startTime;
            }
            lastTweenChangeEndTime = round$1(tweenStartTime + tweenUpdateDuration, 12);
            prevTween = tween;
            animationAnimationLength++;
            addChild(this, tween);
          }
          if (isNaN(iterationDelay) || firstTweenChangeStartTime < iterationDelay) {
            iterationDelay = firstTweenChangeStartTime;
          }
          if (isNaN(iterationDuration) || lastTweenChangeEndTime > iterationDuration) {
            iterationDuration = lastTweenChangeEndTime;
          }
          if (tweenType === tweenTypes.TRANSFORM) {
            lastTransformGroupIndex = animationAnimationLength - tweenIndex;
            lastTransformGroupLength = animationAnimationLength;
          }
        }
      }
      if (!isNaN(lastTransformGroupIndex)) {
        let i2 = 0;
        forEachChildren(this, (tween) => {
          if (i2 >= lastTransformGroupIndex && i2 < lastTransformGroupLength) {
            tween._renderTransforms = 1;
            if (tween._composition === compositionTypes.blend) {
              forEachChildren(additive.animation, (additiveTween) => {
                if (additiveTween.id === tween.id) {
                  additiveTween._renderTransforms = 1;
                }
              });
            }
          }
          i2++;
        });
      }
    }
    if (!targetsLength) {
      console.warn(`No target found. Make sure the element you're trying to animate is accessible before creating your animation.`);
    }
    if (iterationDelay) {
      forEachChildren(this, (tween) => {
        if (!(tween._startTime - tween._delay)) {
          tween._delay -= iterationDelay;
        }
        tween._startTime -= iterationDelay;
      });
      iterationDuration -= iterationDelay;
    } else {
      iterationDelay = 0;
    }
    if (!iterationDuration) {
      iterationDuration = minValue;
      this.iterationCount = 0;
    }
    this.targets = parsedTargets;
    this.duration = iterationDuration === minValue ? minValue : clampInfinity((iterationDuration + this._loopDelay) * this.iterationCount - this._loopDelay) || minValue;
    this.onRender = onRender || animDefaults.onRender;
    this._ease = animEase;
    this._delay = iterationDelay;
    this.iterationDuration = iterationDuration;
    this._inlineStyles = animInlineStyles;
    if (!this._autoplay && shouldTriggerRender) this.onRender(this);
  }
  /**
   * @param  {Number} newDuration
   * @return {this}
   */
  stretch(newDuration) {
    const currentDuration = this.duration;
    if (currentDuration === normalizeTime(newDuration)) return this;
    const timeScale = newDuration / currentDuration;
    forEachChildren(this, (tween) => {
      tween._updateDuration = normalizeTime(tween._updateDuration * timeScale);
      tween._changeDuration = normalizeTime(tween._changeDuration * timeScale);
      tween._currentTime *= timeScale;
      tween._startTime *= timeScale;
      tween._absoluteStartTime *= timeScale;
    });
    return super.stretch(newDuration);
  }
  /**
   * @return {this}
   */
  refresh() {
    forEachChildren(this, (tween) => {
      const ogValue = getOriginalAnimatableValue(tween.target, tween.property, tween._tweenType);
      decomposeRawValue(ogValue, decomposedOriginalValue);
      tween._fromNumbers = cloneArray(decomposedOriginalValue.d);
      tween._fromNumber = decomposedOriginalValue.n;
      if (tween._func) {
        decomposeRawValue(tween._func(), toTargetObject);
        tween._toNumbers = cloneArray(toTargetObject.d);
        tween._strings = cloneArray(toTargetObject.s);
        tween._toNumber = toTargetObject.n;
      }
    });
    return this;
  }
  /**
   * Cancel the animation and revert all the values affected by this animation to their original state
   * @return {this}
   */
  revert() {
    super.revert();
    return cleanInlineStyles(this);
  }
  /**
   * @param  {Callback<this>} [callback]
   * @return {Promise}
   */
  then(callback) {
    return super.then(callback);
  }
}
const animate = (targets, parameters) => new JSAnimation2(targets, parameters, null, 0, false).init();
const transformsShorthands = ["x", "y", "z"];
[...transformsShorthands, ...validTransforms.filter((t2) => ["X", "Y", "Z"].some((axis) => t2.endsWith(axis)))];
isBrowser$1 && (isUnd(CSS) || !Object.hasOwnProperty.call(CSS, "registerProperty"));
const badgeVariants = cva(
  "inline-flex items-center rounded-full border px-2.5 py-0.5 text-xs font-semibold transition-colors focus:outline-none focus:ring-2 focus:ring-ring focus:ring-offset-2",
  {
    variants: {
      variant: {
        default: "border-transparent bg-primary text-primary-foreground hover:bg-primary/80",
        secondary: "border-transparent bg-secondary text-secondary-foreground hover:bg-secondary/80",
        destructive: "border-transparent bg-destructive text-destructive-foreground hover:bg-destructive/80",
        outline: "text-foreground"
      }
    },
    defaultVariants: {
      variant: "default"
    }
  }
);
function Badge({ className, variant, ...props }) {
  return /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: cn(badgeVariants({ variant }), className), ...props });
}
const useOnboarding = () => {
  const { user } = useAuth();
  const [status, setStatus] = reactExports.useState({
    isCompleted: false,
    isSkipped: false,
    needsOnboarding: false
  });
  reactExports.useEffect(() => {
    if (user) {
      checkOnboardingStatus();
    }
  }, [user]);
  const getUserKey = (key2) => {
    return user ? `${user.id}_${key2}` : key2;
  };
  const checkOnboardingStatus = () => {
    if (!user) {
      setStatus({
        isCompleted: false,
        isSkipped: false,
        needsOnboarding: false
      });
      return;
    }
    const completed = localStorage.getItem(getUserKey("onboarding_completed")) === "true";
    const skipped = localStorage.getItem(getUserKey("onboarding_skipped")) === "true";
    const shown = localStorage.getItem(getUserKey("onboarding_shown")) === "true";
    const needsOnboarding = !completed && !skipped && !shown;
    setStatus({
      isCompleted: completed,
      isSkipped: skipped,
      needsOnboarding
    });
  };
  const markCompleted = () => {
    if (!user) return;
    localStorage.setItem(getUserKey("onboarding_completed"), "true");
    localStorage.setItem(getUserKey("onboarding_shown"), "true");
    setStatus((prev2) => ({
      ...prev2,
      isCompleted: true,
      needsOnboarding: false
    }));
  };
  const markSkipped = () => {
    if (!user) return;
    localStorage.setItem(getUserKey("onboarding_skipped"), "true");
    localStorage.setItem(getUserKey("onboarding_shown"), "true");
    setStatus((prev2) => ({
      ...prev2,
      isSkipped: true,
      needsOnboarding: false
    }));
  };
  const reset = () => {
    if (!user) return;
    localStorage.removeItem(getUserKey("onboarding_completed"));
    localStorage.removeItem(getUserKey("onboarding_skipped"));
    localStorage.removeItem(getUserKey("onboarding_shown"));
    localStorage.removeItem(getUserKey("geolocation_permission_status"));
    localStorage.removeItem(getUserKey("notification_permission_status"));
    setStatus({
      isCompleted: false,
      isSkipped: false,
      needsOnboarding: true
    });
  };
  const shouldShowOnboarding = (isFirstLogin = false) => {
    return isFirstLogin || status.needsOnboarding;
  };
  const forceOnboarding = () => {
    if (!user) return;
    localStorage.removeItem(getUserKey("onboarding_completed"));
    localStorage.removeItem(getUserKey("onboarding_skipped"));
    localStorage.removeItem(getUserKey("onboarding_shown"));
    setStatus({
      isCompleted: false,
      isSkipped: false,
      needsOnboarding: true
    });
  };
  return {
    ...status,
    markCompleted,
    markSkipped,
    reset,
    forceOnboarding,
    shouldShowOnboarding,
    checkOnboardingStatus,
    getUserKey
    // Экспортируем для использования в других компонентах
  };
};
var earthRadius = 63710088e-1;
var factors = {
  centimeters: earthRadius * 100,
  centimetres: earthRadius * 100,
  degrees: 360 / (2 * Math.PI),
  feet: earthRadius * 3.28084,
  inches: earthRadius * 39.37,
  kilometers: earthRadius / 1e3,
  kilometres: earthRadius / 1e3,
  meters: earthRadius,
  metres: earthRadius,
  miles: earthRadius / 1609.344,
  millimeters: earthRadius * 1e3,
  millimetres: earthRadius * 1e3,
  nauticalmiles: earthRadius / 1852,
  radians: 1,
  yards: earthRadius * 1.0936
};
function feature(geom, properties2, options = {}) {
  const feat = { type: "Feature" };
  if (options.id === 0 || options.id) {
    feat.id = options.id;
  }
  if (options.bbox) {
    feat.bbox = options.bbox;
  }
  feat.properties = properties2 || {};
  feat.geometry = geom;
  return feat;
}
function point(coordinates, properties2, options = {}) {
  if (!coordinates) {
    throw new Error("coordinates is required");
  }
  if (!Array.isArray(coordinates)) {
    throw new Error("coordinates must be an Array");
  }
  if (coordinates.length < 2) {
    throw new Error("coordinates must be at least 2 numbers long");
  }
  if (!isNumber(coordinates[0]) || !isNumber(coordinates[1])) {
    throw new Error("coordinates must contain numbers");
  }
  const geom = {
    type: "Point",
    coordinates
  };
  return feature(geom, properties2, options);
}
function polygon(coordinates, properties2, options = {}) {
  for (const ring of coordinates) {
    if (ring.length < 4) {
      throw new Error(
        "Each LinearRing of a Polygon must have 4 or more Positions."
      );
    }
    if (ring[ring.length - 1].length !== ring[0].length) {
      throw new Error("First and last Position are not equivalent.");
    }
    for (let j2 = 0; j2 < ring[ring.length - 1].length; j2++) {
      if (ring[ring.length - 1][j2] !== ring[0][j2]) {
        throw new Error("First and last Position are not equivalent.");
      }
    }
  }
  const geom = {
    type: "Polygon",
    coordinates
  };
  return feature(geom, properties2, options);
}
function lineString(coordinates, properties2, options = {}) {
  if (coordinates.length < 2) {
    throw new Error("coordinates must be an array of two or more positions");
  }
  const geom = {
    type: "LineString",
    coordinates
  };
  return feature(geom, properties2, options);
}
function featureCollection(features, options = {}) {
  const fc = { type: "FeatureCollection" };
  if (options.id) {
    fc.id = options.id;
  }
  if (options.bbox) {
    fc.bbox = options.bbox;
  }
  fc.features = features;
  return fc;
}
function multiLineString(coordinates, properties2, options = {}) {
  const geom = {
    type: "MultiLineString",
    coordinates
  };
  return feature(geom, properties2, options);
}
function radiansToLength(radians, units = "kilometers") {
  const factor = factors[units];
  if (!factor) {
    throw new Error(units + " units is invalid");
  }
  return radians * factor;
}
function lengthToRadians(distance2, units = "kilometers") {
  const factor = factors[units];
  if (!factor) {
    throw new Error(units + " units is invalid");
  }
  return distance2 / factor;
}
function radiansToDegrees(radians) {
  const normalisedRadians = radians % (2 * Math.PI);
  return normalisedRadians * 180 / Math.PI;
}
function degreesToRadians(degrees2) {
  const normalisedDegrees = degrees2 % 360;
  return normalisedDegrees * Math.PI / 180;
}
function convertLength(length2, originalUnit = "kilometers", finalUnit = "kilometers") {
  if (!(length2 >= 0)) {
    throw new Error("length must be a positive number");
  }
  return radiansToLength(lengthToRadians(length2, originalUnit), finalUnit);
}
function isNumber(num) {
  return !isNaN(num) && num !== null && !Array.isArray(num);
}
function getCoord(coord) {
  if (!coord) {
    throw new Error("coord is required");
  }
  if (!Array.isArray(coord)) {
    if (coord.type === "Feature" && coord.geometry !== null && coord.geometry.type === "Point") {
      return [...coord.geometry.coordinates];
    }
    if (coord.type === "Point") {
      return [...coord.coordinates];
    }
  }
  if (Array.isArray(coord) && coord.length >= 2 && !Array.isArray(coord[0]) && !Array.isArray(coord[1])) {
    return [...coord];
  }
  throw new Error("coord must be GeoJSON Point or an Array of numbers");
}
function getCoords(coords) {
  if (Array.isArray(coords)) {
    return coords;
  }
  if (coords.type === "Feature") {
    if (coords.geometry !== null) {
      return coords.geometry.coordinates;
    }
  } else {
    if (coords.coordinates) {
      return coords.coordinates;
    }
  }
  throw new Error(
    "coords must be GeoJSON Feature, Geometry Object or an Array"
  );
}
function featureOf(feature2, type, name) {
  if (!feature2) {
    throw new Error("No feature passed");
  }
  if (!name) {
    throw new Error(".featureOf() requires a name");
  }
  if (!feature2 || feature2.type !== "Feature" || !feature2.geometry) {
    throw new Error(
      "Invalid input to " + name + ", Feature with geometry required"
    );
  }
  if (!feature2.geometry || feature2.geometry.type !== type) {
    throw new Error(
      "Invalid input to " + name + ": must be a " + type + ", given " + feature2.geometry.type
    );
  }
}
function getGeom(geojson) {
  if (geojson.type === "Feature") {
    return geojson.geometry;
  }
  return geojson;
}
function distance(from2, to, options = {}) {
  var coordinates1 = getCoord(from2);
  var coordinates2 = getCoord(to);
  var dLat = degreesToRadians(coordinates2[1] - coordinates1[1]);
  var dLon = degreesToRadians(coordinates2[0] - coordinates1[0]);
  var lat1 = degreesToRadians(coordinates1[1]);
  var lat2 = degreesToRadians(coordinates2[1]);
  var a2 = Math.pow(Math.sin(dLat / 2), 2) + Math.pow(Math.sin(dLon / 2), 2) * Math.cos(lat1) * Math.cos(lat2);
  return radiansToLength(
    2 * Math.atan2(Math.sqrt(a2), Math.sqrt(1 - a2)),
    options.units
  );
}
function coordEach(geojson, callback, excludeWrapCoord) {
  if (geojson === null) return;
  var j2, k2, l2, geometry, stopG, coords, geometryMaybeCollection, wrapShrink = 0, coordIndex = 0, isGeometryCollection, type = geojson.type, isFeatureCollection = type === "FeatureCollection", isFeature = type === "Feature", stop = isFeatureCollection ? geojson.features.length : 1;
  for (var featureIndex = 0; featureIndex < stop; featureIndex++) {
    geometryMaybeCollection = isFeatureCollection ? geojson.features[featureIndex].geometry : isFeature ? geojson.geometry : geojson;
    isGeometryCollection = geometryMaybeCollection ? geometryMaybeCollection.type === "GeometryCollection" : false;
    stopG = isGeometryCollection ? geometryMaybeCollection.geometries.length : 1;
    for (var geomIndex = 0; geomIndex < stopG; geomIndex++) {
      var multiFeatureIndex = 0;
      var geometryIndex = 0;
      geometry = isGeometryCollection ? geometryMaybeCollection.geometries[geomIndex] : geometryMaybeCollection;
      if (geometry === null) continue;
      coords = geometry.coordinates;
      var geomType = geometry.type;
      wrapShrink = 0;
      switch (geomType) {
        case null:
          break;
        case "Point":
          if (callback(
            coords,
            coordIndex,
            featureIndex,
            multiFeatureIndex,
            geometryIndex
          ) === false)
            return false;
          coordIndex++;
          multiFeatureIndex++;
          break;
        case "LineString":
        case "MultiPoint":
          for (j2 = 0; j2 < coords.length; j2++) {
            if (callback(
              coords[j2],
              coordIndex,
              featureIndex,
              multiFeatureIndex,
              geometryIndex
            ) === false)
              return false;
            coordIndex++;
            if (geomType === "MultiPoint") multiFeatureIndex++;
          }
          if (geomType === "LineString") multiFeatureIndex++;
          break;
        case "Polygon":
        case "MultiLineString":
          for (j2 = 0; j2 < coords.length; j2++) {
            for (k2 = 0; k2 < coords[j2].length - wrapShrink; k2++) {
              if (callback(
                coords[j2][k2],
                coordIndex,
                featureIndex,
                multiFeatureIndex,
                geometryIndex
              ) === false)
                return false;
              coordIndex++;
            }
            if (geomType === "MultiLineString") multiFeatureIndex++;
            if (geomType === "Polygon") geometryIndex++;
          }
          if (geomType === "Polygon") multiFeatureIndex++;
          break;
        case "MultiPolygon":
          for (j2 = 0; j2 < coords.length; j2++) {
            geometryIndex = 0;
            for (k2 = 0; k2 < coords[j2].length; k2++) {
              for (l2 = 0; l2 < coords[j2][k2].length - wrapShrink; l2++) {
                if (callback(
                  coords[j2][k2][l2],
                  coordIndex,
                  featureIndex,
                  multiFeatureIndex,
                  geometryIndex
                ) === false)
                  return false;
                coordIndex++;
              }
              geometryIndex++;
            }
            multiFeatureIndex++;
          }
          break;
        case "GeometryCollection":
          for (j2 = 0; j2 < geometry.geometries.length; j2++)
            if (coordEach(geometry.geometries[j2], callback) === false)
              return false;
          break;
        default:
          throw new Error("Unknown Geometry Type");
      }
    }
  }
}
function geomEach(geojson, callback) {
  var i2, j2, g2, geometry, stopG, geometryMaybeCollection, isGeometryCollection, featureProperties, featureBBox, featureId, featureIndex = 0, isFeatureCollection = geojson.type === "FeatureCollection", isFeature = geojson.type === "Feature", stop = isFeatureCollection ? geojson.features.length : 1;
  for (i2 = 0; i2 < stop; i2++) {
    geometryMaybeCollection = isFeatureCollection ? geojson.features[i2].geometry : isFeature ? geojson.geometry : geojson;
    featureProperties = isFeatureCollection ? geojson.features[i2].properties : isFeature ? geojson.properties : {};
    featureBBox = isFeatureCollection ? geojson.features[i2].bbox : isFeature ? geojson.bbox : void 0;
    featureId = isFeatureCollection ? geojson.features[i2].id : isFeature ? geojson.id : void 0;
    isGeometryCollection = geometryMaybeCollection ? geometryMaybeCollection.type === "GeometryCollection" : false;
    stopG = isGeometryCollection ? geometryMaybeCollection.geometries.length : 1;
    for (g2 = 0; g2 < stopG; g2++) {
      geometry = isGeometryCollection ? geometryMaybeCollection.geometries[g2] : geometryMaybeCollection;
      if (geometry === null) {
        if (callback(
          null,
          featureIndex,
          featureProperties,
          featureBBox,
          featureId
        ) === false)
          return false;
        continue;
      }
      switch (geometry.type) {
        case "Point":
        case "LineString":
        case "MultiPoint":
        case "Polygon":
        case "MultiLineString":
        case "MultiPolygon": {
          if (callback(
            geometry,
            featureIndex,
            featureProperties,
            featureBBox,
            featureId
          ) === false)
            return false;
          break;
        }
        case "GeometryCollection": {
          for (j2 = 0; j2 < geometry.geometries.length; j2++) {
            if (callback(
              geometry.geometries[j2],
              featureIndex,
              featureProperties,
              featureBBox,
              featureId
            ) === false)
              return false;
          }
          break;
        }
        default:
          throw new Error("Unknown Geometry Type");
      }
    }
    featureIndex++;
  }
}
function flattenEach(geojson, callback) {
  geomEach(geojson, function(geometry, featureIndex, properties2, bbox, id2) {
    var type = geometry === null ? null : geometry.type;
    switch (type) {
      case null:
      case "Point":
      case "LineString":
      case "Polygon":
        if (callback(
          feature(geometry, properties2, { bbox, id: id2 }),
          featureIndex,
          0
        ) === false)
          return false;
        return;
    }
    var geomType;
    switch (type) {
      case "MultiPoint":
        geomType = "Point";
        break;
      case "MultiLineString":
        geomType = "LineString";
        break;
      case "MultiPolygon":
        geomType = "Polygon";
        break;
    }
    for (var multiFeatureIndex = 0; multiFeatureIndex < geometry.coordinates.length; multiFeatureIndex++) {
      var coordinate = geometry.coordinates[multiFeatureIndex];
      var geom = {
        type: geomType,
        coordinates: coordinate
      };
      if (callback(feature(geom, properties2), featureIndex, multiFeatureIndex) === false)
        return false;
    }
  });
}
function segmentEach(geojson, callback) {
  flattenEach(geojson, function(feature2, featureIndex, multiFeatureIndex) {
    var segmentIndex = 0;
    if (!feature2.geometry) return;
    var type = feature2.geometry.type;
    if (type === "Point" || type === "MultiPoint") return;
    var previousCoords;
    var previousFeatureIndex = 0;
    var previousMultiIndex = 0;
    var prevGeomIndex = 0;
    if (coordEach(
      feature2,
      function(currentCoord, coordIndex, featureIndexCoord, multiPartIndexCoord, geometryIndex) {
        if (previousCoords === void 0 || featureIndex > previousFeatureIndex || multiPartIndexCoord > previousMultiIndex || geometryIndex > prevGeomIndex) {
          previousCoords = currentCoord;
          previousFeatureIndex = featureIndex;
          previousMultiIndex = multiPartIndexCoord;
          prevGeomIndex = geometryIndex;
          segmentIndex = 0;
          return;
        }
        var currentSegment = lineString(
          [previousCoords, currentCoord],
          feature2.properties
        );
        if (callback(
          currentSegment,
          featureIndex,
          multiFeatureIndex,
          geometryIndex,
          segmentIndex
        ) === false)
          return false;
        segmentIndex++;
        previousCoords = currentCoord;
      }
    ) === false)
      return false;
  });
}
const epsilon = 11102230246251565e-32;
const splitter = 134217729;
const resulterrbound = (3 + 8 * epsilon) * epsilon;
function sum(elen, e2, flen, f2, h2) {
  let Q, Qnew, hh, bvirt;
  let enow = e2[0];
  let fnow = f2[0];
  let eindex = 0;
  let findex = 0;
  if (fnow > enow === fnow > -enow) {
    Q = enow;
    enow = e2[++eindex];
  } else {
    Q = fnow;
    fnow = f2[++findex];
  }
  let hindex = 0;
  if (eindex < elen && findex < flen) {
    if (fnow > enow === fnow > -enow) {
      Qnew = enow + Q;
      hh = Q - (Qnew - enow);
      enow = e2[++eindex];
    } else {
      Qnew = fnow + Q;
      hh = Q - (Qnew - fnow);
      fnow = f2[++findex];
    }
    Q = Qnew;
    if (hh !== 0) {
      h2[hindex++] = hh;
    }
    while (eindex < elen && findex < flen) {
      if (fnow > enow === fnow > -enow) {
        Qnew = Q + enow;
        bvirt = Qnew - Q;
        hh = Q - (Qnew - bvirt) + (enow - bvirt);
        enow = e2[++eindex];
      } else {
        Qnew = Q + fnow;
        bvirt = Qnew - Q;
        hh = Q - (Qnew - bvirt) + (fnow - bvirt);
        fnow = f2[++findex];
      }
      Q = Qnew;
      if (hh !== 0) {
        h2[hindex++] = hh;
      }
    }
  }
  while (eindex < elen) {
    Qnew = Q + enow;
    bvirt = Qnew - Q;
    hh = Q - (Qnew - bvirt) + (enow - bvirt);
    enow = e2[++eindex];
    Q = Qnew;
    if (hh !== 0) {
      h2[hindex++] = hh;
    }
  }
  while (findex < flen) {
    Qnew = Q + fnow;
    bvirt = Qnew - Q;
    hh = Q - (Qnew - bvirt) + (fnow - bvirt);
    fnow = f2[++findex];
    Q = Qnew;
    if (hh !== 0) {
      h2[hindex++] = hh;
    }
  }
  if (Q !== 0 || hindex === 0) {
    h2[hindex++] = Q;
  }
  return hindex;
}
function estimate(elen, e2) {
  let Q = e2[0];
  for (let i2 = 1; i2 < elen; i2++) Q += e2[i2];
  return Q;
}
function vec(n2) {
  return new Float64Array(n2);
}
const ccwerrboundA = (3 + 16 * epsilon) * epsilon;
const ccwerrboundB = (2 + 12 * epsilon) * epsilon;
const ccwerrboundC = (9 + 64 * epsilon) * epsilon * epsilon;
const B = vec(4);
const C1 = vec(8);
const C2 = vec(12);
const D = vec(16);
const u = vec(4);
function orient2dadapt(ax, ay, bx, by, cx2, cy, detsum) {
  let acxtail, acytail, bcxtail, bcytail;
  let bvirt, c2, ahi, alo, bhi, blo, _i2, _j, _0, s1, s0, t1, t0, u3;
  const acx = ax - cx2;
  const bcx = bx - cx2;
  const acy = ay - cy;
  const bcy = by - cy;
  s1 = acx * bcy;
  c2 = splitter * acx;
  ahi = c2 - (c2 - acx);
  alo = acx - ahi;
  c2 = splitter * bcy;
  bhi = c2 - (c2 - bcy);
  blo = bcy - bhi;
  s0 = alo * blo - (s1 - ahi * bhi - alo * bhi - ahi * blo);
  t1 = acy * bcx;
  c2 = splitter * acy;
  ahi = c2 - (c2 - acy);
  alo = acy - ahi;
  c2 = splitter * bcx;
  bhi = c2 - (c2 - bcx);
  blo = bcx - bhi;
  t0 = alo * blo - (t1 - ahi * bhi - alo * bhi - ahi * blo);
  _i2 = s0 - t0;
  bvirt = s0 - _i2;
  B[0] = s0 - (_i2 + bvirt) + (bvirt - t0);
  _j = s1 + _i2;
  bvirt = _j - s1;
  _0 = s1 - (_j - bvirt) + (_i2 - bvirt);
  _i2 = _0 - t1;
  bvirt = _0 - _i2;
  B[1] = _0 - (_i2 + bvirt) + (bvirt - t1);
  u3 = _j + _i2;
  bvirt = u3 - _j;
  B[2] = _j - (u3 - bvirt) + (_i2 - bvirt);
  B[3] = u3;
  let det = estimate(4, B);
  let errbound = ccwerrboundB * detsum;
  if (det >= errbound || -det >= errbound) {
    return det;
  }
  bvirt = ax - acx;
  acxtail = ax - (acx + bvirt) + (bvirt - cx2);
  bvirt = bx - bcx;
  bcxtail = bx - (bcx + bvirt) + (bvirt - cx2);
  bvirt = ay - acy;
  acytail = ay - (acy + bvirt) + (bvirt - cy);
  bvirt = by - bcy;
  bcytail = by - (bcy + bvirt) + (bvirt - cy);
  if (acxtail === 0 && acytail === 0 && bcxtail === 0 && bcytail === 0) {
    return det;
  }
  errbound = ccwerrboundC * detsum + resulterrbound * Math.abs(det);
  det += acx * bcytail + bcy * acxtail - (acy * bcxtail + bcx * acytail);
  if (det >= errbound || -det >= errbound) return det;
  s1 = acxtail * bcy;
  c2 = splitter * acxtail;
  ahi = c2 - (c2 - acxtail);
  alo = acxtail - ahi;
  c2 = splitter * bcy;
  bhi = c2 - (c2 - bcy);
  blo = bcy - bhi;
  s0 = alo * blo - (s1 - ahi * bhi - alo * bhi - ahi * blo);
  t1 = acytail * bcx;
  c2 = splitter * acytail;
  ahi = c2 - (c2 - acytail);
  alo = acytail - ahi;
  c2 = splitter * bcx;
  bhi = c2 - (c2 - bcx);
  blo = bcx - bhi;
  t0 = alo * blo - (t1 - ahi * bhi - alo * bhi - ahi * blo);
  _i2 = s0 - t0;
  bvirt = s0 - _i2;
  u[0] = s0 - (_i2 + bvirt) + (bvirt - t0);
  _j = s1 + _i2;
  bvirt = _j - s1;
  _0 = s1 - (_j - bvirt) + (_i2 - bvirt);
  _i2 = _0 - t1;
  bvirt = _0 - _i2;
  u[1] = _0 - (_i2 + bvirt) + (bvirt - t1);
  u3 = _j + _i2;
  bvirt = u3 - _j;
  u[2] = _j - (u3 - bvirt) + (_i2 - bvirt);
  u[3] = u3;
  const C1len = sum(4, B, 4, u, C1);
  s1 = acx * bcytail;
  c2 = splitter * acx;
  ahi = c2 - (c2 - acx);
  alo = acx - ahi;
  c2 = splitter * bcytail;
  bhi = c2 - (c2 - bcytail);
  blo = bcytail - bhi;
  s0 = alo * blo - (s1 - ahi * bhi - alo * bhi - ahi * blo);
  t1 = acy * bcxtail;
  c2 = splitter * acy;
  ahi = c2 - (c2 - acy);
  alo = acy - ahi;
  c2 = splitter * bcxtail;
  bhi = c2 - (c2 - bcxtail);
  blo = bcxtail - bhi;
  t0 = alo * blo - (t1 - ahi * bhi - alo * bhi - ahi * blo);
  _i2 = s0 - t0;
  bvirt = s0 - _i2;
  u[0] = s0 - (_i2 + bvirt) + (bvirt - t0);
  _j = s1 + _i2;
  bvirt = _j - s1;
  _0 = s1 - (_j - bvirt) + (_i2 - bvirt);
  _i2 = _0 - t1;
  bvirt = _0 - _i2;
  u[1] = _0 - (_i2 + bvirt) + (bvirt - t1);
  u3 = _j + _i2;
  bvirt = u3 - _j;
  u[2] = _j - (u3 - bvirt) + (_i2 - bvirt);
  u[3] = u3;
  const C2len = sum(C1len, C1, 4, u, C2);
  s1 = acxtail * bcytail;
  c2 = splitter * acxtail;
  ahi = c2 - (c2 - acxtail);
  alo = acxtail - ahi;
  c2 = splitter * bcytail;
  bhi = c2 - (c2 - bcytail);
  blo = bcytail - bhi;
  s0 = alo * blo - (s1 - ahi * bhi - alo * bhi - ahi * blo);
  t1 = acytail * bcxtail;
  c2 = splitter * acytail;
  ahi = c2 - (c2 - acytail);
  alo = acytail - ahi;
  c2 = splitter * bcxtail;
  bhi = c2 - (c2 - bcxtail);
  blo = bcxtail - bhi;
  t0 = alo * blo - (t1 - ahi * bhi - alo * bhi - ahi * blo);
  _i2 = s0 - t0;
  bvirt = s0 - _i2;
  u[0] = s0 - (_i2 + bvirt) + (bvirt - t0);
  _j = s1 + _i2;
  bvirt = _j - s1;
  _0 = s1 - (_j - bvirt) + (_i2 - bvirt);
  _i2 = _0 - t1;
  bvirt = _0 - _i2;
  u[1] = _0 - (_i2 + bvirt) + (bvirt - t1);
  u3 = _j + _i2;
  bvirt = u3 - _j;
  u[2] = _j - (u3 - bvirt) + (_i2 - bvirt);
  u[3] = u3;
  const Dlen = sum(C2len, C2, 4, u, D);
  return D[Dlen - 1];
}
function orient2d(ax, ay, bx, by, cx2, cy) {
  const detleft = (ay - cy) * (bx - cx2);
  const detright = (ax - cx2) * (by - cy);
  const det = detleft - detright;
  const detsum = Math.abs(detleft + detright);
  if (Math.abs(det) >= ccwerrboundA * detsum) return det;
  return -orient2dadapt(ax, ay, bx, by, cx2, cy, detsum);
}
function pointInPolygon(p2, polygon2) {
  var i2;
  var ii;
  var k2 = 0;
  var f2;
  var u1;
  var v1;
  var u2;
  var v2;
  var currentP;
  var nextP;
  var x2 = p2[0];
  var y2 = p2[1];
  var numContours = polygon2.length;
  for (i2 = 0; i2 < numContours; i2++) {
    ii = 0;
    var contour = polygon2[i2];
    var contourLen = contour.length - 1;
    currentP = contour[0];
    if (currentP[0] !== contour[contourLen][0] && currentP[1] !== contour[contourLen][1]) {
      throw new Error("First and last coordinates in a ring must be the same");
    }
    u1 = currentP[0] - x2;
    v1 = currentP[1] - y2;
    for (ii; ii < contourLen; ii++) {
      nextP = contour[ii + 1];
      u2 = nextP[0] - x2;
      v2 = nextP[1] - y2;
      if (v1 === 0 && v2 === 0) {
        if (u2 <= 0 && u1 >= 0 || u1 <= 0 && u2 >= 0) {
          return 0;
        }
      } else if (v2 >= 0 && v1 <= 0 || v2 <= 0 && v1 >= 0) {
        f2 = orient2d(u1, u2, v1, v2, 0, 0);
        if (f2 === 0) {
          return 0;
        }
        if (f2 > 0 && v2 > 0 && v1 <= 0 || f2 < 0 && v2 <= 0 && v1 > 0) {
          k2++;
        }
      }
      currentP = nextP;
      v1 = v2;
      u1 = u2;
    }
  }
  if (k2 % 2 === 0) {
    return false;
  }
  return true;
}
function booleanPointInPolygon(point2, polygon2, options = {}) {
  if (!point2) {
    throw new Error("point is required");
  }
  if (!polygon2) {
    throw new Error("polygon is required");
  }
  const pt = getCoord(point2);
  const geom = getGeom(polygon2);
  const type = geom.type;
  const bbox = polygon2.bbox;
  let polys = geom.coordinates;
  if (bbox && inBBox(pt, bbox) === false) {
    return false;
  }
  if (type === "Polygon") {
    polys = [polys];
  }
  let result = false;
  for (var i2 = 0; i2 < polys.length; ++i2) {
    const polyResult = pointInPolygon(pt, polys[i2]);
    if (polyResult === 0) return options.ignoreBoundary ? false : true;
    else if (polyResult) result = true;
  }
  return result;
}
function inBBox(pt, bbox) {
  return bbox[0] <= pt[0] && bbox[1] <= pt[1] && bbox[2] >= pt[0] && bbox[3] >= pt[1];
}
function polygonToLine(poly, options = {}) {
  const geom = getGeom(poly);
  if (!options.properties && poly.type === "Feature") {
    options.properties = poly.properties;
  }
  switch (geom.type) {
    case "Polygon":
      return singlePolygonToLine(geom, options);
    case "MultiPolygon":
      return multiPolygonToLine(geom, options);
    default:
      throw new Error("invalid poly");
  }
}
function singlePolygonToLine(poly, options = {}) {
  const geom = getGeom(poly);
  const coords = geom.coordinates;
  const properties2 = options.properties ? options.properties : poly.type === "Feature" ? poly.properties : {};
  return coordsToLine(coords, properties2);
}
function multiPolygonToLine(multiPoly, options = {}) {
  const geom = getGeom(multiPoly);
  const coords = geom.coordinates;
  const properties2 = options.properties ? options.properties : multiPoly.type === "Feature" ? multiPoly.properties : {};
  const lines = [];
  coords.forEach((coord) => {
    lines.push(coordsToLine(coord, properties2));
  });
  return featureCollection(lines);
}
function coordsToLine(coords, properties2) {
  if (coords.length > 1) {
    return multiLineString(coords, properties2);
  }
  return lineString(coords[0], properties2);
}
var __defProp2 = Object.defineProperty;
var __defProps = Object.defineProperties;
var __getOwnPropDescs = Object.getOwnPropertyDescriptors;
var __getOwnPropSymbols = Object.getOwnPropertySymbols;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __propIsEnum = Object.prototype.propertyIsEnumerable;
var __defNormalProp2 = (obj, key2, value) => key2 in obj ? __defProp2(obj, key2, { enumerable: true, configurable: true, writable: true, value }) : obj[key2] = value;
var __spreadValues = (a2, b2) => {
  for (var prop in b2 || (b2 = {}))
    if (__hasOwnProp.call(b2, prop))
      __defNormalProp2(a2, prop, b2[prop]);
  if (__getOwnPropSymbols)
    for (var prop of __getOwnPropSymbols(b2)) {
      if (__propIsEnum.call(b2, prop))
        __defNormalProp2(a2, prop, b2[prop]);
    }
  return a2;
};
var __spreadProps = (a2, b2) => __defProps(a2, __getOwnPropDescs(b2));
function nearestPointOnLine(lines, pt, options = {}) {
  if (!lines || !pt) {
    throw new Error("lines and pt are required arguments");
  }
  const ptPos = getCoord(pt);
  let closestPt = point([Infinity, Infinity], {
    dist: Infinity,
    index: -1,
    multiFeatureIndex: -1,
    location: -1
  });
  let length2 = 0;
  flattenEach(
    lines,
    function(line2, _featureIndex, multiFeatureIndex) {
      const coords = getCoords(line2);
      for (let i2 = 0; i2 < coords.length - 1; i2++) {
        const start = point(coords[i2]);
        start.properties.dist = distance(pt, start, options);
        const startPos = getCoord(start);
        const stop = point(coords[i2 + 1]);
        stop.properties.dist = distance(pt, stop, options);
        const stopPos = getCoord(stop);
        const sectionLength = distance(start, stop, options);
        let intersectPos;
        let wasEnd;
        if (startPos[0] === ptPos[0] && startPos[1] === ptPos[1]) {
          [intersectPos, , wasEnd] = [startPos, void 0, false];
        } else if (stopPos[0] === ptPos[0] && stopPos[1] === ptPos[1]) {
          [intersectPos, , wasEnd] = [stopPos, void 0, true];
        } else {
          [intersectPos, , wasEnd] = nearestPointOnSegment(
            start.geometry.coordinates,
            stop.geometry.coordinates,
            getCoord(pt)
          );
        }
        let intersectPt;
        if (intersectPos) {
          intersectPt = point(intersectPos, {
            dist: distance(pt, intersectPos, options),
            multiFeatureIndex,
            location: length2 + distance(start, intersectPos, options)
          });
        }
        if (intersectPt && intersectPt.properties.dist < closestPt.properties.dist) {
          closestPt = __spreadProps(__spreadValues({}, intersectPt), {
            properties: __spreadProps(__spreadValues({}, intersectPt.properties), {
              // Legacy behaviour where index progresses to next segment # if we
              // went with the end point this iteration.
              index: wasEnd ? i2 + 1 : i2
            })
          });
        }
        length2 += sectionLength;
      }
    }
  );
  return closestPt;
}
function dot$1(v1, v2) {
  const [v1x, v1y, v1z] = v1;
  const [v2x, v2y, v2z] = v2;
  return v1x * v2x + v1y * v2y + v1z * v2z;
}
function cross(v1, v2) {
  const [v1x, v1y, v1z] = v1;
  const [v2x, v2y, v2z] = v2;
  return [v1y * v2z - v1z * v2y, v1z * v2x - v1x * v2z, v1x * v2y - v1y * v2x];
}
function magnitude(v2) {
  return Math.sqrt(Math.pow(v2[0], 2) + Math.pow(v2[1], 2) + Math.pow(v2[2], 2));
}
function angle(v1, v2) {
  const theta = dot$1(v1, v2) / (magnitude(v1) * magnitude(v2));
  return Math.acos(Math.min(Math.max(theta, -1), 1));
}
function lngLatToVector(a2) {
  const lat = degreesToRadians(a2[1]);
  const lng = degreesToRadians(a2[0]);
  return [
    Math.cos(lat) * Math.cos(lng),
    Math.cos(lat) * Math.sin(lng),
    Math.sin(lat)
  ];
}
function vectorToLngLat(v2) {
  const [x2, y2, z2] = v2;
  const lat = radiansToDegrees(Math.asin(z2));
  const lng = radiansToDegrees(Math.atan2(y2, x2));
  return [lng, lat];
}
function nearestPointOnSegment(posA, posB, posC) {
  const A2 = lngLatToVector(posA);
  const B2 = lngLatToVector(posB);
  const C = lngLatToVector(posC);
  const [Cx, Cy, Cz] = C;
  const [D2, E2, F] = cross(A2, B2);
  const a2 = E2 * Cz - F * Cy;
  const b2 = F * Cx - D2 * Cz;
  const c2 = D2 * Cy - E2 * Cx;
  const f2 = c2 * E2 - b2 * F;
  const g2 = a2 * F - c2 * D2;
  const h2 = b2 * D2 - a2 * E2;
  const t2 = 1 / Math.sqrt(Math.pow(f2, 2) + Math.pow(g2, 2) + Math.pow(h2, 2));
  const I1 = [f2 * t2, g2 * t2, h2 * t2];
  const I2 = [-1 * f2 * t2, -1 * g2 * t2, -1 * h2 * t2];
  const angleAB = angle(A2, B2);
  const angleAI1 = angle(A2, I1);
  const angleBI1 = angle(B2, I1);
  const angleAI2 = angle(A2, I2);
  const angleBI2 = angle(B2, I2);
  let I;
  if (angleAI1 < angleAI2 && angleAI1 < angleBI2 || angleBI1 < angleAI2 && angleBI1 < angleBI2) {
    I = I1;
  } else {
    I = I2;
  }
  if (angle(A2, I) > angleAB || angle(B2, I) > angleAB) {
    if (distance(vectorToLngLat(I), vectorToLngLat(A2)) <= distance(vectorToLngLat(I), vectorToLngLat(B2))) {
      return [vectorToLngLat(A2), true, false];
    } else {
      return [vectorToLngLat(B2), false, true];
    }
  }
  return [vectorToLngLat(I), false, false];
}
function rhumbDistance(from2, to, options = {}) {
  const origin = getCoord(from2);
  const destination = getCoord(to);
  destination[0] += destination[0] - origin[0] > 180 ? -360 : origin[0] - destination[0] > 180 ? 360 : 0;
  const distanceInMeters = calculateRhumbDistance(origin, destination);
  const distance2 = convertLength(distanceInMeters, "meters", options.units);
  return distance2;
}
function calculateRhumbDistance(origin, destination, radius) {
  radius = radius === void 0 ? earthRadius : Number(radius);
  const R2 = radius;
  const phi1 = origin[1] * Math.PI / 180;
  const phi2 = destination[1] * Math.PI / 180;
  const DeltaPhi = phi2 - phi1;
  let DeltaLambda = Math.abs(destination[0] - origin[0]) * Math.PI / 180;
  if (DeltaLambda > Math.PI) {
    DeltaLambda -= 2 * Math.PI;
  }
  const DeltaPsi = Math.log(
    Math.tan(phi2 / 2 + Math.PI / 4) / Math.tan(phi1 / 2 + Math.PI / 4)
  );
  const q2 = Math.abs(DeltaPsi) > 1e-11 ? DeltaPhi / DeltaPsi : Math.cos(phi1);
  const delta = Math.sqrt(
    DeltaPhi * DeltaPhi + q2 * q2 * DeltaLambda * DeltaLambda
  );
  const dist = delta * R2;
  return dist;
}
function pointToLineDistance(pt, line2, options = {}) {
  var _a2, _b2;
  const method = (_a2 = options.method) != null ? _a2 : "geodesic";
  const units = (_b2 = options.units) != null ? _b2 : "kilometers";
  if (!pt) {
    throw new Error("pt is required");
  }
  if (Array.isArray(pt)) {
    pt = point(pt);
  } else if (pt.type === "Point") {
    pt = feature(pt);
  } else {
    featureOf(pt, "Point", "point");
  }
  if (!line2) {
    throw new Error("line is required");
  }
  if (Array.isArray(line2)) {
    line2 = lineString(line2);
  } else if (line2.type === "LineString") {
    line2 = feature(line2);
  } else {
    featureOf(line2, "LineString", "line");
  }
  let distance2 = Infinity;
  const p2 = pt.geometry.coordinates;
  segmentEach(line2, (segment) => {
    if (segment) {
      const a2 = segment.geometry.coordinates[0];
      const b2 = segment.geometry.coordinates[1];
      const d2 = distanceToSegment(p2, a2, b2, { method });
      if (d2 < distance2) {
        distance2 = d2;
      }
    }
  });
  return convertLength(distance2, "degrees", units);
}
function distanceToSegment(p2, a2, b2, options) {
  if (options.method === "geodesic") {
    const nearest = nearestPointOnLine(lineString([a2, b2]).geometry, p2, {
      units: "degrees"
    });
    return nearest.properties.dist;
  }
  const v2 = [b2[0] - a2[0], b2[1] - a2[1]];
  const w2 = [p2[0] - a2[0], p2[1] - a2[1]];
  const c1 = dot(w2, v2);
  if (c1 <= 0) {
    return rhumbDistance(p2, a2, { units: "degrees" });
  }
  const c2 = dot(v2, v2);
  if (c2 <= c1) {
    return rhumbDistance(p2, b2, { units: "degrees" });
  }
  const b22 = c1 / c2;
  const Pb = [a2[0] + b22 * v2[0], a2[1] + b22 * v2[1]];
  return rhumbDistance(p2, Pb, { units: "degrees" });
}
function dot(u2, v2) {
  return u2[0] * v2[0] + u2[1] * v2[1];
}
const INCIDENT_DURATION_LIMITS = {
  "theft": 24,
  // Кража - 24 часа
  "assault": 24,
  // Нападение - 24 часа  
  "vandalism": 24,
  // Вандализм - 24 часа
  "traffic_accident": 4,
  // ДТП - 4 часа
  "suspicious_activity": 7,
  // Подозрительная активность - 7 часов
  "suspicious": 7,
  // Подозрительная активность (альтернативное название) - 7 часов
  "other": 3,
  // Прочее - 3 часа
  "drug_activity": 12,
  // Наркотическая активность - 12 часов
  "domestic_violence": 24,
  // Домашнее насилие - 24 часа
  "fire": 6,
  // Пожар - 6 часов
  "medical_emergency": 2
  // Медицинская экстренная ситуация - 2 часа
};
const expirationCache = /* @__PURE__ */ new Map();
const CACHE_DURATION = 3e4;
const clearExpiredCache = () => {
  const now2 = Date.now();
  for (const [key2, value] of expirationCache.entries()) {
    if (now2 - value.timestamp > CACHE_DURATION) {
      expirationCache.delete(key2);
    }
  }
};
const isIncidentExpired = (incident) => {
  const createdAtStr = incident.created_at || incident.timestamp.toISOString();
  const cacheKey = `${incident.id}-${createdAtStr}-${incident.type}`;
  const now2 = Date.now();
  const cached = expirationCache.get(cacheKey);
  if (cached && now2 - cached.timestamp < CACHE_DURATION) {
    return cached.expired;
  }
  if (expirationCache.size > 100) {
    clearExpiredCache();
  }
  const durationLimit = INCIDENT_DURATION_LIMITS[incident.type] || 24;
  const createdAt = incident.created_at ? new Date(incident.created_at) : incident.timestamp;
  const hoursSinceCreation = (now2 - createdAt.getTime()) / (1e3 * 60 * 60);
  const expired = hoursSinceCreation >= durationLimit;
  expirationCache.set(cacheKey, { expired, timestamp: now2 });
  return expired;
};
const filterActiveIncidents = (incidents2) => {
  if (incidents2.length > 50) {
    const activeIncidents = [];
    const batchSize = 25;
    for (let i2 = 0; i2 < incidents2.length; i2 += batchSize) {
      const batch = incidents2.slice(i2, i2 + batchSize);
      const activeBatch = batch.filter((incident) => !isIncidentExpired(incident));
      activeIncidents.push(...activeBatch);
    }
    return activeIncidents;
  }
  return incidents2.filter((incident) => !isIncidentExpired(incident));
};
const getRemainingTime = (incident) => {
  const durationLimit = INCIDENT_DURATION_LIMITS[incident.type] || 24;
  const createdAt = incident.created_at ? new Date(incident.created_at) : incident.timestamp;
  const now2 = /* @__PURE__ */ new Date();
  const hoursSinceCreation = (now2.getTime() - createdAt.getTime()) / (1e3 * 60 * 60);
  return Math.max(0, durationLimit - hoursSinceCreation);
};
const formatRemainingTime = (hours, t2) => {
  if (hours <= 0) return t2("expired");
  if (hours < 1) {
    const minutes = Math.round(hours * 60);
    return `${minutes}${t2("minutesShort")}`;
  } else if (hours < 24) {
    return `${Math.round(hours)}${t2("hoursShort")}`;
  } else {
    const days = Math.floor(hours / 24);
    const remainingHours = Math.round(hours % 24);
    return remainingHours > 0 ? `${days}${t2("daysShort")} ${remainingHours}${t2("hoursShort")}` : `${days}${t2("daysShort")}`;
  }
};
const getTimeIndicatorColor = (remainingHours, totalDuration) => {
  const percentage = remainingHours / totalDuration;
  if (percentage > 0.5) return "text-green-500";
  if (percentage > 0.25) return "text-yellow-500";
  return "text-red-500";
};
const formatTimeAMPM = (date) => {
  return date.toLocaleTimeString("en-US", {
    hour: "numeric",
    minute: "2-digit",
    hour12: true
  });
};
const formatDateTimeAMPM = (date) => {
  return date.toLocaleString("en-US", {
    year: "numeric",
    month: "2-digit",
    day: "2-digit",
    hour: "numeric",
    minute: "2-digit",
    hour12: true
  });
};
const formatDateOnly = (date) => {
  return date.toLocaleDateString("en-US", {
    year: "numeric",
    month: "2-digit",
    day: "2-digit"
  });
};
class RealtimeService {
  constructor() {
    __publicField(this, "channels", {});
    __publicField(this, "subscriptionQueue", {});
    __publicField(this, "channelCounter", 0);
  }
  /** Получить (или создать) канал. subscribe вызывается ровно один раз */
  getChannel(name) {
    console.log(`[Realtime] 🚫 ALL REALTIME DISABLED - Channel '${name}' blocked`);
    return this.createDummyChannel();
  }
  normalizeChannelName(name) {
    if (name.includes("incidents_notifications_")) {
      return "incidents_notifications_global";
    }
    if (name.includes("user_stats_changes_")) {
      return "user_stats_changes_global";
    }
    if (name.includes("notifications-changes-")) {
      return "notifications-changes-global";
    }
    if (name.includes("community-messages-")) {
      return "community-messages-global";
    }
    return name;
  }
  async createChannelInternal(name) {
    return new Promise((resolve, reject) => {
      try {
        const uniqueName = `${name}_${++this.channelCounter}_${Date.now()}`;
        console.log(`[Realtime] 🔄 Creating channel '${name}' with unique name '${uniqueName}'`);
        const channel = supabase.channel(uniqueName);
        const subscribedChannel = channel.subscribe();
        this.channels[name] = subscribedChannel;
        console.log(`[Realtime] ✅ Channel '${name}' created successfully`);
        setTimeout(() => {
          resolve(subscribedChannel);
        }, 10);
      } catch (error) {
        console.error(`[Realtime] ❌ Error creating channel '${name}':`, error);
        delete this.channels[name];
        reject(error);
      }
    });
  }
  /** Синхронная версия для обратной совместимости */
  getChannelSync(name) {
    if (this.channels[name]) {
      return this.channels[name];
    }
    if (this.subscriptionQueue[name]) {
      return this.createDummyChannel();
    }
    return this.createChannelSync(name);
  }
  createChannelSync(name) {
    try {
      const uniqueName = `${name}_${++this.channelCounter}_${Date.now()}`;
      const channel = supabase.channel(uniqueName);
      const subscribedChannel = channel.subscribe();
      this.channels[name] = subscribedChannel;
      console.log(`[Realtime] ✅ Channel '${name}' created`);
      return subscribedChannel;
    } catch (error) {
      console.error(`[Realtime] ❌ Error creating channel '${name}':`, error);
      delete this.channels[name];
      return this.createDummyChannel();
    }
  }
  createDummyChannel() {
    return {
      on: () => ({ subscribe: () => ({}) }),
      subscribe: () => ({}),
      unsubscribe: () => {
      },
      send: () => {
      },
      presence: { track: () => {
      }, untrack: () => {
      }, subscribe: () => {
      }, state: {} }
    };
  }
  /** Полностью закрыть канал, если он больше не нужен */
  dropChannel(name) {
    const ch = this.channels[name];
    if (ch) {
      try {
        ch.unsubscribe();
        delete this.channels[name];
        delete this.subscriptionQueue[name];
      } catch (error) {
        console.error(`[Realtime] ❌ Error dropping channel '${name}':`, error);
        delete this.channels[name];
        delete this.subscriptionQueue[name];
      }
    }
  }
  /** Получить информацию о текущих каналах для отладки */
  getDebugInfo() {
    console.log("[Realtime] 📊 Current channels:", Object.keys(this.channels));
    console.log("[Realtime] 🔄 Subscription queue:", Object.keys(this.subscriptionQueue));
    return {
      channels: Object.keys(this.channels),
      subscriptionQueue: Object.keys(this.subscriptionQueue),
      channelCount: Object.keys(this.channels).length,
      queueCount: Object.keys(this.subscriptionQueue).length,
      channelCounter: this.channelCounter
    };
  }
  /** Принудительно очистить все каналы */
  forceReset() {
    console.log("[Realtime] 🔄 Force reset all channels and queue");
    Object.keys(this.channels).forEach((name) => {
      try {
        this.channels[name].unsubscribe();
      } catch (error) {
        console.error(`[Realtime] ❌ Error during force reset for '${name}':`, error);
      }
    });
    this.channels = {};
    this.subscriptionQueue = {};
    this.channelCounter = 0;
    console.log("[Realtime] ✅ All channels and queue reset");
  }
}
const realtimeService = new RealtimeService();
if (typeof window !== "undefined") {
  window.realtimeService = realtimeService;
  window.realtimeDebug = () => realtimeService.getDebugInfo();
  window.realtimeReset = () => realtimeService.forceReset();
}
const translations = {
  en,
  es
};
const getCurrentLanguage = () => {
  const savedLanguage = localStorage.getItem("language");
  if (savedLanguage && ["en", "es"].includes(savedLanguage)) {
    return savedLanguage;
  }
  return "en";
};
const translateText = (key2, options) => {
  const language = getCurrentLanguage();
  const locale = translations[language];
  const keys = key2.split(".");
  let value = locale;
  for (const k2 of keys) {
    if (value && typeof value === "object" && k2 in value) {
      value = value[k2];
    } else {
      console.warn(`[i18n] Translation not found: ${key2} for language: ${language}`);
      return key2;
    }
  }
  if (typeof value === "string") {
    return interpolateString(value, options);
  }
  console.warn(`[i18n] Translation not found: ${key2} for language: ${language}`);
  return key2;
};
const interpolateString = (str, options) => {
  if (!options) return str;
  return str.replace(/\{(\w+)\}/g, (match2, key2) => {
    return key2 in options ? String(options[key2]) : match2;
  });
};
class DangerZoneTranslations {
  static getEntryTitle(riskLevel) {
    return translateText(`notifications.dangerZone.entryTitle.level${riskLevel}`);
  }
  static getProximityTitle(riskLevel) {
    return translateText(`notifications.dangerZone.proximityTitle.level${riskLevel}`);
  }
  static getEntryMessage(zoneName) {
    return translateText("notifications.dangerZone.entryMessage", { zoneName });
  }
  static getProximityMessage(zoneName, distance2) {
    return translateText("notifications.dangerZone.proximityMessage", {
      zoneName,
      distance: distance2.toString()
    });
  }
  static getPredictiveTitle() {
    return translateText("notifications.dangerZone.predictiveTitle");
  }
  static getPredictiveMessage(zoneName, riskLevel) {
    return translateText("notifications.dangerZone.predictiveMessage", {
      zoneName,
      riskLevel: riskLevel.toString()
    });
  }
  static getNearByText(zoneName) {
    return translateText("notifications.dangerZone.nearBy", { zoneName });
  }
  static getDirectionToText(zoneName) {
    return translateText("notifications.dangerZone.directionTo", { zoneName });
  }
  static getBasicActions() {
    const actions = [];
    for (let i2 = 0; i2 < 10; i2++) {
      const action = translateText(`dangerZone.actions.basic.${i2}`);
      if (action && action !== `dangerZone.actions.basic.${i2}`) {
        actions.push(action);
      } else {
        break;
      }
    }
    return actions;
  }
  static getHighRiskActions(isInside) {
    const actionType = isInside ? "inside" : "approaching";
    const actions = [];
    for (let i2 = 0; i2 < 10; i2++) {
      const action = translateText(`dangerZone.actions.highRisk.${actionType}.${i2}`);
      if (action && action !== `dangerZone.actions.highRisk.${actionType}.${i2}`) {
        actions.push(action);
      } else {
        break;
      }
    }
    return actions;
  }
  static getModerateActions() {
    const actions = [];
    for (let i2 = 0; i2 < 10; i2++) {
      const action = translateText(`dangerZone.actions.moderate.${i2}`);
      if (action && action !== `dangerZone.actions.moderate.${i2}`) {
        actions.push(action);
      } else {
        break;
      }
    }
    return actions;
  }
  static getPredictiveActions() {
    const actions = [];
    for (let i2 = 0; i2 < 10; i2++) {
      const action = translateText(`dangerZone.actions.predictive.${i2}`);
      if (action && action !== `dangerZone.actions.predictive.${i2}`) {
        actions.push(action);
      } else {
        break;
      }
    }
    return actions;
  }
  static getTimeSpecificActions(timeType) {
    const actions = [];
    for (let i2 = 0; i2 < 10; i2++) {
      const action = translateText(`dangerZone.actions.timeSpecific.${timeType}.${i2}`);
      if (action && action !== `dangerZone.actions.timeSpecific.${timeType}.${i2}`) {
        actions.push(action);
      } else {
        break;
      }
    }
    return actions;
  }
  static getApproachingTitle(riskLevel) {
    return translateText(`notifications.dangerZone.approachingTitle.level${riskLevel}`);
  }
  static getCloserTitle(riskLevel) {
    return translateText(`notifications.dangerZone.closerTitle.level${riskLevel}`);
  }
  static getWarningTitle(riskLevel) {
    return translateText(`notifications.dangerZone.warningTitle.level${riskLevel}`);
  }
  static getCriticalTitle(riskLevel) {
    return translateText(`notifications.dangerZone.criticalTitle.level${riskLevel}`);
  }
  static getApproachingMessage(zoneName, distance2) {
    return translateText("notifications.dangerZone.approachingMessage", { zoneName, distance: distance2 });
  }
  static getCloserMessage(zoneName, distance2) {
    return translateText("notifications.dangerZone.closerMessage", { zoneName, distance: distance2 });
  }
  static getWarningMessage(zoneName, distance2) {
    return translateText("notifications.dangerZone.warningMessage", { zoneName, distance: distance2 });
  }
  static getCriticalMessage(zoneName, distance2) {
    return translateText("notifications.dangerZone.criticalMessage", { zoneName, distance: distance2 });
  }
  // NEW: Unified notification methods with call-to-action
  static getInsideTitle() {
    return translateText("notifications.dangerZone.insideTitle");
  }
  static getInsideMessage() {
    return translateText("notifications.dangerZone.insideMessage");
  }
  static getNearTitle() {
    return translateText("notifications.dangerZone.nearTitle");
  }
  static getNearMessage() {
    return translateText("notifications.dangerZone.nearMessage");
  }
  static getExitTitle() {
    return translateText("notifications.dangerZone.exitTitle");
  }
  static getExitMessage() {
    return translateText("notifications.dangerZone.exitMessage");
  }
  static getCallToAction() {
    return translateText("notifications.dangerZone.callToAction");
  }
}
const translations$1 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  DangerZoneTranslations,
  getCurrentLanguage,
  translateText
}, Symbol.toStringTag, { value: "Module" }));
class UnifiedNotificationService {
  /**
   * Получить унифицированные тексты для уведомлений об инцидентах
   */
  static getIncidentNotification() {
    return {
      title: translateText("notifications.unified.incidentNearby.title"),
      message: translateText("notifications.unified.incidentNearby.message"),
      callToAction: translateText("notifications.unified.incidentNearby.callToAction")
    };
  }
  /**
   * Получить унифицированные тексты для запросов дружбы
   */
  static getFriendRequestNotification() {
    return {
      title: translateText("notifications.unified.friendRequest.title"),
      message: translateText("notifications.unified.friendRequest.message"),
      callToAction: translateText("notifications.unified.friendRequest.callToAction")
    };
  }
  /**
   * Получить унифицированные тексты для принятых запросов дружбы
   */
  static getFriendAcceptedNotification() {
    return {
      title: translateText("notifications.unified.friendAccepted.title"),
      message: translateText("notifications.unified.friendAccepted.message"),
      callToAction: translateText("notifications.unified.friendAccepted.callToAction")
    };
  }
  /**
   * Получить унифицированные тексты для сообщества
   */
  static getCommunityPostNotification() {
    return {
      title: translateText("notifications.unified.communityPost.title"),
      message: translateText("notifications.unified.communityPost.message"),
      callToAction: translateText("notifications.unified.communityPost.callToAction")
    };
  }
  /**
   * Получить унифицированные тексты для комментариев сообщества
   */
  static getCommunityCommentNotification() {
    return {
      title: translateText("notifications.unified.communityComment.title"),
      message: translateText("notifications.unified.communityComment.message"),
      callToAction: translateText("notifications.unified.communityComment.callToAction")
    };
  }
  /**
   * Получить унифицированные тексты для экстренных уведомлений
   */
  static getEmergencyNotification() {
    return {
      title: translateText("notifications.unified.emergency.title"),
      message: translateText("notifications.unified.emergency.message"),
      callToAction: translateText("notifications.unified.emergency.callToAction")
    };
  }
  /**
   * Получить унифицированные тексты для трафика
   */
  static getTrafficNotification() {
    return {
      title: translateText("notifications.unified.traffic.title"),
      message: translateText("notifications.unified.traffic.message"),
      callToAction: translateText("notifications.unified.traffic.callToAction")
    };
  }
  /**
   * Получить унифицированные тексты для админских уведомлений
   */
  static getAdminNotification() {
    return {
      title: translateText("notifications.unified.admin.title"),
      message: translateText("notifications.unified.admin.message"),
      callToAction: translateText("notifications.unified.admin.callToAction")
    };
  }
  /**
   * Получить унифицированные тексты для уведомлений о разыскиваемых
   */
  static getWantedPersonNotification() {
    return {
      title: translateText("notifications.unified.wantedPerson.title"),
      message: translateText("notifications.unified.wantedPerson.message"),
      callToAction: translateText("notifications.unified.wantedPerson.callToAction")
    };
  }
  /**
   * Получить унифицированные тексты для системных уведомлений
   */
  static getSystemNotification() {
    return {
      title: translateText("notifications.unified.system.title"),
      message: translateText("notifications.unified.system.message"),
      callToAction: translateText("notifications.unified.system.callToAction")
    };
  }
  /**
   * Получить приоритет уведомления по типу
   */
  static getPriorityByType(type) {
    switch (type) {
      case "emergency":
      case "wantedPerson":
        return "urgent";
      case "incident":
      case "admin":
        return "high";
      case "friendRequest":
      case "traffic":
        return "medium";
      case "community":
      case "system":
      default:
        return "low";
    }
  }
  /**
   * Получить иконку для типа уведомления
   */
  static getIconByType(type) {
    switch (type) {
      case "incident":
        return "🚨";
      case "friendRequest":
        return "👥";
      case "community":
        return "💬";
      case "emergency":
        return "🚨";
      case "traffic":
        return "🚗";
      case "admin":
        return "⚙️";
      case "wantedPerson":
        return "🔍";
      case "system":
        return "ℹ️";
      default:
        return "🔔";
    }
  }
}
const SmartNotifications = ({
  userLocation,
  alertRadius,
  onNotificationsGenerated,
  showNearbyOnly = false
}) => {
  useLanguage$1();
  const { user } = useAuth();
  const notifChannelRef = reactExports.useRef(null);
  reactExports.useEffect(() => {
    console.log("=== SmartNotifications: Starting ===");
    if (!userLocation || !user) {
      console.log("SmartNotifications: No user location or user - skipping");
      onNotificationsGenerated([]);
      return;
    }
    const loadNotifications = async () => {
      try {
        console.log("SmartNotifications: Loading incidents from database...");
        const { data: incidents2, error } = await supabase.from("incidents").select("*").order("created_at", { ascending: false });
        if (error) {
          console.error("SmartNotifications: Database error:", error);
          onNotificationsGenerated([]);
          return;
        }
        console.log("SmartNotifications: Found incidents:", incidents2?.length || 0);
        if (!incidents2 || incidents2.length === 0) {
          console.log("SmartNotifications: No incidents found");
          onNotificationsGenerated([]);
          return;
        }
        const notifications = [];
        incidents2.forEach((incident) => {
          const incidentForTimeCheck = {
            id: incident.id,
            coordinates: {
              latitude: Number(incident.latitude),
              longitude: Number(incident.longitude)
            },
            type: incident.incident_type,
            description: incident.description,
            timestamp: new Date(incident.created_at),
            created_at: incident.created_at
          };
          const activeIncidents = filterActiveIncidents([incidentForTimeCheck]);
          if (activeIncidents.length === 0) {
            console.log(`SmartNotifications: Incident ${incident.id} expired - skipping`);
            return;
          }
          const distance2 = calculateDistance(
            userLocation.lat,
            userLocation.lng,
            Number(incident.latitude),
            Number(incident.longitude)
          );
          const shouldInclude = !showNearbyOnly || distance2 <= alertRadius;
          if (shouldInclude) {
            const unifiedTexts = UnifiedNotificationService.getIncidentNotification();
            const notification = {
              id: `incident_${incident.id}`,
              type: "incident_nearby",
              title: unifiedTexts.title,
              message: unifiedTexts.message,
              priority: UnifiedNotificationService.getPriorityByType("incident"),
              location: {
                lat: Number(incident.latitude),
                lng: Number(incident.longitude),
                address: incident.address || "Ubicación"
              },
              timestamp: new Date(incident.created_at),
              actionRequired: false,
              suggestedActions: [unifiedTexts.callToAction],
              aiConfidence: 0.95
            };
            notifications.push(notification);
            console.log(`SmartNotifications: Created notification for incident ${incident.id}`);
          }
        });
        console.log("SmartNotifications: Generated notifications:", notifications.length);
        console.log("SmartNotifications: Calling onNotificationsGenerated...");
        onNotificationsGenerated(notifications);
      } catch (error) {
        console.error("SmartNotifications: Error:", error);
        onNotificationsGenerated([]);
      }
    };
    loadNotifications();
    if (!notifChannelRef.current) {
      notifChannelRef.current = realtimeService.getChannel(`incidents_notifications_${user?.id ?? "anon"}`).on(
        "postgres_changes",
        {
          event: "*",
          // Слушаем все изменения (INSERT, UPDATE, DELETE)
          schema: "public",
          table: "incidents"
        },
        (payload) => {
          console.log("SmartNotifications: Database change detected:", payload);
          loadNotifications();
        }
      ).subscribe();
    }
    const interval = setInterval(loadNotifications, 6e4);
    return () => {
      realtimeService.dropChannel(`incidents_notifications_${user?.id ?? "anon"}`);
      notifChannelRef.current = null;
      clearInterval(interval);
    };
  }, [userLocation, alertRadius, user?.id, showNearbyOnly]);
  const calculateDistance = (lat1, lng1, lat2, lng2) => {
    const R2 = 6371e3;
    const φ1 = lat1 * Math.PI / 180;
    const φ2 = lat2 * Math.PI / 180;
    const Δφ = (lat2 - lat1) * Math.PI / 180;
    const Δλ = (lng2 - lng1) * Math.PI / 180;
    const a2 = Math.sin(Δφ / 2) * Math.sin(Δφ / 2) + Math.cos(φ1) * Math.cos(φ2) * Math.sin(Δλ / 2) * Math.sin(Δλ / 2);
    const c2 = 2 * Math.atan2(Math.sqrt(a2), Math.sqrt(1 - a2));
    return R2 * c2;
  };
  return null;
};
const EnhancedNotifications = ({
  notifications,
  onDismiss,
  onNotificationClick
}) => {
  useLanguage$1();
  console.log("EnhancedNotifications: Received notifications:", notifications.length, notifications);
  if (notifications.length === 0) {
    console.log("EnhancedNotifications: No notifications to display");
    return null;
  }
  const getPriorityColor = (priority) => {
    switch (priority) {
      case "urgent":
        return "bg-gradient-to-br from-red-600 to-red-800 border-red-400 shadow-red-500/40";
      case "high":
        return "bg-gradient-to-br from-orange-600 to-orange-800 border-orange-400 shadow-orange-500/40";
      case "medium":
        return "bg-gradient-to-br from-yellow-600 to-yellow-800 border-yellow-400 shadow-yellow-500/40";
      case "low":
        return "bg-gradient-to-br from-blue-600 to-blue-800 border-blue-400 shadow-blue-500/40";
      case "success":
        return "bg-gradient-to-br from-green-600 to-green-800 border-green-400 shadow-green-500/40";
      default:
        return "bg-gradient-to-br from-gray-600 to-gray-800 border-gray-400 shadow-gray-500/40";
    }
  };
  const getPriorityIcon = (priority) => {
    switch (priority) {
      case "urgent":
      case "high":
        return /* @__PURE__ */ jsxRuntimeExports.jsx(TriangleAlert, { className: "w-4 h-4" });
      case "medium":
        return /* @__PURE__ */ jsxRuntimeExports.jsx(Shield, { className: "w-4 h-4" });
      case "low":
        return /* @__PURE__ */ jsxRuntimeExports.jsx(Clock$1, { className: "w-4 h-4" });
      case "success":
        return /* @__PURE__ */ jsxRuntimeExports.jsx(CircleCheckBig, { className: "w-4 h-4" });
      default:
        return /* @__PURE__ */ jsxRuntimeExports.jsx(TriangleAlert, { className: "w-4 h-4" });
    }
  };
  const getTypeLabel = (type) => {
    switch (type) {
      case "zone_entry":
        return "Alerta de Zona";
      case "incident_nearby":
        return "Alerta de Seguridad";
      case "friend_request":
        return "Solicitud de Amistad";
      case "community":
        return "Actualización de Comunidad";
      case "emergency":
        return "Alerta de Emergencia";
      case "traffic_alert":
        return "Actualización de Tráfico";
      case "time_risk":
        return "Alerta de Seguridad";
      case "weather_risk":
        return "Alerta de Seguridad";
      case "crowd_density":
        return "Alerta de Seguridad";
      case "ai_prediction":
        return "Alerta de Seguridad";
      default:
        return "Alerta de RADAR";
    }
  };
  const formatTime = (timestamp) => {
    return formatTimeAMPM(timestamp);
  };
  return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "px-6 py-4 space-y-3 bg-[#23272b] border-2 border-[#2d3237] backdrop-blur-md rounded-lg shadow-2xl", children: [
    /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "flex items-center justify-between mb-3", children: /* @__PURE__ */ jsxRuntimeExports.jsxs("h3", { className: "text-sm font-semibold text-white flex items-center", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx(TriangleAlert, { className: "w-5 h-5 text-orange-400 animate-pulse mr-3 drop-shadow-[0_0_8px_rgba(255,115,0,0.8)]", style: { filter: "drop-shadow(0 0 8px #ff6600)" } }),
      "Alertas de Seguridad (",
      notifications.length,
      ")"
    ] }) }),
    /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "space-y-2 max-h-64 overflow-y-auto", children: [
      notifications.slice(0, 3).map((notification) => /* @__PURE__ */ jsxRuntimeExports.jsx(
        Card,
        {
          className: `${getPriorityColor(notification.priority)} backdrop-blur-md border-2 shadow-2xl animate-fade-in cursor-pointer hover:scale-[1.02] hover:shadow-3xl transform transition-all duration-300 hover:-translate-y-1`,
          onClick: () => onNotificationClick?.(notification.location.lat, notification.location.lng),
          children: /* @__PURE__ */ jsxRuntimeExports.jsxs(CardContent, { className: "p-3", children: [
            /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex items-start justify-between", children: [
              /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex-1 min-w-0", children: [
                /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex items-center space-x-2 mb-1", children: [
                  /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "p-2 rounded-full bg-white/20 backdrop-blur-sm text-white shadow-lg", children: getPriorityIcon(notification.priority) }),
                  /* @__PURE__ */ jsxRuntimeExports.jsx(
                    Badge,
                    {
                      variant: "outline",
                      className: "text-xs border-white/20 text-white/80 bg-white/5",
                      children: getTypeLabel(notification.type)
                    }
                  ),
                  /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "text-xs text-white/60", children: formatTime(notification.timestamp) })
                ] }),
                /* @__PURE__ */ jsxRuntimeExports.jsx("h4", { className: "font-semibold text-white/90 text-sm mb-1 line-clamp-1", children: notification.title }),
                /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: "text-white/70 text-xs mb-2 line-clamp-2", children: notification.message }),
                /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex items-center text-xs text-white/60", children: [
                  /* @__PURE__ */ jsxRuntimeExports.jsx(MapPin, { className: "w-3 h-3 mr-1" }),
                  /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "truncate", children: notification.location.address })
                ] }),
                notification.aiConfidence && /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "mt-1", children: /* @__PURE__ */ jsxRuntimeExports.jsxs("span", { className: "text-xs text-blue-300/80", children: [
                  "Confianza IA: ",
                  Math.round(notification.aiConfidence * 100),
                  "%"
                ] }) })
              ] }),
              /* @__PURE__ */ jsxRuntimeExports.jsx(
                Button$1,
                {
                  variant: "ghost",
                  size: "icon",
                  onClick: (e2) => {
                    e2.stopPropagation();
                    onDismiss(notification.id);
                  },
                  className: "h-6 w-6 text-white/60 hover:text-white/90 hover:bg-white/10 ml-2 flex-shrink-0",
                  children: /* @__PURE__ */ jsxRuntimeExports.jsx(X, { className: "w-4 h-4" })
                }
              )
            ] }),
            notification.suggestedActions && notification.suggestedActions.length > 0 && /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "mt-2 pt-2 border-t border-white/10", children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: "text-xs text-white/60 mb-1", children: "Acciones recomendadas:" }),
              /* @__PURE__ */ jsxRuntimeExports.jsx("ul", { className: "text-xs text-white/70 space-y-0.5", children: notification.suggestedActions.slice(0, 2).map((action, index2) => /* @__PURE__ */ jsxRuntimeExports.jsxs("li", { className: "flex items-start", children: [
                /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "text-red-400 mr-1", children: "•" }),
                /* @__PURE__ */ jsxRuntimeExports.jsx("span", { children: action })
              ] }, index2)) })
            ] })
          ] })
        },
        notification.id
      )),
      notifications.length > 3 && /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "text-center py-2", children: /* @__PURE__ */ jsxRuntimeExports.jsxs("span", { className: "text-xs text-white/50", children: [
        "+",
        notifications.length - 3,
        " alertas más"
      ] }) })
    ] })
  ] });
};
var mapboxGl = { exports: {} };
(function(module, exports) {
  (function(global, factory) {
    module.exports = factory();
  })(commonjsGlobal, function() {
    var shared, worker, mapboxgl2;
    function define2(_2, chunk) {
      if (!shared) {
        shared = chunk;
      } else if (!worker) {
        worker = chunk;
      } else {
        var workerBundleString = "self.onerror = function() { console.error('An error occurred while parsing the WebWorker bundle. This is most likely due to improper transpilation by Babel; please see https://docs.mapbox.com/mapbox-gl-js/guides/install/#transpiling'); }; var sharedChunk = {}; (" + shared + ")(sharedChunk); (" + worker + ")(sharedChunk); self.onerror = null;";
        var sharedChunk = {};
        shared(sharedChunk);
        mapboxgl2 = chunk(sharedChunk);
        if (typeof window !== "undefined" && window && window.URL && window.URL.createObjectURL) {
          mapboxgl2.workerUrl = window.URL.createObjectURL(new Blob([workerBundleString], { type: "text/javascript" }));
        }
      }
    }
    define2(["exports"], function(t2) {
      var e2 = 1e-6, r2 = "undefined" != typeof Float32Array ? Float32Array : Array;
      function n2(t22, e22) {
        var r22 = e22[0], n22 = e22[1], i22 = e22[2], s2 = e22[3], o2 = r22 * s2 - i22 * n22;
        return o2 ? (t22[0] = s2 * (o2 = 1 / o2), t22[1] = -n22 * o2, t22[2] = -i22 * o2, t22[3] = r22 * o2, t22) : null;
      }
      function i2() {
        var t22 = new r2(9);
        return r2 != Float32Array && (t22[1] = 0, t22[2] = 0, t22[3] = 0, t22[5] = 0, t22[6] = 0, t22[7] = 0), t22[0] = 1, t22[4] = 1, t22[8] = 1, t22;
      }
      function s(t22, e22) {
        var r22 = e22[0], n22 = e22[1], i22 = e22[2], s2 = e22[3], o2 = e22[4], a22 = e22[5], l22 = e22[6], u22 = e22[7], c22 = e22[8];
        return t22[0] = o2 * c22 - a22 * u22, t22[1] = i22 * u22 - n22 * c22, t22[2] = n22 * a22 - i22 * o2, t22[3] = a22 * l22 - s2 * c22, t22[4] = r22 * c22 - i22 * l22, t22[5] = i22 * s2 - r22 * a22, t22[6] = s2 * u22 - o2 * l22, t22[7] = n22 * l22 - r22 * u22, t22[8] = r22 * o2 - n22 * s2, t22;
      }
      function o(t22, e22, r22) {
        var n22 = e22[0], i22 = e22[1], s2 = e22[2], o2 = e22[3], a22 = e22[4], l22 = e22[5], u22 = e22[6], c22 = e22[7], h22 = e22[8], p22 = r22[0], f22 = r22[1], d22 = r22[2], m22 = r22[3], y22 = r22[4], g22 = r22[5], x22 = r22[6], v22 = r22[7], b22 = r22[8];
        return t22[0] = p22 * n22 + f22 * o2 + d22 * u22, t22[1] = p22 * i22 + f22 * a22 + d22 * c22, t22[2] = p22 * s2 + f22 * l22 + d22 * h22, t22[3] = m22 * n22 + y22 * o2 + g22 * u22, t22[4] = m22 * i22 + y22 * a22 + g22 * c22, t22[5] = m22 * s2 + y22 * l22 + g22 * h22, t22[6] = x22 * n22 + v22 * o2 + b22 * u22, t22[7] = x22 * i22 + v22 * a22 + b22 * c22, t22[8] = x22 * s2 + v22 * l22 + b22 * h22, t22;
      }
      function a2() {
        var t22 = new r2(16);
        return r2 != Float32Array && (t22[1] = 0, t22[2] = 0, t22[3] = 0, t22[4] = 0, t22[6] = 0, t22[7] = 0, t22[8] = 0, t22[9] = 0, t22[11] = 0, t22[12] = 0, t22[13] = 0, t22[14] = 0), t22[0] = 1, t22[5] = 1, t22[10] = 1, t22[15] = 1, t22;
      }
      function l2(t22) {
        return t22[0] = 1, t22[1] = 0, t22[2] = 0, t22[3] = 0, t22[4] = 0, t22[5] = 1, t22[6] = 0, t22[7] = 0, t22[8] = 0, t22[9] = 0, t22[10] = 1, t22[11] = 0, t22[12] = 0, t22[13] = 0, t22[14] = 0, t22[15] = 1, t22;
      }
      function u2(t22, e22) {
        var r22 = e22[0], n22 = e22[1], i22 = e22[2], s2 = e22[3], o2 = e22[4], a22 = e22[5], l22 = e22[6], u22 = e22[7], c22 = e22[8], h22 = e22[9], p22 = e22[10], f22 = e22[11], d22 = e22[12], m22 = e22[13], y22 = e22[14], g22 = e22[15], x22 = r22 * a22 - n22 * o2, v22 = r22 * l22 - i22 * o2, b22 = r22 * u22 - s2 * o2, _22 = n22 * l22 - i22 * a22, w22 = n22 * u22 - s2 * a22, A22 = i22 * u22 - s2 * l22, M22 = c22 * m22 - h22 * d22, I2 = c22 * y22 - p22 * d22, S2 = c22 * g22 - f22 * d22, z22 = h22 * y22 - p22 * m22, k22 = h22 * g22 - f22 * m22, E22 = p22 * g22 - f22 * y22, P22 = x22 * E22 - v22 * k22 + b22 * z22 + _22 * S2 - w22 * I2 + A22 * M22;
        return P22 ? (t22[0] = (a22 * E22 - l22 * k22 + u22 * z22) * (P22 = 1 / P22), t22[1] = (i22 * k22 - n22 * E22 - s2 * z22) * P22, t22[2] = (m22 * A22 - y22 * w22 + g22 * _22) * P22, t22[3] = (p22 * w22 - h22 * A22 - f22 * _22) * P22, t22[4] = (l22 * S2 - o2 * E22 - u22 * I2) * P22, t22[5] = (r22 * E22 - i22 * S2 + s2 * I2) * P22, t22[6] = (y22 * b22 - d22 * A22 - g22 * v22) * P22, t22[7] = (c22 * A22 - p22 * b22 + f22 * v22) * P22, t22[8] = (o2 * k22 - a22 * S2 + u22 * M22) * P22, t22[9] = (n22 * S2 - r22 * k22 - s2 * M22) * P22, t22[10] = (d22 * w22 - m22 * b22 + g22 * x22) * P22, t22[11] = (h22 * b22 - c22 * w22 - f22 * x22) * P22, t22[12] = (a22 * I2 - o2 * z22 - l22 * M22) * P22, t22[13] = (r22 * z22 - n22 * I2 + i22 * M22) * P22, t22[14] = (m22 * v22 - d22 * _22 - y22 * x22) * P22, t22[15] = (c22 * _22 - h22 * v22 + p22 * x22) * P22, t22) : null;
      }
      function c2(t22, e22, r22) {
        var n22 = e22[0], i22 = e22[1], s2 = e22[2], o2 = e22[3], a22 = e22[4], l22 = e22[5], u22 = e22[6], c22 = e22[7], h22 = e22[8], p22 = e22[9], f22 = e22[10], d22 = e22[11], m22 = e22[12], y22 = e22[13], g22 = e22[14], x22 = e22[15], v22 = r22[0], b22 = r22[1], _22 = r22[2], w22 = r22[3];
        return t22[0] = v22 * n22 + b22 * a22 + _22 * h22 + w22 * m22, t22[1] = v22 * i22 + b22 * l22 + _22 * p22 + w22 * y22, t22[2] = v22 * s2 + b22 * u22 + _22 * f22 + w22 * g22, t22[3] = v22 * o2 + b22 * c22 + _22 * d22 + w22 * x22, t22[4] = (v22 = r22[4]) * n22 + (b22 = r22[5]) * a22 + (_22 = r22[6]) * h22 + (w22 = r22[7]) * m22, t22[5] = v22 * i22 + b22 * l22 + _22 * p22 + w22 * y22, t22[6] = v22 * s2 + b22 * u22 + _22 * f22 + w22 * g22, t22[7] = v22 * o2 + b22 * c22 + _22 * d22 + w22 * x22, t22[8] = (v22 = r22[8]) * n22 + (b22 = r22[9]) * a22 + (_22 = r22[10]) * h22 + (w22 = r22[11]) * m22, t22[9] = v22 * i22 + b22 * l22 + _22 * p22 + w22 * y22, t22[10] = v22 * s2 + b22 * u22 + _22 * f22 + w22 * g22, t22[11] = v22 * o2 + b22 * c22 + _22 * d22 + w22 * x22, t22[12] = (v22 = r22[12]) * n22 + (b22 = r22[13]) * a22 + (_22 = r22[14]) * h22 + (w22 = r22[15]) * m22, t22[13] = v22 * i22 + b22 * l22 + _22 * p22 + w22 * y22, t22[14] = v22 * s2 + b22 * u22 + _22 * f22 + w22 * g22, t22[15] = v22 * o2 + b22 * c22 + _22 * d22 + w22 * x22, t22;
      }
      function h2(t22, e22, r22) {
        var n22, i22, s2, o2, a22, l22, u22, c22, h22, p22, f22, d22, m22 = r22[0], y22 = r22[1], g22 = r22[2];
        return e22 === t22 ? (t22[12] = e22[0] * m22 + e22[4] * y22 + e22[8] * g22 + e22[12], t22[13] = e22[1] * m22 + e22[5] * y22 + e22[9] * g22 + e22[13], t22[14] = e22[2] * m22 + e22[6] * y22 + e22[10] * g22 + e22[14], t22[15] = e22[3] * m22 + e22[7] * y22 + e22[11] * g22 + e22[15]) : (i22 = e22[1], s2 = e22[2], o2 = e22[3], a22 = e22[4], l22 = e22[5], u22 = e22[6], c22 = e22[7], h22 = e22[8], p22 = e22[9], f22 = e22[10], d22 = e22[11], t22[0] = n22 = e22[0], t22[1] = i22, t22[2] = s2, t22[3] = o2, t22[4] = a22, t22[5] = l22, t22[6] = u22, t22[7] = c22, t22[8] = h22, t22[9] = p22, t22[10] = f22, t22[11] = d22, t22[12] = n22 * m22 + a22 * y22 + h22 * g22 + e22[12], t22[13] = i22 * m22 + l22 * y22 + p22 * g22 + e22[13], t22[14] = s2 * m22 + u22 * y22 + f22 * g22 + e22[14], t22[15] = o2 * m22 + c22 * y22 + d22 * g22 + e22[15]), t22;
      }
      function p2(t22, e22, r22) {
        var n22 = r22[0], i22 = r22[1], s2 = r22[2];
        return t22[0] = e22[0] * n22, t22[1] = e22[1] * n22, t22[2] = e22[2] * n22, t22[3] = e22[3] * n22, t22[4] = e22[4] * i22, t22[5] = e22[5] * i22, t22[6] = e22[6] * i22, t22[7] = e22[7] * i22, t22[8] = e22[8] * s2, t22[9] = e22[9] * s2, t22[10] = e22[10] * s2, t22[11] = e22[11] * s2, t22[12] = e22[12], t22[13] = e22[13], t22[14] = e22[14], t22[15] = e22[15], t22;
      }
      function f2(t22, e22, r22) {
        var n22 = Math.sin(r22), i22 = Math.cos(r22), s2 = e22[4], o2 = e22[5], a22 = e22[6], l22 = e22[7], u22 = e22[8], c22 = e22[9], h22 = e22[10], p22 = e22[11];
        return e22 !== t22 && (t22[0] = e22[0], t22[1] = e22[1], t22[2] = e22[2], t22[3] = e22[3], t22[12] = e22[12], t22[13] = e22[13], t22[14] = e22[14], t22[15] = e22[15]), t22[4] = s2 * i22 + u22 * n22, t22[5] = o2 * i22 + c22 * n22, t22[6] = a22 * i22 + h22 * n22, t22[7] = l22 * i22 + p22 * n22, t22[8] = u22 * i22 - s2 * n22, t22[9] = c22 * i22 - o2 * n22, t22[10] = h22 * i22 - a22 * n22, t22[11] = p22 * i22 - l22 * n22, t22;
      }
      function d2(t22, e22, r22) {
        var n22 = Math.sin(r22), i22 = Math.cos(r22), s2 = e22[0], o2 = e22[1], a22 = e22[2], l22 = e22[3], u22 = e22[8], c22 = e22[9], h22 = e22[10], p22 = e22[11];
        return e22 !== t22 && (t22[4] = e22[4], t22[5] = e22[5], t22[6] = e22[6], t22[7] = e22[7], t22[12] = e22[12], t22[13] = e22[13], t22[14] = e22[14], t22[15] = e22[15]), t22[0] = s2 * i22 - u22 * n22, t22[1] = o2 * i22 - c22 * n22, t22[2] = a22 * i22 - h22 * n22, t22[3] = l22 * i22 - p22 * n22, t22[8] = s2 * n22 + u22 * i22, t22[9] = o2 * n22 + c22 * i22, t22[10] = a22 * n22 + h22 * i22, t22[11] = l22 * n22 + p22 * i22, t22;
      }
      function m2(t22, e22, r22) {
        var n22 = Math.sin(r22), i22 = Math.cos(r22), s2 = e22[0], o2 = e22[1], a22 = e22[2], l22 = e22[3], u22 = e22[4], c22 = e22[5], h22 = e22[6], p22 = e22[7];
        return e22 !== t22 && (t22[8] = e22[8], t22[9] = e22[9], t22[10] = e22[10], t22[11] = e22[11], t22[12] = e22[12], t22[13] = e22[13], t22[14] = e22[14], t22[15] = e22[15]), t22[0] = s2 * i22 + u22 * n22, t22[1] = o2 * i22 + c22 * n22, t22[2] = a22 * i22 + h22 * n22, t22[3] = l22 * i22 + p22 * n22, t22[4] = u22 * i22 - s2 * n22, t22[5] = c22 * i22 - o2 * n22, t22[6] = h22 * i22 - a22 * n22, t22[7] = p22 * i22 - l22 * n22, t22;
      }
      function y2(t22, e22) {
        return t22[0] = e22[0], t22[1] = 0, t22[2] = 0, t22[3] = 0, t22[4] = 0, t22[5] = e22[1], t22[6] = 0, t22[7] = 0, t22[8] = 0, t22[9] = 0, t22[10] = e22[2], t22[11] = 0, t22[12] = 0, t22[13] = 0, t22[14] = 0, t22[15] = 1, t22;
      }
      function g2(t22, r22, n22) {
        var i22, s2, o2, a22 = n22[0], l22 = n22[1], u22 = n22[2], c22 = Math.hypot(a22, l22, u22);
        return c22 < e2 ? null : (a22 *= c22 = 1 / c22, l22 *= c22, u22 *= c22, i22 = Math.sin(r22), s2 = Math.cos(r22), t22[0] = a22 * a22 * (o2 = 1 - s2) + s2, t22[1] = l22 * a22 * o2 + u22 * i22, t22[2] = u22 * a22 * o2 - l22 * i22, t22[3] = 0, t22[4] = a22 * l22 * o2 - u22 * i22, t22[5] = l22 * l22 * o2 + s2, t22[6] = u22 * l22 * o2 + a22 * i22, t22[7] = 0, t22[8] = a22 * u22 * o2 + l22 * i22, t22[9] = l22 * u22 * o2 - a22 * i22, t22[10] = u22 * u22 * o2 + s2, t22[11] = 0, t22[12] = 0, t22[13] = 0, t22[14] = 0, t22[15] = 1, t22);
      }
      function x2(t22, e22) {
        var r22 = e22[0], n22 = e22[1], i22 = e22[2], s2 = e22[3], o2 = r22 + r22, a22 = n22 + n22, l22 = i22 + i22, u22 = r22 * o2, c22 = n22 * o2, h22 = n22 * a22, p22 = i22 * o2, f22 = i22 * a22, d22 = i22 * l22, m22 = s2 * o2, y22 = s2 * a22, g22 = s2 * l22;
        return t22[0] = 1 - h22 - d22, t22[1] = c22 + g22, t22[2] = p22 - y22, t22[3] = 0, t22[4] = c22 - g22, t22[5] = 1 - u22 - d22, t22[6] = f22 + m22, t22[7] = 0, t22[8] = p22 + y22, t22[9] = f22 - m22, t22[10] = 1 - u22 - h22, t22[11] = 0, t22[12] = 0, t22[13] = 0, t22[14] = 0, t22[15] = 1, t22;
      }
      Math.hypot || (Math.hypot = function() {
        for (var t22 = 0, e22 = arguments.length; e22--; ) t22 += arguments[e22] * arguments[e22];
        return Math.sqrt(t22);
      });
      var v2 = c2;
      function b2() {
        var t22 = new r2(3);
        return r2 != Float32Array && (t22[0] = 0, t22[1] = 0, t22[2] = 0), t22;
      }
      function _2(t22) {
        var e22 = new r2(3);
        return e22[0] = t22[0], e22[1] = t22[1], e22[2] = t22[2], e22;
      }
      function w2(t22) {
        return Math.hypot(t22[0], t22[1], t22[2]);
      }
      function A2(t22, e22, n22) {
        var i22 = new r2(3);
        return i22[0] = t22, i22[1] = e22, i22[2] = n22, i22;
      }
      function M2(t22, e22, r22) {
        return t22[0] = e22[0] + r22[0], t22[1] = e22[1] + r22[1], t22[2] = e22[2] + r22[2], t22;
      }
      function I(t22, e22, r22) {
        return t22[0] = e22[0] - r22[0], t22[1] = e22[1] - r22[1], t22[2] = e22[2] - r22[2], t22;
      }
      function S(t22, e22, r22) {
        return t22[0] = e22[0] * r22[0], t22[1] = e22[1] * r22[1], t22[2] = e22[2] * r22[2], t22;
      }
      function z2(t22, e22, r22) {
        return t22[0] = Math.min(e22[0], r22[0]), t22[1] = Math.min(e22[1], r22[1]), t22[2] = Math.min(e22[2], r22[2]), t22;
      }
      function k2(t22, e22, r22) {
        return t22[0] = Math.max(e22[0], r22[0]), t22[1] = Math.max(e22[1], r22[1]), t22[2] = Math.max(e22[2], r22[2]), t22;
      }
      function E2(t22, e22, r22) {
        return t22[0] = e22[0] * r22, t22[1] = e22[1] * r22, t22[2] = e22[2] * r22, t22;
      }
      function P2(t22, e22, r22, n22) {
        return t22[0] = e22[0] + r22[0] * n22, t22[1] = e22[1] + r22[1] * n22, t22[2] = e22[2] + r22[2] * n22, t22;
      }
      function T(t22, e22) {
        var r22 = e22[0] - t22[0], n22 = e22[1] - t22[1], i22 = e22[2] - t22[2];
        return r22 * r22 + n22 * n22 + i22 * i22;
      }
      function B2(t22) {
        var e22 = t22[0], r22 = t22[1], n22 = t22[2];
        return e22 * e22 + r22 * r22 + n22 * n22;
      }
      function V(t22, e22) {
        return t22[0] = -e22[0], t22[1] = -e22[1], t22[2] = -e22[2], t22;
      }
      function C(t22, e22) {
        var r22 = e22[0], n22 = e22[1], i22 = e22[2], s2 = r22 * r22 + n22 * n22 + i22 * i22;
        return s2 > 0 && (s2 = 1 / Math.sqrt(s2)), t22[0] = e22[0] * s2, t22[1] = e22[1] * s2, t22[2] = e22[2] * s2, t22;
      }
      function D2(t22, e22) {
        return t22[0] * e22[0] + t22[1] * e22[1] + t22[2] * e22[2];
      }
      function F(t22, e22, r22) {
        var n22 = e22[0], i22 = e22[1], s2 = e22[2], o2 = r22[0], a22 = r22[1], l22 = r22[2];
        return t22[0] = i22 * l22 - s2 * a22, t22[1] = s2 * o2 - n22 * l22, t22[2] = n22 * a22 - i22 * o2, t22;
      }
      function L2(t22, e22, r22, n22) {
        var i22 = e22[0], s2 = e22[1], o2 = e22[2];
        return t22[0] = i22 + n22 * (r22[0] - i22), t22[1] = s2 + n22 * (r22[1] - s2), t22[2] = o2 + n22 * (r22[2] - o2), t22;
      }
      function R2(t22, e22, r22) {
        var n22 = e22[0], i22 = e22[1], s2 = e22[2], o2 = r22[3] * n22 + r22[7] * i22 + r22[11] * s2 + r22[15];
        return t22[0] = (r22[0] * n22 + r22[4] * i22 + r22[8] * s2 + r22[12]) / (o2 = o2 || 1), t22[1] = (r22[1] * n22 + r22[5] * i22 + r22[9] * s2 + r22[13]) / o2, t22[2] = (r22[2] * n22 + r22[6] * i22 + r22[10] * s2 + r22[14]) / o2, t22;
      }
      function O(t22, e22, r22) {
        var n22 = e22[0], i22 = e22[1], s2 = e22[2];
        return t22[0] = n22 * r22[0] + i22 * r22[3] + s2 * r22[6], t22[1] = n22 * r22[1] + i22 * r22[4] + s2 * r22[7], t22[2] = n22 * r22[2] + i22 * r22[5] + s2 * r22[8], t22;
      }
      function U2(t22, e22, r22) {
        var n22 = r22[0], i22 = r22[1], s2 = r22[2], o2 = e22[0], a22 = e22[1], l22 = e22[2], u22 = i22 * l22 - s2 * a22, c22 = s2 * o2 - n22 * l22, h22 = n22 * a22 - i22 * o2, p22 = i22 * h22 - s2 * c22, f22 = s2 * u22 - n22 * h22, d22 = n22 * c22 - i22 * u22, m22 = 2 * r22[3];
        return c22 *= m22, h22 *= m22, f22 *= 2, d22 *= 2, t22[0] = o2 + (u22 *= m22) + (p22 *= 2), t22[1] = a22 + c22 + f22, t22[2] = l22 + h22 + d22, t22;
      }
      function N2(t22, e22) {
        return t22[0] === e22[0] && t22[1] === e22[1] && t22[2] === e22[2];
      }
      var j2 = I, $ = S, G = w2;
      function q2() {
        var t22 = new r2(4);
        return r2 != Float32Array && (t22[0] = 0, t22[1] = 0, t22[2] = 0, t22[3] = 0), t22;
      }
      function H(t22, e22, r22) {
        return t22[0] = e22[0] * r22, t22[1] = e22[1] * r22, t22[2] = e22[2] * r22, t22[3] = e22[3] * r22, t22;
      }
      function X2(t22, e22) {
        var r22 = e22[0], n22 = e22[1], i22 = e22[2], s2 = e22[3], o2 = r22 * r22 + n22 * n22 + i22 * i22 + s2 * s2;
        return o2 > 0 && (o2 = 1 / Math.sqrt(o2)), t22[0] = r22 * o2, t22[1] = n22 * o2, t22[2] = i22 * o2, t22[3] = s2 * o2, t22;
      }
      function Z(t22, e22, r22) {
        var n22 = e22[0], i22 = e22[1], s2 = e22[2], o2 = e22[3];
        return t22[0] = r22[0] * n22 + r22[4] * i22 + r22[8] * s2 + r22[12] * o2, t22[1] = r22[1] * n22 + r22[5] * i22 + r22[9] * s2 + r22[13] * o2, t22[2] = r22[2] * n22 + r22[6] * i22 + r22[10] * s2 + r22[14] * o2, t22[3] = r22[3] * n22 + r22[7] * i22 + r22[11] * s2 + r22[15] * o2, t22;
      }
      function W() {
        var t22 = new r2(4);
        return r2 != Float32Array && (t22[0] = 0, t22[1] = 0, t22[2] = 0), t22[3] = 1, t22;
      }
      function Y(t22) {
        return t22[0] = 0, t22[1] = 0, t22[2] = 0, t22[3] = 1, t22;
      }
      function K2(t22, e22, r22) {
        r22 *= 0.5;
        var n22 = e22[0], i22 = e22[1], s2 = e22[2], o2 = e22[3], a22 = Math.sin(r22), l22 = Math.cos(r22);
        return t22[0] = n22 * l22 + o2 * a22, t22[1] = i22 * l22 + s2 * a22, t22[2] = s2 * l22 - i22 * a22, t22[3] = o2 * l22 - n22 * a22, t22;
      }
      function J(t22, e22, r22) {
        r22 *= 0.5;
        var n22 = e22[0], i22 = e22[1], s2 = e22[2], o2 = e22[3], a22 = Math.sin(r22), l22 = Math.cos(r22);
        return t22[0] = n22 * l22 - s2 * a22, t22[1] = i22 * l22 + o2 * a22, t22[2] = s2 * l22 + n22 * a22, t22[3] = o2 * l22 - i22 * a22, t22;
      }
      b2(), q2();
      var Q, tt, et, rt, nt, it = X2, st = (Q = b2(), tt = A2(1, 0, 0), et = A2(0, 1, 0), function(t22, e22, r22) {
        var n22 = D2(e22, r22);
        return n22 < -0.999999 ? (F(Q, tt, e22), G(Q) < 1e-6 && F(Q, et, e22), C(Q, Q), function(t3, e3, r3) {
          r3 *= 0.5;
          var n3 = Math.sin(r3);
          t3[0] = n3 * e3[0], t3[1] = n3 * e3[1], t3[2] = n3 * e3[2], t3[3] = Math.cos(r3);
        }(t22, Q, Math.PI), t22) : n22 > 0.999999 ? (t22[0] = 0, t22[1] = 0, t22[2] = 0, t22[3] = 1, t22) : (F(Q, e22, r22), t22[0] = Q[0], t22[1] = Q[1], t22[2] = Q[2], t22[3] = 1 + n22, it(t22, t22));
      });
      function ot() {
        var t22 = new r2(2);
        return r2 != Float32Array && (t22[0] = 0, t22[1] = 0), t22;
      }
      function at(t22, e22) {
        var n22 = new r2(2);
        return n22[0] = t22, n22[1] = e22, n22;
      }
      function lt(t22, e22, r22) {
        return t22[0] = e22[0] + r22[0], t22[1] = e22[1] + r22[1], t22;
      }
      function ut2(t22, e22, r22) {
        return t22[0] = e22[0] - r22[0], t22[1] = e22[1] - r22[1], t22;
      }
      function ct2(t22, e22, r22) {
        return t22[0] = e22[0] * r22, t22[1] = e22[1] * r22, t22;
      }
      function ht(t22) {
        return Math.hypot(t22[0], t22[1]);
      }
      function pt(t22, e22) {
        var r22 = e22[0], n22 = e22[1], i22 = r22 * r22 + n22 * n22;
        return i22 > 0 && (i22 = 1 / Math.sqrt(i22)), t22[0] = e22[0] * i22, t22[1] = e22[1] * i22, t22;
      }
      function ft2(t22, e22) {
        return t22[0] * e22[0] + t22[1] * e22[1];
      }
      function dt(t22) {
        return t22 && t22.__esModule && Object.prototype.hasOwnProperty.call(t22, "default") ? t22.default : t22;
      }
      W(), W(), i2(), ot();
      var mt, yt, gt = function() {
        if (nt) return rt;
        function t22(t3, e22, r22, n22) {
          this.cx = 3 * t3, this.bx = 3 * (r22 - t3) - this.cx, this.ax = 1 - this.cx - this.bx, this.cy = 3 * e22, this.by = 3 * (n22 - e22) - this.cy, this.ay = 1 - this.cy - this.by, this.p1x = t3, this.p1y = e22, this.p2x = r22, this.p2y = n22;
        }
        return nt = 1, rt = t22, t22.prototype = { sampleCurveX: function(t3) {
          return ((this.ax * t3 + this.bx) * t3 + this.cx) * t3;
        }, sampleCurveY: function(t3) {
          return ((this.ay * t3 + this.by) * t3 + this.cy) * t3;
        }, sampleCurveDerivativeX: function(t3) {
          return (3 * this.ax * t3 + 2 * this.bx) * t3 + this.cx;
        }, solveCurveX: function(t3, e22) {
          if (void 0 === e22 && (e22 = 1e-6), t3 < 0) return 0;
          if (t3 > 1) return 1;
          for (var r22 = t3, n22 = 0; n22 < 8; n22++) {
            var i22 = this.sampleCurveX(r22) - t3;
            if (Math.abs(i22) < e22) return r22;
            var s2 = this.sampleCurveDerivativeX(r22);
            if (Math.abs(s2) < 1e-6) break;
            r22 -= i22 / s2;
          }
          var o2 = 0, a22 = 1;
          for (r22 = t3, n22 = 0; n22 < 20 && (i22 = this.sampleCurveX(r22), !(Math.abs(i22 - t3) < e22)); n22++) t3 > i22 ? o2 = r22 : a22 = r22, r22 = 0.5 * (a22 - o2) + o2;
          return r22;
        }, solve: function(t3, e22) {
          return this.sampleCurveY(this.solveCurveX(t3, e22));
        } }, rt;
      }(), xt = dt(gt);
      function vt() {
        if (yt) return mt;
        function t22(t3, e22) {
          this.x = t3, this.y = e22;
        }
        return yt = 1, mt = t22, t22.prototype = { clone: function() {
          return new t22(this.x, this.y);
        }, add: function(t3) {
          return this.clone()._add(t3);
        }, sub: function(t3) {
          return this.clone()._sub(t3);
        }, multByPoint: function(t3) {
          return this.clone()._multByPoint(t3);
        }, divByPoint: function(t3) {
          return this.clone()._divByPoint(t3);
        }, mult: function(t3) {
          return this.clone()._mult(t3);
        }, div: function(t3) {
          return this.clone()._div(t3);
        }, rotate: function(t3) {
          return this.clone()._rotate(t3);
        }, rotateAround: function(t3, e22) {
          return this.clone()._rotateAround(t3, e22);
        }, matMult: function(t3) {
          return this.clone()._matMult(t3);
        }, unit: function() {
          return this.clone()._unit();
        }, perp: function() {
          return this.clone()._perp();
        }, round: function() {
          return this.clone()._round();
        }, mag: function() {
          return Math.sqrt(this.x * this.x + this.y * this.y);
        }, equals: function(t3) {
          return this.x === t3.x && this.y === t3.y;
        }, dist: function(t3) {
          return Math.sqrt(this.distSqr(t3));
        }, distSqr: function(t3) {
          var e22 = t3.x - this.x, r22 = t3.y - this.y;
          return e22 * e22 + r22 * r22;
        }, angle: function() {
          return Math.atan2(this.y, this.x);
        }, angleTo: function(t3) {
          return Math.atan2(this.y - t3.y, this.x - t3.x);
        }, angleWith: function(t3) {
          return this.angleWithSep(t3.x, t3.y);
        }, angleWithSep: function(t3, e22) {
          return Math.atan2(this.x * e22 - this.y * t3, this.x * t3 + this.y * e22);
        }, _matMult: function(t3) {
          var e22 = t3[2] * this.x + t3[3] * this.y;
          return this.x = t3[0] * this.x + t3[1] * this.y, this.y = e22, this;
        }, _add: function(t3) {
          return this.x += t3.x, this.y += t3.y, this;
        }, _sub: function(t3) {
          return this.x -= t3.x, this.y -= t3.y, this;
        }, _mult: function(t3) {
          return this.x *= t3, this.y *= t3, this;
        }, _div: function(t3) {
          return this.x /= t3, this.y /= t3, this;
        }, _multByPoint: function(t3) {
          return this.x *= t3.x, this.y *= t3.y, this;
        }, _divByPoint: function(t3) {
          return this.x /= t3.x, this.y /= t3.y, this;
        }, _unit: function() {
          return this._div(this.mag()), this;
        }, _perp: function() {
          var t3 = this.y;
          return this.y = this.x, this.x = -t3, this;
        }, _rotate: function(t3) {
          var e22 = Math.cos(t3), r22 = Math.sin(t3), n22 = r22 * this.x + e22 * this.y;
          return this.x = e22 * this.x - r22 * this.y, this.y = n22, this;
        }, _rotateAround: function(t3, e22) {
          var r22 = Math.cos(t3), n22 = Math.sin(t3), i22 = e22.y + n22 * (this.x - e22.x) + r22 * (this.y - e22.y);
          return this.x = e22.x + r22 * (this.x - e22.x) - n22 * (this.y - e22.y), this.y = i22, this;
        }, _round: function() {
          return this.x = Math.round(this.x), this.y = Math.round(this.y), this;
        } }, t22.convert = function(e22) {
          return e22 instanceof t22 ? e22 : Array.isArray(e22) ? new t22(e22[0], e22[1]) : e22;
        }, mt;
      }
      var bt = dt(vt());
      function _t2(t22, e22) {
        if (Array.isArray(t22)) {
          if (!Array.isArray(e22) || t22.length !== e22.length) return false;
          for (let r22 = 0; r22 < t22.length; r22++) if (!_t2(t22[r22], e22[r22])) return false;
          return true;
        }
        if ("object" == typeof t22 && null !== t22 && null !== e22) {
          if ("object" != typeof e22) return false;
          if (Object.keys(t22).length !== Object.keys(e22).length) return false;
          for (const r22 in t22) if (!_t2(t22[r22], e22[r22])) return false;
          return true;
        }
        return t22 === e22;
      }
      const wt = Math.PI / 180, At = 180 / Math.PI;
      function Mt(t22) {
        return t22 * wt;
      }
      function It2(t22) {
        return t22 * At;
      }
      const St = [[0, 0], [1, 0], [1, 1], [0, 1]];
      function zt(t22) {
        if (t22 <= 0) return 0;
        if (t22 >= 1) return 1;
        const e22 = t22 * t22, r22 = e22 * t22;
        return 4 * (t22 < 0.5 ? r22 : 3 * (t22 - e22) + r22 - 0.75);
      }
      function kt(t22, e22, r22, n22) {
        const i22 = new xt(t22, e22, r22, n22);
        return function(t3) {
          return i22.solve(t3);
        };
      }
      const Et = kt(0.25, 0.1, 0.25, 1);
      function Pt(t22, e22, r22) {
        return Math.min(r22, Math.max(e22, t22));
      }
      function Tt(t22, e22, r22) {
        return (r22 = Pt((r22 - t22) / (e22 - t22), 0, 1)) * r22 * (3 - 2 * r22);
      }
      function Bt(t22, e22, r22) {
        const n22 = r22 - e22, i22 = ((t22 - e22) % n22 + n22) % n22 + e22;
        return i22 === e22 ? r22 : i22;
      }
      function Vt2(t22, e22, r22) {
        if (!t22.length) return r22(null, []);
        let n22 = t22.length;
        const i22 = new Array(t22.length);
        let s2 = null;
        t22.forEach((t3, o2) => {
          e22(t3, (t4, e3) => {
            t4 && (s2 = t4), i22[o2] = e3, 0 == --n22 && r22(s2, i22);
          });
        });
      }
      function Ct2(t22, ...e22) {
        for (const r22 of e22) for (const e3 in r22) t22[e3] = r22[e3];
        return t22;
      }
      let Dt2 = 1;
      function Ft2() {
        return Dt2++;
      }
      function Lt(t22) {
        return t22 <= 1 ? 1 : Math.pow(2, Math.ceil(Math.log(t22) / Math.LN2));
      }
      function Rt(t22, e22) {
        t22.forEach((t3) => {
          e22[t3] && (e22[t3] = e22[t3].bind(e22));
        });
      }
      function Ot2(t22, e22, r22) {
        const n22 = {};
        for (const r3 in t22) n22[r3] = e22.call(this, t22[r3], r3, t22);
        return n22;
      }
      function Ut2(t22, e22, r22) {
        const n22 = {};
        for (const r3 in t22) e22.call(this, t22[r3], r3, t22) && (n22[r3] = t22[r3]);
        return n22;
      }
      function Nt(t22) {
        return Array.isArray(t22) ? t22.map(Nt) : "object" == typeof t22 && t22 ? Ot2(t22, Nt) : t22;
      }
      const jt = {};
      function $t2(t22) {
        jt[t22] || ("undefined" != typeof console && console.warn(t22), jt[t22] = true);
      }
      function Gt(t22, e22, r22) {
        return (r22.y - t22.y) * (e22.x - t22.x) > (e22.y - t22.y) * (r22.x - t22.x);
      }
      function qt2(t22) {
        let e22 = 0;
        for (let r22, n22, i22 = 0, s2 = t22.length, o2 = s2 - 1; i22 < s2; o2 = i22++) r22 = t22[i22], n22 = t22[o2], e22 += (n22.x - r22.x) * (r22.y + n22.y);
        return e22;
      }
      function Ht2([t22, e22, r22]) {
        const n22 = Mt(e22 + 90), i22 = Mt(r22);
        return { x: t22 * Math.cos(n22) * Math.sin(i22), y: t22 * Math.sin(n22) * Math.sin(i22), z: t22 * Math.cos(i22), azimuthal: e22, polar: r22 };
      }
      function Xt2(t22) {
        return ("undefined" != typeof self || void 0 !== t22) && "undefined" != typeof WorkerGlobalScope && (void 0 !== t22 ? t22 : self) instanceof WorkerGlobalScope;
      }
      function Zt2(t22) {
        const e22 = {};
        if (t22.replace(/(?:^|(?:\s*\,\s*))([^\x00-\x20\(\)<>@\,;\:\\"\/\[\]\?\=\{\}\x7F]+)(?:\=(?:([^\x00-\x20\(\)<>@\,;\:\\"\/\[\]\?\=\{\}\x7F]+)|(?:\"((?:[^"\\]|\\.)*)\")))?/g, (t3, r22, n22, i22) => {
          const s2 = n22 || i22;
          return e22[r22] = !s2 || s2.toLowerCase(), "";
        }), e22["max-age"]) {
          const t3 = parseInt(e22["max-age"], 10);
          isNaN(t3) ? delete e22["max-age"] : e22["max-age"] = t3;
        }
        return e22;
      }
      let Wt2 = null;
      function Yt(t22, e22) {
        return [t22[4 * e22], t22[4 * e22 + 1], t22[4 * e22 + 2], t22[4 * e22 + 3]];
      }
      function Kt2(t22, e22, r22, n22) {
        for (; e22 < r22; ) {
          const i22 = e22 + r22 >> 1;
          t22[i22] < n22 ? e22 = i22 + 1 : r22 = i22;
        }
        return e22;
      }
      function Jt2(t22, e22, r22, n22) {
        for (; e22 < r22; ) {
          const i22 = e22 + r22 >> 1;
          t22[i22] <= n22 ? e22 = i22 + 1 : r22 = i22;
        }
        return e22;
      }
      function Qt2(t22) {
        return t22 > 0 ? 1 / (1.001 - t22) : 1 + t22;
      }
      function te2(t22) {
        return t22 > 0 ? 1 - 1 / (1.001 - t22) : -t22;
      }
      function ee2(t22, e22, r22) {
        return (t22 - e22.min) * (r22.max - r22.min) / (e22.max - e22.min) + r22.min;
      }
      const re = { API_URL: "https://api.mapbox.com", get API_URL_REGEX() {
        return /^((https?:)?\/\/)?([^\/]+\.)?mapbox\.c(n|om)(\/|\?|$)/i;
      }, get API_TILEJSON_REGEX() {
        return /^((https?:)?\/\/)?([^\/]+\.)?mapbox\.c(n|om)(\/v[0-9]*\/.*\.json.*$)/i;
      }, get API_SPRITE_REGEX() {
        return /^((https?:)?\/\/)?([^\/]+\.)?mapbox\.c(n|om)(\/styles\/v[0-9]*\/)(.*\/sprite.*\..*$)/i;
      }, get API_FONTS_REGEX() {
        return /^((https?:)?\/\/)?([^\/]+\.)?mapbox\.c(n|om)(\/fonts\/v[0-9]*\/)(.*\.pbf.*$)/i;
      }, get API_STYLE_REGEX() {
        return /^((https?:)?\/\/)?([^\/]+\.)?mapbox\.c(n|om)(\/styles\/v[0-9]*\/)(.*$)/i;
      }, get API_CDN_URL_REGEX() {
        return /^((https?:)?\/\/)?api\.mapbox\.c(n|om)(\/mapbox-gl-js\/)(.*$)/i;
      }, get EVENTS_URL() {
        if (!re.API_URL) return null;
        try {
          const t22 = new URL(re.API_URL);
          return "api.mapbox.cn" === t22.hostname ? "https://events.mapbox.cn/events/v2" : "api.mapbox.com" === t22.hostname ? "https://events.mapbox.com/events/v2" : null;
        } catch (t22) {
          return null;
        }
      }, SESSION_PATH: "/map-sessions/v1", FEEDBACK_URL: "https://apps.mapbox.com/feedback", TILE_URL_VERSION: "v4", RASTER_URL_PREFIX: "raster/v1", RASTERARRAYS_URL_PREFIX: "rasterarrays/v1", REQUIRE_ACCESS_TOKEN: true, ACCESS_TOKEN: null, DEFAULT_STYLE: "mapbox://styles/mapbox/standard", MAX_PARALLEL_IMAGE_REQUESTS: 16, DRACO_URL: "https://api.mapbox.com/mapbox-gl-js/draco_decoder_gltf_v1.5.6.wasm", MESHOPT_URL: "https://api.mapbox.com/mapbox-gl-js/meshopt_base_v0.20.wasm", MESHOPT_SIMD_URL: "https://api.mapbox.com/mapbox-gl-js/meshopt_simd_v0.20.wasm", GLYPHS_URL: "mapbox://fonts/mapbox/{fontstack}/{range}.pbf", TILES3D_URL_PREFIX: "3dtiles/v1" };
      function ne2(t22) {
        return re.API_URL_REGEX.test(t22);
      }
      function ie2(t22) {
        return re.API_SPRITE_REGEX.test(t22);
      }
      let se2, oe2, ae2, le, ue, ce2;
      function he() {
        return null == se2 && (se2 = self.OffscreenCanvas && new OffscreenCanvas(1, 1).getContext("2d") && "function" == typeof self.createImageBitmap), se2;
      }
      const pe = { now: () => void 0 !== le ? le : performance.now(), setNow(t22) {
        le = t22;
      }, restoreNow() {
        le = void 0;
      }, frame(t22) {
        const e22 = requestAnimationFrame(t22);
        return { cancel: () => cancelAnimationFrame(e22) };
      }, getImageData(t22, e22 = 0) {
        const { width: r22, height: n22 } = t22;
        ue || (ue = document.createElement("canvas"));
        const i22 = ue.getContext("2d", { willReadFrequently: true });
        if (!i22) throw new Error("failed to create canvas 2d context");
        return (r22 > ue.width || n22 > ue.height) && (ue.width = r22, ue.height = n22), i22.clearRect(-e22, -e22, r22 + 2 * e22, n22 + 2 * e22), i22.drawImage(t22, 0, 0, r22, n22), i22.getImageData(-e22, -e22, r22 + 2 * e22, n22 + 2 * e22);
      }, resolveURL: (t22) => (oe2 || (oe2 = document.createElement("a")), oe2.href = t22, oe2.href), get devicePixelRatio() {
        return window.devicePixelRatio;
      }, get prefersReducedMotion() {
        return !!window.matchMedia && (null == ae2 && (ae2 = window.matchMedia("(prefers-reduced-motion: reduce)")), ae2.matches);
      }, hasCanvasFingerprintNoise() {
        if (void 0 !== ce2) return ce2;
        if (!he()) return ce2 = false, false;
        const t22 = new OffscreenCanvas(85, 1), e22 = t22.getContext("2d", { willReadFrequently: true });
        let r22 = 0;
        for (let n3 = 0; n3 < t22.width; ++n3) e22.fillStyle = `rgba(${r22++},${r22++},${r22++}, 255)`, e22.fillRect(n3, 0, 1, 1);
        const n22 = e22.getImageData(0, 0, t22.width, t22.height);
        r22 = 0;
        for (let t3 = 0; t3 < n22.data.length; ++t3) if (t3 % 4 != 3 && r22++ !== n22.data[t3]) return ce2 = true, true;
        return ce2 = false, false;
      } };
      function fe(t22, e22) {
        const r22 = t22.indexOf("?");
        if (r22 < 0) return `${t22}?${new URLSearchParams(e22).toString()}`;
        const n22 = new URLSearchParams(t22.slice(r22));
        for (const t3 in e22) n22.set(t3, e22[t3]);
        return `${t22.slice(0, r22)}?${n22.toString()}`;
      }
      function de(t22, e22 = { persistentParams: [] }) {
        const r22 = t22.indexOf("?");
        if (r22 < 0) return t22;
        const n22 = new URLSearchParams(), i22 = new URLSearchParams(t22.slice(r22));
        for (const t3 of e22.persistentParams) {
          const e3 = i22.get(t3);
          e3 && n22.set(t3, e3);
        }
        const s2 = n22.toString();
        return `${t22.slice(0, r22)}${s2.length > 0 ? `?${s2}` : ""}`;
      }
      const me = "mapbox-tiles";
      let ye = 500, ge = 50;
      const xe = ["language", "worldview", "jobid"];
      let ve, be;
      function _e2() {
        try {
          return caches;
        } catch (t22) {
        }
      }
      function we() {
        const t22 = _e2();
        t22 && null == ve && (ve = t22.open(me));
      }
      let Ae = 1 / 0;
      const Me = { supported: false, testSupport: function(t22) {
        !ze && Se && (ke ? Pe(t22) : Ie = t22);
      } };
      let Ie, Se, ze = false, ke = false;
      const Ee = "undefined" != typeof self ? self : {};
      function Pe(t22) {
        const e22 = t22.createTexture();
        t22.bindTexture(t22.TEXTURE_2D, e22);
        try {
          if (t22.texImage2D(t22.TEXTURE_2D, 0, t22.RGBA, t22.RGBA, t22.UNSIGNED_BYTE, Se), t22.isContextLost()) return;
          Me.supported = true;
        } catch (t3) {
        }
        t22.deleteTexture(e22), ze = true;
      }
      Ee.document && (Se = Ee.document.createElement("img"), Se.onload = function() {
        Ie && Pe(Ie), Ie = null, ke = true;
      }, Se.onerror = function() {
        ze = true, Ie = null;
      }, Se.src = "data:image/webp;base64,UklGRh4AAABXRUJQVlA4TBEAAAAvAQAAAAfQ//73v/+BiOh/AAA=");
      const Te2 = { Unknown: "Unknown", Style: "Style", Source: "Source", Tile: "Tile", Glyphs: "Glyphs", SpriteImage: "SpriteImage", SpriteJSON: "SpriteJSON", Iconset: "Iconset", Image: "Image", Model: "Model" };
      "function" == typeof Object.freeze && Object.freeze(Te2);
      class Be extends Error {
        constructor(t22, e22, r22) {
          401 === e22 && ne2(r22) && (t22 += ": you may have provided an invalid Mapbox access token. See https://docs.mapbox.com/api/overview/#access-tokens-and-token-scopes"), super(t22), this.status = e22, this.url = r22;
        }
        toString() {
          return `${this.name}: ${this.message} (${this.status}): ${this.url}`;
        }
      }
      const Ve = Xt2() ? () => self.worker.referrer : () => ("blob:" === location.protocol ? parent : self).location.href;
      const Ce = function(t22, e22) {
        if (!(/^file:/.test(r22 = t22.url) || /^file:/.test(Ve()) && !/^\w+:/.test(r22))) {
          if (self.fetch && self.Request && self.AbortController && Request.prototype.hasOwnProperty("signal")) return function(t3, e3) {
            const r3 = new AbortController(), n22 = new Request(t3.url, { method: t3.method || "GET", body: t3.body, credentials: t3.credentials, headers: t3.headers, referrer: Ve(), referrerPolicy: t3.referrerPolicy, signal: r3.signal });
            let i22 = false, s2 = false;
            const o2 = (a22 = n22.url).indexOf("sku=") > 0 && ne2(a22);
            var a22;
            "json" === t3.type && n22.headers.set("Accept", "application/json");
            const l22 = (r4, i3, a3) => {
              if (s2) return;
              if (r4 && "SecurityError" !== r4.message && $t2(r4.toString()), i3 && a3) return u22(i3);
              const l3 = Date.now();
              fetch(n22).then((r5) => {
                if (r5.ok) {
                  const t4 = o2 ? r5.clone() : null;
                  return u22(r5, t4, l3);
                }
                return e3(new Be(r5.statusText, r5.status, t3.url));
              }).catch((r5) => {
                "AbortError" !== r5.name && e3(new Error(`${r5.message} ${t3.url}`));
              });
            }, u22 = (r4, o3, a3) => {
              ("arrayBuffer" === t3.type ? r4.arrayBuffer() : "json" === t3.type ? r4.json() : r4.text()).then((t4) => {
                s2 || (o3 && a3 && function(t5, e4, r5) {
                  if (we(), null == ve) return;
                  const n3 = Zt2(e4.headers.get("Cache-Control") || "");
                  if (n3["no-store"]) return;
                  const i3 = { status: e4.status, statusText: e4.statusText, headers: new Headers() };
                  e4.headers.forEach((t6, e5) => i3.headers.set(e5, t6)), n3["max-age"] && i3.headers.set("Expires", new Date(r5 + 1e3 * n3["max-age"]).toUTCString());
                  const s3 = i3.headers.get("Expires");
                  if (!s3) return;
                  if (new Date(s3).getTime() - r5 < 42e4) return;
                  let o4 = de(t5.url, { persistentParams: xe });
                  if (206 === e4.status) {
                    const e5 = t5.headers.get("Range");
                    if (!e5) return;
                    i3.status = 200, o4 = fe(o4, { range: e5 });
                  }
                  !function(t6, e5) {
                    if (void 0 === be) try {
                      new Response(new ReadableStream()), be = true;
                    } catch (t7) {
                      be = false;
                    }
                    be ? e5(t6.body) : t6.blob().then(e5).catch((t7) => $t2(t7.message));
                  }(e4, (t6) => {
                    const r6 = new Response(200 !== (n4 = e4.status) && 404 !== n4 && [101, 103, 204, 205, 304].includes(n4) ? null : t6, i3);
                    var n4;
                    we(), null != ve && ve.then((t7) => t7.put(o4, r6)).catch((t7) => $t2(t7.message));
                  });
                }(n22, o3, a3), i22 = true, e3(null, t4, r4.headers.get("Cache-Control"), r4.headers.get("Expires")));
              }).catch((t4) => {
                s2 || e3(new Error(t4.message));
              });
            };
            return o2 ? function(t4, e4) {
              if (we(), null == ve) return e4(null);
              ve.then((r4) => {
                let n3 = de(t4.url, { persistentParams: xe });
                const i3 = t4.headers.get("Range");
                i3 && (n3 = fe(n3, { range: i3 })), r4.match(n3).then((t5) => {
                  const i4 = function(t6) {
                    if (!t6) return false;
                    const e5 = new Date(t6.headers.get("Expires") || 0), r5 = Zt2(t6.headers.get("Cache-Control") || "");
                    return Number(e5) > Date.now() && !r5["no-cache"];
                  }(t5);
                  r4.delete(n3).catch(e4), i4 && r4.put(n3, t5.clone()).catch(e4), e4(null, t5, i4);
                }).catch(e4);
              }).catch(e4);
            }(n22, l22) : l22(null, null), { cancel: () => {
              s2 = true, i22 || r3.abort();
            } };
          }(t22, e22);
          if (Xt2(self) && self.worker.actor) return self.worker.actor.send("getResource", t22, e22, void 0, true);
        }
        var r22;
        return function(t3, e3) {
          const r3 = new XMLHttpRequest();
          r3.open(t3.method || "GET", t3.url, true), "arrayBuffer" === t3.type && (r3.responseType = "arraybuffer");
          for (const e4 in t3.headers) r3.setRequestHeader(e4, t3.headers[e4]);
          return "json" === t3.type && (r3.responseType = "text", r3.setRequestHeader("Accept", "application/json")), r3.withCredentials = "include" === t3.credentials, r3.onerror = () => {
            e3(new Error(r3.statusText));
          }, r3.onload = () => {
            if ((r3.status >= 200 && r3.status < 300 || 0 === r3.status) && null !== r3.response) {
              let n22 = r3.response;
              if ("json" === t3.type) try {
                n22 = JSON.parse(r3.response);
              } catch (t4) {
                return e3(t4);
              }
              e3(null, n22, r3.getResponseHeader("Cache-Control"), r3.getResponseHeader("Expires"));
            } else e3(new Be(r3.statusText, r3.status, t3.url));
          }, r3.send(t3.body), { cancel: () => r3.abort() };
        }(t22, e22);
      }, De = function(t22, e22) {
        return Ce(Ct2(t22, { type: "arrayBuffer" }), e22);
      };
      function Fe(t22) {
        const e22 = document.createElement("a");
        return e22.href = t22, e22.protocol === location.protocol && e22.host === location.host;
      }
      const Le = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAAC0lEQVQYV2NgAAIAAAUAAarVyFEAAAAASUVORK5CYII=";
      let Re, Oe;
      Re = [], Oe = 0;
      const Ue = function(t22, e22) {
        if (Me.supported && (t22.headers || (t22.headers = {}), t22.headers.accept = "image/webp,*/*"), Oe >= re.MAX_PARALLEL_IMAGE_REQUESTS) {
          const r3 = { requestParameters: t22, callback: e22, cancelled: false, cancel() {
            this.cancelled = true;
          } };
          return Re.push(r3), r3;
        }
        Oe++;
        let r22 = false;
        const n22 = () => {
          if (!r22) for (r22 = true, Oe--; Re.length && Oe < re.MAX_PARALLEL_IMAGE_REQUESTS; ) {
            const t3 = Re.shift(), { requestParameters: e3, callback: r3, cancelled: n3 } = t3;
            n3 || (t3.cancel = Ue(e3, r3).cancel);
          }
        }, i22 = De(t22, (t3, r3, i3, s2) => {
          n22(), t3 ? e22(t3) : r3 && (self.createImageBitmap ? function(t4, e3) {
            const r4 = new Blob([new Uint8Array(t4)], { type: "image/png" });
            createImageBitmap(r4).then((t5) => {
              e3(null, t5);
            }).catch((t5) => {
              e3(new Error(`Could not load image because of ${t5.message}. Please make sure to use a supported image type such as PNG or JPEG. Note that SVGs are not supported.`));
            });
          }(r3, (t4, r4) => e22(t4, r4, i3, s2)) : function(t4, e3) {
            const r4 = new Image();
            r4.onload = () => {
              e3(null, r4), URL.revokeObjectURL(r4.src), r4.onload = null, requestAnimationFrame(() => {
                r4.src = Le;
              });
            }, r4.onerror = () => e3(new Error("Could not load image. Please make sure to use a supported image type such as PNG or JPEG. Note that SVGs are not supported."));
            const n3 = new Blob([new Uint8Array(t4)], { type: "image/png" });
            r4.src = t4.byteLength ? URL.createObjectURL(n3) : Le;
          }(r3, (t4, r4) => e22(t4, r4, i3, s2)));
        });
        return { cancel: () => {
          i22.cancel(), n22();
        } };
      };
      var Ne, je, $e, Ge = { exports: {} }, qe = { exports: {} }, He = { exports: {} }, Xe = function() {
        if ($e) return Ge.exports;
        $e = 1;
        var t22 = (Ne || (Ne = 1, qe.exports = function(t3, e3) {
          var r22, n22, i22, s2, o2, a22, l22, u22;
          for (n22 = t3.length - (r22 = 3 & t3.length), i22 = e3, o2 = 3432918353, a22 = 461845907, u22 = 0; u22 < n22; ) l22 = 255 & t3.charCodeAt(u22) | (255 & t3.charCodeAt(++u22)) << 8 | (255 & t3.charCodeAt(++u22)) << 16 | (255 & t3.charCodeAt(++u22)) << 24, ++u22, i22 = 27492 + (65535 & (s2 = 5 * (65535 & (i22 = (i22 ^= l22 = (65535 & (l22 = (l22 = (65535 & l22) * o2 + (((l22 >>> 16) * o2 & 65535) << 16) & 4294967295) << 15 | l22 >>> 17)) * a22 + (((l22 >>> 16) * a22 & 65535) << 16) & 4294967295) << 13 | i22 >>> 19)) + ((5 * (i22 >>> 16) & 65535) << 16) & 4294967295)) + ((58964 + (s2 >>> 16) & 65535) << 16);
          switch (l22 = 0, r22) {
            case 3:
              l22 ^= (255 & t3.charCodeAt(u22 + 2)) << 16;
            case 2:
              l22 ^= (255 & t3.charCodeAt(u22 + 1)) << 8;
            case 1:
              i22 ^= l22 = (65535 & (l22 = (l22 = (65535 & (l22 ^= 255 & t3.charCodeAt(u22))) * o2 + (((l22 >>> 16) * o2 & 65535) << 16) & 4294967295) << 15 | l22 >>> 17)) * a22 + (((l22 >>> 16) * a22 & 65535) << 16) & 4294967295;
          }
          return i22 ^= t3.length, i22 = 2246822507 * (65535 & (i22 ^= i22 >>> 16)) + ((2246822507 * (i22 >>> 16) & 65535) << 16) & 4294967295, i22 = 3266489909 * (65535 & (i22 ^= i22 >>> 13)) + ((3266489909 * (i22 >>> 16) & 65535) << 16) & 4294967295, (i22 ^= i22 >>> 16) >>> 0;
        }), qe.exports), e22 = (je || (je = 1, He.exports = function(t3, e3) {
          for (var r22, n22 = t3.length, i22 = e3 ^ n22, s2 = 0; n22 >= 4; ) r22 = 1540483477 * (65535 & (r22 = 255 & t3.charCodeAt(s2) | (255 & t3.charCodeAt(++s2)) << 8 | (255 & t3.charCodeAt(++s2)) << 16 | (255 & t3.charCodeAt(++s2)) << 24)) + ((1540483477 * (r22 >>> 16) & 65535) << 16), i22 = 1540483477 * (65535 & i22) + ((1540483477 * (i22 >>> 16) & 65535) << 16) ^ (r22 = 1540483477 * (65535 & (r22 ^= r22 >>> 24)) + ((1540483477 * (r22 >>> 16) & 65535) << 16)), n22 -= 4, ++s2;
          switch (n22) {
            case 3:
              i22 ^= (255 & t3.charCodeAt(s2 + 2)) << 16;
            case 2:
              i22 ^= (255 & t3.charCodeAt(s2 + 1)) << 8;
            case 1:
              i22 = 1540483477 * (65535 & (i22 ^= 255 & t3.charCodeAt(s2))) + ((1540483477 * (i22 >>> 16) & 65535) << 16);
          }
          return i22 = 1540483477 * (65535 & (i22 ^= i22 >>> 13)) + ((1540483477 * (i22 >>> 16) & 65535) << 16), (i22 ^= i22 >>> 15) >>> 0;
        }), He.exports);
        return Ge.exports = t22, Ge.exports.murmur3 = t22, Ge.exports.murmur2 = e22, Ge.exports;
      }(), Ze = dt(Xe);
      class We {
        constructor(t22, ...e22) {
          Ct2(this, e22[0] || {}), this.type = t22;
        }
      }
      class Ye extends We {
        constructor(t22, e22 = {}) {
          super("error", Ct2({ error: t22 }, e22));
        }
      }
      function Ke(t22, e22, r22) {
        r22[t22] && -1 !== r22[t22].indexOf(e22) || (r22[t22] = r22[t22] || [], r22[t22].push(e22));
      }
      function Je(t22, e22, r22) {
        if (r22 && r22[t22]) {
          const n22 = r22[t22].indexOf(e22);
          -1 !== n22 && r22[t22].splice(n22, 1);
        }
      }
      class Qe {
        on(t22, e22) {
          return this._listeners = this._listeners || {}, Ke(t22, e22, this._listeners), this;
        }
        off(t22, e22) {
          return Je(t22, e22, this._listeners), Je(t22, e22, this._oneTimeListeners), this;
        }
        once(t22, e22) {
          return e22 ? (this._oneTimeListeners = this._oneTimeListeners || {}, Ke(t22, e22, this._oneTimeListeners), this) : new Promise((e3) => {
            this.once(t22, e3);
          });
        }
        fire(t22, e22) {
          const r22 = "string" == typeof t22 ? new We(t22, e22) : t22, n22 = r22.type;
          if (this.listens(n22)) {
            r22.target = this;
            const t3 = this._listeners && this._listeners[n22] ? this._listeners[n22].slice() : [];
            for (const e4 of t3) e4.call(this, r22);
            const e3 = this._oneTimeListeners && this._oneTimeListeners[n22] ? this._oneTimeListeners[n22].slice() : [];
            for (const t4 of e3) Je(n22, t4, this._oneTimeListeners), t4.call(this, r22);
            const i22 = this._eventedParent;
            i22 && (Ct2(r22, "function" == typeof this._eventedParentData ? this._eventedParentData() : this._eventedParentData), i22.fire(r22));
          } else r22 instanceof Ye && console.error(r22.error);
          return this;
        }
        listens(t22) {
          return !!(this._listeners && this._listeners[t22] && this._listeners[t22].length > 0 || this._oneTimeListeners && this._oneTimeListeners[t22] && this._oneTimeListeners[t22].length > 0 || this._eventedParent && this._eventedParent.listens(t22));
        }
        setEventedParent(t22, e22) {
          return this._eventedParent = t22, this._eventedParentData = e22, this;
        }
      }
      class tr {
        constructor(t22) {
          "string" == typeof t22 ? this.name = t22 : (this.name = t22.name, this.iconsetId = t22.iconsetId);
        }
        static from(t22) {
          return new tr(t22);
        }
        static toString(t22) {
          return t22.iconsetId ? `${t22.name}${t22.iconsetId}` : t22.name;
        }
        static parse(t22) {
          const [e22, r22] = t22.split("");
          return new tr({ name: e22, iconsetId: r22 });
        }
        static isEqual(t22, e22) {
          return t22.name === e22.name && t22.iconsetId === e22.iconsetId;
        }
        toString() {
          return tr.toString(this);
        }
        serialize() {
          return { name: this.name, iconsetId: this.iconsetId };
        }
      }
      var er, rr = {}, nr = function() {
        if (er) return rr;
        er = 1;
        var t22 = { transparent: [0, 0, 0, 0], aliceblue: [240, 248, 255, 1], antiquewhite: [250, 235, 215, 1], aqua: [0, 255, 255, 1], aquamarine: [127, 255, 212, 1], azure: [240, 255, 255, 1], beige: [245, 245, 220, 1], bisque: [255, 228, 196, 1], black: [0, 0, 0, 1], blanchedalmond: [255, 235, 205, 1], blue: [0, 0, 255, 1], blueviolet: [138, 43, 226, 1], brown: [165, 42, 42, 1], burlywood: [222, 184, 135, 1], cadetblue: [95, 158, 160, 1], chartreuse: [127, 255, 0, 1], chocolate: [210, 105, 30, 1], coral: [255, 127, 80, 1], cornflowerblue: [100, 149, 237, 1], cornsilk: [255, 248, 220, 1], crimson: [220, 20, 60, 1], cyan: [0, 255, 255, 1], darkblue: [0, 0, 139, 1], darkcyan: [0, 139, 139, 1], darkgoldenrod: [184, 134, 11, 1], darkgray: [169, 169, 169, 1], darkgreen: [0, 100, 0, 1], darkgrey: [169, 169, 169, 1], darkkhaki: [189, 183, 107, 1], darkmagenta: [139, 0, 139, 1], darkolivegreen: [85, 107, 47, 1], darkorange: [255, 140, 0, 1], darkorchid: [153, 50, 204, 1], darkred: [139, 0, 0, 1], darksalmon: [233, 150, 122, 1], darkseagreen: [143, 188, 143, 1], darkslateblue: [72, 61, 139, 1], darkslategray: [47, 79, 79, 1], darkslategrey: [47, 79, 79, 1], darkturquoise: [0, 206, 209, 1], darkviolet: [148, 0, 211, 1], deeppink: [255, 20, 147, 1], deepskyblue: [0, 191, 255, 1], dimgray: [105, 105, 105, 1], dimgrey: [105, 105, 105, 1], dodgerblue: [30, 144, 255, 1], firebrick: [178, 34, 34, 1], floralwhite: [255, 250, 240, 1], forestgreen: [34, 139, 34, 1], fuchsia: [255, 0, 255, 1], gainsboro: [220, 220, 220, 1], ghostwhite: [248, 248, 255, 1], gold: [255, 215, 0, 1], goldenrod: [218, 165, 32, 1], gray: [128, 128, 128, 1], green: [0, 128, 0, 1], greenyellow: [173, 255, 47, 1], grey: [128, 128, 128, 1], honeydew: [240, 255, 240, 1], hotpink: [255, 105, 180, 1], indianred: [205, 92, 92, 1], indigo: [75, 0, 130, 1], ivory: [255, 255, 240, 1], khaki: [240, 230, 140, 1], lavender: [230, 230, 250, 1], lavenderblush: [255, 240, 245, 1], lawngreen: [124, 252, 0, 1], lemonchiffon: [255, 250, 205, 1], lightblue: [173, 216, 230, 1], lightcoral: [240, 128, 128, 1], lightcyan: [224, 255, 255, 1], lightgoldenrodyellow: [250, 250, 210, 1], lightgray: [211, 211, 211, 1], lightgreen: [144, 238, 144, 1], lightgrey: [211, 211, 211, 1], lightpink: [255, 182, 193, 1], lightsalmon: [255, 160, 122, 1], lightseagreen: [32, 178, 170, 1], lightskyblue: [135, 206, 250, 1], lightslategray: [119, 136, 153, 1], lightslategrey: [119, 136, 153, 1], lightsteelblue: [176, 196, 222, 1], lightyellow: [255, 255, 224, 1], lime: [0, 255, 0, 1], limegreen: [50, 205, 50, 1], linen: [250, 240, 230, 1], magenta: [255, 0, 255, 1], maroon: [128, 0, 0, 1], mediumaquamarine: [102, 205, 170, 1], mediumblue: [0, 0, 205, 1], mediumorchid: [186, 85, 211, 1], mediumpurple: [147, 112, 219, 1], mediumseagreen: [60, 179, 113, 1], mediumslateblue: [123, 104, 238, 1], mediumspringgreen: [0, 250, 154, 1], mediumturquoise: [72, 209, 204, 1], mediumvioletred: [199, 21, 133, 1], midnightblue: [25, 25, 112, 1], mintcream: [245, 255, 250, 1], mistyrose: [255, 228, 225, 1], moccasin: [255, 228, 181, 1], navajowhite: [255, 222, 173, 1], navy: [0, 0, 128, 1], oldlace: [253, 245, 230, 1], olive: [128, 128, 0, 1], olivedrab: [107, 142, 35, 1], orange: [255, 165, 0, 1], orangered: [255, 69, 0, 1], orchid: [218, 112, 214, 1], palegoldenrod: [238, 232, 170, 1], palegreen: [152, 251, 152, 1], paleturquoise: [175, 238, 238, 1], palevioletred: [219, 112, 147, 1], papayawhip: [255, 239, 213, 1], peachpuff: [255, 218, 185, 1], peru: [205, 133, 63, 1], pink: [255, 192, 203, 1], plum: [221, 160, 221, 1], powderblue: [176, 224, 230, 1], purple: [128, 0, 128, 1], rebeccapurple: [102, 51, 153, 1], red: [255, 0, 0, 1], rosybrown: [188, 143, 143, 1], royalblue: [65, 105, 225, 1], saddlebrown: [139, 69, 19, 1], salmon: [250, 128, 114, 1], sandybrown: [244, 164, 96, 1], seagreen: [46, 139, 87, 1], seashell: [255, 245, 238, 1], sienna: [160, 82, 45, 1], silver: [192, 192, 192, 1], skyblue: [135, 206, 235, 1], slateblue: [106, 90, 205, 1], slategray: [112, 128, 144, 1], slategrey: [112, 128, 144, 1], snow: [255, 250, 250, 1], springgreen: [0, 255, 127, 1], steelblue: [70, 130, 180, 1], tan: [210, 180, 140, 1], teal: [0, 128, 128, 1], thistle: [216, 191, 216, 1], tomato: [255, 99, 71, 1], turquoise: [64, 224, 208, 1], violet: [238, 130, 238, 1], wheat: [245, 222, 179, 1], white: [255, 255, 255, 1], whitesmoke: [245, 245, 245, 1], yellow: [255, 255, 0, 1], yellowgreen: [154, 205, 50, 1] };
        function e22(t3) {
          return (t3 = Math.round(t3)) < 0 ? 0 : t3 > 255 ? 255 : t3;
        }
        function r22(t3) {
          return e22("%" === t3[t3.length - 1] ? parseFloat(t3) / 100 * 255 : parseInt(t3));
        }
        function n22(t3) {
          return (e3 = "%" === t3[t3.length - 1] ? parseFloat(t3) / 100 : parseFloat(t3)) < 0 ? 0 : e3 > 1 ? 1 : e3;
          var e3;
        }
        function i22(t3, e3, r3) {
          return r3 < 0 ? r3 += 1 : r3 > 1 && (r3 -= 1), 6 * r3 < 1 ? t3 + (e3 - t3) * r3 * 6 : 2 * r3 < 1 ? e3 : 3 * r3 < 2 ? t3 + (e3 - t3) * (2 / 3 - r3) * 6 : t3;
        }
        try {
          rr.parseCSSColor = function(s2) {
            var o2, a22 = s2.replace(/ /g, "").toLowerCase();
            if (a22 in t22) return t22[a22].slice();
            if ("#" === a22[0]) return 4 === a22.length ? (o2 = parseInt(a22.substr(1), 16)) >= 0 && o2 <= 4095 ? [(3840 & o2) >> 4 | (3840 & o2) >> 8, 240 & o2 | (240 & o2) >> 4, 15 & o2 | (15 & o2) << 4, 1] : null : 7 === a22.length && (o2 = parseInt(a22.substr(1), 16)) >= 0 && o2 <= 16777215 ? [(16711680 & o2) >> 16, (65280 & o2) >> 8, 255 & o2, 1] : null;
            var l22 = a22.indexOf("("), u22 = a22.indexOf(")");
            if (-1 !== l22 && u22 + 1 === a22.length) {
              var c22 = a22.substr(0, l22), h22 = a22.substr(l22 + 1, u22 - (l22 + 1)).split(","), p22 = 1;
              switch (c22) {
                case "rgba":
                  if (4 !== h22.length) return null;
                  p22 = n22(h22.pop());
                case "rgb":
                  return 3 !== h22.length ? null : [r22(h22[0]), r22(h22[1]), r22(h22[2]), p22];
                case "hsla":
                  if (4 !== h22.length) return null;
                  p22 = n22(h22.pop());
                case "hsl":
                  if (3 !== h22.length) return null;
                  var f22 = (parseFloat(h22[0]) % 360 + 360) % 360 / 360, d22 = n22(h22[1]), m22 = n22(h22[2]), y22 = m22 <= 0.5 ? m22 * (d22 + 1) : m22 + d22 - m22 * d22, g22 = 2 * m22 - y22;
                  return [e22(255 * i22(g22, y22, f22 + 1 / 3)), e22(255 * i22(g22, y22, f22)), e22(255 * i22(g22, y22, f22 - 1 / 3)), p22];
                default:
                  return null;
              }
            }
            return null;
          };
        } catch (t3) {
        }
        return rr;
      }();
      class ir {
        constructor(t22, e22, r22, n22 = 1) {
          this.r = t22, this.g = e22, this.b = r22, this.a = n22;
        }
        static parse(t22) {
          if (!t22) return;
          if (t22 instanceof ir) return t22;
          if ("string" != typeof t22) return;
          const e22 = nr.parseCSSColor(t22);
          return e22 ? new ir(e22[0] / 255 * e22[3], e22[1] / 255 * e22[3], e22[2] / 255 * e22[3], e22[3]) : void 0;
        }
        toStringPremultipliedAlpha() {
          const [t22, e22, r22, n22] = 0 === this.a ? [0, 0, 0, 0] : [255 * this.r / this.a, 255 * this.g / this.a, 255 * this.b / this.a, this.a];
          return `rgba(${Math.round(t22)},${Math.round(e22)},${Math.round(r22)},${n22})`;
        }
        toString() {
          const [t22, e22, r22, n22] = [this.r, this.g, this.b, this.a];
          return `rgba(${Math.round(255 * t22)},${Math.round(255 * e22)},${Math.round(255 * r22)},${n22})`;
        }
        toRenderColor(t22) {
          const { r: e22, g: r22, b: n22, a: i22 } = this;
          return new sr(t22, e22, r22, n22, i22);
        }
        clone() {
          return new ir(this.r, this.g, this.b, this.a);
        }
      }
      class sr {
        constructor(t22, e22, r22, n22, i22) {
          if (t22) {
            const s2 = t22.image.height, o2 = s2 * s2;
            e22 = 0 === i22 ? 0 : e22 / i22 * (s2 - 1), r22 = 0 === i22 ? 0 : r22 / i22 * (s2 - 1), n22 = 0 === i22 ? 0 : n22 / i22 * (s2 - 1);
            const a22 = Math.floor(e22), l22 = Math.floor(r22), u22 = Math.floor(n22), c22 = Math.ceil(e22), h22 = Math.ceil(r22), p22 = Math.ceil(n22), f22 = e22 - a22, d22 = r22 - l22, m22 = n22 - u22, y22 = t22.image.data, g22 = 4 * (a22 + l22 * o2 + u22 * s2), x22 = 4 * (a22 + l22 * o2 + p22 * s2), v22 = 4 * (a22 + h22 * o2 + u22 * s2), b22 = 4 * (a22 + h22 * o2 + p22 * s2), _22 = 4 * (c22 + l22 * o2 + u22 * s2), w22 = 4 * (c22 + l22 * o2 + p22 * s2), A22 = 4 * (c22 + h22 * o2 + u22 * s2), M22 = 4 * (c22 + h22 * o2 + p22 * s2);
            if (g22 < 0 || M22 >= y22.length) throw new Error("out of range");
            this.r = or(or(or(y22[g22], y22[x22], m22), or(y22[v22], y22[b22], m22), d22), or(or(y22[_22], y22[w22], m22), or(y22[A22], y22[M22], m22), d22), f22) / 255 * i22, this.g = or(or(or(y22[g22 + 1], y22[x22 + 1], m22), or(y22[v22 + 1], y22[b22 + 1], m22), d22), or(or(y22[_22 + 1], y22[w22 + 1], m22), or(y22[A22 + 1], y22[M22 + 1], m22), d22), f22) / 255 * i22, this.b = or(or(or(y22[g22 + 2], y22[x22 + 2], m22), or(y22[v22 + 2], y22[b22 + 2], m22), d22), or(or(y22[_22 + 2], y22[w22 + 2], m22), or(y22[A22 + 2], y22[M22 + 2], m22), d22), f22) / 255 * i22, this.a = i22;
          } else this.r = e22, this.g = r22, this.b = n22, this.a = i22;
        }
        toArray() {
          const { r: t22, g: e22, b: r22, a: n22 } = this;
          return 0 === n22 ? [0, 0, 0, 0] : [255 * t22 / n22, 255 * e22 / n22, 255 * r22 / n22, n22];
        }
        toHslaArray() {
          if (0 === this.a) return [0, 0, 0, 0];
          const { r: t22, g: e22, b: r22, a: n22 } = this, i22 = Math.min(Math.max(t22 / n22, 0), 1), s2 = Math.min(Math.max(e22 / n22, 0), 1), o2 = Math.min(Math.max(r22 / n22, 0), 1), a22 = Math.min(i22, s2, o2), l22 = Math.max(i22, s2, o2), u22 = (a22 + l22) / 2;
          if (a22 === l22) return [0, 0, 100 * u22, n22];
          const c22 = l22 - a22, h22 = u22 > 0.5 ? c22 / (2 - l22 - a22) : c22 / (l22 + a22);
          let p22 = 0;
          return l22 === i22 ? p22 = (s2 - o2) / c22 + (s2 < o2 ? 6 : 0) : l22 === s2 ? p22 = (o2 - i22) / c22 + 2 : l22 === o2 && (p22 = (i22 - s2) / c22 + 4), p22 *= 60, [Math.min(Math.max(p22, 0), 360), Math.min(Math.max(100 * h22, 0), 100), Math.min(Math.max(100 * u22, 0), 100), n22];
        }
        toArray01() {
          const { r: t22, g: e22, b: r22, a: n22 } = this;
          return 0 === n22 ? [0, 0, 0, 0] : [t22 / n22, e22 / n22, r22 / n22, n22];
        }
        toArray01Scaled(t22) {
          const { r: e22, g: r22, b: n22, a: i22 } = this;
          return 0 === i22 ? [0, 0, 0] : [e22 / i22 * t22, r22 / i22 * t22, n22 / i22 * t22];
        }
        toArray01PremultipliedAlpha() {
          const { r: t22, g: e22, b: r22, a: n22 } = this;
          return [t22, e22, r22, n22];
        }
        toArray01Linear() {
          const { r: t22, g: e22, b: r22, a: n22 } = this;
          return 0 === n22 ? [0, 0, 0, 0] : [Math.pow(t22 / n22, 2.2), Math.pow(e22 / n22, 2.2), Math.pow(r22 / n22, 2.2), n22];
        }
      }
      function or(t22, e22, r22) {
        return t22 * (1 - r22) + e22 * r22;
      }
      function ar(t22, e22, r22) {
        return t22.map((t3, n22) => or(t3, e22[n22], r22));
      }
      function lr(t22) {
        return t22 * t22 * t22 * t22 * t22;
      }
      ir.black = new ir(0, 0, 0, 1), ir.white = new ir(1, 1, 1, 1), ir.transparent = new ir(0, 0, 0, 0), ir.red = new ir(1, 0, 0, 1), ir.blue = new ir(0, 0, 1, 1);
      var ur = Object.freeze({ __proto__: null, array: ar, color: function(t22, e22, r22) {
        return new ir(or(t22.r, e22.r, r22), or(t22.g, e22.g, r22), or(t22.b, e22.b, r22), or(t22.a, e22.a, r22));
      }, easeIn: lr, number: or });
      function cr(t22, ...e22) {
        for (const r22 of e22) for (const e3 in r22) t22[e3] = r22[e3];
        return t22;
      }
      class hr extends Error {
        constructor(t22, e22) {
          super(e22), this.message = e22, this.key = t22;
        }
      }
      class pr {
        constructor(t22, e22 = []) {
          this.parent = t22, this.bindings = {};
          for (const [t3, r22] of e22) this.bindings[t3] = r22;
        }
        concat(t22) {
          return new pr(this, t22);
        }
        get(t22) {
          if (this.bindings[t22]) return this.bindings[t22];
          if (this.parent) return this.parent.get(t22);
          throw new Error(`${t22} not found in scope.`);
        }
        has(t22) {
          return !!this.bindings[t22] || !!this.parent && this.parent.has(t22);
        }
      }
      const fr = { kind: "null" }, dr = { kind: "number" }, mr = { kind: "string" }, yr = { kind: "boolean" }, gr = { kind: "color" }, xr = { kind: "object" }, vr = { kind: "value" }, br = { kind: "collator" }, _r = { kind: "formatted" }, wr = { kind: "resolvedImage" };
      function Ar(t22, e22) {
        return { kind: "array", itemType: t22, N: e22 };
      }
      function Mr(t22) {
        if ("array" === t22.kind) {
          const e22 = Mr(t22.itemType);
          return "number" == typeof t22.N ? `array<${e22}, ${t22.N}>` : "value" === t22.itemType.kind ? "array" : `array<${e22}>`;
        }
        return t22.kind;
      }
      const Ir = [fr, dr, mr, yr, gr, _r, xr, Ar(vr), wr];
      function Sr(t22, e22) {
        if ("error" === e22.kind) return null;
        if ("array" === t22.kind) {
          if ("array" === e22.kind && (0 === e22.N && "value" === e22.itemType.kind || !Sr(t22.itemType, e22.itemType)) && ("number" != typeof t22.N || t22.N === e22.N)) return null;
        } else {
          if (t22.kind === e22.kind) return null;
          if ("value" === t22.kind) {
            for (const t3 of Ir) if (!Sr(t3, e22)) return null;
          }
        }
        return `Expected ${Mr(t22)} but found ${Mr(e22)} instead.`;
      }
      function zr(t22, e22) {
        return e22.some((e3) => e3.kind === t22.kind);
      }
      function kr(t22, e22) {
        return e22.some((e3) => "null" === e3 ? null === t22 : "array" === e3 ? Array.isArray(t22) : "object" === e3 ? t22 && !Array.isArray(t22) && "object" == typeof t22 : e3 === typeof t22);
      }
      class Er {
        constructor(t22, e22, r22) {
          this.sensitivity = t22 ? e22 ? "variant" : "case" : e22 ? "accent" : "base", this.locale = r22, this.collator = new Intl.Collator(this.locale ? this.locale : [], { sensitivity: this.sensitivity, usage: "search" });
        }
        compare(t22, e22) {
          return this.collator.compare(t22, e22);
        }
        resolvedLocale() {
          return new Intl.Collator(this.locale ? this.locale : []).resolvedOptions().locale;
        }
      }
      class Pr {
        constructor(t22, e22, r22, n22, i22) {
          this.text = t22.normalize ? t22.normalize() : t22, this.image = e22, this.scale = r22, this.fontStack = n22, this.textColor = i22;
        }
      }
      class Tr {
        constructor(t22) {
          this.sections = t22;
        }
        static fromString(t22) {
          return new Tr([new Pr(t22, null, null, null, null)]);
        }
        isEmpty() {
          return 0 === this.sections.length || !this.sections.some((t22) => 0 !== t22.text.length || !!t22.image && t22.image.hasPrimary());
        }
        static factory(t22) {
          return t22 instanceof Tr ? t22 : Tr.fromString(t22);
        }
        toString() {
          return 0 === this.sections.length ? "" : this.sections.map((t22) => t22.text).join("");
        }
        serialize() {
          const t22 = ["format"];
          for (const e22 of this.sections) {
            if (e22.image) {
              const r3 = e22.image.getPrimary().id.toString();
              t22.push(["image", r3]);
              continue;
            }
            t22.push(e22.text);
            const r22 = {};
            e22.fontStack && (r22["text-font"] = ["literal", e22.fontStack.split(",")]), e22.scale && (r22["font-scale"] = e22.scale), e22.textColor && (r22["text-color"] = ["rgba"].concat(e22.textColor.toRenderColor(null).toArray())), t22.push(r22);
          }
          return t22;
        }
      }
      class Br {
        constructor(t22, e22 = {}) {
          if (this.id = tr.from(t22), this.options = Object.assign({}, e22), e22.transform) {
            const { a: t3, b: r22, c: n22, d: i22, e: s2, f: o2 } = e22.transform;
            this.options.transform = new DOMMatrix([t3, r22, n22, i22, s2, o2]);
          } else this.options.transform = new DOMMatrix([1, 0, 0, 1, 0, 0]);
        }
        toString() {
          const { a: t22, b: e22, c: r22, d: n22, e: i22, f: s2 } = this.options.transform;
          return JSON.stringify({ name: this.id.name, iconsetId: this.id.iconsetId, params: this.options.params, transform: { a: t22, b: e22, c: r22, d: n22, e: i22, f: s2 } });
        }
        static parse(t22) {
          let e22, r22, n22, i22;
          try {
            ({ name: e22, iconsetId: r22, params: n22, transform: i22 } = JSON.parse(t22) || {});
          } catch (t3) {
            return null;
          }
          if (!e22) return null;
          const { a: s2, b: o2, c: a22, d: l22, e: u22, f: c22 } = i22 || {};
          return new Br({ name: e22, iconsetId: r22 }, { params: n22, transform: new DOMMatrix([s2, o2, a22, l22, u22, c22]) });
        }
        scaleSelf(t22, e22) {
          return this.options.transform.scaleSelf(t22, e22), this;
        }
      }
      class Vr {
        constructor(t22, e22, r22, n22, i22 = false) {
          this.primaryId = tr.from(t22), this.primaryOptions = e22, r22 && (this.secondaryId = tr.from(r22)), this.secondaryOptions = n22, this.available = i22;
        }
        toString() {
          return this.primaryId && this.secondaryId ? `[${this.primaryId.name},${this.secondaryId.name}]` : this.primaryId.name;
        }
        hasPrimary() {
          return !!this.primaryId;
        }
        getPrimary() {
          return new Br(this.primaryId, this.primaryOptions);
        }
        hasSecondary() {
          return !!this.secondaryId;
        }
        getSecondary() {
          return this.secondaryId ? new Br(this.secondaryId, this.secondaryOptions) : null;
        }
        static from(t22) {
          return "string" == typeof t22 ? Vr.build({ name: t22 }) : t22;
        }
        static build(t22, e22, r22, n22) {
          return !t22 || "object" == typeof t22 && !("name" in t22) ? null : new Vr(t22, r22, e22, n22);
        }
      }
      function Cr(t22, e22, r22, n22) {
        return "number" == typeof t22 && t22 >= 0 && t22 <= 255 && "number" == typeof e22 && e22 >= 0 && e22 <= 255 && "number" == typeof r22 && r22 >= 0 && r22 <= 255 ? void 0 === n22 || "number" == typeof n22 && n22 >= 0 && n22 <= 1 ? null : `Invalid rgba value [${[t22, e22, r22, n22].join(", ")}]: 'a' must be between 0 and 1.` : `Invalid rgba value [${("number" == typeof n22 ? [t22, e22, r22, n22] : [t22, e22, r22]).join(", ")}]: 'r', 'g', and 'b' must be between 0 and 255.`;
      }
      function Dr(t22) {
        if (null === t22) return true;
        if ("string" == typeof t22) return true;
        if ("boolean" == typeof t22) return true;
        if ("number" == typeof t22) return true;
        if (t22 instanceof ir) return true;
        if (t22 instanceof Er) return true;
        if (t22 instanceof Tr) return true;
        if (t22 instanceof Vr) return true;
        if (Array.isArray(t22)) {
          for (const e22 of t22) if (!Dr(e22)) return false;
          return true;
        }
        if ("object" == typeof t22) {
          for (const e22 in t22) if (!Dr(t22[e22])) return false;
          return true;
        }
        return false;
      }
      function Fr(t22) {
        if (null === t22) return fr;
        if ("string" == typeof t22) return mr;
        if ("boolean" == typeof t22) return yr;
        if ("number" == typeof t22) return dr;
        if (t22 instanceof ir) return gr;
        if (t22 instanceof Er) return br;
        if (t22 instanceof Tr) return _r;
        if (t22 instanceof Vr) return wr;
        if (Array.isArray(t22)) {
          const e22 = t22.length;
          let r22;
          for (const e3 of t22) {
            const t3 = Fr(e3);
            if (r22) {
              if (r22 === t3) continue;
              r22 = vr;
              break;
            }
            r22 = t3;
          }
          return Ar(r22 || vr, e22);
        }
        return xr;
      }
      function Lr(t22) {
        const e22 = typeof t22;
        return null === t22 ? "" : "string" === e22 || "number" === e22 || "boolean" === e22 ? String(t22) : t22 instanceof ir ? t22.toStringPremultipliedAlpha() : t22 instanceof Tr || t22 instanceof Vr ? t22.toString() : JSON.stringify(t22);
      }
      class Rr {
        constructor(t22, e22) {
          this.type = t22, this.value = e22;
        }
        static parse(t22, e22) {
          if (2 !== t22.length) return e22.error(`'literal' expression requires exactly one argument, but found ${t22.length - 1} instead.`);
          if (!Dr(t22[1])) return e22.error("invalid value");
          const r22 = t22[1];
          let n22 = Fr(r22);
          const i22 = e22.expectedType;
          return "array" !== n22.kind || 0 !== n22.N || !i22 || "array" !== i22.kind || "number" == typeof i22.N && 0 !== i22.N || (n22 = i22), new Rr(n22, r22);
        }
        evaluate() {
          return this.value;
        }
        eachChild() {
        }
        outputDefined() {
          return true;
        }
        serialize() {
          return "array" === this.type.kind || "object" === this.type.kind ? ["literal", this.value] : this.value instanceof ir ? ["rgba"].concat(this.value.toRenderColor(null).toArray()) : this.value instanceof Tr ? this.value.serialize() : this.value;
        }
      }
      class Or {
        constructor(t22) {
          this.name = "ExpressionEvaluationError", this.message = t22;
        }
        toJSON() {
          return this.message;
        }
      }
      const Ur = { string: mr, number: dr, boolean: yr, object: xr };
      class Nr {
        constructor(t22, e22) {
          this.type = t22, this.args = e22;
        }
        static parse(t22, e22) {
          if (t22.length < 2) return e22.error("Expected at least one argument.");
          let r22, n22 = 1;
          const i22 = t22[0];
          if ("array" === i22) {
            let i3, s3;
            if (t22.length > 2) {
              const r3 = t22[1];
              if ("string" != typeof r3 || !(r3 in Ur) || "object" === r3) return e22.error('The item type argument of "array" must be one of string, number, boolean', 1);
              i3 = Ur[r3], n22++;
            } else i3 = vr;
            if (t22.length > 3) {
              if (null !== t22[2] && ("number" != typeof t22[2] || t22[2] < 0 || t22[2] !== Math.floor(t22[2]))) return e22.error('The length argument to "array" must be a positive integer literal', 2);
              s3 = t22[2], n22++;
            }
            r22 = Ar(i3, s3);
          } else r22 = Ur[i22];
          const s2 = [];
          for (; n22 < t22.length; n22++) {
            const r3 = e22.parse(t22[n22], n22, vr);
            if (!r3) return null;
            s2.push(r3);
          }
          return new Nr(r22, s2);
        }
        evaluate(t22) {
          for (let e22 = 0; e22 < this.args.length; e22++) {
            const r22 = this.args[e22].evaluate(t22);
            if (!Sr(this.type, Fr(r22))) return r22;
            if (e22 === this.args.length - 1) throw new Or(`The expression ${JSON.stringify(this.args[e22].serialize())} evaluated to ${Mr(Fr(r22))} but was expected to be of type ${Mr(this.type)}.`);
          }
          return null;
        }
        eachChild(t22) {
          this.args.forEach(t22);
        }
        outputDefined() {
          return this.args.every((t22) => t22.outputDefined());
        }
        serialize() {
          const t22 = this.type, e22 = [t22.kind];
          if ("array" === t22.kind) {
            const r22 = t22.itemType;
            if ("string" === r22.kind || "number" === r22.kind || "boolean" === r22.kind) {
              e22.push(r22.kind);
              const n22 = t22.N;
              ("number" == typeof n22 || this.args.length > 1) && e22.push(n22);
            }
          }
          return e22.concat(this.args.map((t3) => t3.serialize()));
        }
      }
      class jr {
        constructor(t22) {
          this.type = _r, this.sections = t22;
        }
        static parse(t22, e22) {
          if (t22.length < 2) return e22.error("Expected at least one argument.");
          const r22 = t22[1];
          if (!Array.isArray(r22) && "object" == typeof r22) return e22.error("First argument must be an image or text section.");
          const n22 = [];
          let i22 = false;
          for (let r3 = 1; r3 <= t22.length - 1; ++r3) {
            const s2 = t22[r3];
            if (i22 && "object" == typeof s2 && !Array.isArray(s2)) {
              i22 = false;
              let t3 = null;
              if (s2["font-scale"] && (t3 = e22.parseObjectValue(s2["font-scale"], r3, "font-scale", dr), !t3)) return null;
              let o2 = null;
              if (s2["text-font"] && (o2 = e22.parseObjectValue(s2["text-font"], r3, "text-font", Ar(mr)), !o2)) return null;
              let a22 = null;
              if (s2["text-color"] && (a22 = e22.parseObjectValue(s2["text-color"], r3, "text-color", gr), !a22)) return null;
              const l22 = n22[n22.length - 1];
              l22.scale = t3, l22.font = o2, l22.textColor = a22;
            } else {
              const s3 = e22.parse(t22[r3], r3, vr);
              if (!s3) return null;
              const o2 = s3.type.kind;
              if ("string" !== o2 && "value" !== o2 && "null" !== o2 && "resolvedImage" !== o2) return e22.error("Formatted text type must be 'string', 'value', 'image' or 'null'.");
              i22 = true, n22.push({ content: s3, scale: null, font: null, textColor: null });
            }
          }
          return new jr(n22);
        }
        evaluate(t22) {
          return new Tr(this.sections.map((e22) => {
            const r22 = e22.content.evaluate(t22);
            return Fr(r22) === wr ? new Pr("", r22, null, null, null) : new Pr(Lr(r22), null, e22.scale ? e22.scale.evaluate(t22) : null, e22.font ? e22.font.evaluate(t22).join(",") : null, e22.textColor ? e22.textColor.evaluate(t22) : null);
          }));
        }
        eachChild(t22) {
          for (const e22 of this.sections) t22(e22.content), e22.scale && t22(e22.scale), e22.font && t22(e22.font), e22.textColor && t22(e22.textColor);
        }
        outputDefined() {
          return false;
        }
        serialize() {
          const t22 = ["format"];
          for (const e22 of this.sections) {
            t22.push(e22.content.serialize());
            const r22 = {};
            e22.scale && (r22["font-scale"] = e22.scale.serialize()), e22.font && (r22["text-font"] = e22.font.serialize()), e22.textColor && (r22["text-color"] = e22.textColor.serialize()), t22.push(r22);
          }
          return t22;
        }
      }
      class $r {
        constructor(t22, e22, r22, n22) {
          this._imageWarnHistory = {}, this.type = wr, this.namePrimary = t22, this.nameSecondary = e22, r22 && (this.paramsPrimary = r22.params, this.iconsetIdPrimary = r22.iconset ? r22.iconset.id : void 0), n22 && (this.paramsSecondary = n22.params, this.iconsetIdSecondary = n22.iconset ? n22.iconset.id : void 0);
        }
        static parse(t22, e22) {
          if (t22.length < 2) return e22.error("Expected two or more arguments.");
          let r22 = 1;
          const n22 = [];
          function i22() {
            if (r22 < t22.length) {
              const i3 = e22.parse(t22[r22], r22++, mr);
              return i3 ? (n22.push({ image: i3, options: {} }), true) : (e22.error(n22.length ? "Secondary image variant is not a string." : "No image name provided."), false);
            }
            return true;
          }
          function s2() {
            if (r22 < t22.length) {
              const s3 = t22[r22];
              if (null === (i3 = s3) || "object" != typeof i3 || Array.isArray(i3)) return true;
              const o2 = s3.params, a22 = s3.iconset, l22 = e22.concat(r22);
              if (!o2 && !a22) return r22++, true;
              if (o2) {
                if ("object" != typeof o2 || o2.constructor !== Object) return l22.error('Image options "params" should be an object'), false;
                const t3 = {}, e3 = l22.concat(void 0, "params");
                for (const r3 in o2) {
                  if (!r3) return e3.error("Image parameter name should be non-empty"), false;
                  const n3 = e3.concat(void 0, r3).parse(o2[r3], void 0, gr, void 0, { typeAnnotation: "coerce" });
                  if (!n3) return false;
                  t3[r3] = n3;
                }
                n22[n22.length - 1].options.params = t3;
              }
              if (a22) {
                if ("object" != typeof a22 || a22.constructor !== Object) return l22.error('Image options "iconset" should be an object'), false;
                if (!a22.id) return l22.error('Image options "iconset" should have an "id" property'), false;
                n22[n22.length - 1].options.iconset = a22;
              }
              return r22++, true;
            }
            var i3;
            return true;
          }
          for (let t3 = 0; t3 < 2; t3++) if (!i22() || !s2()) return;
          return new $r(n22[0].image, n22[1] ? n22[1].image : void 0, n22[0].options, n22[1] ? n22[1].options : void 0);
        }
        evaluateParams(t22, e22) {
          const r22 = {};
          if (e22) {
            for (const n22 in e22) if (e22[n22]) try {
              r22[n22] = e22[n22].evaluate(t22);
            } catch (t3) {
              continue;
            }
            if (0 !== Object.keys(r22).length) return { params: r22 };
          }
        }
        evaluate(t22) {
          const e22 = { name: this.namePrimary.evaluate(t22), iconsetId: this.iconsetIdPrimary }, r22 = this.nameSecondary ? { name: this.nameSecondary.evaluate(t22), iconsetId: this.iconsetIdSecondary } : void 0, n22 = Vr.build(e22, r22, this.paramsPrimary ? this.evaluateParams(t22, this.paramsPrimary) : void 0, this.paramsSecondary ? this.evaluateParams(t22, this.paramsSecondary) : void 0);
          if (n22 && t22.availableImages) {
            const e3 = n22.getPrimary().id;
            if (n22.available = t22.availableImages.some((t3) => tr.isEqual(t3, e3)), n22.available) {
              const e4 = n22.getSecondary() ? n22.getSecondary().id : null;
              e4 && (n22.available = t22.availableImages.some((t3) => tr.isEqual(t3, e4)));
            }
          }
          return n22;
        }
        eachChild(t22) {
          if (t22(this.namePrimary), this.paramsPrimary) for (const e22 in this.paramsPrimary) this.paramsPrimary[e22] && t22(this.paramsPrimary[e22]);
          if (this.nameSecondary && (t22(this.nameSecondary), this.paramsSecondary)) for (const e22 in this.paramsSecondary) this.paramsSecondary[e22] && t22(this.paramsSecondary[e22]);
        }
        outputDefined() {
          return false;
        }
        serializeOptions(t22, e22) {
          const r22 = {};
          if (e22 && (r22.iconset = { id: e22 }), t22) {
            r22.params = {};
            for (const e3 in t22) t22[e3] && (r22.params[e3] = t22[e3].serialize());
          }
          return Object.keys(r22).length > 0 ? r22 : void 0;
        }
        serialize() {
          const t22 = ["image", this.namePrimary.serialize()];
          if (this.paramsPrimary || this.iconsetIdPrimary) {
            const e22 = this.serializeOptions(this.paramsPrimary, this.iconsetIdPrimary);
            e22 && t22.push(e22);
          }
          if (this.nameSecondary && (t22.push(this.nameSecondary.serialize()), this.paramsSecondary || this.iconsetIdSecondary)) {
            const e22 = this.serializeOptions(this.paramsSecondary, this.iconsetIdSecondary);
            e22 && t22.push(e22);
          }
          return t22;
        }
      }
      function Gr(t22) {
        return t22 instanceof Number ? "number" : t22 instanceof String ? "string" : t22 instanceof Boolean ? "boolean" : Array.isArray(t22) ? "array" : null === t22 ? "null" : typeof t22;
      }
      const qr = { "to-boolean": yr, "to-color": gr, "to-number": dr, "to-string": mr };
      class Hr {
        constructor(t22, e22) {
          this.type = t22, this.args = e22;
        }
        static parse(t22, e22) {
          if (t22.length < 2) return e22.error("Expected at least one argument.");
          const r22 = t22[0], n22 = [];
          let i22 = fr;
          if ("to-array" === r22) {
            if (!Array.isArray(t22[1])) return null;
            const r3 = t22[1].length;
            if (e22.expectedType) {
              if ("array" !== e22.expectedType.kind) return e22.error(`Expected ${e22.expectedType.kind} but found array.`);
              i22 = Ar(e22.expectedType.itemType, r3);
            } else {
              if (!(r3 > 0 && Dr(t22[1][0]))) return null;
              i22 = Ar(Fr(t22[1][0]), r3);
            }
            for (let s2 = 0; s2 < r3; s2++) {
              const r4 = t22[1][s2];
              let o2;
              if ("array" === Gr(r4)) o2 = e22.parse(r4, void 0, i22.itemType);
              else {
                const t3 = Gr(r4);
                if (t3 !== i22.itemType.kind) return e22.error(`Expected ${i22.itemType.kind} but found ${t3}.`);
                o2 = e22.registry.literal.parse(["literal", void 0 === r4 ? null : r4], e22);
              }
              if (!o2) return null;
              n22.push(o2);
            }
          } else {
            if (("to-boolean" === r22 || "to-string" === r22) && 2 !== t22.length) return e22.error("Expected one argument.");
            i22 = qr[r22];
            for (let r3 = 1; r3 < t22.length; r3++) {
              const i3 = e22.parse(t22[r3], r3, vr);
              if (!i3) return null;
              n22.push(i3);
            }
          }
          return new Hr(i22, n22);
        }
        evaluate(t22) {
          if ("boolean" === this.type.kind) return Boolean(this.args[0].evaluate(t22));
          if ("color" === this.type.kind) {
            let e22, r22;
            for (const n22 of this.args) {
              if (e22 = n22.evaluate(t22), r22 = null, e22 instanceof ir) return e22;
              if ("string" == typeof e22) {
                const r3 = t22.parseColor(e22);
                if (r3) return r3;
              } else if (Array.isArray(e22) && (r22 = e22.length < 3 || e22.length > 4 ? `Invalid rbga value ${JSON.stringify(e22)}: expected an array containing either three or four numeric values.` : Cr(e22[0], e22[1], e22[2], e22[3]), !r22)) return new ir(e22[0] / 255, e22[1] / 255, e22[2] / 255, e22[3]);
            }
            throw new Or(r22 || `Could not parse color from value '${"string" == typeof e22 ? e22 : String(JSON.stringify(e22))}'`);
          }
          if ("number" === this.type.kind) {
            let e22 = null;
            for (const r22 of this.args) {
              if (e22 = r22.evaluate(t22), null === e22) return 0;
              const n22 = Number(e22);
              if (!isNaN(n22)) return n22;
            }
            throw new Or(`Could not convert ${JSON.stringify(e22)} to number.`);
          }
          return "formatted" === this.type.kind ? Tr.fromString(Lr(this.args[0].evaluate(t22))) : "resolvedImage" === this.type.kind ? Vr.build(Lr(this.args[0].evaluate(t22))) : "array" === this.type.kind ? this.args.map((e22) => e22.evaluate(t22)) : Lr(this.args[0].evaluate(t22));
        }
        eachChild(t22) {
          this.args.forEach(t22);
        }
        outputDefined() {
          return this.args.every((t22) => t22.outputDefined());
        }
        serialize() {
          if ("formatted" === this.type.kind) return new jr([{ content: this.args[0], scale: null, font: null, textColor: null }]).serialize();
          if ("resolvedImage" === this.type.kind) return new $r(this.args[0]).serialize();
          const t22 = "array" === this.type.kind ? [] : [`to-${this.type.kind}`];
          return this.eachChild((e22) => {
            t22.push(e22.serialize());
          }), t22;
        }
      }
      const Xr = ["Unknown", "Point", "LineString", "Polygon"];
      class Zr {
        constructor(t22, e22) {
          this.globals = null, this.feature = null, this.featureState = null, this.formattedSection = null, this._parseColorCache = {}, this.availableImages = null, this.canonical = null, this.featureTileCoord = null, this.featureDistanceData = null, this.scope = t22, this.options = e22;
        }
        id() {
          return this.feature && void 0 !== this.feature.id ? this.feature.id : null;
        }
        geometryType() {
          return this.feature ? "number" == typeof this.feature.type ? Xr[this.feature.type] : this.feature.type : null;
        }
        geometry() {
          return this.feature && "geometry" in this.feature ? this.feature.geometry : null;
        }
        canonicalID() {
          return this.canonical;
        }
        properties() {
          return this.feature && this.feature.properties || {};
        }
        measureLight(t22) {
          return this.globals.brightness || 0;
        }
        distanceFromCenter() {
          if (this.featureTileCoord && this.featureDistanceData) {
            const t22 = this.featureDistanceData.center, e22 = this.featureDistanceData.scale, { x: r22, y: n22 } = this.featureTileCoord;
            return this.featureDistanceData.bearing[0] * (r22 * e22 - t22[0]) + this.featureDistanceData.bearing[1] * (n22 * e22 - t22[1]);
          }
          return 0;
        }
        parseColor(t22) {
          let e22 = this._parseColorCache[t22];
          return e22 || (e22 = this._parseColorCache[t22] = ir.parse(t22)), e22;
        }
        getConfig(t22) {
          return this.options ? this.options.get(t22) : null;
        }
      }
      class Wr {
        constructor(t22, e22, r22, n22, i22) {
          this.name = t22, this.type = e22, this._evaluate = r22, this.args = n22, this._overloadIndex = i22;
        }
        evaluate(t22) {
          if (!this._evaluate) {
            const t3 = Wr.definitions[this.name];
            this._evaluate = Array.isArray(t3) ? t3[2] : t3.overloads[this._overloadIndex][1];
          }
          return this._evaluate(t22, this.args);
        }
        eachChild(t22) {
          this.args.forEach(t22);
        }
        outputDefined() {
          return false;
        }
        serialize() {
          return [this.name].concat(this.args.map((t22) => t22.serialize()));
        }
        static parse(t22, e22) {
          const r22 = t22[0], n22 = Wr.definitions[r22];
          if (!n22) return e22.error(`Unknown expression "${r22}". If you wanted a literal array, use ["literal", [...]].`, 0);
          const i22 = Array.isArray(n22) ? n22[0] : n22.type, s2 = Array.isArray(n22) ? [[n22[1], n22[2]]] : n22.overloads, o2 = [];
          let a22 = null, l22 = -1;
          for (const [n3, u22] of s2) {
            if (Array.isArray(n3) && n3.length !== t22.length - 1) continue;
            o2.push(n3), l22++, a22 = new gi(e22.registry, e22.path, null, e22.scope, void 0, e22._scope, e22.options);
            const s3 = [];
            let c22 = false;
            for (let e3 = 1; e3 < t22.length; e3++) {
              const r3 = t22[e3], i3 = Array.isArray(n3) ? n3[e3 - 1] : n3.type, o3 = a22.parse(r3, 1 + s3.length, i3);
              if (!o3) {
                c22 = true;
                break;
              }
              s3.push(o3);
            }
            if (!c22) if (Array.isArray(n3) && n3.length !== s3.length) a22.error(`Expected ${n3.length} arguments, but found ${s3.length} instead.`);
            else {
              for (let t3 = 0; t3 < s3.length; t3++) {
                const e3 = Array.isArray(n3) ? n3[t3] : n3.type, r3 = s3[t3];
                a22.concat(t3 + 1).checkSubtype(e3, r3.type);
              }
              if (0 === a22.errors.length) return new Wr(r22, i22, u22, s3, l22);
            }
          }
          if (1 === o2.length) e22.errors.push(...a22.errors);
          else {
            const r3 = (o2.length ? o2 : s2.map(([t3]) => t3)).map(Yr).join(" | "), n3 = [];
            for (let r4 = 1; r4 < t22.length; r4++) {
              const i3 = e22.parse(t22[r4], 1 + n3.length);
              if (!i3) return null;
              n3.push(Mr(i3.type));
            }
            e22.error(`Expected arguments of type ${r3}, but found (${n3.join(", ")}) instead.`);
          }
          return null;
        }
        static register(t22, e22) {
          Wr.definitions = e22;
          for (const r22 in e22) t22[r22] = Wr;
        }
      }
      function Yr(t22) {
        return Array.isArray(t22) ? `(${t22.map(Mr).join(", ")})` : `(${Mr(t22.type)}...)`;
      }
      class Kr {
        constructor(t22, e22, r22) {
          this.type = br, this.locale = r22, this.caseSensitive = t22, this.diacriticSensitive = e22;
        }
        static parse(t22, e22) {
          if (2 !== t22.length) return e22.error("Expected one argument.");
          const r22 = t22[1];
          if ("object" != typeof r22 || Array.isArray(r22)) return e22.error("Collator options argument must be an object.");
          const n22 = void 0 === r22["case-sensitive"] ? e22.parse(false, 1, yr) : e22.parseObjectValue(r22["case-sensitive"], 1, "case-sensitive", yr);
          if (!n22) return null;
          const i22 = void 0 === r22["diacritic-sensitive"] ? e22.parse(false, 1, yr) : e22.parseObjectValue(r22["diacritic-sensitive"], 1, "diacritic-sensitive", yr);
          if (!i22) return null;
          let s2 = null;
          return r22.locale && (s2 = e22.parseObjectValue(r22.locale, 1, "locale", mr), !s2) ? null : new Kr(n22, i22, s2);
        }
        evaluate(t22) {
          return new Er(this.caseSensitive.evaluate(t22), this.diacriticSensitive.evaluate(t22), this.locale ? this.locale.evaluate(t22) : null);
        }
        eachChild(t22) {
          t22(this.caseSensitive), t22(this.diacriticSensitive), this.locale && t22(this.locale);
        }
        outputDefined() {
          return false;
        }
        serialize() {
          const t22 = {};
          return t22["case-sensitive"] = this.caseSensitive.serialize(), t22["diacritic-sensitive"] = this.diacriticSensitive.serialize(), this.locale && (t22.locale = this.locale.serialize()), ["collator", t22];
        }
      }
      function Jr(t22, e22, r22 = 0, n22 = t22.length - 1, i22 = tn) {
        for (; n22 > r22; ) {
          if (n22 - r22 > 600) {
            const s3 = n22 - r22 + 1, o3 = e22 - r22 + 1, a3 = Math.log(s3), l22 = 0.5 * Math.exp(2 * a3 / 3), u22 = 0.5 * Math.sqrt(a3 * l22 * (s3 - l22) / s3) * (o3 - s3 / 2 < 0 ? -1 : 1);
            Jr(t22, e22, Math.max(r22, Math.floor(e22 - o3 * l22 / s3 + u22)), Math.min(n22, Math.floor(e22 + (s3 - o3) * l22 / s3 + u22)), i22);
          }
          const s2 = t22[e22];
          let o2 = r22, a22 = n22;
          for (Qr(t22, r22, e22), i22(t22[n22], s2) > 0 && Qr(t22, r22, n22); o2 < a22; ) {
            for (Qr(t22, o2, a22), o2++, a22--; i22(t22[o2], s2) < 0; ) o2++;
            for (; i22(t22[a22], s2) > 0; ) a22--;
          }
          0 === i22(t22[r22], s2) ? Qr(t22, r22, a22) : (a22++, Qr(t22, a22, n22)), a22 <= e22 && (r22 = a22 + 1), e22 <= a22 && (n22 = a22 - 1);
        }
      }
      function Qr(t22, e22, r22) {
        const n22 = t22[e22];
        t22[e22] = t22[r22], t22[r22] = n22;
      }
      function tn(t22, e22) {
        return t22 < e22 ? -1 : t22 > e22 ? 1 : 0;
      }
      function en2(t22) {
        let e22 = 0;
        for (let r22, n22, i22 = 0, s2 = t22.length, o2 = s2 - 1; i22 < s2; o2 = i22++) r22 = t22[i22], n22 = t22[o2], e22 += (n22.x - r22.x) * (r22.y + n22.y);
        return e22;
      }
      function rn(t22, e22) {
        t22[0] = Math.min(t22[0], e22[0]), t22[1] = Math.min(t22[1], e22[1]), t22[2] = Math.max(t22[2], e22[0]), t22[3] = Math.max(t22[3], e22[1]);
      }
      function nn(t22, e22) {
        return !(t22[0] <= e22[0] || t22[2] >= e22[2] || t22[1] <= e22[1] || t22[3] >= e22[3]);
      }
      function sn(t22, e22, r22) {
        const n22 = t22[0] - e22[0], i22 = t22[1] - e22[1], s2 = t22[0] - r22[0], o2 = t22[1] - r22[1];
        return n22 * o2 - s2 * i22 == 0 && n22 * s2 <= 0 && i22 * o2 <= 0;
      }
      function on(t22, e22, r22 = false) {
        let n22 = false;
        for (let a22 = 0, l22 = e22.length; a22 < l22; a22++) {
          const l3 = e22[a22];
          for (let e3 = 0, a3 = l3.length, u22 = a3 - 1; e3 < a3; u22 = e3++) {
            const a4 = l3[u22], c22 = l3[e3];
            if (sn(t22, a4, c22)) return r22;
            (s2 = a4)[1] > (i22 = t22)[1] != (o2 = c22)[1] > i22[1] && i22[0] < (o2[0] - s2[0]) * (i22[1] - s2[1]) / (o2[1] - s2[1]) + s2[0] && (n22 = !n22);
          }
        }
        var i22, s2, o2;
        return n22;
      }
      function an(t22, e22, r22, n22) {
        const i22 = n22[0] - r22[0], s2 = n22[1] - r22[1], o2 = (t22[0] - r22[0]) * s2 - i22 * (t22[1] - r22[1]), a22 = (e22[0] - r22[0]) * s2 - i22 * (e22[1] - r22[1]);
        return o2 > 0 && a22 < 0 || o2 < 0 && a22 > 0;
      }
      function ln(t22, e22, r22, n22) {
        return 0 != (i22 = [n22[0] - r22[0], n22[1] - r22[1]])[0] * (s2 = [e22[0] - t22[0], e22[1] - t22[1]])[1] - i22[1] * s2[0] && !(!an(t22, e22, r22, n22) || !an(r22, n22, t22, e22));
        var i22, s2;
      }
      function un(t22) {
        const e22 = new bt(Number.POSITIVE_INFINITY, Number.POSITIVE_INFINITY), r22 = new bt(Number.NEGATIVE_INFINITY, Number.NEGATIVE_INFINITY);
        for (const n22 of t22[0]) e22.x > n22.x && (e22.x = n22.x), e22.y > n22.y && (e22.y = n22.y), r22.x < n22.x && (r22.x = n22.x), r22.y < n22.y && (r22.y = n22.y);
        return { min: e22, max: r22 };
      }
      const cn2 = 8192;
      function hn(t22, e22) {
        const r22 = (180 + t22[0]) / 360, n22 = (180 - 180 / Math.PI * Math.log(Math.tan(Math.PI / 4 + t22[1] * Math.PI / 360))) / 360, i22 = Math.pow(2, e22.z);
        return [Math.round(r22 * i22 * cn2), Math.round(n22 * i22 * cn2)];
      }
      function pn(t22, e22) {
        for (let r22 = 0; r22 < e22.length; r22++) if (on(t22, e22[r22])) return true;
        return false;
      }
      function fn(t22, e22, r22) {
        for (const n22 of r22) for (let r3 = 0, i22 = n22.length, s2 = i22 - 1; r3 < i22; s2 = r3++) if (ln(t22, e22, n22[s2], n22[r3])) return true;
        return false;
      }
      function dn(t22, e22) {
        for (let r22 = 0; r22 < t22.length; ++r22) if (!on(t22[r22], e22)) return false;
        for (let r22 = 0; r22 < t22.length - 1; ++r22) if (fn(t22[r22], t22[r22 + 1], e22)) return false;
        return true;
      }
      function mn(t22, e22) {
        for (let r22 = 0; r22 < e22.length; r22++) if (dn(t22, e22[r22])) return true;
        return false;
      }
      function yn(t22, e22, r22) {
        const n22 = [];
        for (let i22 = 0; i22 < t22.length; i22++) {
          const s2 = [];
          for (let n3 = 0; n3 < t22[i22].length; n3++) {
            const o2 = hn(t22[i22][n3], r22);
            rn(e22, o2), s2.push(o2);
          }
          n22.push(s2);
        }
        return n22;
      }
      function gn(t22, e22, r22) {
        const n22 = [];
        for (let i22 = 0; i22 < t22.length; i22++) {
          const s2 = yn(t22[i22], e22, r22);
          n22.push(s2);
        }
        return n22;
      }
      function xn(t22, e22, r22, n22) {
        if (t22[0] < r22[0] || t22[0] > r22[2]) {
          const e3 = 0.5 * n22;
          let i22 = t22[0] - r22[0] > e3 ? -n22 : r22[0] - t22[0] > e3 ? n22 : 0;
          0 === i22 && (i22 = t22[0] - r22[2] > e3 ? -n22 : r22[2] - t22[0] > e3 ? n22 : 0), t22[0] += i22;
        }
        rn(e22, t22);
      }
      function vn(t22, e22, r22, n22) {
        const i22 = Math.pow(2, n22.z) * cn2, s2 = [n22.x * cn2, n22.y * cn2], o2 = [];
        if (!t22) return o2;
        for (const n3 of t22) for (const t3 of n3) {
          const n4 = [t3.x + s2[0], t3.y + s2[1]];
          xn(n4, e22, r22, i22), o2.push(n4);
        }
        return o2;
      }
      function bn(t22, e22, r22, n22) {
        const i22 = Math.pow(2, n22.z) * cn2, s2 = [n22.x * cn2, n22.y * cn2], o2 = [];
        if (!t22) return o2;
        for (const r3 of t22) {
          const t3 = [];
          for (const n3 of r3) {
            const r4 = [n3.x + s2[0], n3.y + s2[1]];
            rn(e22, r4), t3.push(r4);
          }
          o2.push(t3);
        }
        if (e22[2] - e22[0] <= i22 / 2) {
          (a22 = e22)[0] = a22[1] = 1 / 0, a22[2] = a22[3] = -1 / 0;
          for (const t3 of o2) for (const n3 of t3) xn(n3, e22, r22, i22);
        }
        var a22;
        return o2;
      }
      class _n {
        constructor(t22, e22) {
          this.type = yr, this.geojson = t22, this.geometries = e22;
        }
        static parse(t22, e22) {
          if (2 !== t22.length) return e22.error(`'within' expression requires exactly one argument, but found ${t22.length - 1} instead.`);
          if (Dr(t22[1])) {
            const e3 = t22[1];
            if ("FeatureCollection" === e3.type) for (let t3 = 0; t3 < e3.features.length; ++t3) {
              const r22 = e3.features[t3].geometry.type;
              if ("Polygon" === r22 || "MultiPolygon" === r22) return new _n(e3, e3.features[t3].geometry);
            }
            else if ("Feature" === e3.type) {
              const t3 = e3.geometry.type;
              if ("Polygon" === t3 || "MultiPolygon" === t3) return new _n(e3, e3.geometry);
            } else if ("Polygon" === e3.type || "MultiPolygon" === e3.type) return new _n(e3, e3);
          }
          return e22.error("'within' expression requires valid geojson object that contains polygon geometry type.");
        }
        evaluate(t22) {
          if (null != t22.geometry() && null != t22.canonicalID()) {
            if ("Point" === t22.geometryType()) return function(t3, e22) {
              const r22 = [1 / 0, 1 / 0, -1 / 0, -1 / 0], n22 = [1 / 0, 1 / 0, -1 / 0, -1 / 0], i22 = t3.canonicalID();
              if (!i22) return false;
              if ("Polygon" === e22.type) {
                const s2 = yn(e22.coordinates, n22, i22), o2 = vn(t3.geometry(), r22, n22, i22);
                if (!nn(r22, n22)) return false;
                for (const t4 of o2) if (!on(t4, s2)) return false;
              }
              if ("MultiPolygon" === e22.type) {
                const s2 = gn(e22.coordinates, n22, i22), o2 = vn(t3.geometry(), r22, n22, i22);
                if (!nn(r22, n22)) return false;
                for (const t4 of o2) if (!pn(t4, s2)) return false;
              }
              return true;
            }(t22, this.geometries);
            if ("LineString" === t22.geometryType()) return function(t3, e22) {
              const r22 = [1 / 0, 1 / 0, -1 / 0, -1 / 0], n22 = [1 / 0, 1 / 0, -1 / 0, -1 / 0], i22 = t3.canonicalID();
              if (!i22) return false;
              if ("Polygon" === e22.type) {
                const s2 = yn(e22.coordinates, n22, i22), o2 = bn(t3.geometry(), r22, n22, i22);
                if (!nn(r22, n22)) return false;
                for (const t4 of o2) if (!dn(t4, s2)) return false;
              }
              if ("MultiPolygon" === e22.type) {
                const s2 = gn(e22.coordinates, n22, i22), o2 = bn(t3.geometry(), r22, n22, i22);
                if (!nn(r22, n22)) return false;
                for (const t4 of o2) if (!mn(t4, s2)) return false;
              }
              return true;
            }(t22, this.geometries);
          }
          return false;
        }
        eachChild() {
        }
        outputDefined() {
          return true;
        }
        serialize() {
          return ["within", this.geojson];
        }
      }
      const wn = { kilometers: 1, miles: 1e3 / 1609.344, nauticalmiles: 1e3 / 1852, meters: 1e3, metres: 1e3, yards: 1e3 / 0.9144, feet: 1e3 / 0.3048, inches: 1e3 / 0.0254 }, An = 1 / 298.257223563, Mn = An * (2 - An), In = Math.PI / 180;
      class Sn {
        static fromTile(t22, e22, r22) {
          const n22 = Math.PI * (1 - 2 * (t22 + 0.5) / Math.pow(2, e22)), i22 = Math.atan(0.5 * (Math.exp(n22) - Math.exp(-n22))) / In;
          return new Sn(i22, r22);
        }
        static get units() {
          return wn;
        }
        constructor(t22, e22) {
          if (void 0 === t22) throw new Error("No latitude given.");
          if (e22 && !wn[e22]) throw new Error(`Unknown unit ${e22}. Use one of: ${Object.keys(wn).join(", ")}`);
          const r22 = 6378.137 * In * (e22 ? wn[e22] : 1), n22 = Math.cos(t22 * In), i22 = 1 / (1 - Mn * (1 - n22 * n22)), s2 = Math.sqrt(i22);
          this.kx = r22 * s2 * n22, this.ky = r22 * s2 * i22 * (1 - Mn);
        }
        distance(t22, e22) {
          const r22 = En(t22[0] - e22[0]) * this.kx, n22 = (t22[1] - e22[1]) * this.ky;
          return Math.sqrt(r22 * r22 + n22 * n22);
        }
        bearing(t22, e22) {
          const r22 = En(e22[0] - t22[0]) * this.kx;
          return Math.atan2(r22, (e22[1] - t22[1]) * this.ky) / In;
        }
        destination(t22, e22, r22) {
          const n22 = r22 * In;
          return this.offset(t22, Math.sin(n22) * e22, Math.cos(n22) * e22);
        }
        offset(t22, e22, r22) {
          return [t22[0] + e22 / this.kx, t22[1] + r22 / this.ky];
        }
        lineDistance(t22) {
          let e22 = 0;
          for (let r22 = 0; r22 < t22.length - 1; r22++) e22 += this.distance(t22[r22], t22[r22 + 1]);
          return e22;
        }
        area(t22) {
          let e22 = 0;
          for (let r22 = 0; r22 < t22.length; r22++) {
            const n22 = t22[r22];
            for (let t3 = 0, i22 = n22.length, s2 = i22 - 1; t3 < i22; s2 = t3++) e22 += En(n22[t3][0] - n22[s2][0]) * (n22[t3][1] + n22[s2][1]) * (r22 ? -1 : 1);
          }
          return Math.abs(e22) / 2 * this.kx * this.ky;
        }
        along(t22, e22) {
          let r22 = 0;
          if (e22 <= 0) return t22[0];
          for (let n22 = 0; n22 < t22.length - 1; n22++) {
            const i22 = t22[n22], s2 = t22[n22 + 1], o2 = this.distance(i22, s2);
            if (r22 += o2, r22 > e22) return kn(i22, s2, (e22 - (r22 - o2)) / o2);
          }
          return t22[t22.length - 1];
        }
        pointToSegmentDistance(t22, e22, r22) {
          let [n22, i22] = e22, s2 = En(r22[0] - n22) * this.kx, o2 = (r22[1] - i22) * this.ky;
          if (0 !== s2 || 0 !== o2) {
            const e3 = (En(t22[0] - n22) * this.kx * s2 + (t22[1] - i22) * this.ky * o2) / (s2 * s2 + o2 * o2);
            e3 > 1 ? (n22 = r22[0], i22 = r22[1]) : e3 > 0 && (n22 += s2 / this.kx * e3, i22 += o2 / this.ky * e3);
          }
          return s2 = En(t22[0] - n22) * this.kx, o2 = (t22[1] - i22) * this.ky, Math.sqrt(s2 * s2 + o2 * o2);
        }
        pointOnLine(t22, e22) {
          let r22 = 1 / 0, n22 = t22[0][0], i22 = t22[0][1], s2 = 0, o2 = 0;
          for (let a22 = 0; a22 < t22.length - 1; a22++) {
            let l22 = t22[a22][0], u22 = t22[a22][1], c22 = En(t22[a22 + 1][0] - l22) * this.kx, h22 = (t22[a22 + 1][1] - u22) * this.ky, p22 = 0;
            0 === c22 && 0 === h22 || (p22 = (En(e22[0] - l22) * this.kx * c22 + (e22[1] - u22) * this.ky * h22) / (c22 * c22 + h22 * h22), p22 > 1 ? (l22 = t22[a22 + 1][0], u22 = t22[a22 + 1][1]) : p22 > 0 && (l22 += c22 / this.kx * p22, u22 += h22 / this.ky * p22)), c22 = En(e22[0] - l22) * this.kx, h22 = (e22[1] - u22) * this.ky;
            const f22 = c22 * c22 + h22 * h22;
            f22 < r22 && (r22 = f22, n22 = l22, i22 = u22, s2 = a22, o2 = p22);
          }
          return { point: [n22, i22], index: s2, t: Math.max(0, Math.min(1, o2)) };
        }
        lineSlice(t22, e22, r22) {
          let n22 = this.pointOnLine(r22, t22), i22 = this.pointOnLine(r22, e22);
          if (n22.index > i22.index || n22.index === i22.index && n22.t > i22.t) {
            const t3 = n22;
            n22 = i22, i22 = t3;
          }
          const s2 = [n22.point], o2 = n22.index + 1, a22 = i22.index;
          !zn(r22[o2], s2[0]) && o2 <= a22 && s2.push(r22[o2]);
          for (let t3 = o2 + 1; t3 <= a22; t3++) s2.push(r22[t3]);
          return zn(r22[a22], i22.point) || s2.push(i22.point), s2;
        }
        lineSliceAlong(t22, e22, r22) {
          let n22 = 0;
          const i22 = [];
          for (let s2 = 0; s2 < r22.length - 1; s2++) {
            const o2 = r22[s2], a22 = r22[s2 + 1], l22 = this.distance(o2, a22);
            if (n22 += l22, n22 > t22 && 0 === i22.length && i22.push(kn(o2, a22, (t22 - (n22 - l22)) / l22)), n22 >= e22) return i22.push(kn(o2, a22, (e22 - (n22 - l22)) / l22)), i22;
            n22 > t22 && i22.push(a22);
          }
          return i22;
        }
        bufferPoint(t22, e22) {
          const r22 = e22 / this.ky, n22 = e22 / this.kx;
          return [t22[0] - n22, t22[1] - r22, t22[0] + n22, t22[1] + r22];
        }
        bufferBBox(t22, e22) {
          const r22 = e22 / this.ky, n22 = e22 / this.kx;
          return [t22[0] - n22, t22[1] - r22, t22[2] + n22, t22[3] + r22];
        }
        insideBBox(t22, e22) {
          return En(t22[0] - e22[0]) >= 0 && En(t22[0] - e22[2]) <= 0 && t22[1] >= e22[1] && t22[1] <= e22[3];
        }
      }
      function zn(t22, e22) {
        return t22[0] === e22[0] && t22[1] === e22[1];
      }
      function kn(t22, e22, r22) {
        const n22 = En(e22[0] - t22[0]);
        return [t22[0] + n22 * r22, t22[1] + (e22[1] - t22[1]) * r22];
      }
      function En(t22) {
        for (; t22 < -180; ) t22 += 360;
        for (; t22 > 180; ) t22 -= 360;
        return t22;
      }
      class Pn {
        constructor(t22 = [], e22 = (t3, e3) => t3 < e3 ? -1 : t3 > e3 ? 1 : 0) {
          if (this.data = t22, this.length = this.data.length, this.compare = e22, this.length > 0) for (let t3 = (this.length >> 1) - 1; t3 >= 0; t3--) this._down(t3);
        }
        push(t22) {
          this.data.push(t22), this._up(this.length++);
        }
        pop() {
          if (0 === this.length) return;
          const t22 = this.data[0], e22 = this.data.pop();
          return --this.length > 0 && (this.data[0] = e22, this._down(0)), t22;
        }
        peek() {
          return this.data[0];
        }
        _up(t22) {
          const { data: e22, compare: r22 } = this, n22 = e22[t22];
          for (; t22 > 0; ) {
            const i22 = t22 - 1 >> 1, s2 = e22[i22];
            if (r22(n22, s2) >= 0) break;
            e22[t22] = s2, t22 = i22;
          }
          e22[t22] = n22;
        }
        _down(t22) {
          const { data: e22, compare: r22 } = this, n22 = this.length >> 1, i22 = e22[t22];
          for (; t22 < n22; ) {
            let n3 = 1 + (t22 << 1);
            const s2 = n3 + 1;
            if (s2 < this.length && r22(e22[s2], e22[n3]) < 0 && (n3 = s2), r22(e22[n3], i22) >= 0) break;
            e22[t22] = e22[n3], t22 = n3;
          }
          e22[t22] = i22;
        }
      }
      var Tn = 8192;
      function Bn(t22, e22) {
        return e22.dist - t22.dist;
      }
      const Vn = 100, Cn = 50;
      function Dn(t22) {
        const e22 = [1 / 0, 1 / 0, -1 / 0, -1 / 0];
        if (e22.length !== t22.length) return false;
        for (let r22 = 0; r22 < e22.length; r22++) if (e22[r22] !== t22[r22]) return false;
        return true;
      }
      function Fn(t22) {
        return t22[1] - t22[0] + 1;
      }
      function Ln(t22, e22) {
        const r22 = t22[1] >= t22[0] && t22[1] < e22;
        return r22 || console.warn("Distance Expression: Index is out of range"), r22;
      }
      function Rn(t22, e22) {
        if (t22[0] > t22[1]) return [null, null];
        const r22 = Fn(t22);
        if (e22) {
          if (2 === r22) return [t22, null];
          const e3 = Math.floor(r22 / 2);
          return [[t22[0], t22[0] + e3], [t22[0] + e3, t22[1]]];
        }
        {
          if (1 === r22) return [t22, null];
          const e3 = Math.floor(r22 / 2) - 1;
          return [[t22[0], t22[0] + e3], [t22[0] + e3 + 1, t22[1]]];
        }
      }
      function On(t22, e22) {
        const r22 = [1 / 0, 1 / 0, -1 / 0, -1 / 0];
        if (!Ln(e22, t22.length)) return r22;
        for (let n22 = e22[0]; n22 <= e22[1]; ++n22) rn(r22, t22[n22]);
        return r22;
      }
      function Un(t22) {
        const e22 = [1 / 0, 1 / 0, -1 / 0, -1 / 0];
        for (let r22 = 0; r22 < t22.length; ++r22) for (let n22 = 0; n22 < t22[r22].length; ++n22) rn(e22, t22[r22][n22]);
        return e22;
      }
      function Nn(t22, e22, r22) {
        if (Dn(t22) || Dn(e22)) return NaN;
        let n22 = 0, i22 = 0;
        return t22[2] < e22[0] && (n22 = e22[0] - t22[2]), t22[0] > e22[2] && (n22 = t22[0] - e22[2]), t22[1] > e22[3] && (i22 = t22[1] - e22[3]), t22[3] < e22[1] && (i22 = e22[1] - t22[3]), r22.distance([0, 0], [n22, i22]);
      }
      function jn(t22) {
        return 360 * t22 - 180;
      }
      function $n(t22) {
        return 360 / Math.PI * Math.atan(Math.exp((180 - 360 * t22) * Math.PI / 180)) - 90;
      }
      function Gn(t22, e22) {
        const r22 = Math.pow(2, e22.z), n22 = (t22.y / Tn + e22.y) / r22;
        return [jn((t22.x / Tn + e22.x) / r22), $n(n22)];
      }
      function qn(t22, e22) {
        const r22 = [];
        for (let n22 = 0; n22 < t22.length; ++n22) r22.push(Gn(t22[n22], e22));
        return r22;
      }
      function Hn(t22, e22, r22) {
        const n22 = r22.pointOnLine(e22, t22).point;
        return r22.distance(t22, n22);
      }
      function Xn(t22, e22, r22, n22, i22) {
        const s2 = r22.slice(n22[0], n22[1] + 1);
        let o2 = 1 / 0;
        for (let r3 = e22[0]; r3 <= e22[1]; ++r3) if (0 === (o2 = Math.min(o2, Hn(t22[r3], s2, i22)))) return 0;
        return o2;
      }
      function Zn(t22, e22, r22, n22, i22) {
        const s2 = Math.min(i22.pointToSegmentDistance(t22, r22, n22), i22.pointToSegmentDistance(e22, r22, n22)), o2 = Math.min(i22.pointToSegmentDistance(r22, t22, e22), i22.pointToSegmentDistance(n22, t22, e22));
        return Math.min(s2, o2);
      }
      function Wn(t22, e22, r22, n22, i22) {
        if (!Ln(e22, t22.length) || !Ln(n22, r22.length)) return NaN;
        let s2 = 1 / 0;
        for (let o2 = e22[0]; o2 < e22[1]; ++o2) for (let e3 = n22[0]; e3 < n22[1]; ++e3) {
          if (ln(t22[o2], t22[o2 + 1], r22[e3], r22[e3 + 1])) return 0;
          s2 = Math.min(s2, Zn(t22[o2], t22[o2 + 1], r22[e3], r22[e3 + 1], i22));
        }
        return s2;
      }
      function Yn(t22, e22, r22, n22, i22) {
        if (!Ln(e22, t22.length) || !Ln(n22, r22.length)) return NaN;
        let s2 = 1 / 0;
        for (let o2 = e22[0]; o2 <= e22[1]; ++o2) for (let e3 = n22[0]; e3 <= n22[1]; ++e3) if (0 === (s2 = Math.min(s2, i22.distance(t22[o2], r22[e3])))) return s2;
        return s2;
      }
      function Kn(t22, e22, r22) {
        if (on(t22, e22, true)) return 0;
        let n22 = 1 / 0;
        for (const i22 of e22) {
          const e3 = i22.length;
          if (e3 < 2) return console.warn("Distance Expression: Invalid polygon!"), NaN;
          if (i22[0] !== i22[e3 - 1] && 0 === (n22 = Math.min(n22, r22.pointToSegmentDistance(t22, i22[e3 - 1], i22[0])))) return n22;
          if (0 === (n22 = Math.min(n22, Hn(t22, i22, r22)))) return n22;
        }
        return n22;
      }
      function Jn(t22, e22, r22, n22) {
        if (!Ln(e22, t22.length)) return NaN;
        for (let n3 = e22[0]; n3 <= e22[1]; ++n3) if (on(t22[n3], r22, true)) return 0;
        let i22 = 1 / 0;
        for (let s2 = e22[0]; s2 < e22[1]; ++s2) for (const e3 of r22) for (let r3 = 0, o2 = e3.length, a22 = o2 - 1; r3 < o2; a22 = r3++) {
          if (ln(t22[s2], t22[s2 + 1], e3[a22], e3[r3])) return 0;
          i22 = Math.min(i22, Zn(t22[s2], t22[s2 + 1], e3[a22], e3[r3], n22));
        }
        return i22;
      }
      function Qn(t22, e22) {
        for (const r22 of t22) for (let t3 = 0; t3 <= r22.length - 1; ++t3) if (on(r22[t3], e22, true)) return true;
        return false;
      }
      function ti(t22, e22, r22, n22 = 1 / 0) {
        const i22 = Un(t22), s2 = Un(e22);
        if (n22 !== 1 / 0 && Nn(i22, s2, r22) >= n22) return n22;
        if (nn(i22, s2)) {
          if (Qn(t22, e22)) return 0;
        } else if (Qn(e22, t22)) return 0;
        let o2 = n22;
        for (const n3 of t22) for (let t3 = 0, i3 = n3.length, s3 = i3 - 1; t3 < i3; s3 = t3++) for (const i4 of e22) for (let e3 = 0, a22 = i4.length, l22 = a22 - 1; e3 < a22; l22 = e3++) {
          if (ln(n3[s3], n3[t3], i4[l22], i4[e3])) return 0;
          o2 = Math.min(o2, Zn(n3[s3], n3[t3], i4[l22], i4[e3], r22));
        }
        return o2;
      }
      function ei(t22, e22, r22, n22, i22, s2, o2) {
        if (null === s2 || null === o2) return;
        const a22 = Nn(On(n22, s2), On(i22, o2), r22);
        a22 < e22 && t22.push({ dist: a22, range1: s2, range2: o2 });
      }
      function ri(t22, e22, r22, n22, i22 = 1 / 0) {
        let s2 = Math.min(n22.distance(t22[0], r22[0][0]), i22);
        if (0 === s2) return s2;
        const o2 = new Pn([{ dist: 0, range1: [0, t22.length - 1], range2: [0, 0] }], Bn), a22 = e22 ? Cn : Vn, l22 = Un(r22);
        for (; o2.length; ) {
          const i3 = o2.pop();
          if (i3.dist >= s2) continue;
          const u22 = i3.range1;
          if (Fn(u22) <= a22) {
            if (!Ln(u22, t22.length)) return NaN;
            if (e22) {
              const e3 = Jn(t22, u22, r22, n22);
              if (0 === (s2 = Math.min(s2, e3))) return s2;
            } else for (let e3 = u22[0]; e3 <= u22[1]; ++e3) {
              const i4 = Kn(t22[e3], r22, n22);
              if (0 === (s2 = Math.min(s2, i4))) return s2;
            }
          } else {
            const r3 = Rn(u22, e22);
            if (null !== r3[0]) {
              const e3 = Nn(On(t22, r3[0]), l22, n22);
              e3 < s2 && o2.push({ dist: e3, range1: r3[0], range2: [0, 0] });
            }
            if (null !== r3[1]) {
              const e3 = Nn(On(t22, r3[1]), l22, n22);
              e3 < s2 && o2.push({ dist: e3, range1: r3[1], range2: [0, 0] });
            }
          }
        }
        return s2;
      }
      function ni(t22, e22, r22, n22, i22, s2 = 1 / 0) {
        let o2 = Math.min(s2, i22.distance(t22[0], r22[0]));
        if (0 === o2) return o2;
        const a22 = new Pn([{ dist: 0, range1: [0, t22.length - 1], range2: [0, r22.length - 1] }], Bn), l22 = e22 ? Cn : Vn, u22 = n22 ? Cn : Vn;
        for (; a22.length; ) {
          const s3 = a22.pop();
          if (s3.dist >= o2) continue;
          const c22 = s3.range1, h22 = s3.range2;
          if (Fn(c22) <= l22 && Fn(h22) <= u22) {
            if (!Ln(c22, t22.length) || !Ln(h22, r22.length)) return NaN;
            if (e22 && n22 ? o2 = Math.min(o2, Wn(t22, c22, r22, h22, i22)) : e22 || n22 ? e22 && !n22 ? o2 = Math.min(o2, Xn(r22, h22, t22, c22, i22)) : !e22 && n22 && (o2 = Math.min(o2, Xn(t22, c22, r22, h22, i22))) : o2 = Math.min(o2, Yn(t22, c22, r22, h22, i22)), 0 === o2) return o2;
          } else {
            const s4 = Rn(c22, e22), l3 = Rn(h22, n22);
            ei(a22, o2, i22, t22, r22, s4[0], l3[0]), ei(a22, o2, i22, t22, r22, s4[0], l3[1]), ei(a22, o2, i22, t22, r22, s4[1], l3[0]), ei(a22, o2, i22, t22, r22, s4[1], l3[1]);
          }
        }
        return o2;
      }
      function ii(t22, e22, r22, n22, i22 = 1 / 0) {
        let s2 = i22;
        const o2 = On(t22, [0, t22.length - 1]);
        for (const i3 of r22) if (!(s2 !== 1 / 0 && Nn(o2, On(i3, [0, i3.length - 1]), n22) >= s2) && (s2 = Math.min(s2, ni(t22, e22, i3, true, n22, s2)), 0 === s2)) return s2;
        return s2;
      }
      function si(t22, e22, r22, n22, i22 = 1 / 0) {
        let s2 = i22;
        const o2 = On(t22, [0, t22.length - 1]);
        for (const i3 of r22) {
          if (s2 !== 1 / 0 && Nn(o2, Un(i3), n22) >= s2) continue;
          const r3 = ri(t22, e22, i3, n22, s2);
          if (isNaN(r3)) return r3;
          if (0 === (s2 = Math.min(s2, r3))) return s2;
        }
        return s2;
      }
      function oi(t22) {
        return "Point" === t22 || "MultiPoint" === t22 || "LineString" === t22 || "MultiLineString" === t22 || "Polygon" === t22 || "MultiPolygon" === t22;
      }
      class ai {
        constructor(t22, e22) {
          this.type = dr, this.geojson = t22, this.geometries = e22;
        }
        static parse(t22, e22) {
          if (2 !== t22.length) return e22.error(`'distance' expression requires either one argument, but found ' ${t22.length - 1} instead.`);
          if (Dr(t22[1])) {
            const e3 = t22[1];
            if ("FeatureCollection" === e3.type) {
              for (let t3 = 0; t3 < e3.features.length; ++t3) if (oi(e3.features[t3].geometry.type)) return new ai(e3, e3.features[t3].geometry);
            } else if ("Feature" === e3.type) {
              if (oi(e3.geometry.type)) return new ai(e3, e3.geometry);
            } else if (oi(e3.type)) return new ai(e3, e3);
          }
          return e22.error("'distance' expression needs to be an array with format ['Distance', GeoJSONObj].");
        }
        evaluate(t22) {
          const e22 = t22.geometry(), r22 = t22.canonicalID();
          if (null != e22 && null != r22) {
            if ("Point" === t22.geometryType()) return function(t3, e3, r3) {
              const n22 = [];
              for (const r4 of t3) for (const t4 of r4) n22.push(Gn(t4, e3));
              const i22 = new Sn(n22[0][1], "meters");
              return "Point" === r3.type || "MultiPoint" === r3.type || "LineString" === r3.type ? ni(n22, false, "Point" === r3.type ? [r3.coordinates] : r3.coordinates, "LineString" === r3.type, i22) : "MultiLineString" === r3.type ? ii(n22, false, r3.coordinates, i22) : "Polygon" === r3.type || "MultiPolygon" === r3.type ? si(n22, false, "Polygon" === r3.type ? [r3.coordinates] : r3.coordinates, i22) : null;
            }(e22, r22, this.geometries);
            if ("LineString" === t22.geometryType()) return function(t3, e3, r3) {
              const n22 = [];
              for (const r4 of t3) {
                const t4 = [];
                for (const n3 of r4) t4.push(Gn(n3, e3));
                n22.push(t4);
              }
              const i22 = new Sn(n22[0][0][1], "meters");
              if ("Point" === r3.type || "MultiPoint" === r3.type || "LineString" === r3.type) return ii("Point" === r3.type ? [r3.coordinates] : r3.coordinates, "LineString" === r3.type, n22, i22);
              if ("MultiLineString" === r3.type) {
                let t4 = 1 / 0;
                for (let e4 = 0; e4 < r3.coordinates.length; e4++) {
                  const s2 = ii(r3.coordinates[e4], true, n22, i22, t4);
                  if (isNaN(s2)) return s2;
                  if (0 === (t4 = Math.min(t4, s2))) return t4;
                }
                return t4;
              }
              if ("Polygon" === r3.type || "MultiPolygon" === r3.type) {
                let t4 = 1 / 0;
                for (let e4 = 0; e4 < n22.length; e4++) {
                  const s2 = si(n22[e4], true, "Polygon" === r3.type ? [r3.coordinates] : r3.coordinates, i22, t4);
                  if (isNaN(s2)) return s2;
                  if (0 === (t4 = Math.min(t4, s2))) return t4;
                }
                return t4;
              }
              return null;
            }(e22, r22, this.geometries);
            if ("Polygon" === t22.geometryType()) return function(t3, e3, r3) {
              const n22 = [];
              for (const r4 of function(t4, e4) {
                const r5 = t4.length;
                if (r5 <= 1) return [t4];
                const n3 = [];
                let i3, s2;
                for (let e5 = 0; e5 < r5; e5++) {
                  const r6 = en2(t4[e5]);
                  0 !== r6 && (t4[e5].area = Math.abs(r6), void 0 === s2 && (s2 = r6 < 0), s2 === r6 < 0 ? (i3 && n3.push(i3), i3 = [t4[e5]]) : i3.push(t4[e5]));
                }
                return i3 && n3.push(i3), n3;
              }(t3)) {
                const t4 = [];
                for (let n3 = 0; n3 < r4.length; ++n3) t4.push(qn(r4[n3], e3));
                n22.push(t4);
              }
              const i22 = new Sn(n22[0][0][0][1], "meters");
              if ("Point" === r3.type || "MultiPoint" === r3.type || "LineString" === r3.type) return si("Point" === r3.type ? [r3.coordinates] : r3.coordinates, "LineString" === r3.type, n22, i22);
              if ("MultiLineString" === r3.type) {
                let t4 = 1 / 0;
                for (let e4 = 0; e4 < r3.coordinates.length; e4++) {
                  const s2 = si(r3.coordinates[e4], true, n22, i22, t4);
                  if (isNaN(s2)) return s2;
                  if (0 === (t4 = Math.min(t4, s2))) return t4;
                }
                return t4;
              }
              return "Polygon" === r3.type || "MultiPolygon" === r3.type ? function(t4, e4, r4) {
                let n3 = 1 / 0;
                for (const i3 of t4) for (const t5 of e4) {
                  const e5 = ti(i3, t5, r4, n3);
                  if (isNaN(e5)) return e5;
                  if (0 === (n3 = Math.min(n3, e5))) return n3;
                }
                return n3;
              }("Polygon" === r3.type ? [r3.coordinates] : r3.coordinates, n22, i22) : null;
            }(e22, r22, this.geometries);
            console.warn("Distance Expression: currently only evaluates valid Point/LineString/Polygon geometries.");
          } else console.warn("Distance Expression: requirs valid feature and canonical information.");
          return null;
        }
        eachChild() {
        }
        outputDefined() {
          return true;
        }
        serialize() {
          return ["distance", this.geojson];
        }
      }
      function li(t22, e22) {
        switch (t22) {
          case "string":
            return Lr(e22);
          case "number":
            return +e22;
          case "boolean":
            return !!e22;
          case "color":
            return ir.parse(e22);
          case "formatted":
            return Tr.fromString(Lr(e22));
          case "resolvedImage":
            return Vr.build(Lr(e22));
        }
        return e22;
      }
      function ui(t22, e22, r22, n22) {
        return void 0 !== n22 && (t22 = n22 * Math.round(t22 / n22)), void 0 !== e22 && t22 < e22 && (t22 = e22), void 0 !== r22 && t22 > r22 && (t22 = r22), t22;
      }
      class ci {
        constructor(t22, e22, r22) {
          this.type = t22, this.key = e22, this.scope = r22;
        }
        static parse(t22, e22) {
          let r22 = e22.expectedType;
          if (null == r22 && (r22 = vr), t22.length < 2 || t22.length > 3) return e22.error("Invalid number of arguments for 'config' expression.");
          const n22 = e22.parse(t22[1], 1);
          if (!(n22 instanceof Rr)) return e22.error("Key name of 'config' expression must be a string literal.");
          if (t22.length >= 3) {
            const i22 = e22.parse(t22[2], 2);
            return i22 instanceof Rr ? new ci(r22, Lr(n22.value), Lr(i22.value)) : e22.error("Scope of 'config' expression must be a string literal.");
          }
          return new ci(r22, Lr(n22.value));
        }
        evaluate(t22) {
          const e22 = [this.key, this.scope, t22.scope].filter(Boolean).join(""), r22 = t22.getConfig(e22);
          if (!r22) return null;
          const { type: n22, value: i22, values: s2, minValue: o2, maxValue: a22, stepValue: l22 } = r22, u22 = r22.default.evaluate(t22);
          let c22 = u22;
          if (i22) {
            const e3 = t22.scope;
            t22.scope = (e3 || "").split("").slice(1).join(""), c22 = i22.evaluate(t22), t22.scope = e3;
          }
          return n22 && (c22 = li(n22, c22)), void 0 === c22 || void 0 === o2 && void 0 === a22 && void 0 === l22 || ("number" == typeof c22 ? c22 = ui(c22, o2, a22, l22) : Array.isArray(c22) && (c22 = c22.map((t3) => "number" == typeof t3 ? ui(t3, o2, a22, l22) : t3))), void 0 !== i22 && void 0 !== c22 && s2 && !s2.includes(c22) && (c22 = u22, n22 && (c22 = li(n22, c22))), (n22 && n22 !== this.type || void 0 !== c22 && Fr(c22) !== this.type) && (c22 = li(this.type.kind, c22)), c22;
        }
        eachChild() {
        }
        outputDefined() {
          return false;
        }
        serialize() {
          const t22 = ["config", this.key];
          return this.scope && t22.concat(this.key), t22;
        }
      }
      function hi(t22) {
        if (t22 instanceof Wr) {
          if ("get" === t22.name && 1 === t22.args.length) return false;
          if ("feature-state" === t22.name) return false;
          if ("has" === t22.name && 1 === t22.args.length) return false;
          if ("properties" === t22.name || "geometry-type" === t22.name || "id" === t22.name) return false;
          if (/^filter-/.test(t22.name)) return false;
        }
        if (t22 instanceof _n) return false;
        if (t22 instanceof ai) return false;
        let e22 = true;
        return t22.eachChild((t3) => {
          e22 && !hi(t3) && (e22 = false);
        }), e22;
      }
      function pi(t22) {
        if (t22 instanceof Wr && "feature-state" === t22.name) return false;
        let e22 = true;
        return t22.eachChild((t3) => {
          e22 && !pi(t3) && (e22 = false);
        }), e22;
      }
      function fi(t22) {
        if (t22 instanceof ci) return /* @__PURE__ */ new Set([t22.key]);
        let e22 = /* @__PURE__ */ new Set();
        return t22.eachChild((t3) => {
          e22 = /* @__PURE__ */ new Set([...e22, ...fi(t3)]);
        }), e22;
      }
      function di(t22, e22) {
        if (t22 instanceof Wr && e22.indexOf(t22.name) >= 0) return false;
        let r22 = true;
        return t22.eachChild((t3) => {
          r22 && !di(t3, e22) && (r22 = false);
        }), r22;
      }
      class mi {
        constructor(t22, e22) {
          this.type = e22.type, this.name = t22, this.boundExpression = e22;
        }
        static parse(t22, e22) {
          if (2 !== t22.length || "string" != typeof t22[1]) return e22.error("'var' expression requires exactly one string literal argument.");
          const r22 = t22[1];
          return e22.scope.has(r22) ? new mi(r22, e22.scope.get(r22)) : e22.error(`Unknown variable "${r22}". Make sure "${r22}" has been bound in an enclosing "let" expression before using it.`, 1);
        }
        evaluate(t22) {
          return this.boundExpression.evaluate(t22);
        }
        eachChild() {
        }
        outputDefined() {
          return false;
        }
        serialize() {
          return ["var", this.name];
        }
      }
      class yi {
        constructor(t22, e22 = [], r22, n22 = new pr(), i22 = [], s2, o2) {
          this.registry = t22, this.path = e22, this.key = e22.map((t3) => "string" == typeof t3 ? `['${t3}']` : `[${t3}]`).join(""), this.scope = n22, this.errors = i22, this.expectedType = r22, this._scope = s2, this.options = o2;
        }
        parse(t22, e22, r22, n22, i22 = {}) {
          return e22 || r22 ? this.concat(e22, null, r22, n22)._parse(t22, i22) : this._parse(t22, i22);
        }
        parseObjectValue(t22, e22, r22, n22, i22, s2 = {}) {
          return this.concat(e22, r22, n22, i22)._parse(t22, s2);
        }
        _parse(t22, e22) {
          function r22(t3, e3, r3) {
            return "assert" === r3 ? new Nr(e3, [t3]) : "coerce" === r3 ? new Hr(e3, [t3]) : t3;
          }
          if (null !== t22 && "string" != typeof t22 && "boolean" != typeof t22 && "number" != typeof t22 || (t22 = ["literal", t22]), Array.isArray(t22)) {
            if (0 === t22.length) return this.error('Expected an array with at least one element. If you wanted a literal array, use ["literal", []].');
            const n22 = "string" == typeof t22[0] ? this.registry[t22[0]] : void 0;
            if (n22) {
              let i22 = n22.parse(t22, this);
              if (!i22) return null;
              if (this.expectedType) {
                const t3 = this.expectedType, n3 = i22.type;
                if ("string" !== t3.kind && "number" !== t3.kind && "boolean" !== t3.kind && "object" !== t3.kind && "array" !== t3.kind || "value" !== n3.kind) if ("color" !== t3.kind && "formatted" !== t3.kind && "resolvedImage" !== t3.kind || "value" !== n3.kind && "string" !== n3.kind) {
                  if (this.checkSubtype(t3, n3)) return null;
                } else i22 = r22(i22, t3, e22.typeAnnotation || "coerce");
                else i22 = r22(i22, t3, e22.typeAnnotation || "assert");
              }
              if (!(i22 instanceof Rr) && "resolvedImage" !== i22.type.kind && xi(i22)) {
                const t3 = new Zr(this._scope, this.options);
                try {
                  i22 = new Rr(i22.type, i22.evaluate(t3));
                } catch (t4) {
                  return this.error(t4.message), null;
                }
              }
              return i22;
            }
            return Hr.parse(["to-array", t22], this);
          }
          return this.error(void 0 === t22 ? "'undefined' value invalid. Use null instead." : "object" == typeof t22 ? 'Bare objects invalid. Use ["literal", {...}] instead.' : `Expected an array, but found ${typeof t22} instead.`);
        }
        concat(t22, e22, r22, n22) {
          let i22 = "number" == typeof t22 ? this.path.concat(t22) : this.path;
          i22 = "string" == typeof e22 ? i22.concat(e22) : i22;
          const s2 = n22 ? this.scope.concat(n22) : this.scope;
          return new yi(this.registry, i22, r22 || null, s2, this.errors, this._scope, this.options);
        }
        error(t22, ...e22) {
          const r22 = `${this.key}${e22.map((t3) => `[${t3}]`).join("")}`;
          this.errors.push(new hr(r22, t22));
        }
        checkSubtype(t22, e22) {
          const r22 = Sr(t22, e22);
          return r22 && this.error(r22), r22;
        }
      }
      var gi = yi;
      function xi(t22) {
        if (t22 instanceof mi) return xi(t22.boundExpression);
        if (t22 instanceof Wr && "error" === t22.name) return false;
        if (t22 instanceof Kr) return false;
        if (t22 instanceof _n) return false;
        if (t22 instanceof ai) return false;
        if (t22 instanceof ci) return false;
        const e22 = t22 instanceof Hr || t22 instanceof Nr;
        let r22 = true;
        return t22.eachChild((t3) => {
          r22 = e22 ? r22 && xi(t3) : r22 && t3 instanceof Rr;
        }), !!r22 && hi(t22) && di(t22, ["zoom", "heatmap-density", "line-progress", "raster-value", "sky-radial-progress", "accumulated", "is-supported-script", "pitch", "distance-from-center", "measure-light", "raster-particle-speed"]);
      }
      function vi(t22, e22) {
        const r22 = t22.length - 1;
        let n22, i22, s2 = 0, o2 = r22, a22 = 0;
        for (; s2 <= o2; ) if (a22 = Math.floor((s2 + o2) / 2), n22 = t22[a22], i22 = t22[a22 + 1], n22 <= e22) {
          if (a22 === r22 || e22 < i22) return a22;
          s2 = a22 + 1;
        } else {
          if (!(n22 > e22)) throw new Or("Input is not a number.");
          o2 = a22 - 1;
        }
        return 0;
      }
      class bi {
        constructor(t22, e22, r22) {
          this.type = t22, this.input = e22, this.labels = [], this.outputs = [];
          for (const [t3, e3] of r22) this.labels.push(t3), this.outputs.push(e3);
        }
        static parse(t22, e22) {
          if (t22.length - 1 < 4) return e22.error(`Expected at least 4 arguments, but found only ${t22.length - 1}.`);
          if ((t22.length - 1) % 2 != 0) return e22.error("Expected an even number of arguments.");
          const r22 = e22.parse(t22[1], 1, dr);
          if (!r22) return null;
          const n22 = [];
          let i22 = null;
          e22.expectedType && "value" !== e22.expectedType.kind && (i22 = e22.expectedType);
          for (let r3 = 1; r3 < t22.length; r3 += 2) {
            const s2 = 1 === r3 ? -1 / 0 : t22[r3], o2 = t22[r3 + 1], a22 = r3, l22 = r3 + 1;
            if ("number" != typeof s2) return e22.error('Input/output pairs for "step" expressions must be defined using literal numeric values (not computed expressions) for the input values.', a22);
            if (n22.length && n22[n22.length - 1][0] >= s2) return e22.error('Input/output pairs for "step" expressions must be arranged with input values in strictly ascending order.', a22);
            const u22 = e22.parse(o2, l22, i22);
            if (!u22) return null;
            i22 = i22 || u22.type, n22.push([s2, u22]);
          }
          return new bi(i22, r22, n22);
        }
        evaluate(t22) {
          const e22 = this.labels, r22 = this.outputs;
          if (1 === e22.length) return r22[0].evaluate(t22);
          const n22 = this.input.evaluate(t22);
          if (n22 <= e22[0]) return r22[0].evaluate(t22);
          const i22 = e22.length;
          return n22 >= e22[i22 - 1] ? r22[i22 - 1].evaluate(t22) : r22[vi(e22, n22)].evaluate(t22);
        }
        eachChild(t22) {
          t22(this.input);
          for (const e22 of this.outputs) t22(e22);
        }
        outputDefined() {
          return this.outputs.every((t22) => t22.outputDefined());
        }
        serialize() {
          const t22 = ["step", this.input.serialize()];
          for (let e22 = 0; e22 < this.labels.length; e22++) e22 > 0 && t22.push(this.labels[e22]), t22.push(this.outputs[e22].serialize());
          return t22;
        }
      }
      const _i2 = 0.95047, wi = 1.08883, Ai = 4 / 29, Mi = 6 / 29, Ii = 3 * Mi * Mi, Si = Mi * Mi * Mi, zi = Math.PI / 180, ki = 180 / Math.PI;
      function Ei(t22) {
        return t22 > Si ? Math.pow(t22, 1 / 3) : t22 / Ii + Ai;
      }
      function Pi(t22) {
        return t22 > Mi ? t22 * t22 * t22 : Ii * (t22 - Ai);
      }
      function Ti(t22) {
        return 255 * (t22 <= 31308e-7 ? 12.92 * t22 : 1.055 * Math.pow(t22, 1 / 2.4) - 0.055);
      }
      function Bi(t22) {
        return (t22 /= 255) <= 0.04045 ? t22 / 12.92 : Math.pow((t22 + 0.055) / 1.055, 2.4);
      }
      function Vi(t22) {
        const e22 = Bi(t22.r), r22 = Bi(t22.g), n22 = Bi(t22.b), i22 = Ei((0.4124564 * e22 + 0.3575761 * r22 + 0.1804375 * n22) / _i2), s2 = Ei((0.2126729 * e22 + 0.7151522 * r22 + 0.072175 * n22) / 1);
        return { l: 116 * s2 - 16, a: 500 * (i22 - s2), b: 200 * (s2 - Ei((0.0193339 * e22 + 0.119192 * r22 + 0.9503041 * n22) / wi)), alpha: t22.a };
      }
      function Ci(t22) {
        let e22 = (t22.l + 16) / 116, r22 = isNaN(t22.a) ? e22 : e22 + t22.a / 500, n22 = isNaN(t22.b) ? e22 : e22 - t22.b / 200;
        return e22 = 1 * Pi(e22), r22 = _i2 * Pi(r22), n22 = wi * Pi(n22), new ir(Ti(3.2404542 * r22 - 1.5371385 * e22 - 0.4985314 * n22), Ti(-0.969266 * r22 + 1.8760108 * e22 + 0.041556 * n22), Ti(0.0556434 * r22 - 0.2040259 * e22 + 1.0572252 * n22), t22.alpha);
      }
      function Di(t22, e22, r22) {
        const n22 = e22 - t22;
        return t22 + r22 * (n22 > 180 || n22 < -180 ? n22 - 360 * Math.round(n22 / 360) : n22);
      }
      const Fi = { forward: Vi, reverse: Ci, interpolate: function(t22, e22, r22) {
        return { l: or(t22.l, e22.l, r22), a: or(t22.a, e22.a, r22), b: or(t22.b, e22.b, r22), alpha: or(t22.alpha, e22.alpha, r22) };
      } }, Li = { forward: function(t22) {
        const { l: e22, a: r22, b: n22 } = Vi(t22), i22 = Math.atan2(n22, r22) * ki;
        return { h: i22 < 0 ? i22 + 360 : i22, c: Math.sqrt(r22 * r22 + n22 * n22), l: e22, alpha: t22.a };
      }, reverse: function(t22) {
        const e22 = t22.h * zi, r22 = t22.c;
        return Ci({ l: t22.l, a: Math.cos(e22) * r22, b: Math.sin(e22) * r22, alpha: t22.alpha });
      }, interpolate: function(t22, e22, r22) {
        return { h: Di(t22.h, e22.h, r22), c: or(t22.c, e22.c, r22), l: or(t22.l, e22.l, r22), alpha: or(t22.alpha, e22.alpha, r22) };
      } };
      var Ri = Object.freeze({ __proto__: null, hcl: Li, lab: Fi });
      class Oi {
        constructor(t22, e22, r22, n22, i22) {
          this.type = t22, this.operator = e22, this.interpolation = r22, this.input = n22, this.labels = [], this.outputs = [];
          for (const [t3, e3] of i22) this.labels.push(t3), this.outputs.push(e3);
        }
        static interpolationFactor(t22, e22, r22, n22) {
          let i22 = 0;
          if ("exponential" === t22.name) i22 = Ui(e22, t22.base, r22, n22);
          else if ("linear" === t22.name) i22 = Ui(e22, 1, r22, n22);
          else if ("cubic-bezier" === t22.name) {
            const s2 = t22.controlPoints;
            i22 = new xt(s2[0], s2[1], s2[2], s2[3]).solve(Ui(e22, 1, r22, n22));
          }
          return i22;
        }
        static parse(t22, e22) {
          let [r22, n22, i22, ...s2] = t22;
          if (!Array.isArray(n22) || 0 === n22.length) return e22.error("Expected an interpolation type expression.", 1);
          if ("linear" === n22[0]) n22 = { name: "linear" };
          else if ("exponential" === n22[0]) {
            const t3 = n22[1];
            if ("number" != typeof t3) return e22.error("Exponential interpolation requires a numeric base.", 1, 1);
            n22 = { name: "exponential", base: t3 };
          } else {
            if ("cubic-bezier" !== n22[0]) return e22.error(`Unknown interpolation type ${String(n22[0])}`, 1, 0);
            {
              const t3 = n22.slice(1);
              if (4 !== t3.length || t3.some((t4) => "number" != typeof t4 || t4 < 0 || t4 > 1)) return e22.error("Cubic bezier interpolation requires four numeric arguments with values between 0 and 1.", 1);
              n22 = { name: "cubic-bezier", controlPoints: t3 };
            }
          }
          if (t22.length - 1 < 4) return e22.error(`Expected at least 4 arguments, but found only ${t22.length - 1}.`);
          if (t22.length - 1 > 3 && (t22.length - 1) % 2 != 0) return e22.error("Expected an even number of arguments.");
          if (i22 = e22.parse(i22, 2, dr), !i22) return null;
          const o2 = [];
          let a22 = null;
          "interpolate-hcl" === r22 || "interpolate-lab" === r22 ? a22 = gr : e22.expectedType && "value" !== e22.expectedType.kind && (a22 = e22.expectedType);
          for (let t3 = 0; t3 < s2.length; t3 += 2) {
            const r3 = s2[t3], n3 = s2[t3 + 1], i3 = t3 + 3, l22 = t3 + 4;
            if ("number" != typeof r3) return e22.error('Input/output pairs for "interpolate" expressions must be defined using literal numeric values (not computed expressions) for the input values.', i3);
            if (o2.length && o2[o2.length - 1][0] >= r3) return e22.error('Input/output pairs for "interpolate" expressions must be arranged with input values in strictly ascending order.', i3);
            const u22 = e22.parse(n3, l22, a22);
            if (!u22) return null;
            a22 = a22 || u22.type, o2.push([r3, u22]);
          }
          return "number" === a22.kind || "color" === a22.kind || "array" === a22.kind && "number" === a22.itemType.kind && "number" == typeof a22.N ? new Oi(a22, r22, n22, i22, o2) : e22.error(`Type ${Mr(a22)} is not interpolatable.`);
        }
        evaluate(t22) {
          const e22 = this.labels, r22 = this.outputs;
          if (1 === e22.length) return r22[0].evaluate(t22);
          const n22 = this.input.evaluate(t22);
          if (n22 <= e22[0]) return r22[0].evaluate(t22);
          const i22 = e22.length;
          if (n22 >= e22[i22 - 1]) return r22[i22 - 1].evaluate(t22);
          const s2 = vi(e22, n22), o2 = Oi.interpolationFactor(this.interpolation, n22, e22[s2], e22[s2 + 1]), a22 = r22[s2].evaluate(t22), l22 = r22[s2 + 1].evaluate(t22);
          return "interpolate" === this.operator ? ur[this.type.kind.toLowerCase()](a22, l22, o2) : "interpolate-hcl" === this.operator ? Li.reverse(Li.interpolate(Li.forward(a22), Li.forward(l22), o2)) : Fi.reverse(Fi.interpolate(Fi.forward(a22), Fi.forward(l22), o2));
        }
        eachChild(t22) {
          t22(this.input);
          for (const e22 of this.outputs) t22(e22);
        }
        outputDefined() {
          return this.outputs.every((t22) => t22.outputDefined());
        }
        serialize() {
          let t22;
          t22 = "linear" === this.interpolation.name ? ["linear"] : "exponential" === this.interpolation.name ? 1 === this.interpolation.base ? ["linear"] : ["exponential", this.interpolation.base] : ["cubic-bezier", ...this.interpolation.controlPoints];
          const e22 = [this.operator, t22, this.input.serialize()];
          for (let t3 = 0; t3 < this.labels.length; t3++) e22.push(this.labels[t3], this.outputs[t3].serialize());
          return e22;
        }
      }
      function Ui(t22, e22, r22, n22) {
        const i22 = n22 - r22, s2 = t22 - r22;
        return 0 === i22 ? 0 : 1 === e22 ? s2 / i22 : (Math.pow(e22, s2) - 1) / (Math.pow(e22, i22) - 1);
      }
      class Ni {
        constructor(t22, e22) {
          this.type = t22, this.args = e22;
        }
        static parse(t22, e22) {
          if (t22.length < 2) return e22.error("Expectected at least one argument.");
          let r22 = null;
          const n22 = e22.expectedType;
          n22 && "value" !== n22.kind && (r22 = n22);
          const i22 = [];
          for (const n3 of t22.slice(1)) {
            const t3 = e22.parse(n3, 1 + i22.length, r22, void 0, { typeAnnotation: "omit" });
            if (!t3) return null;
            r22 = r22 || t3.type, i22.push(t3);
          }
          const s2 = n22 && i22.some((t3) => Sr(n22, t3.type));
          return new Ni(s2 ? vr : r22, i22);
        }
        evaluate(t22) {
          let e22, r22 = null, n22 = 0;
          for (const i22 of this.args) {
            if (n22++, r22 = i22.evaluate(t22), r22 && r22 instanceof Vr && !r22.available && (e22 || (e22 = r22), r22 = null, n22 === this.args.length)) return e22;
            if (null !== r22) break;
          }
          return r22;
        }
        eachChild(t22) {
          this.args.forEach(t22);
        }
        outputDefined() {
          return this.args.every((t22) => t22.outputDefined());
        }
        serialize() {
          const t22 = ["coalesce"];
          return this.eachChild((e22) => {
            t22.push(e22.serialize());
          }), t22;
        }
      }
      class ji {
        constructor(t22, e22) {
          this.type = e22.type, this.bindings = [].concat(t22), this.result = e22;
        }
        evaluate(t22) {
          return this.result.evaluate(t22);
        }
        eachChild(t22) {
          for (const e22 of this.bindings) t22(e22[1]);
          t22(this.result);
        }
        static parse(t22, e22) {
          if (t22.length < 4) return e22.error(`Expected at least 3 arguments, but found ${t22.length - 1} instead.`);
          const r22 = [];
          for (let n3 = 1; n3 < t22.length - 1; n3 += 2) {
            const i22 = t22[n3];
            if ("string" != typeof i22) return e22.error(`Expected string, but found ${typeof i22} instead.`, n3);
            if (/[^a-zA-Z0-9_]/.test(i22)) return e22.error("Variable names must contain only alphanumeric characters or '_'.", n3);
            const s2 = e22.parse(t22[n3 + 1], n3 + 1);
            if (!s2) return null;
            r22.push([i22, s2]);
          }
          const n22 = e22.parse(t22[t22.length - 1], t22.length - 1, e22.expectedType, r22);
          return n22 ? new ji(r22, n22) : null;
        }
        outputDefined() {
          return this.result.outputDefined();
        }
        serialize() {
          const t22 = ["let"];
          for (const [e22, r22] of this.bindings) t22.push(e22, r22.serialize());
          return t22.push(this.result.serialize()), t22;
        }
      }
      class $i {
        constructor(t22, e22, r22) {
          this.type = t22, this.index = e22, this.input = r22;
        }
        static parse(t22, e22) {
          if (3 !== t22.length) return e22.error(`Expected 2 arguments, but found ${t22.length - 1} instead.`);
          const r22 = e22.parse(t22[1], 1, dr), n22 = e22.parse(t22[2], 2, Ar(e22.expectedType || vr));
          return r22 && n22 ? new $i(n22.type.itemType, r22, n22) : null;
        }
        evaluate(t22) {
          const e22 = this.index.evaluate(t22), r22 = this.input.evaluate(t22);
          if (e22 < 0) throw new Or(`Array index out of bounds: ${e22} < 0.`);
          if (e22 >= r22.length) throw new Or(`Array index out of bounds: ${e22} > ${r22.length - 1}.`);
          if (e22 !== Math.floor(e22)) throw new Or(`Array index must be an integer, but found ${e22} instead. Use at-interpolated to retrieve interpolated result with a fractional index.`);
          return r22[e22];
        }
        eachChild(t22) {
          t22(this.index), t22(this.input);
        }
        outputDefined() {
          return false;
        }
        serialize() {
          return ["at", this.index.serialize(), this.input.serialize()];
        }
      }
      class Gi {
        constructor(t22, e22, r22) {
          this.type = t22, this.index = e22, this.input = r22;
        }
        static parse(t22, e22) {
          if (3 !== t22.length) return e22.error(`Expected 2 arguments, but found ${t22.length - 1} instead.`);
          const r22 = e22.parse(t22[1], 1, dr), n22 = e22.parse(t22[2], 2, Ar(e22.expectedType || vr));
          return r22 && n22 ? new Gi(n22.type.itemType, r22, n22) : null;
        }
        evaluate(t22) {
          const e22 = this.index.evaluate(t22), r22 = this.input.evaluate(t22);
          if (e22 < 0) throw new Or(`Array index out of bounds: ${e22} < 0.`);
          if (e22 > r22.length - 1) throw new Or(`Array index out of bounds: ${e22} > ${r22.length - 1}.`);
          if (e22 === Math.floor(e22)) return r22[e22];
          const n22 = Math.floor(e22), i22 = Math.ceil(e22), s2 = r22[n22], o2 = r22[i22];
          if ("number" != typeof s2 || "number" != typeof o2) throw new Or(`Cannot interpolate between non-number values at index ${e22}.`);
          const a22 = e22 - n22;
          return s2 * (1 - a22) + o2 * a22;
        }
        eachChild(t22) {
          t22(this.index), t22(this.input);
        }
        outputDefined() {
          return false;
        }
        serialize() {
          return ["at-interpolated", this.index.serialize(), this.input.serialize()];
        }
      }
      class qi {
        constructor(t22, e22) {
          this.type = yr, this.needle = t22, this.haystack = e22;
        }
        static parse(t22, e22) {
          if (3 !== t22.length) return e22.error(`Expected 2 arguments, but found ${t22.length - 1} instead.`);
          const r22 = e22.parse(t22[1], 1, vr), n22 = e22.parse(t22[2], 2, vr);
          return r22 && n22 ? zr(r22.type, [yr, mr, dr, fr, vr]) ? new qi(r22, n22) : e22.error(`Expected first argument to be of type boolean, string, number or null, but found ${Mr(r22.type)} instead`) : null;
        }
        evaluate(t22) {
          const e22 = this.needle.evaluate(t22), r22 = this.haystack.evaluate(t22);
          if (null == r22) return false;
          if (!kr(e22, ["boolean", "string", "number", "null"])) throw new Or(`Expected first argument to be of type boolean, string, number or null, but found ${Mr(Fr(e22))} instead.`);
          if (!kr(r22, ["string", "array"])) throw new Or(`Expected second argument to be of type array or string, but found ${Mr(Fr(r22))} instead.`);
          return r22.indexOf(e22) >= 0;
        }
        eachChild(t22) {
          t22(this.needle), t22(this.haystack);
        }
        outputDefined() {
          return true;
        }
        serialize() {
          return ["in", this.needle.serialize(), this.haystack.serialize()];
        }
      }
      class Hi {
        constructor(t22, e22, r22) {
          this.type = dr, this.needle = t22, this.haystack = e22, this.fromIndex = r22;
        }
        static parse(t22, e22) {
          if (t22.length <= 2 || t22.length >= 5) return e22.error(`Expected 3 or 4 arguments, but found ${t22.length - 1} instead.`);
          const r22 = e22.parse(t22[1], 1, vr), n22 = e22.parse(t22[2], 2, vr);
          if (!r22 || !n22) return null;
          if (!zr(r22.type, [yr, mr, dr, fr, vr])) return e22.error(`Expected first argument to be of type boolean, string, number or null, but found ${Mr(r22.type)} instead`);
          if (4 === t22.length) {
            const i22 = e22.parse(t22[3], 3, dr);
            return i22 ? new Hi(r22, n22, i22) : null;
          }
          return new Hi(r22, n22);
        }
        evaluate(t22) {
          const e22 = this.needle.evaluate(t22), r22 = this.haystack.evaluate(t22);
          if (!kr(e22, ["boolean", "string", "number", "null"])) throw new Or(`Expected first argument to be of type boolean, string, number or null, but found ${Mr(Fr(e22))} instead.`);
          if (!kr(r22, ["string", "array"])) throw new Or(`Expected second argument to be of type array or string, but found ${Mr(Fr(r22))} instead.`);
          if (this.fromIndex) {
            const n22 = this.fromIndex.evaluate(t22);
            return r22.indexOf(e22, n22);
          }
          return r22.indexOf(e22);
        }
        eachChild(t22) {
          t22(this.needle), t22(this.haystack), this.fromIndex && t22(this.fromIndex);
        }
        outputDefined() {
          return false;
        }
        serialize() {
          if (null != this.fromIndex && void 0 !== this.fromIndex) {
            const t22 = this.fromIndex.serialize();
            return ["index-of", this.needle.serialize(), this.haystack.serialize(), t22];
          }
          return ["index-of", this.needle.serialize(), this.haystack.serialize()];
        }
      }
      class Xi {
        constructor(t22, e22, r22, n22, i22, s2) {
          this.inputType = t22, this.type = e22, this.input = r22, this.cases = n22, this.outputs = i22, this.otherwise = s2;
        }
        static parse(t22, e22) {
          if (t22.length < 5) return e22.error(`Expected at least 4 arguments, but found only ${t22.length - 1}.`);
          if (t22.length % 2 != 1) return e22.error("Expected an even number of arguments.");
          let r22, n22;
          e22.expectedType && "value" !== e22.expectedType.kind && (n22 = e22.expectedType);
          const i22 = {}, s2 = [];
          for (let o3 = 2; o3 < t22.length - 1; o3 += 2) {
            let a3 = t22[o3];
            const l22 = t22[o3 + 1];
            Array.isArray(a3) || (a3 = [a3]);
            const u22 = e22.concat(o3);
            if (0 === a3.length) return u22.error("Expected at least one branch label.");
            for (const t3 of a3) {
              if ("number" != typeof t3 && "string" != typeof t3) return u22.error("Branch labels must be numbers or strings.");
              if ("number" == typeof t3 && Math.abs(t3) > Number.MAX_SAFE_INTEGER) return u22.error(`Branch labels must be integers no larger than ${Number.MAX_SAFE_INTEGER}.`);
              if ("number" == typeof t3 && Math.floor(t3) !== t3) return u22.error("Numeric branch labels must be integer values.");
              if (r22) {
                if (u22.checkSubtype(r22, Fr(t3))) return null;
              } else r22 = Fr(t3);
              if (void 0 !== i22[String(t3)]) return u22.error("Branch labels must be unique.");
              i22[String(t3)] = s2.length;
            }
            const c22 = e22.parse(l22, o3, n22);
            if (!c22) return null;
            n22 = n22 || c22.type, s2.push(c22);
          }
          const o2 = e22.parse(t22[1], 1, vr);
          if (!o2) return null;
          const a22 = e22.parse(t22[t22.length - 1], t22.length - 1, n22);
          return a22 ? "value" !== o2.type.kind && e22.concat(1).checkSubtype(r22, o2.type) ? null : new Xi(r22, n22, o2, i22, s2, a22) : null;
        }
        evaluate(t22) {
          const e22 = this.input.evaluate(t22);
          return (Fr(e22) === this.inputType && this.outputs[this.cases[e22]] || this.otherwise).evaluate(t22);
        }
        eachChild(t22) {
          t22(this.input), this.outputs.forEach(t22), t22(this.otherwise);
        }
        outputDefined() {
          return this.outputs.every((t22) => t22.outputDefined()) && this.otherwise.outputDefined();
        }
        serialize() {
          const t22 = ["match", this.input.serialize()], e22 = Object.keys(this.cases).sort(), r22 = [], n22 = {};
          for (const t3 of e22) {
            const e3 = n22[this.cases[t3]];
            void 0 === e3 ? (n22[this.cases[t3]] = r22.length, r22.push([this.cases[t3], [t3]])) : r22[e3][1].push(t3);
          }
          const i22 = (t3) => "number" === this.inputType.kind ? Number(t3) : t3;
          for (const [e3, n3] of r22) t22.push(1 === n3.length ? i22(n3[0]) : n3.map(i22)), t22.push(this.outputs[e3].serialize());
          return t22.push(this.otherwise.serialize()), t22;
        }
      }
      class Zi {
        constructor(t22, e22, r22) {
          this.type = t22, this.branches = e22, this.otherwise = r22;
        }
        static parse(t22, e22) {
          if (t22.length < 4) return e22.error(`Expected at least 3 arguments, but found only ${t22.length - 1}.`);
          if (t22.length % 2 != 0) return e22.error("Expected an odd number of arguments.");
          let r22;
          e22.expectedType && "value" !== e22.expectedType.kind && (r22 = e22.expectedType);
          const n22 = [];
          for (let i3 = 1; i3 < t22.length - 1; i3 += 2) {
            const s2 = e22.parse(t22[i3], i3, yr);
            if (!s2) return null;
            const o2 = e22.parse(t22[i3 + 1], i3 + 1, r22);
            if (!o2) return null;
            n22.push([s2, o2]), r22 = r22 || o2.type;
          }
          const i22 = e22.parse(t22[t22.length - 1], t22.length - 1, r22);
          return i22 ? new Zi(r22, n22, i22) : null;
        }
        evaluate(t22) {
          for (const [e22, r22] of this.branches) if (e22.evaluate(t22)) return r22.evaluate(t22);
          return this.otherwise.evaluate(t22);
        }
        eachChild(t22) {
          for (const [e22, r22] of this.branches) t22(e22), t22(r22);
          t22(this.otherwise);
        }
        outputDefined() {
          return this.branches.every(([t22, e22]) => e22.outputDefined()) && this.otherwise.outputDefined();
        }
        serialize() {
          const t22 = ["case"];
          return this.eachChild((e22) => {
            t22.push(e22.serialize());
          }), t22;
        }
      }
      class Wi {
        constructor(t22, e22, r22, n22) {
          this.type = t22, this.input = e22, this.beginIndex = r22, this.endIndex = n22;
        }
        static parse(t22, e22) {
          if (t22.length <= 2 || t22.length >= 5) return e22.error(`Expected 3 or 4 arguments, but found ${t22.length - 1} instead.`);
          const r22 = e22.parse(t22[1], 1, vr), n22 = e22.parse(t22[2], 2, dr);
          if (!r22 || !n22) return null;
          if (!zr(r22.type, [Ar(vr), mr, vr])) return e22.error(`Expected first argument to be of type array or string, but found ${Mr(r22.type)} instead`);
          if (4 === t22.length) {
            const i22 = e22.parse(t22[3], 3, dr);
            return i22 ? new Wi(r22.type, r22, n22, i22) : null;
          }
          return new Wi(r22.type, r22, n22);
        }
        evaluate(t22) {
          const e22 = this.input.evaluate(t22), r22 = this.beginIndex.evaluate(t22);
          if (!kr(e22, ["string", "array"])) throw new Or(`Expected first argument to be of type array or string, but found ${Mr(Fr(e22))} instead.`);
          if (this.endIndex) {
            const n22 = this.endIndex.evaluate(t22);
            return e22.slice(r22, n22);
          }
          return e22.slice(r22);
        }
        eachChild(t22) {
          t22(this.input), t22(this.beginIndex), this.endIndex && t22(this.endIndex);
        }
        outputDefined() {
          return false;
        }
        serialize() {
          if (null != this.endIndex && void 0 !== this.endIndex) {
            const t22 = this.endIndex.serialize();
            return ["slice", this.input.serialize(), this.beginIndex.serialize(), t22];
          }
          return ["slice", this.input.serialize(), this.beginIndex.serialize()];
        }
      }
      function Yi(t22, e22) {
        return "==" === t22 || "!=" === t22 ? "boolean" === e22.kind || "string" === e22.kind || "number" === e22.kind || "null" === e22.kind || "value" === e22.kind : "string" === e22.kind || "number" === e22.kind || "value" === e22.kind;
      }
      function Ki(t22, e22, r22, n22) {
        return 0 === n22.compare(e22, r22);
      }
      function Ji(t22, e22, r22) {
        const n22 = "==" !== t22 && "!=" !== t22;
        return class i22 {
          constructor(t3, e3, r3) {
            this.type = yr, this.lhs = t3, this.rhs = e3, this.collator = r3, this.hasUntypedArgument = "value" === t3.type.kind || "value" === e3.type.kind;
          }
          static parse(t3, e3) {
            if (3 !== t3.length && 4 !== t3.length) return e3.error("Expected two or three arguments.");
            const r3 = t3[0];
            let s2 = e3.parse(t3[1], 1, vr);
            if (!s2) return null;
            if (!Yi(r3, s2.type)) return e3.concat(1).error(`"${r3}" comparisons are not supported for type '${Mr(s2.type)}'.`);
            let o2 = e3.parse(t3[2], 2, vr);
            if (!o2) return null;
            if (!Yi(r3, o2.type)) return e3.concat(2).error(`"${r3}" comparisons are not supported for type '${Mr(o2.type)}'.`);
            if (s2.type.kind !== o2.type.kind && "value" !== s2.type.kind && "value" !== o2.type.kind) return e3.error(`Cannot compare types '${Mr(s2.type)}' and '${Mr(o2.type)}'.`);
            n22 && ("value" === s2.type.kind && "value" !== o2.type.kind ? s2 = new Nr(o2.type, [s2]) : "value" !== s2.type.kind && "value" === o2.type.kind && (o2 = new Nr(s2.type, [o2])));
            let a22 = null;
            if (4 === t3.length) {
              if ("string" !== s2.type.kind && "string" !== o2.type.kind && "value" !== s2.type.kind && "value" !== o2.type.kind) return e3.error("Cannot use collator to compare non-string types.");
              if (a22 = e3.parse(t3[3], 3, br), !a22) return null;
            }
            return new i22(s2, o2, a22);
          }
          evaluate(i3) {
            const s2 = this.lhs.evaluate(i3), o2 = this.rhs.evaluate(i3);
            if (n22 && this.hasUntypedArgument) {
              const e3 = Fr(s2), r3 = Fr(o2);
              if (e3.kind !== r3.kind || "string" !== e3.kind && "number" !== e3.kind) throw new Or(`Expected arguments for "${t22}" to be (string, string) or (number, number), but found (${e3.kind}, ${r3.kind}) instead.`);
            }
            if (this.collator && !n22 && this.hasUntypedArgument) {
              const t3 = Fr(s2), r3 = Fr(o2);
              if ("string" !== t3.kind || "string" !== r3.kind) return e22(i3, s2, o2);
            }
            return this.collator ? r22(i3, s2, o2, this.collator.evaluate(i3)) : e22(i3, s2, o2);
          }
          eachChild(t3) {
            t3(this.lhs), t3(this.rhs), this.collator && t3(this.collator);
          }
          outputDefined() {
            return true;
          }
          serialize() {
            const e3 = [t22];
            return this.eachChild((t3) => {
              e3.push(t3.serialize());
            }), e3;
          }
        };
      }
      const Qi = Ji("==", function(t22, e22, r22) {
        return e22 === r22;
      }, Ki), ts = Ji("!=", function(t22, e22, r22) {
        return e22 !== r22;
      }, function(t22, e22, r22, n22) {
        return !Ki(0, e22, r22, n22);
      }), es2 = Ji("<", function(t22, e22, r22) {
        return e22 < r22;
      }, function(t22, e22, r22, n22) {
        return n22.compare(e22, r22) < 0;
      }), rs = Ji(">", function(t22, e22, r22) {
        return e22 > r22;
      }, function(t22, e22, r22, n22) {
        return n22.compare(e22, r22) > 0;
      }), ns = Ji("<=", function(t22, e22, r22) {
        return e22 <= r22;
      }, function(t22, e22, r22, n22) {
        return n22.compare(e22, r22) <= 0;
      }), is = Ji(">=", function(t22, e22, r22) {
        return e22 >= r22;
      }, function(t22, e22, r22, n22) {
        return n22.compare(e22, r22) >= 0;
      });
      class ss {
        constructor(t22, e22, r22, n22, i22, s2) {
          this.type = mr, this.number = t22, this.locale = e22, this.currency = r22, this.unit = n22, this.minFractionDigits = i22, this.maxFractionDigits = s2;
        }
        static parse(t22, e22) {
          if (3 !== t22.length) return e22.error("Expected two arguments.");
          const r22 = e22.parse(t22[1], 1, dr);
          if (!r22) return null;
          const n22 = t22[2];
          if ("object" != typeof n22 || Array.isArray(n22)) return e22.error("NumberFormat options argument must be an object.");
          let i22 = null;
          if (n22.locale && (i22 = e22.parseObjectValue(n22.locale, 2, "locale", mr), !i22)) return null;
          let s2 = null;
          if (n22.currency && (s2 = e22.parseObjectValue(n22.currency, 2, "currency", mr), !s2)) return null;
          let o2 = null;
          if (n22.unit && (o2 = e22.parseObjectValue(n22.unit, 2, "unit", mr), !o2)) return null;
          let a22 = null;
          if (n22["min-fraction-digits"] && (a22 = e22.parseObjectValue(n22["min-fraction-digits"], 2, "min-fraction-digits", dr), !a22)) return null;
          let l22 = null;
          return n22["max-fraction-digits"] && (l22 = e22.parseObjectValue(n22["max-fraction-digits"], 2, "max-fraction-digits", dr), !l22) ? null : new ss(r22, i22, s2, o2, a22, l22);
        }
        evaluate(t22) {
          return new Intl.NumberFormat(this.locale ? this.locale.evaluate(t22) : [], { style: (this.currency ? "currency" : this.unit && "unit") || "decimal", currency: this.currency ? this.currency.evaluate(t22) : void 0, unit: this.unit ? this.unit.evaluate(t22) : void 0, minimumFractionDigits: this.minFractionDigits ? this.minFractionDigits.evaluate(t22) : void 0, maximumFractionDigits: this.maxFractionDigits ? this.maxFractionDigits.evaluate(t22) : void 0 }).format(this.number.evaluate(t22));
        }
        eachChild(t22) {
          t22(this.number), this.locale && t22(this.locale), this.currency && t22(this.currency), this.unit && t22(this.unit), this.minFractionDigits && t22(this.minFractionDigits), this.maxFractionDigits && t22(this.maxFractionDigits);
        }
        outputDefined() {
          return false;
        }
        serialize() {
          const t22 = {};
          return this.locale && (t22.locale = this.locale.serialize()), this.currency && (t22.currency = this.currency.serialize()), this.unit && (t22.unit = this.unit.serialize()), this.minFractionDigits && (t22["min-fraction-digits"] = this.minFractionDigits.serialize()), this.maxFractionDigits && (t22["max-fraction-digits"] = this.maxFractionDigits.serialize()), ["number-format", this.number.serialize(), t22];
        }
      }
      class os {
        constructor(t22) {
          this.type = dr, this.input = t22;
        }
        static parse(t22, e22) {
          if (2 !== t22.length) return e22.error(`Expected 1 argument, but found ${t22.length - 1} instead.`);
          const r22 = e22.parse(t22[1], 1);
          return r22 ? "array" !== r22.type.kind && "string" !== r22.type.kind && "value" !== r22.type.kind ? e22.error(`Expected argument of type string or array, but found ${Mr(r22.type)} instead.`) : new os(r22) : null;
        }
        evaluate(t22) {
          const e22 = this.input.evaluate(t22);
          if ("string" == typeof e22) return e22.length;
          if (Array.isArray(e22)) return e22.length;
          throw new Or(`Expected value to be of type string or array, but found ${Mr(Fr(e22))} instead.`);
        }
        eachChild(t22) {
          t22(this.input);
        }
        outputDefined() {
          return false;
        }
        serialize() {
          const t22 = ["length"];
          return this.eachChild((e22) => {
            t22.push(e22.serialize());
          }), t22;
        }
      }
      function as(t22) {
        return function() {
          t22 = 1831565813 + (t22 |= 0) | 0;
          let e22 = Math.imul(t22 ^ t22 >>> 15, 1 | t22);
          return e22 = e22 + Math.imul(e22 ^ e22 >>> 7, 61 | e22) ^ e22, ((e22 ^ e22 >>> 14) >>> 0) / 4294967296;
        };
      }
      const ls = { "==": Qi, "!=": ts, ">": rs, "<": es2, ">=": is, "<=": ns, array: Nr, at: $i, "at-interpolated": Gi, boolean: Nr, case: Zi, coalesce: Ni, collator: Kr, format: jr, image: $r, in: qi, "index-of": Hi, interpolate: Oi, "interpolate-hcl": Oi, "interpolate-lab": Oi, length: os, let: ji, literal: Rr, match: Xi, number: Nr, "number-format": ss, object: Nr, slice: Wi, step: bi, string: Nr, "to-boolean": Hr, "to-color": Hr, "to-number": Hr, "to-string": Hr, var: mi, within: _n, distance: ai, config: ci };
      function us(t22, [e22, r22, n22, i22]) {
        e22 = e22.evaluate(t22), r22 = r22.evaluate(t22), n22 = n22.evaluate(t22);
        const s2 = i22 ? i22.evaluate(t22) : 1, o2 = Cr(e22, r22, n22, s2);
        if (o2) throw new Or(o2);
        return new ir(e22 / 255 * s2, r22 / 255 * s2, n22 / 255 * s2, s2);
      }
      function cs(t22, [e22, r22, n22, i22]) {
        e22 = e22.evaluate(t22), r22 = r22.evaluate(t22), n22 = n22.evaluate(t22);
        const s2 = i22 ? i22.evaluate(t22) : 1, o2 = function(t3, e3, r3, n3) {
          return "number" == typeof t3 && t3 >= 0 && t3 <= 360 ? "number" == typeof e3 && e3 >= 0 && e3 <= 100 && "number" == typeof r3 && r3 >= 0 && r3 <= 100 ? void 0 === n3 || "number" == typeof n3 && n3 >= 0 && n3 <= 1 ? null : `Invalid hsla value [${[t3, e3, r3, n3].join(", ")}]: 'a' must be between 0 and 1.` : `Invalid hsla value [${("number" == typeof n3 ? [t3, e3, r3, n3] : [t3, e3, r3]).join(", ")}]: 's', and 'l' must be between 0 and 100.` : `Invalid hsla value [${("number" == typeof n3 ? [t3, e3, r3, n3] : [t3, e3, r3]).join(", ")}]: 'h' must be between 0 and 360.`;
        }(e22, r22, n22, s2);
        if (o2) throw new Or(o2);
        const a22 = `hsla(${e22}, ${r22}%, ${n22}%, ${s2})`, l22 = ir.parse(a22);
        if (!l22) throw new Or(`Failed to parse HSLA color: ${a22}`);
        return l22;
      }
      function hs(t22, e22) {
        return t22 in e22;
      }
      function ps(t22, e22) {
        const r22 = e22[t22];
        return void 0 === r22 ? null : r22;
      }
      function fs(t22) {
        return { type: t22 };
      }
      function ds(t22) {
        return { result: "success", value: t22 };
      }
      function ms(t22) {
        return { result: "error", value: t22 };
      }
      function ys(t22, e22) {
        return !!t22 && !!t22.parameters && t22.parameters.indexOf(e22) > -1;
      }
      function gs(t22) {
        return "data-driven" === t22["property-type"];
      }
      function xs(t22) {
        return ys(t22.expression, "measure-light");
      }
      function vs(t22) {
        return ys(t22.expression, "zoom");
      }
      function bs(t22) {
        return !!t22.expression && t22.expression.interpolated;
      }
      function _s(t22) {
        return "object" == typeof t22 && null !== t22 && !Array.isArray(t22);
      }
      function ws(t22) {
        return t22;
      }
      function As(t22, e22) {
        const r22 = "color" === e22.type, n22 = t22.stops && "object" == typeof t22.stops[0][0], i22 = n22 || !(n22 || void 0 !== t22.property), s2 = t22.type || (bs(e22) ? "exponential" : "interval");
        if (r22 && ((t22 = cr({}, t22)).stops && (t22.stops = t22.stops.map((t3) => [t3[0], ir.parse(t3[1])])), t22.default = ir.parse(t22.default ? t22.default : e22.default)), t22.colorSpace && "rgb" !== t22.colorSpace && !Ri[t22.colorSpace]) throw new Error(`Unknown color space: ${t22.colorSpace}`);
        let o2, a22, l22;
        if ("exponential" === s2) o2 = zs;
        else if ("interval" === s2) o2 = Ss;
        else if ("categorical" === s2) {
          o2 = Is, a22 = /* @__PURE__ */ Object.create(null);
          for (const e3 of t22.stops) a22[e3[0]] = e3[1];
          l22 = typeof t22.stops[0][0];
        } else {
          if ("identity" !== s2) throw new Error(`Unknown function type "${s2}"`);
          o2 = ks;
        }
        if (n22) {
          const r3 = {}, n3 = [];
          for (let e3 = 0; e3 < t22.stops.length; e3++) {
            const i4 = t22.stops[e3], s4 = i4[0].zoom;
            void 0 === r3[s4] && (r3[s4] = { zoom: s4, type: t22.type, property: t22.property, default: t22.default, stops: [] }, n3.push(s4)), r3[s4].stops.push([i4[0].value, i4[1]]);
          }
          const i3 = [];
          for (const t3 of n3) i3.push([r3[t3].zoom, As(r3[t3], e22)]);
          const s3 = { name: "linear" };
          return { kind: "composite", interpolationType: s3, interpolationFactor: Oi.interpolationFactor.bind(void 0, s3), zoomStops: i3.map((t3) => t3[0]), evaluate: ({ zoom: r4 }, n4) => zs({ stops: i3, base: t22.base }, e22, r4).evaluate(r4, n4) };
        }
        if (i22) {
          const r3 = "exponential" === s2 ? { name: "exponential", base: void 0 !== t22.base ? t22.base : 1 } : null;
          return { kind: "camera", interpolationType: r3, interpolationFactor: Oi.interpolationFactor.bind(void 0, r3), zoomStops: t22.stops.map((t3) => t3[0]), evaluate: ({ zoom: r4 }) => o2(t22, e22, r4, a22, l22) };
        }
        return { kind: "source", evaluate(r3, n3) {
          const i3 = n3 && n3.properties ? n3.properties[t22.property] : void 0;
          return void 0 === i3 ? Ms(t22.default, e22.default) : o2(t22, e22, i3, a22, l22);
        } };
      }
      function Ms(t22, e22, r22) {
        return void 0 !== t22 ? t22 : void 0 !== e22 ? e22 : void 0 !== r22 ? r22 : void 0;
      }
      function Is(t22, e22, r22, n22, i22) {
        return Ms(typeof r22 === i22 ? n22[r22] : void 0, t22.default, e22.default);
      }
      function Ss(t22, e22, r22) {
        if ("number" !== Gr(r22)) return Ms(t22.default, e22.default);
        const n22 = t22.stops.length;
        if (1 === n22) return t22.stops[0][1];
        if (r22 <= t22.stops[0][0]) return t22.stops[0][1];
        if (r22 >= t22.stops[n22 - 1][0]) return t22.stops[n22 - 1][1];
        const i22 = vi(t22.stops.map((t3) => t3[0]), r22);
        return t22.stops[i22][1];
      }
      function zs(t22, e22, r22) {
        const n22 = void 0 !== t22.base ? t22.base : 1;
        if ("number" !== Gr(r22)) return Ms(t22.default, e22.default);
        const i22 = t22.stops.length;
        if (1 === i22) return t22.stops[0][1];
        if (r22 <= t22.stops[0][0]) return t22.stops[0][1];
        if (r22 >= t22.stops[i22 - 1][0]) return t22.stops[i22 - 1][1];
        const s2 = vi(t22.stops.map((t3) => t3[0]), r22), o2 = function(t3, e3, r3, n3) {
          const i3 = n3 - r3, s3 = t3 - r3;
          return 0 === i3 ? 0 : 1 === e3 ? s3 / i3 : (Math.pow(e3, s3) - 1) / (Math.pow(e3, i3) - 1);
        }(r22, n22, t22.stops[s2][0], t22.stops[s2 + 1][0]), a22 = t22.stops[s2][1], l22 = t22.stops[s2 + 1][1];
        let u22 = ur[e22.type] || ws;
        if (t22.colorSpace && "rgb" !== t22.colorSpace) {
          const e3 = Ri[t22.colorSpace];
          u22 = (t3, r3) => e3.reverse(e3.interpolate(e3.forward(t3), e3.forward(r3), o2));
        }
        return "function" == typeof a22.evaluate ? { evaluate(...t3) {
          const e3 = a22.evaluate.apply(void 0, t3), r3 = l22.evaluate.apply(void 0, t3);
          if (void 0 !== e3 && void 0 !== r3) return u22(e3, r3, o2);
        } } : u22(a22, l22, o2);
      }
      function ks(t22, e22, r22) {
        return "color" === e22.type ? r22 = ir.parse(r22) : "formatted" === e22.type ? r22 = Tr.fromString(r22.toString()) : "resolvedImage" === e22.type ? r22 = Vr.build(r22.toString()) : Gr(r22) === e22.type || "enum" === e22.type && e22.values[r22] || (r22 = void 0), Ms(r22, t22.default, e22.default);
      }
      Wr.register(ls, { error: [{ kind: "error" }, [mr], (t22, [e22]) => {
        throw new Or(e22.evaluate(t22));
      }], typeof: [mr, [vr], (t22, [e22]) => Mr(Fr(e22.evaluate(t22)))], "to-rgba": [Ar(dr, 4), [gr], (t22, [e22]) => e22.evaluate(t22).toRenderColor(null).toArray()], "to-hsla": [Ar(dr, 4), [gr], (t22, [e22]) => e22.evaluate(t22).toRenderColor(null).toHslaArray()], rgb: [gr, [dr, dr, dr], us], rgba: [gr, [dr, dr, dr, dr], us], hsl: [gr, [dr, dr, dr], cs], hsla: [gr, [dr, dr, dr, dr], cs], has: { type: yr, overloads: [[[mr], (t22, [e22]) => hs(e22.evaluate(t22), t22.properties())], [[mr, xr], (t22, [e22, r22]) => hs(e22.evaluate(t22), r22.evaluate(t22))]] }, get: { type: vr, overloads: [[[mr], (t22, [e22]) => ps(e22.evaluate(t22), t22.properties())], [[mr, xr], (t22, [e22, r22]) => ps(e22.evaluate(t22), r22.evaluate(t22))]] }, "feature-state": [vr, [mr], (t22, [e22]) => ps(e22.evaluate(t22), t22.featureState || {})], properties: [xr, [], (t22) => t22.properties()], "geometry-type": [mr, [], (t22) => t22.geometryType()], id: [vr, [], (t22) => t22.id()], zoom: [dr, [], (t22) => t22.globals.zoom], pitch: [dr, [], (t22) => t22.globals.pitch || 0], "distance-from-center": [dr, [], (t22) => t22.distanceFromCenter()], "measure-light": [dr, [mr], (t22, [e22]) => t22.measureLight(e22.evaluate(t22))], "heatmap-density": [dr, [], (t22) => t22.globals.heatmapDensity || 0], "line-progress": [dr, [], (t22) => t22.globals.lineProgress || 0], "raster-value": [dr, [], (t22) => t22.globals.rasterValue || 0], "raster-particle-speed": [dr, [], (t22) => t22.globals.rasterParticleSpeed || 0], "sky-radial-progress": [dr, [], (t22) => t22.globals.skyRadialProgress || 0], accumulated: [vr, [], (t22) => void 0 === t22.globals.accumulated ? null : t22.globals.accumulated], "+": [dr, fs(dr), (t22, e22) => {
        let r22 = 0;
        for (const n22 of e22) r22 += n22.evaluate(t22);
        return r22;
      }], "*": [dr, fs(dr), (t22, e22) => {
        let r22 = 1;
        for (const n22 of e22) r22 *= n22.evaluate(t22);
        return r22;
      }], "-": { type: dr, overloads: [[[dr, dr], (t22, [e22, r22]) => e22.evaluate(t22) - r22.evaluate(t22)], [[dr], (t22, [e22]) => -e22.evaluate(t22)]] }, "/": [dr, [dr, dr], (t22, [e22, r22]) => e22.evaluate(t22) / r22.evaluate(t22)], "%": [dr, [dr, dr], (t22, [e22, r22]) => e22.evaluate(t22) % r22.evaluate(t22)], ln2: [dr, [], () => Math.LN2], pi: [dr, [], () => Math.PI], e: [dr, [], () => Math.E], "^": [dr, [dr, dr], (t22, [e22, r22]) => Math.pow(e22.evaluate(t22), r22.evaluate(t22))], sqrt: [dr, [dr], (t22, [e22]) => Math.sqrt(e22.evaluate(t22))], log10: [dr, [dr], (t22, [e22]) => Math.log(e22.evaluate(t22)) / Math.LN10], ln: [dr, [dr], (t22, [e22]) => Math.log(e22.evaluate(t22))], log2: [dr, [dr], (t22, [e22]) => Math.log(e22.evaluate(t22)) / Math.LN2], sin: [dr, [dr], (t22, [e22]) => Math.sin(e22.evaluate(t22))], cos: [dr, [dr], (t22, [e22]) => Math.cos(e22.evaluate(t22))], tan: [dr, [dr], (t22, [e22]) => Math.tan(e22.evaluate(t22))], asin: [dr, [dr], (t22, [e22]) => Math.asin(e22.evaluate(t22))], acos: [dr, [dr], (t22, [e22]) => Math.acos(e22.evaluate(t22))], atan: [dr, [dr], (t22, [e22]) => Math.atan(e22.evaluate(t22))], min: [dr, fs(dr), (t22, e22) => Math.min(...e22.map((e3) => e3.evaluate(t22)))], max: [dr, fs(dr), (t22, e22) => Math.max(...e22.map((e3) => e3.evaluate(t22)))], abs: [dr, [dr], (t22, [e22]) => Math.abs(e22.evaluate(t22))], round: [dr, [dr], (t22, [e22]) => {
        const r22 = e22.evaluate(t22);
        return r22 < 0 ? -Math.round(-r22) : Math.round(r22);
      }], floor: [dr, [dr], (t22, [e22]) => Math.floor(e22.evaluate(t22))], ceil: [dr, [dr], (t22, [e22]) => Math.ceil(e22.evaluate(t22))], "filter-==": [yr, [mr, vr], (t22, [e22, r22]) => t22.properties()[e22.value] === r22.value], "filter-id-==": [yr, [vr], (t22, [e22]) => t22.id() === e22.value], "filter-type-==": [yr, [mr], (t22, [e22]) => t22.geometryType() === e22.value], "filter-<": [yr, [mr, vr], (t22, [e22, r22]) => {
        const n22 = t22.properties()[e22.value], i22 = r22.value;
        return typeof n22 == typeof i22 && n22 < i22;
      }], "filter-id-<": [yr, [vr], (t22, [e22]) => {
        const r22 = t22.id(), n22 = e22.value;
        return typeof r22 == typeof n22 && r22 < n22;
      }], "filter->": [yr, [mr, vr], (t22, [e22, r22]) => {
        const n22 = t22.properties()[e22.value], i22 = r22.value;
        return typeof n22 == typeof i22 && n22 > i22;
      }], "filter-id->": [yr, [vr], (t22, [e22]) => {
        const r22 = t22.id(), n22 = e22.value;
        return typeof r22 == typeof n22 && r22 > n22;
      }], "filter-<=": [yr, [mr, vr], (t22, [e22, r22]) => {
        const n22 = t22.properties()[e22.value], i22 = r22.value;
        return typeof n22 == typeof i22 && n22 <= i22;
      }], "filter-id-<=": [yr, [vr], (t22, [e22]) => {
        const r22 = t22.id(), n22 = e22.value;
        return typeof r22 == typeof n22 && r22 <= n22;
      }], "filter->=": [yr, [mr, vr], (t22, [e22, r22]) => {
        const n22 = t22.properties()[e22.value], i22 = r22.value;
        return typeof n22 == typeof i22 && n22 >= i22;
      }], "filter-id->=": [yr, [vr], (t22, [e22]) => {
        const r22 = t22.id(), n22 = e22.value;
        return typeof r22 == typeof n22 && r22 >= n22;
      }], "filter-has": [yr, [vr], (t22, [e22]) => e22.value in t22.properties()], "filter-has-id": [yr, [], (t22) => null !== t22.id() && void 0 !== t22.id()], "filter-type-in": [yr, [Ar(mr)], (t22, [e22]) => e22.value.indexOf(t22.geometryType()) >= 0], "filter-id-in": [yr, [Ar(vr)], (t22, [e22]) => e22.value.indexOf(t22.id()) >= 0], "filter-in-small": [yr, [mr, Ar(vr)], (t22, [e22, r22]) => r22.value.indexOf(t22.properties()[e22.value]) >= 0], "filter-in-large": [yr, [mr, Ar(vr)], (t22, [e22, r22]) => function(t3, e3, r3, n22) {
        for (; r3 <= n22; ) {
          const i22 = r3 + n22 >> 1;
          if (e3[i22] === t3) return true;
          e3[i22] > t3 ? n22 = i22 - 1 : r3 = i22 + 1;
        }
        return false;
      }(t22.properties()[e22.value], r22.value, 0, r22.value.length - 1)], all: { type: yr, overloads: [[[yr, yr], (t22, [e22, r22]) => e22.evaluate(t22) && r22.evaluate(t22)], [fs(yr), (t22, e22) => {
        for (const r22 of e22) if (!r22.evaluate(t22)) return false;
        return true;
      }]] }, any: { type: yr, overloads: [[[yr, yr], (t22, [e22, r22]) => e22.evaluate(t22) || r22.evaluate(t22)], [fs(yr), (t22, e22) => {
        for (const r22 of e22) if (r22.evaluate(t22)) return true;
        return false;
      }]] }, "!": [yr, [yr], (t22, [e22]) => !e22.evaluate(t22)], "is-supported-script": [yr, [mr], (t22, [e22]) => {
        const r22 = t22.globals && t22.globals.isSupportedScript;
        return !r22 || r22(e22.evaluate(t22));
      }], upcase: [mr, [mr], (t22, [e22]) => e22.evaluate(t22).toUpperCase()], downcase: [mr, [mr], (t22, [e22]) => e22.evaluate(t22).toLowerCase()], concat: [mr, fs(vr), (t22, e22) => e22.map((e3) => Lr(e3.evaluate(t22))).join("")], "resolved-locale": [mr, [br], (t22, [e22]) => e22.evaluate(t22).resolvedLocale()], random: [dr, [dr, dr, vr], (t22, e22) => {
        const [r22, n22, i22] = e22.map((e3) => e3.evaluate(t22));
        if (r22 > n22) return r22;
        if (r22 === n22) return r22;
        let s2;
        if ("string" == typeof i22) s2 = function(t3) {
          let e3 = 0;
          if (0 === t3.length) return e3;
          for (let r3 = 0; r3 < t3.length; r3++) e3 = (e3 << 5) - e3 + t3.charCodeAt(r3), e3 |= 0;
          return e3;
        }(i22);
        else {
          if ("number" != typeof i22) throw new Or(`Invalid seed input: ${i22}`);
          s2 = i22;
        }
        return r22 + as(s2)() * (n22 - r22);
      }] });
      class Es {
        constructor(t22, e22, r22, n22) {
          this.expression = t22, this._warningHistory = {}, this._evaluator = new Zr(r22, n22), this._defaultValue = e22 ? function(t3) {
            return "color" === t3.type && (_s(t3.default) || Array.isArray(t3.default)) ? new ir(0, 0, 0, 0) : "color" === t3.type ? ir.parse(t3.default) || null : void 0 === t3.default ? null : t3.default;
          }(e22) : null, this._enumValues = e22 && "enum" === e22.type ? e22.values : null, this.configDependencies = fi(t22);
        }
        evaluateWithoutErrorHandling(t22, e22, r22, n22, i22, s2, o2, a22) {
          return this._evaluator.globals = t22, this._evaluator.feature = e22, this._evaluator.featureState = r22, this._evaluator.canonical = n22 || null, this._evaluator.availableImages = i22 || null, this._evaluator.formattedSection = s2, this._evaluator.featureTileCoord = o2 || null, this._evaluator.featureDistanceData = a22 || null, this.expression.evaluate(this._evaluator);
        }
        evaluate(t22, e22, r22, n22, i22, s2, o2, a22) {
          this._evaluator.globals = t22, this._evaluator.feature = e22 || null, this._evaluator.featureState = r22 || null, this._evaluator.canonical = n22 || null, this._evaluator.availableImages = i22 || null, this._evaluator.formattedSection = s2 || null, this._evaluator.featureTileCoord = o2 || null, this._evaluator.featureDistanceData = a22 || null;
          try {
            const t3 = this.expression.evaluate(this._evaluator);
            if (null == t3 || "number" == typeof t3 && t3 != t3) return this._defaultValue;
            if (this._enumValues && !(t3 in this._enumValues)) throw new Or(`Expected value to be one of ${Object.keys(this._enumValues).map((t4) => JSON.stringify(t4)).join(", ")}, but found ${JSON.stringify(t3)} instead.`);
            return t3;
          } catch (t3) {
            return this._warningHistory[t3.message] || (this._warningHistory[t3.message] = true, "undefined" != typeof console && console.warn(`Failed to evaluate expression "${JSON.stringify(this.expression.serialize())}". ${t3.message}`)), this._defaultValue;
          }
        }
      }
      function Ps(t22) {
        return Array.isArray(t22) && t22.length > 0 && "string" == typeof t22[0] && t22[0] in ls;
      }
      function Ts(t22, e22, r22, n22) {
        const i22 = new gi(ls, [], e22 ? function(t3) {
          const e3 = { color: gr, string: mr, number: dr, enum: mr, boolean: yr, formatted: _r, resolvedImage: wr };
          return "array" === t3.type ? Ar(e3[t3.value] || vr, t3.length) : e3[t3.type];
        }(e22) : void 0, void 0, void 0, r22, n22), s2 = i22.parse(t22, void 0, void 0, void 0, e22 && "string" === e22.type ? { typeAnnotation: "coerce" } : void 0);
        return s2 ? ds(new Es(s2, e22, r22, n22)) : ms(i22.errors);
      }
      class Bs {
        constructor(t22, e22, r22, n22) {
          this.kind = t22, this._styleExpression = e22, this.isLightConstant = r22, this.isLineProgressConstant = n22, this.isStateDependent = "constant" !== t22 && !pi(e22.expression), this.configDependencies = fi(e22.expression);
        }
        evaluateWithoutErrorHandling(t22, e22, r22, n22, i22, s2) {
          return this._styleExpression.evaluateWithoutErrorHandling(t22, e22, r22, n22, i22, s2);
        }
        evaluate(t22, e22, r22, n22, i22, s2) {
          return this._styleExpression.evaluate(t22, e22, r22, n22, i22, s2);
        }
      }
      class Vs {
        constructor(t22, e22, r22, n22, i22, s2) {
          this.kind = t22, this.zoomStops = r22, this._styleExpression = e22, this.isStateDependent = "camera" !== t22 && !pi(e22.expression), this.isLightConstant = i22, this.isLineProgressConstant = s2, this.configDependencies = fi(e22.expression), this.interpolationType = n22;
        }
        evaluateWithoutErrorHandling(t22, e22, r22, n22, i22, s2) {
          return this._styleExpression.evaluateWithoutErrorHandling(t22, e22, r22, n22, i22, s2);
        }
        evaluate(t22, e22, r22, n22, i22, s2) {
          return this._styleExpression.evaluate(t22, e22, r22, n22, i22, s2);
        }
        interpolationFactor(t22, e22, r22) {
          return this.interpolationType ? Oi.interpolationFactor(this.interpolationType, t22, e22, r22) : 0;
        }
      }
      function Cs(t22, e22, r22, n22) {
        if ("error" === (t22 = Ts(t22, e22, r22, n22)).result) return t22;
        const i22 = t22.value.expression, s2 = hi(i22);
        if (!s2 && !gs(e22)) return ms([new hr("", "data expressions not supported")]);
        const o2 = di(i22, ["zoom", "pitch", "distance-from-center"]);
        if (!o2 && !vs(e22)) return ms([new hr("", "zoom expressions not supported")]);
        const a22 = di(i22, ["measure-light"]);
        if (!a22 && !xs(e22)) return ms([new hr("", "measure-light expression not supported")]);
        const l22 = di(i22, ["line-progress"]);
        if (!l22 && !function(t3) {
          return ys(t3.expression, "line-progress");
        }(e22)) return ms([new hr("", "line-progress expression not supported")]);
        const u22 = e22.expression && e22.expression.relaxZoomRestriction, c22 = Fs(i22);
        return c22 || o2 || u22 ? c22 instanceof hr ? ms([c22]) : c22 instanceof Oi && !bs(e22) ? ms([new hr("", '"interpolate" expressions cannot be used with this property')]) : ds(c22 ? new Vs(s2 && l22 ? "camera" : "composite", t22.value, c22.labels, c22 instanceof Oi ? c22.interpolation : void 0, a22, l22) : new Bs(s2 && l22 ? "constant" : "source", t22.value, a22, l22)) : ms([new hr("", '"zoom" expression may only be used as input to a top-level "step" or "interpolate" expression, or in the properties of atmosphere.')]);
      }
      class Ds {
        constructor(t22, e22) {
          this._parameters = t22, this._specification = e22, cr(this, As(this._parameters, this._specification));
        }
        static deserialize(t22) {
          return new Ds(t22._parameters, t22._specification);
        }
        static serialize(t22) {
          return { _parameters: t22._parameters, _specification: t22._specification };
        }
      }
      function Fs(t22) {
        let e22 = null;
        if (t22 instanceof ji) e22 = Fs(t22.result);
        else if (t22 instanceof Ni) {
          for (const r22 of t22.args) if (e22 = Fs(r22), e22) break;
        } else (t22 instanceof bi || t22 instanceof Oi) && t22.input instanceof Wr && "zoom" === t22.input.name && (e22 = t22);
        return e22 instanceof hr || t22.eachChild((t3) => {
          const r22 = Fs(t3);
          r22 instanceof hr ? e22 = r22 : e22 && r22 && e22 !== r22 && (e22 = new hr("", 'Only one zoom-based "step" or "interpolate" subexpression may be used in an expression.'));
        }), e22;
      }
      var Ls, Rs, Os = function() {
        if (Rs) return Ls;
        Rs = 1, Ls = e22;
        var t22 = 3;
        function e22(e3, r22, n22) {
          var i22 = this.cells = [];
          if (e3 instanceof ArrayBuffer) {
            this.arrayBuffer = e3;
            var s2 = new Int32Array(this.arrayBuffer);
            e3 = s2[0], this.d = (r22 = s2[1]) + 2 * (n22 = s2[2]);
            for (var o2 = 0; o2 < this.d * this.d; o2++) {
              var a22 = s2[t22 + o2], l22 = s2[t22 + o2 + 1];
              i22.push(a22 === l22 ? null : s2.subarray(a22, l22));
            }
            var u22 = s2[t22 + i22.length + 1];
            this.keys = s2.subarray(s2[t22 + i22.length], u22), this.bboxes = s2.subarray(u22), this.insert = this._insertReadonly;
          } else {
            this.d = r22 + 2 * n22;
            for (var c22 = 0; c22 < this.d * this.d; c22++) i22.push([]);
            this.keys = [], this.bboxes = [];
          }
          this.n = r22, this.extent = e3, this.padding = n22, this.scale = r22 / e3, this.uid = 0;
          var h22 = n22 / r22 * e3;
          this.min = -h22, this.max = e3 + h22;
        }
        return e22.prototype.insert = function(t3, e3, r22, n22, i22) {
          this._forEachCell(e3, r22, n22, i22, this._insertCell, this.uid++), this.keys.push(t3), this.bboxes.push(e3), this.bboxes.push(r22), this.bboxes.push(n22), this.bboxes.push(i22);
        }, e22.prototype._insertReadonly = function() {
          throw "Cannot insert into a GridIndex created from an ArrayBuffer.";
        }, e22.prototype._insertCell = function(t3, e3, r22, n22, i22, s2) {
          this.cells[i22].push(s2);
        }, e22.prototype.query = function(t3, e3, r22, n22, i22) {
          var s2 = this.min, o2 = this.max;
          if (t3 <= s2 && e3 <= s2 && o2 <= r22 && o2 <= n22 && !i22) return Array.prototype.slice.call(this.keys);
          var a22 = [];
          return this._forEachCell(t3, e3, r22, n22, this._queryCell, a22, {}, i22), a22;
        }, e22.prototype._queryCell = function(t3, e3, r22, n22, i22, s2, o2, a22) {
          var l22 = this.cells[i22];
          if (null !== l22) for (var u22 = this.keys, c22 = this.bboxes, h22 = 0; h22 < l22.length; h22++) {
            var p22 = l22[h22];
            if (void 0 === o2[p22]) {
              var f22 = 4 * p22;
              (a22 ? a22(c22[f22 + 0], c22[f22 + 1], c22[f22 + 2], c22[f22 + 3]) : t3 <= c22[f22 + 2] && e3 <= c22[f22 + 3] && r22 >= c22[f22 + 0] && n22 >= c22[f22 + 1]) ? (o2[p22] = true, s2.push(u22[p22])) : o2[p22] = false;
            }
          }
        }, e22.prototype._forEachCell = function(t3, e3, r22, n22, i22, s2, o2, a22) {
          for (var l22 = this._convertToCellCoord(t3), u22 = this._convertToCellCoord(e3), c22 = this._convertToCellCoord(r22), h22 = this._convertToCellCoord(n22), p22 = l22; p22 <= c22; p22++) for (var f22 = u22; f22 <= h22; f22++) {
            var d22 = this.d * f22 + p22;
            if ((!a22 || a22(this._convertFromCellCoord(p22), this._convertFromCellCoord(f22), this._convertFromCellCoord(p22 + 1), this._convertFromCellCoord(f22 + 1))) && i22.call(this, t3, e3, r22, n22, d22, s2, o2, a22)) return;
          }
        }, e22.prototype._convertFromCellCoord = function(t3) {
          return (t3 - this.padding) / this.scale;
        }, e22.prototype._convertToCellCoord = function(t3) {
          return Math.max(0, Math.min(this.d - 1, Math.floor(t3 * this.scale) + this.padding));
        }, e22.prototype.toArrayBuffer = function() {
          if (this.arrayBuffer) return this.arrayBuffer;
          for (var e3 = this.cells, r22 = t22 + this.cells.length + 1 + 1, n22 = 0, i22 = 0; i22 < this.cells.length; i22++) n22 += this.cells[i22].length;
          var s2 = new Int32Array(r22 + n22 + this.keys.length + this.bboxes.length);
          s2[0] = this.extent, s2[1] = this.n, s2[2] = this.padding;
          for (var o2 = r22, a22 = 0; a22 < e3.length; a22++) {
            var l22 = e3[a22];
            s2[t22 + a22] = o2, s2.set(l22, o2), o2 += l22.length;
          }
          return s2[t22 + e3.length] = o2, s2.set(this.keys, o2), s2[t22 + e3.length + 1] = o2 += this.keys.length, s2.set(this.bboxes, o2), o2 += this.bboxes.length, s2.buffer;
        }, Ls;
      }(), Us = dt(Os);
      const Ns = {};
      function js(t22, e22, r22 = {}) {
        Object.defineProperty(t22, "_classRegistryKey", { value: e22, writable: false }), Ns[e22] = { klass: t22, omit: r22.omit || [] };
      }
      js(Object, "Object"), Us.serialize = function(t22, e22) {
        const r22 = t22.toArrayBuffer();
        return e22 && e22.add(r22), { buffer: r22 };
      }, Us.deserialize = function(t22) {
        return new Us(t22.buffer);
      }, Object.defineProperty(Us, "name", { value: "Grid" }), js(Us, "Grid"), "undefined" != typeof DOMMatrix && js(DOMMatrix, "DOMMatrix"), js(ir, "Color"), js(Error, "Error"), js(Tr, "Formatted"), js(Pr, "FormattedSection"), js(Be, "AJAXError"), js(Vr, "ResolvedImage"), js(Ds, "StylePropertyFunction"), js(Es, "StyleExpression", { omit: ["_evaluator"] }), js(tr, "ImageId"), js(Br, "ImageVariant"), js(Vs, "ZoomDependentExpression"), js(Bs, "ZoomConstantExpression"), js(Wr, "CompoundExpression", { omit: ["_evaluate"] });
      for (const t22 in ls) Ns[ls[t22]._classRegistryKey] || js(ls[t22], `Expression${t22}`);
      function $s(t22) {
        return t22 && "undefined" != typeof ArrayBuffer && (t22 instanceof ArrayBuffer || t22.constructor && "ArrayBuffer" === t22.constructor.name);
      }
      function Gs(t22) {
        return self.ImageBitmap && t22 instanceof ImageBitmap;
      }
      function qs(t22, e22) {
        if (null == t22 || "boolean" == typeof t22 || "number" == typeof t22 || "string" == typeof t22 || t22 instanceof Boolean || t22 instanceof Number || t22 instanceof String || t22 instanceof Date || t22 instanceof RegExp) return t22;
        if ($s(t22) || Gs(t22)) return e22 && e22.add(t22), t22;
        if (ArrayBuffer.isView(t22)) return e22 && e22.add(t22.buffer), t22;
        if (t22 instanceof ImageData) return e22 && e22.add(t22.data.buffer), t22;
        if (Array.isArray(t22)) {
          const r22 = [];
          for (const n22 of t22) r22.push(qs(n22, e22));
          return r22;
        }
        if (t22 instanceof Map) {
          const r22 = { $name: "Map", entries: [] };
          for (const [n22, i22] of t22.entries()) r22.entries.push(qs(n22), qs(i22, e22));
          return r22;
        }
        if (t22 instanceof Set) {
          const e3 = { $name: "Set" };
          let r22 = 0;
          for (const n22 of t22.values()) e3[++r22] = qs(n22);
          return e3;
        }
        if (t22 instanceof DOMMatrix) {
          const e3 = { $name: "DOMMatrix" }, r22 = ["is2D", "m11", "m12", "m13", "m14", "m21", "m22", "m23", "m24", "m31", "m32", "m33", "m34", "m41", "m42", "m43", "m44", "a", "b", "c", "d", "e", "f"];
          for (const n22 of r22) e3[n22] = t22[n22];
          return e3;
        }
        if ("bigint" == typeof t22) return { $name: "BigInt", value: t22.toString() };
        if ("object" == typeof t22) {
          const r22 = t22.constructor, n22 = r22._classRegistryKey;
          if (!n22) throw new Error(`Can't serialize object of unregistered class "${r22.name}".`);
          const i22 = r22.serialize ? r22.serialize(t22, e22) : {};
          if (!r22.serialize) {
            for (const r3 in t22) t22.hasOwnProperty(r3) && (Ns[n22].omit.indexOf(r3) >= 0 || (i22[r3] = qs(t22[r3], e22)));
            t22 instanceof Error && (i22.message = t22.message);
          }
          if (i22.$name) throw new Error("$name property is reserved for worker serialization logic.");
          return "Object" !== n22 && (i22.$name = n22), i22;
        }
        throw new Error("can't serialize object of type " + typeof t22);
      }
      function Hs(t22) {
        if (null == t22 || "boolean" == typeof t22 || "number" == typeof t22 || "string" == typeof t22 || t22 instanceof Boolean || t22 instanceof Number || t22 instanceof String || t22 instanceof Date || t22 instanceof RegExp || $s(t22) || Gs(t22) || ArrayBuffer.isView(t22) || t22 instanceof ImageData) return t22;
        if (Array.isArray(t22)) return t22.map(Hs);
        if ("object" == typeof t22) {
          const e22 = t22.$name || "Object";
          if ("Map" === e22) {
            const e3 = t22.entries || [], r3 = /* @__PURE__ */ new Map();
            for (let t3 = 0; t3 < e3.length; t3 += 2) r3.set(Hs(e3[t3]), Hs(e3[t3 + 1]));
            return r3;
          }
          if ("Set" === e22) {
            const e3 = /* @__PURE__ */ new Set();
            for (const r3 of Object.keys(t22)) "$name" !== r3 && e3.add(Hs(t22[r3]));
            return e3;
          }
          if ("DOMMatrix" === e22) {
            let e3;
            return e3 = t22.is2D ? [t22.a, t22.b, t22.c, t22.d, t22.e, t22.f] : [t22.m11, t22.m12, t22.m13, t22.m14, t22.m21, t22.m22, t22.m23, t22.m24, t22.m31, t22.m32, t22.m33, t22.m34, t22.m41, t22.m42, t22.m43, t22.m44], new DOMMatrix(e3);
          }
          if ("BigInt" === e22) return BigInt(t22.value);
          const { klass: r22 } = Ns[e22];
          if (!r22) throw new Error(`Can't deserialize unregistered class "${e22}".`);
          if (r22.deserialize) return r22.deserialize(t22);
          const n22 = Object.create(r22.prototype);
          for (const e3 of Object.keys(t22)) "$name" !== e3 && (n22[e3] = Hs(t22[e3]));
          return n22;
        }
        throw new Error("can't deserialize object of type " + typeof t22);
      }
      const Xs = { "Latin-1 Supplement": (t22) => t22 >= 128 && t22 <= 255, Arabic: (t22) => t22 >= 1536 && t22 <= 1791, "Arabic Supplement": (t22) => t22 >= 1872 && t22 <= 1919, "Arabic Extended-A": (t22) => t22 >= 2208 && t22 <= 2303, "Hangul Jamo": (t22) => t22 >= 4352 && t22 <= 4607, "Unified Canadian Aboriginal Syllabics": (t22) => t22 >= 5120 && t22 <= 5759, Khmer: (t22) => t22 >= 6016 && t22 <= 6143, "Unified Canadian Aboriginal Syllabics Extended": (t22) => t22 >= 6320 && t22 <= 6399, "General Punctuation": (t22) => t22 >= 8192 && t22 <= 8303, "Letterlike Symbols": (t22) => t22 >= 8448 && t22 <= 8527, "Number Forms": (t22) => t22 >= 8528 && t22 <= 8591, "Miscellaneous Technical": (t22) => t22 >= 8960 && t22 <= 9215, "Control Pictures": (t22) => t22 >= 9216 && t22 <= 9279, "Optical Character Recognition": (t22) => t22 >= 9280 && t22 <= 9311, "Enclosed Alphanumerics": (t22) => t22 >= 9312 && t22 <= 9471, "Geometric Shapes": (t22) => t22 >= 9632 && t22 <= 9727, "Miscellaneous Symbols": (t22) => t22 >= 9728 && t22 <= 9983, "Miscellaneous Symbols and Arrows": (t22) => t22 >= 11008 && t22 <= 11263, "CJK Radicals Supplement": (t22) => t22 >= 11904 && t22 <= 12031, "Kangxi Radicals": (t22) => t22 >= 12032 && t22 <= 12255, "Ideographic Description Characters": (t22) => t22 >= 12272 && t22 <= 12287, "CJK Symbols and Punctuation": (t22) => t22 >= 12288 && t22 <= 12351, Hiragana: (t22) => t22 >= 12352 && t22 <= 12447, Katakana: (t22) => t22 >= 12448 && t22 <= 12543, Bopomofo: (t22) => t22 >= 12544 && t22 <= 12591, "Hangul Compatibility Jamo": (t22) => t22 >= 12592 && t22 <= 12687, Kanbun: (t22) => t22 >= 12688 && t22 <= 12703, "Bopomofo Extended": (t22) => t22 >= 12704 && t22 <= 12735, "CJK Strokes": (t22) => t22 >= 12736 && t22 <= 12783, "Katakana Phonetic Extensions": (t22) => t22 >= 12784 && t22 <= 12799, "Enclosed CJK Letters and Months": (t22) => t22 >= 12800 && t22 <= 13055, "CJK Compatibility": (t22) => t22 >= 13056 && t22 <= 13311, "CJK Unified Ideographs Extension A": (t22) => t22 >= 13312 && t22 <= 19903, "Yijing Hexagram Symbols": (t22) => t22 >= 19904 && t22 <= 19967, "CJK Unified Ideographs": (t22) => t22 >= 19968 && t22 <= 40959, "Yi Syllables": (t22) => t22 >= 40960 && t22 <= 42127, "Yi Radicals": (t22) => t22 >= 42128 && t22 <= 42191, "Hangul Jamo Extended-A": (t22) => t22 >= 43360 && t22 <= 43391, "Hangul Syllables": (t22) => t22 >= 44032 && t22 <= 55215, "Hangul Jamo Extended-B": (t22) => t22 >= 55216 && t22 <= 55295, "Private Use Area": (t22) => t22 >= 57344 && t22 <= 63743, "CJK Compatibility Ideographs": (t22) => t22 >= 63744 && t22 <= 64255, "Arabic Presentation Forms-A": (t22) => t22 >= 64336 && t22 <= 65023, "Vertical Forms": (t22) => t22 >= 65040 && t22 <= 65055, "CJK Compatibility Forms": (t22) => t22 >= 65072 && t22 <= 65103, "Small Form Variants": (t22) => t22 >= 65104 && t22 <= 65135, "Arabic Presentation Forms-B": (t22) => t22 >= 65136 && t22 <= 65279, "Halfwidth and Fullwidth Forms": (t22) => t22 >= 65280 && t22 <= 65519, Osage: (t22) => t22 >= 66736 && t22 <= 66815, "CJK Unified Ideographs Extension B": (t22) => t22 >= 131072 && t22 <= 173791 };
      function Zs(t22) {
        for (const e22 of t22) if (Ks(e22.charCodeAt(0))) return true;
        return false;
      }
      function Ws(t22) {
        for (const e22 of t22) if (!Ys(e22.charCodeAt(0))) return false;
        return true;
      }
      function Ys(t22) {
        return !(Xs.Arabic(t22) || Xs["Arabic Supplement"](t22) || Xs["Arabic Extended-A"](t22) || Xs["Arabic Presentation Forms-A"](t22) || Xs["Arabic Presentation Forms-B"](t22));
      }
      function Ks(t22) {
        return !(746 !== t22 && 747 !== t22 && (t22 < 4352 || !(Xs["Bopomofo Extended"](t22) || Xs.Bopomofo(t22) || Xs["CJK Compatibility Forms"](t22) && !(t22 >= 65097 && t22 <= 65103) || Xs["CJK Compatibility Ideographs"](t22) || Xs["CJK Compatibility"](t22) || Xs["CJK Radicals Supplement"](t22) || Xs["CJK Strokes"](t22) || !(!Xs["CJK Symbols and Punctuation"](t22) || t22 >= 12296 && t22 <= 12305 || t22 >= 12308 && t22 <= 12319 || 12336 === t22) || Xs["CJK Unified Ideographs Extension A"](t22) || Xs["CJK Unified Ideographs"](t22) || Xs["Enclosed CJK Letters and Months"](t22) || Xs["Hangul Compatibility Jamo"](t22) || Xs["Hangul Jamo Extended-A"](t22) || Xs["Hangul Jamo Extended-B"](t22) || Xs["Hangul Jamo"](t22) || Xs["Hangul Syllables"](t22) || Xs.Hiragana(t22) || Xs["Ideographic Description Characters"](t22) || Xs.Kanbun(t22) || Xs["Kangxi Radicals"](t22) || Xs["Katakana Phonetic Extensions"](t22) || Xs.Katakana(t22) && 12540 !== t22 || !(!Xs["Halfwidth and Fullwidth Forms"](t22) || 65288 === t22 || 65289 === t22 || 65293 === t22 || t22 >= 65306 && t22 <= 65310 || 65339 === t22 || 65341 === t22 || 65343 === t22 || t22 >= 65371 && t22 <= 65503 || 65507 === t22 || t22 >= 65512 && t22 <= 65519) || !(!Xs["Small Form Variants"](t22) || t22 >= 65112 && t22 <= 65118 || t22 >= 65123 && t22 <= 65126) || Xs["Unified Canadian Aboriginal Syllabics"](t22) || Xs["Unified Canadian Aboriginal Syllabics Extended"](t22) || Xs["Vertical Forms"](t22) || Xs["Yijing Hexagram Symbols"](t22) || Xs["Yi Syllables"](t22) || Xs["Yi Radicals"](t22))));
      }
      function Js(t22) {
        return !(Ks(t22) || function(t3) {
          return !!(Xs["Latin-1 Supplement"](t3) && (167 === t3 || 169 === t3 || 174 === t3 || 177 === t3 || 188 === t3 || 189 === t3 || 190 === t3 || 215 === t3 || 247 === t3) || Xs["General Punctuation"](t3) && (8214 === t3 || 8224 === t3 || 8225 === t3 || 8240 === t3 || 8241 === t3 || 8251 === t3 || 8252 === t3 || 8258 === t3 || 8263 === t3 || 8264 === t3 || 8265 === t3 || 8273 === t3) || Xs["Letterlike Symbols"](t3) || Xs["Number Forms"](t3) || Xs["Miscellaneous Technical"](t3) && (t3 >= 8960 && t3 <= 8967 || t3 >= 8972 && t3 <= 8991 || t3 >= 8996 && t3 <= 9e3 || 9003 === t3 || t3 >= 9085 && t3 <= 9114 || t3 >= 9150 && t3 <= 9165 || 9167 === t3 || t3 >= 9169 && t3 <= 9179 || t3 >= 9186 && t3 <= 9215) || Xs["Control Pictures"](t3) && 9251 !== t3 || Xs["Optical Character Recognition"](t3) || Xs["Enclosed Alphanumerics"](t3) || Xs["Geometric Shapes"](t3) || Xs["Miscellaneous Symbols"](t3) && !(t3 >= 9754 && t3 <= 9759) || Xs["Miscellaneous Symbols and Arrows"](t3) && (t3 >= 11026 && t3 <= 11055 || t3 >= 11088 && t3 <= 11097 || t3 >= 11192 && t3 <= 11243) || Xs["CJK Symbols and Punctuation"](t3) || Xs.Katakana(t3) || Xs["Private Use Area"](t3) || Xs["CJK Compatibility Forms"](t3) || Xs["Small Form Variants"](t3) || Xs["Halfwidth and Fullwidth Forms"](t3) || 8734 === t3 || 8756 === t3 || 8757 === t3 || t3 >= 9984 && t3 <= 10087 || t3 >= 10102 && t3 <= 10131 || 65532 === t3 || 65533 === t3);
        }(t22));
      }
      function Qs(t22) {
        return Xs.Arabic(t22) || Xs["Arabic Supplement"](t22) || Xs["Arabic Extended-A"](t22) || Xs["Arabic Presentation Forms-A"](t22) || Xs["Arabic Presentation Forms-B"](t22);
      }
      function to(t22) {
        return t22 >= 1424 && t22 <= 2303 || Xs["Arabic Presentation Forms-A"](t22) || Xs["Arabic Presentation Forms-B"](t22);
      }
      function eo(t22, e22) {
        return !(!e22 && to(t22) || t22 >= 2304 && t22 <= 3583 || t22 >= 3840 && t22 <= 4255 || Xs.Khmer(t22));
      }
      function ro(t22) {
        for (const e22 of t22) if (to(e22.charCodeAt(0))) return true;
        return false;
      }
      const no = "deferred", io = "loading", so = "loaded";
      let oo = null, ao = "unavailable", lo = null;
      const uo = function(t22) {
        t22 && "string" == typeof t22 && t22.indexOf("NetworkError") > -1 && (ao = "error"), oo && oo(t22);
      };
      function co() {
        ho.fire(new We("pluginStateChange", { pluginStatus: ao, pluginURL: lo }));
      }
      const ho = new Qe(), po = function() {
        return ao;
      }, fo = function() {
        if (ao !== no || !lo) throw new Error("rtl-text-plugin cannot be downloaded unless a pluginURL is specified");
        ao = io, co(), lo && De({ url: lo }, (t22) => {
          t22 ? uo(t22) : (ao = so, co());
        });
      }, mo = { applyArabicShaping: null, processBidirectionalText: null, processStyledBidirectionalText: null, isLoaded: () => ao === so || null != mo.applyArabicShaping, isLoading: () => ao === io, setState(t22) {
        ao = t22.pluginStatus, lo = t22.pluginURL;
      }, isParsed: () => null != mo.applyArabicShaping && null != mo.processBidirectionalText && null != mo.processStyledBidirectionalText, getPluginURL: () => lo };
      class yo {
        constructor(t22, e22) {
          this.zoom = t22, e22 ? (this.now = e22.now, this.fadeDuration = e22.fadeDuration, this.transition = e22.transition, this.pitch = e22.pitch, this.brightness = e22.brightness) : (this.now = 0, this.fadeDuration = 0, this.transition = {}, this.pitch = 0, this.brightness = 0);
        }
        isSupportedScript(t22) {
          return function(t3, e22) {
            for (const r22 of t3) if (!eo(r22.charCodeAt(0), e22)) return false;
            return true;
          }(t22, mo.isLoaded());
        }
      }
      class go {
        constructor(t22, e22, r22, n22) {
          this.property = t22, this.value = e22, this.expression = function(t3, e3, r3, n3) {
            if (_s(t3)) return new Ds(t3, e3);
            if (Ps(t3) || Array.isArray(t3) && t3.length > 0) {
              const i22 = Cs(t3, e3, r3, n3);
              if ("error" === i22.result) throw new Error(i22.value.map((t4) => `${t4.key}: ${t4.message}`).join(", "));
              return i22.value;
            }
            {
              let r4 = t3;
              return "string" == typeof t3 && "color" === e3.type && (r4 = ir.parse(t3)), { kind: "constant", configDependencies: /* @__PURE__ */ new Set(), evaluate: () => r4 };
            }
          }(void 0 === e22 ? t22.specification.default : e22, t22.specification, r22, n22);
        }
        isDataDriven() {
          return "source" === this.expression.kind || "composite" === this.expression.kind;
        }
        possiblyEvaluate(t22, e22, r22) {
          return this.property.possiblyEvaluate(this, t22, e22, r22);
        }
      }
      class xo {
        constructor(t22, e22, r22) {
          this.property = t22, this.value = new go(t22, void 0, e22, r22);
        }
        transitioned(t22, e22) {
          return new bo(this.property, this.value, e22, Ct2({}, t22.transition, this.transition), t22.now);
        }
        untransitioned() {
          return new bo(this.property, this.value, null, {}, 0);
        }
      }
      class vo {
        constructor(t22, e22, r22) {
          this._properties = t22, this._values = Object.create(t22.defaultTransitionablePropertyValues), this._scope = e22, this._options = r22, this.configDependencies = /* @__PURE__ */ new Set();
        }
        getValue(t22) {
          return Nt(this._values[t22].value.value);
        }
        setValue(t22, e22) {
          this._values.hasOwnProperty(t22) || (this._values[t22] = new xo(this._values[t22].property, this._scope, this._options)), this._values[t22].value = new go(this._values[t22].property, null === e22 ? void 0 : Nt(e22), this._scope, this._options), this._values[t22].value.expression.configDependencies && (this.configDependencies = /* @__PURE__ */ new Set([...this.configDependencies, ...this._values[t22].value.expression.configDependencies]));
        }
        setTransitionOrValue(t22, e22) {
          e22 && (this._options = e22);
          const r22 = this._properties.properties;
          if (t22) for (const e3 in t22) {
            const n22 = t22[e3];
            if (e3.endsWith("-transition")) {
              const t3 = e3.slice(0, -11);
              r22[t3] && this.setTransition(t3, n22);
            } else r22.hasOwnProperty(e3) && this.setValue(e3, n22);
          }
        }
        getTransition(t22) {
          return Nt(this._values[t22].transition);
        }
        setTransition(t22, e22) {
          this._values.hasOwnProperty(t22) || (this._values[t22] = new xo(this._values[t22].property)), this._values[t22].transition = Nt(e22) || void 0;
        }
        serialize() {
          const t22 = {};
          for (const e22 of Object.keys(this._values)) {
            const r22 = this.getValue(e22);
            void 0 !== r22 && (t22[e22] = r22);
            const n22 = this.getTransition(e22);
            void 0 !== n22 && (t22[`${e22}-transition`] = n22);
          }
          return t22;
        }
        transitioned(t22, e22) {
          const r22 = new _o(this._properties);
          for (const n22 of Object.keys(this._values)) r22._values[n22] = this._values[n22].transitioned(t22, e22._values[n22]);
          return r22;
        }
        untransitioned() {
          const t22 = new _o(this._properties);
          for (const e22 of Object.keys(this._values)) t22._values[e22] = this._values[e22].untransitioned();
          return t22;
        }
      }
      class bo {
        constructor(t22, e22, r22, n22, i22) {
          const s2 = n22.delay || 0, o2 = n22.duration || 0;
          i22 = i22 || 0, this.property = t22, this.value = e22, this.begin = i22 + s2, this.end = this.begin + o2, t22.specification.transition && (n22.delay || n22.duration) && (this.prior = r22);
        }
        possiblyEvaluate(t22, e22, r22) {
          const n22 = t22.now || 0, i22 = this.value.possiblyEvaluate(t22, e22, r22), s2 = this.prior;
          if (s2) {
            if (n22 > this.end) return this.prior = null, i22;
            if (this.value.isDataDriven()) return this.prior = null, i22;
            if (n22 < this.begin) return s2.possiblyEvaluate(t22, e22, r22);
            {
              const o2 = (n22 - this.begin) / (this.end - this.begin);
              return this.property.interpolate(s2.possiblyEvaluate(t22, e22, r22), i22, zt(o2));
            }
          }
          return i22;
        }
      }
      class _o {
        constructor(t22) {
          this._properties = t22, this._values = Object.create(t22.defaultTransitioningPropertyValues);
        }
        possiblyEvaluate(t22, e22, r22) {
          const n22 = new Mo(this._properties);
          for (const i22 of Object.keys(this._values)) n22._values[i22] = this._values[i22].possiblyEvaluate(t22, e22, r22);
          return n22;
        }
        hasTransition() {
          for (const t22 of Object.keys(this._values)) if (this._values[t22].prior) return true;
          return false;
        }
      }
      class wo {
        constructor(t22, e22, r22) {
          this._properties = t22, this._values = Object.create(t22.defaultPropertyValues), this._scope = e22, this._options = r22, this.configDependencies = /* @__PURE__ */ new Set();
        }
        getValue(t22) {
          return Nt(this._values[t22].value);
        }
        setValue(t22, e22) {
          this._values[t22] = new go(this._values[t22].property, null === e22 ? void 0 : Nt(e22), this._scope, this._options), this._values[t22].expression.configDependencies && (this.configDependencies = /* @__PURE__ */ new Set([...this.configDependencies, ...this._values[t22].expression.configDependencies]));
        }
        serialize() {
          const t22 = {};
          for (const e22 of Object.keys(this._values)) {
            const r22 = this.getValue(e22);
            void 0 !== r22 && (t22[e22] = r22);
          }
          return t22;
        }
        possiblyEvaluate(t22, e22, r22) {
          const n22 = new Mo(this._properties);
          for (const i22 of Object.keys(this._values)) n22._values[i22] = this._values[i22].possiblyEvaluate(t22, e22, r22);
          return n22;
        }
      }
      class Ao {
        constructor(t22, e22, r22) {
          this.property = t22, this.value = e22, this.parameters = r22;
        }
        isConstant() {
          return "constant" === this.value.kind;
        }
        constantOr(t22) {
          return "constant" === this.value.kind ? this.value.value : t22;
        }
        evaluate(t22, e22, r22, n22) {
          return this.property.evaluate(this.value, this.parameters, t22, e22, r22, n22);
        }
      }
      class Mo {
        constructor(t22) {
          this._properties = t22, this._values = Object.create(t22.defaultPossiblyEvaluatedValues);
        }
        get(t22) {
          return this._values[t22];
        }
      }
      class Io {
        constructor(t22) {
          this.specification = t22;
        }
        possiblyEvaluate(t22, e22) {
          return t22.expression.evaluate(e22);
        }
        interpolate(t22, e22, r22) {
          const n22 = ur[this.specification.type];
          return n22 ? n22(t22, e22, r22) : t22;
        }
      }
      class So {
        constructor(t22, e22) {
          this.specification = t22, this.overrides = e22;
        }
        possiblyEvaluate(t22, e22, r22, n22) {
          return new Ao(this, "constant" === t22.expression.kind || "camera" === t22.expression.kind ? { kind: "constant", value: t22.expression.evaluate(e22, null, {}, r22, n22) } : t22.expression, e22);
        }
        interpolate(t22, e22, r22) {
          if ("constant" !== t22.value.kind || "constant" !== e22.value.kind) return t22;
          if (void 0 === t22.value.value || void 0 === e22.value.value) return new Ao(this, { kind: "constant", value: void 0 }, t22.parameters);
          const n22 = ur[this.specification.type];
          return n22 ? new Ao(this, { kind: "constant", value: n22(t22.value.value, e22.value.value, r22) }, t22.parameters) : t22;
        }
        evaluate(t22, e22, r22, n22, i22, s2) {
          return "constant" === t22.kind ? t22.value : t22.evaluate(e22, r22, n22, i22, s2);
        }
      }
      class zo {
        constructor(t22) {
          this.specification = t22;
        }
        possiblyEvaluate(t22, e22, r22, n22) {
          return !!t22.expression.evaluate(e22, null, {}, r22, n22);
        }
        interpolate() {
          return false;
        }
      }
      class ko {
        constructor(t22) {
          this.properties = t22, this.defaultPropertyValues = {}, this.defaultTransitionablePropertyValues = {}, this.defaultTransitioningPropertyValues = {}, this.defaultPossiblyEvaluatedValues = {}, this.overridableProperties = [];
          const e22 = new yo(0, {});
          for (const r22 in t22) {
            const n22 = t22[r22];
            n22.specification.overridable && this.overridableProperties.push(r22);
            const i22 = this.defaultPropertyValues[r22] = new go(n22, void 0), s2 = this.defaultTransitionablePropertyValues[r22] = new xo(n22);
            this.defaultTransitioningPropertyValues[r22] = s2.untransitioned(), this.defaultPossiblyEvaluatedValues[r22] = i22.possiblyEvaluate(e22);
          }
        }
      }
      js(So, "DataDrivenProperty"), js(Io, "DataConstantProperty"), js(zo, "ColorRampProperty");
      var Eo = JSON.parse('{"$version":8,"$root":{"version":{"type":"enum","values":[8]},"fragment":{"type":"boolean"},"name":{"type":"string"},"metadata":{"type":"*"},"center":{"type":"array","value":"number"},"zoom":{"type":"number"},"bearing":{"type":"number","default":0,"period":360},"pitch":{"type":"number","default":0},"light":{"type":"light"},"lights":{"type":"array","value":"light-3d"},"terrain":{"type":"terrain","optional":true},"fog":{"type":"fog"},"snow":{"type":"snow"},"rain":{"type":"rain"},"camera":{"type":"camera"},"color-theme":{"type":"colorTheme"},"indoor":{"type":"indoor"},"imports":{"type":"array","value":"import"},"iconsets":{"type":"iconsets"},"schema":{"type":"schema"},"sources":{"type":"sources"},"sprite":{"type":"string"},"glyphs":{"type":"string","default":"mapbox://fonts/mapbox/{fontstack}/{range}.pbf"},"transition":{"type":"transition"},"projection":{"type":"projection"},"layers":{"type":"array","value":"layer"},"models":{"type":"models"},"featuresets":{"type":"featuresets"}},"featuresets":{"*":{"type":"featureset"}},"featureset":{"metadata":{"type":"*"},"selectors":{"type":"array","value":"selector"}},"selector":{"layer":{"type":"string"},"properties":{"type":"selectorProperty"},"featureNamespace":{"type":"string"},"_uniqueFeatureID":{"type":"boolean"}},"selectorProperty":{"*":{"type":"*"}},"model":{"type":"string"},"import":{"id":{"type":"string"},"url":{"type":"string"},"config":{"type":"config"},"data":{"type":"$root"},"color-theme":{"type":"colorTheme","optional":true}},"config":{"*":{"type":"*"}},"schema":{"*":{"type":"option"}},"option":{"default":{"type":"*","expression":{}},"type":{"type":"enum","values":{"string":1,"number":1,"boolean":1,"color":1}},"array":{"type":"boolean"},"minValue":{"type":"number"},"maxValue":{"type":"number"},"stepValue":{"type":"number"},"values":{"type":"array","value":"*"},"metadata":{"type":"*"}},"models":{"*":{"type":"model"}},"light-3d":{"id":{"type":"string"},"properties":{"type":"properties"},"type":{"type":"enum","values":{"ambient":{},"directional":{},"flat":{}}}},"properties":["properties_light_directional","properties_light_ambient","properties_light_flat"],"properties_light_directional":{"direction":{"type":"array","default":[210,30],"minimum":[0,0],"maximum":[360,90],"length":2,"value":"number","transition":true,"expression":{"interpolated":true,"parameters":["zoom"]}},"color":{"type":"color","default":"#ffffff","expression":{"interpolated":true,"parameters":["zoom"]},"transition":true},"intensity":{"type":"number","default":0.5,"minimum":0,"maximum":1,"expression":{"interpolated":true,"parameters":["zoom"]},"transition":true},"cast-shadows":{"type":"boolean","default":false},"shadow-quality":{"type":"number","default":1,"minimum":0,"maximum":1,"expression":{"parameters":["zoom"]}},"shadow-intensity":{"type":"number","default":1,"minimum":0,"maximum":1,"expression":{"interpolated":true,"parameters":["zoom"]},"transition":true}},"properties_light_ambient":{"color":{"type":"color","default":"#ffffff","expression":{"interpolated":true,"parameters":["zoom"]},"transition":true},"intensity":{"type":"number","default":0.5,"minimum":0,"maximum":1,"expression":{"interpolated":true,"parameters":["zoom"]},"transition":true}},"properties_light_flat":{"anchor":{"type":"enum","default":"viewport","values":{"map":1,"viewport":1},"expression":{"parameters":["zoom"]}},"position":{"type":"array","default":[1.15,210,30],"length":3,"value":"number","transition":true,"expression":{"interpolated":true,"parameters":["zoom"]}},"color":{"type":"color","default":"#ffffff","expression":{"interpolated":true,"parameters":["zoom"]},"transition":true},"intensity":{"type":"number","default":0.5,"minimum":0,"maximum":1,"expression":{"interpolated":true,"parameters":["zoom"]},"transition":true}},"iconsets":{"*":{"type":"iconset"}},"iconset":["iconset_sprite","iconset_source"],"iconset_sprite":{"type":{"type":"enum","values":{"sprite":1}},"url":{"type":"string"}},"iconset_source":{"type":{"type":"enum","values":{"source":1}},"source":{"type":"string"}},"sources":{"*":{"type":"source"}},"source":["source_vector","source_raster","source_raster_dem","source_raster_array","source_geojson","source_video","source_image","source_model"],"source_vector":{"type":{"type":"enum","values":{"vector":1}},"url":{"type":"string"},"tiles":{"type":"array","value":"string"},"bounds":{"type":"array","value":"number","length":4,"default":[-180,-85.051129,180,85.051129]},"extra_bounds":{"type":"array","value":{"type":"array","value":"number","length":4}},"scheme":{"type":"enum","values":{"xyz":1,"tms":1},"default":"xyz"},"minzoom":{"type":"number","default":0},"maxzoom":{"type":"number","default":22},"attribution":{"type":"string"},"promoteId":{"type":"promoteId"},"volatile":{"type":"boolean","default":false},"*":{"type":"*"}},"source_raster":{"type":{"type":"enum","values":{"raster":1}},"url":{"type":"string"},"tiles":{"type":"array","value":"string"},"bounds":{"type":"array","value":"number","length":4,"default":[-180,-85.051129,180,85.051129]},"extra_bounds":{"type":"array","value":{"type":"array","value":"number","length":4}},"minzoom":{"type":"number","default":0},"maxzoom":{"type":"number","default":22},"tileSize":{"type":"number","default":512},"scheme":{"type":"enum","values":{"xyz":1,"tms":1},"default":"xyz"},"attribution":{"type":"string"},"volatile":{"type":"boolean","default":false},"*":{"type":"*"}},"source_raster_dem":{"type":{"type":"enum","values":{"raster-dem":1}},"url":{"type":"string"},"tiles":{"type":"array","value":"string"},"bounds":{"type":"array","value":"number","length":4,"default":[-180,-85.051129,180,85.051129]},"extra_bounds":{"type":"array","value":{"type":"array","value":"number","length":4}},"minzoom":{"type":"number","default":0},"maxzoom":{"type":"number","default":22},"tileSize":{"type":"number","default":512},"attribution":{"type":"string"},"encoding":{"type":"enum","values":{"terrarium":1,"mapbox":1},"default":"mapbox"},"volatile":{"type":"boolean","default":false},"*":{"type":"*"}},"source_raster_array":{"type":{"type":"enum","values":{"raster-array":1}},"url":{"type":"string"},"tiles":{"type":"array","value":"string"},"bounds":{"type":"array","value":"number","length":4,"default":[-180,-85.051129,180,85.051129]},"extra_bounds":{"type":"array","value":{"type":"array","value":"number","length":4}},"minzoom":{"type":"number","default":0},"maxzoom":{"type":"number","default":22},"tileSize":{"type":"number","default":512},"attribution":{"type":"string"},"rasterLayers":{"type":"*"},"volatile":{"type":"boolean","default":false},"*":{"type":"*"}},"source_geojson":{"type":{"type":"enum","values":{"geojson":1}},"data":{"type":"*"},"maxzoom":{"type":"number","default":18},"minzoom":{"type":"number","default":0},"attribution":{"type":"string"},"buffer":{"type":"number","default":128,"maximum":512,"minimum":0},"filter":{"type":"*"},"tolerance":{"type":"number","default":0.375},"cluster":{"type":"boolean","default":false},"clusterRadius":{"type":"number","default":50,"minimum":0},"clusterMaxZoom":{"type":"number"},"clusterMinPoints":{"type":"number"},"clusterProperties":{"type":"*"},"lineMetrics":{"type":"boolean","default":false},"generateId":{"type":"boolean","default":false},"promoteId":{"type":"promoteId"},"dynamic":{"type":"boolean","default":false}},"source_video":{"type":{"type":"enum","values":{"video":1}},"urls":{"type":"array","value":"string"},"coordinates":{"type":"array","length":4,"value":{"type":"array","length":2,"value":"number"}}},"source_image":{"type":{"type":"enum","values":{"image":1}},"url":{"type":"string"},"coordinates":{"type":"array","length":4,"value":{"type":"array","length":2,"value":"number"}}},"source_model":{"type":{"type":"enum","values":{"model":1,"batched-model":1}},"maxzoom":{"type":"number","default":18},"minzoom":{"type":"number","default":0},"tiles":{"type":"array","value":"string"}},"layer":{"id":{"type":"string"},"type":{"type":"enum","values":{"fill":{},"line":{},"symbol":{},"circle":{},"heatmap":{},"fill-extrusion":{},"building":{},"raster":{},"raster-particle":{},"hillshade":{},"model":{},"background":{},"sky":{},"slot":{},"clip":{}}},"metadata":{"type":"*"},"source":{"type":"string"},"source-layer":{"type":"string"},"slot":{"type":"string"},"minzoom":{"type":"number","minimum":0,"maximum":24},"maxzoom":{"type":"number","minimum":0,"maximum":24},"filter":{"type":"filter"},"layout":{"type":"layout"},"paint":{"type":"paint"}},"layout":["layout_clip","layout_fill","layout_line","layout_circle","layout_heatmap","layout_fill-extrusion","layout_building","layout_symbol","layout_raster","layout_raster-particle","layout_hillshade","layout_background","layout_sky","layout_model"],"layout_background":{"visibility":{"type":"enum","values":{"visible":1,"none":1},"default":"visible","expression":{}}},"layout_sky":{"visibility":{"type":"enum","values":{"visible":1,"none":1},"default":"visible","expression":{}}},"layout_model":{"visibility":{"type":"enum","values":{"visible":1,"none":1},"default":"visible","expression":{}},"model-id":{"type":"string","default":"","property-type":"data-driven","expression":{"parameters":["zoom","feature"]}}},"layout_clip":{"clip-layer-types":{"type":"array","value":"enum","values":{"model":1,"symbol":1},"default":[],"expression":{}},"clip-layer-scope":{"type":"array","value":"string","default":[],"expression":{}}},"layout_fill":{"fill-sort-key":{"type":"number","expression":{"parameters":["zoom","feature"]},"property-type":"data-driven"},"visibility":{"type":"enum","values":{"visible":1,"none":1},"default":"visible","expression":{}},"fill-elevation-reference":{"type":"enum","values":{"none":1,"hd-road-base":1,"hd-road-markup":1},"default":"none","expression":{}},"fill-construct-bridge-guard-rail":{"type":"boolean","default":"true","expression":{"parameters":["zoom","feature"]},"property-type":"data-driven"}},"layout_circle":{"circle-sort-key":{"type":"number","expression":{"parameters":["zoom","feature"]},"property-type":"data-driven"},"circle-elevation-reference":{"type":"enum","values":{"none":1,"hd-road-markup":1},"default":"none","expression":{}},"visibility":{"type":"enum","values":{"visible":1,"none":1},"default":"visible","expression":{}}},"layout_heatmap":{"visibility":{"type":"enum","values":{"visible":1,"none":1},"default":"visible","expression":{}}},"layout_fill-extrusion":{"visibility":{"type":"enum","values":{"visible":1,"none":1},"default":"visible","expression":{}},"fill-extrusion-edge-radius":{"type":"number","default":0,"minimum":0,"maximum":1,"expression":{}}},"layout_building":{"visibility":{"type":"enum","values":{"visible":1,"none":1},"default":"visible","expression":{}},"building-roof-shape":{"type":"enum","values":{"flat":1,"hipped":1,"gabled":1,"parapet":1,"mansard":1,"skillion":1,"pyramidal":1},"default":"flat","expression":{"parameters":["feature"]},"property-type":"data-driven"},"building-height":{"type":"number","default":0,"minimum":0,"transition":true,"expression":{},"property-type":"data-driven"},"building-base":{"type":"number","default":0,"minimum":0,"transition":true,"expression":{},"property-type":"data-driven"}},"layout_line":{"line-cap":{"type":"enum","values":{"butt":1,"round":1,"square":1},"default":"butt","expression":{"parameters":["zoom","feature"]},"property-type":"data-driven"},"line-join":{"type":"enum","values":{"bevel":1,"round":1,"miter":1,"none":1},"default":"miter","expression":{"parameters":["zoom","feature"]},"property-type":"data-driven"},"line-miter-limit":{"type":"number","default":2,"expression":{"interpolated":true,"parameters":["zoom"]}},"line-round-limit":{"type":"number","default":1.05,"expression":{"interpolated":true,"parameters":["zoom"]}},"line-sort-key":{"type":"number","expression":{"parameters":["zoom","feature"]},"property-type":"data-driven"},"line-z-offset":{"type":"number","default":0,"expression":{"parameters":["zoom","feature","line-progress"]},"property-type":"data-driven"},"line-elevation-reference":{"type":"enum","values":{"none":1,"sea":1,"ground":1,"hd-road-markup":1},"default":"none","expression":{}},"line-cross-slope":{"type":"number","expression":{}},"visibility":{"type":"enum","values":{"visible":1,"none":1},"default":"visible","expression":{}},"line-width-unit":{"type":"enum","values":{"pixels":1,"meters":1},"default":"pixels","expression":{"parameters":["zoom"]}}},"layout_symbol":{"symbol-placement":{"type":"enum","values":{"point":1,"line":1,"line-center":1},"default":"point","expression":{"parameters":["zoom"]}},"symbol-spacing":{"type":"number","default":250,"minimum":1,"expression":{"interpolated":true,"parameters":["zoom"]}},"symbol-avoid-edges":{"type":"boolean","default":false,"expression":{"parameters":["zoom"]}},"symbol-sort-key":{"type":"number","expression":{"parameters":["zoom","feature"]},"property-type":"data-driven"},"symbol-z-order":{"type":"enum","values":{"auto":1,"viewport-y":1,"source":1},"default":"auto","expression":{"parameters":["zoom"]}},"symbol-z-elevate":{"type":"boolean","default":false,"expression":{"parameters":["zoom"]}},"symbol-elevation-reference":{"type":"enum","values":{"sea":1,"ground":1,"hd-road-markup":1},"default":"ground","expression":{"parameters":["zoom"]}},"icon-allow-overlap":{"type":"boolean","default":false,"expression":{"parameters":["zoom"]}},"icon-ignore-placement":{"type":"boolean","default":false,"expression":{"parameters":["zoom"]}},"icon-optional":{"type":"boolean","default":false,"expression":{"parameters":["zoom"]}},"icon-rotation-alignment":{"type":"enum","values":{"map":1,"viewport":1,"auto":1},"default":"auto","expression":{"parameters":["zoom"]}},"icon-size":{"type":"number","default":1,"minimum":0,"expression":{"interpolated":true,"parameters":["zoom","feature"]},"property-type":"data-driven"},"icon-size-scale-range":{"type":"array","value":"number","length":2,"default":[0.8,2],"minimum":0.1,"maximum":10,"expression":{}},"icon-text-fit":{"type":"enum","values":{"none":1,"width":1,"height":1,"both":1},"default":"none","expression":{"parameters":["zoom","feature"]},"property-type":"data-driven"},"icon-text-fit-padding":{"type":"array","value":"number","length":4,"default":[0,0,0,0],"expression":{"interpolated":true,"parameters":["zoom","feature"]},"property-type":"data-driven"},"icon-image":{"type":"resolvedImage","tokens":true,"expression":{"parameters":["zoom","feature"]},"property-type":"data-driven"},"icon-rotate":{"type":"number","default":0,"period":360,"expression":{"interpolated":true,"parameters":["zoom","feature"]},"property-type":"data-driven"},"icon-padding":{"type":"number","default":2,"minimum":0,"expression":{"interpolated":true,"parameters":["zoom"]}},"icon-keep-upright":{"type":"boolean","default":false,"expression":{"parameters":["zoom"]}},"icon-offset":{"type":"array","value":"number","length":2,"default":[0,0],"expression":{"interpolated":true,"parameters":["zoom","feature"]},"property-type":"data-driven"},"icon-anchor":{"type":"enum","values":{"center":1,"left":1,"right":1,"top":1,"bottom":1,"top-left":1,"top-right":1,"bottom-left":1,"bottom-right":1},"default":"center","expression":{"parameters":["zoom","feature"]},"property-type":"data-driven"},"icon-pitch-alignment":{"type":"enum","values":{"map":1,"viewport":1,"auto":1},"default":"auto","expression":{"parameters":["zoom"]}},"text-pitch-alignment":{"type":"enum","values":{"map":1,"viewport":1,"auto":1},"default":"auto","expression":{"parameters":["zoom"]}},"text-rotation-alignment":{"type":"enum","values":{"map":1,"viewport":1,"auto":1},"default":"auto","expression":{"parameters":["zoom"]}},"text-field":{"type":"formatted","default":"","tokens":true,"expression":{"parameters":["zoom","feature"]},"property-type":"data-driven"},"text-font":{"type":"array","value":"string","default":["Open Sans Regular","Arial Unicode MS Regular"],"expression":{"parameters":["zoom","feature"]},"property-type":"data-driven"},"text-size":{"type":"number","default":16,"minimum":0,"expression":{"interpolated":true,"parameters":["zoom","feature"]},"property-type":"data-driven"},"text-size-scale-range":{"type":"array","value":"number","length":2,"default":[0.8,2],"minimum":0.1,"maximum":10,"expression":{}},"text-max-width":{"type":"number","default":10,"minimum":0,"expression":{"interpolated":true,"parameters":["zoom","feature"]},"property-type":"data-driven"},"text-line-height":{"type":"number","default":1.2,"expression":{"interpolated":true,"parameters":["zoom","feature"]},"property-type":"data-driven"},"text-letter-spacing":{"type":"number","default":0,"expression":{"interpolated":true,"parameters":["zoom","feature"]},"property-type":"data-driven"},"text-justify":{"type":"enum","values":{"auto":1,"left":1,"center":1,"right":1},"default":"center","expression":{"parameters":["zoom","feature"]},"property-type":"data-driven"},"text-radial-offset":{"type":"number","default":0,"property-type":"data-driven","expression":{"interpolated":true,"parameters":["zoom","feature"]}},"text-variable-anchor":{"type":"array","value":"enum","values":{"center":1,"left":1,"right":1,"top":1,"bottom":1,"top-left":1,"top-right":1,"bottom-left":1,"bottom-right":1},"expression":{"parameters":["zoom"]}},"text-anchor":{"type":"enum","values":{"center":1,"left":1,"right":1,"top":1,"bottom":1,"top-left":1,"top-right":1,"bottom-left":1,"bottom-right":1},"default":"center","expression":{"parameters":["zoom","feature"]},"property-type":"data-driven"},"text-max-angle":{"type":"number","default":45,"expression":{"interpolated":true,"parameters":["zoom"]}},"text-writing-mode":{"type":"array","value":"enum","values":{"horizontal":1,"vertical":1},"expression":{"parameters":["zoom"]}},"text-rotate":{"type":"number","default":0,"period":360,"expression":{"interpolated":true,"parameters":["zoom","feature"]},"property-type":"data-driven"},"text-padding":{"type":"number","default":2,"minimum":0,"expression":{"interpolated":true,"parameters":["zoom"]}},"text-keep-upright":{"type":"boolean","default":true,"expression":{"parameters":["zoom"]}},"text-transform":{"type":"enum","values":{"none":1,"uppercase":1,"lowercase":1},"default":"none","expression":{"parameters":["zoom","feature"]},"property-type":"data-driven"},"text-offset":{"type":"array","value":"number","length":2,"default":[0,0],"expression":{"interpolated":true,"parameters":["zoom","feature"]},"property-type":"data-driven"},"text-allow-overlap":{"type":"boolean","default":false,"expression":{"parameters":["zoom"]}},"text-ignore-placement":{"type":"boolean","default":false,"expression":{"parameters":["zoom"]}},"text-optional":{"type":"boolean","default":false,"expression":{"parameters":["zoom"]}},"visibility":{"type":"enum","values":{"visible":1,"none":1},"default":"visible","expression":{}}},"layout_raster":{"visibility":{"type":"enum","values":{"visible":1,"none":1},"default":"visible","expression":{}}},"layout_raster-particle":{"visibility":{"type":"enum","values":{"visible":1,"none":1},"default":"visible","expression":{}}},"layout_hillshade":{"visibility":{"type":"enum","values":{"visible":1,"none":1},"default":"visible","expression":{}}},"filter":{"type":"array","value":"*"},"filter_symbol":{"type":"boolean","default":false,"property-type":"data-driven","expression":{"parameters":["zoom","feature","pitch","distance-from-center"]}},"filter_fill":{"type":"boolean","default":false,"property-type":"data-driven","expression":{"parameters":["zoom","feature"]}},"filter_hillshade":{"type":"boolean","default":false,"property-type":"data-driven","expression":{"parameters":["zoom","feature"]}},"filter_raster":{"type":"boolean","default":false,"property-type":"data-driven","expression":{"parameters":["zoom","feature"]}},"filter_raster-particle":{"type":"boolean","default":false,"property-type":"data-driven","expression":{"parameters":["zoom","feature"]}},"filter_clip":{"type":"boolean","default":false,"property-type":"data-driven","expression":{"parameters":["zoom","feature"]}},"filter_model":{"type":"boolean","default":false,"property-type":"data-driven","expression":{"parameters":["zoom","feature"]}},"filter_line":{"type":"boolean","default":false,"property-type":"data-driven","expression":{"parameters":["zoom","feature"]}},"filter_circle":{"type":"boolean","default":false,"property-type":"data-driven","expression":{"parameters":["zoom","feature"]}},"filter_fill-extrusion":{"type":"boolean","default":false,"property-type":"data-driven","expression":{"parameters":["zoom","feature"]}},"filter_building":{"type":"boolean","default":false,"property-type":"data-driven","expression":{"parameters":["zoom","feature"]}},"filter_heatmap":{"type":"boolean","default":false,"property-type":"data-driven","expression":{"parameters":["zoom","feature"]}},"filter_operator":{"type":"enum","values":{"==":1,"!=":1,">":1,">=":1,"<":1,"<=":1,"in":1,"!in":1,"all":1,"any":1,"none":1,"has":1,"!has":1}},"geometry_type":{"type":"enum","values":{"Point":1,"LineString":1,"Polygon":1}},"function":{"expression":{"type":"expression"},"stops":{"type":"array","value":"function_stop"},"base":{"type":"number","default":1,"minimum":0},"property":{"type":"string","default":"$zoom"},"type":{"type":"enum","values":{"identity":1,"exponential":1,"interval":1,"categorical":1},"default":"exponential"},"colorSpace":{"type":"enum","values":{"rgb":1,"lab":1,"hcl":1},"default":"rgb"},"default":{"type":"*"}},"function_stop":{"type":"array","minimum":0,"maximum":24,"value":["number","color"],"length":2},"expression":{"type":"array","value":"*","minimum":1},"fog":{"range":{"type":"array","default":[0.5,10],"minimum":-20,"maximum":20,"length":2,"value":"number","transition":true,"expression":{"interpolated":true,"parameters":["zoom","measure-light"],"relaxZoomRestriction":true}},"color":{"type":"color","default":"#ffffff","expression":{"interpolated":true,"parameters":["zoom","measure-light"],"relaxZoomRestriction":true},"transition":true},"high-color":{"type":"color","default":"#245cdf","expression":{"interpolated":true,"parameters":["zoom","measure-light"],"relaxZoomRestriction":true},"transition":true},"space-color":{"type":"color","default":["interpolate",["linear"],["zoom"],4,"#010b19",7,"#367ab9"],"expression":{"interpolated":true,"parameters":["zoom","measure-light"],"relaxZoomRestriction":true},"transition":true},"horizon-blend":{"type":"number","default":["interpolate",["linear"],["zoom"],4,0.2,7,0.1],"minimum":0,"maximum":1,"expression":{"interpolated":true,"parameters":["zoom","measure-light"],"relaxZoomRestriction":true},"transition":true},"star-intensity":{"type":"number","default":["interpolate",["linear"],["zoom"],5,0.35,6,0],"minimum":0,"maximum":1,"expression":{"interpolated":true,"parameters":["zoom","measure-light"],"relaxZoomRestriction":true},"transition":true},"vertical-range":{"type":"array","default":[0,0],"minimum":0,"length":2,"value":"number","transition":true,"expression":{"interpolated":true,"parameters":["zoom","measure-light"],"relaxZoomRestriction":true}}},"snow":{"density":{"type":"number","default":["interpolate",["linear"],["zoom"],11,0,13,0.85],"minimum":0,"maximum":1,"expression":{"interpolated":true,"parameters":["zoom","measure-light"],"relaxZoomRestriction":true},"transition":true},"intensity":{"type":"number","default":1,"minimum":0,"maximum":1,"expression":{"interpolated":true,"parameters":["zoom","measure-light"],"relaxZoomRestriction":true},"transition":true},"color":{"type":"color","default":"#ffffff","expression":{"interpolated":true,"parameters":["zoom","measure-light"],"relaxZoomRestriction":true},"transition":true},"opacity":{"type":"number","default":1,"minimum":0,"maximum":1,"expression":{"interpolated":true,"parameters":["zoom","measure-light"],"relaxZoomRestriction":true},"transition":true},"vignette":{"type":"number","default":["interpolate",["linear"],["zoom"],11,0,13,0.3],"minimum":0,"maximum":1,"expression":{"interpolated":true,"parameters":["zoom","measure-light"],"relaxZoomRestriction":true},"transition":true},"vignette-color":{"type":"color","default":"#ffffff","expression":{"interpolated":true,"parameters":["zoom","measure-light"],"relaxZoomRestriction":true},"transition":true},"center-thinning":{"type":"number","default":0.4,"minimum":0,"maximum":1,"expression":{"interpolated":true,"parameters":["zoom","measure-light"],"relaxZoomRestriction":true},"transition":true},"direction":{"type":"array","default":[0,50],"minimum":0,"maximum":360,"length":2,"value":"number","transition":true,"expression":{"interpolated":true,"parameters":["zoom","measure-light"],"relaxZoomRestriction":true}},"flake-size":{"type":"number","default":0.71,"minimum":0,"maximum":5,"expression":{"interpolated":true,"parameters":["zoom","measure-light"],"relaxZoomRestriction":true},"transition":true}},"rain":{"density":{"type":"number","default":["interpolate",["linear"],["zoom"],11,0,13,0.5],"minimum":0,"maximum":1,"expression":{"interpolated":true,"parameters":["zoom","measure-light"],"relaxZoomRestriction":true},"transition":true},"intensity":{"type":"number","default":1,"minimum":0,"maximum":1,"expression":{"interpolated":true,"parameters":["zoom","measure-light"],"relaxZoomRestriction":true},"transition":true},"color":{"type":"color","default":["interpolate",["linear"],["measure-light","brightness"],0,"#03113d",0.3,"#a8adbc"],"expression":{"interpolated":true,"parameters":["zoom","measure-light"],"relaxZoomRestriction":true},"transition":true},"opacity":{"type":"number","default":["interpolate",["linear"],["measure-light","brightness"],0,0.88,1,0.7],"minimum":0,"maximum":1,"expression":{"interpolated":true,"parameters":["zoom","measure-light"],"relaxZoomRestriction":true},"transition":true},"vignette":{"type":"number","default":["interpolate",["linear"],["zoom"],11,0,13,1],"minimum":0,"maximum":1,"expression":{"interpolated":true,"parameters":["zoom","measure-light"],"relaxZoomRestriction":true},"transition":true},"vignette-color":{"type":"color","default":["interpolate",["linear"],["measure-light","brightness"],0,"#001736",0.3,"#464646"],"expression":{"interpolated":true,"parameters":["zoom","measure-light"],"relaxZoomRestriction":true},"transition":true},"center-thinning":{"type":"number","default":0.57,"minimum":0,"maximum":1,"expression":{"interpolated":true,"parameters":["zoom","measure-light"],"relaxZoomRestriction":true},"transition":true},"direction":{"type":"array","default":[0,80],"minimum":0,"maximum":360,"length":2,"value":"number","transition":true,"expression":{"interpolated":true,"parameters":["zoom","measure-light"],"relaxZoomRestriction":true}},"droplet-size":{"type":"array","default":[2.6,18.2],"minimum":0,"maximum":50,"length":2,"value":"number","transition":true,"expression":{"interpolated":true,"parameters":["zoom","measure-light"],"relaxZoomRestriction":true}},"distortion-strength":{"type":"number","default":0.7,"minimum":0,"maximum":1,"expression":{"interpolated":true,"parameters":["zoom","measure-light"],"relaxZoomRestriction":true},"transition":true}},"camera":{"camera-projection":{"type":"enum","values":{"perspective":1,"orthographic":1},"transition":true,"expression":{"interpolated":true,"parameters":["zoom"]},"default":"perspective"}},"colorTheme":{"data":{"type":"string","expression":{}}},"indoor":{"floorplanFeaturesetId":{"type":"string","expression":{}},"buildingFeaturesetId":{"type":"string","expression":{}}},"light":{"anchor":{"type":"enum","default":"viewport","values":{"map":1,"viewport":1},"expression":{"parameters":["zoom"]}},"position":{"type":"array","default":[1.15,210,30],"length":3,"value":"number","transition":true,"expression":{"interpolated":true,"parameters":["zoom"]}},"color":{"type":"color","default":"#ffffff","expression":{"interpolated":true,"parameters":["zoom"]},"transition":true},"intensity":{"type":"number","default":0.5,"minimum":0,"maximum":1,"expression":{"interpolated":true,"parameters":["zoom"]},"transition":true}},"projection":{"name":{"type":"enum","values":{"albers":1,"equalEarth":1,"equirectangular":1,"lambertConformalConic":1,"mercator":1,"naturalEarth":1,"winkelTripel":1,"globe":1},"default":"mercator"},"center":{"type":"array","length":2,"value":"number","minimum":[-180,-90],"maximum":[180,90]},"parallels":{"type":"array","length":2,"value":"number","minimum":[-90,-90],"maximum":[90,90]}},"terrain":{"source":{"type":"string"},"exaggeration":{"type":"number","default":1,"minimum":0,"maximum":1000,"expression":{"interpolated":true,"parameters":["zoom"]},"transition":true}},"paint":["paint_fill","paint_line","paint_circle","paint_heatmap","paint_fill-extrusion","paint_building","paint_symbol","paint_raster","paint_raster-particle","paint_hillshade","paint_background","paint_sky","paint_model"],"paint_fill":{"fill-antialias":{"type":"boolean","default":true,"expression":{"parameters":["zoom"]}},"fill-opacity":{"type":"number","default":1,"minimum":0,"maximum":1,"transition":true,"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state","measure-light"]},"property-type":"data-driven"},"fill-color":{"type":"color","default":"#000000","transition":true,"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state","measure-light"]},"property-type":"data-driven"},"fill-outline-color":{"type":"color","transition":true,"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state","measure-light"]},"property-type":"data-driven"},"fill-translate":{"type":"array","value":"number","length":2,"default":[0,0],"transition":true,"expression":{"interpolated":true,"parameters":["zoom"]}},"fill-translate-anchor":{"type":"enum","values":{"map":1,"viewport":1},"default":"map","expression":{"parameters":["zoom"]}},"fill-pattern":{"type":"resolvedImage","expression":{"parameters":["zoom","feature"]},"property-type":"data-driven"},"fill-pattern-cross-fade":{"type":"number","default":0,"minimum":0,"maximum":1,"expression":{"interpolated":true,"parameters":["zoom","measure-light"]},"transition":true},"fill-emissive-strength":{"type":"number","default":0,"minimum":0,"transition":true,"expression":{"interpolated":true,"parameters":["zoom","measure-light"]}},"fill-z-offset":{"type":"number","default":0,"minimum":0,"transition":true,"expression":{"interpolated":true,"parameters":["zoom","feature"]},"property-type":"data-driven"},"fill-bridge-guard-rail-color":{"type":"color","default":"rgba(241, 236, 225, 255)","transition":true,"expression":{"interpolated":true,"parameters":["zoom","measure-light","feature"]},"property-type":"data-driven"},"fill-tunnel-structure-color":{"type":"color","default":"rgba(241, 236, 225, 255)","transition":true,"expression":{"interpolated":true,"parameters":["zoom","measure-light","feature"]},"property-type":"data-driven"}},"paint_fill-extrusion":{"fill-extrusion-opacity":{"type":"number","default":1,"minimum":0,"maximum":1,"transition":true,"expression":{"interpolated":true,"parameters":["zoom"]}},"fill-extrusion-color":{"type":"color","default":"#000000","transition":true,"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state","measure-light"]},"property-type":"data-driven"},"fill-extrusion-translate":{"type":"array","value":"number","length":2,"default":[0,0],"transition":true,"expression":{"interpolated":true,"parameters":["zoom"]}},"fill-extrusion-translate-anchor":{"type":"enum","values":{"map":1,"viewport":1},"default":"map","expression":{"parameters":["zoom"]}},"fill-extrusion-pattern":{"type":"resolvedImage","expression":{"parameters":["zoom","feature"]},"property-type":"data-driven"},"fill-extrusion-pattern-cross-fade":{"type":"number","default":0,"minimum":0,"maximum":1,"expression":{"interpolated":true,"parameters":["zoom","measure-light"]},"transition":true},"fill-extrusion-height":{"type":"number","default":0,"minimum":0,"transition":true,"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state"]},"property-type":"data-driven"},"fill-extrusion-base":{"type":"number","default":0,"minimum":0,"transition":true,"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state"]},"property-type":"data-driven"},"fill-extrusion-height-alignment":{"type":"enum","values":{"terrain":1,"flat":1},"default":"flat"},"fill-extrusion-base-alignment":{"type":"enum","values":{"terrain":1,"flat":1},"default":"terrain"},"fill-extrusion-vertical-gradient":{"type":"boolean","default":true,"expression":{"parameters":["zoom"]}},"fill-extrusion-ambient-occlusion-intensity":{"type":"number","default":0,"minimum":0,"maximum":1,"expression":{"interpolated":true,"parameters":["zoom"]},"transition":true},"fill-extrusion-ambient-occlusion-radius":{"type":"number","default":3,"minimum":0,"expression":{"interpolated":true,"parameters":["zoom"]},"transition":true},"fill-extrusion-ambient-occlusion-wall-radius":{"type":"number","default":3,"minimum":0,"expression":{"interpolated":true,"parameters":["zoom"]},"transition":true},"fill-extrusion-ambient-occlusion-ground-radius":{"type":"number","default":3,"minimum":0,"expression":{"interpolated":true,"parameters":["zoom"]},"transition":true},"fill-extrusion-ambient-occlusion-ground-attenuation":{"type":"number","default":0.69,"minimum":0,"maximum":1,"transition":true,"expression":{"interpolated":true,"parameters":["zoom"]}},"fill-extrusion-flood-light-color":{"type":"color","default":"#ffffff","transition":true,"expression":{"interpolated":true,"parameters":["zoom","measure-light"]}},"fill-extrusion-flood-light-intensity":{"type":"number","default":0,"minimum":0,"maximum":1,"transition":true,"expression":{"interpolated":true,"parameters":["zoom","measure-light"]}},"fill-extrusion-flood-light-wall-radius":{"property-type":"data-driven","type":"number","default":0,"minimum":0,"transition":true,"expression":{"interpolated":true,"parameters":["feature","feature-state"]}},"fill-extrusion-flood-light-ground-radius":{"property-type":"data-driven","type":"number","default":0,"transition":true,"expression":{"interpolated":true,"parameters":["feature","feature-state"]}},"fill-extrusion-flood-light-ground-attenuation":{"type":"number","default":0.69,"minimum":0,"maximum":1,"transition":true,"expression":{"interpolated":true,"parameters":["zoom"]}},"fill-extrusion-vertical-scale":{"type":"number","default":1,"minimum":0,"transition":true,"expression":{"interpolated":true,"parameters":["zoom"]}},"fill-extrusion-rounded-roof":{"type":"boolean","default":true,"expression":{"parameters":["zoom"]}},"fill-extrusion-cutoff-fade-range":{"type":"number","default":0,"minimum":0,"maximum":1,"expression":{}},"fill-extrusion-emissive-strength":{"type":"number","default":0,"minimum":0,"transition":true,"expression":{"interpolated":true,"parameters":["zoom","measure-light","feature-state"]},"property-type":"data-driven"},"fill-extrusion-line-width":{"type":"number","default":0,"minimum":0,"transition":true,"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state","measure-light"]},"property-type":"data-driven"},"fill-extrusion-cast-shadows":{"type":"boolean","default":true}},"paint_building":{"building-opacity":{"type":"number","default":1,"minimum":0,"maximum":1,"transition":true,"expression":{"interpolated":true,"parameters":["zoom"]}},"building-ambient-occlusion-wall-intensity":{"type":"number","default":0,"minimum":0,"maximum":1,"expression":{"interpolated":true,"parameters":["zoom"]},"transition":true},"building-ambient-occlusion-ground-intensity":{"type":"number","default":0,"minimum":0,"maximum":1,"expression":{"interpolated":true,"parameters":["zoom"]},"transition":true},"building-ambient-occlusion-ground-radius":{"type":"number","default":3,"minimum":0,"expression":{"interpolated":true,"parameters":["zoom"]},"transition":true},"building-ambient-occlusion-ground-attenuation":{"type":"number","default":0.69,"minimum":0,"maximum":1,"transition":true,"expression":{"interpolated":true,"parameters":["zoom"]}},"building-vertical-scale":{"type":"number","default":1,"minimum":0,"transition":true,"expression":{"interpolated":true,"parameters":["zoom"]}},"building-cast-shadows":{"type":"boolean","default":true},"building-color":{"type":"color","default":"rgba(193, 154, 127, 1)","expression":{"interpolated":true,"parameters":["feature","feature-state"]},"property-type":"data-driven"},"building-emissive-strength":{"type":"number","default":0,"minimum":0,"expression":{"interpolated":true,"parameters":["feature","feature-state","measure-light"]},"property-type":"data-driven"}},"paint_line":{"line-opacity":{"type":"number","default":1,"minimum":0,"maximum":1,"transition":true,"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state","measure-light"]},"property-type":"data-driven"},"line-color":{"type":"color","default":"#000000","transition":true,"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state","measure-light"]},"property-type":"data-driven"},"line-translate":{"type":"array","value":"number","length":2,"default":[0,0],"transition":true,"expression":{"interpolated":true,"parameters":["zoom"]}},"line-translate-anchor":{"type":"enum","values":{"map":1,"viewport":1},"default":"map","expression":{"parameters":["zoom"]}},"line-width":{"type":"number","default":1,"minimum":0,"transition":true,"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state","measure-light","line-progress"]},"property-type":"data-driven"},"line-gap-width":{"type":"number","default":0,"minimum":0,"transition":true,"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state","measure-light"]},"property-type":"data-driven"},"line-offset":{"type":"number","default":0,"transition":true,"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state","measure-light"]},"property-type":"data-driven"},"line-blur":{"type":"number","default":0,"minimum":0,"transition":true,"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state","measure-light"]},"property-type":"data-driven"},"line-dasharray":{"type":"array","value":"number","minimum":0,"expression":{"parameters":["zoom","feature"]},"property-type":"data-driven"},"line-pattern":{"type":"resolvedImage","expression":{"parameters":["zoom","feature"]},"property-type":"data-driven"},"line-pattern-cross-fade":{"type":"number","default":0,"minimum":0,"maximum":1,"expression":{"interpolated":true,"parameters":["zoom","measure-light"]},"transition":true},"line-gradient":{"type":"color","expression":{"interpolated":true,"parameters":["line-progress"]}},"line-trim-offset":{"type":"array","value":"number","length":2,"default":[0,0],"minimum":[0,0],"maximum":[1,1]},"line-trim-fade-range":{"type":"array","value":"number","length":2,"default":[0,0],"minimum":[0,0],"maximum":[1,1],"expression":{"interpolated":true,"parameters":["zoom","measure-light"]}},"line-trim-color":{"type":"color","default":"transparent","transition":true,"expression":{"interpolated":true,"parameters":["zoom","measure-light"]}},"line-emissive-strength":{"type":"number","default":0,"minimum":0,"transition":true,"expression":{"interpolated":true,"parameters":["zoom","measure-light"]}},"line-border-width":{"type":"number","default":0,"minimum":0,"transition":true,"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state"]},"property-type":"data-driven"},"line-border-color":{"type":"color","default":"rgba(0, 0, 0, 0)","transition":true,"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state"]},"property-type":"data-driven"},"line-occlusion-opacity":{"type":"number","default":0,"minimum":0,"maximum":1,"expression":{"interpolated":true,"parameters":["zoom"]},"transition":true}},"paint_circle":{"circle-radius":{"type":"number","default":5,"minimum":0,"transition":true,"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state","measure-light"]},"property-type":"data-driven"},"circle-color":{"type":"color","default":"#000000","transition":true,"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state","measure-light"]},"property-type":"data-driven"},"circle-blur":{"type":"number","default":0,"transition":true,"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state","measure-light"]},"property-type":"data-driven"},"circle-opacity":{"type":"number","default":1,"minimum":0,"maximum":1,"transition":true,"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state","measure-light"]},"property-type":"data-driven"},"circle-translate":{"type":"array","value":"number","length":2,"default":[0,0],"transition":true,"expression":{"interpolated":true,"parameters":["zoom"]}},"circle-translate-anchor":{"type":"enum","values":{"map":1,"viewport":1},"default":"map","expression":{"parameters":["zoom"]}},"circle-pitch-scale":{"type":"enum","values":{"map":1,"viewport":1},"default":"map","expression":{"parameters":["zoom"]}},"circle-pitch-alignment":{"type":"enum","values":{"map":1,"viewport":1},"default":"viewport","expression":{"parameters":["zoom"]}},"circle-stroke-width":{"type":"number","default":0,"minimum":0,"transition":true,"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state","measure-light"]},"property-type":"data-driven"},"circle-stroke-color":{"type":"color","default":"#000000","transition":true,"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state","measure-light"]},"property-type":"data-driven"},"circle-stroke-opacity":{"type":"number","default":1,"minimum":0,"maximum":1,"transition":true,"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state","measure-light"]},"property-type":"data-driven"},"circle-emissive-strength":{"type":"number","default":0,"minimum":0,"transition":true,"expression":{"interpolated":true,"parameters":["zoom","measure-light"]}}},"paint_heatmap":{"heatmap-radius":{"type":"number","default":30,"minimum":1,"transition":true,"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state","measure-light"]},"property-type":"data-driven"},"heatmap-weight":{"type":"number","default":1,"minimum":0,"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state","measure-light"]},"property-type":"data-driven"},"heatmap-intensity":{"type":"number","default":1,"minimum":0,"transition":true,"expression":{"interpolated":true,"parameters":["zoom"]}},"heatmap-color":{"type":"color","default":["interpolate",["linear"],["heatmap-density"],0,"rgba(0, 0, 255, 0)",0.1,"royalblue",0.3,"cyan",0.5,"lime",0.7,"yellow",1,"red"],"expression":{"interpolated":true,"parameters":["heatmap-density"]}},"heatmap-opacity":{"type":"number","default":1,"minimum":0,"maximum":1,"transition":true,"expression":{"interpolated":true,"parameters":["zoom"]}}},"paint_symbol":{"icon-opacity":{"type":"number","default":1,"minimum":0,"maximum":1,"transition":true,"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state","measure-light"]},"property-type":"data-driven"},"icon-occlusion-opacity":{"type":"number","minimum":0,"maximum":1,"default":0,"transition":true,"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state","measure-light"]},"property-type":"data-driven"},"icon-emissive-strength":{"type":"number","default":1,"minimum":0,"transition":true,"expression":{"interpolated":true,"parameters":["zoom","measure-light","feature-state"]},"property-type":"data-driven"},"text-emissive-strength":{"type":"number","default":1,"minimum":0,"transition":true,"expression":{"interpolated":true,"parameters":["zoom","measure-light","feature-state"]},"property-type":"data-driven"},"icon-color":{"type":"color","default":"#000000","transition":true,"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state","measure-light"]},"property-type":"data-driven"},"icon-halo-color":{"type":"color","default":"rgba(0, 0, 0, 0)","transition":true,"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state","measure-light"]},"property-type":"data-driven"},"icon-halo-width":{"type":"number","default":0,"minimum":0,"transition":true,"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state","measure-light"]},"property-type":"data-driven"},"icon-halo-blur":{"type":"number","default":0,"minimum":0,"transition":true,"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state","measure-light"]},"property-type":"data-driven"},"icon-translate":{"type":"array","value":"number","length":2,"default":[0,0],"transition":true,"expression":{"interpolated":true,"parameters":["zoom"]}},"icon-translate-anchor":{"type":"enum","values":{"map":1,"viewport":1},"default":"map","expression":{"parameters":["zoom"]}},"icon-image-cross-fade":{"type":"number","default":0,"minimum":0,"maximum":1,"expression":{"interpolated":true,"parameters":["zoom","measure-light"]},"transition":true},"text-opacity":{"type":"number","default":1,"minimum":0,"maximum":1,"transition":true,"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state","measure-light"]},"property-type":"data-driven"},"text-occlusion-opacity":{"type":"number","minimum":0,"maximum":1,"default":0,"transition":true,"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state","measure-light"]},"property-type":"data-driven"},"text-color":{"type":"color","default":"#000000","transition":true,"overridable":true,"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state","measure-light"]},"property-type":"data-driven"},"text-halo-color":{"type":"color","default":"rgba(0, 0, 0, 0)","transition":true,"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state","measure-light"]},"property-type":"data-driven"},"text-halo-width":{"type":"number","default":0,"minimum":0,"transition":true,"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state","measure-light"]},"property-type":"data-driven"},"text-halo-blur":{"type":"number","default":0,"minimum":0,"transition":true,"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state","measure-light"]},"property-type":"data-driven"},"text-translate":{"type":"array","value":"number","length":2,"default":[0,0],"transition":true,"expression":{"interpolated":true,"parameters":["zoom"]}},"text-translate-anchor":{"type":"enum","values":{"map":1,"viewport":1},"default":"map","expression":{"parameters":["zoom"]}},"icon-color-saturation":{"type":"number","default":0,"minimum":-1,"maximum":1,"expression":{}},"icon-color-contrast":{"type":"number","default":0,"minimum":-1,"maximum":1,"expression":{}},"icon-color-brightness-min":{"type":"number","default":0,"minimum":0,"maximum":1,"expression":{}},"icon-color-brightness-max":{"type":"number","default":1,"minimum":0,"maximum":1,"expression":{}},"symbol-z-offset":{"type":"number","default":0,"minimum":0,"transition":true,"expression":{"interpolated":true,"parameters":["zoom","feature"]},"property-type":"data-driven"}},"paint_raster":{"raster-opacity":{"type":"number","default":1,"minimum":0,"maximum":1,"transition":true,"expression":{"interpolated":true,"parameters":["zoom"]}},"raster-color":{"type":"color","expression":{"interpolated":true,"parameters":["raster-value"]}},"raster-color-mix":{"type":"array","default":[0.2126,0.7152,0.0722,0],"length":4,"value":"number","transition":true,"expression":{"interpolated":true,"parameters":["zoom"]}},"raster-color-range":{"type":"array","length":2,"value":"number","transition":true,"expression":{"interpolated":true,"parameters":["zoom"]}},"raster-hue-rotate":{"type":"number","default":0,"period":360,"transition":true,"expression":{"interpolated":true,"parameters":["zoom"]}},"raster-brightness-min":{"type":"number","default":0,"minimum":0,"maximum":1,"transition":true,"expression":{"interpolated":true,"parameters":["zoom"]}},"raster-brightness-max":{"type":"number","default":1,"minimum":0,"maximum":1,"transition":true,"expression":{"interpolated":true,"parameters":["zoom"]}},"raster-saturation":{"type":"number","default":0,"minimum":-1,"maximum":1,"transition":true,"expression":{"interpolated":true,"parameters":["zoom"]}},"raster-contrast":{"type":"number","default":0,"minimum":-1,"maximum":1,"transition":true,"expression":{"interpolated":true,"parameters":["zoom"]}},"raster-resampling":{"type":"enum","values":{"linear":1,"nearest":1},"default":"linear","expression":{"parameters":["zoom"]}},"raster-fade-duration":{"type":"number","default":300,"minimum":0,"expression":{"interpolated":true,"parameters":["zoom"]}},"raster-emissive-strength":{"type":"number","default":0,"minimum":0,"transition":true,"expression":{"interpolated":true,"parameters":["zoom","measure-light"]}},"raster-array-band":{"type":"string"},"raster-elevation":{"type":"number","default":0,"minimum":0,"transition":true,"expression":{"interpolated":true,"parameters":["zoom"]}}},"paint_raster-particle":{"raster-particle-array-band":{"type":"string"},"raster-particle-count":{"type":"number","default":512,"minimum":1},"raster-particle-color":{"type":"color","expression":{"interpolated":true,"parameters":["raster-particle-speed"]}},"raster-particle-max-speed":{"type":"number","default":1,"minimum":1},"raster-particle-speed-factor":{"type":"number","default":0.2,"minimum":0,"maximum":1,"transition":true,"expression":{"interpolated":true,"parameters":["zoom"]}},"raster-particle-fade-opacity-factor":{"type":"number","default":0.98,"minimum":0,"maximum":1,"transition":true,"expression":{"interpolated":true,"parameters":["zoom"]}},"raster-particle-reset-rate-factor":{"type":"number","default":0.8,"minimum":0,"maximum":1},"raster-particle-elevation":{"type":"number","default":0,"minimum":0,"transition":true,"expression":{"interpolated":true,"parameters":["zoom"]}}},"paint_hillshade":{"hillshade-illumination-direction":{"type":"number","default":335,"minimum":0,"maximum":359,"expression":{"interpolated":true,"parameters":["zoom"]}},"hillshade-illumination-anchor":{"type":"enum","values":{"map":1,"viewport":1},"default":"viewport","expression":{"parameters":["zoom"]}},"hillshade-exaggeration":{"type":"number","default":0.5,"minimum":0,"maximum":1,"transition":true,"expression":{"interpolated":true,"parameters":["zoom"]}},"hillshade-shadow-color":{"type":"color","default":"#000000","transition":true,"expression":{"interpolated":true,"parameters":["zoom","measure-light"]}},"hillshade-highlight-color":{"type":"color","default":"#FFFFFF","transition":true,"expression":{"interpolated":true,"parameters":["zoom","measure-light"]}},"hillshade-accent-color":{"type":"color","default":"#000000","transition":true,"expression":{"interpolated":true,"parameters":["zoom","measure-light"]}},"hillshade-emissive-strength":{"type":"number","default":0,"minimum":0,"transition":true,"expression":{"interpolated":true,"parameters":["zoom","measure-light"]}}},"paint_background":{"background-pitch-alignment":{"type":"enum","values":{"map":1,"viewport":1},"default":"map","expression":{"parameters":[]}},"background-color":{"type":"color","default":"#000000","transition":true,"expression":{"interpolated":true,"parameters":["zoom"]}},"background-pattern":{"type":"resolvedImage","expression":{"parameters":["zoom"]}},"background-opacity":{"type":"number","default":1,"minimum":0,"maximum":1,"transition":true,"expression":{"interpolated":true,"parameters":["zoom"]}},"background-emissive-strength":{"type":"number","default":0,"minimum":0,"transition":true,"expression":{"interpolated":true,"parameters":["zoom","measure-light"]}}},"paint_sky":{"sky-type":{"type":"enum","values":{"gradient":1,"atmosphere":1},"default":"atmosphere","expression":{"parameters":["zoom"]}},"sky-atmosphere-sun":{"type":"array","value":"number","length":2,"minimum":[0,0],"maximum":[360,180],"expression":{"parameters":["zoom"]}},"sky-atmosphere-sun-intensity":{"type":"number","default":10,"minimum":0,"maximum":100},"sky-gradient-center":{"type":"array","value":"number","default":[0,0],"length":2,"minimum":[0,0],"maximum":[360,180],"expression":{"parameters":["zoom"]}},"sky-gradient-radius":{"type":"number","default":90,"minimum":0,"maximum":180,"expression":{"parameters":["zoom"]}},"sky-gradient":{"type":"color","default":["interpolate",["linear"],["sky-radial-progress"],0.8,"#87ceeb",1,"white"],"expression":{"interpolated":true,"parameters":["sky-radial-progress"]}},"sky-atmosphere-halo-color":{"type":"color","default":"white"},"sky-atmosphere-color":{"type":"color","default":"white"},"sky-opacity":{"type":"number","default":1,"minimum":0,"maximum":1,"transition":true,"expression":{"interpolated":true,"parameters":["zoom"]}}},"paint_model":{"model-opacity":{"type":"number","default":1,"minimum":0,"maximum":1,"transition":true,"expression":{"interpolated":true,"parameters":["feature","feature-state","zoom"]},"property-type":"data-driven"},"model-rotation":{"type":"array","value":"number","length":3,"default":[0,0,0],"period":360,"property-type":"data-driven","expression":{"interpolated":true,"parameters":["feature","feature-state","zoom"]},"transition":true},"model-scale":{"type":"array","value":"number","length":3,"default":[1,1,1],"property-type":"data-driven","expression":{"interpolated":true,"parameters":["feature","feature-state","zoom"]},"transition":true},"model-translation":{"type":"array","value":"number","length":3,"default":[0,0,0],"property-type":"data-driven","expression":{"interpolated":true,"parameters":["feature","feature-state","zoom"]},"transition":true},"model-color":{"type":"color","default":"#ffffff","property-type":"data-driven","expression":{"interpolated":true,"parameters":["feature","feature-state","measure-light","zoom"]},"transition":true},"model-color-mix-intensity":{"type":"number","property-type":"data-driven","default":0,"minimum":0,"maximum":1,"expression":{"interpolated":true,"parameters":["feature","feature-state","measure-light"]},"transition":true},"model-type":{"type":"enum","values":{"common-3d":1,"location-indicator":1},"default":"common-3d"},"model-cast-shadows":{"type":"boolean","default":true},"model-receive-shadows":{"type":"boolean","default":true},"model-ambient-occlusion-intensity":{"type":"number","default":1,"minimum":0,"maximum":1,"expression":{"interpolated":true,"parameters":["zoom"]},"transition":true},"model-emissive-strength":{"type":"number","property-type":"data-driven","default":0,"minimum":0,"maximum":5,"expression":{"interpolated":true,"parameters":["feature","feature-state","measure-light"]},"transition":true},"model-roughness":{"type":"number","default":1,"minimum":0,"maximum":1,"property-type":"data-driven","expression":{"interpolated":true,"parameters":["feature","feature-state"]},"transition":true},"model-height-based-emissive-strength-multiplier":{"type":"array","default":[1,1,1,1,0],"length":5,"value":"number","property-type":"data-driven","expression":{"interpolated":true,"parameters":["feature","feature-state","measure-light"]},"transition":true},"model-cutoff-fade-range":{"type":"number","default":0,"minimum":0,"maximum":1,"expression":{}},"model-front-cutoff":{"type":"array","value":"number","expression":{"interpolated":true,"parameters":["zoom"]},"length":3,"default":[0,0,1],"minimum":[0,0,0],"maximum":[1,1,1]}},"transition":{"duration":{"type":"number","default":300,"minimum":0},"delay":{"type":"number","default":0,"minimum":0}},"promoteId":{"*":{"type":"*"}}}');
      function Po(t22) {
        return t22 instanceof Number || t22 instanceof String || t22 instanceof Boolean ? t22.valueOf() : t22;
      }
      function To(t22) {
        if (Array.isArray(t22)) return t22.map(To);
        if (t22 instanceof Object && !(t22 instanceof Number || t22 instanceof String || t22 instanceof Boolean)) {
          const e22 = {};
          for (const r22 in t22) e22[r22] = To(t22[r22]);
          return e22;
        }
        return Po(t22);
      }
      function Bo(t22) {
        if (true === t22 || false === t22) return true;
        if (!Array.isArray(t22) || 0 === t22.length) return false;
        switch (t22[0]) {
          case "has":
            return t22.length >= 2 && "$id" !== t22[1] && "$type" !== t22[1];
          case "in":
            return t22.length >= 3 && ("string" != typeof t22[1] || Array.isArray(t22[2]));
          case "!in":
          case "!has":
          case "none":
            return false;
          case "==":
          case "!=":
          case ">":
          case ">=":
          case "<":
          case "<=":
            return 3 !== t22.length || Array.isArray(t22[1]) || Array.isArray(t22[2]);
          case "any":
          case "all":
            for (const e22 of t22.slice(1)) if (!Bo(e22) && "boolean" != typeof e22) return false;
            return true;
          default:
            return true;
        }
      }
      function Vo(t22, e22 = "", r22 = null, n22 = "fill") {
        if (null == t22) return { filter: () => true, needGeometry: false, needFeature: false };
        Bo(t22) || (t22 = Uo(t22));
        const i22 = t22;
        let s2 = true;
        try {
          s2 = function(t3) {
            if (!Fo(t3)) return t3;
            let e3 = To(t3);
            return Do(e3), e3 = Co(e3), e3;
          }(i22);
        } catch (t3) {
          console.warn(`Failed to extract static filter. Filter will continue working, but at higher memory usage and slower framerate.
This is most likely a bug, please report this via https://github.com/mapbox/mapbox-gl-js/issues/new?assignees=&labels=&template=Bug_report.md
and paste the contents of this message in the report.
Thank you!
Filter Expression:
${JSON.stringify(i22, null, 2)}
        `);
        }
        let o2 = null, a22 = null;
        if ("background" !== n22 && "sky" !== n22 && "slot" !== n22) {
          a22 = Eo[`filter_${n22}`];
          const t3 = Ts(s2, a22, e22, r22);
          if ("error" === t3.result) throw new Error(t3.value.map((t4) => `${t4.key}: ${t4.message}`).join(", "));
          o2 = (e3, r3, n3) => t3.value.evaluate(e3, r3, {}, n3);
        }
        let l22 = null, u22 = null;
        if (s2 !== i22) {
          const t3 = Ts(i22, a22, e22, r22);
          if ("error" === t3.result) throw new Error(t3.value.map((t4) => `${t4.key}: ${t4.message}`).join(", "));
          l22 = (e3, r3, n3, i3, s3) => t3.value.evaluate(e3, r3, {}, n3, void 0, void 0, i3, s3), u22 = !hi(t3.value.expression);
        }
        return { filter: o2, dynamicFilter: l22 || void 0, needGeometry: Oo(s2), needFeature: !!u22 };
      }
      function Co(t22) {
        if (!Array.isArray(t22)) return t22;
        const e22 = function(t3) {
          if (Lo.has(t3[0])) {
            for (let e3 = 1; e3 < t3.length; e3++) if (Fo(t3[e3])) return true;
          }
          return t3;
        }(t22);
        return true === e22 ? e22 : e22.map((t3) => Co(t3));
      }
      function Do(t22) {
        let e22 = false;
        const r22 = [];
        if ("case" === t22[0]) {
          for (let n22 = 1; n22 < t22.length - 1; n22 += 2) e22 = e22 || Fo(t22[n22]), r22.push(t22[n22 + 1]);
          r22.push(t22[t22.length - 1]);
        } else if ("match" === t22[0]) {
          e22 = e22 || Fo(t22[1]);
          for (let e3 = 2; e3 < t22.length - 1; e3 += 2) r22.push(t22[e3 + 1]);
          r22.push(t22[t22.length - 1]);
        } else if ("step" === t22[0]) {
          e22 = e22 || Fo(t22[1]);
          for (let e3 = 1; e3 < t22.length - 1; e3 += 2) r22.push(t22[e3 + 1]);
        }
        e22 && (t22.length = 0, t22.push("any", ...r22));
        for (let e3 = 1; e3 < t22.length; e3++) Do(t22[e3]);
      }
      function Fo(t22) {
        if (!Array.isArray(t22)) return false;
        if ("pitch" === (e22 = t22[0]) || "distance-from-center" === e22) return true;
        var e22;
        for (let e3 = 1; e3 < t22.length; e3++) if (Fo(t22[e3])) return true;
        return false;
      }
      const Lo = /* @__PURE__ */ new Set(["in", "==", "!=", ">", ">=", "<", "<=", "to-boolean"]);
      function Ro(t22, e22) {
        return t22 < e22 ? -1 : t22 > e22 ? 1 : 0;
      }
      function Oo(t22) {
        if (!Array.isArray(t22)) return false;
        if ("within" === t22[0] || "distance" === t22[0]) return true;
        for (let e22 = 1; e22 < t22.length; e22++) if (Oo(t22[e22])) return true;
        return false;
      }
      function Uo(t22) {
        if (!t22) return true;
        const e22 = t22[0];
        return t22.length <= 1 ? "any" !== e22 : "==" === e22 ? No(t22[1], t22[2], "==") : "!=" === e22 ? Go(No(t22[1], t22[2], "==")) : "<" === e22 || ">" === e22 || "<=" === e22 || ">=" === e22 ? No(t22[1], t22[2], e22) : "any" === e22 ? (r22 = t22.slice(1), ["any"].concat(r22.map(Uo))) : "all" === e22 ? ["all"].concat(t22.slice(1).map(Uo)) : "none" === e22 ? ["all"].concat(t22.slice(1).map(Uo).map(Go)) : "in" === e22 ? jo(t22[1], t22.slice(2)) : "!in" === e22 ? Go(jo(t22[1], t22.slice(2))) : "has" === e22 ? $o(t22[1]) : "!has" !== e22 || Go($o(t22[1]));
        var r22;
      }
      function No(t22, e22, r22) {
        switch (t22) {
          case "$type":
            return [`filter-type-${r22}`, e22];
          case "$id":
            return [`filter-id-${r22}`, e22];
          default:
            return [`filter-${r22}`, t22, e22];
        }
      }
      function jo(t22, e22) {
        if (0 === e22.length) return false;
        switch (t22) {
          case "$type":
            return ["filter-type-in", ["literal", e22]];
          case "$id":
            return ["filter-id-in", ["literal", e22]];
          default:
            return e22.length > 200 && !e22.some((t3) => typeof t3 != typeof e22[0]) ? ["filter-in-large", t22, ["literal", e22.sort(Ro)]] : ["filter-in-small", t22, ["literal", e22]];
        }
      }
      function $o(t22) {
        switch (t22) {
          case "$type":
            return true;
          case "$id":
            return ["filter-has-id"];
          default:
            return ["filter-has", t22];
        }
      }
      function Go(t22) {
        return ["!", t22];
      }
      const qo = "";
      function Ho(t22, e22) {
        return e22 ? `${t22}${qo}${e22}` : t22;
      }
      const Xo = "-transition", Zo = /* @__PURE__ */ new Set(["fill", "line", "background", "hillshade", "raster"]);
      class Wo extends Qe {
        constructor(t22, e22, r22, n22, i22) {
          if (super(), this.id = t22.id, this.fqid = Ho(this.id, r22), this.type = t22.type, this.scope = r22, this.lut = n22, this.options = i22, this._featureFilter = { filter: () => true, needGeometry: false, needFeature: false }, this._filterCompiled = false, this.configDependencies = /* @__PURE__ */ new Set(), "custom" !== t22.type) {
            if (this.metadata = t22.metadata, this.minzoom = t22.minzoom, this.maxzoom = t22.maxzoom, t22.type && "background" !== t22.type && "sky" !== t22.type && "slot" !== t22.type) {
              this.source = t22.source, this.sourceLayer = t22["source-layer"], this.filter = t22.filter;
              const e3 = Ts(this.filter, Eo[`filter_${t22.type}`]);
              "error" !== e3.result && (this.configDependencies = /* @__PURE__ */ new Set([...this.configDependencies, ...e3.value.configDependencies]));
            }
            if (t22.slot && (this.slot = t22.slot), e22.layout && (this._unevaluatedLayout = new wo(e22.layout, this.scope, i22), this.configDependencies = /* @__PURE__ */ new Set([...this.configDependencies, ...this._unevaluatedLayout.configDependencies])), e22.paint) {
              this._transitionablePaint = new vo(e22.paint, this.scope, i22);
              for (const e3 in t22.paint) this.setPaintProperty(e3, t22.paint[e3]);
              for (const e3 in t22.layout) this.setLayoutProperty(e3, t22.layout[e3]);
              this.configDependencies = /* @__PURE__ */ new Set([...this.configDependencies, ...this._transitionablePaint.configDependencies]), this._transitioningPaint = this._transitionablePaint.untransitioned(), this.paint = new Mo(e22.paint);
            }
          }
        }
        onAdd(t22) {
        }
        onRemove(t22) {
        }
        isDraped(t22) {
          return !this.is3D(true) && Zo.has(this.type);
        }
        getLayoutProperty(t22) {
          return "visibility" === t22 ? this.visibility : this._unevaluatedLayout.getValue(t22);
        }
        setLayoutProperty(t22, e22) {
          if ("custom" === this.type && "visibility" === t22) return void (this.visibility = e22);
          const r22 = this._unevaluatedLayout;
          r22._properties.properties[t22] && (r22.setValue(t22, e22), this.configDependencies = /* @__PURE__ */ new Set([...this.configDependencies, ...r22.configDependencies]), "visibility" === t22 && this.possiblyEvaluateVisibility());
        }
        possiblyEvaluateVisibility() {
          this._unevaluatedLayout._values.visibility && (this.visibility = this._unevaluatedLayout._values.visibility.possiblyEvaluate({ zoom: 0 }));
        }
        getPaintProperty(t22) {
          return t22.endsWith(Xo) ? this._transitionablePaint.getTransition(t22.slice(0, -11)) : this._transitionablePaint.getValue(t22);
        }
        setPaintProperty(t22, e22) {
          const r22 = this._transitionablePaint, n22 = r22._properties.properties;
          if (t22.endsWith(Xo)) {
            const i3 = t22.slice(0, -11);
            return n22[i3] && r22.setTransition(i3, e22 || void 0), false;
          }
          if (!n22[t22]) return false;
          const i22 = r22._values[t22], s2 = i22.value.isDataDriven(), o2 = i22.value;
          r22.setValue(t22, e22), this.configDependencies = /* @__PURE__ */ new Set([...this.configDependencies, ...r22.configDependencies]), this._handleSpecialPaintPropertyUpdate(t22);
          const a22 = r22._values[t22].value, l22 = a22.isDataDriven(), u22 = t22.endsWith("pattern") || "line-dasharray" === t22;
          return l22 || s2 || u22 || this._handleOverridablePaintPropertyUpdate(t22, o2, a22);
        }
        _handleSpecialPaintPropertyUpdate(t22) {
        }
        getProgramIds() {
          return null;
        }
        getDefaultProgramParams(t22, e22, r22) {
          return null;
        }
        _handleOverridablePaintPropertyUpdate(t22, e22, r22) {
          return false;
        }
        isHidden(t22) {
          return !!(this.minzoom && t22 < this.minzoom) || !!(this.maxzoom && t22 >= this.maxzoom) || "none" === this.visibility;
        }
        updateTransitions(t22) {
          this._transitioningPaint = this._transitionablePaint.transitioned(t22, this._transitioningPaint);
        }
        hasTransition() {
          return this._transitioningPaint.hasTransition();
        }
        recalculate(t22, e22) {
          this._unevaluatedLayout && (this.layout = this._unevaluatedLayout.possiblyEvaluate(t22, void 0, e22)), this.paint = this._transitioningPaint.possiblyEvaluate(t22, void 0, e22);
        }
        serialize() {
          return Ut2({ id: this.id, type: this.type, slot: this.slot, source: this.source, "source-layer": this.sourceLayer, metadata: this.metadata, minzoom: this.minzoom, maxzoom: this.maxzoom, filter: this.filter, layout: this._unevaluatedLayout && this._unevaluatedLayout.serialize(), paint: this._transitionablePaint && this._transitionablePaint.serialize() }, (t22, e22) => !(void 0 === t22 || "layout" === e22 && !Object.keys(t22).length || "paint" === e22 && !Object.keys(t22).length));
        }
        is3D(t22) {
          return false;
        }
        hasElevation() {
          return false;
        }
        isSky() {
          return false;
        }
        isTileClipped() {
          return false;
        }
        hasOffscreenPass() {
          return false;
        }
        hasShadowPass() {
          return false;
        }
        canCastShadows() {
          return false;
        }
        hasLightBeamPass() {
          return false;
        }
        cutoffRange() {
          return 0;
        }
        tileCoverLift() {
          return 0;
        }
        resize() {
        }
        isStateDependent() {
          for (const t22 in this.paint._values) {
            const e22 = this.paint.get(t22);
            if (e22 instanceof Ao && gs(e22.property.specification) && ("source" === e22.value.kind || "composite" === e22.value.kind) && e22.value.isStateDependent) return true;
          }
          return false;
        }
        compileFilter(t22) {
          this._filterCompiled || (this._featureFilter = Vo(this.filter, this.scope, t22), this._filterCompiled = true);
        }
        invalidateCompiledFilter() {
          this._filterCompiled = false;
        }
        dynamicFilter() {
          return this._featureFilter.dynamicFilter;
        }
        dynamicFilterNeedsFeature() {
          return this._featureFilter.needFeature;
        }
        getLayerRenderingStats() {
          return this._stats;
        }
        resetLayerRenderingStats(t22) {
          this._stats && ("shadow" === t22.renderPass ? this._stats.numRenderedVerticesInShadowPass = 0 : this._stats.numRenderedVerticesInTransparentPass = 0);
        }
        queryRadius(t22) {
        }
        queryIntersectsFeature(t22, e22, r22, n22, i22, s2, o2, a22, l22) {
        }
      }
      const Yo = { Int8: Int8Array, Uint8: Uint8Array, Int16: Int16Array, Uint16: Uint16Array, Int32: Int32Array, Uint32: Uint32Array, Float32: Float32Array };
      class Ko {
        constructor(t22, e22) {
          this._structArray = t22, this._pos1 = e22 * this.size, this._pos2 = this._pos1 / 2, this._pos4 = this._pos1 / 4, this._pos8 = this._pos1 / 8;
        }
      }
      class Jo {
        constructor() {
          this.isTransferred = false, this.capacity = -1, this.resize(0);
        }
        static serialize(t22, e22) {
          return t22._trim(), e22 && (t22.isTransferred = true, e22.add(t22.arrayBuffer)), { length: t22.length, arrayBuffer: t22.arrayBuffer };
        }
        static deserialize(t22) {
          const e22 = Object.create(this.prototype);
          return e22.arrayBuffer = t22.arrayBuffer, e22.length = t22.length, e22.capacity = t22.arrayBuffer.byteLength / e22.bytesPerElement, e22._refreshViews(), e22;
        }
        _trim() {
          this.length !== this.capacity && (this.capacity = this.length, this.arrayBuffer = this.arrayBuffer.slice(0, this.length * this.bytesPerElement), this._refreshViews());
        }
        clear() {
          this.length = 0;
        }
        resize(t22) {
          this.reserve(t22), this.length = t22;
        }
        reserve(t22) {
          if (t22 > this.capacity) {
            this.capacity = Math.max(t22, Math.floor(5 * this.capacity), 128), this.arrayBuffer = new ArrayBuffer(this.capacity * this.bytesPerElement);
            const e22 = this.uint8;
            this._refreshViews(), e22 && this.uint8.set(e22);
          }
        }
        _refreshViews() {
          throw new Error("StructArray#_refreshViews() must be implemented by each concrete StructArray layout");
        }
        emplace(...t22) {
          throw new Error("StructArray#emplace() must be implemented by each concrete StructArray layout");
        }
        emplaceBack(...t22) {
          throw new Error("StructArray#emplaceBack() must be implemented by each concrete StructArray layout");
        }
        destroy() {
          this.int8 = this.uint8 = this.int16 = this.uint16 = this.int32 = this.uint32 = this.float32 = null, this.arrayBuffer = null;
        }
      }
      function Qo(t22, e22 = 1) {
        let r22 = 0, n22 = 0;
        return { members: t22.map((t3) => {
          const i22 = Yo[t3.type].BYTES_PER_ELEMENT, s2 = r22 = ta(r22, Math.max(e22, i22)), o2 = t3.components || 1;
          return n22 = Math.max(n22, i22), r22 += i22 * o2, { name: t3.name, type: t3.type, components: o2, offset: s2 };
        }), size: ta(r22, Math.max(n22, e22)), alignment: e22 };
      }
      function ta(t22, e22) {
        return Math.ceil(t22 / e22) * e22;
      }
      class ea extends Jo {
        _refreshViews() {
          this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer);
        }
        emplaceBack(t22, e22) {
          const r22 = this.length;
          return this.resize(r22 + 1), this.emplace(r22, t22, e22);
        }
        emplace(t22, e22, r22) {
          const n22 = 2 * t22;
          return this.int16[n22 + 0] = e22, this.int16[n22 + 1] = r22, t22;
        }
      }
      ea.prototype.bytesPerElement = 4, js(ea, "StructArrayLayout2i4");
      class ra extends Jo {
        _refreshViews() {
          this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer);
        }
        emplaceBack(t22, e22, r22) {
          const n22 = this.length;
          return this.resize(n22 + 1), this.emplace(n22, t22, e22, r22);
        }
        emplace(t22, e22, r22, n22) {
          const i22 = 3 * t22;
          return this.int16[i22 + 0] = e22, this.int16[i22 + 1] = r22, this.int16[i22 + 2] = n22, t22;
        }
      }
      ra.prototype.bytesPerElement = 6, js(ra, "StructArrayLayout3i6");
      class na extends Jo {
        _refreshViews() {
          this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer);
        }
        emplaceBack(t22, e22, r22, n22) {
          const i22 = this.length;
          return this.resize(i22 + 1), this.emplace(i22, t22, e22, r22, n22);
        }
        emplace(t22, e22, r22, n22, i22) {
          const s2 = 4 * t22;
          return this.int16[s2 + 0] = e22, this.int16[s2 + 1] = r22, this.int16[s2 + 2] = n22, this.int16[s2 + 3] = i22, t22;
        }
      }
      na.prototype.bytesPerElement = 8, js(na, "StructArrayLayout4i8");
      class ia extends Jo {
        _refreshViews() {
          this.uint8 = new Uint8Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer);
        }
        emplaceBack(t22) {
          const e22 = this.length;
          return this.resize(e22 + 1), this.emplace(e22, t22);
        }
        emplace(t22, e22) {
          return this.float32[1 * t22 + 0] = e22, t22;
        }
      }
      ia.prototype.bytesPerElement = 4, js(ia, "StructArrayLayout1f4");
      class sa extends Jo {
        _refreshViews() {
          this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer);
        }
        emplaceBack(t22, e22, r22) {
          const n22 = this.length;
          return this.resize(n22 + 1), this.emplace(n22, t22, e22, r22);
        }
        emplace(t22, e22, r22, n22) {
          const i22 = 4 * t22, s2 = 2 * t22;
          return this.int16[i22 + 0] = e22, this.int16[i22 + 1] = r22, this.float32[s2 + 1] = n22, t22;
        }
      }
      sa.prototype.bytesPerElement = 8, js(sa, "StructArrayLayout2i1f8");
      class oa extends Jo {
        _refreshViews() {
          this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer);
        }
        emplaceBack(t22, e22, r22) {
          const n22 = this.length;
          return this.resize(n22 + 1), this.emplace(n22, t22, e22, r22);
        }
        emplace(t22, e22, r22, n22) {
          const i22 = 4 * t22;
          return this.int16[i22 + 0] = e22, this.int16[i22 + 1] = r22, this.int16[i22 + 2] = n22, t22;
        }
      }
      oa.prototype.bytesPerElement = 8, js(oa, "StructArrayLayout3i8");
      class aa extends Jo {
        _refreshViews() {
          this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer);
        }
        emplaceBack(t22, e22, r22, n22, i22) {
          const s2 = this.length;
          return this.resize(s2 + 1), this.emplace(s2, t22, e22, r22, n22, i22);
        }
        emplace(t22, e22, r22, n22, i22, s2) {
          const o2 = 5 * t22;
          return this.int16[o2 + 0] = e22, this.int16[o2 + 1] = r22, this.int16[o2 + 2] = n22, this.int16[o2 + 3] = i22, this.int16[o2 + 4] = s2, t22;
        }
      }
      aa.prototype.bytesPerElement = 10, js(aa, "StructArrayLayout5i10");
      class la extends Jo {
        _refreshViews() {
          this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer);
        }
        emplaceBack(t22, e22, r22, n22, i22, s2, o2) {
          const a22 = this.length;
          return this.resize(a22 + 1), this.emplace(a22, t22, e22, r22, n22, i22, s2, o2);
        }
        emplace(t22, e22, r22, n22, i22, s2, o2, a22) {
          const l22 = 6 * t22, u22 = 12 * t22, c22 = 3 * t22;
          return this.int16[l22 + 0] = e22, this.int16[l22 + 1] = r22, this.uint8[u22 + 4] = n22, this.uint8[u22 + 5] = i22, this.uint8[u22 + 6] = s2, this.uint8[u22 + 7] = o2, this.float32[c22 + 2] = a22, t22;
        }
      }
      la.prototype.bytesPerElement = 12, js(la, "StructArrayLayout2i4ub1f12");
      class ua extends Jo {
        _refreshViews() {
          this.uint8 = new Uint8Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer);
        }
        emplaceBack(t22, e22, r22) {
          const n22 = this.length;
          return this.resize(n22 + 1), this.emplace(n22, t22, e22, r22);
        }
        emplace(t22, e22, r22, n22) {
          const i22 = 3 * t22;
          return this.float32[i22 + 0] = e22, this.float32[i22 + 1] = r22, this.float32[i22 + 2] = n22, t22;
        }
      }
      ua.prototype.bytesPerElement = 12, js(ua, "StructArrayLayout3f12");
      class ca extends Jo {
        _refreshViews() {
          this.uint8 = new Uint8Array(this.arrayBuffer), this.uint16 = new Uint16Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer);
        }
        emplaceBack(t22, e22, r22, n22, i22) {
          const s2 = this.length;
          return this.resize(s2 + 1), this.emplace(s2, t22, e22, r22, n22, i22);
        }
        emplace(t22, e22, r22, n22, i22, s2) {
          const o2 = 6 * t22, a22 = 3 * t22;
          return this.uint16[o2 + 0] = e22, this.uint16[o2 + 1] = r22, this.uint16[o2 + 2] = n22, this.uint16[o2 + 3] = i22, this.float32[a22 + 2] = s2, t22;
        }
      }
      ca.prototype.bytesPerElement = 12, js(ca, "StructArrayLayout4ui1f12");
      class ha extends Jo {
        _refreshViews() {
          this.uint8 = new Uint8Array(this.arrayBuffer), this.uint16 = new Uint16Array(this.arrayBuffer);
        }
        emplaceBack(t22, e22, r22, n22) {
          const i22 = this.length;
          return this.resize(i22 + 1), this.emplace(i22, t22, e22, r22, n22);
        }
        emplace(t22, e22, r22, n22, i22) {
          const s2 = 4 * t22;
          return this.uint16[s2 + 0] = e22, this.uint16[s2 + 1] = r22, this.uint16[s2 + 2] = n22, this.uint16[s2 + 3] = i22, t22;
        }
      }
      ha.prototype.bytesPerElement = 8, js(ha, "StructArrayLayout4ui8");
      class pa extends Jo {
        _refreshViews() {
          this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer);
        }
        emplaceBack(t22, e22, r22, n22, i22, s2) {
          const o2 = this.length;
          return this.resize(o2 + 1), this.emplace(o2, t22, e22, r22, n22, i22, s2);
        }
        emplace(t22, e22, r22, n22, i22, s2, o2) {
          const a22 = 6 * t22;
          return this.int16[a22 + 0] = e22, this.int16[a22 + 1] = r22, this.int16[a22 + 2] = n22, this.int16[a22 + 3] = i22, this.int16[a22 + 4] = s2, this.int16[a22 + 5] = o2, t22;
        }
      }
      pa.prototype.bytesPerElement = 12, js(pa, "StructArrayLayout6i12");
      class fa extends Jo {
        _refreshViews() {
          this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer), this.uint16 = new Uint16Array(this.arrayBuffer);
        }
        emplaceBack(t22, e22, r22, n22, i22, s2, o2, a22, l22, u22, c22, h22) {
          const p22 = this.length;
          return this.resize(p22 + 1), this.emplace(p22, t22, e22, r22, n22, i22, s2, o2, a22, l22, u22, c22, h22);
        }
        emplace(t22, e22, r22, n22, i22, s2, o2, a22, l22, u22, c22, h22, p22) {
          const f22 = 12 * t22;
          return this.int16[f22 + 0] = e22, this.int16[f22 + 1] = r22, this.int16[f22 + 2] = n22, this.int16[f22 + 3] = i22, this.uint16[f22 + 4] = s2, this.uint16[f22 + 5] = o2, this.uint16[f22 + 6] = a22, this.uint16[f22 + 7] = l22, this.int16[f22 + 8] = u22, this.int16[f22 + 9] = c22, this.int16[f22 + 10] = h22, this.int16[f22 + 11] = p22, t22;
        }
      }
      fa.prototype.bytesPerElement = 24, js(fa, "StructArrayLayout4i4ui4i24");
      class da extends Jo {
        _refreshViews() {
          this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer);
        }
        emplaceBack(t22, e22, r22, n22, i22, s2) {
          const o2 = this.length;
          return this.resize(o2 + 1), this.emplace(o2, t22, e22, r22, n22, i22, s2);
        }
        emplace(t22, e22, r22, n22, i22, s2, o2) {
          const a22 = 10 * t22, l22 = 5 * t22;
          return this.int16[a22 + 0] = e22, this.int16[a22 + 1] = r22, this.int16[a22 + 2] = n22, this.float32[l22 + 2] = i22, this.float32[l22 + 3] = s2, this.float32[l22 + 4] = o2, t22;
        }
      }
      da.prototype.bytesPerElement = 20, js(da, "StructArrayLayout3i3f20");
      class ma extends Jo {
        _refreshViews() {
          this.uint8 = new Uint8Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer);
        }
        emplaceBack(t22, e22, r22, n22) {
          const i22 = this.length;
          return this.resize(i22 + 1), this.emplace(i22, t22, e22, r22, n22);
        }
        emplace(t22, e22, r22, n22, i22) {
          const s2 = 4 * t22;
          return this.float32[s2 + 0] = e22, this.float32[s2 + 1] = r22, this.float32[s2 + 2] = n22, this.float32[s2 + 3] = i22, t22;
        }
      }
      ma.prototype.bytesPerElement = 16, js(ma, "StructArrayLayout4f16");
      class ya extends Jo {
        _refreshViews() {
          this.uint8 = new Uint8Array(this.arrayBuffer), this.uint32 = new Uint32Array(this.arrayBuffer);
        }
        emplaceBack(t22) {
          const e22 = this.length;
          return this.resize(e22 + 1), this.emplace(e22, t22);
        }
        emplace(t22, e22) {
          return this.uint32[1 * t22 + 0] = e22, t22;
        }
      }
      ya.prototype.bytesPerElement = 4, js(ya, "StructArrayLayout1ul4");
      class ga extends Jo {
        _refreshViews() {
          this.uint8 = new Uint8Array(this.arrayBuffer), this.uint16 = new Uint16Array(this.arrayBuffer);
        }
        emplaceBack(t22, e22) {
          const r22 = this.length;
          return this.resize(r22 + 1), this.emplace(r22, t22, e22);
        }
        emplace(t22, e22, r22) {
          const n22 = 2 * t22;
          return this.uint16[n22 + 0] = e22, this.uint16[n22 + 1] = r22, t22;
        }
      }
      ga.prototype.bytesPerElement = 4, js(ga, "StructArrayLayout2ui4");
      class xa extends Jo {
        _refreshViews() {
          this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer), this.uint32 = new Uint32Array(this.arrayBuffer), this.uint16 = new Uint16Array(this.arrayBuffer);
        }
        emplaceBack(t22, e22, r22, n22, i22, s2, o2, a22, l22, u22, c22, h22, p22) {
          const f22 = this.length;
          return this.resize(f22 + 1), this.emplace(f22, t22, e22, r22, n22, i22, s2, o2, a22, l22, u22, c22, h22, p22);
        }
        emplace(t22, e22, r22, n22, i22, s2, o2, a22, l22, u22, c22, h22, p22, f22) {
          const d22 = 20 * t22, m22 = 10 * t22;
          return this.int16[d22 + 0] = e22, this.int16[d22 + 1] = r22, this.int16[d22 + 2] = n22, this.int16[d22 + 3] = i22, this.int16[d22 + 4] = s2, this.float32[m22 + 3] = o2, this.float32[m22 + 4] = a22, this.float32[m22 + 5] = l22, this.float32[m22 + 6] = u22, this.int16[d22 + 14] = c22, this.uint32[m22 + 8] = h22, this.uint16[d22 + 18] = p22, this.uint16[d22 + 19] = f22, t22;
        }
      }
      xa.prototype.bytesPerElement = 40, js(xa, "StructArrayLayout5i4f1i1ul2ui40");
      class va extends Jo {
        _refreshViews() {
          this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer);
        }
        emplaceBack(t22, e22, r22, n22, i22, s2, o2) {
          const a22 = this.length;
          return this.resize(a22 + 1), this.emplace(a22, t22, e22, r22, n22, i22, s2, o2);
        }
        emplace(t22, e22, r22, n22, i22, s2, o2, a22) {
          const l22 = 8 * t22;
          return this.int16[l22 + 0] = e22, this.int16[l22 + 1] = r22, this.int16[l22 + 2] = n22, this.int16[l22 + 4] = i22, this.int16[l22 + 5] = s2, this.int16[l22 + 6] = o2, this.int16[l22 + 7] = a22, t22;
        }
      }
      va.prototype.bytesPerElement = 16, js(va, "StructArrayLayout3i2i2i16");
      class ba extends Jo {
        _refreshViews() {
          this.uint8 = new Uint8Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer);
        }
        emplaceBack(t22, e22, r22, n22, i22) {
          const s2 = this.length;
          return this.resize(s2 + 1), this.emplace(s2, t22, e22, r22, n22, i22);
        }
        emplace(t22, e22, r22, n22, i22, s2) {
          const o2 = 4 * t22, a22 = 8 * t22;
          return this.float32[o2 + 0] = e22, this.float32[o2 + 1] = r22, this.float32[o2 + 2] = n22, this.int16[a22 + 6] = i22, this.int16[a22 + 7] = s2, t22;
        }
      }
      ba.prototype.bytesPerElement = 16, js(ba, "StructArrayLayout2f1f2i16");
      class _a2 extends Jo {
        _refreshViews() {
          this.uint8 = new Uint8Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer);
        }
        emplaceBack(t22, e22, r22, n22, i22, s2) {
          const o2 = this.length;
          return this.resize(o2 + 1), this.emplace(o2, t22, e22, r22, n22, i22, s2);
        }
        emplace(t22, e22, r22, n22, i22, s2, o2) {
          const a22 = 20 * t22, l22 = 5 * t22;
          return this.uint8[a22 + 0] = e22, this.uint8[a22 + 1] = r22, this.float32[l22 + 1] = n22, this.float32[l22 + 2] = i22, this.float32[l22 + 3] = s2, this.float32[l22 + 4] = o2, t22;
        }
      }
      _a2.prototype.bytesPerElement = 20, js(_a2, "StructArrayLayout2ub4f20");
      class wa extends Jo {
        _refreshViews() {
          this.uint8 = new Uint8Array(this.arrayBuffer), this.uint16 = new Uint16Array(this.arrayBuffer);
        }
        emplaceBack(t22, e22, r22) {
          const n22 = this.length;
          return this.resize(n22 + 1), this.emplace(n22, t22, e22, r22);
        }
        emplace(t22, e22, r22, n22) {
          const i22 = 3 * t22;
          return this.uint16[i22 + 0] = e22, this.uint16[i22 + 1] = r22, this.uint16[i22 + 2] = n22, t22;
        }
      }
      wa.prototype.bytesPerElement = 6, js(wa, "StructArrayLayout3ui6");
      class Aa extends Jo {
        _refreshViews() {
          this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer), this.uint16 = new Uint16Array(this.arrayBuffer), this.uint32 = new Uint32Array(this.arrayBuffer);
        }
        emplaceBack(t22, e22, r22, n22, i22, s2, o2, a22, l22, u22, c22, h22, p22, f22, d22, m22, y22, g22, x22, v22, b22) {
          const _22 = this.length;
          return this.resize(_22 + 1), this.emplace(_22, t22, e22, r22, n22, i22, s2, o2, a22, l22, u22, c22, h22, p22, f22, d22, m22, y22, g22, x22, v22, b22);
        }
        emplace(t22, e22, r22, n22, i22, s2, o2, a22, l22, u22, c22, h22, p22, f22, d22, m22, y22, g22, x22, v22, b22, _22) {
          const w22 = 30 * t22, A22 = 15 * t22, M22 = 60 * t22;
          return this.int16[w22 + 0] = e22, this.int16[w22 + 1] = r22, this.int16[w22 + 2] = n22, this.float32[A22 + 2] = i22, this.float32[A22 + 3] = s2, this.uint16[w22 + 8] = o2, this.uint16[w22 + 9] = a22, this.uint32[A22 + 5] = l22, this.uint32[A22 + 6] = u22, this.uint32[A22 + 7] = c22, this.uint16[w22 + 16] = h22, this.uint16[w22 + 17] = p22, this.uint16[w22 + 18] = f22, this.float32[A22 + 10] = d22, this.float32[A22 + 11] = m22, this.uint8[M22 + 48] = y22, this.uint8[M22 + 49] = g22, this.uint8[M22 + 50] = x22, this.uint32[A22 + 13] = v22, this.int16[w22 + 28] = b22, this.uint8[M22 + 58] = _22, t22;
        }
      }
      Aa.prototype.bytesPerElement = 60, js(Aa, "StructArrayLayout3i2f2ui3ul3ui2f3ub1ul1i1ub60");
      class Ma extends Jo {
        _refreshViews() {
          this.uint8 = new Uint8Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer), this.uint16 = new Uint16Array(this.arrayBuffer), this.uint32 = new Uint32Array(this.arrayBuffer);
        }
        emplaceBack(t22, e22, r22, n22, i22, s2, o2, a22, l22, u22, c22, h22, p22, f22, d22, m22, y22, g22, x22, v22, b22, _22, w22, A22, M22, I2, S2, z22, k22, E22, P22, T2, B22) {
          const V2 = this.length;
          return this.resize(V2 + 1), this.emplace(V2, t22, e22, r22, n22, i22, s2, o2, a22, l22, u22, c22, h22, p22, f22, d22, m22, y22, g22, x22, v22, b22, _22, w22, A22, M22, I2, S2, z22, k22, E22, P22, T2, B22);
        }
        emplace(t22, e22, r22, n22, i22, s2, o2, a22, l22, u22, c22, h22, p22, f22, d22, m22, y22, g22, x22, v22, b22, _22, w22, A22, M22, I2, S2, z22, k22, E22, P22, T2, B22, V2) {
          const C22 = 20 * t22, D22 = 40 * t22, F2 = 80 * t22;
          return this.float32[C22 + 0] = e22, this.float32[C22 + 1] = r22, this.int16[D22 + 4] = n22, this.int16[D22 + 5] = i22, this.int16[D22 + 6] = s2, this.int16[D22 + 7] = o2, this.int16[D22 + 8] = a22, this.int16[D22 + 9] = l22, this.int16[D22 + 10] = u22, this.int16[D22 + 11] = c22, this.int16[D22 + 12] = h22, this.uint16[D22 + 13] = p22, this.uint16[D22 + 14] = f22, this.uint16[D22 + 15] = d22, this.uint16[D22 + 16] = m22, this.uint16[D22 + 17] = y22, this.uint16[D22 + 18] = g22, this.uint16[D22 + 19] = x22, this.uint16[D22 + 20] = v22, this.uint16[D22 + 21] = b22, this.uint16[D22 + 22] = _22, this.uint16[D22 + 23] = w22, this.uint16[D22 + 24] = A22, this.uint16[D22 + 25] = M22, this.uint16[D22 + 26] = I2, this.uint16[D22 + 27] = S2, this.uint32[C22 + 14] = z22, this.float32[C22 + 15] = k22, this.float32[C22 + 16] = E22, this.float32[C22 + 17] = P22, this.float32[C22 + 18] = T2, this.uint8[F2 + 76] = B22, this.uint16[D22 + 39] = V2, t22;
        }
      }
      Ma.prototype.bytesPerElement = 80, js(Ma, "StructArrayLayout2f9i15ui1ul4f1ub1ui80");
      class Ia extends Jo {
        _refreshViews() {
          this.uint8 = new Uint8Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer);
        }
        emplaceBack(t22, e22, r22, n22, i22) {
          const s2 = this.length;
          return this.resize(s2 + 1), this.emplace(s2, t22, e22, r22, n22, i22);
        }
        emplace(t22, e22, r22, n22, i22, s2) {
          const o2 = 5 * t22;
          return this.float32[o2 + 0] = e22, this.float32[o2 + 1] = r22, this.float32[o2 + 2] = n22, this.float32[o2 + 3] = i22, this.float32[o2 + 4] = s2, t22;
        }
      }
      Ia.prototype.bytesPerElement = 20, js(Ia, "StructArrayLayout5f20");
      class Sa extends Jo {
        _refreshViews() {
          this.uint8 = new Uint8Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer);
        }
        emplaceBack(t22, e22, r22, n22, i22, s2, o2) {
          const a22 = this.length;
          return this.resize(a22 + 1), this.emplace(a22, t22, e22, r22, n22, i22, s2, o2);
        }
        emplace(t22, e22, r22, n22, i22, s2, o2, a22) {
          const l22 = 7 * t22;
          return this.float32[l22 + 0] = e22, this.float32[l22 + 1] = r22, this.float32[l22 + 2] = n22, this.float32[l22 + 3] = i22, this.float32[l22 + 4] = s2, this.float32[l22 + 5] = o2, this.float32[l22 + 6] = a22, t22;
        }
      }
      Sa.prototype.bytesPerElement = 28, js(Sa, "StructArrayLayout7f28");
      class za extends Jo {
        _refreshViews() {
          this.uint8 = new Uint8Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer);
        }
        emplaceBack(t22, e22, r22, n22, i22, s2, o2, a22, l22, u22, c22) {
          const h22 = this.length;
          return this.resize(h22 + 1), this.emplace(h22, t22, e22, r22, n22, i22, s2, o2, a22, l22, u22, c22);
        }
        emplace(t22, e22, r22, n22, i22, s2, o2, a22, l22, u22, c22, h22) {
          const p22 = 11 * t22;
          return this.float32[p22 + 0] = e22, this.float32[p22 + 1] = r22, this.float32[p22 + 2] = n22, this.float32[p22 + 3] = i22, this.float32[p22 + 4] = s2, this.float32[p22 + 5] = o2, this.float32[p22 + 6] = a22, this.float32[p22 + 7] = l22, this.float32[p22 + 8] = u22, this.float32[p22 + 9] = c22, this.float32[p22 + 10] = h22, t22;
        }
      }
      za.prototype.bytesPerElement = 44, js(za, "StructArrayLayout11f44");
      class ka extends Jo {
        _refreshViews() {
          this.uint8 = new Uint8Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer);
        }
        emplaceBack(t22, e22, r22, n22, i22, s2, o2, a22, l22) {
          const u22 = this.length;
          return this.resize(u22 + 1), this.emplace(u22, t22, e22, r22, n22, i22, s2, o2, a22, l22);
        }
        emplace(t22, e22, r22, n22, i22, s2, o2, a22, l22, u22) {
          const c22 = 9 * t22;
          return this.float32[c22 + 0] = e22, this.float32[c22 + 1] = r22, this.float32[c22 + 2] = n22, this.float32[c22 + 3] = i22, this.float32[c22 + 4] = s2, this.float32[c22 + 5] = o2, this.float32[c22 + 6] = a22, this.float32[c22 + 7] = l22, this.float32[c22 + 8] = u22, t22;
        }
      }
      ka.prototype.bytesPerElement = 36, js(ka, "StructArrayLayout9f36");
      class Ea extends Jo {
        _refreshViews() {
          this.uint8 = new Uint8Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer);
        }
        emplaceBack(t22, e22) {
          const r22 = this.length;
          return this.resize(r22 + 1), this.emplace(r22, t22, e22);
        }
        emplace(t22, e22, r22) {
          const n22 = 2 * t22;
          return this.float32[n22 + 0] = e22, this.float32[n22 + 1] = r22, t22;
        }
      }
      Ea.prototype.bytesPerElement = 8, js(Ea, "StructArrayLayout2f8");
      class Pa extends Jo {
        _refreshViews() {
          this.uint8 = new Uint8Array(this.arrayBuffer), this.uint32 = new Uint32Array(this.arrayBuffer), this.uint16 = new Uint16Array(this.arrayBuffer);
        }
        emplaceBack(t22, e22, r22, n22) {
          const i22 = this.length;
          return this.resize(i22 + 1), this.emplace(i22, t22, e22, r22, n22);
        }
        emplace(t22, e22, r22, n22, i22) {
          const s2 = 6 * t22;
          return this.uint32[3 * t22 + 0] = e22, this.uint16[s2 + 2] = r22, this.uint16[s2 + 3] = n22, this.uint16[s2 + 4] = i22, t22;
        }
      }
      Pa.prototype.bytesPerElement = 12, js(Pa, "StructArrayLayout1ul3ui12");
      class Ta extends Jo {
        _refreshViews() {
          this.uint8 = new Uint8Array(this.arrayBuffer), this.uint16 = new Uint16Array(this.arrayBuffer);
        }
        emplaceBack(t22) {
          const e22 = this.length;
          return this.resize(e22 + 1), this.emplace(e22, t22);
        }
        emplace(t22, e22) {
          return this.uint16[1 * t22 + 0] = e22, t22;
        }
      }
      Ta.prototype.bytesPerElement = 2, js(Ta, "StructArrayLayout1ui2");
      class Ba extends Jo {
        _refreshViews() {
          this.uint8 = new Uint8Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer);
        }
        emplaceBack(t22, e22, r22, n22, i22, s2, o2, a22, l22, u22, c22, h22, p22, f22, d22, m22) {
          const y22 = this.length;
          return this.resize(y22 + 1), this.emplace(y22, t22, e22, r22, n22, i22, s2, o2, a22, l22, u22, c22, h22, p22, f22, d22, m22);
        }
        emplace(t22, e22, r22, n22, i22, s2, o2, a22, l22, u22, c22, h22, p22, f22, d22, m22, y22) {
          const g22 = 16 * t22;
          return this.float32[g22 + 0] = e22, this.float32[g22 + 1] = r22, this.float32[g22 + 2] = n22, this.float32[g22 + 3] = i22, this.float32[g22 + 4] = s2, this.float32[g22 + 5] = o2, this.float32[g22 + 6] = a22, this.float32[g22 + 7] = l22, this.float32[g22 + 8] = u22, this.float32[g22 + 9] = c22, this.float32[g22 + 10] = h22, this.float32[g22 + 11] = p22, this.float32[g22 + 12] = f22, this.float32[g22 + 13] = d22, this.float32[g22 + 14] = m22, this.float32[g22 + 15] = y22, t22;
        }
      }
      Ba.prototype.bytesPerElement = 64, js(Ba, "StructArrayLayout16f64");
      class Va extends Jo {
        _refreshViews() {
          this.uint8 = new Uint8Array(this.arrayBuffer), this.uint16 = new Uint16Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer);
        }
        emplaceBack(t22, e22, r22, n22, i22, s2, o2) {
          const a22 = this.length;
          return this.resize(a22 + 1), this.emplace(a22, t22, e22, r22, n22, i22, s2, o2);
        }
        emplace(t22, e22, r22, n22, i22, s2, o2, a22) {
          const l22 = 10 * t22, u22 = 5 * t22;
          return this.uint16[l22 + 0] = e22, this.uint16[l22 + 1] = r22, this.uint16[l22 + 2] = n22, this.uint16[l22 + 3] = i22, this.float32[u22 + 2] = s2, this.float32[u22 + 3] = o2, this.float32[u22 + 4] = a22, t22;
        }
      }
      Va.prototype.bytesPerElement = 20, js(Va, "StructArrayLayout4ui3f20");
      class Ca extends Jo {
        _refreshViews() {
          this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer);
        }
        emplaceBack(t22) {
          const e22 = this.length;
          return this.resize(e22 + 1), this.emplace(e22, t22);
        }
        emplace(t22, e22) {
          return this.int16[1 * t22 + 0] = e22, t22;
        }
      }
      Ca.prototype.bytesPerElement = 2, js(Ca, "StructArrayLayout1i2");
      class Da extends Jo {
        _refreshViews() {
          this.uint8 = new Uint8Array(this.arrayBuffer);
        }
        emplaceBack(t22) {
          const e22 = this.length;
          return this.resize(e22 + 1), this.emplace(e22, t22);
        }
        emplace(t22, e22) {
          return this.uint8[1 * t22 + 0] = e22, t22;
        }
      }
      Da.prototype.bytesPerElement = 1, js(Da, "StructArrayLayout1ub1");
      class Fa extends Ko {
        get projectedAnchorX() {
          return this._structArray.int16[this._pos2 + 0];
        }
        get projectedAnchorY() {
          return this._structArray.int16[this._pos2 + 1];
        }
        get projectedAnchorZ() {
          return this._structArray.int16[this._pos2 + 2];
        }
        get tileAnchorX() {
          return this._structArray.int16[this._pos2 + 3];
        }
        get tileAnchorY() {
          return this._structArray.int16[this._pos2 + 4];
        }
        get x1() {
          return this._structArray.float32[this._pos4 + 3];
        }
        get y1() {
          return this._structArray.float32[this._pos4 + 4];
        }
        get x2() {
          return this._structArray.float32[this._pos4 + 5];
        }
        get y2() {
          return this._structArray.float32[this._pos4 + 6];
        }
        get padding() {
          return this._structArray.int16[this._pos2 + 14];
        }
        get featureIndex() {
          return this._structArray.uint32[this._pos4 + 8];
        }
        get sourceLayerIndex() {
          return this._structArray.uint16[this._pos2 + 18];
        }
        get bucketIndex() {
          return this._structArray.uint16[this._pos2 + 19];
        }
      }
      Fa.prototype.size = 40;
      class La extends xa {
        get(t22) {
          return new Fa(this, t22);
        }
      }
      js(La, "CollisionBoxArray");
      class Ra extends Ko {
        get projectedAnchorX() {
          return this._structArray.int16[this._pos2 + 0];
        }
        get projectedAnchorY() {
          return this._structArray.int16[this._pos2 + 1];
        }
        get projectedAnchorZ() {
          return this._structArray.int16[this._pos2 + 2];
        }
        get tileAnchorX() {
          return this._structArray.float32[this._pos4 + 2];
        }
        get tileAnchorY() {
          return this._structArray.float32[this._pos4 + 3];
        }
        get glyphStartIndex() {
          return this._structArray.uint16[this._pos2 + 8];
        }
        get numGlyphs() {
          return this._structArray.uint16[this._pos2 + 9];
        }
        get vertexStartIndex() {
          return this._structArray.uint32[this._pos4 + 5];
        }
        get lineStartIndex() {
          return this._structArray.uint32[this._pos4 + 6];
        }
        get lineLength() {
          return this._structArray.uint32[this._pos4 + 7];
        }
        get segment() {
          return this._structArray.uint16[this._pos2 + 16];
        }
        get lowerSize() {
          return this._structArray.uint16[this._pos2 + 17];
        }
        get upperSize() {
          return this._structArray.uint16[this._pos2 + 18];
        }
        get lineOffsetX() {
          return this._structArray.float32[this._pos4 + 10];
        }
        get lineOffsetY() {
          return this._structArray.float32[this._pos4 + 11];
        }
        get writingMode() {
          return this._structArray.uint8[this._pos1 + 48];
        }
        get placedOrientation() {
          return this._structArray.uint8[this._pos1 + 49];
        }
        set placedOrientation(t22) {
          this._structArray.uint8[this._pos1 + 49] = t22;
        }
        get hidden() {
          return this._structArray.uint8[this._pos1 + 50];
        }
        set hidden(t22) {
          this._structArray.uint8[this._pos1 + 50] = t22;
        }
        get crossTileID() {
          return this._structArray.uint32[this._pos4 + 13];
        }
        set crossTileID(t22) {
          this._structArray.uint32[this._pos4 + 13] = t22;
        }
        get associatedIconIndex() {
          return this._structArray.int16[this._pos2 + 28];
        }
        get flipState() {
          return this._structArray.uint8[this._pos1 + 58];
        }
        set flipState(t22) {
          this._structArray.uint8[this._pos1 + 58] = t22;
        }
      }
      Ra.prototype.size = 60;
      class Oa extends Aa {
        get(t22) {
          return new Ra(this, t22);
        }
      }
      js(Oa, "PlacedSymbolArray");
      class Ua extends Ko {
        get tileAnchorX() {
          return this._structArray.float32[this._pos4 + 0];
        }
        get tileAnchorY() {
          return this._structArray.float32[this._pos4 + 1];
        }
        get projectedAnchorX() {
          return this._structArray.int16[this._pos2 + 4];
        }
        get projectedAnchorY() {
          return this._structArray.int16[this._pos2 + 5];
        }
        get projectedAnchorZ() {
          return this._structArray.int16[this._pos2 + 6];
        }
        get rightJustifiedTextSymbolIndex() {
          return this._structArray.int16[this._pos2 + 7];
        }
        get centerJustifiedTextSymbolIndex() {
          return this._structArray.int16[this._pos2 + 8];
        }
        get leftJustifiedTextSymbolIndex() {
          return this._structArray.int16[this._pos2 + 9];
        }
        get verticalPlacedTextSymbolIndex() {
          return this._structArray.int16[this._pos2 + 10];
        }
        get placedIconSymbolIndex() {
          return this._structArray.int16[this._pos2 + 11];
        }
        get verticalPlacedIconSymbolIndex() {
          return this._structArray.int16[this._pos2 + 12];
        }
        get key() {
          return this._structArray.uint16[this._pos2 + 13];
        }
        get textBoxStartIndex() {
          return this._structArray.uint16[this._pos2 + 14];
        }
        get textBoxEndIndex() {
          return this._structArray.uint16[this._pos2 + 15];
        }
        get verticalTextBoxStartIndex() {
          return this._structArray.uint16[this._pos2 + 16];
        }
        get verticalTextBoxEndIndex() {
          return this._structArray.uint16[this._pos2 + 17];
        }
        get iconBoxStartIndex() {
          return this._structArray.uint16[this._pos2 + 18];
        }
        get iconBoxEndIndex() {
          return this._structArray.uint16[this._pos2 + 19];
        }
        get verticalIconBoxStartIndex() {
          return this._structArray.uint16[this._pos2 + 20];
        }
        get verticalIconBoxEndIndex() {
          return this._structArray.uint16[this._pos2 + 21];
        }
        get featureIndex() {
          return this._structArray.uint16[this._pos2 + 22];
        }
        get numHorizontalGlyphVertices() {
          return this._structArray.uint16[this._pos2 + 23];
        }
        get numVerticalGlyphVertices() {
          return this._structArray.uint16[this._pos2 + 24];
        }
        get numIconVertices() {
          return this._structArray.uint16[this._pos2 + 25];
        }
        get numVerticalIconVertices() {
          return this._structArray.uint16[this._pos2 + 26];
        }
        get useRuntimeCollisionCircles() {
          return this._structArray.uint16[this._pos2 + 27];
        }
        get crossTileID() {
          return this._structArray.uint32[this._pos4 + 14];
        }
        set crossTileID(t22) {
          this._structArray.uint32[this._pos4 + 14] = t22;
        }
        get textOffset0() {
          return this._structArray.float32[this._pos4 + 15];
        }
        get textOffset1() {
          return this._structArray.float32[this._pos4 + 16];
        }
        get collisionCircleDiameter() {
          return this._structArray.float32[this._pos4 + 17];
        }
        get zOffset() {
          return this._structArray.float32[this._pos4 + 18];
        }
        set zOffset(t22) {
          this._structArray.float32[this._pos4 + 18] = t22;
        }
        get hasIconTextFit() {
          return this._structArray.uint8[this._pos1 + 76];
        }
        get elevationFeatureIndex() {
          return this._structArray.uint16[this._pos2 + 39];
        }
      }
      Ua.prototype.size = 80;
      class Na extends Ma {
        get(t22) {
          return new Ua(this, t22);
        }
      }
      js(Na, "SymbolInstanceArray");
      class ja extends ia {
        getoffsetX(t22) {
          return this.float32[1 * t22 + 0];
        }
      }
      js(ja, "GlyphOffsetArray");
      class $a extends ea {
        getx(t22) {
          return this.int16[2 * t22 + 0];
        }
        gety(t22) {
          return this.int16[2 * t22 + 1];
        }
      }
      js($a, "SymbolLineVertexArray");
      class Ga extends Ko {
        get featureIndex() {
          return this._structArray.uint32[this._pos4 + 0];
        }
        get sourceLayerIndex() {
          return this._structArray.uint16[this._pos2 + 2];
        }
        get bucketIndex() {
          return this._structArray.uint16[this._pos2 + 3];
        }
        get layoutVertexArrayOffset() {
          return this._structArray.uint16[this._pos2 + 4];
        }
      }
      Ga.prototype.size = 12;
      class qa extends Pa {
        get(t22) {
          return new Ga(this, t22);
        }
      }
      js(qa, "FeatureIndexArray");
      class Ha extends ga {
        geta_centroid_pos0(t22) {
          return this.uint16[2 * t22 + 0];
        }
        geta_centroid_pos1(t22) {
          return this.uint16[2 * t22 + 1];
        }
      }
      js(Ha, "FillExtrusionCentroidArray");
      class Xa extends Ko {
        get a_join_normal_inside0() {
          return this._structArray.int16[this._pos2 + 0];
        }
        get a_join_normal_inside1() {
          return this._structArray.int16[this._pos2 + 1];
        }
        get a_join_normal_inside2() {
          return this._structArray.int16[this._pos2 + 2];
        }
      }
      Xa.prototype.size = 6;
      class Za extends ra {
        get(t22) {
          return new Xa(this, t22);
        }
      }
      js(Za, "FillExtrusionWallArray");
      const Wa = Qo([{ name: "a_pos", components: 2, type: "Int16" }], 4), Ya = Qo([{ name: "a_pos_3", components: 3, type: "Int16" }, { name: "a_pos_normal_3", components: 3, type: "Int16" }]);
      class Ka {
        constructor(t22 = []) {
          this.segments = t22;
        }
        _prepareSegment(t22, e22, r22, n22) {
          let i22 = this.segments[this.segments.length - 1];
          return t22 > Ka.MAX_VERTEX_ARRAY_LENGTH && $t2(`Max vertices per segment is ${Ka.MAX_VERTEX_ARRAY_LENGTH}: bucket requested ${t22}`), (!i22 || i22.vertexLength + t22 > Ka.MAX_VERTEX_ARRAY_LENGTH || i22.sortKey !== n22) && (i22 = { vertexOffset: e22, primitiveOffset: r22, vertexLength: 0, primitiveLength: 0 }, void 0 !== n22 && (i22.sortKey = n22), this.segments.push(i22)), i22;
        }
        prepareSegment(t22, e22, r22, n22) {
          return this._prepareSegment(t22, e22.length, r22.length, n22);
        }
        get() {
          return this.segments;
        }
        destroy() {
          for (const t22 of this.segments) for (const e22 in t22.vaos) t22.vaos[e22].destroy();
        }
        static simpleSegment(t22, e22, r22, n22) {
          return new Ka([{ vertexOffset: t22, primitiveOffset: e22, vertexLength: r22, primitiveLength: n22, vaos: {}, sortKey: 0 }]);
        }
      }
      function Ja(t22, e22) {
        return 256 * (t22 = Pt(Math.floor(t22), 0, 255)) + Pt(Math.floor(e22), 0, 255);
      }
      Ka.MAX_VERTEX_ARRAY_LENGTH = Math.pow(2, 16) - 1, js(Ka, "SegmentVector");
      const Qa = Qo([{ name: "a_pattern", components: 4, type: "Uint16" }, { name: "a_pixel_ratio", components: 1, type: "Float32" }]), tl = Qo([{ name: "a_pattern_b", components: 4, type: "Uint16" }, { name: "a_pixel_ratio", components: 1, type: "Float32" }]), el = Qo([{ name: "a_dash", components: 4, type: "Uint16" }]);
      class rl {
        constructor() {
          this.ids = [], this.uniqueIds = [], this.positions = [], this.indexed = false;
        }
        add(t22, e22, r22, n22) {
          this.ids.push(nl(t22)), this.positions.push(e22, r22, n22);
        }
        eachPosition(t22, e22) {
          const r22 = nl(t22);
          let n22 = 0, i22 = this.ids.length - 1;
          for (; n22 < i22; ) {
            const t3 = n22 + i22 >> 1;
            this.ids[t3] >= r22 ? i22 = t3 : n22 = t3 + 1;
          }
          for (; this.ids[n22] === r22; ) e22(this.positions[3 * n22], this.positions[3 * n22 + 1], this.positions[3 * n22 + 2]), n22++;
        }
        static serialize(t22, e22) {
          const r22 = new Float64Array(t22.ids), n22 = new Uint32Array(t22.positions);
          return il(r22, n22, 0, r22.length - 1), e22 && (e22.add(r22.buffer), e22.add(n22.buffer)), { ids: r22, positions: n22 };
        }
        static deserialize(t22) {
          const e22 = new rl();
          let r22;
          e22.ids = t22.ids, e22.positions = t22.positions;
          for (const t3 of e22.ids) t3 !== r22 && e22.uniqueIds.push(t3), r22 = t3;
          return e22.indexed = true, e22;
        }
      }
      function nl(t22) {
        const e22 = +t22;
        return !isNaN(e22) && Number.MIN_SAFE_INTEGER <= e22 && e22 <= Number.MAX_SAFE_INTEGER ? e22 : Ze(String(t22));
      }
      function il(t22, e22, r22, n22) {
        for (; r22 < n22; ) {
          const i22 = t22[r22 + n22 >> 1];
          let s2 = r22 - 1, o2 = n22 + 1;
          for (; ; ) {
            do {
              s2++;
            } while (t22[s2] < i22);
            do {
              o2--;
            } while (t22[o2] > i22);
            if (s2 >= o2) break;
            sl(t22, s2, o2), sl(e22, 3 * s2, 3 * o2), sl(e22, 3 * s2 + 1, 3 * o2 + 1), sl(e22, 3 * s2 + 2, 3 * o2 + 2);
          }
          o2 - r22 < n22 - o2 ? (il(t22, e22, r22, o2), r22 = o2 + 1) : (il(t22, e22, o2 + 1, n22), n22 = o2);
        }
      }
      function sl(t22, e22, r22) {
        const n22 = t22[e22];
        t22[e22] = t22[r22], t22[r22] = n22;
      }
      js(rl, "FeaturePositionMap");
      class ol {
        constructor(t22) {
          this.gl = t22.gl, this.initialized = false;
        }
        fetchUniformLocation(t22, e22) {
          return this.location || this.initialized || (this.location = this.gl.getUniformLocation(t22, e22), this.initialized = true), !!this.location;
        }
        set(t22, e22, r22) {
          throw new Error("Uniform#set() must be implemented by each concrete Uniform");
        }
      }
      class al extends ol {
        constructor(t22) {
          super(t22), this.current = 0;
        }
        set(t22, e22, r22) {
          this.fetchUniformLocation(t22, e22) && this.current !== r22 && (this.current = r22, this.gl.uniform1i(this.location, r22));
        }
      }
      class ll extends ol {
        constructor(t22) {
          super(t22), this.current = 0;
        }
        set(t22, e22, r22) {
          this.fetchUniformLocation(t22, e22) && this.current !== r22 && (this.current = r22, this.gl.uniform1f(this.location, r22));
        }
      }
      class ul extends ol {
        constructor(t22) {
          super(t22), this.current = [0, 0];
        }
        set(t22, e22, r22) {
          this.fetchUniformLocation(t22, e22) && (r22[0] === this.current[0] && r22[1] === this.current[1] || (this.current = r22, this.gl.uniform2f(this.location, r22[0], r22[1])));
        }
      }
      class cl extends ol {
        constructor(t22) {
          super(t22), this.current = [0, 0, 0];
        }
        set(t22, e22, r22) {
          this.fetchUniformLocation(t22, e22) && (r22[0] === this.current[0] && r22[1] === this.current[1] && r22[2] === this.current[2] || (this.current = r22, this.gl.uniform3f(this.location, r22[0], r22[1], r22[2])));
        }
      }
      class hl extends ol {
        constructor(t22) {
          super(t22), this.current = [0, 0, 0, 0];
        }
        set(t22, e22, r22) {
          this.fetchUniformLocation(t22, e22) && (r22[0] === this.current[0] && r22[1] === this.current[1] && r22[2] === this.current[2] && r22[3] === this.current[3] || (this.current = r22, this.gl.uniform4f(this.location, r22[0], r22[1], r22[2], r22[3])));
        }
      }
      class pl extends ol {
        constructor(t22) {
          super(t22), this.current = ir.transparent.toRenderColor(null);
        }
        set(t22, e22, r22) {
          this.fetchUniformLocation(t22, e22) && (r22.r === this.current.r && r22.g === this.current.g && r22.b === this.current.b && r22.a === this.current.a || (this.current = r22, this.gl.uniform4f(this.location, r22.r, r22.g, r22.b, r22.a)));
        }
      }
      const fl = new Float32Array(16);
      class dl extends ol {
        constructor(t22) {
          super(t22), this.current = fl;
        }
        set(t22, e22, r22) {
          if (this.fetchUniformLocation(t22, e22)) {
            if (r22[12] !== this.current[12] || r22[0] !== this.current[0]) return this.current = r22, void this.gl.uniformMatrix4fv(this.location, false, r22);
            for (let t3 = 1; t3 < 16; t3++) if (r22[t3] !== this.current[t3]) {
              this.current = r22, this.gl.uniformMatrix4fv(this.location, false, r22);
              break;
            }
          }
        }
      }
      const ml = new Float32Array(9), yl = new Float32Array(4);
      class gl extends ol {
        constructor(t22) {
          super(t22), this.current = yl;
        }
        set(t22, e22, r22) {
          if (this.fetchUniformLocation(t22, e22)) {
            for (let t3 = 0; t3 < 4; t3++) if (r22[t3] !== this.current[t3]) {
              this.current = r22, this.gl.uniformMatrix2fv(this.location, false, r22);
              break;
            }
          }
        }
      }
      function xl(t22) {
        return [Ja(255 * t22.r, 255 * t22.g), Ja(255 * t22.b, 255 * t22.a)];
      }
      class vl {
        constructor(t22, e22, r22, n22) {
          this.value = t22, this.uniformNames = e22.map((t3) => `u_${t3}`), this.type = r22, this.context = n22;
        }
        setUniform(t22, e22, r22, n22, i22) {
          const s2 = n22.constantOr(this.value);
          e22.set(t22, i22, s2 instanceof ir ? s2.toRenderColor(this.lutExpression && "none" === this.lutExpression.value ? null : this.context.lut) : s2);
        }
        getBinding(t22, e22) {
          return "color" === this.type ? new pl(t22) : new ll(t22);
        }
      }
      class bl {
        constructor(t22, e22) {
          this.uniformNames = e22.map((t3) => `u_${t3}`), this.pattern = null, this.patternTransition = null, this.pixelRatio = 1;
        }
        setConstantPatternPositions(t22, e22) {
          this.pixelRatio = t22.pixelRatio || 1, this.pattern = t22.tl.concat(t22.br), this.patternTransition = e22 ? e22.tl.concat(e22.br) : this.pattern;
        }
        setUniform(t22, e22, r22, n22, i22) {
          let s2 = null;
          "u_pattern" !== i22 && "u_dash" !== i22 || (s2 = this.pattern), "u_pattern_b" === i22 && (s2 = this.patternTransition), "u_pixel_ratio" === i22 && (s2 = this.pixelRatio), s2 && e22.set(t22, i22, s2);
        }
        getBinding(t22, e22) {
          return "u_pattern" === e22 || "u_pattern_b" === e22 || "u_dash" === e22 ? new hl(t22) : new ll(t22);
        }
      }
      class _l {
        constructor(t22, e22, r22, n22) {
          this.expression = t22, this.type = r22, this.maxValue = 0, this.paintVertexAttributes = e22.map((t3) => ({ name: `a_${t3}`, type: "Float32", components: "color" === r22 ? 2 : 1, offset: 0 })), this.paintVertexArray = new n22();
        }
        populatePaintArray(t22, e22, r22, n22, i22, s2, o2) {
          const a22 = this.paintVertexArray.length, l22 = "composite" === this.expression.kind || "source" === this.expression.kind ? this.expression.evaluate(new yo(0, { brightness: s2 }), e22, {}, i22, n22, o2) : "constant" === this.expression.kind && this.expression.value, u22 = !!this.lutExpression && "none" === ("composite" === this.lutExpression.kind || "source" === this.lutExpression.kind ? this.lutExpression.evaluate(new yo(0, { brightness: s2 }), e22, {}, i22, n22, o2) : this.lutExpression.value);
          this.paintVertexArray.resize(t22), this._setPaintValue(a22, t22, l22, u22 ? null : this.context.lut);
        }
        updatePaintArray(t22, e22, r22, n22, i22, s2, o2) {
          const a22 = "composite" === this.expression.kind || "source" === this.expression.kind ? this.expression.evaluate({ zoom: 0, brightness: o2 }, r22, n22, void 0, i22) : "constant" === this.expression.kind && this.expression.value, l22 = !!this.lutExpression && "none" === ("composite" === this.lutExpression.kind || "source" === this.lutExpression.kind ? this.lutExpression.evaluate(new yo(0, { brightness: o2 }), r22, n22, void 0, i22) : this.lutExpression.value);
          this._setPaintValue(t22, e22, a22, l22 ? null : this.context.lut);
        }
        _setPaintValue(t22, e22, r22, n22) {
          if ("color" === this.type) {
            const i22 = xl(r22.toRenderColor(n22));
            for (let r3 = t22; r3 < e22; r3++) this.paintVertexArray.emplace(r3, i22[0], i22[1]);
          } else {
            for (let n3 = t22; n3 < e22; n3++) this.paintVertexArray.emplace(n3, r22);
            this.maxValue = Math.max(this.maxValue, Math.abs(r22));
          }
        }
        upload(t22) {
          this.paintVertexArray && this.paintVertexArray.arrayBuffer && (this.paintVertexBuffer && this.paintVertexBuffer.buffer ? this.paintVertexBuffer.updateData(this.paintVertexArray) : this.paintVertexBuffer = t22.createVertexBuffer(this.paintVertexArray, this.paintVertexAttributes, this.lutExpression && "constant" !== this.lutExpression.kind && (this.lutExpression.isStateDependent || !this.lutExpression.isLightConstant) || "constant" !== this.expression.kind && (this.expression.isStateDependent || !this.expression.isLightConstant)));
        }
        destroy() {
          this.paintVertexBuffer && this.paintVertexBuffer.destroy();
        }
      }
      class wl {
        constructor(t22, e22, r22, n22, i22, s2) {
          this.expression = t22, this.uniformNames = e22.map((t3) => `u_${t3}_t`), this.type = r22, this.useIntegerZoom = n22, this.context = i22, this.maxValue = 0, this.paintVertexAttributes = e22.map((t3) => ({ name: `a_${t3}`, type: "Float32", components: "color" === r22 ? 4 : 2, offset: 0 })), this.paintVertexArray = new s2();
        }
        populatePaintArray(t22, e22, r22, n22, i22, s2, o2) {
          const a22 = this.expression.evaluate(new yo(this.context.zoom, { brightness: s2 }), e22, {}, i22, n22, o2), l22 = this.expression.evaluate(new yo(this.context.zoom + 1, { brightness: s2 }), e22, {}, i22, n22, o2), u22 = !!this.lutExpression && "none" === ("composite" === this.lutExpression.kind || "source" === this.lutExpression.kind ? this.lutExpression.evaluate(new yo(0, { brightness: s2 }), e22, {}, i22, n22, o2) : this.lutExpression.value), c22 = this.paintVertexArray.length;
          this.paintVertexArray.resize(t22), this._setPaintValue(c22, t22, a22, l22, u22 ? null : this.context.lut);
        }
        updatePaintArray(t22, e22, r22, n22, i22, s2, o2) {
          const a22 = this.expression.evaluate({ zoom: this.context.zoom, brightness: o2 }, r22, n22, void 0, i22), l22 = this.expression.evaluate({ zoom: this.context.zoom + 1, brightness: o2 }, r22, n22, void 0, i22), u22 = !!this.lutExpression && "none" === ("composite" === this.lutExpression.kind || "source" === this.lutExpression.kind ? this.lutExpression.evaluate(new yo(0, { brightness: o2 }), r22, n22, void 0, i22) : this.lutExpression.value);
          this._setPaintValue(t22, e22, a22, l22, u22 ? null : this.context.lut);
        }
        _setPaintValue(t22, e22, r22, n22, i22) {
          if ("color" === this.type) {
            const n3 = xl(r22.toRenderColor(i22)), s2 = xl(r22.toRenderColor(i22));
            for (let r3 = t22; r3 < e22; r3++) this.paintVertexArray.emplace(r3, n3[0], n3[1], s2[0], s2[1]);
          } else {
            for (let i3 = t22; i3 < e22; i3++) this.paintVertexArray.emplace(i3, r22, n22);
            this.maxValue = Math.max(this.maxValue, Math.abs(r22), Math.abs(n22));
          }
        }
        upload(t22) {
          this.paintVertexArray && this.paintVertexArray.arrayBuffer && (this.paintVertexBuffer && this.paintVertexBuffer.buffer ? this.paintVertexBuffer.updateData(this.paintVertexArray) : this.paintVertexBuffer = t22.createVertexBuffer(this.paintVertexArray, this.paintVertexAttributes, this.expression.isStateDependent || !this.expression.isLightConstant));
        }
        destroy() {
          this.paintVertexBuffer && this.paintVertexBuffer.destroy();
        }
        setUniform(t22, e22, r22, n22, i22) {
          const s2 = this.useIntegerZoom ? Math.floor(r22.zoom) : r22.zoom, o2 = Pt(this.expression.interpolationFactor(s2, this.context.zoom, this.context.zoom + 1), 0, 1);
          e22.set(t22, i22, o2);
        }
        getBinding(t22, e22) {
          return new ll(t22);
        }
      }
      class Al {
        constructor(t22, e22, r22, n22, i22) {
          this.expression = t22, this.layerId = i22, this.paintVertexAttributes = ("array" === r22 ? el : Qa).members;
          for (let t3 = 0; t3 < e22.length; ++t3) ;
          this.paintVertexArray = new n22(), this.paintTransitionVertexArray = new ca();
        }
        populatePaintArray(t22, e22, r22, n22) {
          const i22 = this.paintVertexArray.length;
          this.paintVertexArray.resize(t22), this._setPaintValues(i22, t22, e22.patterns && e22.patterns[this.layerId], r22);
        }
        updatePaintArray(t22, e22, r22, n22, i22, s2, o2) {
          this._setPaintValues(t22, e22, r22.patterns && r22.patterns[this.layerId], s2);
        }
        _setPaintValues(t22, e22, r22, n22) {
          if (!n22 || !r22) return;
          const i22 = n22[r22[0]], s2 = n22[r22[1]];
          if (i22) {
            if (i22) {
              const { tl: r3, br: n3, pixelRatio: s3 } = i22;
              for (let i3 = t22; i3 < e22; i3++) this.paintVertexArray.emplace(i3, r3[0], r3[1], n3[0], n3[1], s3);
            }
            if (s2) {
              this.paintTransitionVertexArray.resize(this.paintVertexArray.length);
              const { tl: r3, br: n3, pixelRatio: i3 } = s2;
              for (let s3 = t22; s3 < e22; s3++) this.paintTransitionVertexArray.emplace(s3, r3[0], r3[1], n3[0], n3[1], i3);
            }
          }
        }
        upload(t22) {
          const e22 = this.expression.isStateDependent || !this.expression.isLightConstant;
          this.paintVertexArray && this.paintVertexArray.arrayBuffer && (this.paintVertexBuffer = t22.createVertexBuffer(this.paintVertexArray, this.paintVertexAttributes, e22)), this.paintTransitionVertexArray && this.paintTransitionVertexArray.length && (this.paintTransitionVertexBuffer = t22.createVertexBuffer(this.paintTransitionVertexArray, tl.members, e22));
        }
        destroy() {
          this.paintVertexBuffer && this.paintVertexBuffer.destroy(), this.paintTransitionVertexBuffer && this.paintTransitionVertexBuffer.destroy();
        }
      }
      class Ml {
        constructor(t22, e22, r22 = () => true) {
          this.binders = {}, this._buffers = [], this.context = e22;
          const n22 = [];
          for (const i22 in t22.paint._values) {
            const s2 = t22.paint.get(i22);
            if (i22.endsWith("-use-theme")) continue;
            if (!r22(i22)) continue;
            if (!(s2 instanceof Ao && gs(s2.property.specification))) continue;
            const o2 = zl(i22, t22.type), a22 = s2.value, l22 = s2.property.specification.type, u22 = !!s2.property.useIntegerZoom, c22 = "line-dasharray" === i22 || i22.endsWith("pattern"), h22 = t22.paint.get(`${i22}-use-theme`), p22 = "line-dasharray" === i22 && "constant" !== t22.layout.get("line-cap").value.kind || h22 && "constant" !== h22.value.kind;
            if ("constant" !== a22.kind || p22) if ("source" === a22.kind || p22 || c22) {
              const e3 = Pl(i22, l22, "source");
              this.binders[i22] = c22 ? new Al(a22, o2, l22, e3, t22.id) : new _l(a22, o2, l22, e3), n22.push(`/a_${i22}`);
            } else {
              const t3 = Pl(i22, l22, "composite");
              this.binders[i22] = new wl(a22, o2, l22, u22, e22, t3), n22.push(`/z_${i22}`);
            }
            else this.binders[i22] = c22 ? new bl(a22.value, o2) : new vl(a22.value, o2, l22, e22), n22.push(`/u_${i22}`);
            h22 && (this.binders[i22].lutExpression = h22.value);
          }
          this.cacheKey = n22.sort().join("");
        }
        getMaxValue(t22) {
          const e22 = this.binders[t22];
          return e22 instanceof _l || e22 instanceof wl ? e22.maxValue : 0;
        }
        populatePaintArrays(t22, e22, r22, n22, i22, s2, o2) {
          for (const a22 in this.binders) {
            const l22 = this.binders[a22];
            l22.context = this.context, (l22 instanceof _l || l22 instanceof wl || l22 instanceof Al) && l22.populatePaintArray(t22, e22, r22, n22, i22, s2, o2);
          }
        }
        setConstantPatternPositions(t22, e22) {
          for (const r22 in this.binders) {
            const n22 = this.binders[r22];
            n22 instanceof bl && n22.setConstantPatternPositions(t22, e22);
          }
        }
        getPatternTransitionVertexBuffer(t22) {
          const e22 = this.binders[t22];
          return e22 instanceof Al ? e22.paintTransitionVertexBuffer : null;
        }
        updatePaintArrays(t22, e22, r22, n22, i22, s2, o2, a22, l22) {
          let u22 = false;
          const c22 = Object.keys(t22), h22 = 0 !== c22.length && !a22, p22 = h22 ? c22 : e22.uniqueIds;
          this.context.lut = i22.lut;
          for (const a3 in this.binders) {
            const c3 = this.binders[a3];
            if (c3.context = this.context, (c3 instanceof _l || c3 instanceof wl || c3 instanceof Al) && c3.expression && c3.expression.kind && "constant" !== c3.expression.kind && (true === c3.expression.isStateDependent || false === c3.expression.isLightConstant)) {
              const f22 = i22.paint.get(a3);
              c3.expression = f22.value;
              for (const r3 of p22) {
                const i3 = t22[r3.toString()];
                e22.eachPosition(r3, (t3, e3, r4) => {
                  const a4 = n22.feature(t3);
                  c3.updatePaintArray(e3, r4, a4, i3, s2, o2, l22);
                });
              }
              if (!h22) for (const e3 of r22.uniqueIds) {
                const i3 = t22[e3.toString()];
                r22.eachPosition(e3, (t3, e4, r3) => {
                  const a4 = n22.feature(t3);
                  c3.updatePaintArray(e4, r3, a4, i3, s2, o2, l22);
                });
              }
              u22 = true;
            }
          }
          return u22;
        }
        defines() {
          const t22 = [];
          for (const e22 in this.binders) {
            const r22 = this.binders[e22];
            (r22 instanceof vl || r22 instanceof bl) && t22.push(...r22.uniformNames.map((t3) => `#define HAS_UNIFORM_${t3}`));
          }
          return t22;
        }
        getBinderAttributes() {
          const t22 = [];
          for (const e22 in this.binders) {
            const r22 = this.binders[e22];
            if (r22 instanceof _l || r22 instanceof wl || r22 instanceof Al) for (let e3 = 0; e3 < r22.paintVertexAttributes.length; e3++) t22.push(r22.paintVertexAttributes[e3].name);
            if (r22 instanceof Al) for (let e3 = 0; e3 < tl.members.length; e3++) t22.push(tl.members[e3].name);
          }
          return t22;
        }
        getBinderUniforms() {
          const t22 = [];
          for (const e22 in this.binders) {
            const r22 = this.binders[e22];
            if (r22 instanceof vl || r22 instanceof bl || r22 instanceof wl) for (const e3 of r22.uniformNames) t22.push(e3);
          }
          return t22;
        }
        getPaintVertexBuffers() {
          return this._buffers;
        }
        getUniforms(t22) {
          const e22 = [];
          for (const r22 in this.binders) {
            const n22 = this.binders[r22];
            if (n22 instanceof vl || n22 instanceof bl || n22 instanceof wl) for (const i22 of n22.uniformNames) e22.push({ name: i22, property: r22, binding: n22.getBinding(t22, i22) });
          }
          return e22;
        }
        setUniforms(t22, e22, r22, n22, i22) {
          for (const { name: e3, property: s2, binding: o2 } of r22) this.binders[s2].setUniform(t22, o2, i22, n22.get(s2), e3);
        }
        updatePaintBuffers() {
          this._buffers = [];
          for (const t22 in this.binders) {
            const e22 = this.binders[t22];
            (e22 instanceof _l || e22 instanceof wl || e22 instanceof Al) && e22.paintVertexBuffer && this._buffers.push(e22.paintVertexBuffer), e22 instanceof Al && e22.paintTransitionVertexBuffer && this._buffers.push(e22.paintTransitionVertexBuffer);
          }
        }
        upload(t22) {
          for (const e22 in this.binders) {
            const r22 = this.binders[e22];
            (r22 instanceof _l || r22 instanceof wl || r22 instanceof Al) && r22.upload(t22);
          }
          this.updatePaintBuffers();
        }
        destroy() {
          for (const t22 in this.binders) {
            const e22 = this.binders[t22];
            (e22 instanceof _l || e22 instanceof wl || e22 instanceof Al) && e22.destroy();
          }
        }
      }
      class Il {
        constructor(t22, e22, r22 = () => true) {
          this.programConfigurations = {};
          for (const n22 of t22) this.programConfigurations[n22.id] = new Ml(n22, e22, r22);
          this.needsUpload = false, this._featureMap = new rl(), this._featureMapWithoutIds = new rl(), this._bufferOffset = 0, this._idlessCounter = 0;
        }
        populatePaintArrays(t22, e22, r22, n22, i22, s2, o2, a22) {
          for (const r3 in this.programConfigurations) this.programConfigurations[r3].populatePaintArrays(t22, e22, n22, i22, s2, o2, a22);
          void 0 !== e22.id ? this._featureMap.add(e22.id, r22, this._bufferOffset, t22) : (this._featureMapWithoutIds.add(this._idlessCounter, r22, this._bufferOffset, t22), this._idlessCounter += 1), this._bufferOffset = t22, this.needsUpload = true;
        }
        updatePaintArrays(t22, e22, r22, n22, i22, s2, o2) {
          for (const a22 of r22) this.needsUpload = this.programConfigurations[a22.id].updatePaintArrays(t22, this._featureMap, this._featureMapWithoutIds, e22, a22, n22, i22, s2, o2 || 0) || this.needsUpload;
        }
        get(t22) {
          return this.programConfigurations[t22];
        }
        upload(t22) {
          if (this.needsUpload) {
            for (const e22 in this.programConfigurations) this.programConfigurations[e22].upload(t22);
            this.needsUpload = false;
          }
        }
        destroy() {
          for (const t22 in this.programConfigurations) this.programConfigurations[t22].destroy();
        }
      }
      const Sl = { "text-opacity": ["opacity"], "icon-opacity": ["opacity"], "text-occlusion-opacity": ["occlusion_opacity"], "icon-occlusion-opacity": ["occlusion_opacity"], "text-color": ["fill_color"], "icon-color": ["fill_color"], "text-emissive-strength": ["emissive_strength"], "icon-emissive-strength": ["emissive_strength"], "text-halo-color": ["halo_color"], "icon-halo-color": ["halo_color"], "text-halo-blur": ["halo_blur"], "icon-halo-blur": ["halo_blur"], "text-halo-width": ["halo_width"], "icon-halo-width": ["halo_width"], "symbol-z-offset": ["z_offset"], "line-gap-width": ["gapwidth"], "line-pattern": ["pattern", "pixel_ratio", "pattern_b"], "fill-pattern": ["pattern", "pixel_ratio", "pattern_b"], "fill-extrusion-pattern": ["pattern", "pixel_ratio", "pattern_b"], "line-dasharray": ["dash"] };
      function zl(t22, e22) {
        return Sl[t22] || [t22.replace(`${e22}-`, "").replace(/-/g, "_")];
      }
      const kl = { "line-pattern": { source: ca, composite: ca }, "fill-pattern": { source: ca, composite: ca }, "fill-extrusion-pattern": { source: ca, composite: ca }, "line-dasharray": { source: ha, composite: ha } }, El = { color: { source: Ea, composite: ma }, number: { source: ia, composite: Ea } };
      function Pl(t22, e22, r22) {
        const n22 = kl[t22];
        return n22 && n22[r22] || El[e22][r22];
      }
      js(vl, "ConstantBinder"), js(bl, "PatternConstantBinder"), js(_l, "SourceExpressionBinder"), js(Al, "PatternCompositeBinder"), js(wl, "CompositeExpressionBinder"), js(Ml, "ProgramConfiguration", { omit: ["_buffers"] }), js(Il, "ProgramConfigurationSet");
      const Tl = Tn / Math.PI / 2, Bl = 5, Vl = 6, Cl = 16383, Dl = 64, Fl = [Dl, 32, 16], Ll = -Tl, Rl = Tl;
      function Ol(t22, e22, r22, n22 = Tl) {
        return r22 = Mt(r22), [t22 * Math.sin(r22) * n22, -e22 * n22, t22 * Math.cos(r22) * n22];
      }
      function Ul(t22, e22, r22) {
        return Ol(Math.cos(Mt(t22)), Math.sin(Mt(t22)), e22, r22);
      }
      const Nl = 63710088e-1, jl = 2 * Math.PI * Nl;
      class $l {
        constructor(t22, e22) {
          if (isNaN(t22) || isNaN(e22)) throw new Error(`Invalid LngLat object: (${t22}, ${e22})`);
          if (this.lng = +t22, this.lat = +e22, this.lat > 90 || this.lat < -90) throw new Error("Invalid LngLat latitude value: must be between -90 and 90");
        }
        wrap() {
          return new $l(Bt(this.lng, -180, 180), this.lat);
        }
        toArray() {
          return [this.lng, this.lat];
        }
        toString() {
          return `LngLat(${this.lng}, ${this.lat})`;
        }
        distanceTo(t22) {
          const e22 = Math.PI / 180, r22 = this.lat * e22, n22 = t22.lat * e22, i22 = Math.sin(r22) * Math.sin(n22) + Math.cos(r22) * Math.cos(n22) * Math.cos((t22.lng - this.lng) * e22);
          return Nl * Math.acos(Math.min(i22, 1));
        }
        toBounds(t22 = 0) {
          const e22 = 360 * t22 / 40075017, r22 = e22 / Math.cos(Math.PI / 180 * this.lat);
          return new Gl({ lng: this.lng - r22, lat: this.lat - e22 }, { lng: this.lng + r22, lat: this.lat + e22 });
        }
        toEcef(t22) {
          return Ul(this.lat, this.lng, Tl + t22 * Tl / Nl);
        }
        static convert(t22) {
          if (t22 instanceof $l) return t22;
          if (Array.isArray(t22) && (2 === t22.length || 3 === t22.length)) return new $l(Number(t22[0]), Number(t22[1]));
          if (!Array.isArray(t22) && "object" == typeof t22 && null !== t22) return new $l(Number("lng" in t22 ? t22.lng : t22.lon), Number(t22.lat));
          throw new Error("`LngLatLike` argument must be specified as a LngLat instance, an object {lng: <lng>, lat: <lat>}, an object {lon: <lng>, lat: <lat>}, or an array of [<lng>, <lat>]");
        }
      }
      class Gl {
        constructor(t22, e22) {
          if (t22) if (e22) this.setSouthWest(t22).setNorthEast(e22);
          else if (4 === t22.length) {
            const e3 = t22;
            this.setSouthWest([e3[0], e3[1]]).setNorthEast([e3[2], e3[3]]);
          } else {
            const e3 = t22;
            this.setSouthWest(e3[0]).setNorthEast(e3[1]);
          }
        }
        setNorthEast(t22) {
          return this._ne = t22 instanceof $l ? new $l(t22.lng, t22.lat) : $l.convert(t22), this;
        }
        setSouthWest(t22) {
          return this._sw = t22 instanceof $l ? new $l(t22.lng, t22.lat) : $l.convert(t22), this;
        }
        extend(t22) {
          const e22 = this._sw, r22 = this._ne;
          let n22, i22;
          if (t22 instanceof $l) n22 = t22, i22 = t22;
          else {
            if (!(t22 instanceof Gl)) return Array.isArray(t22) ? 4 === t22.length || t22.every(Array.isArray) ? this.extend(Gl.convert(t22)) : this.extend($l.convert(t22)) : "object" == typeof t22 && null !== t22 && t22.hasOwnProperty("lat") && (t22.hasOwnProperty("lon") || t22.hasOwnProperty("lng")) ? this.extend($l.convert(t22)) : this;
            if (n22 = t22._sw, i22 = t22._ne, !n22 || !i22) return this;
          }
          return e22 || r22 ? (e22.lng = Math.min(n22.lng, e22.lng), e22.lat = Math.min(n22.lat, e22.lat), r22.lng = Math.max(i22.lng, r22.lng), r22.lat = Math.max(i22.lat, r22.lat)) : (this._sw = new $l(n22.lng, n22.lat), this._ne = new $l(i22.lng, i22.lat)), this;
        }
        getCenter() {
          return new $l((this._sw.lng + this._ne.lng) / 2, (this._sw.lat + this._ne.lat) / 2);
        }
        getSouthWest() {
          return this._sw;
        }
        getNorthEast() {
          return this._ne;
        }
        getNorthWest() {
          return new $l(this.getWest(), this.getNorth());
        }
        getSouthEast() {
          return new $l(this.getEast(), this.getSouth());
        }
        getWest() {
          return this._sw.lng;
        }
        getSouth() {
          return this._sw.lat;
        }
        getEast() {
          return this._ne.lng;
        }
        getNorth() {
          return this._ne.lat;
        }
        toArray() {
          return [this._sw.toArray(), this._ne.toArray()];
        }
        toString() {
          return `LngLatBounds(${this._sw.toString()}, ${this._ne.toString()})`;
        }
        isEmpty() {
          return !(this._sw && this._ne);
        }
        contains(t22) {
          const { lng: e22, lat: r22 } = $l.convert(t22);
          let n22 = this._sw.lng <= e22 && e22 <= this._ne.lng;
          return this._sw.lng > this._ne.lng && (n22 = this._sw.lng >= e22 && e22 >= this._ne.lng), this._sw.lat <= r22 && r22 <= this._ne.lat && n22;
        }
        static convert(t22) {
          if (t22) return t22 instanceof Gl ? t22 : new Gl(t22);
        }
      }
      const ql = 0, Hl = 25.5;
      function Xl(t22) {
        return jl * Math.cos(t22 * Math.PI / 180);
      }
      function Zl(t22) {
        return (180 + t22) / 360;
      }
      function Wl(t22) {
        return (180 - 180 / Math.PI * Math.log(Math.tan(Math.PI / 4 + t22 * Math.PI / 360))) / 360;
      }
      function Yl(t22, e22) {
        return t22 / Xl(e22);
      }
      function Kl(t22) {
        return 360 * t22 - 180;
      }
      function Jl(t22) {
        return 360 / Math.PI * Math.atan(Math.exp((180 - 360 * t22) * Math.PI / 180)) - 90;
      }
      function Ql(t22, e22) {
        return t22 * Xl(Jl(e22));
      }
      const tu = 85.051129;
      function eu(t22) {
        return Math.cos(Mt(Pt(t22, -tu, tu)));
      }
      function ru2(t22, e22) {
        const r22 = Pt(e22, ql, Hl), n22 = Math.pow(2, r22);
        return eu(t22) * jl / (512 * n22);
      }
      function nu(t22) {
        return 1 / Math.cos(t22 * Math.PI / 180);
      }
      function iu(t22, e22 = 0) {
        const r22 = Math.exp(Math.PI * (1 - (t22.y + e22 / Tn) / (1 << t22.z) * 2));
        return 80150034 * r22 / (r22 * r22 + 1) / Tn / (1 << t22.z);
      }
      class su {
        constructor(t22, e22, r22 = 0) {
          this.x = +t22, this.y = +e22, this.z = +r22;
        }
        static fromLngLat(t22, e22 = 0) {
          const r22 = $l.convert(t22);
          return new su(Zl(r22.lng), Wl(r22.lat), Yl(e22, r22.lat));
        }
        toLngLat() {
          return new $l(Kl(this.x), Jl(this.y));
        }
        toAltitude() {
          return Ql(this.z, this.y);
        }
        meterInMercatorCoordinateUnits() {
          return 1 / jl * nu(Jl(this.y));
        }
      }
      function ou(t22, e22, r22, n22, i22, s2, o2, a22, l22) {
        const u22 = (e22 + n22) / 2, c22 = (r22 + i22) / 2, h22 = new bt(u22, c22);
        a22(h22), function(t3, e3, r3, n3, i3, s3) {
          const o3 = r3 - i3, a3 = n3 - s3;
          return Math.abs((n3 - e3) * o3 - (r3 - t3) * a3) / Math.hypot(o3, a3);
        }(h22.x, h22.y, s2.x, s2.y, o2.x, o2.y) >= l22 ? (ou(t22, e22, r22, u22, c22, s2, h22, a22, l22), ou(t22, u22, c22, n22, i22, h22, o2, a22, l22)) : t22.push(o2);
      }
      function au(t22, e22, r22) {
        let n22 = t22[0], i22 = n22.x, s2 = n22.y;
        e22(n22);
        const o2 = [n22];
        for (let a22 = 1; a22 < t22.length; a22++) {
          const l22 = t22[a22], { x: u22, y: c22 } = l22;
          e22(l22), ou(o2, i22, s2, u22, c22, n22, l22, e22, r22), i22 = u22, s2 = c22, n22 = l22;
        }
        return o2;
      }
      function lu(t22, e22, r22, n22) {
        if (n22(e22, r22)) {
          const i22 = e22.add(r22)._mult(0.5);
          lu(t22, e22, i22, n22), lu(t22, i22, r22, n22);
        } else t22.push(r22);
      }
      function uu(t22, e22) {
        let r22 = t22[0];
        const n22 = [r22];
        for (let i22 = 1; i22 < t22.length; i22++) {
          const s2 = t22[i22];
          lu(n22, r22, s2, e22), r22 = s2;
        }
        return n22;
      }
      const cu = Math.pow(2, 14) - 1, hu = -cu - 1;
      function pu(t22, e22) {
        const r22 = Math.round(t22.x * e22), n22 = Math.round(t22.y * e22);
        return t22.x = Pt(r22, hu, cu), t22.y = Pt(n22, hu, cu), (r22 < t22.x || r22 > t22.x + 1 || n22 < t22.y || n22 > t22.y + 1) && $t2("Geometry exceeds allowed extent, reduce your vector tile buffer size"), t22;
      }
      function fu(t22, e22, r22) {
        const n22 = t22.loadGeometry(), i22 = t22.extent, s2 = Tn / i22;
        if (e22 && r22 && r22.projection.isReprojectedInTileSpace) {
          const s3 = 1 << e22.z, { scale: o2, x: a22, y: l22, projection: u22 } = r22, c22 = (t3) => {
            const r3 = Kl((e22.x + t3.x / i22) / s3), n3 = Jl((e22.y + t3.y / i22) / s3), c3 = u22.project(r3, n3);
            t3.x = (c3.x * o2 - a22) * i22, t3.y = (c3.y * o2 - l22) * i22;
          };
          for (let e3 = 0; e3 < n22.length; e3++) if (1 !== t22.type) n22[e3] = au(n22[e3], c22, 1);
          else {
            const t3 = [];
            for (const r3 of n22[e3]) r3.x < 0 || r3.x >= i22 || r3.y < 0 || r3.y >= i22 || (c22(r3), t3.push(r3));
            n22[e3] = t3;
          }
        }
        for (const t3 of n22) for (const e3 of t3) pu(e3, s2);
        return n22;
      }
      function du(t22, e22) {
        return { type: t22.type, id: t22.id, properties: t22.properties, geometry: e22 ? fu(t22) : [] };
      }
      function mu(t22, e22, r22, n22, i22) {
        t22.emplaceBack(2 * e22 + (n22 + 1) / 2, 2 * r22 + (i22 + 1) / 2);
      }
      function yu(t22, e22, r22) {
        const n22 = 16384;
        t22.emplaceBack(e22.x, e22.y, e22.z, r22[0] * n22, r22[1] * n22, r22[2] * n22);
      }
      class gu {
        constructor(t22) {
          this.zoom = t22.zoom, this.overscaling = t22.overscaling, this.layers = t22.layers, this.layerIds = this.layers.map((t3) => t3.fqid), this.index = t22.index, this.hasPattern = false, this.projection = t22.projection, this.layoutVertexArray = new ea(), this.indexArray = new wa(), this.segments = new Ka(), this.programConfigurations = new Il(t22.layers, { zoom: t22.zoom, lut: t22.lut }), this.stateDependentLayerIds = this.layers.filter((t3) => t3.isStateDependent()).map((t3) => t3.id);
        }
        updateFootprints(t22, e22) {
        }
        populate(t22, e22, r22, n22) {
          const i22 = this.layers[0], s2 = [];
          let o2 = null;
          "circle" === i22.type && (o2 = i22.layout.get("circle-sort-key"));
          for (const { feature: e3, id: i3, index: a3, sourceLayerIndex: l22 } of t22) {
            const t3 = this.layers[0]._featureFilter.needGeometry, u22 = du(e3, t3);
            if (!this.layers[0]._featureFilter.filter(new yo(this.zoom), u22, r22)) continue;
            const c22 = o2 ? o2.evaluate(u22, {}, r22) : void 0, h22 = { id: i3, properties: e3.properties, type: e3.type, sourceLayerIndex: l22, index: a3, geometry: t3 ? u22.geometry : fu(e3, r22, n22), patterns: {}, sortKey: c22 };
            s2.push(h22);
          }
          o2 && s2.sort((t3, e3) => t3.sortKey - e3.sortKey);
          let a22 = null;
          "globe" === n22.projection.name && (this.globeExtVertexArray = new pa(), a22 = n22.projection);
          for (const n3 of s2) {
            const { geometry: i3, index: s3, sourceLayerIndex: o3 } = n3, l22 = t22[s3].feature;
            this.addFeature(n3, i3, s3, e22.availableImages, r22, a22, e22.brightness), e22.featureIndex.insert(l22, i3, s3, o3, this.index);
          }
        }
        update(t22, e22, r22, n22, i22, s2, o2) {
          this.programConfigurations.updatePaintArrays(t22, e22, i22, r22, n22, s2, o2);
        }
        isEmpty() {
          return 0 === this.layoutVertexArray.length;
        }
        uploadPending() {
          return !this.uploaded || this.programConfigurations.needsUpload;
        }
        upload(t22) {
          this.uploaded || (this.layoutVertexBuffer = t22.createVertexBuffer(this.layoutVertexArray, Wa.members), this.indexBuffer = t22.createIndexBuffer(this.indexArray), this.globeExtVertexArray && (this.globeExtVertexBuffer = t22.createVertexBuffer(this.globeExtVertexArray, Ya.members))), this.programConfigurations.upload(t22), this.uploaded = true;
        }
        destroy() {
          this.layoutVertexBuffer && (this.layoutVertexBuffer.destroy(), this.indexBuffer.destroy(), this.programConfigurations.destroy(), this.segments.destroy(), this.globeExtVertexBuffer && this.globeExtVertexBuffer.destroy());
        }
        addFeature(t22, e22, r22, n22, i22, s2, o2) {
          for (const r3 of e22) for (const e3 of r3) {
            const r4 = e3.x, n3 = e3.y;
            if (r4 < 0 || r4 >= Tn || n3 < 0 || n3 >= Tn) continue;
            if (s2) {
              const t3 = s2.projectTilePoint(r4, n3, i22), e4 = s2.upVector(i22, r4, n3), o4 = this.globeExtVertexArray;
              yu(o4, t3, e4), yu(o4, t3, e4), yu(o4, t3, e4), yu(o4, t3, e4);
            }
            const o3 = this.segments.prepareSegment(4, this.layoutVertexArray, this.indexArray, t22.sortKey), a22 = o3.vertexLength;
            mu(this.layoutVertexArray, r4, n3, -1, -1), mu(this.layoutVertexArray, r4, n3, 1, -1), mu(this.layoutVertexArray, r4, n3, 1, 1), mu(this.layoutVertexArray, r4, n3, -1, 1), this.indexArray.emplaceBack(a22, a22 + 1, a22 + 2), this.indexArray.emplaceBack(a22, a22 + 2, a22 + 3), o3.vertexLength += 4, o3.primitiveLength += 2;
          }
          this.programConfigurations.populatePaintArrays(this.layoutVertexArray.length, t22, r22, {}, n22, i22, o2);
        }
      }
      function xu(t22, e22) {
        for (let r22 = 0; r22 < t22.length; r22++) if (Eu(e22, t22[r22])) return true;
        for (let r22 = 0; r22 < e22.length; r22++) if (Eu(t22, e22[r22])) return true;
        return !!wu(t22, e22);
      }
      function vu(t22, e22, r22) {
        return !!Eu(t22, e22) || !!Su(e22, t22, r22);
      }
      function bu(t22, e22) {
        if (1 === t22.length) return ku(e22, t22[0]);
        for (let r22 = 0; r22 < e22.length; r22++) {
          const n22 = e22[r22];
          for (let e3 = 0; e3 < n22.length; e3++) if (Eu(t22, n22[e3])) return true;
        }
        for (let r22 = 0; r22 < t22.length; r22++) if (ku(e22, t22[r22])) return true;
        for (let r22 = 0; r22 < e22.length; r22++) if (wu(t22, e22[r22])) return true;
        return false;
      }
      function _u(t22, e22, r22) {
        if (t22.length > 1) {
          if (wu(t22, e22)) return true;
          for (let n22 = 0; n22 < e22.length; n22++) if (Su(e22[n22], t22, r22)) return true;
        }
        for (let n22 = 0; n22 < t22.length; n22++) if (Su(t22[n22], e22, r22)) return true;
        return false;
      }
      function wu(t22, e22) {
        if (0 === t22.length || 0 === e22.length) return false;
        for (let r22 = 0; r22 < t22.length - 1; r22++) {
          const n22 = t22[r22], i22 = t22[r22 + 1];
          for (let t3 = 0; t3 < e22.length - 1; t3++) if (Au(n22, i22, e22[t3], e22[t3 + 1])) return true;
        }
        return false;
      }
      function Au(t22, e22, r22, n22) {
        return Gt(t22, r22, n22) !== Gt(e22, r22, n22) && Gt(t22, e22, r22) !== Gt(t22, e22, n22);
      }
      function Mu(t22, e22, r22) {
        return (t22.x - r22.x) * (e22.y - r22.y) - (t22.y - r22.y) * (e22.x - r22.x);
      }
      function Iu(t22, e22, r22, n22) {
        const i22 = Mu(t22, e22, n22), s2 = Mu(t22, e22, r22);
        if (Math.sign(i22) === Math.sign(s2)) return;
        const o2 = Mu(r22, n22, t22), a22 = o2 + s2 - i22;
        return Math.sign(o2) !== Math.sign(a22) ? [o2 / (o2 - a22), s2 / (s2 - i22)] : void 0;
      }
      function Su(t22, e22, r22) {
        const n22 = r22 * r22;
        if (1 === e22.length) return t22.distSqr(e22[0]) < n22;
        for (let r3 = 1; r3 < e22.length; r3++) if (zu(t22, e22[r3 - 1], e22[r3]) < n22) return true;
        return false;
      }
      function zu(t22, e22, r22) {
        const n22 = e22.distSqr(r22);
        if (0 === n22) return t22.distSqr(e22);
        const i22 = ((t22.x - e22.x) * (r22.x - e22.x) + (t22.y - e22.y) * (r22.y - e22.y)) / n22;
        return t22.distSqr(i22 < 0 ? e22 : i22 > 1 ? r22 : r22.sub(e22)._mult(i22)._add(e22));
      }
      function ku(t22, e22) {
        let r22, n22, i22, s2 = false;
        for (let o2 = 0; o2 < t22.length; o2++) {
          r22 = t22[o2];
          for (let t3 = 0, o3 = r22.length - 1; t3 < r22.length; o3 = t3++) n22 = r22[t3], i22 = r22[o3], n22.y > e22.y != i22.y > e22.y && e22.x < (i22.x - n22.x) * (e22.y - n22.y) / (i22.y - n22.y) + n22.x && (s2 = !s2);
        }
        return s2;
      }
      function Eu(t22, e22) {
        let r22 = false;
        for (let n22 = 0, i22 = t22.length - 1; n22 < t22.length; i22 = n22++) {
          const s2 = t22[n22], o2 = t22[i22];
          s2.y > e22.y != o2.y > e22.y && e22.x < (o2.x - s2.x) * (e22.y - s2.y) / (o2.y - s2.y) + s2.x && (r22 = !r22);
        }
        return r22;
      }
      function Pu(t22, e22, r22, n22, i22) {
        for (const s3 of t22) if (e22 <= s3.x && r22 <= s3.y && n22 >= s3.x && i22 >= s3.y) return true;
        const s2 = [new bt(e22, r22), new bt(e22, i22), new bt(n22, i22), new bt(n22, r22)];
        if (t22.length > 2) {
          for (const e3 of s2) if (Eu(t22, e3)) return true;
        }
        for (let e3 = 0; e3 < t22.length - 1; e3++) if (Tu(t22[e3], t22[e3 + 1], s2)) return true;
        return false;
      }
      function Tu(t22, e22, r22) {
        const n22 = r22[0], i22 = r22[2];
        if (t22.x < n22.x && e22.x < n22.x || t22.x > i22.x && e22.x > i22.x || t22.y < n22.y && e22.y < n22.y || t22.y > i22.y && e22.y > i22.y) return false;
        const s2 = Gt(t22, e22, r22[0]);
        return s2 !== Gt(t22, e22, r22[1]) || s2 !== Gt(t22, e22, r22[2]) || s2 !== Gt(t22, e22, r22[3]);
      }
      function Bu(t22, e22, r22, n22, i22, s2) {
        let o2 = e22.y - t22.y, a22 = t22.x - e22.x;
        if (s2 = s2 || 0) {
          const t3 = o2 * o2 + a22 * a22;
          if (0 === t3) return true;
          const e3 = Math.sqrt(t3);
          o2 /= e3, a22 /= e3;
        }
        return !((r22.x - t22.x) * o2 + (r22.y - t22.y) * a22 - s2 < 0 || (n22.x - t22.x) * o2 + (n22.y - t22.y) * a22 - s2 < 0 || (i22.x - t22.x) * o2 + (i22.y - t22.y) * a22 - s2 < 0);
      }
      function Vu(t22, e22, r22, n22, i22, s2, o2) {
        return !(Bu(t22, e22, n22, i22, s2, o2) || Bu(e22, r22, n22, i22, s2, o2) || Bu(r22, t22, n22, i22, s2, o2) || Bu(n22, i22, t22, e22, r22, o2) || Bu(i22, s2, t22, e22, r22, o2) || Bu(s2, n22, t22, e22, r22, o2));
      }
      function Cu(t22, e22, r22) {
        const n22 = e22.paint.get(t22).value;
        return "constant" === n22.kind ? n22.value : r22.programConfigurations.get(e22.id).getMaxValue(t22);
      }
      function Du(t22) {
        return Math.sqrt(t22[0] * t22[0] + t22[1] * t22[1]);
      }
      function Fu(t22, e22, r22, n22, i22) {
        if (!e22[0] && !e22[1]) return t22;
        const s2 = bt.convert(e22)._mult(i22);
        "viewport" === r22 && s2._rotate(-n22);
        const o2 = [];
        for (let e3 = 0; e3 < t22.length; e3++) o2.push(t22[e3].sub(s2));
        return o2;
      }
      function Lu(t22, e22, r22, n22) {
        const i22 = bt.convert(t22)._mult(n22);
        return "viewport" === e22 && i22._rotate(-r22), i22;
      }
      let Ru, Ou;
      function Uu(t22, e22, r22) {
        var n22 = 2 * Math.PI * 6378137 / 256 / Math.pow(2, r22);
        return [t22 * n22 - 2 * Math.PI * 6378137 / 2, e22 * n22 - 2 * Math.PI * 6378137 / 2];
      }
      js(gu, "CircleBucket", { omit: ["layers"] });
      class Nu {
        constructor(t22, e22, r22) {
          this.z = t22, this.x = e22, this.y = r22, this.key = Gu(0, t22, t22, e22, r22);
        }
        equals(t22) {
          return this.z === t22.z && this.x === t22.x && this.y === t22.y;
        }
        url(t22, e22) {
          const r22 = function(t3, e3, r3) {
            var n3 = Uu(256 * t3, 256 * (e3 = Math.pow(2, r3) - e3 - 1), r3), i22 = Uu(256 * (t3 + 1), 256 * (e3 + 1), r3);
            return n3[0] + "," + n3[1] + "," + i22[0] + "," + i22[1];
          }(this.x, this.y, this.z), n22 = function(t3, e3, r3) {
            let n3, i22 = "";
            for (let s2 = t3; s2 > 0; s2--) n3 = 1 << s2 - 1, i22 += (e3 & n3 ? 1 : 0) + (r3 & n3 ? 2 : 0);
            return i22;
          }(this.z, this.x, this.y);
          return t22[(this.x + this.y) % t22.length].replace("{prefix}", (this.x % 16).toString(16) + (this.y % 16).toString(16)).replace(/{z}/g, String(this.z)).replace(/{x}/g, String(this.x)).replace(/{y}/g, String("tms" === e22 ? Math.pow(2, this.z) - this.y - 1 : this.y)).replace("{quadkey}", n22).replace("{bbox-epsg-3857}", r22);
        }
        toString() {
          return `${this.z}/${this.x}/${this.y}`;
        }
      }
      class ju {
        constructor(t22, e22) {
          this.wrap = t22, this.canonical = e22, this.key = Gu(t22, e22.z, e22.z, e22.x, e22.y);
        }
      }
      class $u {
        constructor(t22, e22, r22, n22, i22) {
          this.overscaledZ = t22, this.wrap = e22, this.canonical = new Nu(r22, +n22, +i22), this.key = 0 === e22 && t22 === r22 ? this.canonical.key : Gu(e22, t22, r22, n22, i22);
        }
        equals(t22) {
          return this.overscaledZ === t22.overscaledZ && this.wrap === t22.wrap && this.canonical.equals(t22.canonical);
        }
        scaledTo(t22) {
          const e22 = this.canonical.z - t22;
          return t22 > this.canonical.z ? new $u(t22, this.wrap, this.canonical.z, this.canonical.x, this.canonical.y) : new $u(t22, this.wrap, t22, this.canonical.x >> e22, this.canonical.y >> e22);
        }
        calculateScaledKey(t22, e22 = true) {
          if (this.overscaledZ === t22 && e22) return this.key;
          if (t22 > this.canonical.z) return Gu(this.wrap * +e22, t22, this.canonical.z, this.canonical.x, this.canonical.y);
          {
            const r22 = this.canonical.z - t22;
            return Gu(this.wrap * +e22, t22, t22, this.canonical.x >> r22, this.canonical.y >> r22);
          }
        }
        isChildOf(t22) {
          if (t22.wrap !== this.wrap) return false;
          const e22 = this.canonical.z - t22.canonical.z;
          return 0 === t22.overscaledZ || t22.overscaledZ < this.overscaledZ && t22.canonical.z < this.canonical.z && t22.canonical.x === this.canonical.x >> e22 && t22.canonical.y === this.canonical.y >> e22;
        }
        children(t22) {
          if (this.overscaledZ >= t22) return [new $u(this.overscaledZ + 1, this.wrap, this.canonical.z, this.canonical.x, this.canonical.y)];
          const e22 = this.canonical.z + 1, r22 = 2 * this.canonical.x, n22 = 2 * this.canonical.y;
          return [new $u(e22, this.wrap, e22, r22, n22), new $u(e22, this.wrap, e22, r22 + 1, n22), new $u(e22, this.wrap, e22, r22, n22 + 1), new $u(e22, this.wrap, e22, r22 + 1, n22 + 1)];
        }
        isLessThan(t22) {
          return this.wrap < t22.wrap || !(this.wrap > t22.wrap) && (this.overscaledZ < t22.overscaledZ || !(this.overscaledZ > t22.overscaledZ) && (this.canonical.x < t22.canonical.x || !(this.canonical.x > t22.canonical.x) && this.canonical.y < t22.canonical.y));
        }
        wrapped() {
          return new $u(this.overscaledZ, 0, this.canonical.z, this.canonical.x, this.canonical.y);
        }
        unwrapTo(t22) {
          return new $u(this.overscaledZ, t22, this.canonical.z, this.canonical.x, this.canonical.y);
        }
        overscaleFactor() {
          return Math.pow(2, this.overscaledZ - this.canonical.z);
        }
        toUnwrapped() {
          return new ju(this.wrap, this.canonical);
        }
        toString() {
          return `${this.overscaledZ}/${this.canonical.x}/${this.canonical.y}`;
        }
      }
      function Gu(t22, e22, r22, n22, i22) {
        const s2 = 1 << Math.min(r22, 22);
        let o2 = s2 * (i22 % s2) + n22 % s2;
        return t22 && r22 < 22 && (o2 += s2 * s2 * ((t22 < 0 ? -2 * t22 - 1 : 2 * t22) % (1 << 2 * (22 - r22)))), 16 * (32 * o2 + r22) + (e22 - r22);
      }
      const qu = [(t22) => {
        let e22 = t22.canonical.x - 1, r22 = t22.wrap;
        return e22 < 0 && (e22 = (1 << t22.canonical.z) - 1, r22--), new $u(t22.overscaledZ, r22, t22.canonical.z, e22, t22.canonical.y);
      }, (t22) => {
        let e22 = t22.canonical.x + 1, r22 = t22.wrap;
        return e22 === 1 << t22.canonical.z && (e22 = 0, r22++), new $u(t22.overscaledZ, r22, t22.canonical.z, e22, t22.canonical.y);
      }, (t22) => new $u(t22.overscaledZ, t22.wrap, t22.canonical.z, t22.canonical.x, (0 === t22.canonical.y ? 1 << t22.canonical.z : t22.canonical.y) - 1), (t22) => new $u(t22.overscaledZ, t22.wrap, t22.canonical.z, t22.canonical.x, t22.canonical.y === (1 << t22.canonical.z) - 1 ? 0 : t22.canonical.y + 1)];
      js(Nu, "CanonicalTileID"), js($u, "OverscaledTileID", { omit: ["projMatrix", "expandedProjMatrix"] });
      const Hu = Qo([{ type: "Float32", name: "a_globe_pos", components: 3 }, { type: "Float32", name: "a_uv", components: 2 }]), { members: Xu } = Hu, Zu = Qo([{ name: "a_pos_3", components: 3, type: "Int16" }]);
      var Wu = Qo([{ name: "a_pos", type: "Int16", components: 2 }]);
      class Yu {
        constructor(t22, e22) {
          this.pos = t22, this.dir = e22;
        }
        intersectsPlane(t22, e22, r22) {
          const n22 = ft2(e22, this.dir);
          if (Math.abs(n22) < 1e-6) return false;
          const i22 = ((t22[0] - this.pos[0]) * e22[0] + (t22[1] - this.pos[1]) * e22[1]) / n22;
          return r22[0] = this.pos[0] + this.dir[0] * i22, r22[1] = this.pos[1] + this.dir[1] * i22, true;
        }
      }
      class Ku {
        constructor(t22, e22) {
          this.pos = t22, this.dir = e22;
        }
        intersectsPlane(t22, e22, r22) {
          const n22 = D2(e22, this.dir);
          if (Math.abs(n22) < 1e-6) return false;
          const i22 = ((t22[0] - this.pos[0]) * e22[0] + (t22[1] - this.pos[1]) * e22[1] + (t22[2] - this.pos[2]) * e22[2]) / n22;
          return r22[0] = this.pos[0] + this.dir[0] * i22, r22[1] = this.pos[1] + this.dir[1] * i22, r22[2] = this.pos[2] + this.dir[2] * i22, true;
        }
        closestPointOnSphere(t22, r22, n22) {
          if (function(t3, r3) {
            var n3 = t3[0], i3 = t3[1], s3 = t3[2], o3 = r3[0], a3 = r3[1], l3 = r3[2];
            return Math.abs(n3 - o3) <= e2 * Math.max(1, Math.abs(n3), Math.abs(o3)) && Math.abs(i3 - a3) <= e2 * Math.max(1, Math.abs(i3), Math.abs(a3)) && Math.abs(s3 - l3) <= e2 * Math.max(1, Math.abs(s3), Math.abs(l3));
          }(this.pos, t22) || 0 === r22) return n22[0] = n22[1] = n22[2] = 0, false;
          const [i22, s2, o2] = this.dir, a22 = this.pos[0] - t22[0], l22 = this.pos[1] - t22[1], u22 = this.pos[2] - t22[2], c22 = i22 * i22 + s2 * s2 + o2 * o2, h22 = 2 * (a22 * i22 + l22 * s2 + u22 * o2), p22 = h22 * h22 - 4 * c22 * (a22 * a22 + l22 * l22 + u22 * u22 - r22 * r22);
          if (p22 < 0) {
            const t3 = Math.max(-h22 / 2, 0), e22 = a22 + i22 * t3, c3 = l22 + s2 * t3, p3 = u22 + o2 * t3, f22 = Math.hypot(e22, c3, p3);
            return n22[0] = e22 * r22 / f22, n22[1] = c3 * r22 / f22, n22[2] = p3 * r22 / f22, false;
          }
          {
            const t3 = (-h22 - Math.sqrt(p22)) / (2 * c22);
            if (t3 < 0) {
              const t4 = Math.hypot(a22, l22, u22);
              return n22[0] = a22 * r22 / t4, n22[1] = l22 * r22 / t4, n22[2] = u22 * r22 / t4, false;
            }
            return n22[0] = a22 + i22 * t3, n22[1] = l22 + s2 * t3, n22[2] = u22 + o2 * t3, true;
          }
        }
      }
      class Ju {
        constructor(t22, e22, r22, n22, i22) {
          this.TL = t22, this.TR = e22, this.BR = r22, this.BL = n22, this.horizon = i22;
        }
        static fromInvProjectionMatrix(t22, e22, r22) {
          const n22 = [-1, 1, 1], i22 = [1, 1, 1], s2 = [1, -1, 1], o2 = [-1, -1, 1], a22 = R2(n22, n22, t22), l22 = R2(i22, i22, t22), u22 = R2(s2, s2, t22), c22 = R2(o2, o2, t22);
          return new Ju(a22, l22, u22, c22, e22 / r22);
        }
      }
      function Qu(t22, e22, r22) {
        let n22 = 1 / 0, i22 = -1 / 0;
        const s2 = [];
        for (const o2 of t22) {
          j2(s2, o2, e22);
          const t3 = D2(s2, r22);
          n22 = Math.min(n22, t3), i22 = Math.max(i22, t3);
        }
        return [n22, i22];
      }
      function tc(t22, e22) {
        let r22 = true;
        for (let n22 = 0; n22 < t22.planes.length; n22++) {
          const i22 = t22.planes[n22];
          let s2 = 0;
          for (let t3 = 0; t3 < e22.length; t3++) s2 += D2(i22, e22[t3]) + i22[3] >= 0;
          if (0 === s2) return 0;
          s2 !== e22.length && (r22 = false);
        }
        return r22 ? 2 : 1;
      }
      function ec(t22, e22) {
        for (const r22 of t22.projections) {
          const n22 = Qu(e22, t22.points[0], r22.axis);
          if (r22.projection[1] < n22[0] || r22.projection[0] > n22[1]) return 0;
        }
        return 1;
      }
      function rc(t22, e22) {
        let r22 = 0;
        const n22 = [0, 0, 0, 0];
        for (let o2 = 0; o2 < t22.length; o2++) n22[0] = t22[o2][0], n22[1] = t22[o2][1], n22[2] = t22[o2][2], n22[3] = 1, (i22 = n22)[0] * (s2 = e22)[0] + i22[1] * s2[1] + i22[2] * s2[2] + i22[3] * s2[3] >= 0 && r22++;
        var i22, s2;
        return r22;
      }
      class nc {
        constructor(t22, e22) {
          this.points = t22 || new Array(8).fill([0, 0, 0]), this.planes = e22 || new Array(6).fill([0, 0, 0, 0]), this.bounds = ic.fromPoints(this.points), this.projections = [], this.frustumEdges = [j2([], this.points[2], this.points[3]), j2([], this.points[0], this.points[3]), j2([], this.points[4], this.points[0]), j2([], this.points[5], this.points[1]), j2([], this.points[6], this.points[2]), j2([], this.points[7], this.points[3])];
          for (const t3 of this.frustumEdges) {
            const e3 = [0, -t3[2], t3[1]], r22 = [t3[2], 0, -t3[0]];
            this.projections.push({ axis: e3, projection: Qu(this.points, this.points[0], e3) }), this.projections.push({ axis: r22, projection: Qu(this.points, this.points[0], r22) });
          }
        }
        static fromInvProjectionMatrix(t22, e22, r22, n22) {
          const i22 = Math.pow(2, r22), s2 = [[-1, 1, -1, 1], [1, 1, -1, 1], [1, -1, -1, 1], [-1, -1, -1, 1], [-1, 1, 1, 1], [1, 1, 1, 1], [1, -1, 1, 1], [-1, -1, 1, 1]].map((r3) => {
            const s3 = Z([], r3, t22), o3 = 1 / s3[3] / e22 * i22;
            return (a3 = s3)[0] = (l22 = s3)[0] * (u22 = [o3, o3, n22 ? 1 / s3[3] : o3, o3])[0], a3[1] = l22[1] * u22[1], a3[2] = l22[2] * u22[2], a3[3] = l22[3] * u22[3], a3;
            var a3, l22, u22;
          }), o2 = [[0, 1, 2], [6, 5, 4], [0, 3, 7], [2, 1, 5], [3, 2, 6], [0, 4, 5]].map((t3) => {
            const e3 = C([], F([], j2([], s2[t3[0]], s2[t3[1]]), j2([], s2[t3[2]], s2[t3[1]]))), r3 = -D2(e3, s2[t3[1]]);
            return e3.concat(r3);
          }), a22 = [];
          for (let t3 = 0; t3 < s2.length; t3++) a22.push([s2[t3][0], s2[t3][1], s2[t3][2]]);
          return new nc(a22, o2);
        }
        intersectsPrecise(t22, e22, r22) {
          for (let r3 = 0; r3 < e22.length; r3++) if (!rc(t22, e22[r3])) return 0;
          for (let e3 = 0; e3 < this.planes.length; e3++) if (!rc(t22, this.planes[e3])) return 0;
          for (const e3 of r22) for (const r3 of this.frustumEdges) {
            const n22 = F([], e3, r3), i22 = w2(n22);
            if (0 === i22) continue;
            E2(n22, n22, 1 / i22);
            const s2 = Qu(this.points, this.points[0], n22), o2 = Qu(t22, this.points[0], n22);
            if (s2[0] > o2[1] || o2[0] > s2[1]) return 0;
          }
          return 1;
        }
        containsPoint(t22) {
          for (const e22 of this.planes) {
            const r22 = e22[3];
            if (D2([e22[0], e22[1], e22[2]], t22) + r22 < 0) return false;
          }
          return true;
        }
      }
      class ic {
        static fromPoints(t22) {
          const e22 = [1 / 0, 1 / 0, 1 / 0], r22 = [-1 / 0, -1 / 0, -1 / 0];
          for (const n22 of t22) z2(e22, e22, n22), k2(r22, r22, n22);
          return new ic(e22, r22);
        }
        static fromTileIdAndHeight(t22, e22, r22) {
          const n22 = 1 << t22.canonical.z, i22 = t22.canonical.x, s2 = t22.canonical.y;
          return new ic([i22 / n22, s2 / n22, e22], [(i22 + 1) / n22, (s2 + 1) / n22, r22]);
        }
        static applyTransform(t22, e22) {
          const r22 = t22.getCorners();
          for (let t3 = 0; t3 < r22.length; ++t3) R2(r22[t3], r22[t3], e22);
          return ic.fromPoints(r22);
        }
        static applyTransformFast(t22, e22) {
          const r22 = [e22[12], e22[13], e22[14]], n22 = [...r22];
          for (let i22 = 0; i22 < 3; i22++) for (let s2 = 0; s2 < 3; s2++) {
            const o2 = e22[4 * s2 + i22], a22 = o2 * t22.min[s2], l22 = o2 * t22.max[s2];
            r22[i22] += Math.min(a22, l22), n22[i22] += Math.max(a22, l22);
          }
          return new ic(r22, n22);
        }
        static projectAabbCorners(t22, e22) {
          const r22 = t22.getCorners();
          for (let t3 = 0; t3 < r22.length; ++t3) R2(r22[t3], r22[t3], e22);
          return r22;
        }
        constructor(t22, e22) {
          this.min = t22, this.max = e22, this.center = E2([], M2([], this.min, this.max), 0.5);
        }
        quadrant(t22) {
          const e22 = [t22 % 2 == 0, t22 < 2], r22 = _2(this.min), n22 = _2(this.max);
          for (let t3 = 0; t3 < e22.length; t3++) r22[t3] = e22[t3] ? this.min[t3] : this.center[t3], n22[t3] = e22[t3] ? this.center[t3] : this.max[t3];
          return n22[2] = this.max[2], new ic(r22, n22);
        }
        distanceX(t22) {
          return Math.max(Math.min(this.max[0], t22[0]), this.min[0]) - t22[0];
        }
        distanceY(t22) {
          return Math.max(Math.min(this.max[1], t22[1]), this.min[1]) - t22[1];
        }
        distanceZ(t22) {
          return Math.max(Math.min(this.max[2], t22[2]), this.min[2]) - t22[2];
        }
        getCorners() {
          const t22 = this.min, e22 = this.max;
          return [[t22[0], t22[1], t22[2]], [e22[0], t22[1], t22[2]], [e22[0], e22[1], t22[2]], [t22[0], e22[1], t22[2]], [t22[0], t22[1], e22[2]], [e22[0], t22[1], e22[2]], [e22[0], e22[1], e22[2]], [t22[0], e22[1], e22[2]]];
        }
        intersects(t22) {
          return this.intersectsAabb(t22.bounds) ? tc(t22, this.getCorners()) : 0;
        }
        intersectsFlat(t22) {
          return this.intersectsAabb(t22.bounds) ? tc(t22, [[this.min[0], this.min[1], 0], [this.max[0], this.min[1], 0], [this.max[0], this.max[1], 0], [this.min[0], this.max[1], 0]]) : 0;
        }
        intersectsPrecise(t22, e22) {
          return e22 || this.intersects(t22) ? ec(t22, this.getCorners()) : 0;
        }
        intersectsPreciseFlat(t22, e22) {
          return e22 || this.intersectsFlat(t22) ? ec(t22, [[this.min[0], this.min[1], 0], [this.max[0], this.min[1], 0], [this.max[0], this.max[1], 0], [this.min[0], this.max[1], 0]]) : 0;
        }
        intersectsAabb(t22) {
          for (let e22 = 0; e22 < 3; ++e22) if (this.min[e22] > t22.max[e22] || t22.min[e22] > this.max[e22]) return false;
          return true;
        }
        intersectsAabbXY(t22) {
          return !(this.min[0] > t22.max[0] || t22.min[0] > this.max[0] || this.min[1] > t22.max[1] || t22.min[1] > this.max[1]);
        }
        encapsulate(t22) {
          for (let e22 = 0; e22 < 3; e22++) this.min[e22] = Math.min(this.min[e22], t22.min[e22]), this.max[e22] = Math.max(this.max[e22], t22.max[e22]);
        }
        encapsulatePoint(t22) {
          for (let e22 = 0; e22 < 3; e22++) this.min[e22] = Math.min(this.min[e22], t22[e22]), this.max[e22] = Math.max(this.max[e22], t22[e22]);
        }
        closestPoint(t22) {
          return [Math.max(Math.min(this.max[0], t22[0]), this.min[0]), Math.max(Math.min(this.max[1], t22[1]), this.min[1]), Math.max(Math.min(this.max[2], t22[2]), this.min[2])];
        }
      }
      function sc(t22) {
        return t22 * Tl / Nl;
      }
      js(ic, "Aabb");
      const oc = [new ic([Ll, Ll, Ll], [Rl, Rl, Rl]), new ic([Ll, Ll, Ll], [0, 0, Rl]), new ic([0, Ll, Ll], [Rl, 0, Rl]), new ic([Ll, 0, Ll], [0, Rl, Rl]), new ic([0, 0, Ll], [Rl, Rl, Rl])];
      function ac(t22, e22, r22, n22 = true) {
        const i22 = E2([], t22._camera.position, t22.worldSize), s2 = [e22, r22, 1, 1];
        Z(s2, s2, t22.pixelMatrixInverse), H(s2, s2, 1 / s2[3]);
        const o2 = C([], j2([], s2, i22)), a22 = t22.globeMatrix, l22 = [a22[12], a22[13], a22[14]], u22 = j2([], l22, i22), c22 = w2(u22), h22 = C([], u22), p22 = t22.worldSize / (2 * Math.PI), f22 = D2(h22, o2), d22 = Math.asin(p22 / c22);
        if (d22 < Math.acos(f22)) {
          if (!n22) return null;
          const t3 = [], e3 = [];
          E2(t3, o2, c22 / f22), C(e3, j2(e3, t3, u22)), C(o2, M2(o2, u22, E2(o2, e3, Math.tan(d22) * c22)));
        }
        const m22 = [];
        new Ku(i22, o2).closestPointOnSphere(l22, p22, m22);
        const y22 = C([], Yt(a22, 0)), g22 = C([], Yt(a22, 1)), x22 = C([], Yt(a22, 2)), v22 = D2(y22, m22), b22 = D2(g22, m22), _22 = D2(x22, m22), A22 = It2(Math.asin(-b22 / p22));
        let I2 = It2(Math.atan2(v22, _22));
        I2 = t22.center.lng + function(t3, e3) {
          const r3 = (e3 - t3 + 180) % 360 - 180;
          return r3 < -180 ? r3 + 360 : r3;
        }(t22.center.lng, I2);
        const S2 = Zl(I2), z22 = Pt(Wl(A22), 0, 1);
        return new su(S2, z22);
      }
      class lc {
        constructor(t22, e22, r22) {
          this.a = j2([], t22, r22), this.b = j2([], e22, r22), this.center = r22;
          const n22 = C([], this.a), i22 = C([], this.b);
          this.angle = Math.acos(D2(n22, i22));
        }
      }
      function uc(t22, e22) {
        if (0 === t22.angle) return null;
        let r22;
        return r22 = 0 === t22.a[e22] ? 1 / t22.angle * 0.5 * Math.PI : 1 / t22.angle * Math.atan(t22.b[e22] / t22.a[e22] / Math.sin(t22.angle) - 1 / Math.tan(t22.angle)), r22 < 0 || r22 > 1 ? null : function(t3, e3, r3, n22) {
          const i22 = Math.sin(r3);
          return t3 * (Math.sin((1 - n22) * r3) / i22) + e3 * (Math.sin(n22 * r3) / i22);
        }(t22.a[e22], t22.b[e22], t22.angle, Pt(r22, 0, 1)) + t22.center[e22];
      }
      function cc(t22) {
        if (t22.z <= 1) return oc[t22.z + 2 * t22.y + t22.x];
        const e22 = mc(dc(t22));
        return ic.fromPoints(e22);
      }
      function hc(t22, e22, r22) {
        return E2(t22, t22, 1 - r22), P2(t22, t22, e22, r22);
      }
      function pc(t22, e22, r22) {
        for (const n22 of t22) R2(n22, n22, e22), E2(n22, n22, r22);
      }
      function fc(t22, e22, r22, n22) {
        const i22 = e22 / t22.worldSize, s2 = t22.globeMatrix;
        if (r22.z <= 1) {
          const t3 = cc(r22).getCorners();
          return pc(t3, s2, i22), ic.fromPoints(t3);
        }
        const o2 = dc(r22, n22), a22 = mc(o2, Tl + sc(t22._tileCoverLift));
        pc(a22, s2, i22);
        const l22 = Number.MAX_VALUE, u22 = [-l22, -l22, -l22], c22 = [l22, l22, l22];
        if (o2.contains(t22.center)) {
          for (const t3 of a22) z2(c22, c22, t3), k2(u22, u22, t3);
          u22[2] = 0;
          const e3 = t22.point, r3 = [e3.x * i22, e3.y * i22, 0];
          return z2(c22, c22, r3), k2(u22, u22, r3), new ic(c22, u22);
        }
        if (t22._tileCoverLift > 0) {
          for (const t3 of a22) z2(c22, c22, t3), k2(u22, u22, t3);
          return new ic(c22, u22);
        }
        const h22 = [s2[12] * i22, s2[13] * i22, s2[14] * i22], p22 = o2.getCenter(), f22 = Pt(t22.center.lat, -tu, tu), d22 = Pt(p22.lat, -tu, tu), m22 = Zl(t22.center.lng), y22 = Wl(f22);
        let g22 = m22 - Zl(p22.lng);
        const x22 = y22 - Wl(d22);
        g22 > 0.5 ? g22 -= 1 : g22 < -0.5 && (g22 += 1);
        let v22 = 0;
        Math.abs(g22) > Math.abs(x22) ? v22 = g22 >= 0 ? 1 : 3 : (v22 = x22 >= 0 ? 0 : 2, P2(h22, h22, [s2[4] * i22, s2[5] * i22, s2[6] * i22], -Math.sin(Mt(x22 >= 0 ? o2.getSouth() : o2.getNorth())) * Tl));
        const b22 = a22[v22], _22 = a22[(v22 + 1) % 4], w22 = new lc(b22, _22, h22), A22 = [uc(w22, 0) || b22[0], uc(w22, 1) || b22[1], uc(w22, 2) || b22[2]], I2 = Mc(t22.zoom);
        if (I2 > 0) {
          const n3 = function({ x: t3, y: e3, z: r3 }, n4, i4, s3, o3) {
            const a3 = 1 / (1 << r3);
            let l3 = t3 * a3, u3 = l3 + a3, c3 = e3 * a3, h3 = c3 + a3, p3 = 0;
            const f3 = (l3 + u3) / 2 - s3;
            return f3 > 0.5 ? p3 = -1 : f3 < -0.5 && (p3 = 1), l3 = ((l3 + p3) * n4 - (s3 *= n4)) * i4 + s3, u3 = ((u3 + p3) * n4 - s3) * i4 + s3, c3 = (c3 * n4 - (o3 *= n4)) * i4 + o3, h3 = (h3 * n4 - o3) * i4 + o3, [[l3, h3, 0], [u3, h3, 0], [u3, c3, 0], [l3, c3, 0]];
          }(r22, e22, t22._pixelsPerMercatorPixel, m22, y22);
          for (let t3 = 0; t3 < a22.length; t3++) hc(a22[t3], n3[t3], I2);
          const i3 = M2([], n3[v22], n3[(v22 + 1) % 4]);
          E2(i3, i3, 0.5), hc(A22, i3, I2);
        }
        for (const t3 of a22) z2(c22, c22, t3), k2(u22, u22, t3);
        return c22[2] = Math.min(b22[2], _22[2]), z2(c22, c22, A22), k2(u22, u22, A22), new ic(c22, u22);
      }
      function dc({ x: t22, y: e22, z: r22 }, n22 = false) {
        const i22 = 1 / (1 << r22), s2 = new $l(Kl(t22 * i22), e22 === (1 << r22) - 1 && n22 ? -90 : Jl((e22 + 1) * i22)), o2 = new $l(Kl((t22 + 1) * i22), 0 === e22 && n22 ? 90 : Jl(e22 * i22));
        return new Gl(s2, o2);
      }
      function mc(t22, e22 = Tl) {
        const r22 = Mt(t22.getNorth()), n22 = Mt(t22.getSouth()), i22 = Math.cos(r22), s2 = Math.cos(n22), o2 = Math.sin(r22), a22 = Math.sin(n22), l22 = t22.getWest(), u22 = t22.getEast();
        return [Ol(s2, a22, l22, e22), Ol(s2, a22, u22, e22), Ol(i22, o2, u22, e22), Ol(i22, o2, l22, e22)];
      }
      function yc(t22, e22, r22, n22) {
        const i22 = 1 << r22.z, s2 = (t22 / Tn + r22.x) / i22;
        return Ul(Jl((e22 / Tn + r22.y) / i22), Kl(s2), n22);
      }
      function gc({ min: t22, max: e22 }) {
        return Cl / Math.max(e22[0] - t22[0], e22[1] - t22[1], e22[2] - t22[2]);
      }
      const xc = new Float64Array(16);
      function vc(t22) {
        const e22 = gc(t22), r22 = y2(xc, [e22, e22, e22]);
        return h2(r22, r22, V([], t22.min));
      }
      function bc(t22) {
        const e22 = (n22 = t22.min, (r22 = xc)[0] = 1, r22[1] = 0, r22[2] = 0, r22[3] = 0, r22[4] = 0, r22[5] = 1, r22[6] = 0, r22[7] = 0, r22[8] = 0, r22[9] = 0, r22[10] = 1, r22[11] = 0, r22[12] = n22[0], r22[13] = n22[1], r22[14] = n22[2], r22[15] = 1, r22);
        var r22, n22;
        const i22 = 1 / gc(t22);
        return p2(e22, e22, [i22, i22, i22]);
      }
      function _c2(t22) {
        const e22 = Tn / (2 * Math.PI);
        return t22 / (2 * Math.PI) / e22;
      }
      function wc(t22, e22) {
        return Tn / (512 * Math.pow(2, t22)) * gc(cc(e22));
      }
      function Ac(t22, e22, r22, n22, i22) {
        const s2 = _c2(r22), o2 = [t22, e22, -r22 / (2 * Math.PI)], a22 = l2(new Float64Array(16));
        return h2(a22, a22, o2), p2(a22, a22, [s2, s2, s2]), f2(a22, a22, Mt(-i22)), d2(a22, a22, Mt(-n22)), a22;
      }
      function Mc(t22) {
        return Tt(Bl, Vl, t22);
      }
      function Ic(t22, e22) {
        const r22 = Ul(e22.lat, e22.lng), n22 = function(t3) {
          const e3 = Ul(t3._center.lat, t3._center.lng);
          let r3 = F([], A2(0, 1, 0), e3);
          const n3 = g2([], -t3.angle, e3);
          r3 = R2(r3, r3, n3), g2(n3, -t3._pitch, r3);
          const i3 = C([], e3);
          return E2(i3, i3, sc(t3.cameraToCenterDistance / t3.pixelsPerMeter)), R2(i3, i3, n3), M2([], e3, i3);
        }(t22);
        return o2 = (i22 = I([], n22, r22))[0], a22 = i22[1], l22 = i22[2], u22 = (s2 = r22)[0], c22 = s2[1], h22 = s2[2], f22 = (p22 = Math.sqrt(o2 * o2 + a22 * a22 + l22 * l22) * Math.sqrt(u22 * u22 + c22 * c22 + h22 * h22)) && D2(i22, s2) / p22, Math.acos(Math.min(Math.max(f22, -1), 1));
        var i22, s2, o2, a22, l22, u22, c22, h22, p22, f22;
      }
      function Sc(t22, e22) {
        return Ic(t22, e22) > Math.PI / 2 * 1.01;
      }
      const zc = Mt(85), kc = Math.cos(zc), Ec = Math.sin(zc), Pc = a2(), Tc = (t22) => {
        const e22 = [];
        return "map" === t22.paint.get("circle-pitch-alignment") && e22.push("PITCH_WITH_MAP"), "map" === t22.paint.get("circle-pitch-scale") && e22.push("SCALE_WITH_MAP"), e22;
      };
      function Bc(t22, e22, r22, n22, i22, s2, o2, a22, l22) {
        if (s2 && t22.queryGeometry.isAboveHorizon) return false;
        s2 && (l22 *= t22.pixelToTileUnitsFactor);
        const u22 = t22.tileID.canonical, c22 = r22.projection.upVectorScale(u22, r22.center.lat, r22.worldSize).metersToTile;
        for (const h22 of e22) for (const e3 of h22) {
          const h3 = e3.add(a22), p22 = i22 && r22.elevation ? r22.elevation.exaggeration() * i22.getElevationAt(h3.x, h3.y, true) : 0, f22 = r22.projection.projectTilePoint(h3.x, h3.y, u22);
          if (p22 > 0) {
            const t3 = r22.projection.upVector(u22, h3.x, h3.y);
            f22.x += t3[0] * c22 * p22, f22.y += t3[1] * c22 * p22, f22.z += t3[2] * c22 * p22;
          }
          const d22 = s2 ? h3 : Vc(f22.x, f22.y, f22.z, n22), m22 = s2 ? t22.tilespaceRays.map((t3) => Fc(t3, p22)) : t22.queryGeometry.screenGeometry, y22 = Z([], [f22.x, f22.y, f22.z, 1], n22);
          if (!o2 && s2 ? l22 *= y22[3] / r22.cameraToCenterDistance : o2 && !s2 && (l22 *= r22.cameraToCenterDistance / y22[3]), s2) {
            const t3 = Jl((e3.y / Tn + u22.y) / (1 << u22.z));
            l22 /= r22.projection.pixelsPerMeter(t3, 1) / Yl(1, t3);
          }
          if (vu(m22, d22, l22)) return true;
        }
        return false;
      }
      function Vc(t22, e22, r22, n22) {
        const i22 = Z([], [t22, e22, r22, 1], n22);
        return new bt(i22[0] / i22[3], i22[1] / i22[3]);
      }
      const Cc = A2(0, 0, 0), Dc = A2(0, 0, 1);
      function Fc(t22, e22) {
        const r22 = b2();
        return Cc[2] = e22, t22.intersectsPlane(Cc, Dc, r22), new bt(r22[0], r22[1]);
      }
      class Lc extends gu {
      }
      let Rc, Oc, Uc, Nc;
      function jc(t22, { width: e22, height: r22 }, n22, i22) {
        if (i22) {
          if (i22 instanceof Uint8ClampedArray) i22 = new Uint8Array(i22.buffer);
          else if (i22.length !== e22 * r22 * n22) throw new RangeError("mismatched image size");
        } else i22 = new Uint8Array(e22 * r22 * n22);
        return t22.width = e22, t22.height = r22, t22.data = i22, t22;
      }
      function $c(t22, e22, r22) {
        const { width: n22, height: i22 } = e22;
        n22 === t22.width && i22 === t22.height || (Gc(t22, e22, { x: 0, y: 0 }, { x: 0, y: 0 }, { width: Math.min(t22.width, n22), height: Math.min(t22.height, i22) }, r22, null), t22.width = n22, t22.height = i22, t22.data = e22.data);
      }
      function Gc(t22, e22, r22, n22, i22, s2, o2, a22) {
        if (0 === i22.width || 0 === i22.height) return e22;
        if (i22.width > t22.width || i22.height > t22.height || r22.x > t22.width - i22.width || r22.y > t22.height - i22.height) throw new RangeError("out of range source coordinates for image copy");
        if (i22.width > e22.width || i22.height > e22.height || n22.x > e22.width - i22.width || n22.y > e22.height - i22.height) throw new RangeError("out of range destination coordinates for image copy");
        const l22 = t22.data, u22 = e22.data, c22 = 4 === s2 && a22;
        for (let a3 = 0; a3 < i22.height; a3++) {
          const h22 = ((r22.y + a3) * t22.width + r22.x) * s2, p22 = ((n22.y + a3) * e22.width + n22.x) * s2;
          if (c22) for (let t3 = 0; t3 < i22.width; t3++) {
            const e3 = h22 + t3 * s2 + 3, r3 = p22 + t3 * s2;
            u22[r3 + 0] = 255, u22[r3 + 1] = 255, u22[r3 + 2] = 255, u22[r3 + 3] = l22[e3];
          }
          else if (o2) for (let t3 = 0; t3 < i22.width; t3++) {
            const e3 = h22 + t3 * s2, r3 = p22 + t3 * s2, n3 = l22[e3 + 3], i3 = new ir(l22[e3 + 0] / 255 * n3, l22[e3 + 1] / 255 * n3, l22[e3 + 2] / 255 * n3, n3).toRenderColor(o2).toArray();
            u22[r3 + 0] = i3[0], u22[r3 + 1] = i3[1], u22[r3 + 2] = i3[2], u22[r3 + 3] = i3[3];
          }
          else for (let t3 = 0; t3 < i22.width * s2; t3++) u22[p22 + t3] = l22[h22 + t3];
        }
        return e22;
      }
      js(Lc, "HeatmapBucket", { omit: ["layers"] });
      class qc {
        constructor(t22, e22) {
          jc(this, t22, 1, e22);
        }
        resize(t22) {
          $c(this, new qc(t22), 1);
        }
        clone() {
          return new qc({ width: this.width, height: this.height }, new Uint8Array(this.data));
        }
        static copy(t22, e22, r22, n22, i22) {
          Gc(t22, e22, r22, n22, i22, 1, null);
        }
      }
      class Hc {
        constructor(t22, e22) {
          jc(this, t22, 4, e22);
        }
        resize(t22) {
          $c(this, new Hc(t22), 4);
        }
        replace(t22, e22) {
          e22 ? this.data.set(t22) : this.data = t22 instanceof Uint8ClampedArray ? new Uint8Array(t22.buffer) : t22;
        }
        clone() {
          return new Hc({ width: this.width, height: this.height }, new Uint8Array(this.data));
        }
        static copy(t22, e22, r22, n22, i22, s2, o2) {
          Gc(t22, e22, r22, n22, i22, 4, s2, o2);
        }
      }
      class Xc {
        constructor(t22, e22) {
          this.width = t22.width, this.height = t22.height, this.data = e22 instanceof Uint8Array ? new Float32Array(e22.buffer) : e22;
        }
      }
      function Zc(t22) {
        const e22 = {}, r22 = t22.resolution || 256, n22 = t22.clips ? t22.clips.length : 1, i22 = t22.image || new Hc({ width: r22, height: n22 }), s2 = (r3, n3, s3) => {
          e22[t22.evaluationKey] = s3;
          const o2 = t22.expression.evaluate(e22);
          o2 && (i22.data[r3 + n3 + 0] = Math.floor(255 * o2.r / o2.a), i22.data[r3 + n3 + 1] = Math.floor(255 * o2.g / o2.a), i22.data[r3 + n3 + 2] = Math.floor(255 * o2.b / o2.a), i22.data[r3 + n3 + 3] = Math.floor(255 * o2.a));
        };
        if (t22.clips) for (let e3 = 0, i3 = 0; e3 < n22; ++e3, i3 += 4 * r22) for (let n3 = 0, o2 = 0; n3 < r22; n3++, o2 += 4) {
          const a22 = n3 / (r22 - 1), { start: l22, end: u22 } = t22.clips[e3];
          s2(i3, o2, l22 * (1 - a22) + u22 * a22);
        }
        else for (let t3 = 0, e3 = 0; t3 < r22; t3++, e3 += 4) s2(0, e3, t3 / (r22 - 1));
        return i22;
      }
      js(qc, "AlphaImage"), js(Hc, "RGBAImage");
      const Wc = Qo([{ name: "a_pos", components: 2, type: "Int16" }], 4), Yc = Qo([{ name: "a_road_z_offset", components: 1, type: "Float32" }], 4), Kc = Qo([{ name: "a_pos", components: 2, type: "Int16" }, { name: "a_height", components: 1, type: "Float32" }], 4), Jc = Qo([{ name: "a_pos_normal_3", components: 3, type: "Int16" }], 4);
      function Qc(t22, e22, r22 = 2) {
        const n22 = e22 && e22.length, i22 = n22 ? e22[0] * r22 : t22.length;
        let s2 = th(t22, 0, i22, r22, true);
        const o2 = [];
        if (!s2 || s2.next === s2.prev) return o2;
        let a22, l22, u22;
        if (n22 && (s2 = function(t3, e3, r3, n3) {
          const i3 = [];
          for (let r4 = 0, s3 = e3.length; r4 < s3; r4++) {
            const o3 = th(t3, e3[r4] * n3, r4 < s3 - 1 ? e3[r4 + 1] * n3 : t3.length, n3, false);
            o3 === o3.next && (o3.steiner = true), i3.push(hh(o3));
          }
          i3.sort(ah);
          for (let t4 = 0; t4 < i3.length; t4++) r3 = lh(i3[t4], r3);
          return r3;
        }(t22, e22, s2, r22)), t22.length > 80 * r22) {
          a22 = 1 / 0, l22 = 1 / 0;
          let e3 = -1 / 0, n3 = -1 / 0;
          for (let s3 = r22; s3 < i22; s3 += r22) {
            const r3 = t22[s3], i3 = t22[s3 + 1];
            r3 < a22 && (a22 = r3), i3 < l22 && (l22 = i3), r3 > e3 && (e3 = r3), i3 > n3 && (n3 = i3);
          }
          u22 = Math.max(e3 - a22, n3 - l22), u22 = 0 !== u22 ? 32767 / u22 : 0;
        }
        return rh(s2, o2, r22, a22, l22, u22, 0), o2;
      }
      function th(t22, e22, r22, n22, i22) {
        let s2;
        if (i22 === function(t3, e3, r3, n3) {
          let i3 = 0;
          for (let s3 = e3, o2 = r3 - n3; s3 < r3; s3 += n3) i3 += (t3[o2] - t3[s3]) * (t3[s3 + 1] + t3[o2 + 1]), o2 = s3;
          return i3;
        }(t22, e22, r22, n22) > 0) for (let i3 = e22; i3 < r22; i3 += n22) s2 = wh(i3 / n22 | 0, t22[i3], t22[i3 + 1], s2);
        else for (let i3 = r22 - n22; i3 >= e22; i3 -= n22) s2 = wh(i3 / n22 | 0, t22[i3], t22[i3 + 1], s2);
        return s2 && yh(s2, s2.next) && (Ah(s2), s2 = s2.next), s2;
      }
      function eh(t22, e22) {
        if (!t22) return t22;
        e22 || (e22 = t22);
        let r22, n22 = t22;
        do {
          if (r22 = false, n22.steiner || !yh(n22, n22.next) && 0 !== mh(n22.prev, n22, n22.next)) n22 = n22.next;
          else {
            if (Ah(n22), n22 = e22 = n22.prev, n22 === n22.next) break;
            r22 = true;
          }
        } while (r22 || n22 !== e22);
        return e22;
      }
      function rh(t22, e22, r22, n22, i22, s2, o2) {
        if (!t22) return;
        !o2 && s2 && function(t3, e3, r3, n3) {
          let i3 = t3;
          do {
            0 === i3.z && (i3.z = ch(i3.x, i3.y, e3, r3, n3)), i3.prevZ = i3.prev, i3.nextZ = i3.next, i3 = i3.next;
          } while (i3 !== t3);
          i3.prevZ.nextZ = null, i3.prevZ = null, function(t4) {
            let e4, r4 = 1;
            do {
              let n4, i4 = t4;
              t4 = null;
              let s3 = null;
              for (e4 = 0; i4; ) {
                e4++;
                let o3 = i4, a3 = 0;
                for (let t5 = 0; t5 < r4 && (a3++, o3 = o3.nextZ, o3); t5++) ;
                let l22 = r4;
                for (; a3 > 0 || l22 > 0 && o3; ) 0 !== a3 && (0 === l22 || !o3 || i4.z <= o3.z) ? (n4 = i4, i4 = i4.nextZ, a3--) : (n4 = o3, o3 = o3.nextZ, l22--), s3 ? s3.nextZ = n4 : t4 = n4, n4.prevZ = s3, s3 = n4;
                i4 = o3;
              }
              s3.nextZ = null, r4 *= 2;
            } while (e4 > 1);
          }(i3);
        }(t22, n22, i22, s2);
        let a22 = t22;
        for (; t22.prev !== t22.next; ) {
          const l22 = t22.prev, u22 = t22.next;
          if (s2 ? ih(t22, n22, i22, s2) : nh(t22)) e22.push(l22.i, t22.i, u22.i), Ah(t22), t22 = u22.next, a22 = u22.next;
          else if ((t22 = u22) === a22) {
            o2 ? 1 === o2 ? rh(t22 = sh(eh(t22), e22), e22, r22, n22, i22, s2, 2) : 2 === o2 && oh(t22, e22, r22, n22, i22, s2) : rh(eh(t22), e22, r22, n22, i22, s2, 1);
            break;
          }
        }
      }
      function nh(t22) {
        const e22 = t22.prev, r22 = t22, n22 = t22.next;
        if (mh(e22, r22, n22) >= 0) return false;
        const i22 = e22.x, s2 = r22.x, o2 = n22.x, a22 = e22.y, l22 = r22.y, u22 = n22.y, c22 = Math.min(i22, s2, o2), h22 = Math.min(a22, l22, u22), p22 = Math.max(i22, s2, o2), f22 = Math.max(a22, l22, u22);
        let d22 = n22.next;
        for (; d22 !== e22; ) {
          if (d22.x >= c22 && d22.x <= p22 && d22.y >= h22 && d22.y <= f22 && fh(i22, a22, s2, l22, o2, u22, d22.x, d22.y) && mh(d22.prev, d22, d22.next) >= 0) return false;
          d22 = d22.next;
        }
        return true;
      }
      function ih(t22, e22, r22, n22) {
        const i22 = t22.prev, s2 = t22, o2 = t22.next;
        if (mh(i22, s2, o2) >= 0) return false;
        const a22 = i22.x, l22 = s2.x, u22 = o2.x, c22 = i22.y, h22 = s2.y, p22 = o2.y, f22 = Math.min(a22, l22, u22), d22 = Math.min(c22, h22, p22), m22 = Math.max(a22, l22, u22), y22 = Math.max(c22, h22, p22), g22 = ch(f22, d22, e22, r22, n22), x22 = ch(m22, y22, e22, r22, n22);
        let v22 = t22.prevZ, b22 = t22.nextZ;
        for (; v22 && v22.z >= g22 && b22 && b22.z <= x22; ) {
          if (v22.x >= f22 && v22.x <= m22 && v22.y >= d22 && v22.y <= y22 && v22 !== i22 && v22 !== o2 && fh(a22, c22, l22, h22, u22, p22, v22.x, v22.y) && mh(v22.prev, v22, v22.next) >= 0) return false;
          if (v22 = v22.prevZ, b22.x >= f22 && b22.x <= m22 && b22.y >= d22 && b22.y <= y22 && b22 !== i22 && b22 !== o2 && fh(a22, c22, l22, h22, u22, p22, b22.x, b22.y) && mh(b22.prev, b22, b22.next) >= 0) return false;
          b22 = b22.nextZ;
        }
        for (; v22 && v22.z >= g22; ) {
          if (v22.x >= f22 && v22.x <= m22 && v22.y >= d22 && v22.y <= y22 && v22 !== i22 && v22 !== o2 && fh(a22, c22, l22, h22, u22, p22, v22.x, v22.y) && mh(v22.prev, v22, v22.next) >= 0) return false;
          v22 = v22.prevZ;
        }
        for (; b22 && b22.z <= x22; ) {
          if (b22.x >= f22 && b22.x <= m22 && b22.y >= d22 && b22.y <= y22 && b22 !== i22 && b22 !== o2 && fh(a22, c22, l22, h22, u22, p22, b22.x, b22.y) && mh(b22.prev, b22, b22.next) >= 0) return false;
          b22 = b22.nextZ;
        }
        return true;
      }
      function sh(t22, e22) {
        let r22 = t22;
        do {
          const n22 = r22.prev, i22 = r22.next.next;
          !yh(n22, i22) && gh(n22, r22, r22.next, i22) && bh(n22, i22) && bh(i22, n22) && (e22.push(n22.i, r22.i, i22.i), Ah(r22), Ah(r22.next), r22 = t22 = i22), r22 = r22.next;
        } while (r22 !== t22);
        return eh(r22);
      }
      function oh(t22, e22, r22, n22, i22, s2) {
        let o2 = t22;
        do {
          let t3 = o2.next.next;
          for (; t3 !== o2.prev; ) {
            if (o2.i !== t3.i && dh(o2, t3)) {
              let a22 = _h2(o2, t3);
              return o2 = eh(o2, o2.next), a22 = eh(a22, a22.next), rh(o2, e22, r22, n22, i22, s2, 0), void rh(a22, e22, r22, n22, i22, s2, 0);
            }
            t3 = t3.next;
          }
          o2 = o2.next;
        } while (o2 !== t22);
      }
      function ah(t22, e22) {
        let r22 = t22.x - e22.x;
        return 0 === r22 && (r22 = t22.y - e22.y, 0 === r22) && (r22 = (t22.next.y - t22.y) / (t22.next.x - t22.x) - (e22.next.y - e22.y) / (e22.next.x - e22.x)), r22;
      }
      function lh(t22, e22) {
        const r22 = function(t3, e3) {
          let r3 = e3;
          const n3 = t3.x, i22 = t3.y;
          let s2, o2 = -1 / 0;
          if (yh(t3, r3)) return r3;
          do {
            if (yh(t3, r3.next)) return r3.next;
            if (i22 <= r3.y && i22 >= r3.next.y && r3.next.y !== r3.y) {
              const t4 = r3.x + (i22 - r3.y) * (r3.next.x - r3.x) / (r3.next.y - r3.y);
              if (t4 <= n3 && t4 > o2 && (o2 = t4, s2 = r3.x < r3.next.x ? r3 : r3.next, t4 === n3)) return s2;
            }
            r3 = r3.next;
          } while (r3 !== e3);
          if (!s2) return null;
          const a22 = s2, l22 = s2.x, u22 = s2.y;
          let c22 = 1 / 0;
          r3 = s2;
          do {
            if (n3 >= r3.x && r3.x >= l22 && n3 !== r3.x && ph(i22 < u22 ? n3 : o2, i22, l22, u22, i22 < u22 ? o2 : n3, i22, r3.x, r3.y)) {
              const e4 = Math.abs(i22 - r3.y) / (n3 - r3.x);
              bh(r3, t3) && (e4 < c22 || e4 === c22 && (r3.x > s2.x || r3.x === s2.x && uh(s2, r3))) && (s2 = r3, c22 = e4);
            }
            r3 = r3.next;
          } while (r3 !== a22);
          return s2;
        }(t22, e22);
        if (!r22) return e22;
        const n22 = _h2(r22, t22);
        return eh(n22, n22.next), eh(r22, r22.next);
      }
      function uh(t22, e22) {
        return mh(t22.prev, t22, e22.prev) < 0 && mh(e22.next, t22, t22.next) < 0;
      }
      function ch(t22, e22, r22, n22, i22) {
        return (t22 = 1431655765 & ((t22 = 858993459 & ((t22 = 252645135 & ((t22 = 16711935 & ((t22 = (t22 - r22) * i22 | 0) | t22 << 8)) | t22 << 4)) | t22 << 2)) | t22 << 1)) | (e22 = 1431655765 & ((e22 = 858993459 & ((e22 = 252645135 & ((e22 = 16711935 & ((e22 = (e22 - n22) * i22 | 0) | e22 << 8)) | e22 << 4)) | e22 << 2)) | e22 << 1)) << 1;
      }
      function hh(t22) {
        let e22 = t22, r22 = t22;
        do {
          (e22.x < r22.x || e22.x === r22.x && e22.y < r22.y) && (r22 = e22), e22 = e22.next;
        } while (e22 !== t22);
        return r22;
      }
      function ph(t22, e22, r22, n22, i22, s2, o2, a22) {
        return (i22 - o2) * (e22 - a22) >= (t22 - o2) * (s2 - a22) && (t22 - o2) * (n22 - a22) >= (r22 - o2) * (e22 - a22) && (r22 - o2) * (s2 - a22) >= (i22 - o2) * (n22 - a22);
      }
      function fh(t22, e22, r22, n22, i22, s2, o2, a22) {
        return !(t22 === o2 && e22 === a22) && ph(t22, e22, r22, n22, i22, s2, o2, a22);
      }
      function dh(t22, e22) {
        return t22.next.i !== e22.i && t22.prev.i !== e22.i && !function(t3, e3) {
          let r22 = t3;
          do {
            if (r22.i !== t3.i && r22.next.i !== t3.i && r22.i !== e3.i && r22.next.i !== e3.i && gh(r22, r22.next, t3, e3)) return true;
            r22 = r22.next;
          } while (r22 !== t3);
          return false;
        }(t22, e22) && (bh(t22, e22) && bh(e22, t22) && function(t3, e3) {
          let r22 = t3, n22 = false;
          const i22 = (t3.x + e3.x) / 2, s2 = (t3.y + e3.y) / 2;
          do {
            r22.y > s2 != r22.next.y > s2 && r22.next.y !== r22.y && i22 < (r22.next.x - r22.x) * (s2 - r22.y) / (r22.next.y - r22.y) + r22.x && (n22 = !n22), r22 = r22.next;
          } while (r22 !== t3);
          return n22;
        }(t22, e22) && (mh(t22.prev, t22, e22.prev) || mh(t22, e22.prev, e22)) || yh(t22, e22) && mh(t22.prev, t22, t22.next) > 0 && mh(e22.prev, e22, e22.next) > 0);
      }
      function mh(t22, e22, r22) {
        return (e22.y - t22.y) * (r22.x - e22.x) - (e22.x - t22.x) * (r22.y - e22.y);
      }
      function yh(t22, e22) {
        return t22.x === e22.x && t22.y === e22.y;
      }
      function gh(t22, e22, r22, n22) {
        const i22 = vh2(mh(t22, e22, r22)), s2 = vh2(mh(t22, e22, n22)), o2 = vh2(mh(r22, n22, t22)), a22 = vh2(mh(r22, n22, e22));
        return i22 !== s2 && o2 !== a22 || !(0 !== i22 || !xh(t22, r22, e22)) || !(0 !== s2 || !xh(t22, n22, e22)) || !(0 !== o2 || !xh(r22, t22, n22)) || !(0 !== a22 || !xh(r22, e22, n22));
      }
      function xh(t22, e22, r22) {
        return e22.x <= Math.max(t22.x, r22.x) && e22.x >= Math.min(t22.x, r22.x) && e22.y <= Math.max(t22.y, r22.y) && e22.y >= Math.min(t22.y, r22.y);
      }
      function vh2(t22) {
        return t22 > 0 ? 1 : t22 < 0 ? -1 : 0;
      }
      function bh(t22, e22) {
        return mh(t22.prev, t22, t22.next) < 0 ? mh(t22, e22, t22.next) >= 0 && mh(t22, t22.prev, e22) >= 0 : mh(t22, e22, t22.prev) < 0 || mh(t22, t22.next, e22) < 0;
      }
      function _h2(t22, e22) {
        const r22 = Mh(t22.i, t22.x, t22.y), n22 = Mh(e22.i, e22.x, e22.y), i22 = t22.next, s2 = e22.prev;
        return t22.next = e22, e22.prev = t22, r22.next = i22, i22.prev = r22, n22.next = r22, r22.prev = n22, s2.next = n22, n22.prev = s2, n22;
      }
      function wh(t22, e22, r22, n22) {
        const i22 = Mh(t22, e22, r22);
        return n22 ? (i22.next = n22.next, i22.prev = n22, n22.next.prev = i22, n22.next = i22) : (i22.prev = i22, i22.next = i22), i22;
      }
      function Ah(t22) {
        t22.next.prev = t22.prev, t22.prev.next = t22.next, t22.prevZ && (t22.prevZ.nextZ = t22.nextZ), t22.nextZ && (t22.nextZ.prevZ = t22.prevZ);
      }
      function Mh(t22, e22, r22) {
        return { i: t22, x: e22, y: r22, prev: null, next: null, z: 0, prevZ: null, nextZ: null, steiner: false };
      }
      function Ih(t22, e22) {
        const r22 = t22.length;
        if (r22 <= 1) return [t22];
        const n22 = [];
        let i22, s2;
        for (let e3 = 0; e3 < r22; e3++) {
          const r3 = qt2(t22[e3]);
          0 !== r3 && (t22[e3].area = Math.abs(r3), void 0 === s2 && (s2 = r3 < 0), s2 === r3 < 0 ? (i22 && n22.push(i22), i22 = [t22[e3]]) : i22.push(t22[e3]));
        }
        if (i22 && n22.push(i22), e22 > 1) for (let t3 = 0; t3 < n22.length; t3++) n22[t3].length <= e22 || (Jr(n22[t3], e22, 1, n22[t3].length - 1, Sh), n22[t3] = n22[t3].slice(0, e22));
        return n22;
      }
      function Sh(t22, e22) {
        return e22.area - t22.area;
      }
      function zh(t22, e22, r22 = 1) {
        if (!t22) return null;
        const n22 = "string" == typeof t22 ? Vr.from(t22).getPrimary() : t22.getPrimary(), i22 = "string" == typeof t22 ? null : t22.getSecondary();
        for (const t3 of [n22, i22]) {
          if (!t3) continue;
          const n3 = t3.id.toString();
          e22.has(n3) || e22.set(n3, []), t3.scaleSelf(r22), e22.get(n3).push(t3);
        }
        return { primary: n22.toString(), secondary: i22 ? i22.toString() : null };
      }
      function kh(t22, e22, r22, n22) {
        const i22 = n22.patternDependencies;
        let s2 = false;
        for (const n3 of e22) {
          const e3 = n3.paint.get(`${t22}-pattern`);
          e3.isConstant() || (s2 = true), zh(e3.constantOr(null), i22, r22) && (s2 = true);
        }
        return s2;
      }
      function Eh(t22, e22, r22, n22, i22, s2) {
        const o2 = s2.patternDependencies;
        for (const a22 of e22) {
          const e3 = a22.paint.get(`${t22}-pattern`).value;
          if ("constant" !== e3.kind) {
            let t3 = e3.evaluate({ zoom: n22 }, r22, {}, s2.availableImages);
            t3 = t3 && t3.name ? t3.name : t3;
            const l22 = zh(t3, o2, i22);
            if (!l22) continue;
            const { primary: u22, secondary: c22 } = l22;
            u22 && (r22.patterns[a22.id] = [u22, c22].filter(Boolean));
          }
        }
        return r22;
      }
      var Ph, Th, Bh, Vh, Ch, Dh, Fh, Lh = {};
      function Rh() {
        if (Th) return Ph;
        Th = 1;
        var t22 = vt();
        function e22(t3, e3, n3, i22, s2) {
          this.properties = {}, this.extent = n3, this.type = 0, this._pbf = t3, this._geometry = -1, this._keys = i22, this._values = s2, t3.readFields(r22, this, e3);
        }
        function r22(t3, e3, r3) {
          1 == t3 ? e3.id = r3.readVarint() : 2 == t3 ? function(t4, e4) {
            for (var r4 = t4.readVarint() + t4.pos; t4.pos < r4; ) {
              var n3 = e4._keys[t4.readVarint()], i22 = e4._values[t4.readVarint()];
              e4.properties[n3] = i22;
            }
          }(r3, e3) : 3 == t3 ? e3.type = r3.readVarint() : 4 == t3 && (e3._geometry = r3.pos);
        }
        function n22(t3) {
          for (var e3, r3, n3 = 0, i22 = 0, s2 = t3.length, o2 = s2 - 1; i22 < s2; o2 = i22++) n3 += ((r3 = t3[o2]).x - (e3 = t3[i22]).x) * (e3.y + r3.y);
          return n3;
        }
        return Ph = e22, e22.types = ["Unknown", "Point", "LineString", "Polygon"], e22.prototype.loadGeometry = function() {
          var e3 = this._pbf;
          e3.pos = this._geometry;
          for (var r3, n3 = e3.readVarint() + e3.pos, i22 = 1, s2 = 0, o2 = 0, a22 = 0, l22 = []; e3.pos < n3; ) {
            if (s2 <= 0) {
              var u22 = e3.readVarint();
              i22 = 7 & u22, s2 = u22 >> 3;
            }
            if (s2--, 1 === i22 || 2 === i22) o2 += e3.readSVarint(), a22 += e3.readSVarint(), 1 === i22 && (r3 && l22.push(r3), r3 = []), r3.push(new t22(o2, a22));
            else {
              if (7 !== i22) throw new Error("unknown command " + i22);
              r3 && r3.push(r3[0].clone());
            }
          }
          return r3 && l22.push(r3), l22;
        }, e22.prototype.bbox = function() {
          var t3 = this._pbf;
          t3.pos = this._geometry;
          for (var e3 = t3.readVarint() + t3.pos, r3 = 1, n3 = 0, i22 = 0, s2 = 0, o2 = 1 / 0, a22 = -1 / 0, l22 = 1 / 0, u22 = -1 / 0; t3.pos < e3; ) {
            if (n3 <= 0) {
              var c22 = t3.readVarint();
              r3 = 7 & c22, n3 = c22 >> 3;
            }
            if (n3--, 1 === r3 || 2 === r3) (i22 += t3.readSVarint()) < o2 && (o2 = i22), i22 > a22 && (a22 = i22), (s2 += t3.readSVarint()) < l22 && (l22 = s2), s2 > u22 && (u22 = s2);
            else if (7 !== r3) throw new Error("unknown command " + r3);
          }
          return [o2, l22, a22, u22];
        }, e22.prototype.toGeoJSON = function(t3, r3, i22) {
          var s2, o2, a22 = this.extent * Math.pow(2, i22), l22 = this.extent * t3, u22 = this.extent * r3, c22 = this.loadGeometry(), h22 = e22.types[this.type];
          function p22(t4) {
            for (var e3 = 0; e3 < t4.length; e3++) {
              var r4 = t4[e3];
              t4[e3] = [360 * (r4.x + l22) / a22 - 180, 360 / Math.PI * Math.atan(Math.exp((180 - 360 * (r4.y + u22) / a22) * Math.PI / 180)) - 90];
            }
          }
          switch (this.type) {
            case 1:
              var f22 = [];
              for (s2 = 0; s2 < c22.length; s2++) f22[s2] = c22[s2][0];
              p22(c22 = f22);
              break;
            case 2:
              for (s2 = 0; s2 < c22.length; s2++) p22(c22[s2]);
              break;
            case 3:
              for (c22 = function(t4) {
                var e3 = t4.length;
                if (e3 <= 1) return [t4];
                for (var r4, i3, s3 = [], o3 = 0; o3 < e3; o3++) {
                  var a3 = n22(t4[o3]);
                  0 !== a3 && (void 0 === i3 && (i3 = a3 < 0), i3 === a3 < 0 ? (r4 && s3.push(r4), r4 = [t4[o3]]) : r4.push(t4[o3]));
                }
                return r4 && s3.push(r4), s3;
              }(c22), s2 = 0; s2 < c22.length; s2++) for (o2 = 0; o2 < c22[s2].length; o2++) p22(c22[s2][o2]);
          }
          1 === c22.length ? c22 = c22[0] : h22 = "Multi" + h22;
          var d22 = { type: "Feature", geometry: { type: h22, coordinates: c22 }, properties: this.properties };
          return "id" in this && (d22.id = this.id), d22;
        }, Ph;
      }
      function Oh() {
        if (Vh) return Bh;
        Vh = 1;
        var t22 = Rh();
        function e22(t3, e3) {
          this.version = 1, this.name = null, this.extent = 4096, this.length = 0, this._pbf = t3, this._keys = [], this._values = [], this._features = [], t3.readFields(r22, this, e3), this.length = this._features.length;
        }
        function r22(t3, e3, r3) {
          15 === t3 ? e3.version = r3.readVarint() : 1 === t3 ? e3.name = r3.readString() : 5 === t3 ? e3.extent = r3.readVarint() : 2 === t3 ? e3._features.push(r3.pos) : 3 === t3 ? e3._keys.push(r3.readString()) : 4 === t3 && e3._values.push(function(t4) {
            for (var e4 = null, r4 = t4.readVarint() + t4.pos; t4.pos < r4; ) {
              var n22 = t4.readVarint() >> 3;
              e4 = 1 === n22 ? t4.readString() : 2 === n22 ? t4.readFloat() : 3 === n22 ? t4.readDouble() : 4 === n22 ? t4.readVarint64() : 5 === n22 ? t4.readVarint() : 6 === n22 ? t4.readSVarint() : 7 === n22 ? t4.readBoolean() : null;
            }
            return e4;
          }(r3));
        }
        return Bh = e22, e22.prototype.feature = function(e3) {
          if (e3 < 0 || e3 >= this._features.length) throw new Error("feature index out of bounds");
          this._pbf.pos = this._features[e3];
          var r3 = this._pbf.readVarint() + this._pbf.pos;
          return new t22(this._pbf, r3, this.extent, this._keys, this._values);
        }, Bh;
      }
      function Uh() {
        return Fh || (Fh = 1, Lh.VectorTile = function() {
          if (Dh) return Ch;
          Dh = 1;
          var t22 = Oh();
          function e22(e3, r22, n22) {
            if (3 === e3) {
              var i22 = new t22(n22, n22.readVarint() + n22.pos);
              i22.length && (r22[i22.name] = i22);
            }
          }
          return Ch = function(t3, r22) {
            this.layers = t3.readFields(e22, {}, r22);
          }, Ch;
        }(), Lh.VectorTileFeature = Rh(), Lh.VectorTileLayer = Oh()), Lh;
      }
      var Nh = Uh();
      const jh = "3d_elevation_id", $h = "level";
      class Gh {
        constructor() {
          this._valid = false;
        }
        reset(t22) {
          return this.feature = t22, this._valid = true, this._geometry = t22.loadGeometry(), 0 !== this._geometry.length && 0 !== this._geometry[0].length || (this._valid = false), this;
        }
        geometry(t22, e22) {
          return this._valid && t22(e22(this._geometry)), this;
        }
        require(t22, e22, r22) {
          return this.get(t22, true, e22, r22);
        }
        optional(t22, e22, r22) {
          return this.get(t22, false, e22, r22);
        }
        success() {
          return this._valid;
        }
        get(t22, e22, r22, n22) {
          const i22 = this.feature.properties.hasOwnProperty(t22) ? +this.feature.properties[t22] : void 0;
          return this._valid && void 0 !== i22 && !Number.isNaN(i22) ? r22(n22 ? n22(i22) : i22) : e22 && (this._valid = false), this;
        }
      }
      class qh {
        constructor(t22, e22) {
          this.featureFunc = t22, this.vertexFunc = e22;
        }
        parseFeature(t22, e22, r22) {
          return this.featureFunc(t22, e22, r22);
        }
        parseVertex(t22, e22, r22) {
          return this.vertexFunc(t22, e22, r22);
        }
      }
      const Hh = new qh((t22, e22, r22) => t22.reset(e22).require(jh, (t3) => {
        r22.id = t3;
      }).optional("fixed_height_relative", (t3) => {
        r22.constantHeight = t3;
      }, Zh.decodeRelativeHeight).geometry((t3) => {
        r22.bounds = t3;
      }, un).success(), (t22, e22, r22) => t22.reset(e22).require(jh, (t3) => {
        r22.id = t3;
      }).require("elevation_idx", (t3) => {
        r22.idx = t3;
      }).require("extent", (t3) => {
        r22.extent = t3;
      }).require("height_relative", (t3) => {
        r22.height = t3;
      }, Zh.decodeRelativeHeight).geometry((t3) => {
        r22.position = t3;
      }, Zh.getPoint).success()), Xh = new qh((t22, e22, r22) => t22.reset(e22).require(jh, (t3) => {
        r22.id = t3;
      }).optional("fixed_height", (t3) => {
        r22.constantHeight = t3;
      }, Zh.decodeMetricHeight).geometry((t3) => {
        r22.bounds = t3;
      }, un).success(), (t22, e22, r22) => t22.reset(e22).require(jh, (t3) => {
        r22.id = t3;
      }).require("elevation_idx", (t3) => {
        r22.idx = t3;
      }).require("extent", (t3) => {
        r22.extent = t3;
      }).require("height", (t3) => {
        r22.height = t3;
      }, Zh.decodeMetricHeight).geometry((t3) => {
        r22.position = t3;
      }, Zh.getPoint).success());
      class Zh {
        static getPoint(t22) {
          return at(t22[0][0].x, t22[0][0].y);
        }
        static decodeRelativeHeight(t22) {
          return 1e-4 * t22 * 5;
        }
        static decodeMetricHeight(t22) {
          return 1e-4 * t22;
        }
        static parse(t22) {
          const e22 = [], r22 = [], n22 = t22.length, i22 = new Gh();
          for (let o2 = 0; o2 < n22; o2++) {
            const n3 = t22.feature(o2), a22 = n3.properties.hasOwnProperty("version") ? String(n3.properties.version) : void 0, l22 = (s2 = a22) ? "1.0.1" === s2 ? Xh : void 0 : Hh;
            if (void 0 === l22) {
              $t2(`Unknown elevation feature version number ${a22 || "(unknown)"}`);
              continue;
            }
            const u22 = n3.properties.hasOwnProperty("type") ? n3.properties.type : void 0;
            if (u22) {
              if ("Point" === Nh.VectorTileFeature.types[n3.type] && "curve_point" === u22) {
                const t3 = {};
                l22.parseVertex(i22, n3, t3) && e22.push(t3);
              } else if ("Polygon" === Nh.VectorTileFeature.types[n3.type] && "curve_meta" === u22) {
                const t3 = {};
                l22.parseFeature(i22, n3, t3) && r22.push(t3);
              }
            }
          }
          var s2;
          return { vertices: e22, features: r22 };
        }
      }
      class Wh {
        constructor(t22, e22) {
          this.feature = t22, this.metersToTile = e22, this.index = 0;
        }
        get() {
          const t22 = this.feature.vertices[this.index], e22 = this.feature.vertexProps[this.index].dir, r22 = e22[1], n22 = -e22[0], i22 = (t22.extent + 1) * this.metersToTile;
          return [new bt(Math.trunc(t22.position[0] + r22 * i22), Math.trunc(t22.position[1] + n22 * i22)), new bt(Math.trunc(t22.position[0] - r22 * i22), Math.trunc(t22.position[1] - n22 * i22))];
        }
        next() {
          this.index++;
        }
        valid() {
          return this.index < this.feature.vertices.length;
        }
      }
      class Yh {
        constructor(t22, e22, r22, n22, i22, s2) {
          if (this.vertices = new Array(), this.vertexProps = new Array(), this.edges = new Array(), this.edgeProps = new Array(), this.id = t22, this.heightRange = { min: r22, max: r22 }, this.safeArea = e22, this.constantHeight = r22, null == this.constantHeight && (null != this.constantHeight || 0 !== n22.length)) {
            this.vertices = n22, this.edges = i22, this.edges = this.edges.filter((t3) => {
              return t3.a < this.vertices.length && t3.b < this.vertices.length && !((e3 = this.vertices[t3.a].position)[0] === (r3 = this.vertices[t3.b].position)[0] && e3[1] === r3[1]);
              var e3, r3;
            }), this.heightRange = { min: Number.POSITIVE_INFINITY, max: Number.NEGATIVE_INFINITY };
            for (const t3 of this.vertices) this.vertexProps.push({ dir: at(0, 0) }), this.heightRange.min = Math.min(this.heightRange.min, t3.height), this.heightRange.max = Math.max(this.heightRange.max, t3.height);
            for (const t3 of this.edges) {
              const e3 = this.vertices[t3.a].position, r3 = this.vertices[t3.b].position, n3 = ut2(ot(), r3, e3), i3 = ht(n3), s3 = ct2(ot(), n3, 1 / i3);
              this.edgeProps.push({ vec: n3, dir: s3, len: i3 });
              const o2 = this.vertexProps[t3.a].dir, a22 = this.vertexProps[t3.b].dir;
              lt(o2, o2, s3), lt(a22, a22, s3);
            }
            for (const t3 of this.vertexProps) 0 === t3.dir[0] && 0 === t3.dir[1] || pt(t3.dir, t3.dir);
            this.tessellate(s2);
          }
        }
        pointElevation(t22) {
          if (null != this.constantHeight) return this.constantHeight;
          const e22 = this.getClosestEdge(t22);
          if (null == e22) return 0;
          const [r22, n22] = e22;
          return ((t3, e3, r3) => (1 - r3) * t3 + r3 * e3)(this.vertices[this.edges[r22].a].height, this.vertices[this.edges[r22].b].height, n22);
        }
        getSafeArea() {
          return this.safeArea;
        }
        isTunnel() {
          return this.heightRange.max <= -5;
        }
        getClosestEdge(t22) {
          if (0 === this.edges.length) return;
          let e22 = 0, r22 = Number.POSITIVE_INFINITY, n22 = 0;
          const i22 = at(t22.x, t22.y);
          for (let t3 = 0; t3 < this.edges.length; t3++) {
            const s2 = this.edges[t3], o2 = this.edgeProps[t3].dir, a22 = new Yu(i22, this.edgeProps[t3].dir), l22 = this.vertices[s2.a].position, u22 = this.vertices[s2.b].position, c22 = ot(), h22 = ot(), p22 = a22.intersectsPlane(l22, this.vertexProps[s2.a].dir, c22), f22 = a22.intersectsPlane(u22, this.vertexProps[s2.b].dir, h22);
            if (!p22 || !f22) continue;
            const d22 = ut2(ot(), h22, c22), m22 = ut2(ot(), i22, c22), y22 = ft2(d22, d22), g22 = y22 > 0 ? ft2(m22, d22) / y22 : 0, x22 = Pt(g22, 0, 1), v22 = Math.abs((g22 - x22) * this.edgeProps[t3].len), b22 = ut2(ot(), i22, l22), _22 = v22 + Math.abs(ft2(b22, at(o2[1], -o2[0])));
            _22 < r22 && (e22 = t3, r22 = _22, n22 = x22);
          }
          return [e22, n22];
        }
        tessellate(t22) {
          for (let e22 = this.edges.length - 1; e22 >= 0; --e22) {
            const r22 = this.edges[e22].a, n22 = this.edges[e22].b, { position: i22, height: s2, extent: o2 } = this.vertices[r22], { position: a22, height: l22, extent: u22 } = this.vertices[n22], c22 = this.vertexProps[r22].dir, h22 = this.vertexProps[n22].dir, p22 = A2(i22[0] / t22, i22[1] / t22, s2), f22 = A2(a22[0] / t22, a22[1] / t22, l22), d22 = A2(c22[1], -c22[0], 0);
            E2(d22, d22, o2);
            const m22 = A2(h22[1], -h22[0], 0);
            if (E2(m22, m22, u22), this.distSqLines(A2(p22[0] + 0.5 * d22[0], p22[1] + 0.5 * d22[1], p22[2] + 0.5 * d22[2]), A2(f22[0] - 0.5 * m22[0], f22[1] - 0.5 * m22[1], f22[2] - 0.5 * m22[2]), A2(p22[0] - 0.5 * d22[0], p22[1] - 0.5 * d22[1], p22[2] - 0.5 * d22[2]), A2(f22[0] + 0.5 * m22[0], f22[1] + 0.5 * m22[1], f22[2] + 0.5 * m22[2])) <= 0.0025000000000000005) continue;
            const y22 = this.vertices.length, g22 = lt(ot(), i22, a22);
            this.vertices.push({ position: ct2(g22, g22, 0.5), height: 0.5 * (s2 + l22), extent: 0.5 * (o2 + u22) });
            const x22 = lt(ot(), c22, h22);
            this.vertexProps.push({ dir: pt(x22, x22) }), this.edges.splice(e22, 1), this.edgeProps.splice(e22, 1), this.edges.push({ a: r22, b: y22 }), this.edges.push({ a: y22, b: n22 });
            const v22 = ut2(ot(), this.vertices[y22].position, i22), b22 = ht(v22), _22 = { vec: v22, dir: ct2(ot(), v22, 1 / b22), len: b22 };
            this.edgeProps.push(_22), this.edgeProps.push(_22);
          }
        }
        distSqLines(t22, e22, r22, n22) {
          const i22 = I(b2(), e22, t22), s2 = I(b2(), n22, r22), o2 = I(b2(), t22, r22), a22 = D2(i22, i22), l22 = D2(i22, s2), u22 = D2(i22, o2), c22 = D2(s2, s2), h22 = D2(s2, o2), p22 = a22 * c22 - l22 * l22;
          if (0 === p22) {
            const e3 = D2(o2, s2) / D2(s2, s2);
            return T(L2(b2(), r22, n22, e3), t22);
          }
          const f22 = (l22 * h22 - u22 * c22) / p22, d22 = (a22 * h22 - l22 * u22) / p22;
          return T(L2(b2(), t22, e22, f22), L2(b2(), r22, n22, d22));
        }
      }
      class Kh {
        static parseFrom(t22, e22) {
          const r22 = Zh.parse(t22);
          if (!r22) return [];
          let { vertices: n22, features: i22 } = r22;
          const s2 = 1 / iu(e22);
          i22.sort((t3, e3) => t3.id - e3.id), n22.sort((t3, e3) => t3.id - e3.id || t3.idx - e3.idx), n22 = n22.filter((t3, e3, r3) => e3 === r3.findIndex((e4) => e4.id === t3.id && e4.idx === t3.idx));
          const o2 = new Array();
          let a22 = 0;
          const l22 = n22.length;
          for (const t3 of i22) {
            if (t3.constantHeight) {
              o2.push(new Yh(t3.id, t3.bounds, t3.constantHeight));
              continue;
            }
            for (; a22 !== l22 && n22[a22].id < t3.id; ) a22++;
            if (a22 === l22 || n22[a22].id !== t3.id) continue;
            const e3 = new Array(), r3 = new Array(), i3 = a22;
            for (; a22 !== l22 && n22[a22].id === t3.id; ) {
              const t4 = n22[a22];
              if (e3.push({ position: t4.position, height: t4.height, extent: t4.extent }), a22 !== i3 && n22[a22 - 1].idx === t4.idx - 1) {
                const t5 = a22 - i3;
                r3.push({ a: t5 - 1, b: t5 });
              }
              a22++;
            }
            o2.push(new Yh(t3.id, t3.bounds, void 0, e3, r3, s2));
          }
          return o2;
        }
        static getElevationFeature(t22, e22) {
          if (!e22) return;
          const r22 = +t22.properties[jh];
          return Number.isNaN(r22) ? void 0 : e22.find((t3) => t3.id === r22);
        }
      }
      class Jh {
        constructor(t22, e22) {
          this.zScale = 1, this.xOffset = 0, this.yOffset = 0, t22.equals(e22) || (this.zScale = Math.pow(2, e22.z - t22.z), this.xOffset = (t22.x * this.zScale - e22.x) * Tn, this.yOffset = (t22.y * this.zScale - e22.y) * Tn);
        }
        constantElevation(t22, e22) {
          if (null != t22.constantHeight) return this.computeBiasedHeight(t22.constantHeight, e22);
        }
        pointElevation(t22, e22, r22) {
          const n22 = this.constantElevation(e22, r22);
          return null != n22 ? n22 : (t22.x = t22.x * this.zScale + this.xOffset, t22.y = t22.y * this.zScale + this.yOffset, this.computeBiasedHeight(e22.pointElevation(t22), r22));
        }
        computeBiasedHeight(t22, e22) {
          return e22 <= 0 ? t22 : t22 + e22 * Tt(0, e22, t22 >= 0 ? t22 : Math.abs(0.5 * t22));
        }
      }
      js(Yh, "ElevationFeature");
      class Qh {
        constructor() {
          this.polygons = /* @__PURE__ */ new Map();
        }
        add(t22, ...e22) {
          this.polygons.has(t22) ? this.polygons.get(t22).push(...e22) : this.polygons.set(t22, e22);
        }
        merge(t22) {
          for (const [e22, r22] of t22.polygons) this.add(e22, ...r22);
        }
      }
      class tp {
        constructor() {
          this.portals = [];
        }
        static evaluate(t22) {
          if (0 === t22.length) return new tp();
          let e22 = [];
          for (const r3 of t22) e22.push(...r3.portals);
          if (0 === e22.length) return new tp();
          const r22 = (t3, e3) => t3 <= 0 && e3 <= 0 || t3 >= Tn && e3 >= Tn;
          for (const t3 of e22) {
            const e3 = t3.va, n3 = t3.vb;
            (r22(e3.x, n3.x) || r22(e3.y, n3.y)) && (t3.type = "border");
          }
          const n22 = e22.filter((t3) => "unevaluated" !== t3.type), i22 = e22.filter((t3) => "unevaluated" === t3.type);
          if (0 === i22.length) return new tp();
          i22.sort((t3, e3) => t3.hash === e3.hash ? t3.isTunnel === e3.isTunnel ? 0 : t3.isTunnel ? -1 : 1 : t3.hash < e3.hash ? 1 : -1), e22 = n22.concat(i22);
          let s2 = n22.length, o2 = s2, a22 = s2;
          do {
            if (o2++, o2 === e22.length || e22[s2].hash !== e22[o2].hash) {
              if (o2 - s2 == 2) {
                a22 < s2 && (e22[a22] = e22[s2], e22[s2] = null);
                const t3 = e22[a22], r3 = e22[o2 - 1];
                t3.type = t3.isTunnel !== r3.isTunnel ? "tunnel" : "polygon", t3.connection = { a: t3.connection.a, b: r3.connection.a }, a22++;
              }
              s2 = o2;
            }
          } while (s2 !== e22.length);
          return e22.splice(a22), e22.sort((t3, e3) => t3.hash < e3.hash ? 1 : -1), { portals: e22 };
        }
      }
      js(tp, "ElevationPortalGraph"), js(Qh, "ElevationPolygons");
      class ep {
        constructor(t22, e22, r22) {
          this.outPositions = t22, this.outNormals = e22, this.outIndices = r22, this.vertexLookup = /* @__PURE__ */ new Map(), this.buffer = new ArrayBuffer(4), this.view = new DataView(this.buffer);
        }
        addVertex(t22, e22, r22) {
          let n22 = t22[2];
          null != r22 && (n22 *= r22);
          const i22 = this.getVec3Bits(t22) << 96n | this.getVec3Bits(e22), s2 = this.vertexLookup.get(i22);
          if (null != s2) return s2;
          const o2 = this.outPositions.length;
          this.vertexLookup.set(i22, o2);
          const a22 = Math.trunc(16384 * e22[0]), l22 = Math.trunc(16384 * e22[1]), u22 = Math.trunc(16384 * e22[2]);
          return this.outPositions.emplaceBack(t22[0], t22[1], n22), this.outNormals.emplaceBack(a22, l22, u22), o2;
        }
        addVertices(t22, e22, ...r22) {
          const n22 = [];
          for (const i22 of r22) {
            const r3 = this.addVertex(i22, t22, e22);
            n22.push(r3);
          }
          return n22;
        }
        addTriangles(t22, e22, r22) {
          if (e22 && r22) {
            const n22 = 1 === r22.length, i22 = A2(0, 0, 0);
            for (let s2 = 0; s2 < t22.length; s2 += 3) {
              const o2 = e22[t22[s2 + 0]], a22 = e22[t22[s2 + 1]], l22 = e22[t22[s2 + 2]], u22 = n22 ? r22[0] : r22[t22[s2 + 1]], c22 = n22 ? r22[0] : r22[t22[s2 + 2]], h22 = this.addVertex(A2(o2.x, o2.y, n22 ? r22[0] : r22[t22[s2 + 0]]), i22), p22 = this.addVertex(A2(a22.x, a22.y, u22), i22), f22 = this.addVertex(A2(l22.x, l22.y, c22), i22);
              this.outIndices.emplaceBack(h22, p22, f22);
            }
          } else for (let e3 = 0; e3 < t22.length; e3 += 3) this.outIndices.emplaceBack(t22[e3 + 0], t22[e3 + 1], t22[e3 + 2]);
        }
        addQuad(t22, e22) {
          const r22 = this.addVertices(e22, void 0, ...t22.map((t3) => A2(t3.coord.x, t3.coord.y, t3.height))), [n22, i22, s2, o2] = r22;
          this.addTriangles([n22, i22, s2, s2, o2, n22]);
        }
        getBits(t22) {
          return this.view.setFloat32(0, t22), BigInt(this.view.getUint32(0));
        }
        getVec3Bits(t22) {
          return this.getBits(t22[0]) << 64n | this.getBits(t22[1]) << 32n | this.getBits(t22[2]);
        }
      }
      class rp {
        constructor(t22) {
          this.unevaluatedPortals = new tp(), this.portalPolygons = new Qh(), this.vertexHashLookup = /* @__PURE__ */ new Map(), this.unevalVertices = [], this.unevalHeights = [], this.unevalTriangles = [], this.unevalTunnelTriangles = [], this.unevalEdges = [], this.vertexPositions = new sa(), this.vertexNormals = new oa(), this.indexArray = new wa(), this.tileToMeters = iu(t22);
        }
        addVertices(t22, e22) {
          const r22 = this.unevalVertices.length;
          for (let r3 = 0; r3 < t22.length; r3++) this.unevalVertices.push(t22[r3]), this.unevalHeights.push(e22[r3]);
          return r22;
        }
        addTriangles(t22, e22, r22) {
          const n22 = r22 ? this.unevalTunnelTriangles : this.unevalTriangles;
          for (const r3 of t22) n22.push(r3 + e22);
        }
        addRenderableRing(t22, e22, r22, n22, i22) {
          const s2 = [new bt(i22.min.x, i22.min.y), new bt(i22.max.x, i22.min.y), new bt(i22.max.x, i22.max.y), new bt(i22.min.x, i22.max.y)];
          for (let o2 = 0; o2 < r22 - 1; o2++) {
            const r3 = e22 + o2, a22 = r3 + 1, l22 = this.unevalVertices[r3], u22 = this.unevalVertices[a22];
            if (!(l22.x >= i22.min.x && l22.x <= i22.max.x && l22.y >= i22.min.y && l22.y <= i22.max.y || u22.x >= i22.min.x && u22.x <= i22.max.x && u22.y >= i22.min.y && u22.y <= i22.max.y || Tu(l22, u22, s2))) continue;
            if (this.isOnBorder(l22.x, u22.x) || this.isOnBorder(l22.y, u22.y)) continue;
            const c22 = rp.computeEdgeHash(this.unevalVertices[r3], this.unevalVertices[a22]);
            let h22, p22 = this.vertexHashLookup.get(rp.computePosHash(l22));
            null != p22 ? h22 = p22.next : (p22 = this.vertexHashLookup.get(rp.computePosHash(u22)), h22 = null != p22 ? p22.prev : c22), this.unevalEdges.push({ polygonIdx: t22, a: r3, b: a22, hash: c22, portalHash: h22, isTunnel: n22, type: "unevaluated" });
          }
        }
        addPortalCandidates(t22, e22, r22, n22, i22) {
          if (0 === e22.length) return;
          this.portalPolygons.add(t22, { geometry: e22, zLevel: i22 });
          const s2 = e22[0];
          this.vertexHashLookup.clear();
          let o2 = rp.computeEdgeHash(s2[s2.length - 2], s2[s2.length - 1]);
          for (let e3 = 0; e3 < s2.length - 1; e3++) {
            const i3 = s2[e3 + 0], a22 = s2[e3 + 1], l22 = at(a22.x - i3.x, a22.y - i3.y), u22 = ht(l22);
            if (0 === u22) continue;
            let c22 = "unevaluated";
            const h22 = n22.pointElevation(i3), p22 = n22.pointElevation(a22);
            Math.abs(h22) < 0.01 && Math.abs(p22) < 0.01 ? c22 = "entrance" : (this.isOnBorder(i3.x, a22.x) || this.isOnBorder(i3.y, a22.y)) && (c22 = "border");
            const f22 = rp.computeEdgeHash(i3, a22);
            this.unevaluatedPortals.portals.push({ connection: { a: t22, b: void 0 }, va: i3, vb: a22, vab: l22, length: u22, hash: f22, isTunnel: r22, type: c22 });
            const d22 = rp.computePosHash(i3);
            this.vertexHashLookup.set(d22, { prev: o2, next: f22 }), o2 = f22;
          }
        }
        construct(t22) {
          if (0 === this.unevalVertices.length) return;
          const e22 = () => ({ vertexOffset: 0, primitiveOffset: this.indexArray.length }), r22 = (t3) => {
            t3.primitiveLength = this.indexArray.length - t3.primitiveOffset;
          }, n22 = new ep(this.vertexPositions, this.vertexNormals, this.indexArray);
          this.prepareEdges(t22.portals, this.unevalEdges);
          const i22 = e22(), s2 = e22(), o2 = e22(), a22 = (t3, e3) => {
            t3.sort((t4, r4) => t4.type === e3 && r4.type !== e3 ? -1 : t4.type !== e3 && r4.type === e3 ? 1 : 0);
            const r3 = t3.findIndex((t4) => t4.type !== e3);
            return r3 >= 0 ? r3 : t3.length;
          };
          let l22 = 0;
          this.unevalEdges.length > 0 && (l22 = a22(this.unevalEdges, "none"), this.constructBridgeStructures(n22, this.unevalVertices, this.unevalHeights, this.unevalEdges, { min: 0, max: l22 }, this.tileToMeters));
          const u22 = e22();
          if (this.unevalEdges.length > 0) {
            const t3 = this.unevalEdges.splice(l22), e3 = a22(t3, "tunnel") + l22;
            this.unevalEdges.push(...t3), this.constructTunnelStructures(n22, this.unevalVertices, this.unevalHeights, this.unevalEdges, { min: 0, max: l22 }, { min: l22, max: e3 });
          }
          r22(o2), n22.addTriangles(this.unevalTriangles, this.unevalVertices, this.unevalHeights), r22(u22), n22.addTriangles(this.unevalTunnelTriangles, this.unevalVertices, this.unevalHeights), r22(s2), n22.addTriangles(this.unevalTunnelTriangles, this.unevalVertices, [-0.1]), r22(i22), this.maskSegments = Ka.simpleSegment(0, u22.primitiveOffset, 0, u22.primitiveLength), this.depthSegments = Ka.simpleSegment(0, s2.primitiveOffset, 0, s2.primitiveLength), this.renderableSegments = Ka.simpleSegment(0, o2.primitiveOffset, 0, o2.primitiveLength), this.shadowCasterSegments = Ka.simpleSegment(0, i22.primitiveOffset, 0, i22.primitiveLength);
        }
        upload(t22) {
          this.vertexBuffer || 0 === this.vertexPositions.length || 0 === this.vertexNormals.length || 0 === this.indexArray.length || (this.vertexBuffer = t22.createVertexBuffer(this.vertexPositions, Kc.members), this.vertexBufferNormal = t22.createVertexBuffer(this.vertexNormals, Jc.members), this.indexBuffer = t22.createIndexBuffer(this.indexArray));
        }
        destroy() {
          this.vertexBuffer && (this.vertexBuffer.destroy(), this.vertexBufferNormal.destroy(), this.indexBuffer.destroy()), this.maskSegments && (this.maskSegments.destroy(), this.depthSegments.destroy(), this.renderableSegments.destroy(), this.shadowCasterSegments.destroy());
        }
        computeVertexConnections(t22, e22, r22, n22, i22) {
          const s2 = /* @__PURE__ */ new Map();
          for (let o2 = n22; o2 < i22; o2++) {
            const n3 = r22[o2], i3 = n3.a, a22 = n3.b, l22 = rp.computePosHash(t22[i3]), u22 = rp.computePosHash(t22[a22]);
            s2.has(l22) || s2.set(l22, {}), s2.has(u22) || s2.set(u22, {});
            const c22 = s2.get(l22), h22 = s2.get(u22);
            e22[i3] <= 0 && e22[a22] <= 0 || (c22.to = a22, h22.from = i3);
          }
          return s2;
        }
        constructBridgeStructures(t22, e22, r22, n22, i22, s2) {
          const o2 = this.computeVertexConnections(e22, r22, n22, i22.min, i22.max), a22 = 1 / s2, l22 = 0.5 * a22, u22 = (t3) => A2(e22[t3].x, e22[t3].y, r22[t3] * a22), c22 = (t3) => {
            const r3 = o2.get(rp.computePosHash(e22[t3])), n3 = r3.from, i3 = r3.to;
            if (!n3 || !i3) return;
            const s3 = u22(n3), a3 = u22(t3), l3 = u22(i3), c3 = A2(0, 0, 0);
            if (!N2(s3, a3)) {
              const t4 = j2(b2(), a3, s3);
              M2(c3, c3, C(t4, t4));
            }
            if (!N2(l3, a3)) {
              const t4 = j2(b2(), l3, a3);
              M2(c3, c3, C(t4, t4));
            }
            const h22 = G(c3);
            return h22 > 0 ? E2(c3, c3, 1 / h22) : void 0;
          };
          for (let o3 = i22.min; o3 < i22.max; o3++) {
            const i3 = n22[o3], u3 = this.prepareEdgePoints(e22, r22, i3, (t3, e3) => t3 > e3);
            if (null == u3) continue;
            const h22 = u3[0], p22 = u3[1], f22 = A2(h22.coord.x, h22.coord.y, a22 * h22.height), d22 = A2(p22.coord.x, p22.coord.y, a22 * p22.height);
            if (N2(f22, d22)) continue;
            const m22 = j2(b2(), d22, f22);
            C(m22, m22);
            const y22 = (t3) => C(t3, t3), g22 = c22(i3.a) || m22, x22 = c22(i3.b) || m22, v22 = y22(A2(g22[1], -g22[0], 0)), _22 = y22(A2(x22[1], -x22[0], 0)), w22 = y22(F(b2(), v22, g22)), I2 = y22(F(b2(), _22, x22)), S2 = b2(), z22 = [M2(b2(), f22, E2(S2, j2(S2, v22, w22), l22)), M2(b2(), f22, E2(S2, M2(S2, v22, w22), l22)), M2(b2(), f22, E2(S2, w22, l22)), f22], k22 = [M2(b2(), d22, E2(S2, j2(S2, _22, I2), l22)), M2(b2(), d22, E2(S2, M2(S2, _22, I2), l22)), M2(b2(), d22, E2(S2, I2, l22)), d22], [P22, T2] = t22.addVertices(v22, s2, z22[0], z22[1]), [B22, D22] = t22.addVertices(_22, s2, k22[0], k22[1]);
            t22.addTriangles([P22, T2, B22, T2, D22, B22]);
            const [L22, R22] = t22.addVertices(w22, s2, z22[1], z22[2]), [O2, U22] = t22.addVertices(I2, s2, k22[1], k22[2]);
            t22.addTriangles([L22, R22, O2, R22, U22, O2]);
            const [$2, G2] = t22.addVertices(V(v22, v22), s2, z22[2], z22[3]), [q22, H2] = t22.addVertices(V(_22, _22), s2, k22[2], k22[3]);
            t22.addTriangles([$2, G2, q22, G2, H2, q22]);
          }
        }
        constructTunnelStructures(t22, e22, r22, n22, i22, s2) {
          const o2 = (t3) => C(t3, t3);
          for (let s3 = i22.min; s3 < i22.max; s3++) {
            const i3 = this.prepareEdgePoints(e22, r22, n22[s3], (t3, e3) => t3 < e3);
            if (null == i3) continue;
            const [a22, l22] = i3, u22 = o2(A2(l22.coord.y - a22.coord.y, -(l22.coord.x - a22.coord.x), 0));
            t22.addQuad([a22, l22, { coord: l22.coord, height: n22[s3].isTunnel ? -0.1 : 0 }, { coord: a22.coord, height: n22[s3].isTunnel ? -0.1 : 0 }], u22);
          }
          for (let i3 = s2.min; i3 < s2.max; i3++) {
            const s3 = n22[i3], a22 = e22[s3.a], l22 = e22[s3.b], u22 = o2(A2(l22.y - a22.y, -(l22.x - a22.x), 0));
            t22.addQuad([{ coord: l22, height: 0 }, { coord: a22, height: 0 }, { coord: a22, height: r22[s3.a] + 4 }, { coord: l22, height: r22[s3.b] + 4 }], u22), t22.addQuad([{ coord: a22, height: 0 }, { coord: l22, height: 0 }, { coord: l22, height: r22[s3.b] + 4 }, { coord: a22, height: r22[s3.a] + 4 }], u22);
          }
        }
        prepareEdgePoints(t22, e22, r22, n22) {
          let i22 = e22[r22.a], s2 = e22[r22.b];
          const o2 = n22(i22, 0), a22 = n22(s2, 0);
          if (o2 && a22) return [{ coord: t22[r22.a], height: i22 }, { coord: t22[r22.b], height: s2 }];
          if (!o2 && !a22) return;
          const l22 = t22[r22.a].clone(), u22 = t22[r22.b].clone();
          if (o2) {
            if (!a22) {
              const t3 = s2 / (s2 - i22);
              u22.x = or(u22.x, l22.x, t3), u22.y = or(u22.y, l22.y, t3), s2 = or(s2, i22, t3);
            }
          } else {
            const t3 = i22 / (i22 - s2);
            l22.x = or(l22.x, u22.x, t3), l22.y = or(l22.y, u22.y, t3), i22 = or(i22, s2, t3);
          }
          return [{ coord: l22, height: i22 }, { coord: u22, height: s2 }];
        }
        prepareEdges(t22, e22) {
          if (0 === e22.length) return;
          e22.sort((t3, e3) => t3.hash === e3.hash ? e3.polygonIdx - t3.polygonIdx : e3.hash > t3.hash ? 1 : -1);
          let r22 = 0, n22 = 0, i22 = 0, s2 = e22[r22].polygonIdx;
          do {
            n22++, (n22 === e22.length || e22[r22].hash !== e22[n22].hash) && ((1 == n22 - r22 || e22[n22 - 1].polygonIdx !== s2) && (i22 < r22 && (e22[i22] = e22[r22], e22[r22] = null), e22[i22].type = "none", i22++), r22 = n22, r22 !== e22.length && (s2 = e22[r22].polygonIdx));
          } while (r22 !== e22.length);
          if (e22.splice(i22), 0 !== e22.length && 0 !== t22.length) {
            e22.sort((t3, e3) => t3.portalHash < e3.portalHash ? 1 : -1);
            let r3 = 0, n3 = 0;
            for (; r3 !== e22.length && n3 !== t22.length; ) {
              const i3 = e22[r3], s3 = t22[n3];
              i3.portalHash > s3.hash ? r3++ : s3.hash > i3.portalHash ? n3++ : (i3.type = s3.type, r3++);
            }
          }
        }
        isOnBorder(t22, e22) {
          return t22 <= 0 && e22 <= 0 || t22 >= Tn && e22 >= Tn;
        }
        static computeEdgeHash(t22, e22) {
          return (t22.y === e22.y && t22.x > e22.x || t22.y > e22.y) && ([t22, e22] = [e22, t22]), BigInt(rp.computePosHash(t22)) << 32n | BigInt(rp.computePosHash(e22));
        }
        static computePosHash(t22) {
          return ((65535 & t22.x) << 16 | 65535 & t22.y) >>> 0;
        }
      }
      var np, ip = { exports: {} }, sp = (np || (np = 1, function(t22, e22) {
        !function(t3) {
          function e3(t4, e4) {
            return t4 > e4 ? 1 : t4 < e4 ? -1 : 0;
          }
          var r22 = function(t4, r3) {
            void 0 === t4 && (t4 = e3), void 0 === r3 && (r3 = false), this._compare = t4, this._root = null, this._size = 0, this._noDuplicates = !!r3;
          }, n22 = { size: { configurable: true } };
          function i22(t4, e4, r3, n3, s3) {
            var o3 = s3 - n3;
            if (o3 > 0) {
              var a3 = n3 + Math.floor(o3 / 2), l3 = { key: e4[a3], data: r3[a3], parent: t4 };
              return l3.left = i22(l3, e4, r3, n3, a3), l3.right = i22(l3, e4, r3, a3 + 1, s3), l3;
            }
            return null;
          }
          function s2(t4, e4, r3, n3, i3) {
            if (!(r3 >= n3)) {
              for (var o3 = t4[r3 + n3 >> 1], a3 = r3 - 1, l3 = n3 + 1; ; ) {
                do {
                  a3++;
                } while (i3(t4[a3], o3) < 0);
                do {
                  l3--;
                } while (i3(t4[l3], o3) > 0);
                if (a3 >= l3) break;
                var u3 = t4[a3];
                t4[a3] = t4[l3], t4[l3] = u3, u3 = e4[a3], e4[a3] = e4[l3], e4[l3] = u3;
              }
              s2(t4, e4, r3, l3, i3), s2(t4, e4, l3 + 1, n3, i3);
            }
          }
          r22.prototype.rotateLeft = function(t4) {
            var e4 = t4.right;
            e4 && (t4.right = e4.left, e4.left && (e4.left.parent = t4), e4.parent = t4.parent), t4.parent ? t4 === t4.parent.left ? t4.parent.left = e4 : t4.parent.right = e4 : this._root = e4, e4 && (e4.left = t4), t4.parent = e4;
          }, r22.prototype.rotateRight = function(t4) {
            var e4 = t4.left;
            e4 && (t4.left = e4.right, e4.right && (e4.right.parent = t4), e4.parent = t4.parent), t4.parent ? t4 === t4.parent.left ? t4.parent.left = e4 : t4.parent.right = e4 : this._root = e4, e4 && (e4.right = t4), t4.parent = e4;
          }, r22.prototype._splay = function(t4) {
            for (; t4.parent; ) {
              var e4 = t4.parent;
              e4.parent ? e4.left === t4 && e4.parent.left === e4 ? (this.rotateRight(e4.parent), this.rotateRight(e4)) : e4.right === t4 && e4.parent.right === e4 ? (this.rotateLeft(e4.parent), this.rotateLeft(e4)) : e4.left === t4 && e4.parent.right === e4 ? (this.rotateRight(e4), this.rotateLeft(e4)) : (this.rotateLeft(e4), this.rotateRight(e4)) : e4.left === t4 ? this.rotateRight(e4) : this.rotateLeft(e4);
            }
          }, r22.prototype.splay = function(t4) {
            for (var e4, r3, n3, i3, s3; t4.parent; ) (r3 = (e4 = t4.parent).parent) && r3.parent ? ((n3 = r3.parent).left === r3 ? n3.left = t4 : n3.right = t4, t4.parent = n3) : (t4.parent = null, this._root = t4), i3 = t4.left, s3 = t4.right, t4 === e4.left ? (r3 && (r3.left === e4 ? (e4.right ? (r3.left = e4.right, r3.left.parent = r3) : r3.left = null, e4.right = r3, r3.parent = e4) : (i3 ? (r3.right = i3, i3.parent = r3) : r3.right = null, t4.left = r3, r3.parent = t4)), s3 ? (e4.left = s3, s3.parent = e4) : e4.left = null, t4.right = e4, e4.parent = t4) : (r3 && (r3.right === e4 ? (e4.left ? (r3.right = e4.left, r3.right.parent = r3) : r3.right = null, e4.left = r3, r3.parent = e4) : (s3 ? (r3.left = s3, s3.parent = r3) : r3.left = null, t4.right = r3, r3.parent = t4)), i3 ? (e4.right = i3, i3.parent = e4) : e4.right = null, t4.left = e4, e4.parent = t4);
          }, r22.prototype.replace = function(t4, e4) {
            t4.parent ? t4 === t4.parent.left ? t4.parent.left = e4 : t4.parent.right = e4 : this._root = e4, e4 && (e4.parent = t4.parent);
          }, r22.prototype.minNode = function(t4) {
            if (void 0 === t4 && (t4 = this._root), t4) for (; t4.left; ) t4 = t4.left;
            return t4;
          }, r22.prototype.maxNode = function(t4) {
            if (void 0 === t4 && (t4 = this._root), t4) for (; t4.right; ) t4 = t4.right;
            return t4;
          }, r22.prototype.insert = function(t4, e4) {
            var r3 = this._root, n3 = null, i3 = this._compare;
            if (this._noDuplicates) for (; r3; ) {
              if (n3 = r3, 0 === i3(r3.key, t4)) return;
              r3 = i3(r3.key, t4) < 0 ? r3.right : r3.left;
            }
            else for (; r3; ) n3 = r3, r3 = i3(r3.key, t4) < 0 ? r3.right : r3.left;
            return r3 = { key: t4, data: e4, left: null, right: null, parent: n3 }, n3 ? i3(n3.key, r3.key) < 0 ? n3.right = r3 : n3.left = r3 : this._root = r3, this.splay(r3), this._size++, r3;
          }, r22.prototype.find = function(t4) {
            for (var e4 = this._root, r3 = this._compare; e4; ) {
              var n3 = r3(e4.key, t4);
              if (n3 < 0) e4 = e4.right;
              else {
                if (!(n3 > 0)) return e4;
                e4 = e4.left;
              }
            }
            return null;
          }, r22.prototype.contains = function(t4) {
            for (var e4 = this._root, r3 = this._compare; e4; ) {
              var n3 = r3(t4, e4.key);
              if (0 === n3) return true;
              e4 = n3 < 0 ? e4.left : e4.right;
            }
            return false;
          }, r22.prototype.remove = function(t4) {
            var e4 = this.find(t4);
            if (!e4) return false;
            if (this.splay(e4), e4.left) if (e4.right) {
              var r3 = this.minNode(e4.right);
              r3.parent !== e4 && (this.replace(r3, r3.right), r3.right = e4.right, r3.right.parent = r3), this.replace(e4, r3), r3.left = e4.left, r3.left.parent = r3;
            } else this.replace(e4, e4.left);
            else this.replace(e4, e4.right);
            return this._size--, true;
          }, r22.prototype.removeNode = function(t4) {
            if (!t4) return false;
            if (this.splay(t4), t4.left) if (t4.right) {
              var e4 = this.minNode(t4.right);
              e4.parent !== t4 && (this.replace(e4, e4.right), e4.right = t4.right, e4.right.parent = e4), this.replace(t4, e4), e4.left = t4.left, e4.left.parent = e4;
            } else this.replace(t4, t4.left);
            else this.replace(t4, t4.right);
            return this._size--, true;
          }, r22.prototype.erase = function(t4) {
            var e4 = this.find(t4);
            if (e4) {
              this.splay(e4);
              var r3 = e4.left, n3 = e4.right, i3 = null;
              r3 && (r3.parent = null, i3 = this.maxNode(r3), this.splay(i3), this._root = i3), n3 && (r3 ? i3.right = n3 : this._root = n3, n3.parent = i3), this._size--;
            }
          }, r22.prototype.pop = function() {
            var t4 = this._root, e4 = null;
            if (t4) {
              for (; t4.left; ) t4 = t4.left;
              e4 = { key: t4.key, data: t4.data }, this.remove(t4.key);
            }
            return e4;
          }, r22.prototype.next = function(t4) {
            var e4 = t4;
            if (e4) if (e4.right) for (e4 = e4.right; e4 && e4.left; ) e4 = e4.left;
            else for (e4 = t4.parent; e4 && e4.right === t4; ) t4 = e4, e4 = e4.parent;
            return e4;
          }, r22.prototype.prev = function(t4) {
            var e4 = t4;
            if (e4) if (e4.left) for (e4 = e4.left; e4 && e4.right; ) e4 = e4.right;
            else for (e4 = t4.parent; e4 && e4.left === t4; ) t4 = e4, e4 = e4.parent;
            return e4;
          }, r22.prototype.forEach = function(t4) {
            for (var e4 = this._root, r3 = [], n3 = false, i3 = 0; !n3; ) e4 ? (r3.push(e4), e4 = e4.left) : r3.length > 0 ? (t4(e4 = r3.pop(), i3++), e4 = e4.right) : n3 = true;
            return this;
          }, r22.prototype.range = function(t4, e4, r3, n3) {
            for (var i3 = [], s3 = this._compare, o3 = this._root; 0 !== i3.length || o3; ) if (o3) i3.push(o3), o3 = o3.left;
            else {
              if (s3((o3 = i3.pop()).key, e4) > 0) break;
              if (s3(o3.key, t4) >= 0 && r3.call(n3, o3)) return this;
              o3 = o3.right;
            }
            return this;
          }, r22.prototype.keys = function() {
            for (var t4 = this._root, e4 = [], r3 = [], n3 = false; !n3; ) t4 ? (e4.push(t4), t4 = t4.left) : e4.length > 0 ? (t4 = e4.pop(), r3.push(t4.key), t4 = t4.right) : n3 = true;
            return r3;
          }, r22.prototype.values = function() {
            for (var t4 = this._root, e4 = [], r3 = [], n3 = false; !n3; ) t4 ? (e4.push(t4), t4 = t4.left) : e4.length > 0 ? (t4 = e4.pop(), r3.push(t4.data), t4 = t4.right) : n3 = true;
            return r3;
          }, r22.prototype.at = function(t4) {
            for (var e4 = this._root, r3 = [], n3 = false, i3 = 0; !n3; ) if (e4) r3.push(e4), e4 = e4.left;
            else if (r3.length > 0) {
              if (e4 = r3.pop(), i3 === t4) return e4;
              i3++, e4 = e4.right;
            } else n3 = true;
            return null;
          }, r22.prototype.load = function(t4, e4, r3) {
            if (void 0 === t4 && (t4 = []), void 0 === e4 && (e4 = []), void 0 === r3 && (r3 = false), 0 !== this._size) throw new Error("bulk-load: tree is not empty");
            var n3 = t4.length;
            return r3 && s2(t4, e4, 0, n3 - 1, this._compare), this._root = i22(null, t4, e4, 0, n3), this._size = n3, this;
          }, r22.prototype.min = function() {
            var t4 = this.minNode(this._root);
            return t4 ? t4.key : null;
          }, r22.prototype.max = function() {
            var t4 = this.maxNode(this._root);
            return t4 ? t4.key : null;
          }, r22.prototype.isEmpty = function() {
            return null === this._root;
          }, n22.size.get = function() {
            return this._size;
          }, r22.createTree = function(t4, e4, n3, i3, s3) {
            return new r22(n3, s3).load(t4, e4, i3);
          }, Object.defineProperties(r22.prototype, n22);
          var o2 = 0, a22 = 1, l22 = 2, u22 = 3, c22 = 0, h22 = 1, p22 = 2, f22 = 3;
          function d22(t4, e4, r3) {
            null === e4 ? (t4.inOut = false, t4.otherInOut = true) : (t4.isSubject === e4.isSubject ? (t4.inOut = !e4.inOut, t4.otherInOut = e4.otherInOut) : (t4.inOut = !e4.otherInOut, t4.otherInOut = e4.isVertical() ? !e4.inOut : e4.inOut), e4 && (t4.prevInResult = !m22(e4, r3) || e4.isVertical() ? e4.prevInResult : e4));
            var n3 = m22(t4, r3);
            t4.resultTransition = n3 ? function(t5, e5) {
              var r4, n4 = !t5.inOut, i3 = !t5.otherInOut;
              switch (e5) {
                case c22:
                  r4 = n4 && i3;
                  break;
                case h22:
                  r4 = n4 || i3;
                  break;
                case f22:
                  r4 = n4 ^ i3;
                  break;
                case p22:
                  r4 = t5.isSubject ? n4 && !i3 : i3 && !n4;
              }
              return r4 ? 1 : -1;
            }(t4, r3) : 0;
          }
          function m22(t4, e4) {
            switch (t4.type) {
              case o2:
                switch (e4) {
                  case c22:
                    return !t4.otherInOut;
                  case h22:
                    return t4.otherInOut;
                  case p22:
                    return t4.isSubject && t4.otherInOut || !t4.isSubject && !t4.otherInOut;
                  case f22:
                    return true;
                }
                break;
              case l22:
                return e4 === c22 || e4 === h22;
              case u22:
                return e4 === p22;
              case a22:
                return false;
            }
            return false;
          }
          var y22 = function(t4, e4, r3, n3, i3) {
            this.left = e4, this.point = t4, this.otherEvent = r3, this.isSubject = n3, this.type = i3 || o2, this.inOut = false, this.otherInOut = false, this.prevInResult = null, this.resultTransition = 0, this.otherPos = -1, this.outputContourId = -1, this.isExteriorRing = true;
          }, g22 = { inResult: { configurable: true } };
          function x22(t4, e4) {
            return t4[0] === e4[0] && t4[1] === e4[1];
          }
          y22.prototype.isBelow = function(t4) {
            var e4 = this.point, r3 = this.otherEvent.point;
            return this.left ? (e4[0] - t4[0]) * (r3[1] - t4[1]) - (r3[0] - t4[0]) * (e4[1] - t4[1]) > 0 : (r3[0] - t4[0]) * (e4[1] - t4[1]) - (e4[0] - t4[0]) * (r3[1] - t4[1]) > 0;
          }, y22.prototype.isAbove = function(t4) {
            return !this.isBelow(t4);
          }, y22.prototype.isVertical = function() {
            return this.point[0] === this.otherEvent.point[0];
          }, g22.inResult.get = function() {
            return 0 !== this.resultTransition;
          }, y22.prototype.clone = function() {
            var t4 = new y22(this.point, this.left, this.otherEvent, this.isSubject, this.type);
            return t4.contourId = this.contourId, t4.resultTransition = this.resultTransition, t4.prevInResult = this.prevInResult, t4.isExteriorRing = this.isExteriorRing, t4.inOut = this.inOut, t4.otherInOut = this.otherInOut, t4;
          }, Object.defineProperties(y22.prototype, g22);
          var v22 = 11102230246251565e-32, b22 = 134217729, _22 = (3 + 8 * v22) * v22;
          function w22(t4, e4, r3, n3, i3) {
            var s3, o3, a3, l3, u3 = e4[0], c3 = n3[0], h3 = 0, p3 = 0;
            c3 > u3 == c3 > -u3 ? (s3 = u3, u3 = e4[++h3]) : (s3 = c3, c3 = n3[++p3]);
            var f3 = 0;
            if (h3 < t4 && p3 < r3) for (c3 > u3 == c3 > -u3 ? (a3 = s3 - ((o3 = u3 + s3) - u3), u3 = e4[++h3]) : (a3 = s3 - ((o3 = c3 + s3) - c3), c3 = n3[++p3]), s3 = o3, 0 !== a3 && (i3[f3++] = a3); h3 < t4 && p3 < r3; ) c3 > u3 == c3 > -u3 ? (a3 = s3 - ((o3 = s3 + u3) - (l3 = o3 - s3)) + (u3 - l3), u3 = e4[++h3]) : (a3 = s3 - ((o3 = s3 + c3) - (l3 = o3 - s3)) + (c3 - l3), c3 = n3[++p3]), s3 = o3, 0 !== a3 && (i3[f3++] = a3);
            for (; h3 < t4; ) a3 = s3 - ((o3 = s3 + u3) - (l3 = o3 - s3)) + (u3 - l3), u3 = e4[++h3], s3 = o3, 0 !== a3 && (i3[f3++] = a3);
            for (; p3 < r3; ) a3 = s3 - ((o3 = s3 + c3) - (l3 = o3 - s3)) + (c3 - l3), c3 = n3[++p3], s3 = o3, 0 !== a3 && (i3[f3++] = a3);
            return 0 === s3 && 0 !== f3 || (i3[f3++] = s3), f3;
          }
          function A22(t4) {
            return new Float64Array(t4);
          }
          var M22 = 33306690738754716e-32, I2 = 22204460492503146e-32, S2 = 11093356479670487e-47, z22 = A22(4), k22 = A22(8), E22 = A22(12), P22 = A22(16), T2 = A22(4);
          function B22(t4, e4, r3) {
            var n3 = function(t5, e5, r4, n4, i3, s3) {
              var o3 = (e5 - s3) * (r4 - i3), a3 = (t5 - i3) * (n4 - s3), l3 = o3 - a3;
              if (0 === o3 || 0 === a3 || o3 > 0 != a3 > 0) return l3;
              var u3 = Math.abs(o3 + a3);
              return Math.abs(l3) >= M22 * u3 ? l3 : -function(t6, e6, r5, n5, i4, s4, o4) {
                var a4, l4, u4, c3, h3, p3, f3, d3, m3, y3, g3, x3, v3, A3, M3, B3, V3, C3, D3 = t6 - i4, F3 = r5 - i4, L3 = e6 - s4, R3 = n5 - s4;
                z22[0] = (M3 = (d3 = D3 - (f3 = (p3 = b22 * D3) - (p3 - D3))) * (y3 = R3 - (m3 = (p3 = b22 * R3) - (p3 - R3))) - ((A3 = D3 * R3) - f3 * m3 - d3 * m3 - f3 * y3)) - ((g3 = M3 - (V3 = (d3 = L3 - (f3 = (p3 = b22 * L3) - (p3 - L3))) * (y3 = F3 - (m3 = (p3 = b22 * F3) - (p3 - F3))) - ((B3 = L3 * F3) - f3 * m3 - d3 * m3 - f3 * y3))) + (h3 = M3 - g3)) + (h3 - V3), z22[1] = (v3 = A3 - ((x3 = A3 + g3) - (h3 = x3 - A3)) + (g3 - h3)) - ((g3 = v3 - B3) + (h3 = v3 - g3)) + (h3 - B3), z22[2] = x3 - ((C3 = x3 + g3) - (h3 = C3 - x3)) + (g3 - h3), z22[3] = C3;
                var O3 = function(t7, e7) {
                  for (var r6 = e7[0], n6 = 1; n6 < 4; n6++) r6 += e7[n6];
                  return r6;
                }(0, z22), U3 = I2 * o4;
                if (O3 >= U3 || -O3 >= U3) return O3;
                if (a4 = t6 - (D3 + (h3 = t6 - D3)) + (h3 - i4), u4 = r5 - (F3 + (h3 = r5 - F3)) + (h3 - i4), l4 = e6 - (L3 + (h3 = e6 - L3)) + (h3 - s4), c3 = n5 - (R3 + (h3 = n5 - R3)) + (h3 - s4), 0 === a4 && 0 === l4 && 0 === u4 && 0 === c3) return O3;
                if (U3 = S2 * o4 + _22 * Math.abs(O3), (O3 += D3 * c3 + R3 * a4 - (L3 * u4 + F3 * l4)) >= U3 || -O3 >= U3) return O3;
                T2[0] = (M3 = (d3 = a4 - (f3 = (p3 = b22 * a4) - (p3 - a4))) * (y3 = R3 - (m3 = (p3 = b22 * R3) - (p3 - R3))) - ((A3 = a4 * R3) - f3 * m3 - d3 * m3 - f3 * y3)) - ((g3 = M3 - (V3 = (d3 = l4 - (f3 = (p3 = b22 * l4) - (p3 - l4))) * (y3 = F3 - (m3 = (p3 = b22 * F3) - (p3 - F3))) - ((B3 = l4 * F3) - f3 * m3 - d3 * m3 - f3 * y3))) + (h3 = M3 - g3)) + (h3 - V3), T2[1] = (v3 = A3 - ((x3 = A3 + g3) - (h3 = x3 - A3)) + (g3 - h3)) - ((g3 = v3 - B3) + (h3 = v3 - g3)) + (h3 - B3), T2[2] = x3 - ((C3 = x3 + g3) - (h3 = C3 - x3)) + (g3 - h3), T2[3] = C3;
                var N3 = w22(4, z22, 4, T2, k22);
                T2[0] = (M3 = (d3 = D3 - (f3 = (p3 = b22 * D3) - (p3 - D3))) * (y3 = c3 - (m3 = (p3 = b22 * c3) - (p3 - c3))) - ((A3 = D3 * c3) - f3 * m3 - d3 * m3 - f3 * y3)) - ((g3 = M3 - (V3 = (d3 = L3 - (f3 = (p3 = b22 * L3) - (p3 - L3))) * (y3 = u4 - (m3 = (p3 = b22 * u4) - (p3 - u4))) - ((B3 = L3 * u4) - f3 * m3 - d3 * m3 - f3 * y3))) + (h3 = M3 - g3)) + (h3 - V3), T2[1] = (v3 = A3 - ((x3 = A3 + g3) - (h3 = x3 - A3)) + (g3 - h3)) - ((g3 = v3 - B3) + (h3 = v3 - g3)) + (h3 - B3), T2[2] = x3 - ((C3 = x3 + g3) - (h3 = C3 - x3)) + (g3 - h3), T2[3] = C3;
                var j3 = w22(N3, k22, 4, T2, E22);
                T2[0] = (M3 = (d3 = a4 - (f3 = (p3 = b22 * a4) - (p3 - a4))) * (y3 = c3 - (m3 = (p3 = b22 * c3) - (p3 - c3))) - ((A3 = a4 * c3) - f3 * m3 - d3 * m3 - f3 * y3)) - ((g3 = M3 - (V3 = (d3 = l4 - (f3 = (p3 = b22 * l4) - (p3 - l4))) * (y3 = u4 - (m3 = (p3 = b22 * u4) - (p3 - u4))) - ((B3 = l4 * u4) - f3 * m3 - d3 * m3 - f3 * y3))) + (h3 = M3 - g3)) + (h3 - V3), T2[1] = (v3 = A3 - ((x3 = A3 + g3) - (h3 = x3 - A3)) + (g3 - h3)) - ((g3 = v3 - B3) + (h3 = v3 - g3)) + (h3 - B3), T2[2] = x3 - ((C3 = x3 + g3) - (h3 = C3 - x3)) + (g3 - h3), T2[3] = C3;
                var $3 = w22(j3, E22, 4, T2, P22);
                return P22[$3 - 1];
              }(t5, e5, r4, n4, i3, s3, u3);
            }(t4[0], t4[1], e4[0], e4[1], r3[0], r3[1]);
            return n3 > 0 ? -1 : n3 < 0 ? 1 : 0;
          }
          function V2(t4, e4) {
            var r3 = t4.point, n3 = e4.point;
            return r3[0] > n3[0] ? 1 : r3[0] < n3[0] ? -1 : r3[1] !== n3[1] ? r3[1] > n3[1] ? 1 : -1 : function(t5, e5, r4, n4) {
              return t5.left !== e5.left ? t5.left ? 1 : -1 : 0 !== B22(r4, t5.otherEvent.point, e5.otherEvent.point) ? t5.isBelow(e5.otherEvent.point) ? -1 : 1 : !t5.isSubject && e5.isSubject ? 1 : -1;
            }(t4, e4, r3);
          }
          function C22(t4, e4, r3) {
            var n3 = new y22(e4, false, t4, t4.isSubject), i3 = new y22(e4, true, t4.otherEvent, t4.isSubject);
            return x22(t4.point, t4.otherEvent.point) && console.warn("what is that, a collapsed segment?", t4), n3.contourId = i3.contourId = t4.contourId, V2(i3, t4.otherEvent) > 0 && (t4.otherEvent.left = true, i3.left = false), t4.otherEvent.otherEvent = i3, t4.otherEvent = n3, r3.push(i3), r3.push(n3), r3;
          }
          function D22(t4, e4) {
            return t4[0] * e4[1] - t4[1] * e4[0];
          }
          function F2(t4, e4) {
            return t4[0] * e4[0] + t4[1] * e4[1];
          }
          function L22(t4, e4, r3) {
            var n3 = function(t5, e5, r4, n4, i4) {
              var s4 = [e5[0] - t5[0], e5[1] - t5[1]], o4 = [n4[0] - r4[0], n4[1] - r4[1]];
              function a3(t6, e6, r5) {
                return [t6[0] + e6 * r5[0], t6[1] + e6 * r5[1]];
              }
              var l3 = [r4[0] - t5[0], r4[1] - t5[1]], u3 = D22(s4, o4), c4 = u3 * u3, h3 = F2(s4, s4);
              if (c4 > 0) {
                var p3 = D22(l3, o4) / u3;
                if (p3 < 0 || p3 > 1) return null;
                var f3 = D22(l3, s4) / u3;
                return f3 < 0 || f3 > 1 ? null : 0 === p3 || 1 === p3 ? [a3(t5, p3, s4)] : 0 === f3 || 1 === f3 ? [a3(r4, f3, o4)] : [a3(t5, p3, s4)];
              }
              if ((c4 = (u3 = D22(l3, s4)) * u3) > 0) return null;
              var d3 = F2(s4, l3) / h3, m3 = d3 + F2(s4, o4) / h3, y3 = Math.min(d3, m3), g3 = Math.max(d3, m3);
              return y3 <= 1 && g3 >= 0 ? 1 === y3 ? [a3(t5, y3 > 0 ? y3 : 0, s4)] : 0 === g3 ? [a3(t5, g3 < 1 ? g3 : 1, s4)] : [a3(t5, y3 > 0 ? y3 : 0, s4), a3(t5, g3 < 1 ? g3 : 1, s4)] : null;
            }(t4.point, t4.otherEvent.point, e4.point, e4.otherEvent.point), i3 = n3 ? n3.length : 0;
            if (0 === i3) return 0;
            if (1 === i3 && (x22(t4.point, e4.point) || x22(t4.otherEvent.point, e4.otherEvent.point))) return 0;
            if (2 === i3 && t4.isSubject === e4.isSubject) return 0;
            if (1 === i3) return x22(t4.point, n3[0]) || x22(t4.otherEvent.point, n3[0]) || C22(t4, n3[0], r3), x22(e4.point, n3[0]) || x22(e4.otherEvent.point, n3[0]) || C22(e4, n3[0], r3), 1;
            var s3 = [], o3 = false, c3 = false;
            return x22(t4.point, e4.point) ? o3 = true : 1 === V2(t4, e4) ? s3.push(e4, t4) : s3.push(t4, e4), x22(t4.otherEvent.point, e4.otherEvent.point) ? c3 = true : 1 === V2(t4.otherEvent, e4.otherEvent) ? s3.push(e4.otherEvent, t4.otherEvent) : s3.push(t4.otherEvent, e4.otherEvent), o3 && c3 || o3 ? (e4.type = a22, t4.type = e4.inOut === t4.inOut ? l22 : u22, o3 && !c3 && C22(s3[1].otherEvent, s3[0].point, r3), 2) : c3 ? (C22(s3[0], s3[1].point, r3), 3) : s3[0] !== s3[3].otherEvent ? (C22(s3[0], s3[1].point, r3), C22(s3[1], s3[2].point, r3), 3) : (C22(s3[0], s3[1].point, r3), C22(s3[3].otherEvent, s3[2].point, r3), 3);
          }
          function R22(t4, e4) {
            if (t4 === e4) return 0;
            if (0 !== B22(t4.point, t4.otherEvent.point, e4.point) || 0 !== B22(t4.point, t4.otherEvent.point, e4.otherEvent.point)) return x22(t4.point, e4.point) ? t4.isBelow(e4.otherEvent.point) ? -1 : 1 : t4.point[0] === e4.point[0] ? t4.point[1] < e4.point[1] ? -1 : 1 : 1 === V2(t4, e4) ? e4.isAbove(t4.point) ? -1 : 1 : t4.isBelow(e4.point) ? -1 : 1;
            if (t4.isSubject !== e4.isSubject) return t4.isSubject ? -1 : 1;
            var r3 = t4.point, n3 = e4.point;
            return r3[0] === n3[0] && r3[1] === n3[1] ? (r3 = t4.otherEvent.point)[0] === (n3 = e4.otherEvent.point)[0] && r3[1] === n3[1] ? 0 : t4.contourId > e4.contourId ? 1 : -1 : 1 === V2(t4, e4) ? 1 : -1;
          }
          var O2 = function() {
            this.points = [], this.holeIds = [], this.holeOf = null, this.depth = null;
          };
          function U22(t4, e4, r3, n3) {
            var i3, s3 = t4 + 1, o3 = e4[t4].point, a3 = e4.length;
            for (s3 < a3 && (i3 = e4[s3].point); s3 < a3 && i3[0] === o3[0] && i3[1] === o3[1]; ) {
              if (!r3[s3]) return s3;
              ++s3 < a3 && (i3 = e4[s3].point);
            }
            for (s3 = t4 - 1; r3[s3] && s3 > n3; ) s3--;
            return s3;
          }
          O2.prototype.isExterior = function() {
            return null == this.holeOf;
          };
          var N22 = $2, j22 = $2;
          function $2(t4, e4) {
            if (!(this instanceof $2)) return new $2(t4, e4);
            if (this.data = t4 || [], this.length = this.data.length, this.compare = e4 || G2, this.length > 0) for (var r3 = (this.length >> 1) - 1; r3 >= 0; r3--) this._down(r3);
          }
          function G2(t4, e4) {
            return t4 < e4 ? -1 : t4 > e4 ? 1 : 0;
          }
          $2.prototype = { push: function(t4) {
            this.data.push(t4), this.length++, this._up(this.length - 1);
          }, pop: function() {
            if (0 !== this.length) {
              var t4 = this.data[0];
              return this.length--, this.length > 0 && (this.data[0] = this.data[this.length], this._down(0)), this.data.pop(), t4;
            }
          }, peek: function() {
            return this.data[0];
          }, _up: function(t4) {
            for (var e4 = this.data, r3 = this.compare, n3 = e4[t4]; t4 > 0; ) {
              var i3 = t4 - 1 >> 1, s3 = e4[i3];
              if (r3(n3, s3) >= 0) break;
              e4[t4] = s3, t4 = i3;
            }
            e4[t4] = n3;
          }, _down: function(t4) {
            for (var e4 = this.data, r3 = this.compare, n3 = this.length >> 1, i3 = e4[t4]; t4 < n3; ) {
              var s3 = 1 + (t4 << 1), o3 = s3 + 1, a3 = e4[s3];
              if (o3 < this.length && r3(e4[o3], a3) < 0 && (s3 = o3, a3 = e4[o3]), r3(a3, i3) >= 0) break;
              e4[t4] = a3, t4 = s3;
            }
            e4[t4] = i3;
          } }, N22.default = j22;
          var q22 = Math.max, H2 = Math.min, X22 = 0;
          function Z2(t4, e4, r3, n3, i3, s3) {
            var o3, a3, l3, u3, c3, h3;
            for (o3 = 0, a3 = t4.length - 1; o3 < a3; o3++) if (u3 = t4[o3 + 1], c3 = new y22(l3 = t4[o3], false, void 0, e4), h3 = new y22(u3, false, c3, e4), c3.otherEvent = h3, l3[0] !== u3[0] || l3[1] !== u3[1]) {
              c3.contourId = h3.contourId = r3, s3 || (c3.isExteriorRing = false, h3.isExteriorRing = false), V2(c3, h3) > 0 ? h3.left = true : c3.left = true;
              var p3 = l3[0], f3 = l3[1];
              i3[0] = H2(i3[0], p3), i3[1] = H2(i3[1], f3), i3[2] = q22(i3[2], p3), i3[3] = q22(i3[3], f3), n3.push(c3), n3.push(h3);
            }
          }
          var W2 = [];
          function Y2(t4, e4, n3) {
            "number" == typeof t4[0][0][0] && (t4 = [t4]), "number" == typeof e4[0][0][0] && (e4 = [e4]);
            var i3 = function(t5, e5, r3) {
              var n4 = null;
              return t5.length * e5.length == 0 && (r3 === c22 ? n4 = W2 : r3 === p22 ? n4 = t5 : r3 !== h22 && r3 !== f22 || (n4 = 0 === t5.length ? e5 : t5)), n4;
            }(t4, e4, n3);
            if (i3) return i3 === W2 ? null : i3;
            var s3 = [1 / 0, 1 / 0, -1 / 0, -1 / 0], o3 = [1 / 0, 1 / 0, -1 / 0, -1 / 0], a3 = function(t5, e5, r3, n4, i4) {
              var s4, o4, a4, l4, u4, c3, h3 = new N22(null, V2);
              for (a4 = 0, l4 = t5.length; a4 < l4; a4++) for (u4 = 0, c3 = (s4 = t5[a4]).length; u4 < c3; u4++) (o4 = 0 === u4) && X22++, Z2(s4[u4], true, X22, h3, r3, o4);
              for (a4 = 0, l4 = e5.length; a4 < l4; a4++) for (u4 = 0, c3 = (s4 = e5[a4]).length; u4 < c3; u4++) o4 = 0 === u4, i4 === p22 && (o4 = false), o4 && X22++, Z2(s4[u4], false, X22, h3, n4, o4);
              return h3;
            }(t4, e4, s3, o3, n3);
            if (i3 = function(t5, e5, r3, n4, i4) {
              var s4 = null;
              return (r3[0] > n4[2] || n4[0] > r3[2] || r3[1] > n4[3] || n4[1] > r3[3]) && (i4 === c22 ? s4 = W2 : i4 === p22 ? s4 = t5 : i4 !== h22 && i4 !== f22 || (s4 = t5.concat(e5))), s4;
            }(t4, e4, s3, o3, n3)) return i3 === W2 ? null : i3;
            for (var l3 = function(t5) {
              var e5, r3, n4 = function(t6) {
                var e6, r4, n5, i5, s5 = [];
                for (r4 = 0, n5 = t6.length; r4 < n5; r4++) ((e6 = t6[r4]).left && e6.inResult || !e6.left && e6.otherEvent.inResult) && s5.push(e6);
                for (var o5 = false; !o5; ) for (o5 = true, r4 = 0, n5 = s5.length; r4 < n5; r4++) r4 + 1 < n5 && 1 === V2(s5[r4], s5[r4 + 1]) && (i5 = s5[r4], s5[r4] = s5[r4 + 1], s5[r4 + 1] = i5, o5 = false);
                for (r4 = 0, n5 = s5.length; r4 < n5; r4++) (e6 = s5[r4]).otherPos = r4;
                for (r4 = 0, n5 = s5.length; r4 < n5; r4++) (e6 = s5[r4]).left || (i5 = e6.otherPos, e6.otherPos = e6.otherEvent.otherPos, e6.otherEvent.otherPos = i5);
                return s5;
              }(t5), i4 = {}, s4 = [], o4 = function() {
                if (!i4[e5]) {
                  var t6 = s4.length, r4 = function(t7, e6, r5) {
                    var n5 = new O2();
                    if (null != t7.prevInResult) {
                      var i5 = t7.prevInResult, s5 = i5.outputContourId;
                      if (i5.resultTransition > 0) {
                        var o6 = e6[s5];
                        if (null != o6.holeOf) {
                          var a5 = o6.holeOf;
                          e6[a5].holeIds.push(r5), n5.holeOf = a5, n5.depth = e6[s5].depth;
                        } else e6[s5].holeIds.push(r5), n5.holeOf = s5, n5.depth = e6[s5].depth + 1;
                      } else n5.holeOf = null, n5.depth = e6[s5].depth;
                    } else n5.holeOf = null, n5.depth = 0;
                    return n5;
                  }(n4[e5], s4, t6), o5 = function(e6) {
                    i4[e6] = true, e6 < n4.length && n4[e6] && (n4[e6].outputContourId = t6);
                  }, a4 = e5, l4 = e5;
                  for (r4.points.push(n4[e5].point); o5(a4), o5(a4 = n4[a4].otherPos), r4.points.push(n4[a4].point), !((a4 = U22(a4, n4, i4, l4)) == l4 || a4 >= n4.length) && n4[a4]; ) ;
                  s4.push(r4);
                }
              };
              for (e5 = 0, r3 = n4.length; e5 < r3; e5++) o4();
              return s4;
            }(function(t5, e5, n4, i4, s4, o4) {
              for (var a4, l4, u4, h3 = new r22(R22), f3 = [], m4 = Math.min(i4[2], s4[2]); 0 !== t5.length; ) {
                var y4 = t5.pop();
                if (f3.push(y4), o4 === c22 && y4.point[0] > m4 || o4 === p22 && y4.point[0] > i4[2]) break;
                if (y4.left) {
                  l4 = a4 = h3.insert(y4), a4 = a4 !== (u4 = h3.minNode()) ? h3.prev(a4) : null, l4 = h3.next(l4);
                  var g4 = a4 ? a4.key : null;
                  if (d22(y4, g4, o4), l4 && 2 === L22(y4, l4.key, t5) && (d22(y4, g4, o4), d22(l4.key, y4, o4)), a4 && 2 === L22(a4.key, y4, t5)) {
                    var x4 = a4;
                    d22(g4, (x4 = x4 !== u4 ? h3.prev(x4) : null) ? x4.key : null, o4), d22(y4, g4, o4);
                  }
                } else l4 = a4 = h3.find(y4 = y4.otherEvent), a4 && l4 && (a4 = a4 !== u4 ? h3.prev(a4) : null, l4 = h3.next(l4), h3.remove(y4), l4 && a4 && L22(a4.key, l4.key, t5));
              }
              return f3;
            }(a3, 0, 0, s3, o3, n3)), u3 = [], m3 = 0; m3 < l3.length; m3++) {
              var y3 = l3[m3];
              if (y3.isExterior()) {
                for (var g3 = [y3.points], x3 = 0; x3 < y3.holeIds.length; x3++) g3.push(l3[y3.holeIds[x3]].points);
                u3.push(g3);
              }
            }
            return u3;
          }
          var K22 = { UNION: h22, DIFFERENCE: p22, INTERSECTION: c22, XOR: f22 };
          t3.diff = function(t4, e4) {
            return Y2(t4, e4, p22);
          }, t3.intersection = function(t4, e4) {
            return Y2(t4, e4, c22);
          }, t3.operations = K22, t3.union = function(t4, e4) {
            return Y2(t4, e4, h22);
          }, t3.xor = function(t4, e4) {
            return Y2(t4, e4, f22);
          }, Object.defineProperty(t3, "__esModule", { value: true });
        }(e22);
      }(0, ip.exports)), ip.exports);
      /**
       * martinez v0.7.4
       * Martinez polygon clipping algorithm, does boolean operation on polygons (multipolygons, polygons with holes etc): intersection, union, difference, xor
       *
       * @author Alex Milevski <info@w8r.name>
       * @license MIT
       * @preserve
       */
      function op(t22, e22, r22, n22) {
        const i22 = [], s2 = 0 === n22 ? (t3, e3, r3, n3, i3, s3) => {
          t3.push(new bt(s3, r3 + (s3 - e3) / (n3 - e3) * (i3 - r3)));
        } : (t3, e3, r3, n3, i3, s3) => {
          t3.push(new bt(e3 + (s3 - r3) / (i3 - r3) * (n3 - e3), s3));
        };
        for (const o2 of t22) {
          const t3 = [];
          for (const i3 of o2) {
            if (i3.length <= 2) continue;
            const o3 = [];
            for (let t4 = 0; t4 < i3.length - 1; t4++) {
              const a3 = i3[t4].x, l3 = i3[t4].y, u22 = i3[t4 + 1].x, c22 = i3[t4 + 1].y, h22 = 0 === n22 ? a3 : l3, p22 = 0 === n22 ? u22 : c22;
              h22 < e22 ? p22 > e22 && s2(o3, a3, l3, u22, c22, e22) : h22 > r22 ? p22 < r22 && s2(o3, a3, l3, u22, c22, r22) : o3.push(i3[t4]), p22 < e22 && h22 >= e22 && s2(o3, a3, l3, u22, c22, e22), p22 > r22 && h22 <= r22 && s2(o3, a3, l3, u22, c22, r22);
            }
            let a22 = i3[i3.length - 1];
            const l22 = 0 === n22 ? a22.x : a22.y;
            l22 >= e22 && l22 <= r22 && o3.push(a22), o3.length && (a22 = o3[o3.length - 1], o3[0].x === a22.x && o3[0].y === a22.y || o3.push(o3[0]), t3.push(o3));
          }
          t3.length && i22.push(t3);
        }
        return i22;
      }
      function ap(t22, e22) {
        const r22 = up(t22), n22 = up([e22]), i22 = sp.intersection(r22, n22);
        return null == i22 ? [] : cp(i22);
      }
      function lp(t22, e22) {
        const r22 = 65536;
        let n22 = up(t22, r22);
        for (; e22.valid(); e22.next()) {
          const [t3, i22] = e22.get(), s2 = t3.x * r22, o2 = t3.y * r22, a22 = i22.x * r22, l22 = i22.y * r22, u22 = a22 - s2, c22 = l22 - o2, h22 = Math.hypot(u22, c22), p22 = Math.trunc(c22 / h22 * 3), f22 = -Math.trunc(u22 / h22 * 3);
          n22 = sp.diff(n22, [[[s2, o2], [a22, l22], [a22 + p22, l22 + f22], [s2 + p22, o2 + f22], [s2, o2]]]);
        }
        return cp(n22, 1 / r22);
      }
      function up(t22, e22 = 1) {
        return [t22.map((t3) => t3.map((t4) => [t4.x * e22, t4.y * e22]))];
      }
      function cp(t22, e22 = 1) {
        return t22.map((t3) => t3.map((t4, r22) => {
          const n22 = t4.map((t5) => new bt(t5[0] * e22, t5[1] * e22).round());
          return r22 > 0 && n22.reverse(), n22;
        }));
      }
      class hp {
        constructor(t22, e22) {
          this.layoutVertexArray = new ea(), this.indexArray = new wa(), this.lineIndexArray = new ga(), this.triangleSegments = new Ka(), this.lineSegments = new Ka(), this.programConfigurations = new Il(t22.layers, { zoom: t22.zoom, lut: t22.lut }), this.uploaded = false, e22 && (this.elevatedLayoutVertexArray = new ia());
        }
        update(t22, e22, r22, n22, i22, s2, o2) {
          this.programConfigurations.updatePaintArrays(t22, e22, i22, r22, n22, s2, o2);
        }
        isEmpty() {
          return 0 === this.layoutVertexArray.length;
        }
        needsUpload() {
          return this.programConfigurations.needsUpload;
        }
        upload(t22) {
          this.uploaded || (this.layoutVertexBuffer = t22.createVertexBuffer(this.layoutVertexArray, Wc.members), this.indexBuffer = t22.createIndexBuffer(this.indexArray), this.lineIndexBuffer = t22.createIndexBuffer(this.lineIndexArray), this.elevatedLayoutVertexArray && this.elevatedLayoutVertexArray.length > 0 && (this.elevatedLayoutVertexBuffer = t22.createVertexBuffer(this.elevatedLayoutVertexArray, Yc.members))), this.programConfigurations.upload(t22), this.uploaded = true;
        }
        destroy() {
          this.layoutVertexBuffer && (this.elevatedLayoutVertexBuffer && this.elevatedLayoutVertexBuffer.destroy(), this.layoutVertexBuffer.destroy(), this.indexBuffer.destroy(), this.lineIndexBuffer.destroy(), this.programConfigurations.destroy(), this.triangleSegments.destroy(), this.lineSegments.destroy());
        }
        populatePaintArrays(t22, e22, r22, n22, i22, s2) {
          this.programConfigurations.populatePaintArrays(this.layoutVertexArray.length, t22, e22, r22, n22, i22, s2);
        }
      }
      class pp {
        constructor(t22) {
          this.zoom = t22.zoom, this.pixelRatio = t22.pixelRatio, this.overscaling = t22.overscaling, this.layers = t22.layers, this.layerIds = this.layers.map((t3) => t3.fqid), this.index = t22.index, this.hasPattern = false, this.patternFeatures = [], this.bufferData = new hp(t22, false), this.elevationBufferData = new hp(t22, true), this.stateDependentLayerIds = this.layers.filter((t3) => t3.isStateDependent()).map((t3) => t3.id), this.projection = t22.projection, this.elevationMode = this.layers[0].layout.get("fill-elevation-reference");
        }
        updateFootprints(t22, e22) {
        }
        populate(t22, e22, r22, n22) {
          this.hasPattern = kh("fill", this.layers, this.pixelRatio, e22);
          const i22 = this.layers[0].layout.get("fill-sort-key"), s2 = [];
          for (const { feature: o2, id: a22, index: l22, sourceLayerIndex: u22 } of t22) {
            const t3 = this.layers[0]._featureFilter.needGeometry, c22 = du(o2, t3);
            if (!this.layers[0]._featureFilter.filter(new yo(this.zoom), c22, r22)) continue;
            const h22 = i22 ? i22.evaluate(c22, {}, r22, e22.availableImages) : void 0, p22 = { id: a22, properties: o2.properties, type: o2.type, sourceLayerIndex: u22, index: l22, geometry: t3 ? c22.geometry : fu(o2, r22, n22), patterns: {}, sortKey: h22 };
            s2.push(p22);
          }
          i22 && s2.sort((t3, e3) => t3.sortKey - e3.sortKey);
          for (const n3 of s2) {
            const { geometry: i3, index: s3, sourceLayerIndex: o2 } = n3;
            if (this.hasPattern) {
              const t3 = Eh("fill", this.layers, n3, this.zoom, this.pixelRatio, e22);
              this.patternFeatures.push(t3);
            } else this.addFeature(n3, i3, s3, r22, {}, e22.availableImages, e22.brightness, e22.elevationFeatures);
            e22.featureIndex.insert(t22[s3].feature, i3, s3, o2, this.index);
          }
        }
        update(t22, e22, r22, n22, i22, s2, o2) {
          this.bufferData.update(t22, e22, r22, n22, i22, s2, o2), this.elevationBufferData.update(t22, e22, r22, n22, i22, s2, o2);
        }
        addFeatures(t22, e22, r22, n22, i22, s2) {
          for (const i3 of this.patternFeatures) this.addFeature(i3, i3.geometry, i3.index, e22, r22, n22, s2, t22.elevationFeatures);
        }
        isEmpty() {
          return this.bufferData.isEmpty() && this.elevationBufferData.isEmpty();
        }
        uploadPending() {
          return !this.uploaded || this.bufferData.needsUpload() || this.elevationBufferData.needsUpload();
        }
        upload(t22) {
          this.bufferData.upload(t22), this.elevationBufferData.upload(t22), this.elevatedStructures && this.elevatedStructures.upload(t22);
        }
        destroy() {
          this.bufferData.destroy(), this.elevationBufferData.destroy(), this.elevatedStructures && this.elevatedStructures.destroy();
        }
        addFeature(t22, e22, r22, n22, i22, s2 = [], o2, a22) {
          const l22 = Ih(e22, 500);
          "none" !== this.elevationMode ? this.addElevatedRoadFeature(t22, l22, n22, r22, a22) : this.addGeometry(l22, this.bufferData), this.bufferData.populatePaintArrays(t22, r22, i22, s2, n22, o2), this.elevationBufferData.populatePaintArrays(t22, r22, i22, s2, n22, o2);
        }
        getUnevaluatedPortalGraph() {
          return this.elevatedStructures ? this.elevatedStructures.unevaluatedPortals : void 0;
        }
        getElevationPolygons() {
          return this.elevatedStructures ? this.elevatedStructures.portalPolygons : void 0;
        }
        setEvaluatedPortalGraph(t22) {
          this.elevatedStructures && this.elevatedStructures.construct(t22);
        }
        addElevatedRoadFeature(t22, e22, r22, n22, i22) {
          const s2 = new Array(), o2 = Kh.getElevationFeature(t22, i22);
          if (o2) {
            {
              const t3 = this.clipPolygonsToTile(e22, 1);
              t3.length > 0 && s2.push({ polygons: t3, elevationFeature: o2, elevationTileID: r22 });
            }
            for (const e3 of s2) if (e3.elevationFeature) {
              if ("hd-road-base" === this.elevationMode) {
                this.elevatedStructures || (this.elevatedStructures = new rp(e3.elevationTileID));
                const r3 = e3.elevationFeature.isTunnel();
                let n3 = 0;
                t22.properties.hasOwnProperty($h) && (n3 = +t22.properties[$h]);
                for (const t3 of e3.polygons) this.elevatedStructures.addPortalCandidates(e3.elevationFeature.id, t3, r3, e3.elevationFeature, n3);
              }
              null == e3.elevationFeature.constantHeight && (e3.polygons = this.prepareElevatedPolygons(e3.polygons, e3.elevationFeature, e3.elevationTileID));
              const i3 = new Jh(r22, e3.elevationTileID);
              this.addElevatedGeometry(e3.polygons, i3, e3.elevationFeature, "hd-road-base" === this.elevationMode ? 0 : 0.05, n22);
            }
          } else this.addGeometry(e22, this.bufferData);
        }
        addElevatedGeometry(t22, e22, r22, n22, i22) {
          const s2 = { elevation: r22, elevationSampler: e22, bias: n22, index: i22 }, [o2, a22] = this.addGeometry(t22, this.elevationBufferData, s2);
          null == this.elevationBufferData.heightRange ? this.elevationBufferData.heightRange = { min: o2, max: a22 } : (this.elevationBufferData.heightRange.min = Math.min(this.elevationBufferData.heightRange.min, o2), this.elevationBufferData.heightRange.max = Math.max(this.elevationBufferData.heightRange.max, a22));
        }
        addGeometry(t22, e22, r22) {
          let n22 = Number.POSITIVE_INFINITY, i22 = Number.NEGATIVE_INFINITY, s2 = null;
          r22 && (s2 = r22.elevationSampler.constantElevation(r22.elevation, r22.bias), null != s2 && (n22 = s2, i22 = s2));
          const o2 = (t3, o3, a22) => {
            if (null != r22) if (o3.push(t3), null != s2) e22.elevatedLayoutVertexArray.emplaceBack(s2), a22.push(s2);
            else {
              const s3 = r22.elevationSampler.pointElevation(t3, r22.elevation, r22.bias);
              e22.elevatedLayoutVertexArray.emplaceBack(s3), a22.push(s3), n22 = Math.min(n22, s3), i22 = Math.max(i22, s3);
            }
          };
          for (const n3 of t22) {
            let t3 = 0;
            for (const e3 of n3) t3 += e3.length;
            const i3 = e22.triangleSegments.prepareSegment(t3, e22.layoutVertexArray, e22.indexArray), s3 = i3.vertexLength, a22 = [], l22 = [], u22 = [], c22 = [], h22 = [], p22 = e22.layoutVertexArray.length;
            for (const t4 of n3) {
              if (0 === t4.length) continue;
              t4 !== n3[0] && l22.push(a22.length / 2);
              const i4 = e22.lineSegments.prepareSegment(t4.length, e22.layoutVertexArray, e22.lineIndexArray), s4 = i4.vertexLength;
              r22 && h22.push(e22.layoutVertexArray.length - p22), o2(t4[0], u22, c22), e22.layoutVertexArray.emplaceBack(t4[0].x, t4[0].y), e22.lineIndexArray.emplaceBack(s4 + t4.length - 1, s4), a22.push(t4[0].x), a22.push(t4[0].y);
              for (let r3 = 1; r3 < t4.length; r3++) o2(t4[r3], u22, c22), e22.layoutVertexArray.emplaceBack(t4[r3].x, t4[r3].y), e22.lineIndexArray.emplaceBack(s4 + r3 - 1, s4 + r3), a22.push(t4[r3].x), a22.push(t4[r3].y);
              i4.vertexLength += t4.length, i4.primitiveLength += t4.length;
            }
            const f22 = Qc(a22, l22);
            for (let t4 = 0; t4 < f22.length; t4 += 3) e22.indexArray.emplaceBack(s3 + f22[t4], s3 + f22[t4 + 1], s3 + f22[t4 + 2]);
            if (f22.length > 0 && r22 && "hd-road-base" === this.elevationMode) {
              const t4 = r22.elevation.isTunnel(), e3 = r22.elevation.safeArea, n4 = this.elevatedStructures.addVertices(u22, c22);
              this.elevatedStructures.addTriangles(f22, n4, t4);
              const i4 = h22.length;
              if (i4 > 0) {
                for (let s4 = 0; s4 < i4 - 1; s4++) this.elevatedStructures.addRenderableRing(r22.index, h22[s4] + n4, h22[s4 + 1] - h22[s4], t4, e3);
                this.elevatedStructures.addRenderableRing(r22.index, h22[i4 - 1] + n4, u22.length - h22[i4 - 1], t4, e3);
              }
            }
            i3.vertexLength += t3, i3.primitiveLength += f22.length / 3;
          }
          return [n22, i22];
        }
        prepareElevatedPolygons(t22, e22, r22) {
          const n22 = 1 / iu(r22), i22 = [];
          for (const r3 of t22) {
            const t3 = lp(r3, new Wh(e22, n22));
            i22.push(...t3);
          }
          return i22;
        }
        clipPolygonsToTile(t22, e22) {
          const r22 = -e22, n22 = -e22, i22 = Tn + e22, s2 = Tn + e22;
          let o2 = 0;
          const a22 = [], l22 = [];
          for (; o2 < t22.length; o2++) {
            const e3 = t22[o2], u3 = un(e3);
            (u3.min.x >= r22 && u3.max.x <= i22 && u3.min.y >= n22 && u3.max.y <= s2 ? a22 : l22).push(e3);
          }
          if (a22.length === t22.length) return t22;
          const u22 = [new bt(r22, n22), new bt(i22, n22), new bt(i22, s2), new bt(r22, s2), new bt(r22, n22)], c22 = a22;
          for (const t3 of l22) c22.push(...ap(t3, u22));
          return c22;
        }
      }
      let fp, dp, mp, yp;
      js(pp, "FillBucket", { omit: ["layers", "patternFeatures"] }), js(hp, "FillBufferData"), js(rp, "ElevatedStructures");
      class gp {
        constructor(t22, e22, r22, n22) {
          if (this.triangleCount = e22.length / 3, this.min = new bt(0, 0), this.max = new bt(0, 0), this.xScale = 0, this.yScale = 0, this.cellsX = 0, this.cellsY = 0, this.cells = [], this.payload = [], 0 === this.triangleCount || 0 === t22.length) return;
          const [i22, s2] = [t22[0].clone(), t22[0].clone()];
          for (let e3 = 1; e3 < t22.length; ++e3) {
            const r3 = t22[e3];
            i22.x = Math.min(i22.x, r3.x), i22.y = Math.min(i22.y, r3.y), s2.x = Math.max(s2.x, r3.x), s2.y = Math.max(s2.y, r3.y);
          }
          if (n22) {
            const t3 = Math.ceil(Math.max(s2.x - i22.x, s2.y - i22.y) / n22);
            r22 = Math.max(r22, t3);
          }
          if (0 === r22) return;
          this.min = i22, this.max = s2;
          const o2 = this.max.sub(this.min);
          o2.x = Math.max(o2.x, 1), o2.y = Math.max(o2.y, 1);
          const a22 = Math.max(o2.x, o2.y) / r22;
          this.cellsX = Math.max(1, Math.ceil(o2.x / a22)), this.cellsY = Math.max(1, Math.ceil(o2.y / a22)), this.xScale = 1 / a22, this.yScale = 1 / a22;
          const l22 = [];
          for (let r3 = 0; r3 < this.triangleCount; r3++) {
            const n3 = t22[e22[3 * r3 + 0]].sub(this.min), i3 = t22[e22[3 * r3 + 1]].sub(this.min), s3 = t22[e22[3 * r3 + 2]].sub(this.min), o3 = xp(Math.floor(Math.min(n3.x, i3.x, s3.x)), this.xScale, this.cellsX), u3 = xp(Math.floor(Math.max(n3.x, i3.x, s3.x)), this.xScale, this.cellsX), c22 = xp(Math.floor(Math.min(n3.y, i3.y, s3.y)), this.yScale, this.cellsY), h22 = xp(Math.floor(Math.max(n3.y, i3.y, s3.y)), this.yScale, this.cellsY), p22 = new bt(0, 0), f22 = new bt(0, 0), d22 = new bt(0, 0), m22 = new bt(0, 0);
            for (let t3 = c22; t3 <= h22; ++t3) {
              p22.y = f22.y = t3 * a22, d22.y = m22.y = (t3 + 1) * a22;
              for (let e3 = o3; e3 <= u3; ++e3) p22.x = d22.x = e3 * a22, f22.x = m22.x = (e3 + 1) * a22, (Vu(n3, i3, s3, p22, f22, m22) || Vu(n3, i3, s3, p22, m22, d22)) && l22.push({ cellIdx: t3 * this.cellsX + e3, triIdx: r3 });
            }
          }
          if (0 === l22.length) return;
          l22.sort((t3, e3) => t3.cellIdx - e3.cellIdx || t3.triIdx - e3.triIdx);
          let u22 = 0;
          for (; u22 < l22.length; ) {
            const t3 = l22[u22].cellIdx, e3 = { start: this.payload.length, len: 0 };
            for (; u22 < l22.length && l22[u22].cellIdx === t3; ) ++e3.len, this.payload.push(l22[u22++].triIdx);
            this.cells[t3] = e3;
          }
        }
        _lazyInitLookup() {
          this.lookup || (this.lookup = new Uint8Array(Math.ceil(this.triangleCount / 8))), this.lookup.fill(0);
        }
        queryPoint(t22, e22) {
          if (0 === this.triangleCount || 0 === this.cells.length) return;
          if (t22.x > this.max.x || this.min.x > t22.x || t22.y > this.max.y || this.min.y > t22.y) return;
          const r22 = xp(t22.x - this.min.x, this.xScale, this.cellsX), n22 = xp(t22.y - this.min.y, this.yScale, this.cellsY), i22 = this.cells[n22 * this.cellsX + r22];
          if (i22) {
            this._lazyInitLookup();
            for (let t3 = 0; t3 < i22.len; t3++) {
              const r3 = this.payload[i22.start + t3], n3 = Math.floor(r3 / 8), s2 = 1 << r3 % 8;
              if (!(this.lookup[n3] & s2) && (this.lookup[n3] |= s2, e22.push(r3), e22.length === this.triangleCount)) return;
            }
          }
        }
        query(t22, e22, r22) {
          if (0 === this.triangleCount || 0 === this.cells.length) return;
          if (t22.x > this.max.x || this.min.x > e22.x) return;
          if (t22.y > this.max.y || this.min.y > e22.y) return;
          this._lazyInitLookup();
          const n22 = xp(t22.x - this.min.x, this.xScale, this.cellsX), i22 = xp(e22.x - this.min.x, this.xScale, this.cellsX), s2 = xp(t22.y - this.min.y, this.yScale, this.cellsY), o2 = xp(e22.y - this.min.y, this.yScale, this.cellsY);
          for (let t3 = s2; t3 <= o2; t3++) for (let e3 = n22; e3 <= i22; e3++) {
            const n3 = this.cells[t3 * this.cellsX + e3];
            if (n3) for (let t4 = 0; t4 < n3.len; t4++) {
              const e4 = this.payload[n3.start + t4], i3 = Math.floor(e4 / 8), s3 = 1 << e4 % 8;
              if (!(this.lookup[i3] & s3) && (this.lookup[i3] |= s3, r22.push(e4), r22.length === this.triangleCount)) return;
            }
          }
        }
      }
      function xp(t22, e22, r22) {
        return Math.max(0, Math.min(r22 - 1, Math.floor(t22 * e22)));
      }
      js(gp, "TriangleGridIndex");
      class vp {
        constructor(t22) {
          this.zoom = t22.zoom, this.layers = t22.layers, this.layerIds = this.layers.map((t3) => t3.fqid), this.index = t22.index, this.hasPattern = false, this.stateDependentLayerIds = this.layers.filter((t3) => t3.isStateDependent()).map((t3) => t3.id), this.footprints = [];
        }
        updateFootprints(t22, e22) {
          for (const r22 of this.footprints) e22.push({ footprint: r22, id: t22 });
        }
        populate(t22, e22, r22, n22) {
          const i22 = [];
          for (const { feature: e3, id: s2, index: o2, sourceLayerIndex: a22 } of t22) {
            const t3 = this.layers[0]._featureFilter.needGeometry, l22 = du(e3, t3);
            if (!this.layers[0]._featureFilter.filter(new yo(this.zoom), l22, r22)) continue;
            const u22 = { id: s2, properties: e3.properties, type: e3.type, sourceLayerIndex: a22, index: o2, geometry: t3 ? l22.geometry : fu(e3, r22, n22), patterns: {} };
            i22.push(u22);
          }
          for (const n3 of i22) {
            const { geometry: i3, index: s2, sourceLayerIndex: o2 } = n3;
            this.addFeature(n3, i3, s2, r22, {}, e22.availableImages, e22.brightness), e22.featureIndex.insert(t22[s2].feature, i3, s2, o2, this.index);
          }
        }
        isEmpty() {
          return 0 === this.footprints.length;
        }
        uploadPending() {
          return false;
        }
        upload(t22) {
        }
        update(t22, e22, r22, n22, i22, s2, o2) {
        }
        destroy() {
        }
        addFeature(t22, e22, r22, n22, i22, s2 = [], o2) {
          for (const t3 of Ih(e22, 2)) {
            const e3 = [], r3 = [], n3 = [], i3 = new bt(1 / 0, 1 / 0), s3 = new bt(-1 / 0, -1 / 0);
            for (const o4 of t3) if (0 !== o4.length) {
              o4 !== t3[0] && n3.push(r3.length / 2);
              for (let t4 = 0; t4 < o4.length; t4++) r3.push(o4[t4].x), r3.push(o4[t4].y), e3.push(o4[t4]), i3.x = Math.min(i3.x, o4[t4].x), i3.y = Math.min(i3.y, o4[t4].y), s3.x = Math.max(s3.x, o4[t4].x), s3.y = Math.max(s3.y, o4[t4].y);
            }
            const o3 = Qc(r3, n3), a22 = new gp(e3, o3, 8, 256);
            this.footprints.push({ vertices: e3, indices: o3, grid: a22, min: i3, max: s3 });
          }
        }
      }
      js(vp, "ClipBucket", { omit: ["layers"] });
      const bp = Qo([{ name: "a_pos_normal_ed", components: 4, type: "Int16" }]), _p = Qo([{ name: "a_pos_end", components: 4, type: "Int16" }, { name: "a_angular_offset_factor", components: 1, type: "Int16" }]), wp = Qo([{ name: "a_centroid_pos", components: 2, type: "Uint16" }]), Ap = Qo([{ name: "a_join_normal_inside", components: 3, type: "Int16" }]), Mp = Qo([{ name: "a_hidden_by_landmark", components: 1, type: "Uint8" }]), Ip = Qo([{ name: "a_pos_3", components: 3, type: "Int16" }, { name: "a_pos_normal_3", components: 3, type: "Int16" }]), { members: Sp } = bp, zp = Number.MAX_SAFE_INTEGER;
      function kp(t22, e22, r22, n22) {
        return t22.order < e22 || t22.order === zp || !(t22.clipMask & r22) || function(t3, e3) {
          return 0 !== e3.length && void 0 === e3.find((e4) => e4 === t3);
        }(n22, t22.clipScope);
      }
      function Ep(t22, e22) {
        return t22.x - e22.x || t22.y - e22.y;
      }
      function Pp(t22, e22) {
        return 0 === Ep(t22.min, e22.min) && 0 === Ep(t22.max, e22.max);
      }
      function Tp(t22, e22) {
        return !(t22.min.x > e22.max.x || t22.max.x < e22.min.x || t22.min.y > e22.max.y || t22.max.y < e22.min.y);
      }
      function Bp(t22, e22) {
        if (t22.length !== e22.length) return false;
        for (let r22 = 0; r22 < t22.length; r22++) if (t22[r22].sourceId !== e22[r22].sourceId || !Pp(t22[r22], e22[r22]) || t22[r22].order !== e22[r22].order || t22[r22].clipMask !== e22[r22].clipMask || !_t2(t22[r22].clipScope, e22[r22].clipScope)) return false;
        return true;
      }
      function Vp(t22, e22, r22) {
        const n22 = 1 / Tn, i22 = 1 / (1 << r22.canonical.z), s2 = (e22.x * n22 + r22.canonical.x) * i22 + r22.wrap, o2 = (e22.y * n22 + r22.canonical.y) * i22;
        return { min: new bt((t22.x * n22 + r22.canonical.x) * i22 + r22.wrap, (t22.y * n22 + r22.canonical.y) * i22), max: new bt(s2, o2) };
      }
      function Cp(t22, e22, r22) {
        const n22 = 1 << r22.canonical.z, i22 = ((e22.x - r22.wrap) * n22 - r22.canonical.x) * Tn, s2 = (e22.y * n22 - r22.canonical.y) * Tn;
        return { min: new bt(((t22.x - r22.wrap) * n22 - r22.canonical.x) * Tn, (t22.y * n22 - r22.canonical.y) * Tn), max: new bt(i22, s2) };
      }
      function Dp(t22, e22, r22, n22, i22, s2, o2) {
        const a22 = t22.indices, l22 = t22.vertices, u22 = [];
        for (let c22 = n22; c22 < n22 + i22; c22 += 3) {
          const n3 = e22[r22[c22 + 0] + s2], i3 = e22[r22[c22 + 1] + s2], h22 = e22[r22[c22 + 2] + s2], p22 = Math.min(n3.x, i3.x, h22.x), f22 = Math.max(n3.x, i3.x, h22.x), d22 = Math.min(n3.y, i3.y, h22.y), m22 = Math.max(n3.y, i3.y, h22.y);
          u22.length = 0, t22.grid.query(new bt(p22, d22), new bt(f22, m22), u22);
          for (let t3 = 0; t3 < u22.length; t3++) {
            const e3 = u22[t3];
            if (Vu(l22[a22[3 * e3 + 0]], l22[a22[3 * e3 + 1]], l22[a22[3 * e3 + 2]], n3, i3, h22, o2)) return true;
          }
        }
        return false;
      }
      function Fp(t22, e22, r22, n22) {
        if (!t22 || !r22) return false;
        let i22 = t22.vertices;
        if (!e22.canonical.equals(n22.canonical) || e22.wrap !== n22.wrap) {
          if (r22.vertices.length < t22.vertices.length) return Fp(r22, n22, t22, e22);
          const s2 = e22.canonical, o2 = n22.canonical, a22 = Math.pow(2, o2.z - s2.z);
          i22 = t22.vertices.map((t3) => new bt((t3.x + s2.x * Tn) * a22 - o2.x * Tn, (t3.y + s2.y * Tn) * a22 - o2.y * Tn));
        }
        return Dp(r22, i22, t22.indices, 0, t22.indices.length, 0, 0);
      }
      function Lp(t22, e22, r22, n22) {
        const i22 = Math.pow(2, n22.z - r22.z);
        return new bt((t22 + r22.x * Tn) * i22 - n22.x * Tn, (e22 + r22.y * Tn) * i22 - n22.y * Tn);
      }
      function Rp(t22, e22) {
        const r22 = [];
        e22.grid.queryPoint(t22, r22);
        const n22 = e22.indices, i22 = e22.vertices;
        for (let e3 = 0; e3 < r22.length; e3++) {
          const s2 = r22[e3];
          if (Eu([i22[n22[3 * s2 + 0]], i22[n22[3 * s2 + 1]], i22[n22[3 * s2 + 2]]], t22)) return true;
        }
        return false;
      }
      const Op = [new bt(0, 0), new bt(Tn, 0), new bt(Tn, Tn), new bt(0, Tn)];
      function Up(t22, e22) {
        const r22 = [];
        let n22 = [];
        if (!e22 || t22.length < 2) return [t22];
        if (2 === t22.length) return Tu(t22[0], t22[1], Op) ? [t22] : [];
        for (let e3 = 0; e3 < t22.length + 2; e3++) {
          const i22 = t22[e3 % t22.length], s2 = t22[(e3 + 1) % t22.length], o2 = Tu(0 === e3 ? t22[t22.length - 1] : t22[(e3 - 1) % t22.length], i22, Op), a22 = Tu(i22, s2, Op), l22 = o2 || a22;
          l22 && n22.push(i22), l22 && a22 || n22.length > 0 && (n22.length > 1 && r22.push(n22), n22 = []);
        }
        return n22.length > 1 && r22.push(n22), r22;
      }
      const Np = Nh.VectorTileFeature.types, jp = ["fill-extrusion-base", "fill-extrusion-height", "fill-extrusion-color", "fill-extrusion-pattern", "fill-extrusion-flood-light-wall-radius", "fill-extrusion-line-width", "fill-extrusion-emissive-strength"], $p = ["fill-extrusion-flood-light-ground-radius"], Gp = Math.pow(2, 13), qp = Math.pow(2, 15) - 1, Hp = new bt(0, 1), Xp = 2147483648;
      function Zp(t22, e22, r22, n22, i22, s2, o2, a22) {
        t22.emplaceBack((e22 << 1) + o2, (r22 << 1) + s2, (Math.floor(n22 * Gp) << 1) + i22, Math.round(a22));
      }
      function Wp(t22, e22, r22) {
        t22.emplaceBack(e22.x * Tn, e22.y * Tn, r22 ? 1 : 0);
      }
      function Yp(t22, e22, r22, n22, i22, s2) {
        t22.emplaceBack(e22.x, e22.y, (r22.x << 1) + n22, (r22.y << 1) + i22, s2);
      }
      function Kp(t22, e22, r22) {
        const n22 = 16384;
        t22.emplaceBack(e22.x, e22.y, e22.z, r22[0] * n22, r22[1] * n22, r22[2] * n22);
      }
      class Jp {
        constructor() {
          this.vertexOffset = 0, this.vertexCount = 0, this.indexOffset = 0, this.indexCount = 0;
        }
      }
      class Qp {
        constructor() {
          this.centroidXY = new bt(0, 0), this.vertexArrayOffset = 0, this.vertexCount = 0, this.groundVertexArrayOffset = 0, this.groundVertexCount = 0, this.flags = 0, this.footprintSegIdx = -1, this.footprintSegLen = 0, this.polygonSegIdx = -1, this.polygonSegLen = 0, this.min = new bt(Number.MAX_VALUE, Number.MAX_VALUE), this.max = new bt(-Number.MAX_VALUE, -Number.MAX_VALUE), this.height = 0;
        }
        span() {
          return new bt(this.max.x - this.min.x, this.max.y - this.min.y);
        }
      }
      class tf {
        constructor() {
          this.acc = new bt(0, 0), this.accCount = 0, this.centroidDataIndex = 0;
        }
        startRing(t22, e22) {
          t22.min.x === Number.MAX_VALUE && (t22.min.x = t22.max.x = e22.x, t22.min.y = t22.max.y = e22.y);
        }
        appendEdge(t22, e22, r22) {
          this.accCount++, this.acc._add(e22);
          let n22 = !!this.borders;
          e22.x < t22.min.x ? (t22.min.x = e22.x, n22 = true) : e22.x > t22.max.x && (t22.max.x = e22.x, n22 = true), e22.y < t22.min.y ? (t22.min.y = e22.y, n22 = true) : e22.y > t22.max.y && (t22.max.y = e22.y, n22 = true), ((0 === e22.x || e22.x === Tn) && e22.x === r22.x) != ((0 === e22.y || e22.y === Tn) && e22.y === r22.y) && this.processBorderOverlap(e22, r22), n22 && this.checkBorderIntersection(e22, r22);
        }
        checkBorderIntersection(t22, e22) {
          e22.x < 0 != t22.x < 0 && this.addBorderIntersection(0, or(e22.y, t22.y, (0 - e22.x) / (t22.x - e22.x))), e22.x > Tn != t22.x > Tn && this.addBorderIntersection(1, or(e22.y, t22.y, (Tn - e22.x) / (t22.x - e22.x))), e22.y < 0 != t22.y < 0 && this.addBorderIntersection(2, or(e22.x, t22.x, (0 - e22.y) / (t22.y - e22.y))), e22.y > Tn != t22.y > Tn && this.addBorderIntersection(3, or(e22.x, t22.x, (Tn - e22.y) / (t22.y - e22.y)));
        }
        addBorderIntersection(t22, e22) {
          this.borders || (this.borders = [[Number.MAX_VALUE, -Number.MAX_VALUE], [Number.MAX_VALUE, -Number.MAX_VALUE], [Number.MAX_VALUE, -Number.MAX_VALUE], [Number.MAX_VALUE, -Number.MAX_VALUE]]);
          const r22 = this.borders[t22];
          e22 < r22[0] && (r22[0] = e22), e22 > r22[1] && (r22[1] = e22);
        }
        processBorderOverlap(t22, e22) {
          if (t22.x === e22.x) {
            if (t22.y === e22.y) return;
            const r22 = 0 === t22.x ? 0 : 1;
            this.addBorderIntersection(r22, e22.y), this.addBorderIntersection(r22, t22.y);
          } else {
            const r22 = 0 === t22.y ? 2 : 3;
            this.addBorderIntersection(r22, e22.x), this.addBorderIntersection(r22, t22.x);
          }
        }
        centroid() {
          return 0 === this.accCount ? new bt(0, 0) : new bt(Math.floor(Math.max(0, this.acc.x) / this.accCount), Math.floor(Math.max(0, this.acc.y) / this.accCount));
        }
        intersectsCount() {
          return this.borders ? this.borders.reduce((t22, e22) => t22 + +(e22[0] !== Number.MAX_VALUE), 0) : 0;
        }
      }
      function ef(t22, e22) {
        const r22 = t22.add(e22)._unit(), n22 = Pt(t22.x * r22.x + t22.y * r22.y, -1, 1);
        var i22, s2, o2;
        return i22 = Math.acos(n22), Math.min(4, Math.max(-4, Math.tan(i22))) / 4 * qp * ((s2 = t22).x * (o2 = e22).y - s2.y * o2.x < 0 ? -1 : 1);
      }
      const rf = [(t22) => t22.x < 0, (t22) => t22.x > Tn, (t22) => t22.y < 0, (t22) => t22.y > Tn];
      function nf(t22, e22, r22, n22) {
        const i22 = [4];
        if (0 === n22) return i22;
        r22._mult(n22);
        const s2 = t22.sub(r22), o2 = e22.sub(r22), a22 = [t22, e22, s2, o2];
        for (let t3 = 0; t3 < 4; t3++) for (const e3 of a22) if (rf[t3](e3)) {
          i22.push(t3);
          break;
        }
        return i22;
      }
      class sf {
        constructor(t22) {
          this.vertexArray = new aa(), this.indexArray = new wa(), this.programConfigurations = new Il(t22.layers, { zoom: t22.zoom, lut: t22.lut }, (t3) => $p.includes(t3)), this._segments = new Ka(), this.hiddenByLandmarkVertexArray = new Da(), this._segmentToGroundQuads = {}, this._segmentToGroundQuads[0] = [], this._segmentToRegionTriCounts = {}, this._segmentToRegionTriCounts[0] = [0, 0, 0, 0, 0], this.regionSegments = {}, this.regionSegments[4] = new Ka();
        }
        getDefaultSegment() {
          return this.regionSegments[4];
        }
        hasData() {
          return 0 !== this.vertexArray.length;
        }
        addData(t22, e22, r22, n22 = false) {
          const i22 = t22.length;
          if (i22 > 2) {
            let s2 = Math.max(0, this._segments.get().length - 1);
            const o2 = this._segments._prepareSegment(4 * i22, this.vertexArray.length, 2 * this._segmentToGroundQuads[s2].length);
            let a22;
            s2 !== this._segments.get().length - 1 && (s2++, this._segmentToGroundQuads[s2] = [], this._segmentToRegionTriCounts[s2] = [0, 0, 0, 0, 0]);
            {
              const e3 = t22[0], r3 = t22[1];
              a22 = ef(e3.sub(t22[i22 - 1])._perp()._unit(), r3.sub(e3)._perp()._unit());
            }
            for (let l22 = 0; l22 < i22; l22++) {
              const u22 = l22 === i22 - 1 ? 0 : l22 + 1, c22 = t22[l22], h22 = t22[u22], p22 = t22[u22 === i22 - 1 ? 0 : u22 + 1], f22 = h22.sub(c22)._perp()._unit(), d22 = ef(f22, p22.sub(h22)._perp()._unit()), m22 = a22, y22 = d22;
              if (cf(c22, h22, e22) || n22 && hf(c22, e22) && hf(h22, e22)) {
                a22 = d22;
                continue;
              }
              const g22 = o2.vertexLength;
              Yp(this.vertexArray, c22, h22, 1, 1, m22), Yp(this.vertexArray, c22, h22, 1, 0, m22), Yp(this.vertexArray, c22, h22, 0, 1, y22), Yp(this.vertexArray, c22, h22, 0, 0, y22), o2.vertexLength += 4;
              const x22 = nf(c22, h22, f22, r22);
              for (const t3 of x22) this._segmentToGroundQuads[s2].push({ id: g22, region: t3 }), this._segmentToRegionTriCounts[s2][t3] += 2, o2.primitiveLength += 2;
              a22 = d22;
            }
          }
        }
        prepareBorderSegments() {
          if (!this.hasData()) return;
          const t22 = this._segments.get(), e22 = t22.length;
          for (let t3 = 0; t3 < e22; t3++) this._segmentToGroundQuads[t3].sort((t4, e3) => t4.region - e3.region);
          for (let r22 = 0; r22 < e22; r22++) {
            const e3 = this._segmentToGroundQuads[r22], n22 = t22[r22], i22 = this._segmentToRegionTriCounts[r22];
            i22.reduce((t3, e4) => t3 + e4, 0);
            let s2 = 0;
            for (let t3 = 0; t3 <= 4; t3++) {
              const e4 = i22[t3];
              if (0 !== e4) {
                let r3 = this.regionSegments[t3];
                r3 || (r3 = this.regionSegments[t3] = new Ka());
                const i3 = { vertexOffset: n22.vertexOffset, primitiveOffset: n22.primitiveOffset + s2, vertexLength: n22.vertexLength, primitiveLength: e4 };
                r3.get().push(i3);
              }
              s2 += e4;
            }
            for (let t3 = 0; t3 < e3.length; t3++) {
              const r3 = e3[t3].id;
              this.indexArray.emplaceBack(r3, r3 + 1, r3 + 3), this.indexArray.emplaceBack(r3, r3 + 3, r3 + 2);
            }
          }
          this._segmentToGroundQuads = null, this._segmentToRegionTriCounts = null, this._segments.destroy(), this._segments = null;
        }
        addPaintPropertiesData(t22, e22, r22, n22, i22, s2) {
          this.hasData() && this.programConfigurations.populatePaintArrays(this.vertexArray.length, t22, e22, r22, n22, i22, s2);
        }
        upload(t22) {
          this.hasData() && (this.vertexBuffer = t22.createVertexBuffer(this.vertexArray, _p.members), this.indexBuffer = t22.createIndexBuffer(this.indexArray));
        }
        uploadPaintProperties(t22) {
          this.hasData() && this.programConfigurations.upload(t22);
        }
        update(t22, e22, r22, n22, i22, s2, o2) {
          this.hasData() && this.programConfigurations.updatePaintArrays(t22, e22, r22, n22, i22, s2, o2);
        }
        updateHiddenByLandmark(t22) {
          if (!this.hasData()) return;
          const e22 = t22.groundVertexCount + t22.groundVertexArrayOffset;
          if (0 === t22.groundVertexCount) return;
          const r22 = t22.flags & Xp ? 1 : 0;
          for (let n22 = t22.groundVertexArrayOffset; n22 < e22; ++n22) this.hiddenByLandmarkVertexArray.emplace(n22, r22);
          this._needsHiddenByLandmarkUpdate = true;
        }
        uploadHiddenByLandmark(t22) {
          this.hasData() && this._needsHiddenByLandmarkUpdate && (!this.hiddenByLandmarkVertexBuffer && this.hiddenByLandmarkVertexArray.length > 0 ? this.hiddenByLandmarkVertexBuffer = t22.createVertexBuffer(this.hiddenByLandmarkVertexArray, Mp.members, true) : this.hiddenByLandmarkVertexBuffer && this.hiddenByLandmarkVertexBuffer.updateData(this.hiddenByLandmarkVertexArray), this._needsHiddenByLandmarkUpdate = false);
        }
        destroy() {
          if (this.vertexBuffer) {
            this.vertexBuffer.destroy(), this.indexBuffer.destroy(), this.hiddenByLandmarkVertexBuffer && this.hiddenByLandmarkVertexBuffer.destroy(), this._segments && this._segments.destroy(), this.programConfigurations.destroy();
            for (let t22 = 0; t22 <= 4; t22++) {
              const e22 = this.regionSegments[t22];
              e22 && e22.destroy();
            }
          }
        }
      }
      class of {
        constructor(t22) {
          this.zoom = t22.zoom, this.canonical = t22.canonical, this.overscaling = t22.overscaling, this.layers = t22.layers, this.pixelRatio = t22.pixelRatio, this.layerIds = this.layers.map((t3) => t3.fqid), this.index = t22.index, this.hasPattern = false, this.edgeRadius = 0, this.projection = t22.projection, this.activeReplacements = [], this.replacementUpdateTime = 0, this.centroidData = [], this.footprintIndices = new wa(), this.footprintVertices = new ea(), this.footprintSegments = [], this.layoutVertexArray = new na(), this.centroidVertexArray = new Ha(), this.wallVertexArray = new Za(), this.indexArray = new wa(), this.programConfigurations = new Il(t22.layers, { zoom: t22.zoom, lut: t22.lut }, (t3) => jp.includes(t3)), this.segments = new Ka(), this.stateDependentLayerIds = this.layers.filter((t3) => t3.isStateDependent()).map((t3) => t3.id), this.groundEffect = new sf(t22), this.maxHeight = 0, this.partLookup = {}, this.triangleSubSegments = [], this.polygonSegments = [];
        }
        updateFootprints(t22, e22) {
        }
        populate(t22, e22, r22, n22) {
          this.features = [], this.hasPattern = kh("fill-extrusion", this.layers, this.pixelRatio, e22), this.featuresOnBorder = [], this.borderFeatureIndices = [[], [], [], []], this.borderDoneWithNeighborZ = [-1, -1, -1, -1], this.selfDEMTileTimestamp = Number.MAX_VALUE, this.borderDEMTileTimestamp = [Number.MAX_VALUE, Number.MAX_VALUE, Number.MAX_VALUE, Number.MAX_VALUE], this.tileToMeter = iu(r22), this.edgeRadius = this.layers[0].layout.get("fill-extrusion-edge-radius") / this.tileToMeter, this.wallMode = 0 !== this.layers[0].paint.get("fill-extrusion-line-width").constantOr(1);
          for (const { feature: i22, id: s2, index: o2, sourceLayerIndex: a22 } of t22) {
            const t3 = this.layers[0]._featureFilter.needGeometry, l22 = du(i22, t3);
            if (!this.layers[0]._featureFilter.filter(new yo(this.zoom), l22, r22)) continue;
            const u22 = { id: s2, sourceLayerIndex: a22, index: o2, geometry: t3 ? l22.geometry : fu(i22, r22, n22), properties: i22.properties, type: i22.type, patterns: {} }, c22 = this.layoutVertexArray.length, h22 = "Polygon" === Np[u22.type];
            if (this.hasPattern) this.features.push(Eh("fill-extrusion", this.layers, u22, this.zoom, this.pixelRatio, e22));
            else if (this.wallMode) for (const t4 of u22.geometry) for (const i3 of Up(t4, h22)) this.addFeature(u22, [i3], o2, r22, {}, e22.availableImages, n22, e22.brightness);
            else this.addFeature(u22, u22.geometry, o2, r22, {}, e22.availableImages, n22, e22.brightness);
            e22.featureIndex.insert(i22, u22.geometry, o2, a22, this.index, c22);
          }
          this.sortBorders(), "mercator" === this.projection.name && this.splitToSubtiles(), this.groundEffect.prepareBorderSegments(), this.polygonSegments.length = 0;
        }
        addFeatures(t22, e22, r22, n22, i22, s2) {
          for (const t3 of this.features) {
            const o2 = "Polygon" === Np[t3.type], { geometry: a22 } = t3;
            if (this.wallMode) for (const l22 of a22) for (const a3 of Up(l22, o2)) this.addFeature(t3, [a3], t3.index, e22, r22, n22, i22, s2);
            else this.addFeature(t3, a22, t3.index, e22, r22, n22, i22, s2);
          }
          this.sortBorders(), "mercator" === this.projection.name && this.splitToSubtiles();
        }
        update(t22, e22, r22, n22, i22, s2, o2) {
          this.programConfigurations.updatePaintArrays(t22, e22, i22, r22, n22, s2, o2), this.groundEffect.update(t22, e22, i22, r22, n22, s2, o2);
        }
        isEmpty() {
          return 0 === this.layoutVertexArray.length;
        }
        uploadPending() {
          return !this.uploaded || this.programConfigurations.needsUpload || this.groundEffect.programConfigurations.needsUpload;
        }
        upload(t22) {
          this.uploaded || (this.layoutVertexBuffer = t22.createVertexBuffer(this.layoutVertexArray, Sp), this.indexBuffer = t22.createIndexBuffer(this.indexArray), this.wallVertexBuffer = t22.createVertexBuffer(this.wallVertexArray, Ap.members), this.layoutVertexExtArray && (this.layoutVertexExtBuffer = t22.createVertexBuffer(this.layoutVertexExtArray, Ip.members, true)), this.groundEffect.upload(t22)), this.groundEffect.uploadPaintProperties(t22), this.programConfigurations.upload(t22), this.uploaded = true;
        }
        uploadCentroid(t22) {
          this.groundEffect.uploadHiddenByLandmark(t22), this.needsCentroidUpdate && (!this.centroidVertexBuffer && this.centroidVertexArray.length > 0 ? this.centroidVertexBuffer = t22.createVertexBuffer(this.centroidVertexArray, wp.members, true) : this.centroidVertexBuffer && this.centroidVertexBuffer.updateData(this.centroidVertexArray), this.needsCentroidUpdate = false);
        }
        destroy() {
          this.layoutVertexBuffer && (this.layoutVertexBuffer.destroy(), this.centroidVertexBuffer && this.centroidVertexBuffer.destroy(), this.layoutVertexExtBuffer && this.layoutVertexExtBuffer.destroy(), this.groundEffect.destroy(), this.indexBuffer.destroy(), this.programConfigurations.destroy(), this.segments.destroy());
        }
        addFeature(t22, e22, r22, n22, i22, s2, o2, a22) {
          const l22 = this.layers[0].paint.get("fill-extrusion-flood-light-ground-radius").evaluate(t22, {}) / this.tileToMeter, u22 = [new bt(0, 0), new bt(Tn, Tn)], c22 = o2.projection, h22 = "globe" === c22.name, p22 = this.wallMode || "Polygon" === Np[t22.type], f22 = new tf();
          f22.centroidDataIndex = this.centroidData.length;
          const d22 = new Qp(), m22 = this.layers[0].paint.get("fill-extrusion-base").evaluate(t22, {}, n22) <= 0, y22 = this.layers[0].paint.get("fill-extrusion-height").evaluate(t22, {}, n22);
          let g22;
          if (d22.height = y22, d22.vertexArrayOffset = this.layoutVertexArray.length, d22.groundVertexArrayOffset = this.groundEffect.vertexArray.length, h22 && !this.layoutVertexExtArray && (this.layoutVertexExtArray = new pa()), this.wallMode) {
            if (h22) return void $t2("Non zero fill-extrusion-line-width is not yet supported on globe.");
            if (1 !== e22.length) return;
            g22 = function(t3) {
              const e3 = t3[0].x === t3[t3.length - 1].x && t3[0].y === t3[t3.length - 1].y, r3 = function(t4) {
                let e4 = 0;
                const r4 = t4.length;
                for (let n4 = 0; n4 < r4; n4++) e4 += (t4[(n4 + 1) % r4].x - t4[n4].x) * (t4[(n4 + 1) % r4].y + t4[n4].y);
                return e4 >= 0;
              }(t3);
              r3 || (t3 = t3.reverse());
              const n3 = { geometry: [], joinNormals: [], indices: [] }, i3 = [], s3 = [], o3 = [];
              let a3 = t3.length;
              for (; a3 >= 2 && t3[a3 - 1].equals(t3[a3 - 2]); ) a3--;
              if (a3 < (e3 ? 3 : 2)) return n3;
              let l3, u3, c3, h3, p3, f3 = 0;
              for (; f3 < a3 - 1 && t3[f3].equals(t3[f3 + 1]); ) f3++;
              e3 && (l3 = t3[a3 - 2], p3 = t3[f3].sub(l3)._unit()._perp());
              for (let r4 = f3; r4 < a3; r4++) {
                if (c3 = r4 === a3 - 1 ? e3 ? t3[f3 + 1] : void 0 : t3[r4 + 1], c3 && t3[r4].equals(c3)) continue;
                p3 && (h3 = p3), l3 && (u3 = l3), l3 = t3[r4], p3 = c3 ? c3.sub(l3)._unit()._perp() : h3, h3 = h3 || p3;
                let n4 = h3.add(p3);
                0 === n4.x && 0 === n4.y || n4._unit();
                const d4 = n4.x * p3.x + n4.y * p3.y, m3 = 0 !== d4 ? 1 / d4 : 1 / 0, y3 = h3.x * p3.y - h3.y * p3.x > 0;
                let g3 = "miter";
                const x3 = 2;
                "miter" === g3 && m3 > x3 && (g3 = "bevel"), "bevel" === g3 && (m3 > 100 && (g3 = "flipbevel"), m3 < x3 && (g3 = "miter"));
                const v3 = (t4, e4, r5, n5) => {
                  const a4 = new bt(t4.x, t4.y), l4 = new bt(t4.x, t4.y);
                  a4.x += e4.x * n5, a4.y += e4.y * n5, l4.x -= e4.x * Math.max(r5, 1), l4.y -= e4.y * Math.max(r5, 1), o3.push(e4), i3.push(a4), s3.push(l4);
                };
                if ("miter" === g3) n4._mult(m3), v3(l3, n4, 0, 0);
                else if ("flipbevel" === g3) n4 = p3.mult(-1), v3(l3, n4, 0, 0), v3(l3, n4.mult(-1), 0, 0);
                else {
                  const t4 = -Math.sqrt(m3 * m3 - 1), e4 = y3 ? t4 : 0, r5 = y3 ? 0 : t4;
                  u3 && v3(l3, h3, e4, r5), c3 && v3(l3, p3, e4, r5);
                }
              }
              n3.geometry = [...i3, ...s3.reverse(), i3[0]], n3.joinNormals = [...o3, ...o3.reverse(), o3[o3.length - 1]];
              const d3 = n3.geometry.length - 1;
              for (let t4 = 0; t4 < d3 / 2; t4++) if (t4 + 1 < d3 / 2) {
                let e4 = t4, r4 = t4 + 1, i4 = d3 - 1 - t4, s4 = d3 - 2 - t4;
                e4 = 0 === e4 ? d3 - 1 : e4 - 1, r4 = 0 === r4 ? d3 - 1 : r4 - 1, i4 = 0 === i4 ? d3 - 1 : i4 - 1, s4 = 0 === s4 ? d3 - 1 : s4 - 1, n3.indices.push(i4), n3.indices.push(r4), n3.indices.push(e4), n3.indices.push(i4), n3.indices.push(s4), n3.indices.push(r4);
              }
              return n3;
            }(e22[0]), e22 = [g22.geometry];
          }
          const x22 = (t3, e3) => t3 < (e3.length - 1) / 2 || t3 === e3.length - 1, v22 = this.wallMode ? [e22] : Ih(e22, 500);
          for (let t3 = v22.length - 1; t3 >= 0; t3--) {
            const e3 = v22[t3];
            (0 === e3.length || (b22 = e3[0]).every((t4) => t4.x <= 0) || b22.every((t4) => t4.x >= Tn) || b22.every((t4) => t4.y <= 0) || b22.every((t4) => t4.y >= Tn)) && v22.splice(t3, 1);
          }
          var b22;
          let _22;
          if (h22) _22 = mf(v22, u22, n22);
          else {
            _22 = [];
            for (const t3 of v22) _22.push({ polygon: t3, bounds: u22 });
          }
          const w22 = p22 ? this.edgeRadius : 0, A22 = w22 > 0 && this.zoom < 17, M22 = (t3, e3) => {
            if (0 === t3.length) return false;
            const r3 = t3[t3.length - 1];
            return e3.x === r3.x && e3.y === r3.y;
          };
          for (const { polygon: t3, bounds: e3 } of _22) {
            let r3 = 0, i3 = 0;
            for (const e4 of t3) p22 && !e4[0].equals(e4[e4.length - 1]) && e4.push(e4[0]), i3 += p22 ? e4.length - 1 : e4.length;
            const s3 = this.segments.prepareSegment((p22 ? 5 : 4) * i3, this.layoutVertexArray, this.indexArray);
            d22.footprintSegIdx < 0 && (d22.footprintSegIdx = this.footprintSegments.length), d22.polygonSegIdx < 0 && (d22.polygonSegIdx = this.polygonSegments.length);
            const o3 = { triangleArrayOffset: this.indexArray.length, triangleCount: 0, triangleSegIdx: this.segments.segments.length - 1 }, a3 = new Jp();
            if (a3.vertexOffset = this.footprintVertices.length, a3.indexOffset = 3 * this.footprintIndices.length, a3.ringIndices = [], p22) {
              const i4 = [], o4 = [];
              r3 = s3.vertexLength;
              for (let r4 = 0; r4 < t3.length; r4++) {
                const u4 = t3[r4];
                u4.length && 0 !== r4 && o4.push(i4.length / 2);
                const p3 = [];
                let f3, d3;
                f3 = u4[1].sub(u4[0])._perp()._unit(), a3.ringIndices.push(u4.length - 1);
                for (let t4 = 1; t4 < u4.length; t4++) {
                  const e4 = u4[t4], r5 = u4[t4 === u4.length - 1 ? 1 : t4 + 1], o5 = e4.clone();
                  if (w22) {
                    d3 = r5.sub(e4)._perp()._unit();
                    const t5 = f3.add(d3)._unit(), n3 = w22 * Math.min(4, 1 / (f3.x * t5.x + f3.y * t5.y));
                    o5.x += n3 * t5.x, o5.y += n3 * t5.y, o5.x = Math.round(o5.x), o5.y = Math.round(o5.y), f3 = d3;
                  }
                  if (!m22 || 0 !== w22 && !A22 || M22(p3, o5) || p3.push(o5), Zp(this.layoutVertexArray, o5.x, o5.y, 0, 0, 1, 1, 0), this.wallMode) {
                    const e5 = x22(t4, u4);
                    Wp(this.wallVertexArray, g22.joinNormals[t4], !e5);
                  }
                  s3.vertexLength++, this.footprintVertices.emplaceBack(e4.x, e4.y), i4.push(e4.x, e4.y), h22 && Kp(this.layoutVertexExtArray, c22.projectTilePoint(o5.x, o5.y, n22), c22.upVector(n22, o5.x, o5.y));
                }
                m22 && (0 === w22 || A22) && (0 !== p3.length && M22(p3, p3[0]) && p3.pop(), this.groundEffect.addData(p3, e3, l22));
              }
              const u3 = this.wallMode ? g22.indices : Qc(i4, o4);
              for (let t4 = 0; t4 < u3.length; t4 += 3) this.footprintIndices.emplaceBack(a3.vertexOffset + u3[t4 + 0], a3.vertexOffset + u3[t4 + 1], a3.vertexOffset + u3[t4 + 2]), this.indexArray.emplaceBack(r3 + u3[t4], r3 + u3[t4 + 2], r3 + u3[t4 + 1]), s3.primitiveLength++;
              a3.indexCount += u3.length, a3.vertexCount += this.footprintVertices.length - a3.vertexOffset;
            }
            for (let i4 = 0; i4 < t3.length; i4++) {
              const o4 = t3[i4];
              f22.startRing(d22, o4[0]);
              let a4 = o4.length > 4 && pf(o4[o4.length - 2], o4[0], o4[1]), u3 = w22 ? lf(o4[o4.length - 2], o4[0], o4[1], w22) : 0;
              const y3 = [];
              let v3, b3, _3;
              b3 = o4[1].sub(o4[0])._perp()._unit();
              let A3 = true;
              for (let t4 = 1, i5 = 0; t4 < o4.length; t4++) {
                let l3 = o4[t4 - 1], p3 = o4[t4];
                const I2 = o4[t4 === o4.length - 1 ? 1 : t4 + 1];
                if (f22.appendEdge(d22, p3, l3), cf(p3, l3, e3)) {
                  w22 && (b3 = I2.sub(p3)._perp()._unit(), A3 = !A3);
                  continue;
                }
                const S2 = p3.sub(l3)._perp(), z22 = S2.x / (Math.abs(S2.x) + Math.abs(S2.y)), k22 = S2.y > 0 ? 1 : 0, E22 = l3.dist(p3);
                if (i5 + E22 > 32768 && (i5 = 0), w22) {
                  _3 = I2.sub(p3)._perp()._unit();
                  let t5 = uf(l3, p3, I2, af(b3, _3), w22);
                  isNaN(t5) && (t5 = 0);
                  const e4 = p3.sub(l3)._unit();
                  l3 = l3.add(e4.mult(u3))._round(), p3 = p3.add(e4.mult(-t5))._round(), u3 = t5, b3 = _3, m22 && this.zoom >= 17 && (M22(y3, l3) || y3.push(l3), M22(y3, p3) || y3.push(p3));
                }
                const P22 = s3.vertexLength, T2 = o4.length > 4 && pf(l3, p3, I2);
                let B22 = ff(i5, a4, A3);
                if (Zp(this.layoutVertexArray, l3.x, l3.y, z22, k22, 0, 0, B22), Zp(this.layoutVertexArray, l3.x, l3.y, z22, k22, 0, 1, B22), this.wallMode) {
                  const e4 = x22(t4 - 1, o4), r4 = g22.joinNormals[t4 - 1];
                  Wp(this.wallVertexArray, r4, e4), Wp(this.wallVertexArray, r4, e4);
                }
                if (i5 += E22, B22 = ff(i5, T2, !A3), a4 = T2, Zp(this.layoutVertexArray, p3.x, p3.y, z22, k22, 0, 0, B22), Zp(this.layoutVertexArray, p3.x, p3.y, z22, k22, 0, 1, B22), this.wallMode) {
                  const e4 = x22(t4, o4), r4 = g22.joinNormals[t4];
                  Wp(this.wallVertexArray, r4, e4), Wp(this.wallVertexArray, r4, e4);
                }
                if (s3.vertexLength += 4, this.indexArray.emplaceBack(P22 + 0, P22 + 1, P22 + 2), this.indexArray.emplaceBack(P22 + 1, P22 + 3, P22 + 2), s3.primitiveLength += 2, w22) {
                  const n3 = r3 + (1 === t4 ? o4.length - 2 : t4 - 2), i6 = 1 === t4 ? r3 : n3 + 1;
                  if (this.indexArray.emplaceBack(P22 + 1, n3, P22 + 3), this.indexArray.emplaceBack(n3, i6, P22 + 3), s3.primitiveLength += 2, void 0 === v3 && (v3 = P22), !cf(I2, o4[t4], e3)) {
                    const e4 = t4 === o4.length - 1 ? v3 : s3.vertexLength;
                    this.indexArray.emplaceBack(P22 + 2, P22 + 3, e4), this.indexArray.emplaceBack(P22 + 3, e4 + 1, e4), this.indexArray.emplaceBack(P22 + 3, i6, e4 + 1), s3.primitiveLength += 3;
                  }
                  A3 = !A3;
                }
                if (h22) {
                  const t5 = this.layoutVertexExtArray, e4 = c22.projectTilePoint(l3.x, l3.y, n22), r4 = c22.projectTilePoint(p3.x, p3.y, n22), i6 = c22.upVector(n22, l3.x, l3.y), s4 = c22.upVector(n22, p3.x, p3.y);
                  Kp(t5, e4, i6), Kp(t5, e4, i6), Kp(t5, r4, s4), Kp(t5, r4, s4);
                }
              }
              p22 && (r3 += o4.length - 1), m22 && w22 && this.zoom >= 17 && (0 !== y3.length && M22(y3, y3[0]) && y3.pop(), this.groundEffect.addData(y3, e3, l22, w22 > 0));
            }
            this.footprintSegments.push(a3), o3.triangleCount = this.indexArray.length - o3.triangleArrayOffset, this.polygonSegments.push(o3), ++d22.footprintSegLen, ++d22.polygonSegLen;
          }
          if (d22.vertexCount = this.layoutVertexArray.length - d22.vertexArrayOffset, d22.groundVertexCount = this.groundEffect.vertexArray.length - d22.groundVertexArrayOffset, 0 !== d22.vertexCount) {
            if (d22.centroidXY = f22.borders ? Hp : this.encodeCentroid(f22, d22), this.centroidData.push(d22), f22.borders) {
              this.featuresOnBorder.push(f22);
              const t3 = this.featuresOnBorder.length - 1;
              for (let e3 = 0; e3 < f22.borders.length; e3++) f22.borders[e3][0] !== Number.MAX_VALUE && this.borderFeatureIndices[e3].push(t3);
            }
            this.programConfigurations.populatePaintArrays(this.layoutVertexArray.length, t22, r22, i22, s2, n22, a22), this.groundEffect.addPaintPropertiesData(t22, r22, i22, s2, n22, a22), this.maxHeight = Math.max(this.maxHeight, y22);
          }
        }
        sortBorders() {
          for (let t22 = 0; t22 < this.borderFeatureIndices.length; t22++) this.borderFeatureIndices[t22].sort((e22, r22) => this.featuresOnBorder[e22].borders[t22][0] - this.featuresOnBorder[r22].borders[t22][0]);
        }
        splitToSubtiles() {
          const t22 = [];
          for (let e3 = 0; e3 < this.centroidData.length; e3++) {
            const r3 = this.centroidData[e3], n3 = +(r3.min.y + r3.max.y > Tn), i3 = 2 * n3 + (+(r3.min.x + r3.max.x > Tn) ^ n3);
            for (let n4 = 0; n4 < r3.polygonSegLen; n4++) {
              const s3 = r3.polygonSegIdx + n4;
              t22.push({ centroidIdx: e3, subtile: i3, polygonSegmentIdx: s3, triangleSegmentIdx: this.polygonSegments[s3].triangleSegIdx });
            }
          }
          const e22 = new wa();
          t22.sort((t3, e3) => t3.triangleSegmentIdx === e3.triangleSegmentIdx ? t3.subtile - e3.subtile : t3.triangleSegmentIdx - e3.triangleSegmentIdx);
          let r22 = 0, n22 = 0, i22 = 0;
          for (const e3 of t22) {
            if (e3.triangleSegmentIdx !== r22) break;
            i22++;
          }
          const s2 = t22.length;
          for (; n22 !== t22.length; ) {
            r22 = t22[n22].triangleSegmentIdx;
            let o2 = 0, a22 = n22, l22 = n22;
            for (let e3 = a22; e3 < i22 && t22[e3].subtile === o2; e3++) l22++;
            for (; a22 !== i22; ) {
              const n3 = t22[a22];
              o2 = n3.subtile;
              const s3 = this.centroidData[n3.centroidIdx].min.clone(), u22 = this.centroidData[n3.centroidIdx].max.clone(), c22 = { vertexOffset: this.segments.segments[r22].vertexOffset, primitiveOffset: e22.length, vertexLength: this.segments.segments[r22].vertexLength, primitiveLength: 0, sortKey: void 0, vaos: {} };
              for (let r3 = a22; r3 < l22; r3++) {
                const n4 = t22[r3], i3 = this.polygonSegments[n4.polygonSegmentIdx], o3 = this.centroidData[n4.centroidIdx].min, a3 = this.centroidData[n4.centroidIdx].max, l3 = this.indexArray.uint16;
                for (let t3 = i3.triangleArrayOffset; t3 < i3.triangleArrayOffset + i3.triangleCount; t3++) e22.emplaceBack(l3[3 * t3], l3[3 * t3 + 1], l3[3 * t3 + 2]);
                c22.primitiveLength += i3.triangleCount, s3.x = Math.min(s3.x, o3.x), s3.y = Math.min(s3.y, o3.y), u22.x = Math.max(u22.x, a3.x), u22.y = Math.max(u22.y, a3.y);
              }
              c22.primitiveLength > 0 && this.triangleSubSegments.push({ segment: c22, min: s3, max: u22 }), a22 = l22;
              for (let e3 = a22; e3 < i22 && t22[e3].subtile === t22[a22].subtile; e3++) l22++;
            }
            n22 = i22;
            for (let e3 = n22; e3 < s2 && t22[e3].triangleSegmentIdx === t22[n22].triangleSegmentIdx; e3++) i22++;
          }
          e22._trim(), this.indexArray = e22;
        }
        getVisibleSegments(t22, e22, r22) {
          const n22 = new Ka();
          if (this.wallMode) {
            for (const t3 of this.triangleSubSegments) n22.segments.push(t3.segment);
            return n22;
          }
          let i22 = 0, s2 = 0;
          const o2 = 1 << t22.canonical.z;
          if (e22) {
            const r3 = e22.getMinMaxForTile(t22);
            r3 && (i22 = r3.min, s2 = r3.max);
          }
          s2 += this.maxHeight;
          const a22 = t22.toUnwrapped();
          let l22;
          const u22 = [a22.canonical.x / o2 + a22.wrap, a22.canonical.y / o2], c22 = [(a22.canonical.x + 1) / o2 + a22.wrap, (a22.canonical.y + 1) / o2], h22 = (t3, e3, r3) => [t3[0] * (1 - r3[0]) + e3[0] * r3[0], t3[1] * (1 - r3[1]) + e3[1] * r3[1]], p22 = [], f22 = [];
          for (const t3 of this.triangleSubSegments) {
            p22[0] = t3.min.x / Tn, p22[1] = t3.min.y / Tn, f22[0] = t3.max.x / Tn, f22[1] = t3.max.y / Tn;
            const e3 = h22(u22, c22, p22), o3 = h22(u22, c22, f22);
            if (0 === new ic([e3[0], e3[1], i22], [o3[0], o3[1], s2]).intersectsPrecise(r22)) {
              l22 && (n22.segments.push(l22), l22 = void 0);
              continue;
            }
            const a3 = t3.segment;
            l22 && l22.vertexOffset !== a3.vertexOffset && (n22.segments.push(l22), l22 = void 0), l22 ? (l22.vertexLength += a3.vertexLength, l22.primitiveLength += a3.primitiveLength) : l22 = { vertexOffset: a3.vertexOffset, primitiveLength: a3.primitiveLength, vertexLength: a3.vertexLength, primitiveOffset: a3.primitiveOffset, sortKey: void 0, vaos: {} };
          }
          return l22 && n22.segments.push(l22), n22;
        }
        encodeCentroid(t22, e22) {
          const r22 = t22.centroid(), n22 = e22.span(), i22 = Math.min(7, Math.round(n22.x * this.tileToMeter / 10)), s2 = Math.min(7, Math.round(n22.y * this.tileToMeter / 10));
          return new bt(Pt(r22.x, 1, Tn - 1) << 3 | i22, Pt(r22.y, 1, Tn - 1) << 3 | s2);
        }
        encodeBorderCentroid(t22) {
          if (!t22.borders) return new bt(0, 0);
          const e22 = t22.borders, r22 = Number.MAX_VALUE;
          if (e22[0][0] !== r22 || e22[1][0] !== r22) {
            const t3 = e22[0][0] !== r22 ? 0 : 1;
            return new bt(6 | (e22[0][0] !== r22 ? 0 : 65528), (e22[t3][0] + e22[t3][1]) / 2 << 3 | 6);
          }
          {
            const t3 = e22[2][0] !== r22 ? 2 : 3;
            return new bt((e22[t3][0] + e22[t3][1]) / 2 << 3 | 6, 6 | (e22[2][0] !== r22 ? 0 : 65528));
          }
        }
        showCentroid(t22) {
          const e22 = this.centroidData[t22.centroidDataIndex];
          e22.flags &= Xp, e22.centroidXY.x = 0, e22.centroidXY.y = 0, this.writeCentroidToBuffer(e22);
        }
        writeCentroidToBuffer(t22) {
          this.groundEffect.updateHiddenByLandmark(t22);
          const e22 = t22.vertexArrayOffset, r22 = t22.vertexCount + t22.vertexArrayOffset, n22 = t22.flags & Xp ? Hp : t22.centroidXY, i22 = this.centroidVertexArray.geta_centroid_pos0(e22);
          if (this.centroidVertexArray.geta_centroid_pos1(e22) !== n22.y || i22 !== n22.x) {
            for (let t3 = e22; t3 < r22; ++t3) this.centroidVertexArray.emplace(t3, n22.x, n22.y);
            this.needsCentroidUpdate = true;
          }
        }
        createCentroidsBuffer() {
          this.centroidVertexArray.resize(this.layoutVertexArray.length), this.groundEffect.hiddenByLandmarkVertexArray.resize(this.groundEffect.vertexArray.length);
          for (const t22 of this.centroidData) this.writeCentroidToBuffer(t22);
        }
        updateReplacement(t22, e22, r22) {
          if (e22.updateTime === this.replacementUpdateTime) return;
          this.replacementUpdateTime = e22.updateTime;
          const n22 = e22.getReplacementRegionsForTile(t22.toUnwrapped());
          if (Bp(this.activeReplacements, n22)) return;
          if (this.activeReplacements = n22, 0 === this.centroidVertexArray.length) this.createCentroidsBuffer();
          else for (const t3 of this.centroidData) t3.flags &= 2147483647;
          const i22 = [];
          for (const e3 of this.activeReplacements) {
            if (e3.order < r22) continue;
            const n3 = Math.max(1, Math.pow(2, e3.footprintTileId.canonical.z - t22.canonical.z));
            for (const r3 of this.centroidData) if (!(r3.flags & Xp || e3.min.x > r3.max.x || r3.min.x > e3.max.x || e3.min.y > r3.max.y || r3.min.y > e3.max.y)) for (let s2 = 0; s2 < r3.footprintSegLen; s2++) {
              const o2 = this.footprintSegments[r3.footprintSegIdx + s2];
              if (i22.length = 0, yf(this.footprintVertices, o2.vertexOffset, o2.vertexCount, e3.footprintTileId.canonical, t22.canonical, i22), Dp(e3.footprint, i22, this.footprintIndices.uint16, o2.indexOffset, o2.indexCount, -o2.vertexOffset, -n3)) {
                r3.flags |= Xp;
                break;
              }
            }
          }
          for (const t3 of this.centroidData) this.writeCentroidToBuffer(t3);
          this.borderDoneWithNeighborZ = [-1, -1, -1, -1];
        }
        footprintContainsPoint(t22, e22, r22) {
          let n22 = false;
          for (let i22 = 0; i22 < r22.footprintSegLen; i22++) {
            const s2 = this.footprintSegments[r22.footprintSegIdx + i22];
            let o2 = 0;
            for (const r3 of s2.ringIndices) {
              for (let i3 = o2, a22 = r3 + o2 - 1; i3 < r3 + o2; a22 = i3++) {
                const r4 = this.footprintVertices.int16[2 * (i3 + s2.vertexOffset) + 0], o3 = this.footprintVertices.int16[2 * (i3 + s2.vertexOffset) + 1], l22 = this.footprintVertices.int16[2 * (a22 + s2.vertexOffset) + 1];
                o3 > e22 != l22 > e22 && t22 < (this.footprintVertices.int16[2 * (a22 + s2.vertexOffset) + 0] - r4) * (e22 - o3) / (l22 - o3) + r4 && (n22 = !n22);
              }
              o2 = r3;
            }
          }
          return n22;
        }
        getHeightAtTileCoord(t22, e22) {
          let r22 = Number.NEGATIVE_INFINITY, n22 = true;
          const i22 = 4 * (t22 + Tn) * Tn + (e22 + Tn);
          if (this.partLookup.hasOwnProperty(i22)) {
            const t3 = this.partLookup[i22];
            return t3 ? { height: t3.height, hidden: !!(t3.flags & Xp) } : void 0;
          }
          for (const s2 of this.centroidData) t22 > s2.max.x || s2.min.x > t22 || e22 > s2.max.y || s2.min.y > e22 || this.footprintContainsPoint(t22, e22, s2) && s2 && s2.height > r22 && (r22 = s2.height, this.partLookup[i22] = s2, n22 = !!(s2.flags & Xp));
          if (r22 !== Number.NEGATIVE_INFINITY) return { height: r22, hidden: n22 };
          this.partLookup[i22] = void 0;
        }
      }
      function af(t22, e22) {
        const r22 = t22.add(e22)._unit();
        return t22.x * r22.x + t22.y * r22.y;
      }
      function lf(t22, e22, r22, n22) {
        const i22 = e22.sub(t22)._perp()._unit(), s2 = r22.sub(e22)._perp()._unit();
        return uf(t22, e22, r22, af(i22, s2), n22);
      }
      function uf(t22, e22, r22, n22, i22) {
        const s2 = Math.sqrt(1 - n22 * n22);
        return Math.min(t22.dist(e22) / 3, e22.dist(r22) / 3, i22 * s2 / n22);
      }
      function cf(t22, e22, r22) {
        return t22.x < r22[0].x && e22.x < r22[0].x || t22.x > r22[1].x && e22.x > r22[1].x || t22.y < r22[0].y && e22.y < r22[0].y || t22.y > r22[1].y && e22.y > r22[1].y;
      }
      function hf(t22, e22) {
        return t22.x < e22[0].x || t22.x > e22[1].x || t22.y < e22[0].y || t22.y > e22[1].y;
      }
      function pf(t22, e22, r22) {
        if (t22.x < 0 || t22.x >= Tn || e22.x < 0 || e22.x >= Tn || r22.x < 0 || r22.x >= Tn) return false;
        const n22 = r22.sub(e22), i22 = n22.perp(), s2 = t22.sub(e22);
        return (n22.x * s2.x + n22.y * s2.y) / Math.sqrt((n22.x * n22.x + n22.y * n22.y) * (s2.x * s2.x + s2.y * s2.y)) > -0.866 && i22.x * s2.x + i22.y * s2.y < 0;
      }
      function ff(t22, e22, r22) {
        const n22 = e22 ? 2 | t22 : -3 & t22;
        return r22 ? 1 | n22 : -2 & n22;
      }
      function df() {
        const t22 = Math.PI / 32, e22 = Math.tan(t22), r22 = Nl;
        return r22 * Math.sqrt(1 + 2 * e22 * e22) - r22;
      }
      function mf(t22, e22, r22) {
        const n22 = 1 << r22.z, i22 = Kl(r22.x / n22), s2 = Kl((r22.x + 1) / n22), o2 = Jl(r22.y / n22), a22 = Jl((r22.y + 1) / n22);
        return function(t3, e3, r3, n3, i3 = 0, s3) {
          const o3 = [];
          if (!t3.length || !r3 || !n3) return o3;
          const a3 = (t4, e4) => {
            for (const r4 of t4) o3.push({ polygon: r4, bounds: e4 });
          }, l22 = Math.ceil(Math.log2(r3)), u22 = Math.ceil(Math.log2(n3)), c22 = l22 - u22, h22 = [];
          for (let t4 = 0; t4 < Math.abs(c22); t4++) h22.push(c22 > 0 ? 0 : 1);
          for (let t4 = 0; t4 < Math.min(l22, u22); t4++) h22.push(0), h22.push(1);
          let p22 = t3;
          if (p22 = op(p22, e3[0].y - i3, e3[1].y + i3, 1), p22 = op(p22, e3[0].x - i3, e3[1].x + i3, 0), !p22.length) return o3;
          const f22 = [];
          for (h22.length ? f22.push({ polygons: p22, bounds: e3, depth: 0 }) : a3(p22, e3); f22.length; ) {
            const t4 = f22.pop(), e4 = t4.depth, r4 = h22[e4], n4 = t4.bounds[0], o4 = t4.bounds[1], l3 = 0 === r4 ? n4.x : n4.y, u3 = 0 === r4 ? o4.x : o4.y, c3 = s3 ? s3(r4, l3, u3) : 0.5 * (l3 + u3), p3 = op(t4.polygons, l3 - i3, c3 + i3, r4), d22 = op(t4.polygons, c3 - i3, u3 + i3, r4);
            if (p3.length) {
              const t5 = [n4, new bt(0 === r4 ? c3 : o4.x, 1 === r4 ? c3 : o4.y)];
              h22.length > e4 + 1 ? f22.push({ polygons: p3, bounds: t5, depth: e4 + 1 }) : a3(p3, t5);
            }
            if (d22.length) {
              const t5 = [new bt(0 === r4 ? c3 : n4.x, 1 === r4 ? c3 : n4.y), o4];
              h22.length > e4 + 1 ? f22.push({ polygons: d22, bounds: t5, depth: e4 + 1 }) : a3(d22, t5);
            }
          }
          return o3;
        }(t22, e22, Math.ceil((s2 - i22) / 11.25), Math.ceil((o2 - a22) / 11.25), 1, (t3, e3, i3) => {
          if (0 === t3) return 0.5 * (e3 + i3);
          {
            const t4 = Jl((r22.y + e3 / Tn) / n22);
            return (Wl(0.5 * (Jl((r22.y + i3 / Tn) / n22) + t4)) * n22 - r22.y) * Tn;
          }
        });
      }
      function yf(t22, e22, r22, n22, i22, s2) {
        const o2 = Math.pow(2, n22.z - i22.z);
        for (let a22 = 0; a22 < r22; a22++) {
          let r3 = t22.int16[2 * (a22 + e22) + 0], l22 = t22.int16[2 * (a22 + e22) + 1];
          r3 = (r3 + i22.x * Tn) * o2 - n22.x * Tn, l22 = (l22 + i22.y * Tn) * o2 - n22.y * Tn, s2.push(new bt(r3, l22));
        }
      }
      let gf, xf;
      js(of, "FillExtrusionBucket", { omit: ["layers", "features"] }), js(Qp, "PartData"), js(Jp, "FootprintSegment"), js(tf, "BorderCentroidData"), js(sf, "GroundEffect");
      class vf extends bt {
        constructor(t22, e22, r22) {
          super(t22, e22), this.z = r22;
        }
      }
      class bf extends vf {
        constructor(t22, e22, r22, n22) {
          super(t22, e22, r22), this.w = n22;
        }
      }
      function _f2(t22, e22, r22, n22) {
        const i22 = "x" === r22 ? "y" : "x", s2 = (n22 - t22[r22]) / (e22[r22] - t22[r22]);
        t22[i22] = Math.round(t22[i22] + (e22[i22] - t22[i22]) * s2), t22[r22] = n22, t22.hasOwnProperty("z") && (t22.z = or(t22.z, e22.z, s2)), t22.hasOwnProperty("w") && (t22.w = or(t22.w, e22.w, s2));
      }
      function wf(t22, e22, r22, n22) {
        const i22 = r22, s2 = n22;
        for (const r3 of ["x", "y"]) {
          let n3 = t22, o2 = e22;
          n3[r3] >= o2[r3] && (n3 = e22, o2 = t22), n3[r3] < i22 && o2[r3] > i22 && _f2(n3, o2, r3, i22), n3[r3] < s2 && o2[r3] > s2 && _f2(o2, n3, r3, s2);
        }
      }
      function Af(t22, e22, r22, n22, i22, s2) {
        const o2 = [];
        for (let a22 = 0; a22 < t22.length; a22++) {
          const l22 = t22[a22];
          let u22;
          const c22 = o2.length;
          let h22 = 0;
          for (let t3 = 0; t3 < l22.length - 1; t3++) {
            let c3 = l22[t3], p22 = l22[t3 + 1], f22 = 0;
            const d22 = h22;
            let m22, y22;
            s2 && (f22 = Math.hypot(p22.x - c3.x, p22.y - c3.y), h22 += f22, m22 = c3, y22 = p22), c3.x < e22 && p22.x < e22 || (c3.x < e22 ? c3 = new bt(e22, c3.y + (e22 - c3.x) / (p22.x - c3.x) * (p22.y - c3.y))._round() : p22.x < e22 && (p22 = new bt(e22, c3.y + (e22 - c3.x) / (p22.x - c3.x) * (p22.y - c3.y))._round()), c3.y < r22 && p22.y < r22 || (c3.y < r22 ? c3 = new bt(c3.x + (r22 - c3.y) / (p22.y - c3.y) * (p22.x - c3.x), r22)._round() : p22.y < r22 && (p22 = new bt(c3.x + (r22 - c3.y) / (p22.y - c3.y) * (p22.x - c3.x), r22)._round()), c3.x >= n22 && p22.x >= n22 || (c3.x >= n22 ? c3 = new bt(n22, c3.y + (n22 - c3.x) / (p22.x - c3.x) * (p22.y - c3.y))._round() : p22.x >= n22 && (p22 = new bt(n22, c3.y + (n22 - c3.x) / (p22.x - c3.x) * (p22.y - c3.y))._round()), c3.y >= i22 && p22.y >= i22 || (c3.y >= i22 ? c3 = new bt(c3.x + (i22 - c3.y) / (p22.y - c3.y) * (p22.x - c3.x), i22)._round() : p22.y >= i22 && (p22 = new bt(c3.x + (i22 - c3.y) / (p22.y - c3.y) * (p22.x - c3.x), i22)._round()), u22 && c3.equals(u22[u22.length - 1]) || (u22 = [c3], o2.push(u22), s2 && s2.push({ progress: { min: d22 + If(m22, y22, c3) * f22, max: 1 }, parentIndex: a22, prevPoint: m22, nextPoint: y22 })), u22.push(p22), s2 && (s2[s2.length - 1].progress.max = d22 + If(m22, y22, p22) * f22, s2[s2.length - 1].nextPoint = y22)))));
          }
          if (s2 && h22 > 0) for (let t3 = c22; t3 < o2.length; t3++) s2[t3].progress.min /= h22, s2[t3].progress.max /= h22;
        }
        return o2;
      }
      function Mf(t22, e22, r22, n22, i22) {
        if (t22.length < 2) return void n22.push(t22);
        const s2 = [];
        for (; e22.valid(); ) {
          const [r3, n3] = e22.get();
          for (let e3 = 0; e3 < t22.length - 1; e3++) {
            const i3 = t22[e3], o3 = t22[e3 + 1], a3 = Iu(i3, o3, r3, n3);
            if (a3) {
              const [t3] = a3, r4 = new bt(or(i3.x, o3.x, t3), or(i3.y, o3.y, t3));
              s2.push({ t: e3 + t3, distance: 0, point: r4 });
            }
          }
          e22.next();
        }
        if (0 === s2.length) return void n22.push(t22);
        s2.sort((t3, e3) => t3.t - e3.t);
        let o2 = 0, a22 = 0, l22 = [];
        for (n22.push(l22); o2 !== t22.length; ) {
          if (a22 === s2.length) {
            for (; o2 !== t22.length; ) 0 !== l22.length && l22[l22.length - 1].equals(t22[o2]) || l22.push(t22[o2]), o2++;
            break;
          }
          s2[a22].t <= o2 ? (0 !== l22.length && l22[l22.length - 1].equals(s2[a22].point) || l22.push(s2[a22].point), Math.trunc(s2[a22].t), a22++) : (0 !== l22.length && l22[l22.length - 1].equals(t22[o2]) || l22.push(t22[o2]), o2++);
        }
      }
      function If(t22, e22, r22) {
        return t22.x !== e22.x ? (r22.x - t22.x) / (e22.x - t22.x) : t22.y !== e22.y ? (r22.y - t22.y) / (e22.y - t22.y) : 0;
      }
      function Sf(t22, e22) {
        return t22.x * e22.x + t22.y * e22.y;
      }
      function zf(t22, e22) {
        if (1 === t22.length) {
          let r22 = 0;
          const n22 = e22[r22++];
          let i22;
          for (; !i22 || n22.equals(i22); ) if (i22 = e22[r22++], !i22) return 1 / 0;
          for (; r22 < e22.length; r22++) {
            const s2 = e22[r22], o2 = t22[0], a22 = i22.sub(n22), l22 = s2.sub(n22), u22 = o2.sub(n22), c22 = Sf(a22, a22), h22 = Sf(a22, l22), p22 = Sf(l22, l22), f22 = Sf(u22, a22), d22 = Sf(u22, l22), m22 = c22 * p22 - h22 * h22, y22 = (p22 * f22 - h22 * d22) / m22, g22 = (c22 * d22 - h22 * f22) / m22, x22 = n22.z * (1 - y22 - g22) + i22.z * y22 + s2.z * g22;
            if (isFinite(x22)) return x22;
          }
          return 1 / 0;
        }
        {
          let t3 = 1 / 0;
          for (const r22 of e22) t3 = Math.min(t3, r22.z);
          return t3;
        }
      }
      function kf(t22, e22, r22, n22, i22, s2, o2, a22) {
        const l22 = o2 * i22.getElevationAt(t22, e22, true, true), u22 = 0 !== s2[0], c22 = u22 ? 0 === s2[1] ? o2 * (s2[0] / 7 - 450) : o2 * function(t3, e3, r3) {
          const n3 = Math.floor(e3[0] / 8), i3 = Math.floor(e3[1] / 8), s3 = 10 * (e3[0] - 8 * n3), o3 = 10 * (e3[1] - 8 * i3), a3 = t3.getElevationAt(n3, i3, true, true), l3 = t3.getMeterToDEM(r3), u3 = Math.floor(0.5 * (s3 * l3 - 1)), c3 = Math.floor(0.5 * (o3 * l3 - 1)), h22 = t3.tileCoordToPixel(n3, i3), p22 = 2 * u3 + 1, f22 = 2 * c3 + 1, d22 = function(t4, e4, r4, n4, i4) {
            return [t4.getElevationAtPixel(e4, r4, true), t4.getElevationAtPixel(e4 + i4, r4, true), t4.getElevationAtPixel(e4, r4 + i4, true), t4.getElevationAtPixel(e4 + n4, r4 + i4, true)];
          }(t3, h22.x - u3, h22.y - c3, p22, f22), m22 = Math.abs(d22[0] - d22[1]), y22 = Math.abs(d22[2] - d22[3]), g22 = Math.abs(d22[0] - d22[2]) + Math.abs(d22[1] - d22[3]), x22 = Math.min(0.25, 0.5 * l3 * (m22 + y22) / p22), v22 = Math.min(0.25, 0.5 * l3 * g22 / f22);
          return a3 + Math.max(x22 * s3, v22 * o3);
        }(i22, s2, a22) : l22;
        return { base: l22 + (0 === r22 ? -1 : r22), top: u22 ? Math.max(c22 + n22, l22 + r22 + 2) : l22 + n22 };
      }
      const Ef = Qo([{ name: "a_pos_normal", components: 2, type: "Int16" }, { name: "a_data", components: 4, type: "Uint8" }, { name: "a_linesofar", components: 1, type: "Float32" }], 4), Pf = Qo([{ name: "a_z_offset_width", components: 3, type: "Float32" }], 4), { members: Tf } = Ef, Bf = Qo([{ name: "a_packed", components: 3, type: "Float32" }]), { members: Vf } = Bf, Cf = Qo([{ name: "a_pattern_data", components: 3, type: "Float32" }]), { members: Df } = Cf;
      class Ff {
        constructor(t22, e22) {
          this.width = t22, this.height = e22, this.nextRow = 0, this.image = new qc({ width: t22, height: e22 }), this.positions = {}, this.uploaded = false;
        }
        getDash(t22, e22) {
          const r22 = this.getKey(t22, e22);
          return this.positions[r22];
        }
        trim() {
          const t22 = this.width, e22 = this.height = Lt(this.nextRow);
          this.image.resize({ width: t22, height: e22 });
        }
        getKey(t22, e22) {
          return t22.join(",") + e22;
        }
        getDashRanges(t22, e22, r22) {
          const n22 = [];
          let i22 = t22.length % 2 == 1 ? -t22[t22.length - 1] * r22 : 0, s2 = t22[0] * r22, o2 = true;
          n22.push({ left: i22, right: s2, isDash: o2, zeroLength: 0 === t22[0] });
          let a22 = t22[0];
          for (let e3 = 1; e3 < t22.length; e3++) {
            o2 = !o2;
            const l22 = t22[e3];
            i22 = a22 * r22, a22 += l22, s2 = a22 * r22, n22.push({ left: i22, right: s2, isDash: o2, zeroLength: 0 === l22 });
          }
          return n22;
        }
        addRoundDash(t22, e22, r22) {
          const n22 = e22 / 2;
          for (let e3 = -r22; e3 <= r22; e3++) {
            const i22 = this.width * (this.nextRow + r22 + e3);
            let s2 = 0, o2 = t22[s2];
            for (let a22 = 0; a22 < this.width; a22++) {
              a22 / o2.right > 1 && (o2 = t22[++s2]);
              const l22 = Math.abs(a22 - o2.left), u22 = Math.abs(a22 - o2.right), c22 = Math.min(l22, u22);
              let h22;
              const p22 = e3 / r22 * (n22 + 1);
              if (o2.isDash) {
                const t3 = n22 - Math.abs(p22);
                h22 = Math.sqrt(c22 * c22 + t3 * t3);
              } else h22 = n22 - Math.sqrt(c22 * c22 + p22 * p22);
              this.image.data[i22 + a22] = Math.max(0, Math.min(255, h22 + 128));
            }
          }
        }
        addRegularDash(t22, e22) {
          for (let e3 = t22.length - 1; e3 >= 0; --e3) {
            const r3 = t22[e3], n3 = t22[e3 + 1];
            r3.zeroLength ? t22.splice(e3, 1) : n3 && n3.isDash === r3.isDash && (n3.left = r3.left, t22.splice(e3, 1));
          }
          const r22 = t22[0], n22 = t22[t22.length - 1];
          r22.isDash === n22.isDash && (r22.left = n22.left - this.width, n22.right = r22.right + this.width);
          const i22 = this.width * this.nextRow;
          let s2 = 0, o2 = t22[s2];
          for (let r3 = 0; r3 < this.width; r3++) {
            r3 / o2.right > 1 && (o2 = t22[++s2]);
            const n3 = Math.abs(r3 - o2.left), a22 = Math.abs(r3 - o2.right), l22 = Math.min(n3, a22);
            this.image.data[i22 + r3] = Math.max(0, Math.min(255, (o2.isDash ? l22 : -l22) + e22 + 128));
          }
        }
        addDash(t22, e22) {
          const r22 = this.getKey(t22, e22);
          if (this.positions[r22]) return this.positions[r22];
          const n22 = "round" === e22, i22 = n22 ? 7 : 0, s2 = 2 * i22 + 1;
          if (this.nextRow + s2 > this.height) return $t2("LineAtlas out of space"), null;
          0 === t22.length && t22.push(1);
          let o2 = 0;
          for (let e3 = 0; e3 < t22.length; e3++) t22[e3] < 0 && ($t2("Negative value is found in line dasharray, replacing values with 0"), t22[e3] = 0), o2 += t22[e3];
          if (0 !== o2) {
            const r3 = this.width / o2, s3 = this.getDashRanges(t22, this.width, r3);
            n22 ? this.addRoundDash(s3, r3, i22) : this.addRegularDash(s3, "square" === e22 ? 0.5 * r3 : 0);
          }
          const a22 = this.nextRow + i22;
          this.nextRow += s2;
          const l22 = { tl: [a22, i22], br: [o2, 0] };
          return this.positions[r22] = l22, l22;
        }
      }
      js(Ff, "LineAtlas");
      const Lf = Nh.VectorTileFeature.types, Rf = Math.cos(Math.PI / 180 * 37.5), Of = Math.cos(Math.PI / 180 * 5);
      class Uf {
        constructor(t22) {
          this.evaluationGlobals = { zoom: 0, lineProgress: void 0 }, this.elevationType = "none", this.zoom = t22.zoom, this.evaluationGlobals.zoom = this.zoom, this.overscaling = t22.overscaling, this.pixelRatio = t22.pixelRatio, this.layers = t22.layers, this.layerIds = this.layers.map((t3) => t3.fqid), this.index = t22.index, this.projection = t22.projection, this.hasPattern = false, this.hasCrossSlope = false, this.patternFeatures = [], this.lineClipsArray = [], this.gradients = {}, this.layers.forEach((t3) => {
            this.gradients[t3.id] = {};
          }), this.layoutVertexArray = new la(), this.layoutVertexArray2 = new ua(), this.patternVertexArray = new ua(), this.indexArray = new wa(), this.programConfigurations = new Il(t22.layers, { zoom: t22.zoom, lut: t22.lut }), this.segments = new Ka(), this.maxLineLength = 0, this.zOffsetVertexArray = new ua(), this.stateDependentLayerIds = this.layers.filter((t3) => t3.isStateDependent()).map((t3) => t3.id), this.tessellationStep = t22.tessellationStep ? t22.tessellationStep : Tn / 64;
        }
        updateFootprints(t22, e22) {
        }
        populate(t22, e22, r22, n22) {
          this.hasPattern = kh("line", this.layers, this.pixelRatio, e22);
          const i22 = this.layers[0].layout.get("line-sort-key");
          this.tileToMeter = iu(r22);
          const s2 = this.layers[0].layout.get("line-elevation-reference");
          if ("hd-road-markup" === s2) this.elevationType = "road";
          else {
            const t3 = this.layers[0].layout.get("line-z-offset"), e3 = t3.isConstant() && !t3.constantOr(0);
            this.elevationType = "sea" !== s2 && "ground" !== s2 && e3 ? "none" : "offset", "offset" === this.elevationType && "none" === s2 && $t2(`line-elevation-reference: ground is used for the layer ${this.layerIds[0]} because non-zero line-z-offset value was found.`);
          }
          const o2 = this.layers[0].layout.get("line-cross-slope");
          this.hasCrossSlope = "offset" === this.elevationType && void 0 !== o2;
          const a22 = [];
          for (const { feature: e3, id: s3, index: o3, sourceLayerIndex: l3 } of t22) {
            const t3 = this.layers[0]._featureFilter.needGeometry, u3 = du(e3, t3);
            if (!this.layers[0]._featureFilter.filter(new yo(this.zoom), u3, r22)) continue;
            const c3 = i22 ? i22.evaluate(u3, {}, r22) : void 0, h22 = { id: s3, properties: e3.properties, type: e3.type, sourceLayerIndex: l3, index: o3, geometry: t3 ? u3.geometry : fu(e3, r22, n22), patterns: {}, sortKey: c3 };
            a22.push(h22);
          }
          i22 && a22.sort((t3, e3) => t3.sortKey - e3.sortKey);
          const { lineAtlas: l22, featureIndex: u22 } = e22, c22 = this.addConstantDashes(l22);
          for (const n3 of a22) {
            const { geometry: i3, index: s3, sourceLayerIndex: o3 } = n3;
            if (c22 && this.addFeatureDashes(n3, l22), this.hasPattern) {
              const t3 = Eh("line", this.layers, n3, this.zoom, this.pixelRatio, e22);
              this.patternFeatures.push(t3);
            } else this.addFeature(n3, i3, s3, r22, l22.positions, e22.availableImages, e22.brightness, e22.elevationFeatures);
            u22.insert(t22[s3].feature, i3, s3, o3, this.index);
          }
        }
        addConstantDashes(t22) {
          let e22 = false;
          for (const r22 of this.layers) {
            const n22 = r22.paint.get("line-dasharray").value, i22 = r22.layout.get("line-cap").value;
            if ("constant" !== n22.kind || "constant" !== i22.kind) e22 = true;
            else {
              const e3 = i22.value, r3 = n22.value;
              if (!r3) continue;
              t22.addDash(r3, e3);
            }
          }
          return e22;
        }
        addFeatureDashes(t22, e22) {
          const r22 = this.zoom;
          for (const n22 of this.layers) {
            const i22 = n22.paint.get("line-dasharray").value, s2 = n22.layout.get("line-cap").value;
            if ("constant" === i22.kind && "constant" === s2.kind) continue;
            let o2, a22;
            if ("constant" === i22.kind) {
              if (o2 = i22.value, !o2) continue;
            } else o2 = i22.evaluate({ zoom: r22 }, t22);
            a22 = "constant" === s2.kind ? s2.value : s2.evaluate({ zoom: r22 }, t22), e22.addDash(o2, a22), t22.patterns[n22.id] = [e22.getKey(o2, a22)];
          }
        }
        update(t22, e22, r22, n22, i22, s2, o2) {
          this.programConfigurations.updatePaintArrays(t22, e22, i22, r22, n22, s2, o2);
        }
        addFeatures(t22, e22, r22, n22, i22, s2) {
          for (const t3 of this.patternFeatures) this.addFeature(t3, t3.geometry, t3.index, e22, r22, n22, s2);
        }
        isEmpty() {
          return 0 === this.layoutVertexArray.length;
        }
        uploadPending() {
          return !this.uploaded || this.programConfigurations.needsUpload;
        }
        upload(t22) {
          this.uploaded || (0 !== this.layoutVertexArray2.length && (this.layoutVertexBuffer2 = t22.createVertexBuffer(this.layoutVertexArray2, Vf)), 0 !== this.patternVertexArray.length && (this.patternVertexBuffer = t22.createVertexBuffer(this.patternVertexArray, Df)), !this.zOffsetVertexBuffer && this.zOffsetVertexArray.length > 0 && (this.zOffsetVertexBuffer = t22.createVertexBuffer(this.zOffsetVertexArray, Pf.members, true)), this.layoutVertexBuffer = t22.createVertexBuffer(this.layoutVertexArray, Tf), this.indexBuffer = t22.createIndexBuffer(this.indexArray)), this.programConfigurations.upload(t22), this.uploaded = true;
        }
        destroy() {
          this.layoutVertexBuffer && (this.zOffsetVertexBuffer && this.zOffsetVertexBuffer.destroy(), this.layoutVertexBuffer.destroy(), this.indexBuffer.destroy(), this.programConfigurations.destroy(), this.segments.destroy());
        }
        lineFeatureClips(t22) {
          if (t22.properties && t22.properties.hasOwnProperty("mapbox_clip_start") && t22.properties.hasOwnProperty("mapbox_clip_end")) return { start: +t22.properties.mapbox_clip_start, end: +t22.properties.mapbox_clip_end };
        }
        addFeature(t22, e22, r22, n22, i22, s2, o2, a22) {
          const l22 = this.layers[0].layout, u22 = l22.get("line-join").evaluate(t22, {}), c22 = l22.get("line-cap").evaluate(t22, {}), h22 = l22.get("line-miter-limit"), p22 = l22.get("line-round-limit");
          this.lineClips = this.lineFeatureClips(t22), this.lineFeature = t22, this.zOffsetValue = l22.get("line-z-offset").value;
          const f22 = this.layers[0].paint.get("line-width").value;
          if ("constant" !== f22.kind && false === f22.isLineProgressConstant && (this.variableWidthValue = f22), "road" === this.elevationType) {
            const r3 = this.layoutVertexArray.length;
            if (!this.addElevatedRoadFeature(t22, e22, n22, a22, u22, c22, h22, p22)) {
              const [i3, s3] = this.clipRuntimeLinesToTile(e22, 1);
              for (let e3 = 0; e3 < i3.length; e3++) {
                const r4 = i3[e3], o3 = s3[e3], a3 = { progress: { min: o3.progress.min, max: o3.progress.max }, nextDir: this.computeSegNextDir(o3, r4), prevDir: this.computeSegPrevDir(o3, r4) };
                this.addLine(r4, t22, n22, u22, c22, h22, p22, a3);
              }
              this.fillNonElevatedRoadSegment(r3);
            }
          } else for (const r3 of e22) this.addLine(r3, t22, n22, u22, c22, h22, p22);
          this.programConfigurations.populatePaintArrays(this.layoutVertexArray.length, t22, r22, i22, s2, n22, o2);
        }
        computeSegNextDir(t22, e22) {
          return t22.nextPoint.sub(e22.at(-2)).unit();
        }
        computeSegPrevDir(t22, e22) {
          return e22[1].sub(t22.prevPoint).unit();
        }
        clipLinesToTile(t22, e22) {
          return Af(t22, -e22, -e22, Tn + e22, Tn + e22);
        }
        clipRuntimeLinesToTile(t22, e22) {
          const r22 = [];
          return [Af(t22, -e22, -e22, Tn + e22, Tn + e22, r22), r22];
        }
        addElevatedRoadFeature(t22, e22, r22, n22, i22, s2, o2, a22) {
          const l22 = [], u22 = Kh.getElevationFeature(t22, n22);
          if (u22) {
            const t3 = this.clipLinesToTile(e22, 1), n3 = this.prepareElevatedLines(t3, u22, r22);
            for (const t4 of n3) l22.push({ geometry: t4, elevation: u22, elevationTileID: r22, segment: { progress: { min: 0, max: 1 }, nextDir: void 0, prevDir: void 0 } });
          }
          if (0 === l22.length) return false;
          for (const e3 of l22) {
            const n3 = this.layoutVertexArray.length;
            this.addLine(e3.geometry, t22, r22, i22, s2, o2, a22);
            const l3 = new Jh(r22, e3.elevationTileID);
            if (e3.elevation) for (let t3 = n3; t3 < this.layoutVertexArray.length; t3++) {
              const r3 = new bt(this.layoutVertexArray.int16[6 * t3] >> 1, this.layoutVertexArray.int16[6 * t3 + 1] >> 1), n4 = l3.pointElevation(r3, e3.elevation, 0.05);
              this.updateHeightRange(n4), this.zOffsetVertexArray.emplaceBack(n4, 0, 0);
            }
            else this.fillNonElevatedRoadSegment(n3);
          }
          return true;
        }
        prepareElevatedLines(t22, e22, r22) {
          if (null != e22.constantHeight) return t22;
          const n22 = [], i22 = 1 / iu(r22);
          for (const r3 of t22) Mf(r3, new Wh(e22, i22), 0, n22);
          return n22;
        }
        fillNonElevatedRoadSegment(t22) {
          for (let e22 = t22; e22 < this.layoutVertexArray.length; e22++) this.zOffsetVertexArray.emplaceBack(0, 0, 0);
        }
        updateHeightRange(t22) {
          this.heightRange ? (this.heightRange.min = Math.min(this.heightRange.min, t22), this.heightRange.max = Math.max(this.heightRange.max, t22)) : this.heightRange = { min: t22, max: t22 };
        }
        addLine(t22, e22, r22, n22, i22, s2, o2, a22) {
          this.distance = 0, this.prevDistance = 0, this.scaledDistance = 0, this.totalDistance = 0, this.totalFeatureLength = 0, this.lineSoFar = 0, this.currentVertex = void 0;
          const l22 = "none" === n22;
          this.patternJoinNone = this.hasPattern && l22, this.segmentStart = 0, this.segmentStartf32 = 0, this.segmentPoints = [];
          const u22 = a22 && a22.progress.min > 0, c22 = a22 && a22.progress.max < 1;
          if (this.lineClips) {
            let r3 = { min: this.lineClips.start, max: this.lineClips.end }, n3 = 1;
            if (a22) {
              const t3 = this.lineClips.end - this.lineClips.start;
              r3 = function(t4, e3, r4) {
                return { min: ee2(t4.min, e3, r4), max: ee2(t4.max, e3, r4) };
              }(a22.progress, { min: 0, max: 1 }, r3), t3 > 0 && (n3 = (r3.max - r3.min) / t3);
            }
            const i3 = +e22.properties.mapbox_clip_feature_len, s3 = +e22.properties.mapbox_clip_seg_len;
            if (Number.isNaN(i3) || Number.isNaN(s3)) {
              for (let e4 = 0; e4 < t22.length - 1; e4++) this.totalDistance += t22[e4].dist(t22[e4 + 1]);
              const e3 = this.totalDistance / (r3.max - r3.min);
              this.totalFeatureLength = Number.isFinite(e3) ? e3 : 0, this.lineClips.start = r3.min, this.lineClips.end = r3.max, this.maxLineLength = Math.max(this.maxLineLength, this.totalDistance);
            } else this.totalFeatureLength = i3, this.distance = s3 * n3, this.lineClips.start = r3.min, this.lineClips.end = r3.max, this.maxLineLength = Math.max(this.maxLineLength, this.distance);
            this.lineClipsArray.push(this.lineClips), this.updateScaledDistance();
          }
          const h22 = "Polygon" === Lf[e22.type];
          let p22 = t22.length;
          for (; p22 >= 2 && t22[p22 - 1].equals(t22[p22 - 2]); ) p22--;
          let f22 = 0;
          for (; f22 < p22 - 1 && t22[f22].equals(t22[f22 + 1]); ) f22++;
          if (p22 < (h22 ? 3 : 2)) return;
          "bevel" === n22 && (s2 = 1.05);
          const d22 = this.segments.prepareSegment(10 * p22, this.layoutVertexArray, this.indexArray);
          let m22, y22, g22, x22, v22, b22, _22, w22;
          a22 && a22.prevDir && (b22 = a22.prevDir.perp()), a22 && a22.nextDir && (_22 = a22.nextDir.perp()), this.e1 = this.e2 = -1, h22 && (m22 = t22[p22 - 2], v22 = t22[f22].sub(m22)._unit()._perp());
          for (let e3 = f22; e3 < p22; e3++) {
            if (g22 = e3 === p22 - 1 ? h22 ? t22[f22 + 1] : void 0 : t22[e3 + 1], g22 && t22[e3].equals(g22)) continue;
            v22 && (x22 = v22), m22 && (y22 = m22), m22 = t22[e3], w22 = this.evaluateLineProgressFeatures(y22 ? y22.dist(m22) : 0), v22 = g22 ? g22.sub(m22)._unit()._perp() : x22, x22 = x22 || v22;
            const r3 = y22 && g22;
            let a3 = r3 ? n22 : h22 || l22 ? "butt" : i22;
            const A22 = x22.x * v22.x + x22.y * v22.y;
            if (l22) {
              const t3 = function(t4) {
                if (t4.patternJoinNone) {
                  const e4 = t4.segmentPoints.length / 2, r4 = t4.lineSoFar - t4.segmentStart;
                  for (let n3 = 0; n3 < e4; ++n3) {
                    const e5 = t4.segmentPoints[2 * n3 + 1], i3 = Math.round(t4.segmentPoints[2 * n3]) + 0.5 + 0.25 * e5;
                    t4.patternVertexArray.emplaceBack(i3, r4, t4.segmentStart), t4.patternVertexArray.emplaceBack(i3, r4, t4.segmentStart);
                  }
                  t4.segmentPoints.length = 0;
                }
                t4.e1 = t4.e2 = -1;
              };
              if (r3 && A22 < Of) {
                this.updateDistance(y22, m22), this.addCurrentVertex(m22, x22, 1, 1, d22, w22), t3(this), this.addCurrentVertex(m22, v22, -1, -1, d22, w22);
                continue;
              }
              if (y22) {
                if (!g22) {
                  this.updateDistance(y22, m22), this.addCurrentVertex(m22, x22, 1, 1, d22, w22), t3(this);
                  continue;
                }
                a3 = "miter";
              }
            }
            let M22 = x22.add(v22);
            0 === M22.x && 0 === M22.y || M22._unit();
            const I2 = M22.x * v22.x + M22.y * v22.y, S2 = 0 !== I2 ? 1 / I2 : 1 / 0, z22 = 2 * Math.sqrt(2 - 2 * I2), k22 = I2 < Rf && y22 && g22, E22 = x22.x * v22.y - x22.y * v22.x > 0, P22 = this.overscaling <= 16 ? 15 * Tn / (512 * this.overscaling) : 0;
            if (r3 && "round" === a3) {
              if (S2 < o2) a3 = "miter";
              else if (S2 <= 2) {
                const t3 = Nf(m22, -10, Tn + 10);
                a3 = "offset" === this.elevationType && (t3 || this.hasCrossSlope) ? "miter" : "fakeround";
              }
            }
            if ("miter" === a3 && S2 > s2 && (a3 = "bevel"), "bevel" === a3 && (S2 > 2 && (a3 = "flipbevel"), S2 < s2 && (a3 = "miter")), y22 && !("miter" === a3 && k22) && this.updateDistance(y22, m22), "miter" === a3) if (k22) {
              const t3 = m22.dist(y22);
              if (t3 > 2 * P22) {
                const e5 = m22.sub(m22.sub(y22)._mult(P22 / t3)._round());
                this.updateDistance(y22, e5), this.addCurrentVertex(e5, x22, 0, 0, d22, w22), y22 = e5;
              }
              this.updateDistance(y22, m22), M22._mult(S2), this.addCurrentVertex(m22, M22, 0, 0, d22, w22);
              const e4 = m22.dist(g22);
              if (e4 > 2 * P22) {
                const t4 = m22.add(g22.sub(m22)._mult(P22 / e4)._round());
                this.updateDistance(m22, t4), this.addCurrentVertex(t4, v22, 0, 0, d22, w22), m22 = t4;
              }
            } else M22._mult(S2), this.addCurrentVertex(m22, M22, 0, 0, d22, w22);
            else if ("flipbevel" === a3) {
              if (S2 > 100) M22 = v22.mult(-1);
              else {
                const t3 = S2 * x22.add(v22).mag() / x22.sub(v22).mag();
                M22._perp()._mult(t3 * (E22 ? -1 : 1));
              }
              this.addCurrentVertex(m22, M22, 0, 0, d22, w22), this.addCurrentVertex(m22, M22.mult(-1), 0, 0, d22, w22);
            } else if ("bevel" === a3 || "fakeround" === a3) {
              null != w22 && y22 && this.addCurrentVertex(m22, _22 || x22, -1, -1, d22, w22);
              const t3 = m22.dist(y22) <= 2 * P22 && "bevel" !== a3, e4 = M22.mult(E22 ? 1 : -1);
              e4._mult(S2);
              const r4 = v22.mult(E22 ? -1 : 1), n3 = x22.mult(E22 ? -1 : 1), i3 = this.evaluateLineProgressFeatures(this.distance);
              if (null == w22 && (this.addHalfVertex(m22, e4.x, e4.y, false, !E22, 0, d22, i3), t3 || this.addHalfVertex(m22, e4.x + 2 * n3.x, e4.y + 2 * n3.y, false, E22, 0, d22, i3)), "fakeround" === a3) {
                const t4 = Math.round(180 * z22 / Math.PI / 20);
                this.addHalfVertex(m22, n3.x, n3.y, false, E22, 0, d22, i3);
                for (let e5 = 0; e5 < t4; e5++) {
                  let s3 = e5 / t4;
                  if (0.5 !== s3) {
                    const t5 = s3 - 0.5;
                    s3 += s3 * t5 * (s3 - 1) * ((1.0904 + A22 * (A22 * (3.55645 - 1.43519 * A22) - 3.2452)) * t5 * t5 + (0.848013 + A22 * (0.215638 * A22 - 1.06021)));
                  }
                  const o3 = r4.sub(n3)._mult(s3)._add(n3)._unit();
                  this.addHalfVertex(m22, o3.x, o3.y, false, E22, 0, d22, i3);
                }
                this.addHalfVertex(m22, r4.x, r4.y, false, E22, 0, d22, i3);
              }
              t3 || null != w22 || this.addHalfVertex(m22, e4.x + 2 * r4.x, e4.y + 2 * r4.y, false, E22, 0, d22, i3), null != w22 && g22 && this.addCurrentVertex(m22, b22 || v22, 1, 1, d22, w22);
            } else if ("butt" === a3) this.addCurrentVertex(m22, M22, 0, 0, d22, w22);
            else if ("square" === a3) {
              if (!y22) {
                const t3 = u22 ? 0 : -1;
                this.addCurrentVertex(m22, M22, t3, t3, d22, w22);
              }
              if (this.addCurrentVertex(m22, M22, 0, 0, d22, w22), y22) {
                const t3 = c22 ? 0 : 1;
                this.addCurrentVertex(m22, M22, t3, t3, d22, w22);
              }
            } else if ("round" === a3) {
              if (y22) {
                const t3 = !r3 && _22 ? _22 : x22;
                this.addCurrentVertex(m22, t3, 0, 0, d22, w22), !r3 && c22 || this.addCurrentVertex(m22, t3, 1, 1, d22, w22, true);
              }
              if (g22) {
                const t3 = !r3 && b22 ? b22 : v22;
                !r3 && u22 || this.addCurrentVertex(m22, t3, -1, -1, d22, w22, true), this.addCurrentVertex(m22, t3, 0, 0, d22, w22);
              }
            }
          }
        }
        addVerticesTo(t22, e22, r22, n22, i22, s2, o2, a22, l22, u22) {
          const c22 = (e22.w - t22.w) / this.tessellationStep | 0;
          let h22 = 0;
          const p22 = this.scaledDistance;
          if (c22 > 1) {
            this.lineSoFar = t22.w;
            const p3 = (e22.x - t22.x) / c22, f3 = (e22.y - t22.y) / c22, d22 = (e22.z - t22.z) / c22, m22 = (e22.w - t22.w) / c22;
            for (let e3 = 1; e3 < c22; ++e3) {
              t22.x += p3, t22.y += f3, t22.z += d22, this.lineSoFar += m22, h22 += m22;
              const e4 = this.evaluateLineProgressFeatures(this.prevDistance + h22);
              this.scaledDistance = (this.prevDistance + h22) / this.totalDistance, this.addHalfVertex(t22, r22, n22, u22, false, o2, l22, e4), this.addHalfVertex(t22, i22, s2, u22, true, -a22, l22, e4);
            }
          }
          this.lineSoFar = e22.w, this.scaledDistance = p22;
          const f22 = this.evaluateLineProgressFeatures(this.distance);
          this.addHalfVertex(e22, r22, n22, u22, false, o2, l22, f22), this.addHalfVertex(e22, i22, s2, u22, true, -a22, l22, f22);
        }
        evaluateLineProgressFeatures(t22) {
          if (!this.variableWidthValue && "offset" !== this.elevationType) return null;
          this.evaluationGlobals.lineProgress = 0, this.lineClips ? this.evaluationGlobals.lineProgress = Math.min(1, (this.totalFeatureLength * this.lineClips.start + t22) / this.totalFeatureLength) : $t2(`line-progress evaluation for ${this.layerIds[0]} requires enabling 'lineMetrics' for the source.`);
          let e22 = 0;
          return this.variableWidthValue && "constant" !== this.variableWidthValue.kind && (e22 = this.variableWidthValue.evaluate(this.evaluationGlobals, this.lineFeature) || 0), "offset" !== this.elevationType ? { zOffset: 0, variableWidth: e22 } : "constant" === this.zOffsetValue.kind ? { zOffset: this.zOffsetValue.value, variableWidth: e22 } : { zOffset: this.zOffsetValue.evaluate(this.evaluationGlobals, this.lineFeature) || 0, variableWidth: e22 };
        }
        addCurrentVertex(t22, e22, r22, n22, i22, s2, o2 = false) {
          const a22 = e22.x + e22.y * r22, l22 = e22.y - e22.x * r22, u22 = e22.y * n22 - e22.x, c22 = -e22.y - e22.x * n22;
          if (null != s2) {
            const e3 = "offset" === this.elevationType, h22 = -10, p22 = Tn + 10, f22 = s2.zOffset, d22 = new bf(t22.x, t22.y, f22, this.lineSoFar), m22 = !!e3 && Nf(t22, h22, p22), y22 = this.lineSoFar, g22 = this.distance;
            if (this.currentVertex) if (m22) {
              const e4 = this.currentVertexIsOutside, s3 = this.currentVertex, m3 = new bf(t22.x, t22.y, f22, this.lineSoFar);
              if (wf(s3, m3, h22, p22), !Nf(m3, h22, p22)) {
                if (e4) {
                  this.e1 = this.e2 = -1, this.distance -= s3.dist(d22), this.lineSoFar = s3.w;
                  const t3 = this.evaluateLineProgressFeatures(s3.w - this.totalFeatureLength * (this.lineClips ? this.lineClips.start : 0));
                  this.addHalfVertex(s3, a22, l22, o2, false, r22, i22, t3), this.addHalfVertex(s3, u22, c22, o2, true, -n22, i22, t3), this.prevDistance = this.distance;
                }
                this.distance = this.prevDistance + s3.dist(m3), this.scaledDistance = this.distance / this.totalDistance, this.addVerticesTo(s3, m3, a22, l22, u22, c22, r22, n22, i22, o2), this.distance = g22, this.scaledDistance = this.distance / this.totalDistance;
              }
            } else {
              const t3 = this.currentVertex;
              if (this.currentVertexIsOutside) {
                wf(t3, d22, h22, p22), this.e1 = this.e2 = -1, this.distance -= t3.dist(d22), this.scaledDistance = this.distance / this.totalDistance, this.lineSoFar = t3.w;
                const e4 = this.evaluateLineProgressFeatures(t3.w - this.totalFeatureLength * (this.lineClips ? this.lineClips.start : 0));
                this.addHalfVertex(t3, a22, l22, o2, false, r22, i22, e4), this.addHalfVertex(t3, u22, c22, o2, true, -n22, i22, e4), this.prevDistance = this.distance, this.distance = g22, this.scaledDistance = this.distance / this.totalDistance;
              }
              this.addVerticesTo(t3, d22, a22, l22, u22, c22, r22, n22, i22, o2);
            }
            else m22 || (this.addHalfVertex(t22, a22, l22, o2, false, r22, i22, s2), this.addHalfVertex(t22, u22, c22, o2, true, -n22, i22, s2));
            this.currentVertex = d22, this.currentVertexIsOutside = m22, this.lineSoFar = y22;
          } else this.addHalfVertex(t22, a22, l22, o2, false, r22, i22, s2), this.addHalfVertex(t22, u22, c22, o2, true, -n22, i22, s2);
        }
        addHalfVertex({ x: t22, y: e22 }, r22, n22, i22, s2, o2, a22, l22) {
          if (this.patternJoinNone && (0 === this.segmentPoints.length && (this.segmentStart = this.lineSoFar, this.segmentStartf32 = Math.fround(this.lineSoFar)), s2 || this.segmentPoints.push(this.lineSoFar - this.segmentStart, o2)), this.layoutVertexArray.emplaceBack((t22 << 1) + (i22 ? 1 : 0), (e22 << 1) + (s2 ? 1 : 0), Math.round(63 * r22) + 128, Math.round(63 * n22) + 128, 1 + (0 === o2 ? 0 : o2 < 0 ? -1 : 1), 0, this.lineSoFar - this.segmentStartf32), this.lineClips) {
            const t3 = or(this.lineClips.start, this.lineClips.end, this.scaledDistance);
            this.layoutVertexArray2.emplaceBack(this.scaledDistance, this.lineClipsArray.length, t3);
          }
          const u22 = a22.vertexLength++;
          this.e1 >= 0 && this.e2 >= 0 && (this.indexArray.emplaceBack(this.e1, this.e2, u22), a22.primitiveLength++), s2 ? this.e2 = u22 : this.e1 = u22, null != l22 && this.zOffsetVertexArray.emplaceBack(l22.zOffset, l22.variableWidth, l22.variableWidth);
        }
        updateScaledDistance() {
          this.lineClips ? (this.scaledDistance = this.distance / this.totalDistance, this.lineSoFar = this.totalFeatureLength * this.lineClips.start + this.distance) : this.lineSoFar = this.distance;
        }
        updateDistance(t22, e22) {
          this.prevDistance = this.distance, this.distance += t22.dist(e22), this.updateScaledDistance();
        }
      }
      function Nf(t22, e22, r22) {
        return t22.x < e22 || t22.x > r22 || t22.y < e22 || t22.y > r22;
      }
      let jf, $f;
      function Gf(t22, e22, r22) {
        return e22 * (Tn / (t22.tileSize * Math.pow(2, r22 - t22.tileID.overscaledZ)));
      }
      js(Uf, "LineBucket", { omit: ["layers", "patternFeatures", "currentVertex", "currentVertexIsOutside"] });
      const qf = (t22, e22, r22) => (1 - r22) * t22 + r22 * e22;
      function Hf(t22, e22) {
        return 1 / Gf(t22, 1, e22.tileZoom);
      }
      function Xf(t22, e22, r22, n22) {
        return t22.translatePosMatrix(n22 || e22.tileID.projMatrix, e22, r22.paint.get("line-translate"), r22.paint.get("line-translate-anchor"));
      }
      const Zf = (t22) => {
        const e22 = [];
        Wf(t22) && e22.push("RENDER_LINE_DASH"), t22.paint.get("line-gradient") && e22.push("RENDER_LINE_GRADIENT");
        const r22 = t22.paint.get("line-trim-offset");
        0 === r22[0] && 0 === r22[1] || e22.push("RENDER_LINE_TRIM_OFFSET"), 0 !== t22.paint.get("line-border-width").constantOr(1) && e22.push("RENDER_LINE_BORDER");
        const n22 = "none" === t22.layout.get("line-join").constantOr("miter"), i22 = !!t22.paint.get("line-pattern").constantOr(1);
        return n22 && i22 && e22.push("LINE_JOIN_NONE"), e22;
      };
      function Wf(t22) {
        const e22 = t22.paint.get("line-dasharray").value;
        return e22.value || "constant" !== e22.kind;
      }
      let Yf;
      const Kf = () => Yf || (Yf = { layout: jf || (jf = new ko({ "line-cap": new So(Eo.layout_line["line-cap"]), "line-join": new So(Eo.layout_line["line-join"]), "line-miter-limit": new Io(Eo.layout_line["line-miter-limit"]), "line-round-limit": new Io(Eo.layout_line["line-round-limit"]), "line-sort-key": new So(Eo.layout_line["line-sort-key"]), "line-z-offset": new So(Eo.layout_line["line-z-offset"]), "line-elevation-reference": new Io(Eo.layout_line["line-elevation-reference"]), "line-cross-slope": new Io(Eo.layout_line["line-cross-slope"]), visibility: new Io(Eo.layout_line.visibility), "line-width-unit": new Io(Eo.layout_line["line-width-unit"]) })), paint: $f || ($f = new ko({ "line-opacity": new So(Eo.paint_line["line-opacity"]), "line-color": new So(Eo.paint_line["line-color"]), "line-translate": new Io(Eo.paint_line["line-translate"]), "line-translate-anchor": new Io(Eo.paint_line["line-translate-anchor"]), "line-width": new So(Eo.paint_line["line-width"]), "line-gap-width": new So(Eo.paint_line["line-gap-width"]), "line-offset": new So(Eo.paint_line["line-offset"]), "line-blur": new So(Eo.paint_line["line-blur"]), "line-dasharray": new So(Eo.paint_line["line-dasharray"]), "line-pattern": new So(Eo.paint_line["line-pattern"]), "line-pattern-cross-fade": new Io(Eo.paint_line["line-pattern-cross-fade"]), "line-gradient": new zo(Eo.paint_line["line-gradient"]), "line-trim-offset": new Io(Eo.paint_line["line-trim-offset"]), "line-trim-fade-range": new Io(Eo.paint_line["line-trim-fade-range"]), "line-trim-color": new Io(Eo.paint_line["line-trim-color"]), "line-emissive-strength": new Io(Eo.paint_line["line-emissive-strength"]), "line-border-width": new So(Eo.paint_line["line-border-width"]), "line-border-color": new So(Eo.paint_line["line-border-color"]), "line-occlusion-opacity": new Io(Eo.paint_line["line-occlusion-opacity"]), "line-color-use-theme": new So({ type: "string", default: "default", "property-type": "data-driven" }), "line-gradient-use-theme": new So({ type: "string", default: "default", "property-type": "data-driven" }), "line-trim-color-use-theme": new So({ type: "string", default: "default", "property-type": "data-driven" }), "line-border-color-use-theme": new So({ type: "string", default: "default", "property-type": "data-driven" }) })) }, Yf);
      class Jf extends So {
        possiblyEvaluate(t22, e22) {
          return e22 = new yo(Math.floor(e22.zoom), { now: e22.now, fadeDuration: e22.fadeDuration, transition: e22.transition }), super.possiblyEvaluate(t22, e22);
        }
        evaluate(t22, e22, r22, n22) {
          return e22 = Ct2({}, e22, { zoom: Math.floor(e22.zoom) }), super.evaluate(t22, e22, r22, n22);
        }
      }
      let Qf;
      function td(t22, e22) {
        return e22 > 0 ? e22 + 2 * t22 : t22;
      }
      const ed = Qo([{ name: "a_pos_offset", components: 4, type: "Int16" }, { name: "a_tex_size", components: 4, type: "Uint16" }, { name: "a_pixeloffset", components: 4, type: "Int16" }], 4), rd = Qo([{ name: "a_globe_anchor", components: 3, type: "Int16" }, { name: "a_globe_normal", components: 3, type: "Float32" }], 4), nd = Qo([{ name: "a_projected_pos", components: 4, type: "Float32" }], 4);
      Qo([{ name: "a_fade_opacity", components: 1, type: "Uint32" }], 4);
      const id2 = Qo([{ name: "a_auto_z_offset", components: 1, type: "Float32" }], 4), sd = Qo([{ name: "a_texb", components: 2, type: "Uint16" }]), od = Qo([{ name: "a_placed", components: 2, type: "Uint8" }, { name: "a_shift", components: 2, type: "Float32" }, { name: "a_elevation_from_sea", components: 2, type: "Float32" }]), ad = Qo([{ name: "a_size_scale", components: 1, type: "Float32" }, { name: "a_padding", components: 2, type: "Float32" }, { name: "a_auto_z_offset", components: 1, type: "Float32" }]);
      Qo([{ type: "Int16", name: "projectedAnchorX" }, { type: "Int16", name: "projectedAnchorY" }, { type: "Int16", name: "projectedAnchorZ" }, { type: "Int16", name: "tileAnchorX" }, { type: "Int16", name: "tileAnchorY" }, { type: "Float32", name: "x1" }, { type: "Float32", name: "y1" }, { type: "Float32", name: "x2" }, { type: "Float32", name: "y2" }, { type: "Int16", name: "padding" }, { type: "Uint32", name: "featureIndex" }, { type: "Uint16", name: "sourceLayerIndex" }, { type: "Uint16", name: "bucketIndex" }]);
      const ld = Qo([{ name: "a_pos", components: 3, type: "Int16" }, { name: "a_anchor_pos", components: 2, type: "Int16" }, { name: "a_extrude", components: 2, type: "Int16" }], 4), ud = Qo([{ name: "a_pos_2f", components: 2, type: "Float32" }, { name: "a_radius", components: 1, type: "Float32" }, { name: "a_flags", components: 2, type: "Int16" }], 4);
      Qo([{ name: "triangle", components: 3, type: "Uint16" }]), Qo([{ type: "Int16", name: "projectedAnchorX" }, { type: "Int16", name: "projectedAnchorY" }, { type: "Int16", name: "projectedAnchorZ" }, { type: "Float32", name: "tileAnchorX" }, { type: "Float32", name: "tileAnchorY" }, { type: "Uint16", name: "glyphStartIndex" }, { type: "Uint16", name: "numGlyphs" }, { type: "Uint32", name: "vertexStartIndex" }, { type: "Uint32", name: "lineStartIndex" }, { type: "Uint32", name: "lineLength" }, { type: "Uint16", name: "segment" }, { type: "Uint16", name: "lowerSize" }, { type: "Uint16", name: "upperSize" }, { type: "Float32", name: "lineOffsetX" }, { type: "Float32", name: "lineOffsetY" }, { type: "Uint8", name: "writingMode" }, { type: "Uint8", name: "placedOrientation" }, { type: "Uint8", name: "hidden" }, { type: "Uint32", name: "crossTileID" }, { type: "Int16", name: "associatedIconIndex" }, { type: "Uint8", name: "flipState" }]), Qo([{ type: "Float32", name: "tileAnchorX" }, { type: "Float32", name: "tileAnchorY" }, { type: "Int16", name: "projectedAnchorX" }, { type: "Int16", name: "projectedAnchorY" }, { type: "Int16", name: "projectedAnchorZ" }, { type: "Int16", name: "rightJustifiedTextSymbolIndex" }, { type: "Int16", name: "centerJustifiedTextSymbolIndex" }, { type: "Int16", name: "leftJustifiedTextSymbolIndex" }, { type: "Int16", name: "verticalPlacedTextSymbolIndex" }, { type: "Int16", name: "placedIconSymbolIndex" }, { type: "Int16", name: "verticalPlacedIconSymbolIndex" }, { type: "Uint16", name: "key" }, { type: "Uint16", name: "textBoxStartIndex" }, { type: "Uint16", name: "textBoxEndIndex" }, { type: "Uint16", name: "verticalTextBoxStartIndex" }, { type: "Uint16", name: "verticalTextBoxEndIndex" }, { type: "Uint16", name: "iconBoxStartIndex" }, { type: "Uint16", name: "iconBoxEndIndex" }, { type: "Uint16", name: "verticalIconBoxStartIndex" }, { type: "Uint16", name: "verticalIconBoxEndIndex" }, { type: "Uint16", name: "featureIndex" }, { type: "Uint16", name: "numHorizontalGlyphVertices" }, { type: "Uint16", name: "numVerticalGlyphVertices" }, { type: "Uint16", name: "numIconVertices" }, { type: "Uint16", name: "numVerticalIconVertices" }, { type: "Uint16", name: "useRuntimeCollisionCircles" }, { type: "Uint32", name: "crossTileID" }, { type: "Float32", components: 2, name: "textOffset" }, { type: "Float32", name: "collisionCircleDiameter" }, { type: "Float32", name: "zOffset" }, { type: "Uint8", name: "hasIconTextFit" }, { type: "Uint16", name: "elevationFeatureIndex" }]), Qo([{ type: "Float32", name: "offsetX" }]), Qo([{ type: "Int16", name: "x" }, { type: "Int16", name: "y" }]);
      var cd = 24;
      function hd(t22, e22, r22) {
        return t22.sections.forEach((t3) => {
          t3.text = function(t4, e3, r3) {
            const n22 = e3.layout.get("text-transform").evaluate(r3, {});
            return "uppercase" === n22 ? t4 = t4.toLocaleUpperCase() : "lowercase" === n22 && (t4 = t4.toLocaleLowerCase()), mo.applyArabicShaping && (t4 = mo.applyArabicShaping(t4)), t4;
          }(t3.text, e22, r22);
        }), t22;
      }
      const pd = { "!": "︕", "#": "＃", $: "＄", "%": "％", "&": "＆", "(": "︵", ")": "︶", "*": "＊", "+": "＋", ",": "︐", "-": "︲", ".": "・", "/": "／", ":": "︓", ";": "︔", "<": "︿", "=": "＝", ">": "﹀", "?": "︖", "@": "＠", "[": "﹇", "\\": "＼", "]": "﹈", "^": "＾", _: "︳", "`": "｀", "{": "︷", "|": "―", "}": "︸", "~": "～", "¢": "￠", "£": "￡", "¥": "￥", "¦": "￤", "¬": "￢", "¯": "￣", "–": "︲", "—": "︱", "‘": "﹃", "’": "﹄", "“": "﹁", "”": "﹂", "…": "︙", "‧": "・", "₩": "￦", "、": "︑", "。": "︒", "〈": "︿", "〉": "﹀", "《": "︽", "》": "︾", "「": "﹁", "」": "﹂", "『": "﹃", "』": "﹄", "【": "︻", "】": "︼", "〔": "︹", "〕": "︺", "〖": "︗", "〗": "︘", "！": "︕", "（": "︵", "）": "︶", "，": "︐", "－": "︲", "．": "・", "：": "︓", "；": "︔", "＜": "︿", "＞": "﹀", "？": "︖", "［": "﹇", "］": "﹈", "＿": "︳", "｛": "︷", "｜": "―", "｝": "︸", "｟": "︵", "｠": "︶", "｡": "︒", "｢": "﹁", "｣": "﹂", "←": "↑", "→": "↓" };
      function fd(t22) {
        return "︶" === t22 || "﹈" === t22 || "︸" === t22 || "﹄" === t22 || "﹂" === t22 || "︾" === t22 || "︼" === t22 || "︺" === t22 || "︘" === t22 || "﹀" === t22 || "︐" === t22 || "︓" === t22 || "︔" === t22 || "｀" === t22 || "￣" === t22 || "︑" === t22 || "︒" === t22;
      }
      function dd(t22) {
        return "︵" === t22 || "﹇" === t22 || "︷" === t22 || "﹃" === t22 || "﹁" === t22 || "︽" === t22 || "︻" === t22 || "︹" === t22 || "︗" === t22 || "︿" === t22;
      }
      var md, yd, gd, xd = {};
      /*! ieee754. BSD-3-Clause License. Feross Aboukhadijeh <https://feross.org/opensource> */
      function vd() {
        return md || (md = 1, xd.read = function(t22, e22, r22, n22, i22) {
          var s2, o2, a22 = 8 * i22 - n22 - 1, l22 = (1 << a22) - 1, u22 = l22 >> 1, c22 = -7, h22 = r22 ? i22 - 1 : 0, p22 = r22 ? -1 : 1, f22 = t22[e22 + h22];
          for (h22 += p22, s2 = f22 & (1 << -c22) - 1, f22 >>= -c22, c22 += a22; c22 > 0; s2 = 256 * s2 + t22[e22 + h22], h22 += p22, c22 -= 8) ;
          for (o2 = s2 & (1 << -c22) - 1, s2 >>= -c22, c22 += n22; c22 > 0; o2 = 256 * o2 + t22[e22 + h22], h22 += p22, c22 -= 8) ;
          if (0 === s2) s2 = 1 - u22;
          else {
            if (s2 === l22) return o2 ? NaN : 1 / 0 * (f22 ? -1 : 1);
            o2 += Math.pow(2, n22), s2 -= u22;
          }
          return (f22 ? -1 : 1) * o2 * Math.pow(2, s2 - n22);
        }, xd.write = function(t22, e22, r22, n22, i22, s2) {
          var o2, a22, l22, u22 = 8 * s2 - i22 - 1, c22 = (1 << u22) - 1, h22 = c22 >> 1, p22 = 23 === i22 ? Math.pow(2, -24) - Math.pow(2, -77) : 0, f22 = n22 ? 0 : s2 - 1, d22 = n22 ? 1 : -1, m22 = e22 < 0 || 0 === e22 && 1 / e22 < 0 ? 1 : 0;
          for (e22 = Math.abs(e22), isNaN(e22) || e22 === 1 / 0 ? (a22 = isNaN(e22) ? 1 : 0, o2 = c22) : (o2 = Math.floor(Math.log(e22) / Math.LN2), e22 * (l22 = Math.pow(2, -o2)) < 1 && (o2--, l22 *= 2), (e22 += o2 + h22 >= 1 ? p22 / l22 : p22 * Math.pow(2, 1 - h22)) * l22 >= 2 && (o2++, l22 /= 2), o2 + h22 >= c22 ? (a22 = 0, o2 = c22) : o2 + h22 >= 1 ? (a22 = (e22 * l22 - 1) * Math.pow(2, i22), o2 += h22) : (a22 = e22 * Math.pow(2, h22 - 1) * Math.pow(2, i22), o2 = 0)); i22 >= 8; t22[r22 + f22] = 255 & a22, f22 += d22, a22 /= 256, i22 -= 8) ;
          for (o2 = o2 << i22 | a22, u22 += i22; u22 > 0; t22[r22 + f22] = 255 & o2, f22 += d22, o2 /= 256, u22 -= 8) ;
          t22[r22 + f22 - d22] |= 128 * m22;
        }), xd;
      }
      function bd() {
        if (gd) return yd;
        gd = 1, yd = e22;
        var t22 = vd();
        function e22(t3) {
          this.buf = ArrayBuffer.isView && ArrayBuffer.isView(t3) ? t3 : new Uint8Array(t3 || 0), this.pos = 0, this.type = 0, this.length = this.buf.length;
        }
        e22.Varint = 0, e22.Fixed64 = 1, e22.Bytes = 2, e22.Fixed32 = 5;
        var r22 = 4294967296, n22 = 1 / r22, i22 = "undefined" == typeof TextDecoder ? null : new TextDecoder("utf8");
        function s2(t3) {
          return t3.type === e22.Bytes ? t3.readVarint() + t3.pos : t3.pos + 1;
        }
        function o2(t3, e3, r3) {
          return r3 ? 4294967296 * e3 + (t3 >>> 0) : 4294967296 * (e3 >>> 0) + (t3 >>> 0);
        }
        function a22(t3, e3, r3) {
          var n3 = e3 <= 16383 ? 1 : e3 <= 2097151 ? 2 : e3 <= 268435455 ? 3 : Math.floor(Math.log(e3) / (7 * Math.LN2));
          r3.realloc(n3);
          for (var i3 = r3.pos - 1; i3 >= t3; i3--) r3.buf[i3 + n3] = r3.buf[i3];
        }
        function l22(t3, e3) {
          for (var r3 = 0; r3 < t3.length; r3++) e3.writeVarint(t3[r3]);
        }
        function u22(t3, e3) {
          for (var r3 = 0; r3 < t3.length; r3++) e3.writeSVarint(t3[r3]);
        }
        function c22(t3, e3) {
          for (var r3 = 0; r3 < t3.length; r3++) e3.writeFloat(t3[r3]);
        }
        function h22(t3, e3) {
          for (var r3 = 0; r3 < t3.length; r3++) e3.writeDouble(t3[r3]);
        }
        function p22(t3, e3) {
          for (var r3 = 0; r3 < t3.length; r3++) e3.writeBoolean(t3[r3]);
        }
        function f22(t3, e3) {
          for (var r3 = 0; r3 < t3.length; r3++) e3.writeFixed32(t3[r3]);
        }
        function d22(t3, e3) {
          for (var r3 = 0; r3 < t3.length; r3++) e3.writeSFixed32(t3[r3]);
        }
        function m22(t3, e3) {
          for (var r3 = 0; r3 < t3.length; r3++) e3.writeFixed64(t3[r3]);
        }
        function y22(t3, e3) {
          for (var r3 = 0; r3 < t3.length; r3++) e3.writeSFixed64(t3[r3]);
        }
        function g22(t3, e3) {
          return (t3[e3] | t3[e3 + 1] << 8 | t3[e3 + 2] << 16) + 16777216 * t3[e3 + 3];
        }
        function x22(t3, e3, r3) {
          t3[r3] = e3, t3[r3 + 1] = e3 >>> 8, t3[r3 + 2] = e3 >>> 16, t3[r3 + 3] = e3 >>> 24;
        }
        function v22(t3, e3) {
          return (t3[e3] | t3[e3 + 1] << 8 | t3[e3 + 2] << 16) + (t3[e3 + 3] << 24);
        }
        return e22.prototype = { destroy: function() {
          this.buf = null;
        }, readFields: function(t3, e3, r3) {
          for (r3 = r3 || this.length; this.pos < r3; ) {
            var n3 = this.readVarint(), i3 = n3 >> 3, s3 = this.pos;
            this.type = 7 & n3, t3(i3, e3, this), this.pos === s3 && this.skip(n3);
          }
          return e3;
        }, readMessage: function(t3, e3) {
          return this.readFields(t3, e3, this.readVarint() + this.pos);
        }, readFixed32: function() {
          var t3 = g22(this.buf, this.pos);
          return this.pos += 4, t3;
        }, readSFixed32: function() {
          var t3 = v22(this.buf, this.pos);
          return this.pos += 4, t3;
        }, readFixed64: function() {
          var t3 = g22(this.buf, this.pos) + g22(this.buf, this.pos + 4) * r22;
          return this.pos += 8, t3;
        }, readSFixed64: function() {
          var t3 = g22(this.buf, this.pos) + v22(this.buf, this.pos + 4) * r22;
          return this.pos += 8, t3;
        }, readFloat: function() {
          var e3 = t22.read(this.buf, this.pos, true, 23, 4);
          return this.pos += 4, e3;
        }, readDouble: function() {
          var e3 = t22.read(this.buf, this.pos, true, 52, 8);
          return this.pos += 8, e3;
        }, readVarint: function(t3) {
          var e3, r3, n3 = this.buf;
          return e3 = 127 & (r3 = n3[this.pos++]), r3 < 128 ? e3 : (e3 |= (127 & (r3 = n3[this.pos++])) << 7, r3 < 128 ? e3 : (e3 |= (127 & (r3 = n3[this.pos++])) << 14, r3 < 128 ? e3 : (e3 |= (127 & (r3 = n3[this.pos++])) << 21, r3 < 128 ? e3 : function(t4, e4, r4) {
            var n4, i3, s3 = r4.buf;
            if (n4 = (112 & (i3 = s3[r4.pos++])) >> 4, i3 < 128) return o2(t4, n4, e4);
            if (n4 |= (127 & (i3 = s3[r4.pos++])) << 3, i3 < 128) return o2(t4, n4, e4);
            if (n4 |= (127 & (i3 = s3[r4.pos++])) << 10, i3 < 128) return o2(t4, n4, e4);
            if (n4 |= (127 & (i3 = s3[r4.pos++])) << 17, i3 < 128) return o2(t4, n4, e4);
            if (n4 |= (127 & (i3 = s3[r4.pos++])) << 24, i3 < 128) return o2(t4, n4, e4);
            if (n4 |= (1 & (i3 = s3[r4.pos++])) << 31, i3 < 128) return o2(t4, n4, e4);
            throw new Error("Expected varint not more than 10 bytes");
          }(e3 |= (15 & (r3 = n3[this.pos])) << 28, t3, this))));
        }, readVarint64: function() {
          return this.readVarint(true);
        }, readSVarint: function() {
          var t3 = this.readVarint();
          return t3 % 2 == 1 ? (t3 + 1) / -2 : t3 / 2;
        }, readBoolean: function() {
          return Boolean(this.readVarint());
        }, readString: function() {
          var t3 = this.readVarint() + this.pos, e3 = this.pos;
          return this.pos = t3, t3 - e3 >= 12 && i22 ? function(t4, e4, r3) {
            return i22.decode(t4.subarray(e4, r3));
          }(this.buf, e3, t3) : function(t4, e4, r3) {
            for (var n3 = "", i3 = e4; i3 < r3; ) {
              var s3, o3, a3, l3 = t4[i3], u3 = null, c3 = l3 > 239 ? 4 : l3 > 223 ? 3 : l3 > 191 ? 2 : 1;
              if (i3 + c3 > r3) break;
              1 === c3 ? l3 < 128 && (u3 = l3) : 2 === c3 ? 128 == (192 & (s3 = t4[i3 + 1])) && (u3 = (31 & l3) << 6 | 63 & s3) <= 127 && (u3 = null) : 3 === c3 ? (o3 = t4[i3 + 2], 128 == (192 & (s3 = t4[i3 + 1])) && 128 == (192 & o3) && ((u3 = (15 & l3) << 12 | (63 & s3) << 6 | 63 & o3) <= 2047 || u3 >= 55296 && u3 <= 57343) && (u3 = null)) : 4 === c3 && (o3 = t4[i3 + 2], a3 = t4[i3 + 3], 128 == (192 & (s3 = t4[i3 + 1])) && 128 == (192 & o3) && 128 == (192 & a3) && ((u3 = (15 & l3) << 18 | (63 & s3) << 12 | (63 & o3) << 6 | 63 & a3) <= 65535 || u3 >= 1114112) && (u3 = null)), null === u3 ? (u3 = 65533, c3 = 1) : u3 > 65535 && (u3 -= 65536, n3 += String.fromCharCode(u3 >>> 10 & 1023 | 55296), u3 = 56320 | 1023 & u3), n3 += String.fromCharCode(u3), i3 += c3;
            }
            return n3;
          }(this.buf, e3, t3);
        }, readBytes: function() {
          var t3 = this.readVarint() + this.pos, e3 = this.buf.subarray(this.pos, t3);
          return this.pos = t3, e3;
        }, readPackedVarint: function(t3, r3) {
          if (this.type !== e22.Bytes) return t3.push(this.readVarint(r3));
          var n3 = s2(this);
          for (t3 = t3 || []; this.pos < n3; ) t3.push(this.readVarint(r3));
          return t3;
        }, readPackedSVarint: function(t3) {
          if (this.type !== e22.Bytes) return t3.push(this.readSVarint());
          var r3 = s2(this);
          for (t3 = t3 || []; this.pos < r3; ) t3.push(this.readSVarint());
          return t3;
        }, readPackedBoolean: function(t3) {
          if (this.type !== e22.Bytes) return t3.push(this.readBoolean());
          var r3 = s2(this);
          for (t3 = t3 || []; this.pos < r3; ) t3.push(this.readBoolean());
          return t3;
        }, readPackedFloat: function(t3) {
          if (this.type !== e22.Bytes) return t3.push(this.readFloat());
          var r3 = s2(this);
          for (t3 = t3 || []; this.pos < r3; ) t3.push(this.readFloat());
          return t3;
        }, readPackedDouble: function(t3) {
          if (this.type !== e22.Bytes) return t3.push(this.readDouble());
          var r3 = s2(this);
          for (t3 = t3 || []; this.pos < r3; ) t3.push(this.readDouble());
          return t3;
        }, readPackedFixed32: function(t3) {
          if (this.type !== e22.Bytes) return t3.push(this.readFixed32());
          var r3 = s2(this);
          for (t3 = t3 || []; this.pos < r3; ) t3.push(this.readFixed32());
          return t3;
        }, readPackedSFixed32: function(t3) {
          if (this.type !== e22.Bytes) return t3.push(this.readSFixed32());
          var r3 = s2(this);
          for (t3 = t3 || []; this.pos < r3; ) t3.push(this.readSFixed32());
          return t3;
        }, readPackedFixed64: function(t3) {
          if (this.type !== e22.Bytes) return t3.push(this.readFixed64());
          var r3 = s2(this);
          for (t3 = t3 || []; this.pos < r3; ) t3.push(this.readFixed64());
          return t3;
        }, readPackedSFixed64: function(t3) {
          if (this.type !== e22.Bytes) return t3.push(this.readSFixed64());
          var r3 = s2(this);
          for (t3 = t3 || []; this.pos < r3; ) t3.push(this.readSFixed64());
          return t3;
        }, skip: function(t3) {
          var r3 = 7 & t3;
          if (r3 === e22.Varint) for (; this.buf[this.pos++] > 127; ) ;
          else if (r3 === e22.Bytes) this.pos = this.readVarint() + this.pos;
          else if (r3 === e22.Fixed32) this.pos += 4;
          else {
            if (r3 !== e22.Fixed64) throw new Error("Unimplemented type: " + r3);
            this.pos += 8;
          }
        }, writeTag: function(t3, e3) {
          this.writeVarint(t3 << 3 | e3);
        }, realloc: function(t3) {
          for (var e3 = this.length || 16; e3 < this.pos + t3; ) e3 *= 2;
          if (e3 !== this.length) {
            var r3 = new Uint8Array(e3);
            r3.set(this.buf), this.buf = r3, this.length = e3;
          }
        }, finish: function() {
          return this.length = this.pos, this.pos = 0, this.buf.subarray(0, this.length);
        }, writeFixed32: function(t3) {
          this.realloc(4), x22(this.buf, t3, this.pos), this.pos += 4;
        }, writeSFixed32: function(t3) {
          this.realloc(4), x22(this.buf, t3, this.pos), this.pos += 4;
        }, writeFixed64: function(t3) {
          this.realloc(8), x22(this.buf, -1 & t3, this.pos), x22(this.buf, Math.floor(t3 * n22), this.pos + 4), this.pos += 8;
        }, writeSFixed64: function(t3) {
          this.realloc(8), x22(this.buf, -1 & t3, this.pos), x22(this.buf, Math.floor(t3 * n22), this.pos + 4), this.pos += 8;
        }, writeVarint: function(t3) {
          (t3 = +t3 || 0) > 268435455 || t3 < 0 ? function(t4, e3) {
            var r3, n3;
            if (t4 >= 0 ? (r3 = t4 % 4294967296 | 0, n3 = t4 / 4294967296 | 0) : (n3 = ~(-t4 / 4294967296), 4294967295 ^ (r3 = ~(-t4 % 4294967296)) ? r3 = r3 + 1 | 0 : (r3 = 0, n3 = n3 + 1 | 0)), t4 >= 18446744073709552e3 || t4 < -18446744073709552e3) throw new Error("Given varint doesn't fit into 10 bytes");
            e3.realloc(10), function(t5, e4, r4) {
              r4.buf[r4.pos++] = 127 & t5 | 128, t5 >>>= 7, r4.buf[r4.pos++] = 127 & t5 | 128, t5 >>>= 7, r4.buf[r4.pos++] = 127 & t5 | 128, t5 >>>= 7, r4.buf[r4.pos++] = 127 & t5 | 128, r4.buf[r4.pos] = 127 & (t5 >>>= 7);
            }(r3, 0, e3), function(t5, e4) {
              var r4 = (7 & t5) << 4;
              e4.buf[e4.pos++] |= r4 | ((t5 >>>= 3) ? 128 : 0), t5 && (e4.buf[e4.pos++] = 127 & t5 | ((t5 >>>= 7) ? 128 : 0), t5 && (e4.buf[e4.pos++] = 127 & t5 | ((t5 >>>= 7) ? 128 : 0), t5 && (e4.buf[e4.pos++] = 127 & t5 | ((t5 >>>= 7) ? 128 : 0), t5 && (e4.buf[e4.pos++] = 127 & t5 | ((t5 >>>= 7) ? 128 : 0), t5 && (e4.buf[e4.pos++] = 127 & t5)))));
            }(n3, e3);
          }(t3, this) : (this.realloc(4), this.buf[this.pos++] = 127 & t3 | (t3 > 127 ? 128 : 0), t3 <= 127 || (this.buf[this.pos++] = 127 & (t3 >>>= 7) | (t3 > 127 ? 128 : 0), t3 <= 127 || (this.buf[this.pos++] = 127 & (t3 >>>= 7) | (t3 > 127 ? 128 : 0), t3 <= 127 || (this.buf[this.pos++] = t3 >>> 7 & 127))));
        }, writeSVarint: function(t3) {
          this.writeVarint(t3 < 0 ? 2 * -t3 - 1 : 2 * t3);
        }, writeBoolean: function(t3) {
          this.writeVarint(Boolean(t3));
        }, writeString: function(t3) {
          t3 = String(t3), this.realloc(4 * t3.length), this.pos++;
          var e3 = this.pos;
          this.pos = function(t4, e4, r4) {
            for (var n3, i3, s3 = 0; s3 < e4.length; s3++) {
              if ((n3 = e4.charCodeAt(s3)) > 55295 && n3 < 57344) {
                if (!i3) {
                  n3 > 56319 || s3 + 1 === e4.length ? (t4[r4++] = 239, t4[r4++] = 191, t4[r4++] = 189) : i3 = n3;
                  continue;
                }
                if (n3 < 56320) {
                  t4[r4++] = 239, t4[r4++] = 191, t4[r4++] = 189, i3 = n3;
                  continue;
                }
                n3 = i3 - 55296 << 10 | n3 - 56320 | 65536, i3 = null;
              } else i3 && (t4[r4++] = 239, t4[r4++] = 191, t4[r4++] = 189, i3 = null);
              n3 < 128 ? t4[r4++] = n3 : (n3 < 2048 ? t4[r4++] = n3 >> 6 | 192 : (n3 < 65536 ? t4[r4++] = n3 >> 12 | 224 : (t4[r4++] = n3 >> 18 | 240, t4[r4++] = n3 >> 12 & 63 | 128), t4[r4++] = n3 >> 6 & 63 | 128), t4[r4++] = 63 & n3 | 128);
            }
            return r4;
          }(this.buf, t3, this.pos);
          var r3 = this.pos - e3;
          r3 >= 128 && a22(e3, r3, this), this.pos = e3 - 1, this.writeVarint(r3), this.pos += r3;
        }, writeFloat: function(e3) {
          this.realloc(4), t22.write(this.buf, e3, this.pos, true, 23, 4), this.pos += 4;
        }, writeDouble: function(e3) {
          this.realloc(8), t22.write(this.buf, e3, this.pos, true, 52, 8), this.pos += 8;
        }, writeBytes: function(t3) {
          var e3 = t3.length;
          this.writeVarint(e3), this.realloc(e3);
          for (var r3 = 0; r3 < e3; r3++) this.buf[this.pos++] = t3[r3];
        }, writeRawMessage: function(t3, e3) {
          this.pos++;
          var r3 = this.pos;
          t3(e3, this);
          var n3 = this.pos - r3;
          n3 >= 128 && a22(r3, n3, this), this.pos = r3 - 1, this.writeVarint(n3), this.pos += n3;
        }, writeMessage: function(t3, r3, n3) {
          this.writeTag(t3, e22.Bytes), this.writeRawMessage(r3, n3);
        }, writePackedVarint: function(t3, e3) {
          e3.length && this.writeMessage(t3, l22, e3);
        }, writePackedSVarint: function(t3, e3) {
          e3.length && this.writeMessage(t3, u22, e3);
        }, writePackedBoolean: function(t3, e3) {
          e3.length && this.writeMessage(t3, p22, e3);
        }, writePackedFloat: function(t3, e3) {
          e3.length && this.writeMessage(t3, c22, e3);
        }, writePackedDouble: function(t3, e3) {
          e3.length && this.writeMessage(t3, h22, e3);
        }, writePackedFixed32: function(t3, e3) {
          e3.length && this.writeMessage(t3, f22, e3);
        }, writePackedSFixed32: function(t3, e3) {
          e3.length && this.writeMessage(t3, d22, e3);
        }, writePackedFixed64: function(t3, e3) {
          e3.length && this.writeMessage(t3, m22, e3);
        }, writePackedSFixed64: function(t3, e3) {
          e3.length && this.writeMessage(t3, y22, e3);
        }, writeBytesField: function(t3, r3) {
          this.writeTag(t3, e22.Bytes), this.writeBytes(r3);
        }, writeFixed32Field: function(t3, r3) {
          this.writeTag(t3, e22.Fixed32), this.writeFixed32(r3);
        }, writeSFixed32Field: function(t3, r3) {
          this.writeTag(t3, e22.Fixed32), this.writeSFixed32(r3);
        }, writeFixed64Field: function(t3, r3) {
          this.writeTag(t3, e22.Fixed64), this.writeFixed64(r3);
        }, writeSFixed64Field: function(t3, r3) {
          this.writeTag(t3, e22.Fixed64), this.writeSFixed64(r3);
        }, writeVarintField: function(t3, r3) {
          this.writeTag(t3, e22.Varint), this.writeVarint(r3);
        }, writeSVarintField: function(t3, r3) {
          this.writeTag(t3, e22.Varint), this.writeSVarint(r3);
        }, writeStringField: function(t3, r3) {
          this.writeTag(t3, e22.Bytes), this.writeString(r3);
        }, writeFloatField: function(t3, r3) {
          this.writeTag(t3, e22.Fixed32), this.writeFloat(r3);
        }, writeDoubleField: function(t3, r3) {
          this.writeTag(t3, e22.Fixed64), this.writeDouble(r3);
        }, writeBooleanField: function(t3, e3) {
          this.writeVarintField(t3, Boolean(e3));
        } }, yd;
      }
      var _d2 = dt(bd());
      const wd = 3;
      function Ad(t22, e22, r22) {
        e22.glyphs = [], 1 === t22 && r22.readMessage(Md, e22);
      }
      function Md(t22, e22, r22) {
        if (3 === t22) {
          const { id: t3, bitmap: n22, width: i22, height: s2, left: o2, top: a22, advance: l22 } = r22.readMessage(Id, {});
          e22.glyphs.push({ id: t3, bitmap: new qc({ width: i22 + 2 * wd, height: s2 + 2 * wd }, n22), metrics: { width: i22, height: s2, left: o2, top: a22, advance: l22 } });
        } else 4 === t22 ? e22.ascender = r22.readSVarint() : 5 === t22 && (e22.descender = r22.readSVarint());
      }
      function Id(t22, e22, r22) {
        1 === t22 ? e22.id = r22.readVarint() : 2 === t22 ? e22.bitmap = r22.readBytes() : 3 === t22 ? e22.width = r22.readVarint() : 4 === t22 ? e22.height = r22.readVarint() : 5 === t22 ? e22.left = r22.readSVarint() : 6 === t22 ? e22.top = r22.readSVarint() : 7 === t22 && (e22.advance = r22.readVarint());
      }
      const Sd = wd, zd = { horizontal: 1, vertical: 2, horizontalOnly: 3 };
      class kd {
        constructor() {
          this.scale = 1, this.fontStack = "", this.image = null;
        }
        static forText(t22, e22) {
          const r22 = new kd();
          return r22.scale = t22 || 1, r22.fontStack = e22, r22;
        }
        static forImage(t22) {
          const e22 = new kd();
          return e22.image = t22, e22;
        }
      }
      class Ed {
        constructor() {
          this.text = "", this.sectionIndex = [], this.sections = [], this.imageSectionID = null;
        }
        static fromFeature(t22, e22, r22) {
          const n22 = new Ed();
          for (let i22 = 0; i22 < t22.sections.length; i22++) {
            const s2 = t22.sections[i22];
            s2.image ? n22.addImageSection(s2, r22) : n22.addTextSection(s2, e22);
          }
          return n22;
        }
        length() {
          return this.text.length;
        }
        getSection(t22) {
          return this.sections[this.sectionIndex[t22]];
        }
        getSections() {
          return this.sections;
        }
        getSectionIndex(t22) {
          return this.sectionIndex[t22];
        }
        getCodePoint(t22) {
          return this.text.codePointAt(t22);
        }
        verticalizePunctuation(t22) {
          this.text = function(t3, e22) {
            let r22 = "";
            for (let n22 = 0; n22 < t3.length; n22++) {
              const i22 = t3.charCodeAt(n22 + 1) || null, s2 = t3.charCodeAt(n22 - 1) || null;
              r22 += !e22 && (i22 && Js(i22) && !pd[t3[n22 + 1]] || s2 && Js(s2) && !pd[t3[n22 - 1]]) || !pd[t3[n22]] ? t3[n22] : pd[t3[n22]];
            }
            return r22;
          }(this.text, t22);
        }
        trim() {
          let t22 = 0;
          for (let e3 = 0; e3 < this.text.length && Td[this.text.charCodeAt(e3)]; e3++) t22++;
          let e22 = this.text.length;
          for (let r22 = this.text.length - 1; r22 >= 0 && r22 >= t22 && Td[this.text.charCodeAt(r22)]; r22--) e22--;
          this.text = this.text.substring(t22, e22), this.sectionIndex = this.sectionIndex.slice(t22, e22);
        }
        substring(t22, e22) {
          const r22 = new Ed();
          return r22.text = this.text.substring(t22, e22), r22.sectionIndex = this.sectionIndex.slice(t22, e22), r22.sections = this.sections, r22;
        }
        toString() {
          return this.text;
        }
        getMaxScale() {
          return this.sectionIndex.reduce((t22, e22) => Math.max(t22, this.sections[e22].scale), 0);
        }
        addTextSection(t22, e22) {
          this.text += t22.text, this.sections.push(kd.forText(t22.scale, t22.fontStack || e22));
          const r22 = this.sections.length - 1;
          for (let e3 = 0; e3 < t22.text.length; ++e3) this.sectionIndex.push(r22);
        }
        addImageSection(t22, e22) {
          const r22 = t22.image ? t22.image.getPrimary() : null;
          if (!r22) return void $t2("Can't add FormattedSection with an empty image.");
          r22.scaleSelf(e22);
          const n22 = this.getNextImageSectionCharCode();
          n22 ? (this.text += String.fromCodePoint(n22), this.sections.push(kd.forImage(r22)), this.sectionIndex.push(this.sections.length - 1)) : $t2("Reached maximum number of images 6401");
        }
        getNextImageSectionCharCode() {
          return this.imageSectionID ? this.imageSectionID >= 63743 ? null : ++this.imageSectionID : (this.imageSectionID = 57344, this.imageSectionID);
        }
      }
      function Pd(t22, e22, r22, n22, i22, s2, o2, a22, l22, u22, c22, h22, p22, f22, d22, m22 = 1) {
        const y22 = Ed.fromFeature(t22, i22, m22);
        h22 === zd.vertical && y22.verticalizePunctuation(p22);
        let g22 = [];
        const x22 = function(t3, e3, r3, n3, i3, s3) {
          if (!t3) return [];
          const o3 = [], a3 = function(t4, e4, r4, n4, i4, s4) {
            let o4 = 0;
            for (let r5 = 0; r5 < t4.length(); r5++) {
              const a4 = t4.getSection(r5);
              o4 += Vd(t4.getCodePoint(r5), a4, n4, i4, e4, s4);
            }
            return o4 / Math.max(1, Math.ceil(o4 / r4));
          }(t3, e3, r3, n3, i3, s3), l3 = t3.text.indexOf("​") >= 0;
          let u3 = 0;
          for (let r4 = 0; r4 < t3.length(); r4++) {
            const h3 = t3.getSection(r4), p3 = t3.getCodePoint(r4);
            if (Td[p3] || (u3 += Vd(p3, h3, n3, i3, e3, s3)), r4 < t3.length() - 1) {
              const e4 = !((c3 = p3) < 11904 || !(Xs["Bopomofo Extended"](c3) || Xs.Bopomofo(c3) || Xs["CJK Compatibility Forms"](c3) || Xs["CJK Compatibility Ideographs"](c3) || Xs["CJK Compatibility"](c3) || Xs["CJK Radicals Supplement"](c3) || Xs["CJK Strokes"](c3) || Xs["CJK Symbols and Punctuation"](c3) || Xs["CJK Unified Ideographs Extension A"](c3) || Xs["CJK Unified Ideographs"](c3) || Xs["Enclosed CJK Letters and Months"](c3) || Xs["Halfwidth and Fullwidth Forms"](c3) || Xs.Hiragana(c3) || Xs["Ideographic Description Characters"](c3) || Xs["Kangxi Radicals"](c3) || Xs["Katakana Phonetic Extensions"](c3) || Xs.Katakana(c3) || Xs["Vertical Forms"](c3) || Xs["Yi Radicals"](c3) || Xs["Yi Syllables"](c3)));
              (Bd[p3] || e4 || h3.image) && o3.push(Fd(r4 + 1, u3, a3, o3, Dd(p3, t3.getCodePoint(r4 + 1), e4 && l3), false));
            }
          }
          var c3;
          return Ld(Fd(t3.length(), u3, a3, o3, 0, true));
        }(y22, u22, s2, e22, n22, f22), { processBidirectionalText: v22, processStyledBidirectionalText: b22 } = mo;
        if (v22 && 1 === y22.sections.length) {
          const t3 = v22(y22.toString(), x22);
          for (const e3 of t3) {
            const t4 = new Ed();
            t4.text = e3, t4.sections = y22.sections;
            for (let r3 = 0; r3 < e3.length; r3++) t4.sectionIndex.push(0);
            g22.push(t4);
          }
        } else if (b22) {
          const t3 = b22(y22.text, y22.sectionIndex, x22);
          for (const e3 of t3) {
            const t4 = new Ed();
            t4.text = e3[0], t4.sectionIndex = e3[1], t4.sections = y22.sections, g22.push(t4);
          }
        } else g22 = function(t3, e3) {
          const r3 = [], n3 = t3.text;
          let i3 = 0;
          for (const n4 of e3) r3.push(t3.substring(i3, n4)), i3 = n4;
          return i3 < n3.length && r3.push(t3.substring(i3, n3.length)), r3;
        }(y22, x22);
        const _22 = [], w22 = { positionedLines: _22, text: y22.toString(), top: c22[1], bottom: c22[1], left: c22[0], right: c22[0], writingMode: h22, iconsInText: false, verticalizable: false, hasBaseline: false };
        if (function(t3, e3, r3, n3, i3, s3, o3, a3, l3, u3, c3, h3) {
          let p3 = 0, f3 = 0, d3 = 0;
          const m3 = "right" === a3 ? 1 : "left" === a3 ? 0 : 0.5;
          let y3 = false;
          for (const t4 of i3) {
            const r4 = t4.getSections();
            for (const t5 of r4) {
              if (t5.image) continue;
              const r5 = e3[t5.fontStack];
              if (r5 && (y3 = void 0 !== r5.ascender && void 0 !== r5.descender, !y3)) break;
            }
            if (!y3) break;
          }
          let g3 = 0;
          for (const o4 of i3) {
            o4.trim();
            const i4 = o4.getMaxScale(), a4 = (i4 - 1) * cd, v4 = { positionedGlyphs: [], lineOffset: 0 };
            t3.positionedLines[g3] = v4;
            const b4 = v4.positionedGlyphs;
            let _4 = 0;
            if (!o4.length()) {
              f3 += s3, ++g3;
              continue;
            }
            let w3 = 0, A22 = 0;
            for (let s4 = 0; s4 < o4.length(); s4++) {
              const a5 = o4.getSection(s4), d4 = o4.getSectionIndex(s4), m4 = o4.getCodePoint(s4);
              let g4 = a5.scale, v5 = null, M3 = null, I2 = null, S2 = cd, z22 = 0;
              l3 === zd.vertical && (12312 === (x3 = m4) || 12313 === x3 || 12316 === x3 || 12540 === x3 || 12448 === x3) && (l3 = zd.horizontal);
              const k22 = !(l3 === zd.horizontal || !c3 && !Ks(m4) || c3 && (Td[m4] || Qs(m4)));
              if (a5.image) {
                const e4 = n3.get(a5.image.toString());
                if (!e4) continue;
                I2 = a5.image, t3.iconsInText = t3.iconsInText || true, M3 = e4.paddedRect;
                const r4 = e4.displaySize;
                g4 = g4 * cd / h3, v5 = { width: r4[0], height: r4[1], left: 0, top: -Sd, advance: k22 ? r4[1] : r4[0], localGlyph: false }, z22 = y3 ? -v5.height * g4 : i4 * cd - 17 - r4[1] * g4, S2 = v5.advance;
                const s5 = (k22 ? r4[0] : r4[1]) * g4 - cd * i4;
                s5 > 0 && s5 > _4 && (_4 = s5);
              } else {
                const t4 = r3[a5.fontStack];
                if (!t4) continue;
                t4[m4] && (M3 = t4[m4]);
                const n4 = e3[a5.fontStack];
                if (!n4) continue;
                const s5 = n4.glyphs[m4];
                if (!s5) continue;
                if (v5 = s5.metrics, S2 = 8203 !== m4 ? cd : 0, y3) {
                  const t5 = void 0 !== n4.ascender ? Math.abs(n4.ascender) : 0, e4 = void 0 !== n4.descender ? Math.abs(n4.descender) : 0, r4 = (t5 + e4) * g4;
                  w3 < r4 && (w3 = r4, A22 = (t5 - e4) / 2 * g4), z22 = -t5 * g4;
                } else z22 = (i4 - g4) * cd - 17;
              }
              k22 ? (t3.verticalizable = true, b4.push({ glyph: m4, image: I2, x: p3, y: f3 + z22, vertical: k22, scale: g4, localGlyph: v5.localGlyph, fontStack: a5.fontStack, sectionIndex: d4, metrics: v5, rect: M3 }), p3 += S2 * g4 + u3) : (b4.push({ glyph: m4, image: I2, x: p3, y: f3 + z22, vertical: k22, scale: g4, localGlyph: v5.localGlyph, fontStack: a5.fontStack, sectionIndex: d4, metrics: v5, rect: M3 }), p3 += v5.advance * g4 + u3);
            }
            0 !== b4.length && (d3 = Math.max(p3 - u3, d3), y3 ? Od(b4, m3, _4, A22, s3 * i4 / 2) : Od(b4, m3, _4, 0, s3 / 2)), p3 = 0;
            const M22 = s3 * i4 + _4;
            v4.lineOffset = Math.max(_4, a4), f3 += M22, ++g3;
          }
          var x3;
          const v3 = f3, { horizontalAlign: b3, verticalAlign: _3 } = Rd(o3);
          (function(t4, e4, r4, n4, i4, s4) {
            const o4 = (e4 - r4) * i4, a4 = -s4 * n4;
            for (const e5 of t4) for (const t5 of e5.positionedGlyphs) t5.x += o4, t5.y += a4;
          })(t3.positionedLines, m3, b3, _3, d3, v3), t3.top += -_3 * v3, t3.bottom = t3.top + v3, t3.left += -b3 * d3, t3.right = t3.left + d3, t3.hasBaseline = y3;
        }(w22, e22, r22, n22, g22, o2, a22, l22, h22, u22, p22, d22), !function(t3) {
          for (const e3 of t3) if (0 !== e3.positionedGlyphs.length) return false;
          return true;
        }(_22)) return w22;
      }
      const Td = { 9: true, 10: true, 11: true, 12: true, 13: true, 32: true }, Bd = { 10: true, 32: true, 38: true, 40: true, 41: true, 43: true, 45: true, 47: true, 173: true, 183: true, 8203: true, 8208: true, 8211: true, 8231: true };
      function Vd(t22, e22, r22, n22, i22, s2) {
        if (e22.image) {
          const t3 = n22.get(e22.image.toString());
          return t3 ? t3.displaySize[0] * e22.scale * cd / s2 + i22 : 0;
        }
        {
          const n3 = r22[e22.fontStack], s3 = n3 && n3.glyphs[t22];
          return s3 ? s3.metrics.advance * e22.scale + i22 : 0;
        }
      }
      function Cd(t22, e22, r22, n22) {
        const i22 = Math.pow(t22 - e22, 2);
        return n22 ? t22 < e22 ? i22 / 2 : 2 * i22 : i22 + Math.abs(r22) * r22;
      }
      function Dd(t22, e22, r22) {
        let n22 = 0;
        return 10 === t22 && (n22 -= 1e4), r22 && (n22 += 150), 40 !== t22 && 65288 !== t22 || (n22 += 50), 41 !== e22 && 65289 !== e22 || (n22 += 50), n22;
      }
      function Fd(t22, e22, r22, n22, i22, s2) {
        let o2 = null, a22 = Cd(e22, r22, i22, s2);
        for (const t3 of n22) {
          const n3 = Cd(e22 - t3.x, r22, i22, s2) + t3.badness;
          n3 <= a22 && (o2 = t3, a22 = n3);
        }
        return { index: t22, x: e22, priorBreak: o2, badness: a22 };
      }
      function Ld(t22) {
        return t22 ? Ld(t22.priorBreak).concat(t22.index) : [];
      }
      function Rd(t22) {
        let e22 = 0.5, r22 = 0.5;
        switch (t22) {
          case "right":
          case "top-right":
          case "bottom-right":
            e22 = 1;
            break;
          case "left":
          case "top-left":
          case "bottom-left":
            e22 = 0;
        }
        switch (t22) {
          case "bottom":
          case "bottom-right":
          case "bottom-left":
            r22 = 1;
            break;
          case "top":
          case "top-right":
          case "top-left":
            r22 = 0;
        }
        return { horizontalAlign: e22, verticalAlign: r22 };
      }
      function Od(t22, e22, r22, n22, i22) {
        if (!(e22 || r22 || n22 || i22)) return;
        const s2 = t22.length - 1, o2 = t22[s2], a22 = (o2.x + o2.metrics.advance * o2.scale) * e22;
        for (let e3 = 0; e3 <= s2; e3++) t22[e3].x -= a22, t22[e3].y += r22 + n22 + i22;
      }
      function Ud(t22) {
        return void 0 !== t22.imagePrimary && void 0 !== t22.top && void 0 !== t22.bottom && void 0 !== t22.left && void 0 !== t22.right;
      }
      function Nd(t22, e22, r22, n22) {
        const { horizontalAlign: i22, verticalAlign: s2 } = Rd(n22), o2 = r22[0] - t22.displaySize[0] * i22, a22 = r22[1] - t22.displaySize[1] * s2;
        return { imagePrimary: t22, imageSecondary: e22, top: a22, bottom: a22 + t22.displaySize[1], left: o2, right: o2 + t22.displaySize[0] };
      }
      function jd(t22, e22, r22, n22, i22, s2) {
        const o2 = t22.imagePrimary;
        let a22;
        if (o2.content) {
          const t3 = o2.content, e3 = o2.pixelRatio || 1;
          a22 = [t3[0] / e3, t3[1] / e3, o2.displaySize[0] - t3[2] / e3, o2.displaySize[1] - t3[3] / e3];
        }
        const l22 = e22.left * s2, u22 = e22.right * s2;
        let c22, h22, p22, f22;
        "width" === r22 || "both" === r22 ? (f22 = i22[0] + l22 - n22[3], h22 = i22[0] + u22 + n22[1]) : (f22 = i22[0] + (l22 + u22 - o2.displaySize[0]) / 2, h22 = f22 + o2.displaySize[0]);
        const d22 = e22.top * s2, m22 = e22.bottom * s2;
        return "height" === r22 || "both" === r22 ? (c22 = i22[1] + d22 - n22[0], p22 = i22[1] + m22 + n22[2]) : (c22 = i22[1] + (d22 + m22 - o2.displaySize[1]) / 2, p22 = c22 + o2.displaySize[1]), { imagePrimary: o2, imageSecondary: void 0, top: c22, right: h22, bottom: p22, left: f22, collisionPadding: a22 };
      }
      function $d(t22) {
        return !t22.imagePrimary.stretchX;
      }
      function Gd(t22) {
        return !t22.imagePrimary.stretchY;
      }
      function qd(t22) {
        return { width: t22.right - t22.left, height: t22.bottom - t22.top };
      }
      const Hd = 128;
      function Xd(t22, e22) {
        const { expression: r22 } = e22;
        if ("constant" === r22.kind) return { kind: "constant", layoutSize: r22.evaluate(new yo(t22 + 1)) };
        if ("source" === r22.kind) return { kind: "source" };
        {
          const { zoomStops: e3, interpolationType: n22 } = r22;
          let i22 = 0;
          for (; i22 < e3.length && e3[i22] <= t22; ) i22++;
          i22 = Math.max(0, i22 - 1);
          let s2 = i22;
          for (; s2 < e3.length && e3[s2] < t22 + 1; ) s2++;
          s2 = Math.min(e3.length - 1, s2);
          const o2 = e3[i22], a22 = e3[s2];
          return "composite" === r22.kind ? { kind: "composite", minZoom: o2, maxZoom: a22, interpolationType: n22 } : { kind: "camera", minZoom: o2, maxZoom: a22, minSize: r22.evaluate(new yo(o2)), maxSize: r22.evaluate(new yo(a22)), interpolationType: n22 };
        }
      }
      function Zd(t22, { uSize: e22, uSizeT: r22 }, { lowerSize: n22, upperSize: i22 }) {
        return "source" === t22.kind ? n22 / Hd : "composite" === t22.kind ? or(n22 / Hd, i22 / Hd, r22) : e22;
      }
      function Wd(t22, e22, r22 = 1) {
        let n22 = 0, i22 = 0;
        if ("constant" === t22.kind) i22 = t22.layoutSize * r22;
        else if ("source" !== t22.kind) {
          const { interpolationType: s2, minZoom: o2, maxZoom: a22 } = t22, l22 = s2 ? Pt(Oi.interpolationFactor(s2, e22, o2, a22), 0, 1) : 0;
          "camera" === t22.kind ? i22 = or(t22.minSize, t22.maxSize, l22) * r22 : n22 = l22 * r22;
        }
        return { uSizeT: n22, uSize: i22 };
      }
      class Yd extends bt {
        constructor(t22, e22, r22, n22, i22) {
          super(t22, e22), this.angle = n22, this.z = r22, void 0 !== i22 && (this.segment = i22);
        }
        clone() {
          return new Yd(this.x, this.y, this.z, this.angle, this.segment);
        }
      }
      function Kd(t22, e22, r22, n22, i22) {
        if (void 0 === e22.segment) return true;
        let s2 = e22, o2 = e22.segment + 1, a22 = 0;
        for (; a22 > -r22 / 2; ) {
          if (o2--, o2 < 0) return false;
          a22 -= t22[o2].dist(s2), s2 = t22[o2];
        }
        a22 += t22[o2].dist(t22[o2 + 1]), o2++;
        const l22 = [];
        let u22 = 0;
        for (; a22 < r22 / 2; ) {
          const e3 = t22[o2], r3 = t22[o2 + 1];
          if (!r3) return false;
          let s3 = t22[o2 - 1].angleTo(e3) - e3.angleTo(r3);
          for (s3 = Math.abs((s3 + 3 * Math.PI) % (2 * Math.PI) - Math.PI), l22.push({ distance: a22, angleDelta: s3 }), u22 += s3; a22 - l22[0].distance > n22; ) u22 -= l22.shift().angleDelta;
          if (u22 > i22) return false;
          o2++, a22 += e3.dist(r3);
        }
        return true;
      }
      function Jd(t22) {
        let e22 = 0;
        for (let r22 = 0; r22 < t22.length - 1; r22++) e22 += t22[r22].dist(t22[r22 + 1]);
        return e22;
      }
      function Qd(t22, e22, r22) {
        return t22 ? 0.6 * e22 * r22 : 0;
      }
      function tm(t22, e22) {
        return Math.max(t22 ? t22.right - t22.left : 0, e22 ? e22.right - e22.left : 0);
      }
      function em(t22, e22, r22, n22, i22, s2) {
        const o2 = Qd(r22, i22, s2), a22 = tm(r22, n22) * s2;
        let l22 = 0;
        const u22 = Jd(t22) / 2;
        for (let r3 = 0; r3 < t22.length - 1; r3++) {
          const n3 = t22[r3], i3 = t22[r3 + 1], s3 = n3.dist(i3);
          if (l22 + s3 > u22) {
            const c22 = (u22 - l22) / s3, h22 = or(n3.x, i3.x, c22), p22 = or(n3.y, i3.y, c22), f22 = new Yd(h22, p22, 0, i3.angleTo(n3), r3);
            return !o2 || Kd(t22, f22, a22, o2, e22) ? f22 : void 0;
          }
          l22 += s3;
        }
      }
      function rm(t22, e22, r22, n22, i22, s2, o2, a22, l22) {
        const u22 = Qd(n22, s2, o2), c22 = tm(n22, i22), h22 = c22 * o2, p22 = 0 === t22[0].x || t22[0].x === l22 || 0 === t22[0].y || t22[0].y === l22;
        return e22 - h22 < e22 / 4 && (e22 = h22 + e22 / 4), nm(t22, p22 ? e22 / 2 * a22 % e22 : (c22 / 2 + 2 * s2) * o2 * a22 % e22, e22, u22, r22, h22, p22, false, l22);
      }
      function nm(t22, e22, r22, n22, i22, s2, o2, a22, l22) {
        const u22 = s2 / 2, c22 = Jd(t22);
        let h22 = 0, p22 = e22 - r22, f22 = [];
        for (let e3 = 0; e3 < t22.length - 1; e3++) {
          const o3 = t22[e3], a3 = t22[e3 + 1], d22 = o3.dist(a3), m22 = a3.angleTo(o3);
          for (; p22 + r22 < h22 + d22; ) {
            p22 += r22;
            const y22 = (p22 - h22) / d22, g22 = or(o3.x, a3.x, y22), x22 = or(o3.y, a3.y, y22);
            if (g22 >= 0 && g22 < l22 && x22 >= 0 && x22 < l22 && p22 - u22 >= 0 && p22 + u22 <= c22) {
              const r3 = new Yd(g22, x22, 0, m22, e3);
              n22 && !Kd(t22, r3, s2, n22, i22) || f22.push(r3);
            }
          }
          h22 += d22;
        }
        return a22 || f22.length || o2 || (f22 = nm(t22, h22 / 2, r22, n22, i22, s2, o2, true, l22)), f22;
      }
      function im(t22) {
        let e22 = 0, r22 = 0;
        for (const n3 of t22) e22 += n3.w * n3.h, r22 = Math.max(r22, n3.w);
        t22.sort((t3, e3) => e3.h - t3.h);
        const n22 = [{ x: 0, y: 0, w: Math.max(Math.ceil(Math.sqrt(e22 / 0.95)), r22), h: 1 / 0 }];
        let i22 = 0, s2 = 0;
        for (const e3 of t22) for (let t3 = n22.length - 1; t3 >= 0; t3--) {
          const r3 = n22[t3];
          if (!(e3.w > r3.w || e3.h > r3.h)) {
            if (e3.x = r3.x, e3.y = r3.y, s2 = Math.max(s2, e3.y + e3.h), i22 = Math.max(i22, e3.x + e3.w), e3.w === r3.w && e3.h === r3.h) {
              const e4 = n22.pop();
              t3 < n22.length && (n22[t3] = e4);
            } else e3.h === r3.h ? (r3.x += e3.w, r3.w -= e3.w) : e3.w === r3.w ? (r3.y += e3.h, r3.h -= e3.h) : (n22.push({ x: r3.x + e3.w, y: r3.y, w: r3.w - e3.w, h: e3.h }), r3.y += e3.h, r3.h -= e3.h);
            break;
          }
        }
        return { w: i22, h: s2, fill: e22 / (i22 * s2) || 0 };
      }
      js(Yd, "Anchor");
      const sm = 1;
      class om {
        static getImagePositionScale(t22, e22, r22) {
          if (e22 && t22 && t22.options && t22.options.transform) {
            const e3 = t22.options.transform;
            return { x: e3.a, y: e3.d };
          }
          return { x: r22, y: r22 };
        }
        constructor(t22, e22, r22, n22) {
          this.paddedRect = t22;
          const { pixelRatio: i22, version: s2, stretchX: o2, stretchY: a22, content: l22, sdf: u22, usvg: c22 } = e22;
          this.pixelRatio = i22, this.stretchX = o2, this.stretchY = a22, this.content = l22, this.version = s2, this.padding = r22, this.sdf = u22, this.scale = om.getImagePositionScale(n22, c22, i22);
        }
        get tl() {
          return [this.paddedRect.x + this.padding, this.paddedRect.y + this.padding];
        }
        get br() {
          return [this.paddedRect.x + this.paddedRect.w - this.padding, this.paddedRect.y + this.paddedRect.h - this.padding];
        }
        get displaySize() {
          return [(this.paddedRect.w - 2 * this.padding) / this.scale.x, (this.paddedRect.h - 2 * this.padding) / this.scale.y];
        }
      }
      function am(t22, e22, r22) {
        const n22 = Br.parse(t22), i22 = function(t3, e3, r3 = [1, 1]) {
          return { x: 0, y: 0, w: (t3.data ? t3.data.width : t3.width * r3[0]) + 2 * e3, h: (t3.data ? t3.data.height : t3.height * r3[1]) + 2 * e3 };
        }(e22, r22, [n22.options.transform.a, n22.options.transform.d]);
        return { bin: i22, imagePosition: new om(i22, e22, r22, n22), imageVariant: n22 };
      }
      class lm {
        constructor(t22, e22, r22) {
          const n22 = /* @__PURE__ */ new Map(), i22 = /* @__PURE__ */ new Map();
          this.haveRenderCallbacks = [];
          const s2 = [];
          this.addImages(t22, n22, sm, s2), this.addImages(e22, i22, 2, s2);
          const { w: o2, h: a22 } = im(s2), l22 = new Hc({ width: o2 || 1, height: a22 || 1 });
          for (const [e3, i3] of t22.entries()) {
            const t3 = n22.get(e3).paddedRect;
            Hc.copy(i3.data, l22, { x: 0, y: 0 }, { x: t3.x + sm, y: t3.y + sm }, i3.data, r22, i3.sdf);
          }
          for (const [t3, n3] of e22.entries()) {
            const e3 = i22.get(t3), s3 = e3.paddedRect;
            let o3 = e3.padding;
            const a3 = s3.x + o3, u22 = s3.y + o3, c22 = n3.data.width, h22 = n3.data.height;
            o3 = o3 > 1 ? o3 - 1 : o3, Hc.copy(n3.data, l22, { x: 0, y: 0 }, { x: a3, y: u22 }, n3.data, r22), Hc.copy(n3.data, l22, { x: 0, y: h22 - o3 }, { x: a3, y: u22 - o3 }, { width: c22, height: o3 }, r22), Hc.copy(n3.data, l22, { x: 0, y: 0 }, { x: a3, y: u22 + h22 }, { width: c22, height: o3 }, r22), Hc.copy(n3.data, l22, { x: c22 - o3, y: 0 }, { x: a3 - o3, y: u22 }, { width: o3, height: h22 }, r22), Hc.copy(n3.data, l22, { x: 0, y: 0 }, { x: a3 + c22, y: u22 }, { width: o3, height: h22 }, r22), Hc.copy(n3.data, l22, { x: c22 - o3, y: h22 - o3 }, { x: a3 - o3, y: u22 - o3 }, { width: o3, height: o3 }, r22), Hc.copy(n3.data, l22, { x: 0, y: h22 - o3 }, { x: a3 + c22, y: u22 - o3 }, { width: o3, height: o3 }, r22), Hc.copy(n3.data, l22, { x: 0, y: 0 }, { x: a3 + c22, y: u22 + h22 }, { width: o3, height: o3 }, r22), Hc.copy(n3.data, l22, { x: c22 - o3, y: 0 }, { x: a3 - o3, y: u22 + h22 }, { width: o3, height: o3 }, r22);
          }
          this.lut = r22, this.image = l22, this.iconPositions = n22, this.patternPositions = i22;
        }
        addImages(t22, e22, r22, n22) {
          for (const [i22, s2] of t22.entries()) {
            const { bin: t3, imagePosition: o2, imageVariant: a22 } = am(i22, s2, r22);
            e22.set(i22, o2), n22.push(t3), s2.hasRenderCallback && this.haveRenderCallbacks.push(a22.id);
          }
        }
        patchUpdatedImages(t22, e22, r22) {
          this.haveRenderCallbacks = this.haveRenderCallbacks.filter((e3) => t22.hasImage(e3, r22)), t22.dispatchRenderCallbacks(this.haveRenderCallbacks, r22);
          for (const n22 of t22.getUpdatedImages(r22)) {
            for (const i22 of this.iconPositions.keys()) {
              const s2 = Br.parse(i22);
              if (tr.isEqual(s2.id, n22)) {
                const s3 = t22.getImage(n22, r22);
                this.patchUpdatedImage(this.iconPositions.get(i22), s3, e22);
              }
            }
            for (const i22 of this.patternPositions.keys()) {
              const s2 = Br.parse(i22);
              if (tr.isEqual(s2.id, n22)) {
                const s3 = t22.getImage(n22, r22);
                this.patchUpdatedImage(this.patternPositions.get(i22), s3, e22);
              }
            }
          }
        }
        patchUpdatedImage(t22, e22, r22) {
          if (!t22 || !e22) return;
          if (t22.version === e22.version) return;
          t22.version = e22.version;
          const [n22, i22] = t22.tl, s2 = t22.sdf;
          if (this.lut || s2) {
            const t3 = { width: e22.data.width, height: e22.data.height }, o2 = new Hc(t3);
            Hc.copy(e22.data, o2, { x: 0, y: 0 }, { x: 0, y: 0 }, t3, this.lut, s2), r22.update(o2, { position: { x: n22, y: i22 } });
          } else r22.update(e22.data, { position: { x: n22, y: i22 } });
        }
      }
      js(om, "ImagePosition"), js(lm, "ImageAtlas");
      const um = 1e20;
      function cm(t22, e22, r22, n22, i22, s2, o2, a22, l22) {
        for (let u22 = e22; u22 < e22 + n22; u22++) hm(t22, r22 * s2 + u22, s2, i22, o2, a22, l22);
        for (let u22 = r22; u22 < r22 + i22; u22++) hm(t22, u22 * s2 + e22, 1, n22, o2, a22, l22);
      }
      function hm(t22, e22, r22, n22, i22, s2, o2) {
        s2[0] = 0, o2[0] = -um, o2[1] = um, i22[0] = t22[e22];
        for (let a22 = 1, l22 = 0, u22 = 0; a22 < n22; a22++) {
          i22[a22] = t22[e22 + a22 * r22];
          const n3 = a22 * a22;
          do {
            const t3 = s2[l22];
            u22 = (i22[a22] - i22[t3] + n3 - t3 * t3) / (a22 - t3) / 2;
          } while (u22 <= o2[l22] && --l22 > -1);
          l22++, s2[l22] = a22, o2[l22] = u22, o2[l22 + 1] = um;
        }
        for (let a22 = 0, l22 = 0; a22 < n22; a22++) {
          for (; o2[l22 + 1] < a22; ) l22++;
          const n3 = s2[l22], u22 = a22 - n3;
          t22[e22 + a22 * r22] = i22[n3] + u22 * u22;
        }
      }
      const pm = 2, fm = { none: 0, ideographs: 1, all: 2 };
      class dm {
        constructor(t22, e22, r22) {
          this.requestManager = t22, this.localGlyphMode = e22, this.localFontFamily = r22, this.urls = {}, this.entries = {}, this.localGlyphs = { 200: {}, 400: {}, 500: {}, 900: {} };
        }
        setURL(t22, e22) {
          this.urls[e22] = t22;
        }
        getGlyphs(t22, e22, r22) {
          const n22 = [], i22 = this.urls[e22] || re.GLYPHS_URL;
          for (const e3 in t22) for (const r3 of t22[e3]) n22.push({ stack: e3, id: r3 });
          Vt2(n22, ({ stack: t3, id: e3 }, r3) => {
            let n3 = this.entries[t3];
            n3 || (n3 = this.entries[t3] = { glyphs: {}, requests: {}, ranges: {}, ascender: void 0, descender: void 0 });
            let s2 = n3.glyphs[e3];
            if (void 0 !== s2) return void r3(null, { stack: t3, id: e3, glyph: s2 });
            if (s2 = this._tinySDF(n3, t3, e3), s2) return n3.glyphs[e3] = s2, void r3(null, { stack: t3, id: e3, glyph: s2 });
            const o2 = Math.floor(e3 / 256);
            if (256 * o2 > 65535) return $t2("glyphs > 65535 not supported"), void r3(null, { stack: t3, id: e3, glyph: s2 });
            if (n3.ranges[o2]) return void r3(null, { stack: t3, id: e3, glyph: s2 });
            let a22 = n3.requests[o2];
            a22 || (a22 = n3.requests[o2] = [], dm.loadGlyphRange(t3, o2, i22, this.requestManager, (t4, e4) => {
              if (e4) {
                n3.ascender = e4.ascender, n3.descender = e4.descender;
                for (const t5 in e4.glyphs) this._doesCharSupportLocalGlyph(+t5) || (n3.glyphs[+t5] = e4.glyphs[+t5]);
                n3.ranges[o2] = true;
              }
              for (const r4 of a22) r4(t4, e4);
              delete n3.requests[o2];
            })), a22.push((n4, i3) => {
              n4 ? r3(n4) : i3 && r3(null, { stack: t3, id: e3, glyph: i3.glyphs[e3] || null });
            });
          }, (t3, e3) => {
            if (t3) r22(t3);
            else if (e3) {
              const t4 = {};
              for (const { stack: r3, id: n3, glyph: i3 } of e3) void 0 === t4[r3] && (t4[r3] = {}), void 0 === t4[r3].glyphs && (t4[r3].glyphs = {}), t4[r3].glyphs[n3] = i3 && { id: i3.id, bitmap: i3.bitmap.clone(), metrics: i3.metrics }, t4[r3].ascender = this.entries[r3].ascender, t4[r3].descender = this.entries[r3].descender;
              r22(null, t4);
            }
          });
        }
        _doesCharSupportLocalGlyph(t22) {
          return this.localGlyphMode !== fm.none && (this.localGlyphMode === fm.all ? !!this.localFontFamily : !!this.localFontFamily && (Xs["CJK Unified Ideographs"](t22) || Xs["Hangul Syllables"](t22) || Xs.Hiragana(t22) || Xs.Katakana(t22) || Xs["CJK Symbols and Punctuation"](t22) || Xs["CJK Unified Ideographs Extension A"](t22) || Xs["CJK Unified Ideographs Extension B"](t22) || Xs.Osage(t22)));
        }
        _tinySDF(t22, e22, r22) {
          const n22 = this.localFontFamily;
          if (!n22 || !this._doesCharSupportLocalGlyph(r22)) return;
          let i22 = t22.tinySDF;
          if (!i22) {
            let r3 = "400";
            /bold/i.test(e22) ? r3 = "900" : /medium/i.test(e22) ? r3 = "500" : /light/i.test(e22) && (r3 = "200"), i22 = t22.tinySDF = new dm.TinySDF({ fontFamily: n22, fontWeight: r3, fontSize: 24 * pm, buffer: 3 * pm, radius: 8 * pm }), i22.fontWeight = r3;
          }
          if (this.localGlyphs[i22.fontWeight][r22]) return this.localGlyphs[i22.fontWeight][r22];
          const s2 = String.fromCodePoint(r22), { data: o2, width: a22, height: l22, glyphWidth: u22, glyphHeight: c22, glyphLeft: h22, glyphTop: p22, glyphAdvance: f22 } = i22.draw(s2);
          return this.localGlyphs[i22.fontWeight][r22] = { id: r22, bitmap: new qc({ width: a22, height: l22 }, o2), metrics: { width: u22 / pm, height: c22 / pm, left: h22 / pm, top: p22 / pm - 27, advance: f22 / pm, localGlyph: true } };
        }
      }
      dm.loadGlyphRange = function(t22, e22, r22, n22, i22) {
        const s2 = 256 * e22, o2 = s2 + 255, a22 = n22.transformRequest(n22.normalizeGlyphsURL(r22).replace("{fontstack}", t22).replace("{range}", `${s2}-${o2}`), Te2.Glyphs);
        De(a22, (t3, e3) => {
          if (t3) i22(t3);
          else if (e3) {
            const t4 = {}, r3 = function(t5) {
              return new _d2(t5).readFields(Ad, {});
            }(e3);
            for (const e4 of r3.glyphs) t4[e4.id] = e4;
            i22(null, { glyphs: t4, ascender: r3.ascender, descender: r3.descender });
          }
        });
      }, dm.TinySDF = class {
        constructor({ fontSize: t22 = 24, buffer: e22 = 3, radius: r22 = 8, cutoff: n22 = 0.25, fontFamily: i22 = "sans-serif", fontWeight: s2 = "normal", fontStyle: o2 = "normal" } = {}) {
          this.buffer = e22, this.cutoff = n22, this.radius = r22;
          const a22 = this.size = t22 + 4 * e22, l22 = this._createCanvas(a22), u22 = this.ctx = l22.getContext("2d", { willReadFrequently: true });
          u22.font = `${o2} ${s2} ${t22}px ${i22}`, u22.textBaseline = "alphabetic", u22.textAlign = "left", u22.fillStyle = "black", this.gridOuter = new Float64Array(a22 * a22), this.gridInner = new Float64Array(a22 * a22), this.f = new Float64Array(a22), this.z = new Float64Array(a22 + 1), this.v = new Uint16Array(a22);
        }
        _createCanvas(t22) {
          const e22 = document.createElement("canvas");
          return e22.width = e22.height = t22, e22;
        }
        draw(t22) {
          const { width: e22, actualBoundingBoxAscent: r22, actualBoundingBoxDescent: n22, actualBoundingBoxLeft: i22, actualBoundingBoxRight: s2 } = this.ctx.measureText(t22), o2 = Math.ceil(r22), a22 = Math.max(0, Math.min(this.size - this.buffer, Math.ceil(s2 - i22))), l22 = Math.min(this.size - this.buffer, o2 + Math.ceil(n22)), u22 = a22 + 2 * this.buffer, c22 = l22 + 2 * this.buffer, h22 = Math.max(u22 * c22, 0), p22 = new Uint8ClampedArray(h22), f22 = { data: p22, width: u22, height: c22, glyphWidth: a22, glyphHeight: l22, glyphTop: o2, glyphLeft: 0, glyphAdvance: e22 };
          if (0 === a22 || 0 === l22) return f22;
          const { ctx: d22, buffer: m22, gridInner: y22, gridOuter: g22 } = this;
          d22.clearRect(m22, m22, a22, l22), d22.fillText(t22, m22, m22 + o2);
          const x22 = d22.getImageData(m22, m22, a22, l22);
          g22.fill(um, 0, h22), y22.fill(0, 0, h22);
          for (let t3 = 0; t3 < l22; t3++) for (let e3 = 0; e3 < a22; e3++) {
            const r3 = x22.data[4 * (t3 * a22 + e3) + 3] / 255;
            if (0 === r3) continue;
            const n3 = (t3 + m22) * u22 + e3 + m22;
            if (1 === r3) g22[n3] = 0, y22[n3] = um;
            else {
              const t4 = 0.5 - r3;
              g22[n3] = t4 > 0 ? t4 * t4 : 0, y22[n3] = t4 < 0 ? t4 * t4 : 0;
            }
          }
          cm(g22, 0, 0, u22, c22, u22, this.f, this.v, this.z), cm(y22, m22, m22, a22, l22, u22, this.f, this.v, this.z);
          for (let t3 = 0; t3 < h22; t3++) {
            const e3 = Math.sqrt(g22[t3]) - Math.sqrt(y22[t3]);
            p22[t3] = Math.round(255 - 255 * (e3 / this.radius + this.cutoff));
          }
          return f22;
        }
      };
      const mm = sm;
      function ym(t22, e22) {
        return t22 + e22[1] - e22[0];
      }
      function gm(t22, e22, r22, n22, i22 = 1) {
        const s2 = [], o2 = t22.imagePrimary, a22 = o2.pixelRatio, l22 = o2.paddedRect.w - 2 * mm, u22 = o2.paddedRect.h - 2 * mm, c22 = (t22.right - t22.left) * i22, h22 = (t22.bottom - t22.top) * i22, p22 = o2.stretchX || [[0, l22]], f22 = o2.stretchY || [[0, u22]], d22 = p22.reduce(ym, 0), m22 = f22.reduce(ym, 0), y22 = l22 - d22, g22 = u22 - m22;
        let x22 = 0, v22 = d22, b22 = 0, _22 = m22, w22 = 0, A22 = y22, M22 = 0, I2 = g22;
        if (o2.content && n22) {
          const t3 = o2.content;
          x22 = xm(p22, 0, t3[0]), b22 = xm(f22, 0, t3[1]), v22 = xm(p22, t3[0], t3[2]), _22 = xm(f22, t3[1], t3[3]), w22 = t3[0] - x22, M22 = t3[1] - b22, A22 = t3[2] - t3[0] - v22, I2 = t3[3] - t3[1] - _22;
        }
        const S2 = (n3, s3, l3, u3) => {
          const p3 = bm(n3.stretch - x22, v22, c22, t22.left * i22), f3 = _m(n3.fixed - w22, A22, n3.stretch, d22), y3 = bm(s3.stretch - b22, _22, h22, t22.top * i22), g3 = _m(s3.fixed - M22, I2, s3.stretch, m22), S3 = bm(l3.stretch - x22, v22, c22, t22.left * i22), z22 = _m(l3.fixed - w22, A22, l3.stretch, d22), k22 = bm(u3.stretch - b22, _22, h22, t22.top * i22), E22 = _m(u3.fixed - M22, I2, u3.stretch, m22), P22 = new bt(p3, y3), T2 = new bt(S3, y3), B22 = new bt(S3, k22), V2 = new bt(p3, k22), C22 = new bt(f3 / a22, g3 / a22), D22 = new bt(z22 / a22, E22 / a22), F2 = e22 * Math.PI / 180;
          if (F2) {
            const t3 = Math.sin(F2), e3 = Math.cos(F2), r3 = [e3, -t3, t3, e3];
            P22._matMult(r3), T2._matMult(r3), V2._matMult(r3), B22._matMult(r3);
          }
          const L22 = n3.stretch + n3.fixed, R22 = l3.stretch + l3.fixed, O2 = s3.stretch + s3.fixed, U22 = u3.stretch + u3.fixed, N22 = t22.imageSecondary;
          return { tl: P22, tr: T2, bl: V2, br: B22, texPrimary: { x: o2.paddedRect.x + mm + L22, y: o2.paddedRect.y + mm + O2, w: R22 - L22, h: U22 - O2 }, texSecondary: N22 ? { x: N22.paddedRect.x + mm + L22, y: N22.paddedRect.y + mm + O2, w: R22 - L22, h: U22 - O2 } : void 0, writingMode: void 0, glyphOffset: [0, 0], sectionIndex: 0, pixelOffsetTL: C22, pixelOffsetBR: D22, minFontScaleX: A22 / a22 / c22, minFontScaleY: I2 / a22 / h22, isSDF: r22 };
        };
        if (n22 && (o2.stretchX || o2.stretchY)) {
          const t3 = vm(p22, y22, d22), e3 = vm(f22, g22, m22);
          for (let r3 = 0; r3 < t3.length - 1; r3++) {
            const n3 = t3[r3], i3 = t3[r3 + 1];
            for (let t4 = 0; t4 < e3.length - 1; t4++) s2.push(S2(n3, e3[t4], i3, e3[t4 + 1]));
          }
        } else s2.push(S2({ fixed: 0, stretch: -1 }, { fixed: 0, stretch: -1 }, { fixed: 0, stretch: l22 + 1 }, { fixed: 0, stretch: u22 + 1 }));
        return s2;
      }
      function xm(t22, e22, r22) {
        let n22 = 0;
        for (const i22 of t22) n22 += Math.max(e22, Math.min(r22, i22[1])) - Math.max(e22, Math.min(r22, i22[0]));
        return n22;
      }
      function vm(t22, e22, r22) {
        const n22 = [{ fixed: -mm, stretch: 0 }];
        for (const [e3, r3] of t22) {
          const t3 = n22[n22.length - 1];
          n22.push({ fixed: e3 - t3.stretch, stretch: t3.stretch }), n22.push({ fixed: e3 - t3.stretch, stretch: t3.stretch + (r3 - e3) });
        }
        return n22.push({ fixed: e22 + mm, stretch: r22 }), n22;
      }
      function bm(t22, e22, r22, n22) {
        return t22 / e22 * r22 + n22;
      }
      function _m(t22, e22, r22, n22) {
        return t22 - e22 * r22 / n22;
      }
      function wm(t22, e22, r22, n22) {
        const i22 = e22 + t22.positionedLines[n22].lineOffset;
        return 0 === n22 ? r22 + i22 / 2 : r22 + (i22 + (e22 + t22.positionedLines[n22 - 1].lineOffset)) / 2;
      }
      function Am(t22, e22 = 1, r22 = false) {
        let n22 = 1 / 0, i22 = 1 / 0, s2 = -1 / 0, o2 = -1 / 0;
        const a22 = t22[0];
        for (let t3 = 0; t3 < a22.length; t3++) {
          const e3 = a22[t3];
          (!t3 || e3.x < n22) && (n22 = e3.x), (!t3 || e3.y < i22) && (i22 = e3.y), (!t3 || e3.x > s2) && (s2 = e3.x), (!t3 || e3.y > o2) && (o2 = e3.y);
        }
        const l22 = Math.min(s2 - n22, o2 - i22);
        let u22 = l22 / 2;
        const c22 = new Pn([], Mm);
        if (0 === l22) return new bt(n22, i22);
        for (let e3 = n22; e3 < s2; e3 += l22) for (let r3 = i22; r3 < o2; r3 += l22) c22.push(new Im(e3 + u22, r3 + u22, u22, t22));
        let h22 = function(t3) {
          let e3 = 0, r3 = 0, n3 = 0;
          const i3 = t3[0];
          for (let t4 = 0, s3 = i3.length, o3 = s3 - 1; t4 < s3; o3 = t4++) {
            const s4 = i3[t4], a3 = i3[o3], l3 = s4.x * a3.y - a3.x * s4.y;
            r3 += (s4.x + a3.x) * l3, n3 += (s4.y + a3.y) * l3, e3 += 3 * l3;
          }
          return new Im(r3 / e3, n3 / e3, 0, t3);
        }(t22), p22 = c22.length;
        for (; c22.length; ) {
          const n3 = c22.pop();
          (n3.d > h22.d || !h22.d) && (h22 = n3, r22 && console.log("found best %d after %d probes", Math.round(1e4 * n3.d) / 1e4, p22)), n3.max - h22.d <= e22 || (u22 = n3.h / 2, c22.push(new Im(n3.p.x - u22, n3.p.y - u22, u22, t22)), c22.push(new Im(n3.p.x + u22, n3.p.y - u22, u22, t22)), c22.push(new Im(n3.p.x - u22, n3.p.y + u22, u22, t22)), c22.push(new Im(n3.p.x + u22, n3.p.y + u22, u22, t22)), p22 += 4);
        }
        return r22 && (console.log(`num probes: ${p22}`), console.log(`best distance: ${h22.d}`)), h22.p;
      }
      function Mm(t22, e22) {
        return e22.max - t22.max;
      }
      class Im {
        constructor(t22, e22, r22, n22) {
          this.p = new bt(t22, e22), this.h = r22, this.d = function(t3, e3) {
            let r3 = false, n3 = 1 / 0;
            for (let i22 = 0; i22 < e3.length; i22++) {
              const s2 = e3[i22];
              for (let e4 = 0, i3 = s2.length, o2 = i3 - 1; e4 < i3; o2 = e4++) {
                const i4 = s2[e4], a22 = s2[o2];
                i4.y > t3.y != a22.y > t3.y && t3.x < (a22.x - i4.x) * (t3.y - i4.y) / (a22.y - i4.y) + i4.x && (r3 = !r3), n3 = Math.min(n3, zu(t3, i4, a22));
              }
            }
            return (r3 ? 1 : -1) * Math.sqrt(n3);
          }(this.p, n22), this.max = this.d + this.h * Math.SQRT2;
        }
      }
      const Sm = Object.keys, zm = Number.POSITIVE_INFINITY, km = Math.sqrt(2);
      function Em(t22, [e22, r22]) {
        let n22 = 0, i22 = 0;
        if (r22 === zm) {
          e22 < 0 && (e22 = 0);
          const r3 = e22 / km;
          switch (t22) {
            case "top-right":
            case "top-left":
              i22 = r3 - 7;
              break;
            case "bottom-right":
            case "bottom-left":
              i22 = 7 - r3;
              break;
            case "bottom":
              i22 = 7 - e22;
              break;
            case "top":
              i22 = e22 - 7;
          }
          switch (t22) {
            case "top-right":
            case "bottom-right":
              n22 = -r3;
              break;
            case "top-left":
            case "bottom-left":
              n22 = r3;
              break;
            case "left":
              n22 = e22;
              break;
            case "right":
              n22 = -e22;
          }
        } else {
          switch (e22 = Math.abs(e22), r22 = Math.abs(r22), t22) {
            case "top-right":
            case "top-left":
            case "top":
              i22 = r22 - 7;
              break;
            case "bottom-right":
            case "bottom-left":
            case "bottom":
              i22 = 7 - r22;
          }
          switch (t22) {
            case "top-right":
            case "bottom-right":
            case "right":
              n22 = -e22;
              break;
            case "top-left":
            case "bottom-left":
            case "left":
              n22 = e22;
          }
        }
        return [n22, i22];
      }
      function Pm(t22, e22, r22, n22, i22, s2, o2, a22, l22) {
        if (!e22 || !e22.usvg) return;
        const u22 = qd(n22), c22 = qd(i22), h22 = "both" !== s2 && "width" !== s2 || !$d(n22) ? 1 : Math.max(1, c22.width / u22.width), p22 = "both" !== s2 && "height" !== s2 || !Gd(n22) ? 1 : Math.max(1, c22.height / u22.height);
        r22.scaleSelf(h22, p22);
        const f22 = r22.toString();
        o2.set(f22, r22), a22.set(f22, e22);
        const { imagePosition: d22 } = am(f22, e22, sm);
        l22.set(f22, d22);
      }
      function Tm(t22, e22, r22, n22, i22, s2, o2, a22) {
        if (!t22) return;
        const l22 = function(t3, e3, r3, n3, i3) {
          if ("camera" === t3.kind) return t3.maxSize;
          if ("composite" === t3.kind) {
            const n4 = e3.possiblyEvaluate(new yo(t3.maxZoom), r3).evaluate(i3, {}, r3), s3 = e3.possiblyEvaluate(new yo(t3.minZoom), r3).evaluate(i3, {}, r3);
            return Math.max(n4, s3);
          }
          return e3.possiblyEvaluate(new yo(n3)).evaluate(i3, {}, r3);
        }(e22, r22, n22, i22, s2);
        return t22.scaleSelf(l22 * a22 * o2);
      }
      function Bm(t22, e22, r22, n22, i22, s2, o2, a22) {
        return { iconPrimary: Tm(t22.getPrimary(), e22, r22, n22, i22, s2, o2, a22), iconSecondary: Tm(t22.getSecondary(), e22, r22, n22, i22, s2, o2, a22) };
      }
      function Vm(t22, e22, r22, n22) {
        if (!t22) return;
        const i22 = e22.get(r22.toString());
        if (t22.imagePrimary = i22, n22) {
          const r3 = e22.get(n22.toString());
          t22.imageSecondary = r3;
        }
      }
      function Cm(t22, e22) {
        for (const r22 in t22.horizontal) Dm(t22.horizontal[r22], e22);
        Dm(t22.vertical, e22);
      }
      function Dm(t22, e22) {
        if (t22) {
          for (const r22 of t22.positionedLines) for (const t3 of r22.positionedGlyphs) if (null !== t3.image) {
            const r3 = t3.image.toString();
            t3.rect = e22.get(r3).paddedRect;
          }
        }
      }
      function Fm(t22) {
        switch (t22) {
          case "right":
          case "top-right":
          case "bottom-right":
            return "right";
          case "left":
          case "top-left":
          case "bottom-left":
            return "left";
        }
        return "center";
      }
      function Lm(t22, e22, r22, n22, i22, s2, o2, a22, l22) {
        const u22 = jm(s2.horizontal) || s2.vertical, c22 = r22.get("icon-text-fit-padding").evaluate(n22, {}, i22);
        let h22, p22 = e22;
        return e22 && "none" !== l22 && (t22.allowVerticalPlacement && s2.vertical && (h22 = jd(e22, s2.vertical, l22, c22, a22, o2)), u22 && (p22 = jd(e22, u22, l22, c22, a22, o2))), { defaultShapedIcon: p22, verticallyShapedIcon: h22 };
      }
      function Rm(t22, e22, r22, n22, i22, s2, o2, a22, l22, u22, c22, h22, p22, f22, d22, m22, y22, g22, x22, v22) {
        let b22 = o2.textMaxSize.evaluate(e22, {}, p22);
        void 0 === b22 ? b22 = a22 * o2.textScaleFactor : b22 *= o2.textScaleFactor;
        const _22 = t22.layers[0].layout, w22 = jm(r22.horizontal) || r22.vertical, A22 = "globe" === f22.name, M22 = cd, I2 = t22.tilePixelRatio * b22 / M22, S2 = (B22 = t22.overscaling, t22.zoom > 18 && B22 > 2 && (B22 >>= 1), Math.max(Tn / (512 * B22), 1) * _22.get("symbol-spacing")), z22 = _22.get("text-padding") * t22.tilePixelRatio, k22 = _22.get("icon-padding") * t22.tilePixelRatio, E22 = Mt(_22.get("text-max-angle")), P22 = "map" === _22.get("icon-rotation-alignment") && "point" !== v22, T2 = S2 / 2;
        var B22;
        false === t22.hasAnyIconTextFit && "none" !== y22 && (t22.hasAnyIconTextFit = true);
        const V2 = e22.properties ? +e22.properties[jh] : null, C22 = V2 && t22.elevationFeatureIdToIndex ? t22.elevationFeatureIdToIndex.get(V2) : 65535, D22 = (a3, l3, v3) => {
          if (l3.x < 0 || l3.x >= Tn || l3.y < 0 || l3.y >= Tn) return;
          let b3 = null;
          if (A22) {
            const { x: t3, y: e3, z: r3 } = f22.projectTilePoint(l3.x, l3.y, v3);
            b3 = { anchor: new Yd(t3, e3, r3, 0, void 0), up: f22.upVector(v3, l3.x, l3.y) };
          }
          !function(t3, e3, r3, n3, i3, s3, o3, a4, l4, u3, c3, h3, p3, f3, d3, m3, y3, g3, x3, v4, b4, _3, w3, A3, M3, I3, S3, z3, k3) {
            const E3 = t3.addToLineVertexArray(e3, n3);
            let P3, T3, B3, V3, C3, D3, F2, L22 = 0, R22 = 0, O2 = 0, U22 = 0, N22 = -1, j22 = -1;
            const $2 = {};
            let G2 = Ze("");
            const q22 = r3 ? r3.anchor : e3, H2 = "none" !== z3;
            let X22 = 0, Z2 = 0;
            if (void 0 === l4._unevaluatedLayout.getValue("text-radial-offset")) {
              const t4 = l4.layout.get("text-offset").evaluate(b4, {}, M3);
              X22 = t4[0] * cd, Z2 = t4[1] * cd;
            } else X22 = l4.layout.get("text-radial-offset").evaluate(b4, {}, M3) * cd, Z2 = zm;
            if (t3.allowVerticalPlacement && i3.vertical) {
              const t4 = i3.vertical;
              if (d3) D3 = Gm(t4), a4 && (F2 = Gm(a4));
              else {
                const r4 = l4.layout.get("text-rotate").evaluate(b4, {}, M3) + 90;
                B3 = $m(u3, q22, e3, c3, h3, p3, t4, f3, r4, m3), a4 && (V3 = $m(u3, q22, e3, c3, h3, p3, a4, g3, r4));
              }
            }
            if (s3) {
              const n4 = t3.iconSizeData, i4 = l4.layout.get("icon-rotate").evaluate(b4, {}, M3), o4 = gm(s3, i4, w3, H2, _3.iconScaleFactor), f4 = a4 ? gm(a4, i4, w3, H2, _3.iconScaleFactor) : void 0;
              T3 = $m(u3, q22, e3, c3, h3, p3, s3, g3, i4, null), L22 = 4 * o4.length;
              let d4 = null;
              "source" === n4.kind ? (d4 = [Hd * l4.layout.get("icon-size").evaluate(b4, {}, M3) * _3.iconScaleFactor], d4[0] > Um && $t2(`${t3.layerIds[0]}: Value for "icon-size" is >= ${Om}. Reduce your "icon-size".`)) : "composite" === n4.kind && (d4 = [Hd * _3.compositeIconSizes[0].evaluate(b4, {}, M3) * _3.iconScaleFactor, Hd * _3.compositeIconSizes[1].evaluate(b4, {}, M3) * _3.iconScaleFactor], (d4[0] > Um || d4[1] > Um) && $t2(`${t3.layerIds[0]}: Value for "icon-size" is >= ${Om}. Reduce your "icon-size".`)), t3.addSymbols(t3.icon, o4, d4, v4, x3, b4, void 0, r3, e3, E3.lineStartIndex, E3.lineLength, -1, A3, M3, I3, S3), N22 = t3.icon.placedSymbolArray.length - 1, f4 && (R22 = 4 * f4.length, t3.addSymbols(t3.icon, f4, d4, v4, x3, b4, zd.vertical, r3, e3, E3.lineStartIndex, E3.lineLength, -1, A3, M3, I3, S3), j22 = t3.icon.placedSymbolArray.length - 1);
            }
            for (const n4 in i3.horizontal) {
              const s4 = n4, a5 = i3.horizontal[s4];
              P3 || (G2 = Ze(a5.text), d3 ? C3 = Gm(a5) : P3 = $m(u3, q22, e3, c3, h3, p3, a5, f3, l4.layout.get("text-rotate").evaluate(b4, {}, M3), m3));
              const y4 = 1 === a5.positionedLines.length;
              if (O2 += Nm(t3, r3, e3, a5, o3, l4, d3, b4, m3, E3, i3.vertical ? zd.horizontal : zd.horizontalOnly, y4 ? Sm(i3.horizontal) : [s4], $2, N22, _3, A3, M3, I3), y4) break;
            }
            i3.vertical && (U22 += Nm(t3, r3, e3, i3.vertical, o3, l4, d3, b4, m3, E3, zd.vertical, ["vertical"], $2, j22, _3, A3, M3, I3));
            let W2 = -1;
            const Y2 = (t4, e4) => t4 ? Math.max(t4, e4) : e4;
            W2 = Y2(C3, W2), W2 = Y2(D3, W2), W2 = Y2(F2, W2);
            const K22 = W2 > -1 ? 1 : 0;
            t3.glyphOffsetArray.length >= 65535 && $t2("Too many glyphs being rendered in a tile. See https://github.com/mapbox/mapbox-gl-js/issues/2907"), void 0 !== b4.sortKey && t3.addToSortKeyRanges(t3.symbolInstances.length, b4.sortKey), t3.symbolInstances.emplaceBack(e3.x, e3.y, q22.x, q22.y, q22.z, $2.right >= 0 ? $2.right : -1, $2.center >= 0 ? $2.center : -1, $2.left >= 0 ? $2.left : -1, $2.vertical >= 0 ? $2.vertical : -1, N22, j22, G2, void 0 !== P3 ? P3 : t3.collisionBoxArray.length, void 0 !== P3 ? P3 + 1 : t3.collisionBoxArray.length, void 0 !== B3 ? B3 : t3.collisionBoxArray.length, void 0 !== B3 ? B3 + 1 : t3.collisionBoxArray.length, void 0 !== T3 ? T3 : t3.collisionBoxArray.length, void 0 !== T3 ? T3 + 1 : t3.collisionBoxArray.length, V3 || t3.collisionBoxArray.length, V3 ? V3 + 1 : t3.collisionBoxArray.length, c3, O2, U22, L22, R22, K22, 0, X22, Z2, W2, 0, H2 ? 1 : 0, k3);
          }(t22, l3, b3, a3, r22, n22, s2, i22, t22.layers[0], t22.collisionBoxArray, e22.index, e22.sourceLayerIndex, t22.index, z22, x22, u22, 0, k22, P22, g22, e22, o2, c22, h22, p22, d22, m22, y22, C22);
        };
        if ("line" === v22) for (const i3 of Af(e22.geometry, 0, 0, Tn, Tn)) {
          const e3 = rm(i3, S2, E22, r22.vertical || w22, n22, M22, I2, t22.overscaling, Tn);
          for (const r3 of e3) w22 && qm(t22, w22.text, T2, r3) || D22(i3, r3, p22);
        }
        else if ("line-center" === v22) {
          for (const t3 of e22.geometry) if (t3.length > 1) {
            const e3 = em(t3, E22, r22.vertical || w22, n22, M22, I2);
            e3 && D22(t3, e3, p22);
          }
        } else if ("Polygon" === e22.type) for (const t3 of Ih(e22.geometry, 0)) {
          const e3 = Am(t3, 16);
          D22(t3[0], new Yd(e3.x, e3.y, 0, 0, void 0), p22);
        }
        else if ("LineString" === e22.type) for (const t3 of e22.geometry) D22(t3, new Yd(t3[0].x, t3[0].y, 0, 0, void 0), p22);
        else if ("Point" === e22.type) for (const t3 of e22.geometry) for (const e3 of t3) D22([e3], new Yd(e3.x, e3.y, 0, 0, void 0), p22);
      }
      const Om = 255, Um = Om * Hd;
      function Nm(t22, e22, r22, n22, i22, s2, o2, a22, l22, u22, c22, h22, p22, f22, d22, m22, y22, g22) {
        const x22 = function(t3, e3, r3, n3, i3, s3, o3, a3) {
          const l3 = [];
          if (0 === e3.positionedLines.length) return l3;
          const u3 = n3.layout.get("text-rotate").evaluate(s3, {}) * Math.PI / 180, c3 = function(t4) {
            const e4 = t4[0], r4 = t4[1], n4 = e4 * r4;
            return n4 > 0 ? [e4, -r4] : n4 < 0 ? [-e4, r4] : 0 === e4 ? [r4, e4] : [r4, -e4];
          }(r3);
          let h3 = Math.abs(e3.top - e3.bottom);
          for (const t4 of e3.positionedLines) h3 -= t4.lineOffset;
          const p3 = e3.positionedLines.length, f3 = h3 / p3;
          let d3 = e3.top - r3[1];
          for (let t4 = 0; t4 < p3; ++t4) {
            const n4 = e3.positionedLines[t4];
            d3 = wm(e3, f3, d3, t4);
            for (const t5 of n4.positionedGlyphs) {
              if (!t5.rect) continue;
              const n5 = t5.rect || {};
              let s4 = Sd + 1, h4 = true, p4 = 1, f4 = 0;
              if (t5.image) {
                const e4 = o3.get(t5.image.toString());
                if (!e4) continue;
                if (e4.sdf) {
                  $t2("SDF images are not supported in formatted text and will be ignored.");
                  continue;
                }
                h4 = false, p4 = e4.pixelRatio, s4 = sm / p4;
              }
              const m3 = (i3 || a3) && t5.vertical, y3 = t5.metrics.advance * t5.scale / 2, g3 = t5.metrics, x3 = t5.rect;
              if (null === x3) continue;
              a3 && e3.verticalizable && (f4 = t5.image ? y3 - t5.metrics.width * t5.scale / 2 : 0);
              const v3 = i3 ? [t5.x + y3, t5.y] : [0, 0];
              let b3 = [0, 0], _22 = [0, 0], w22 = false;
              i3 || (m3 ? (_22 = [t5.x + y3 + c3[0], t5.y + c3[1] - f4], w22 = true) : b3 = [t5.x + y3 + r3[0], t5.y + r3[1] - f4]);
              const A22 = x3.w * t5.scale / (p4 * (t5.localGlyph ? pm : 1)), M22 = x3.h * t5.scale / (p4 * (t5.localGlyph ? pm : 1));
              let I2, S2, z22, k22;
              if (m3) {
                const e4 = t5.y - d3, r4 = new bt(-y3, y3 - e4), n6 = -Math.PI / 2, i4 = new bt(..._22);
                I2 = new bt(-y3 + b3[0], b3[1]), I2._rotateAround(n6, r4)._add(i4), I2.x += -e4 + y3, I2.y -= (g3.left - s4) * t5.scale;
                const o4 = t5.image ? g3.advance * t5.scale : cd * t5.scale, a4 = String.fromCodePoint(t5.glyph);
                fd(a4) ? I2.x += (1 - s4) * t5.scale : dd(a4) ? I2.x += o4 - g3.height * t5.scale + (-s4 - 1) * t5.scale : I2.x += t5.image || g3.width + 2 * s4 === x3.w && g3.height + 2 * s4 === x3.h ? (o4 - M22) / 2 : (o4 - (g3.height + 2 * s4) * t5.scale) / 2, S2 = new bt(I2.x, I2.y - A22), z22 = new bt(I2.x + M22, I2.y), k22 = new bt(I2.x + M22, I2.y - A22);
              } else {
                const e4 = (g3.left - s4) * t5.scale - y3 + b3[0], r4 = (-g3.top - s4) * t5.scale + b3[1], n6 = e4 + A22, i4 = r4 + M22;
                I2 = new bt(e4, r4), S2 = new bt(n6, r4), z22 = new bt(e4, i4), k22 = new bt(n6, i4);
              }
              if (u3) {
                let t6;
                t6 = i3 ? new bt(0, 0) : w22 ? new bt(c3[0], c3[1]) : new bt(r3[0], r3[1]), I2._rotateAround(u3, t6), S2._rotateAround(u3, t6), z22._rotateAround(u3, t6), k22._rotateAround(u3, t6);
              }
              const E22 = new bt(0, 0), P22 = new bt(0, 0);
              l3.push({ tl: I2, tr: S2, bl: z22, br: k22, texPrimary: n5, texSecondary: void 0, writingMode: e3.writingMode, glyphOffset: v3, sectionIndex: t5.sectionIndex, isSDF: h4, pixelOffsetTL: E22, pixelOffsetBR: P22, minFontScaleX: 0, minFontScaleY: 0 });
            }
          }
          return l3;
        }(0, n22, l22, s2, o2, a22, i22, t22.allowVerticalPlacement), v22 = t22.textSizeData;
        let b22 = null;
        "source" === v22.kind ? (b22 = [Hd * s2.layout.get("text-size").evaluate(a22, {}, y22) * d22.textScaleFactor], b22[0] > Um && $t2(`${t22.layerIds[0]}: Value for "text-size" is >= ${Om}. Reduce your "text-size".`)) : "composite" === v22.kind && (b22 = [Hd * d22.compositeTextSizes[0].evaluate(a22, {}, y22) * d22.textScaleFactor, Hd * d22.compositeTextSizes[1].evaluate(a22, {}, y22) * d22.textScaleFactor], (b22[0] > Um || b22[1] > Um) && $t2(`${t22.layerIds[0]}: Value for "text-size" is >= ${Om}. Reduce your "text-size".`)), t22.addSymbols(t22.text, x22, b22, l22, o2, a22, c22, e22, r22, u22.lineStartIndex, u22.lineLength, f22, m22, y22, g22, false);
        for (const e3 of h22) p22[e3] = t22.text.placedSymbolArray.length - 1;
        return 4 * x22.length;
      }
      function jm(t22) {
        for (const e22 in t22) return t22[e22];
        return null;
      }
      function $m(t22, e22, r22, n22, i22, s2, o2, a22, l22, u22) {
        let c22 = o2.top, h22 = o2.bottom, p22 = o2.left, f22 = o2.right;
        if (Ud(o2) && o2.collisionPadding) {
          const t3 = o2.collisionPadding;
          p22 -= t3[0], c22 -= t3[1], f22 += t3[2], h22 += t3[3];
        }
        if (l22) {
          const t3 = new bt(p22, c22), e3 = new bt(f22, c22), r3 = new bt(p22, h22), n3 = new bt(f22, h22), i3 = Mt(l22);
          let s3 = new bt(0, 0);
          u22 && (s3 = new bt(u22[0], u22[1])), t3._rotateAround(i3, s3), e3._rotateAround(i3, s3), r3._rotateAround(i3, s3), n3._rotateAround(i3, s3), p22 = Math.min(t3.x, e3.x, r3.x, n3.x), f22 = Math.max(t3.x, e3.x, r3.x, n3.x), c22 = Math.min(t3.y, e3.y, r3.y, n3.y), h22 = Math.max(t3.y, e3.y, r3.y, n3.y);
        }
        return t22.emplaceBack(e22.x, e22.y, e22.z, r22.x, r22.y, p22, c22, f22, h22, a22, n22, i22, s2), t22.length - 1;
      }
      function Gm(t22) {
        Ud(t22) && t22.collisionPadding && (t22.top -= t22.collisionPadding[1], t22.bottom += t22.collisionPadding[3]);
        const e22 = t22.bottom - t22.top;
        return e22 > 0 ? Math.max(10, e22) : null;
      }
      function qm(t22, e22, r22, n22) {
        const i22 = t22.compareText;
        if (e22 in i22) {
          const t3 = i22[e22];
          for (let e3 = t3.length - 1; e3 >= 0; e3--) if (n22.dist(t3[e3]) < r22) return true;
        } else i22[e22] = [];
        return i22[e22].push(n22), false;
      }
      function Hm(t22, e22) {
        const r22 = t22.fovAboveCenter, n22 = t22.elevation ? t22.elevation.getMinElevationBelowMSL() * e22 : 0, i22 = (t22._camera.position[2] * t22.worldSize - n22) / Math.cos(t22._pitch), s2 = Math.sin(r22) * i22 / Math.sin(Math.max(Math.PI / 2 - t22._pitch - r22, 0.01));
        let o2 = Math.sin(t22._pitch) * s2 + i22;
        const a22 = i22 * (1 / t22._horizonShift);
        if (!t22.elevation || 0 === t22.elevation.exaggeration()) {
          let e3 = Math.max(t22.zoom - 17, 0);
          t22.isOrthographic && (e3 /= 10), o2 *= 1 + e3;
        }
        return Math.min(1.01 * o2, a22);
      }
      function Xm(t22, e22) {
        if (!e22.isReprojectedInTileSpace) return { scale: 1 << t22.z, x: t22.x, y: t22.y, x2: t22.x + 1, y2: t22.y + 1, projection: e22 };
        const r22 = Math.pow(2, -t22.z), n22 = t22.x * r22, i22 = (t22.x + 1) * r22, s2 = t22.y * r22, o2 = (t22.y + 1) * r22, a22 = Kl(n22), l22 = Kl(i22), u22 = Jl(s2), c22 = Jl(o2), h22 = e22.project(a22, u22), p22 = e22.project(l22, u22), f22 = e22.project(l22, c22), d22 = e22.project(a22, c22);
        let m22 = Math.min(h22.x, p22.x, f22.x, d22.x), y22 = Math.min(h22.y, p22.y, f22.y, d22.y), g22 = Math.max(h22.x, p22.x, f22.x, d22.x), x22 = Math.max(h22.y, p22.y, f22.y, d22.y);
        const v22 = r22 / 16;
        function b22(t3, r3, n3, i3, s3, o3) {
          const a3 = (n3 + s3) / 2, l3 = (i3 + o3) / 2, u3 = e22.project(Kl(a3), Jl(l3)), c3 = Math.max(0, m22 - u3.x, y22 - u3.y, u3.x - g22, u3.y - x22);
          m22 = Math.min(m22, u3.x), g22 = Math.max(g22, u3.x), y22 = Math.min(y22, u3.y), x22 = Math.max(x22, u3.y), c3 > v22 && (b22(t3, u3, n3, i3, a3, l3), b22(u3, r3, a3, l3, s3, o3));
        }
        b22(h22, p22, n22, s2, i22, s2), b22(p22, f22, i22, s2, i22, o2), b22(f22, d22, i22, o2, n22, o2), b22(d22, h22, n22, o2, n22, s2), m22 -= v22, y22 -= v22, g22 += v22, x22 += v22;
        const _22 = 1 / Math.max(g22 - m22, x22 - y22);
        return { scale: _22, x: m22 * _22, y: y22 * _22, x2: g22 * _22, y2: x22 * _22, projection: e22 };
      }
      function Zm(t22, { x: e22, y: r22 }, n22 = 0) {
        return new bt(((e22 - n22) * t22.scale - t22.x) * Tn, (r22 * t22.scale - t22.y) * Tn);
      }
      const Wm = l2(new Float32Array(16));
      class Ym {
        constructor(t22) {
          this.spec = t22, this.name = t22.name, this.wrap = false, this.requiresDraping = false, this.supportsWorldCopies = false, this.supportsTerrain = false, this.supportsFog = false, this.supportsFreeCamera = false, this.zAxisUnit = "meters", this.isReprojectedInTileSpace = true, this.unsupportedLayers = ["custom"], this.center = [0, 0], this.range = [3.5, 7];
        }
        project(t22, e22) {
          return { x: 0, y: 0, z: 0 };
        }
        unproject(t22, e22) {
          return new $l(0, 0);
        }
        projectTilePoint(t22, e22, r22) {
          return { x: t22, y: e22, z: 0 };
        }
        locationPoint(t22, e22, r22, n22 = true) {
          return t22._coordinatePoint(t22.locationCoordinate(e22, r22), n22);
        }
        pixelsPerMeter(t22, e22) {
          return Yl(1, t22) * e22;
        }
        pixelSpaceConversion(t22, e22, r22) {
          return 1;
        }
        farthestPixelDistance(t22) {
          return Hm(t22, t22.pixelsPerMeter);
        }
        pointCoordinate(t22, e22, r22, n22) {
          const i22 = t22.horizonLineFromTop(false), s2 = new bt(e22, Math.max(i22, r22));
          return t22.rayIntersectionCoordinate(t22.pointRayIntersection(s2, n22));
        }
        pointCoordinate3D(t22, e22, r22) {
          const n22 = new bt(e22, r22);
          if (t22.elevation) return t22.elevation.pointCoordinate(n22);
          {
            const e3 = this.pointCoordinate(t22, n22.x, n22.y, 0);
            return [e3.x, e3.y, e3.z];
          }
        }
        isPointAboveHorizon(t22, e22) {
          if (t22.elevation && t22.elevation.visibleDemTiles.length) return !this.pointCoordinate3D(t22, e22.x, e22.y);
          const r22 = t22.horizonLineFromTop();
          return e22.y < r22;
        }
        createInversionMatrix(t22, e22) {
          return Wm;
        }
        createTileMatrix(t22, e22, r22) {
          let n22, i22, s2;
          const o2 = r22.canonical, a22 = l2(new Float64Array(16));
          if (this.isReprojectedInTileSpace) {
            const l22 = Xm(o2, this);
            n22 = 1, i22 = l22.x + r22.wrap * l22.scale, s2 = l22.y, p2(a22, a22, [n22 / l22.scale, n22 / l22.scale, t22.pixelsPerMeter / e22]);
          } else n22 = e22 / t22.zoomScale(o2.z), i22 = (o2.x + Math.pow(2, o2.z) * r22.wrap) * n22, s2 = o2.y * n22;
          return h2(a22, a22, [i22, s2, 0]), p2(a22, a22, [n22 / Tn, n22 / Tn, 1]), a22;
        }
        upVector(t22, e22, r22) {
          return [0, 0, 1];
        }
        upVectorScale(t22, e22, r22) {
          return { metersToTile: 1 };
        }
      }
      class Km extends Ym {
        constructor(t22) {
          super(t22), this.range = [4, 7], this.center = t22.center || [-96, 37.5];
          const [e22, r22] = this.parallels = t22.parallels || [29.5, 45.5], n22 = Math.sin(Mt(e22));
          this.n = (n22 + Math.sin(Mt(r22))) / 2, this.c = 1 + n22 * (2 * this.n - n22), this.r0 = Math.sqrt(this.c) / this.n;
        }
        project(t22, e22) {
          const { n: r22, c: n22, r0: i22 } = this, s2 = Mt(t22 - this.center[0]), o2 = Mt(e22), a22 = Math.sqrt(n22 - 2 * r22 * Math.sin(o2)) / r22;
          return { x: a22 * Math.sin(s2 * r22), y: a22 * Math.cos(s2 * r22) - i22, z: 0 };
        }
        unproject(t22, e22) {
          const { n: r22, c: n22, r0: i22 } = this, s2 = i22 + e22;
          let o2 = Math.atan2(t22, Math.abs(s2)) * Math.sign(s2);
          s2 * r22 < 0 && (o2 -= Math.PI * Math.sign(t22) * Math.sign(s2));
          const a22 = Mt(this.center[0]) * r22;
          o2 = Bt(o2, -Math.PI - a22, Math.PI - a22);
          const l22 = Pt(It2(o2 / r22) + this.center[0], -180, 180), u22 = Math.asin(Pt((n22 - (t22 * t22 + s2 * s2) * r22 * r22) / (2 * r22), -1, 1)), c22 = Pt(It2(u22), -tu, tu);
          return new $l(l22, c22);
        }
      }
      const Jm = 1.340264, Qm = -0.081106, ty = 893e-6, ey = 3796e-6, ry = Math.sqrt(3) / 2;
      class ny extends Ym {
        project(t22, e22) {
          e22 = e22 / 180 * Math.PI, t22 = t22 / 180 * Math.PI;
          const r22 = Math.asin(ry * Math.sin(e22)), n22 = r22 * r22, i22 = n22 * n22 * n22;
          return { x: 0.5 * (t22 * Math.cos(r22) / (ry * (Jm + 3 * Qm * n22 + i22 * (7 * ty + 9 * ey * n22))) / Math.PI + 0.5), y: 1 - 0.5 * (r22 * (Jm + Qm * n22 + i22 * (ty + ey * n22)) / Math.PI + 1), z: 0 };
        }
        unproject(t22, e22) {
          t22 = (2 * t22 - 0.5) * Math.PI;
          let r22 = e22 = (2 * (1 - e22) - 1) * Math.PI, n22 = r22 * r22, i22 = n22 * n22 * n22;
          for (let t3, s3, o3, a3 = 0; a3 < 12 && (s3 = r22 * (Jm + Qm * n22 + i22 * (ty + ey * n22)) - e22, o3 = Jm + 3 * Qm * n22 + i22 * (7 * ty + 9 * ey * n22), t3 = s3 / o3, r22 = Pt(r22 - t3, -Math.PI / 3, Math.PI / 3), n22 = r22 * r22, i22 = n22 * n22 * n22, !(Math.abs(t3) < 1e-12)); ++a3) ;
          const s2 = ry * t22 * (Jm + 3 * Qm * n22 + i22 * (7 * ty + 9 * ey * n22)) / Math.cos(r22), o2 = Math.asin(Math.sin(r22) / ry), a22 = Pt(180 * s2 / Math.PI, -180, 180), l22 = Pt(180 * o2 / Math.PI, -tu, tu);
          return new $l(a22, l22);
        }
      }
      class iy extends Ym {
        constructor(t22) {
          super(t22), this.wrap = true, this.supportsWorldCopies = true;
        }
        project(t22, e22) {
          return { x: 0.5 + t22 / 360, y: 0.5 - e22 / 360, z: 0 };
        }
        unproject(t22, e22) {
          const r22 = 360 * (t22 - 0.5), n22 = Pt(360 * (0.5 - e22), -tu, tu);
          return new $l(r22, n22);
        }
      }
      const sy = Math.PI / 2;
      function oy(t22) {
        return Math.tan((sy + t22) / 2);
      }
      class ay extends Ym {
        constructor(t22) {
          super(t22), this.center = t22.center || [0, 30];
          const [e22, r22] = this.parallels = t22.parallels || [30, 30];
          let n22 = Mt(e22), i22 = Mt(r22);
          this.southernCenter = n22 + i22 < 0, this.southernCenter && (n22 = -n22, i22 = -i22);
          const s2 = Math.cos(n22), o2 = oy(n22);
          this.n = n22 === i22 ? Math.sin(n22) : Math.log(s2 / Math.cos(i22)) / Math.log(oy(i22) / o2), this.f = s2 * Math.pow(oy(n22), this.n) / this.n;
        }
        project(t22, e22) {
          e22 = Mt(e22), this.southernCenter && (e22 = -e22), t22 = Mt(t22 - this.center[0]);
          const r22 = 1e-6, { n: n22, f: i22 } = this;
          i22 > 0 ? e22 < -sy + r22 && (e22 = -sy + r22) : e22 > sy - r22 && (e22 = sy - r22);
          const s2 = i22 / Math.pow(oy(e22), n22);
          let o2 = s2 * Math.sin(n22 * t22), a22 = i22 - s2 * Math.cos(n22 * t22);
          return o2 = 0.5 * (o2 / Math.PI + 0.5), a22 = 0.5 * (a22 / Math.PI + 0.5), { x: o2, y: this.southernCenter ? a22 : 1 - a22, z: 0 };
        }
        unproject(t22, e22) {
          t22 = (2 * t22 - 0.5) * Math.PI, this.southernCenter && (e22 = 1 - e22), e22 = (2 * (1 - e22) - 0.5) * Math.PI;
          const { n: r22, f: n22 } = this, i22 = n22 - e22, s2 = Math.sign(i22), o2 = Math.sign(r22) * Math.sqrt(t22 * t22 + i22 * i22);
          let a22 = Math.atan2(t22, Math.abs(i22)) * s2;
          i22 * r22 < 0 && (a22 -= Math.PI * Math.sign(t22) * s2);
          const l22 = Pt(It2(a22 / r22) + this.center[0], -180, 180), u22 = Pt(It2(2 * Math.atan(Math.pow(n22 / o2, 1 / r22)) - sy), -tu, tu);
          return new $l(l22, this.southernCenter ? -u22 : u22);
        }
      }
      class ly extends Ym {
        constructor(t22) {
          super(t22), this.wrap = true, this.supportsWorldCopies = true, this.supportsTerrain = true, this.supportsFog = true, this.supportsFreeCamera = true, this.isReprojectedInTileSpace = false, this.unsupportedLayers = [], this.range = null;
        }
        project(t22, e22) {
          return { x: Zl(t22), y: Wl(e22), z: 0 };
        }
        unproject(t22, e22) {
          const r22 = Kl(t22), n22 = Jl(e22);
          return new $l(r22, n22);
        }
      }
      const uy = Mt(tu);
      class cy extends Ym {
        project(t22, e22) {
          const r22 = (e22 = Mt(e22)) * e22, n22 = r22 * r22;
          return { x: 0.5 * ((t22 = Mt(t22)) * (0.8707 - 0.131979 * r22 + n22 * (n22 * (3971e-6 * r22 - 1529e-6 * n22) - 0.013791)) / Math.PI + 0.5), y: 1 - 0.5 * (e22 * (1.007226 + r22 * (0.015085 + n22 * (0.028874 * r22 - 0.044475 - 5916e-6 * n22))) / Math.PI + 1), z: 0 };
        }
        unproject(t22, e22) {
          t22 = (2 * t22 - 0.5) * Math.PI;
          let r22 = e22 = (2 * (1 - e22) - 1) * Math.PI, n22 = 25, i22 = 0, s2 = r22 * r22;
          do {
            s2 = r22 * r22;
            const t3 = s2 * s2;
            i22 = (r22 * (1.007226 + s2 * (0.015085 + t3 * (0.028874 * s2 - 0.044475 - 5916e-6 * t3))) - e22) / (1.007226 + s2 * (0.045255 + t3 * (0.259866 * s2 - 0.311325 - 5916e-6 * 11 * t3))), r22 = Pt(r22 - i22, -uy, uy);
          } while (Math.abs(i22) > 1e-6 && --n22 > 0);
          s2 = r22 * r22;
          const o2 = Pt(It2(t22 / (0.8707 + s2 * (s2 * (s2 * s2 * s2 * (3971e-6 - 1529e-6 * s2) - 0.013791) - 0.131979))), -180, 180), a22 = It2(r22);
          return new $l(o2, a22);
        }
      }
      const hy = Mt(tu);
      class py extends Ym {
        project(t22, e22) {
          e22 = Mt(e22), t22 = Mt(t22);
          const r22 = Math.cos(e22), n22 = 2 / Math.PI, i22 = Math.acos(r22 * Math.cos(t22 / 2)), s2 = Math.sin(i22) / i22, o2 = 0.5 * (t22 * n22 + 2 * r22 * Math.sin(t22 / 2) / s2) || 0, a22 = 0.5 * (e22 + Math.sin(e22) / s2) || 0;
          return { x: 0.5 * (o2 / Math.PI + 0.5), y: 1 - 0.5 * (a22 / Math.PI + 1), z: 0 };
        }
        unproject(t22, e22) {
          let r22 = t22 = (2 * t22 - 0.5) * Math.PI, n22 = e22 = (2 * (1 - e22) - 1) * Math.PI, i22 = 25;
          const s2 = 1e-6;
          let o2 = 0, a22 = 0;
          do {
            const i3 = Math.cos(n22), s3 = Math.sin(n22), l22 = 2 * s3 * i3, u22 = s3 * s3, c22 = i3 * i3, h22 = Math.cos(r22 / 2), p22 = Math.sin(r22 / 2), f22 = 2 * h22 * p22, d22 = p22 * p22, m22 = 1 - c22 * h22 * h22, y22 = m22 ? 1 / m22 : 0, g22 = m22 ? Math.acos(i3 * h22) * Math.sqrt(1 / m22) : 0, x22 = 0.5 * (2 * g22 * i3 * p22 + 2 * r22 / Math.PI) - t22, v22 = 0.5 * (g22 * s3 + n22) - e22, b22 = 0.5 * y22 * (c22 * d22 + g22 * i3 * h22 * u22) + 1 / Math.PI, _22 = y22 * (f22 * l22 / 4 - g22 * s3 * p22), w22 = 0.125 * y22 * (l22 * p22 - g22 * s3 * c22 * f22), A22 = 0.5 * y22 * (u22 * h22 + g22 * d22 * i3) + 0.5, M22 = _22 * w22 - A22 * b22;
            o2 = (v22 * _22 - x22 * A22) / M22, a22 = (x22 * w22 - v22 * b22) / M22, r22 = Pt(r22 - o2, -Math.PI, Math.PI), n22 = Pt(n22 - a22, -hy, hy);
          } while ((Math.abs(o2) > s2 || Math.abs(a22) > s2) && --i22 > 0);
          return new $l(It2(r22), It2(n22));
        }
      }
      class fy extends Ym {
        constructor(t22) {
          super(t22), this.center = t22.center || [0, 0], this.parallels = t22.parallels || [0, 0], this.cosPhi = Math.max(0.01, Math.cos(Mt(this.parallels[0]))), this.scale = 1 / (2 * Math.max(Math.PI * this.cosPhi, 1 / this.cosPhi)), this.wrap = true, this.supportsWorldCopies = true;
        }
        project(t22, e22) {
          const { scale: r22, cosPhi: n22 } = this;
          return { x: Mt(t22) * n22 * r22 + 0.5, y: -Math.sin(Mt(e22)) / n22 * r22 + 0.5, z: 0 };
        }
        unproject(t22, e22) {
          const { scale: r22, cosPhi: n22 } = this, i22 = -(e22 - 0.5) / r22, s2 = Pt(It2((t22 - 0.5) / r22) / n22, -180, 180), o2 = Math.asin(Pt(i22 * n22, -1, 1)), a22 = Pt(It2(o2), -tu, tu);
          return new $l(s2, a22);
        }
      }
      class dy extends ly {
        constructor(t22) {
          super(t22), this.requiresDraping = true, this.supportsWorldCopies = false, this.supportsFog = true, this.zAxisUnit = "pixels", this.unsupportedLayers = ["debug"], this.range = [3, 5];
        }
        projectTilePoint(t22, e22, r22) {
          const n22 = yc(t22, e22, r22);
          return R2(n22, n22, vc(cc(r22))), { x: n22[0], y: n22[1], z: n22[2] };
        }
        locationPoint(t22, e22, r22) {
          const n22 = Ul(e22.lat, e22.lng), i22 = C([], n22), s2 = r22 ? t22._centerAltitude + r22 : t22.elevation ? t22.elevation.getAtPointOrZero(t22.locationCoordinate(e22), t22._centerAltitude) : t22._centerAltitude;
          P2(n22, n22, i22, Yl(1, 0) * Tn * s2);
          const o2 = l2(new Float64Array(16));
          return c2(o2, t22.pixelMatrix, t22.globeMatrix), R2(n22, n22, o2), new bt(n22[0], n22[1]);
        }
        pixelsPerMeter(t22, e22) {
          return Yl(1, 0) * e22;
        }
        pixelSpaceConversion(t22, e22, r22) {
          const n22 = Yl(1, t22) * e22, i22 = or(Yl(1, 45) * e22, n22, r22);
          return this.pixelsPerMeter(t22, e22) / i22;
        }
        createTileMatrix(t22, e22, r22) {
          const n22 = bc(cc(r22.canonical));
          return c2(new Float64Array(16), t22.globeMatrix, n22);
        }
        createInversionMatrix(t22, e22) {
          const { center: r22 } = t22, n22 = vc(cc(e22));
          return d2(n22, n22, Mt(r22.lng)), f2(n22, n22, Mt(r22.lat)), p2(n22, n22, [t22._pixelsPerMercatorPixel, t22._pixelsPerMercatorPixel, 1]), Float32Array.from(n22);
        }
        pointCoordinate(t22, e22, r22, n22) {
          return ac(t22, e22, r22, true) || new su(0, 0);
        }
        pointCoordinate3D(t22, e22, r22) {
          const n22 = this.pointCoordinate(t22, e22, r22, 0);
          return [n22.x, n22.y, n22.z];
        }
        isPointAboveHorizon(t22, e22) {
          return !ac(t22, e22.x, e22.y, false);
        }
        farthestPixelDistance(t22) {
          const e22 = function(t3, e3) {
            const r3 = t3.cameraToCenterDistance, n22 = t3._centerAltitude * e3, i22 = t3._camera, s2 = t3._camera.forward(), o2 = M2([], E2([], s2, -r3), [0, 0, n22]), a22 = t3.worldSize / (2 * Math.PI), l22 = [0, 0, -a22], u22 = t3.width / t3.height, c22 = Math.tan(t3.fovAboveCenter), h22 = E2([], i22.up(), c22), p22 = E2([], i22.right(), c22 * u22), f22 = C([], M2([], M2([], s2, h22), p22)), d22 = [];
            let m22;
            if (new Ku(o2, f22).closestPointOnSphere(l22, a22, d22)) {
              const e4 = M2([], d22, l22), r4 = j2([], e4, o2);
              m22 = Math.cos(t3.fovAboveCenter) * w2(r4);
            } else {
              const t4 = j2([], o2, l22), e4 = j2([], l22, o2);
              C(e4, e4);
              const r4 = w2(t4) - a22;
              m22 = Math.sqrt(r4 * (r4 + 2 * a22));
              const n3 = Math.acos(m22 / (a22 + r4)) - Math.acos(D2(s2, e4));
              m22 *= Math.cos(n3);
            }
            return 1.01 * m22;
          }(t22, this.pixelsPerMeter(t22.center.lat, t22.worldSize)), r22 = Mc(t22.zoom);
          if (r22 > 0) {
            const n22 = Hm(t22, Yl(1, t22.center.lat) * t22.worldSize), i22 = t22.worldSize / (2 * Math.PI), s2 = Math.max(t22.width, t22.height) / t22.worldSize * Math.PI;
            return or(e22, n22 + i22 * (1 - Math.cos(s2)), Math.pow(r22, 10));
          }
          return e22;
        }
        upVector(t22, e22, r22) {
          return yc(e22, r22, t22, 1);
        }
        upVectorScale(t22) {
          return { metersToTile: sc(gc(cc(t22))) };
        }
      }
      function my(t22) {
        const e22 = t22.parallels, r22 = !!e22 && Math.abs(e22[0] + e22[1]) < 0.01;
        switch (t22.name) {
          case "mercator":
            return new ly(t22);
          case "equirectangular":
            return new iy(t22);
          case "naturalEarth":
            return new cy(t22);
          case "equalEarth":
            return new ny(t22);
          case "winkelTripel":
            return new py(t22);
          case "albers":
            return r22 ? new fy(t22) : new Km(t22);
          case "lambertConformalConic":
            return r22 ? new fy(t22) : new ay(t22);
          case "globe":
            return new dy(t22);
        }
        throw new Error(`Invalid projection name: ${t22.name}`);
      }
      const yy = Nh.VectorTileFeature.types, gy = [{ name: "a_fade_opacity", components: 1, type: "Uint8", offset: 0 }];
      function xy(t22, e22, r22, n22, i22, s2, o2, a22, l22, u22, c22, h22, p22) {
        const f22 = a22 ? Math.min(Um, Math.round(a22[0])) : 0, d22 = a22 ? Math.min(Um, Math.round(a22[1])) : 0;
        t22.emplaceBack(e22, r22, Math.round(32 * n22), Math.round(32 * i22), s2, o2, (f22 << 1) + (l22 ? 1 : 0), d22, 16 * u22, 16 * c22, 256 * h22, 256 * p22);
      }
      function vy(t22, e22, r22) {
        t22.emplaceBack(e22, r22);
      }
      function by(t22, e22, r22, n22, i22, s2, o2) {
        t22.emplaceBack(e22, r22, n22, i22, s2, o2);
      }
      function _y(t22, e22, r22, n22, i22) {
        t22.emplaceBack(e22, r22, n22, i22), t22.emplaceBack(e22, r22, n22, i22), t22.emplaceBack(e22, r22, n22, i22), t22.emplaceBack(e22, r22, n22, i22);
      }
      function wy(t22) {
        for (const e22 of t22.sections) if (ro(e22.text)) return true;
        return false;
      }
      class Ay {
        constructor(t22) {
          this.layoutVertexArray = new fa(), this.indexArray = new wa(), this.programConfigurations = t22, this.segments = new Ka(), this.dynamicLayoutVertexArray = new ma(), this.opacityVertexArray = new ya(), this.placedSymbolArray = new Oa(), this.iconTransitioningVertexArray = new ga(), this.globeExtVertexArray = new da(), this.zOffsetVertexArray = new ia();
        }
        isEmpty() {
          return 0 === this.layoutVertexArray.length && 0 === this.indexArray.length && 0 === this.dynamicLayoutVertexArray.length && 0 === this.opacityVertexArray.length && 0 === this.iconTransitioningVertexArray.length;
        }
        upload(t22, e22, r22, n22, i22) {
          this.isEmpty() || (r22 && (this.layoutVertexBuffer = t22.createVertexBuffer(this.layoutVertexArray, ed.members), this.indexBuffer = t22.createIndexBuffer(this.indexArray, e22), this.dynamicLayoutVertexBuffer = t22.createVertexBuffer(this.dynamicLayoutVertexArray, nd.members, true), this.opacityVertexBuffer = t22.createVertexBuffer(this.opacityVertexArray, gy, true), this.iconTransitioningVertexArray.length > 0 && (this.iconTransitioningVertexBuffer = t22.createVertexBuffer(this.iconTransitioningVertexArray, sd.members, true)), this.globeExtVertexArray.length > 0 && (this.globeExtVertexBuffer = t22.createVertexBuffer(this.globeExtVertexArray, rd.members, true)), !this.zOffsetVertexBuffer && (this.zOffsetVertexArray.length > 0 || i22) && (this.zOffsetVertexBuffer = t22.createVertexBuffer(this.zOffsetVertexArray, id2.members, true)), this.opacityVertexBuffer.itemSize = 1), (r22 || n22) && this.programConfigurations.upload(t22));
        }
        destroy() {
          this.layoutVertexBuffer && (this.layoutVertexBuffer.destroy(), this.indexBuffer.destroy(), this.programConfigurations.destroy(), this.segments.destroy(), this.dynamicLayoutVertexBuffer.destroy(), this.opacityVertexBuffer.destroy(), this.iconTransitioningVertexBuffer && this.iconTransitioningVertexBuffer.destroy(), this.globeExtVertexBuffer && this.globeExtVertexBuffer.destroy(), this.zOffsetVertexBuffer && this.zOffsetVertexBuffer.destroy());
        }
      }
      js(Ay, "SymbolBuffers");
      class My {
        constructor(t22, e22, r22) {
          this.layoutVertexArray = new t22(), this.layoutAttributes = e22, this.indexArray = new r22(), this.segments = new Ka(), this.collisionVertexArray = new _a2(), this.collisionVertexArrayExt = new ma();
        }
        upload(t22) {
          this.layoutVertexBuffer = t22.createVertexBuffer(this.layoutVertexArray, this.layoutAttributes), this.indexBuffer = t22.createIndexBuffer(this.indexArray), this.collisionVertexBuffer = t22.createVertexBuffer(this.collisionVertexArray, od.members, true), this.collisionVertexBufferExt = t22.createVertexBuffer(this.collisionVertexArrayExt, ad.members, true);
        }
        destroy() {
          this.layoutVertexBuffer && (this.layoutVertexBuffer.destroy(), this.indexBuffer.destroy(), this.segments.destroy(), this.collisionVertexBuffer.destroy(), this.collisionVertexBufferExt.destroy());
        }
      }
      js(My, "CollisionBuffers");
      class Iy {
        constructor(t22) {
          this.collisionBoxArray = t22.collisionBoxArray, this.zoom = t22.zoom, this.lut = t22.lut, this.overscaling = t22.overscaling, this.layers = t22.layers, this.layerIds = this.layers.map((t3) => t3.fqid), this.index = t22.index, this.pixelRatio = t22.pixelRatio, this.sourceLayerIndex = t22.sourceLayerIndex, this.hasPattern = false, this.hasRTLText = false, this.fullyClipped = false, this.hasAnyIconTextFit = false, this.sortKeyRanges = [], this.collisionCircleArray = [], this.placementInvProjMatrix = l2([]), this.placementViewportMatrix = l2([]);
          const e22 = this.layers[0]._unevaluatedLayout._values;
          this.textSizeData = Xd(this.zoom, e22["text-size"]), this.iconSizeData = Xd(this.zoom, e22["icon-size"]);
          const r22 = this.layers[0].layout, n22 = r22.get("symbol-sort-key"), i22 = r22.get("symbol-z-order");
          this.canOverlap = r22.get("text-allow-overlap") || r22.get("icon-allow-overlap") || r22.get("text-ignore-placement") || r22.get("icon-ignore-placement"), this.sortFeaturesByKey = "viewport-y" !== i22 && void 0 !== n22.constantOr(1), this.sortFeaturesByY = ("viewport-y" === i22 || "auto" === i22 && !this.sortFeaturesByKey) && this.canOverlap, this.writingModes = r22.get("text-writing-mode").map((t3) => zd[t3]), this.stateDependentLayerIds = this.layers.filter((t3) => t3.isStateDependent()).map((t3) => t3.id), this.sourceID = t22.sourceID, this.projection = t22.projection, this.hasAnyZOffset = false, this.zOffsetSortDirty = false, this.zOffsetBuffersNeedUpload = false, this.elevationType = "none", this.elevationStateComplete = false, this.activeReplacements = [], this.replacementUpdateTime = 0;
        }
        createArrays() {
          this.text = new Ay(new Il(this.layers, { zoom: this.zoom, lut: this.lut }, (t22) => t22.startsWith("text") || t22.startsWith("symbol"))), this.icon = new Ay(new Il(this.layers, { zoom: this.zoom, lut: this.lut }, (t22) => t22.startsWith("icon") || t22.startsWith("symbol"))), this.glyphOffsetArray = new ja(), this.lineVertexArray = new $a(), this.symbolInstances = new Na();
        }
        calculateGlyphDependencies(t22, e22, r22, n22, i22) {
          for (const r3 of t22) {
            const t3 = r3.codePointAt(0);
            if (void 0 === t3) break;
            if (e22[t3] = true, n22 && i22 && t3 <= 65535) {
              const t4 = pd[r3];
              t4 && (e22[t4.charCodeAt(0)] = true);
            }
          }
        }
        updateFootprints(t22, e22) {
        }
        updateReplacement(t22, e22) {
          if (e22.updateTime === this.replacementUpdateTime) return false;
          this.replacementUpdateTime = e22.updateTime;
          const r22 = e22.getReplacementRegionsForTile(t22.toUnwrapped(), true);
          return !Bp(this.activeReplacements, r22) && (this.activeReplacements = r22, true);
        }
        populate(t22, e22, r22, n22) {
          const i22 = this.layers[0], s2 = i22.layout, o2 = "globe" === this.projection.name, a22 = s2.get("text-font"), l22 = s2.get("text-field"), u22 = s2.get("icon-image"), [c22, h22] = s2.get("icon-size-scale-range"), p22 = Pt(e22.scaleFactor || 1, c22, h22), f22 = ("constant" !== l22.value.kind || l22.value.value instanceof Tr && !l22.value.value.isEmpty() || l22.value.value.toString().length > 0) && ("constant" !== a22.value.kind || a22.value.value.length > 0), d22 = "constant" !== u22.value.kind || !!u22.value.value || Object.keys(u22.parameters).length > 0, m22 = s2.get("symbol-sort-key");
          if (this.features = [], !f22 && !d22) return;
          const y22 = e22.iconDependencies, g22 = e22.glyphDependencies, x22 = e22.availableImages, v22 = new yo(this.zoom);
          for (const { feature: e3, id: l3, index: u3, sourceLayerIndex: c3 } of t22) {
            const t3 = i22._featureFilter.needGeometry, h3 = du(e3, t3);
            if (!i22._featureFilter.filter(v22, h3, r22)) continue;
            if (t3 || (h3.geometry = fu(e3, r22, n22)), o2 && 1 !== e3.type && r22.z <= 5) {
              const t4 = h3.geometry, e4 = 0.98078528056, n3 = (t5, n4) => D2(yc(t5.x, t5.y, r22, 1), yc(n4.x, n4.y, r22, 1)) < e4;
              for (let e5 = 0; e5 < t4.length; e5++) t4[e5] = uu(t4[e5], n3);
            }
            let b22, _22;
            if (f22) {
              const t4 = i22.getValueAndResolveTokens("text-field", h3, r22, x22), e4 = Tr.factory(t4);
              wy(e4) && (this.hasRTLText = true), (!this.hasRTLText || "unavailable" === po() || this.hasRTLText && mo.isParsed()) && (b22 = hd(e4, i22, h3));
            }
            if (d22) {
              const t4 = i22.getValueAndResolveTokens("icon-image", h3, r22, x22);
              _22 = "string" == typeof t4 ? Vr.build(t4) : t4;
            }
            if (!b22 && !_22) continue;
            const w22 = this.sortFeaturesByKey ? m22.evaluate(h3, {}, r22) : void 0, A22 = { id: l3, text: b22, icon: _22, index: u3, sourceLayerIndex: c3, geometry: h3.geometry, properties: e3.properties, type: yy[e3.type], sortKey: w22 };
            if (this.features.push(A22), _22) {
              const t4 = this.layers[0]._unevaluatedLayout._values, { iconPrimary: e4, iconSecondary: n3 } = Bm(_22, this.iconSizeData, t4["icon-size"], r22, this.zoom, A22, this.pixelRatio, p22), i3 = e4.id.toString();
              if (y22.has(i3) ? y22.get(i3).push(e4) : y22.set(i3, [e4]), n3) {
                const t5 = n3.id.toString();
                y22.has(t5) ? y22.get(t5).push(n3) : y22.set(t5, [n3]);
              }
            }
            if (b22) {
              const t4 = a22.evaluate(h3, {}, r22).join(","), e4 = "map" === s2.get("text-rotation-alignment") && "point" !== s2.get("symbol-placement");
              this.allowVerticalPlacement = this.writingModes && this.writingModes.indexOf(zd.vertical) >= 0;
              for (const r3 of b22.sections) if (r3.image) {
                const t5 = r3.image.getPrimary().scaleSelf(this.pixelRatio), e5 = t5.id.toString(), n3 = y22.get(e5) || [];
                n3.push(t5), y22.set(e5, n3);
              } else {
                const n3 = Zs(b22.toString()), i3 = r3.fontStack || t4, s3 = g22[i3] = g22[i3] || {};
                this.calculateGlyphDependencies(r3.text, s3, e4, this.allowVerticalPlacement, n3);
              }
            }
          }
          if ("line" === s2.get("symbol-placement") && (this.features = function(t3) {
            const e3 = {}, r3 = {}, n3 = [];
            let i3 = 0;
            function s3(e4) {
              n3.push(t3[e4]), i3++;
            }
            function o3(t4, e4, i4) {
              const s4 = r3[t4];
              return delete r3[t4], r3[e4] = s4, n3[s4].geometry[0].pop(), n3[s4].geometry[0] = n3[s4].geometry[0].concat(i4[0]), s4;
            }
            function a3(t4, r4, i4) {
              const s4 = e3[r4];
              return delete e3[r4], e3[t4] = s4, n3[s4].geometry[0].shift(), n3[s4].geometry[0] = i4[0].concat(n3[s4].geometry[0]), s4;
            }
            function l3(t4, e4, r4) {
              const n4 = r4 ? e4[0][e4[0].length - 1] : e4[0][0];
              return `${t4}:${n4.x}:${n4.y}`;
            }
            for (let u3 = 0; u3 < t3.length; u3++) {
              const c3 = t3[u3], h3 = c3.geometry, p3 = c3.text ? c3.text.toString() : null;
              if (!p3) {
                s3(u3);
                continue;
              }
              const f3 = l3(p3, h3), d3 = l3(p3, h3, true);
              if (f3 in r3 && d3 in e3 && r3[f3] !== e3[d3]) {
                const t4 = a3(f3, d3, h3), i4 = o3(f3, d3, n3[t4].geometry);
                delete e3[f3], delete r3[d3], r3[l3(p3, n3[i4].geometry, true)] = i4, n3[t4].geometry = null;
              } else f3 in r3 ? o3(f3, d3, h3) : d3 in e3 ? a3(f3, d3, h3) : (s3(u3), e3[f3] = i3 - 1, r3[d3] = i3 - 1);
            }
            return n3.filter((t4) => t4.geometry);
          }(this.features)), "hd-road-markup" === s2.get("symbol-elevation-reference")) {
            if (this.elevationType = "road", e22.elevationFeatures) {
              !this.elevationFeatures && e22.elevationFeatures.length > 0 && (this.elevationFeatures = [], this.elevationFeatureIdToIndex = /* @__PURE__ */ new Map());
              for (const t3 of e22.elevationFeatures) this.elevationFeatureIdToIndex.set(t3.id, this.elevationFeatures.length), this.elevationFeatures.push(t3);
            }
          } else s2.get("symbol-z-elevate") && (this.elevationType = "offset");
          "none" !== this.elevationType && (this.zOffsetBuffersNeedUpload = true), this.sortFeaturesByKey && this.features.sort((t3, e3) => t3.sortKey - e3.sortKey);
        }
        update(t22, e22, r22, n22, i22, s2, o2) {
          this.text.programConfigurations.updatePaintArrays(t22, e22, i22, r22, n22, s2, o2), this.icon.programConfigurations.updatePaintArrays(t22, e22, i22, r22, n22, s2, o2);
        }
        updateRoadElevation() {
          if ("road" !== this.elevationType || !this.elevationFeatures) return;
          if (this.elevationStateComplete) return;
          this.elevationStateComplete = true, this.hasAnyZOffset = false;
          let t22 = false;
          for (let e22 = 0; e22 < this.symbolInstances.length; e22++) {
            const r22 = this.symbolInstances.get(e22);
            if (65535 === r22.elevationFeatureIndex) continue;
            const n22 = this.elevationFeatures[r22.elevationFeatureIndex];
            if (n22) {
              const e3 = 0.05 + n22.pointElevation(new bt(r22.tileAnchorX, r22.tileAnchorY));
              r22.zOffset !== e3 && (t22 = true, r22.zOffset = e3);
            }
          }
          t22 && (this.zOffsetBuffersNeedUpload = true, this.zOffsetSortDirty = true);
        }
        updateZOffset() {
          const t22 = (t3, e3, n3) => {
            r22 += e3, r22 > t3.length && t3.resize(r22);
            for (let i22 = -e3; i22 < 0; i22++) t3.emplace(i22 + r22, n3);
          }, e22 = (t3, e3, r3) => {
            n22 += e3, n22 > t3.length && t3.resize(n22);
            for (let i22 = -e3; i22 < 0; i22++) t3.emplace(i22 + n22, r3);
          };
          if (!this.zOffsetBuffersNeedUpload) return;
          this.zOffsetBuffersNeedUpload = false;
          let r22 = 0, n22 = 0;
          for (let r3 = 0; r3 < this.symbolInstances.length; r3++) {
            const n3 = this.symbolInstances.get(r3), { numHorizontalGlyphVertices: i22, numVerticalGlyphVertices: s2, numIconVertices: o2 } = n3, a22 = n3.zOffset, l22 = o2 > 0;
            if ((i22 > 0 || s2 > 0) && (t22(this.text.zOffsetVertexArray, i22, a22), t22(this.text.zOffsetVertexArray, s2, a22)), l22) {
              const { placedIconSymbolIndex: t3, verticalPlacedIconSymbolIndex: r4 } = n3;
              t3 >= 0 && e22(this.icon.zOffsetVertexArray, o2, a22), r4 >= 0 && e22(this.icon.zOffsetVertexArray, n3.numVerticalIconVertices, a22);
            }
          }
          this.text.zOffsetVertexBuffer && this.text.zOffsetVertexBuffer.updateData(this.text.zOffsetVertexArray), this.icon.zOffsetVertexBuffer && this.icon.zOffsetVertexBuffer.updateData(this.icon.zOffsetVertexArray);
        }
        isEmpty() {
          return 0 === this.symbolInstances.length && !this.hasRTLText;
        }
        uploadPending() {
          return !this.uploaded || this.text.programConfigurations.needsUpload || this.icon.programConfigurations.needsUpload;
        }
        upload(t22) {
          !this.uploaded && this.hasDebugData() && (this.textCollisionBox.upload(t22), this.iconCollisionBox.upload(t22)), this.text.upload(t22, this.sortFeaturesByY, !this.uploaded, this.text.programConfigurations.needsUpload, this.zOffsetBuffersNeedUpload), this.icon.upload(t22, this.sortFeaturesByY, !this.uploaded, this.icon.programConfigurations.needsUpload, this.zOffsetBuffersNeedUpload), this.uploaded = true;
        }
        destroyDebugData() {
          this.textCollisionBox.destroy(), this.iconCollisionBox.destroy();
        }
        getProjection() {
          return this.projectionInstance || (this.projectionInstance = my(this.projection)), this.projectionInstance;
        }
        destroy() {
          this.text.destroy(), this.icon.destroy(), this.hasDebugData() && this.destroyDebugData();
        }
        addToLineVertexArray(t22, e22) {
          const r22 = this.lineVertexArray.length;
          if (void 0 !== t22.segment) for (const { x: t3, y: r3 } of e22) this.lineVertexArray.emplaceBack(t3, r3);
          return { lineStartIndex: r22, lineLength: this.lineVertexArray.length - r22 };
        }
        addSymbols(t22, e22, r22, n22, i22, s2, o2, a22, l22, u22, c22, h22, p22, f22, d22, m22) {
          const y22 = t22.indexArray, g22 = t22.layoutVertexArray, x22 = t22.globeExtVertexArray, v22 = t22.segments.prepareSegment(4 * e22.length, g22, y22, this.canOverlap ? s2.sortKey : void 0), b22 = this.glyphOffsetArray.length, _22 = v22.vertexLength, w22 = this.allowVerticalPlacement && o2 === zd.vertical ? Math.PI / 2 : 0, A22 = s2.text && s2.text.sections;
          for (let n3 = 0; n3 < e22.length; n3++) {
            const { tl: i3, tr: o3, bl: u3, br: c3, texPrimary: h3, texSecondary: b3, pixelOffsetTL: _3, pixelOffsetBR: M3, minFontScaleX: I2, minFontScaleY: S2, glyphOffset: z22, isSDF: k22, sectionIndex: E22 } = e22[n3], P22 = v22.vertexLength, T2 = z22[1];
            if (xy(g22, l22.x, l22.y, i3.x, T2 + i3.y, h3.x, h3.y, r22, k22, _3.x, _3.y, I2, S2), xy(g22, l22.x, l22.y, o3.x, T2 + o3.y, h3.x + h3.w, h3.y, r22, k22, M3.x, _3.y, I2, S2), xy(g22, l22.x, l22.y, u3.x, T2 + u3.y, h3.x, h3.y + h3.h, r22, k22, _3.x, M3.y, I2, S2), xy(g22, l22.x, l22.y, c3.x, T2 + c3.y, h3.x + h3.w, h3.y + h3.h, r22, k22, M3.x, M3.y, I2, S2), a22) {
              const { x: e3, y: r3, z: n4 } = a22.anchor, [i4, s3, o4] = a22.up;
              by(x22, e3, r3, n4, i4, s3, o4), by(x22, e3, r3, n4, i4, s3, o4), by(x22, e3, r3, n4, i4, s3, o4), by(x22, e3, r3, n4, i4, s3, o4), _y(t22.dynamicLayoutVertexArray, e3, r3, n4, w22);
            } else _y(t22.dynamicLayoutVertexArray, l22.x, l22.y, l22.z, w22);
            if (m22) {
              const e3 = b3 || h3;
              vy(t22.iconTransitioningVertexArray, e3.x, e3.y), vy(t22.iconTransitioningVertexArray, e3.x + e3.w, e3.y), vy(t22.iconTransitioningVertexArray, e3.x, e3.y + e3.h), vy(t22.iconTransitioningVertexArray, e3.x + e3.w, e3.y + e3.h);
            }
            y22.emplaceBack(P22, P22 + 1, P22 + 2), y22.emplaceBack(P22 + 1, P22 + 2, P22 + 3), v22.vertexLength += 4, v22.primitiveLength += 2, this.glyphOffsetArray.emplaceBack(z22[0]), n3 !== e22.length - 1 && E22 === e22[n3 + 1].sectionIndex || t22.programConfigurations.populatePaintArrays(g22.length, s2, s2.index, {}, p22, f22, d22, A22 && A22[E22]);
          }
          const M22 = a22 ? a22.anchor : l22;
          t22.placedSymbolArray.emplaceBack(M22.x, M22.y, M22.z, l22.x, l22.y, b22, this.glyphOffsetArray.length - b22, _22, u22, c22, l22.segment, r22 ? r22[0] : 0, r22 ? r22[1] : 0, n22[0], n22[1], o2, 0, 0, 0, h22, 0);
        }
        _commitLayoutVertex(t22, e22, r22, n22, i22, s2, o2) {
          t22.emplaceBack(e22, r22, n22, i22, s2, Math.round(o2.x), Math.round(o2.y));
        }
        _addCollisionDebugVertices(t22, e22, r22, n22, i22, s2, o2) {
          const a22 = r22.segments.prepareSegment(4, r22.layoutVertexArray, r22.indexArray), l22 = a22.vertexLength, u22 = o2.tileAnchorX, c22 = o2.tileAnchorY;
          for (let t3 = 0; t3 < 4; t3++) r22.collisionVertexArray.emplaceBack(0, 0, 0, 0, 0, 0);
          this._commitDebugCollisionVertexUpdate(r22.collisionVertexArrayExt, e22, t22.padding, o2.zOffset), this._commitLayoutVertex(r22.layoutVertexArray, n22, i22, s2, u22, c22, new bt(t22.x1, t22.y1)), this._commitLayoutVertex(r22.layoutVertexArray, n22, i22, s2, u22, c22, new bt(t22.x2, t22.y1)), this._commitLayoutVertex(r22.layoutVertexArray, n22, i22, s2, u22, c22, new bt(t22.x2, t22.y2)), this._commitLayoutVertex(r22.layoutVertexArray, n22, i22, s2, u22, c22, new bt(t22.x1, t22.y2)), a22.vertexLength += 4;
          const h22 = r22.indexArray;
          h22.emplaceBack(l22, l22 + 1), h22.emplaceBack(l22 + 1, l22 + 2), h22.emplaceBack(l22 + 2, l22 + 3), h22.emplaceBack(l22 + 3, l22), a22.primitiveLength += 4;
        }
        _addTextDebugCollisionBoxes(t22, e22, r22, n22, i22, s2) {
          for (let o2 = n22; o2 < i22; o2++) {
            const n3 = r22.get(o2), i3 = this.getSymbolInstanceTextSize(t22, s2, e22, o2);
            this._addCollisionDebugVertices(n3, i3, this.textCollisionBox, n3.projectedAnchorX, n3.projectedAnchorY, n3.projectedAnchorZ, s2);
          }
        }
        _addIconDebugCollisionBoxes(t22, e22, r22, n22, i22, s2) {
          for (let o2 = n22; o2 < i22; o2++) {
            const n3 = r22.get(o2), i3 = this.getSymbolInstanceIconSize(t22, e22, s2.placedIconSymbolIndex);
            this._addCollisionDebugVertices(n3, i3, this.iconCollisionBox, n3.projectedAnchorX, n3.projectedAnchorY, n3.projectedAnchorZ, s2);
          }
        }
        generateCollisionDebugBuffers(t22, e22, r22) {
          this.hasDebugData() && this.destroyDebugData(), this.textCollisionBox = new My(va, ld.members, ga), this.iconCollisionBox = new My(va, ld.members, ga);
          const n22 = Wd(this.iconSizeData, t22), i22 = Wd(this.textSizeData, t22, r22);
          for (let r3 = 0; r3 < this.symbolInstances.length; r3++) {
            const s2 = this.symbolInstances.get(r3);
            this._addTextDebugCollisionBoxes(i22, t22, e22, s2.textBoxStartIndex, s2.textBoxEndIndex, s2), this._addTextDebugCollisionBoxes(i22, t22, e22, s2.verticalTextBoxStartIndex, s2.verticalTextBoxEndIndex, s2), this._addIconDebugCollisionBoxes(n22, t22, e22, s2.iconBoxStartIndex, s2.iconBoxEndIndex, s2), this._addIconDebugCollisionBoxes(n22, t22, e22, s2.verticalIconBoxStartIndex, s2.verticalIconBoxEndIndex, s2);
          }
        }
        getSymbolInstanceTextSize(t22, e22, r22, n22) {
          const i22 = this.text.placedSymbolArray.get(e22.rightJustifiedTextSymbolIndex >= 0 ? e22.rightJustifiedTextSymbolIndex : e22.centerJustifiedTextSymbolIndex >= 0 ? e22.centerJustifiedTextSymbolIndex : e22.leftJustifiedTextSymbolIndex >= 0 ? e22.leftJustifiedTextSymbolIndex : e22.verticalPlacedTextSymbolIndex >= 0 ? e22.verticalPlacedTextSymbolIndex : n22), s2 = Zd(this.textSizeData, t22, i22) / cd;
          return this.tilePixelRatio * s2;
        }
        getSymbolInstanceIconSize(t22, e22, r22) {
          const n22 = this.icon.placedSymbolArray.get(r22), i22 = Zd(this.iconSizeData, t22, n22);
          return this.tilePixelRatio * i22;
        }
        _commitDebugCollisionVertexUpdate(t22, e22, r22, n22) {
          t22.emplaceBack(e22, -r22, -r22, n22), t22.emplaceBack(e22, r22, -r22, n22), t22.emplaceBack(e22, r22, r22, n22), t22.emplaceBack(e22, -r22, r22, n22);
        }
        _updateTextDebugCollisionBoxes(t22, e22, r22, n22, i22, s2, o2) {
          for (let o3 = n22; o3 < i22; o3++) {
            const n3 = r22.get(o3), i3 = this.getSymbolInstanceTextSize(t22, s2, e22, o3);
            this._commitDebugCollisionVertexUpdate(this.textCollisionBox.collisionVertexArrayExt, i3, n3.padding, s2.zOffset);
          }
        }
        _updateIconDebugCollisionBoxes(t22, e22, r22, n22, i22, s2, o2) {
          for (let o3 = n22; o3 < i22; o3++) {
            const n3 = r22.get(o3), i3 = this.getSymbolInstanceIconSize(t22, e22, s2.placedIconSymbolIndex);
            this._commitDebugCollisionVertexUpdate(this.iconCollisionBox.collisionVertexArrayExt, i3, n3.padding, s2.zOffset);
          }
        }
        updateCollisionDebugBuffers(t22, e22, r22, n22) {
          if (!this.hasDebugData()) return;
          this.hasTextCollisionBoxData() && this.textCollisionBox.collisionVertexArrayExt.clear(), this.hasIconCollisionBoxData() && this.iconCollisionBox.collisionVertexArrayExt.clear();
          const i22 = Wd(this.iconSizeData, t22, n22), s2 = Wd(this.textSizeData, t22, r22);
          for (let o2 = 0; o2 < this.symbolInstances.length; o2++) {
            const a22 = this.symbolInstances.get(o2);
            this._updateTextDebugCollisionBoxes(s2, t22, e22, a22.textBoxStartIndex, a22.textBoxEndIndex, a22, r22), this._updateTextDebugCollisionBoxes(s2, t22, e22, a22.verticalTextBoxStartIndex, a22.verticalTextBoxEndIndex, a22, r22), this._updateIconDebugCollisionBoxes(i22, t22, e22, a22.iconBoxStartIndex, a22.iconBoxEndIndex, a22, n22), this._updateIconDebugCollisionBoxes(i22, t22, e22, a22.verticalIconBoxStartIndex, a22.verticalIconBoxEndIndex, a22, n22);
          }
          this.hasTextCollisionBoxData() && this.textCollisionBox.collisionVertexBufferExt && this.textCollisionBox.collisionVertexBufferExt.updateData(this.textCollisionBox.collisionVertexArrayExt), this.hasIconCollisionBoxData() && this.iconCollisionBox.collisionVertexBufferExt && this.iconCollisionBox.collisionVertexBufferExt.updateData(this.iconCollisionBox.collisionVertexArrayExt);
        }
        _deserializeCollisionBoxesForSymbol(t22, e22, r22, n22, i22, s2, o2, a22, l22) {
          const u22 = {};
          if (e22 < r22) {
            const { x1: r3, y1: n3, x2: i3, y2: s3, padding: o3, projectedAnchorX: a3, projectedAnchorY: l3, projectedAnchorZ: c22, tileAnchorX: h22, tileAnchorY: p22, featureIndex: f22 } = t22.get(e22);
            u22.textBox = { x1: r3, y1: n3, x2: i3, y2: s3, padding: o3, projectedAnchorX: a3, projectedAnchorY: l3, projectedAnchorZ: c22, tileAnchorX: h22, tileAnchorY: p22 }, u22.textFeatureIndex = f22;
          }
          if (n22 < i22) {
            const { x1: e3, y1: r3, x2: i3, y2: s3, padding: o3, projectedAnchorX: a3, projectedAnchorY: l3, projectedAnchorZ: c22, tileAnchorX: h22, tileAnchorY: p22, featureIndex: f22 } = t22.get(n22);
            u22.verticalTextBox = { x1: e3, y1: r3, x2: i3, y2: s3, padding: o3, projectedAnchorX: a3, projectedAnchorY: l3, projectedAnchorZ: c22, tileAnchorX: h22, tileAnchorY: p22 }, u22.verticalTextFeatureIndex = f22;
          }
          if (s2 < o2) {
            const { x1: e3, y1: r3, x2: n3, y2: i3, padding: o3, projectedAnchorX: a3, projectedAnchorY: l3, projectedAnchorZ: c22, tileAnchorX: h22, tileAnchorY: p22, featureIndex: f22 } = t22.get(s2);
            u22.iconBox = { x1: e3, y1: r3, x2: n3, y2: i3, padding: o3, projectedAnchorX: a3, projectedAnchorY: l3, projectedAnchorZ: c22, tileAnchorX: h22, tileAnchorY: p22 }, u22.iconFeatureIndex = f22;
          }
          if (a22 < l22) {
            const { x1: e3, y1: r3, x2: n3, y2: i3, padding: s3, projectedAnchorX: o3, projectedAnchorY: l3, projectedAnchorZ: c22, tileAnchorX: h22, tileAnchorY: p22, featureIndex: f22 } = t22.get(a22);
            u22.verticalIconBox = { x1: e3, y1: r3, x2: n3, y2: i3, padding: s3, projectedAnchorX: o3, projectedAnchorY: l3, projectedAnchorZ: c22, tileAnchorX: h22, tileAnchorY: p22 }, u22.verticalIconFeatureIndex = f22;
          }
          return u22;
        }
        deserializeCollisionBoxes(t22) {
          this.collisionArrays = [];
          for (let e22 = 0; e22 < this.symbolInstances.length; e22++) {
            const r22 = this.symbolInstances.get(e22);
            this.collisionArrays.push(this._deserializeCollisionBoxesForSymbol(t22, r22.textBoxStartIndex, r22.textBoxEndIndex, r22.verticalTextBoxStartIndex, r22.verticalTextBoxEndIndex, r22.iconBoxStartIndex, r22.iconBoxEndIndex, r22.verticalIconBoxStartIndex, r22.verticalIconBoxEndIndex));
          }
        }
        hasTextData() {
          return this.text.segments.get().length > 0;
        }
        hasIconData() {
          return this.icon.segments.get().length > 0;
        }
        hasDebugData() {
          return this.textCollisionBox && this.iconCollisionBox;
        }
        hasTextCollisionBoxData() {
          return this.hasDebugData() && this.textCollisionBox.segments.get().length > 0;
        }
        hasIconCollisionBoxData() {
          return this.hasDebugData() && this.iconCollisionBox.segments.get().length > 0;
        }
        hasIconTextFit() {
          return this.hasAnyIconTextFit;
        }
        addIndicesForPlacedSymbol(t22, e22) {
          const r22 = t22.placedSymbolArray.get(e22), n22 = r22.vertexStartIndex + 4 * r22.numGlyphs;
          for (let e3 = r22.vertexStartIndex; e3 < n22; e3 += 4) t22.indexArray.emplaceBack(e3, e3 + 1, e3 + 2), t22.indexArray.emplaceBack(e3 + 1, e3 + 2, e3 + 3);
        }
        getSortedSymbolIndexes(t22) {
          if (this.sortedAngle === t22 && void 0 !== this.symbolInstanceIndexes) return this.symbolInstanceIndexes;
          const e22 = Math.sin(t22), r22 = Math.cos(t22), n22 = [], i22 = [], s2 = [];
          for (let t3 = 0; t3 < this.symbolInstances.length; ++t3) {
            s2.push(t3);
            const o2 = this.symbolInstances.get(t3);
            n22.push(0 | Math.round(e22 * o2.tileAnchorX + r22 * o2.tileAnchorY)), i22.push(o2.featureIndex);
          }
          return s2.sort((t3, e3) => n22[t3] - n22[e3] || i22[e3] - i22[t3]), s2;
        }
        getSortedIndexesByZOffset() {
          if (!this.zOffsetSortDirty) return this.symbolInstanceIndexesSortedZOffset;
          if (!this.symbolInstanceIndexesSortedZOffset) {
            this.symbolInstanceIndexesSortedZOffset = [];
            for (let t22 = 0; t22 < this.symbolInstances.length; ++t22) this.symbolInstanceIndexesSortedZOffset.push(t22);
          }
          return this.zOffsetSortDirty = false, this.symbolInstanceIndexesSortedZOffset.sort((t22, e22) => this.symbolInstances.get(e22).zOffset - this.symbolInstances.get(t22).zOffset);
        }
        addToSortKeyRanges(t22, e22) {
          const r22 = this.sortKeyRanges[this.sortKeyRanges.length - 1];
          r22 && r22.sortKey === e22 ? r22.symbolInstanceEnd = t22 + 1 : this.sortKeyRanges.push({ sortKey: e22, symbolInstanceStart: t22, symbolInstanceEnd: t22 + 1 });
        }
        sortFeatures(t22) {
          if (this.sortFeaturesByY && this.sortedAngle !== t22 && !(this.text.segments.get().length > 1 || this.icon.segments.get().length > 1)) {
            this.symbolInstanceIndexes = this.getSortedSymbolIndexes(t22), this.sortedAngle = t22, this.text.indexArray.clear(), this.icon.indexArray.clear(), this.featureSortOrder = [];
            for (const t3 of this.symbolInstanceIndexes) {
              const e22 = this.symbolInstances.get(t3);
              this.featureSortOrder.push(e22.featureIndex);
              const { rightJustifiedTextSymbolIndex: r22, centerJustifiedTextSymbolIndex: n22, leftJustifiedTextSymbolIndex: i22, verticalPlacedTextSymbolIndex: s2, placedIconSymbolIndex: o2, verticalPlacedIconSymbolIndex: a22 } = e22;
              r22 >= 0 && this.addIndicesForPlacedSymbol(this.text, r22), n22 >= 0 && n22 !== r22 && this.addIndicesForPlacedSymbol(this.text, n22), i22 >= 0 && i22 !== n22 && i22 !== r22 && this.addIndicesForPlacedSymbol(this.text, i22), s2 >= 0 && this.addIndicesForPlacedSymbol(this.text, s2), o2 >= 0 && this.addIndicesForPlacedSymbol(this.icon, o2), a22 >= 0 && this.addIndicesForPlacedSymbol(this.icon, a22);
            }
            this.text.indexBuffer && this.text.indexBuffer.updateData(this.text.indexArray), this.icon.indexBuffer && this.icon.indexBuffer.updateData(this.icon.indexArray);
          }
        }
      }
      let Sy, zy, ky;
      js(Iy, "SymbolBucket", { omit: ["layers", "collisionBoxArray", "features", "compareText"] }), Iy.addDynamicAttributes = _y;
      class Ey {
        constructor(t22) {
          this.type = t22.property.overrides ? t22.property.overrides.runtimeType : fr, this.defaultValue = t22;
        }
        evaluate(t22) {
          if (t22.formattedSection) {
            const e22 = this.defaultValue.property.overrides;
            if (e22 && e22.hasOverride(t22.formattedSection)) return e22.getOverride(t22.formattedSection);
          }
          return t22.feature && t22.featureState ? this.defaultValue.evaluate(t22.feature, t22.featureState) : this.defaultValue.property.specification.default;
        }
        eachChild(t22) {
          this.defaultValue.isConstant() || t22(this.defaultValue.value._styleExpression.expression);
        }
        outputDefined() {
          return false;
        }
        serialize() {
          return null;
        }
      }
      js(Ey, "FormatSectionOverride", { omit: ["defaultValue"] });
      const Py = () => ky || (ky = { layout: Sy || (Sy = new ko({ "symbol-placement": new Io(Eo.layout_symbol["symbol-placement"]), "symbol-spacing": new Io(Eo.layout_symbol["symbol-spacing"]), "symbol-avoid-edges": new Io(Eo.layout_symbol["symbol-avoid-edges"]), "symbol-sort-key": new So(Eo.layout_symbol["symbol-sort-key"]), "symbol-z-order": new Io(Eo.layout_symbol["symbol-z-order"]), "symbol-z-elevate": new Io(Eo.layout_symbol["symbol-z-elevate"]), "symbol-elevation-reference": new Io(Eo.layout_symbol["symbol-elevation-reference"]), "icon-allow-overlap": new Io(Eo.layout_symbol["icon-allow-overlap"]), "icon-ignore-placement": new Io(Eo.layout_symbol["icon-ignore-placement"]), "icon-optional": new Io(Eo.layout_symbol["icon-optional"]), "icon-rotation-alignment": new Io(Eo.layout_symbol["icon-rotation-alignment"]), "icon-size": new So(Eo.layout_symbol["icon-size"]), "icon-size-scale-range": new Io(Eo.layout_symbol["icon-size-scale-range"]), "icon-text-fit": new So(Eo.layout_symbol["icon-text-fit"]), "icon-text-fit-padding": new So(Eo.layout_symbol["icon-text-fit-padding"]), "icon-image": new So(Eo.layout_symbol["icon-image"]), "icon-rotate": new So(Eo.layout_symbol["icon-rotate"]), "icon-padding": new Io(Eo.layout_symbol["icon-padding"]), "icon-keep-upright": new Io(Eo.layout_symbol["icon-keep-upright"]), "icon-offset": new So(Eo.layout_symbol["icon-offset"]), "icon-anchor": new So(Eo.layout_symbol["icon-anchor"]), "icon-pitch-alignment": new Io(Eo.layout_symbol["icon-pitch-alignment"]), "text-pitch-alignment": new Io(Eo.layout_symbol["text-pitch-alignment"]), "text-rotation-alignment": new Io(Eo.layout_symbol["text-rotation-alignment"]), "text-field": new So(Eo.layout_symbol["text-field"]), "text-font": new So(Eo.layout_symbol["text-font"]), "text-size": new So(Eo.layout_symbol["text-size"]), "text-size-scale-range": new Io(Eo.layout_symbol["text-size-scale-range"]), "text-max-width": new So(Eo.layout_symbol["text-max-width"]), "text-line-height": new So(Eo.layout_symbol["text-line-height"]), "text-letter-spacing": new So(Eo.layout_symbol["text-letter-spacing"]), "text-justify": new So(Eo.layout_symbol["text-justify"]), "text-radial-offset": new So(Eo.layout_symbol["text-radial-offset"]), "text-variable-anchor": new Io(Eo.layout_symbol["text-variable-anchor"]), "text-anchor": new So(Eo.layout_symbol["text-anchor"]), "text-max-angle": new Io(Eo.layout_symbol["text-max-angle"]), "text-writing-mode": new Io(Eo.layout_symbol["text-writing-mode"]), "text-rotate": new So(Eo.layout_symbol["text-rotate"]), "text-padding": new Io(Eo.layout_symbol["text-padding"]), "text-keep-upright": new Io(Eo.layout_symbol["text-keep-upright"]), "text-transform": new So(Eo.layout_symbol["text-transform"]), "text-offset": new So(Eo.layout_symbol["text-offset"]), "text-allow-overlap": new Io(Eo.layout_symbol["text-allow-overlap"]), "text-ignore-placement": new Io(Eo.layout_symbol["text-ignore-placement"]), "text-optional": new Io(Eo.layout_symbol["text-optional"]), visibility: new Io(Eo.layout_symbol.visibility) })), paint: zy || (zy = new ko({ "icon-opacity": new So(Eo.paint_symbol["icon-opacity"]), "icon-occlusion-opacity": new So(Eo.paint_symbol["icon-occlusion-opacity"]), "icon-emissive-strength": new So(Eo.paint_symbol["icon-emissive-strength"]), "text-emissive-strength": new So(Eo.paint_symbol["text-emissive-strength"]), "icon-color": new So(Eo.paint_symbol["icon-color"]), "icon-halo-color": new So(Eo.paint_symbol["icon-halo-color"]), "icon-halo-width": new So(Eo.paint_symbol["icon-halo-width"]), "icon-halo-blur": new So(Eo.paint_symbol["icon-halo-blur"]), "icon-translate": new Io(Eo.paint_symbol["icon-translate"]), "icon-translate-anchor": new Io(Eo.paint_symbol["icon-translate-anchor"]), "icon-image-cross-fade": new Io(Eo.paint_symbol["icon-image-cross-fade"]), "text-opacity": new So(Eo.paint_symbol["text-opacity"]), "text-occlusion-opacity": new So(Eo.paint_symbol["text-occlusion-opacity"]), "text-color": new So(Eo.paint_symbol["text-color"], { runtimeType: gr, getOverride: (t22) => t22.textColor, hasOverride: (t22) => !!t22.textColor }), "text-halo-color": new So(Eo.paint_symbol["text-halo-color"]), "text-halo-width": new So(Eo.paint_symbol["text-halo-width"]), "text-halo-blur": new So(Eo.paint_symbol["text-halo-blur"]), "text-translate": new Io(Eo.paint_symbol["text-translate"]), "text-translate-anchor": new Io(Eo.paint_symbol["text-translate-anchor"]), "icon-color-saturation": new Io(Eo.paint_symbol["icon-color-saturation"]), "icon-color-contrast": new Io(Eo.paint_symbol["icon-color-contrast"]), "icon-color-brightness-min": new Io(Eo.paint_symbol["icon-color-brightness-min"]), "icon-color-brightness-max": new Io(Eo.paint_symbol["icon-color-brightness-max"]), "symbol-z-offset": new So(Eo.paint_symbol["symbol-z-offset"]), "icon-color-use-theme": new So({ type: "string", default: "default", "property-type": "data-driven" }), "icon-halo-color-use-theme": new So({ type: "string", default: "default", "property-type": "data-driven" }), "text-color-use-theme": new So({ type: "string", default: "default", "property-type": "data-driven" }), "text-halo-color-use-theme": new So({ type: "string", default: "default", "property-type": "data-driven" }) })) }, ky);
      class Ty extends Wo {
        constructor(t22, e22, r22, n22) {
          super(t22, Py(), e22, r22, n22), this._colorAdjustmentMatrix = l2([]), this.hasInitialOcclusionOpacityProperties = void 0 !== t22.paint && ("icon-occlusion-opacity" in t22.paint || "text-occlusion-opacity" in t22.paint);
        }
        recalculate(t22, e22) {
          super.recalculate(t22, e22), "auto" === this.layout.get("icon-rotation-alignment") && (this.layout._values["icon-rotation-alignment"] = "point" !== this.layout.get("symbol-placement") ? "map" : "viewport"), "auto" === this.layout.get("text-rotation-alignment") && (this.layout._values["text-rotation-alignment"] = "point" !== this.layout.get("symbol-placement") ? "map" : "viewport"), "auto" === this.layout.get("text-pitch-alignment") && (this.layout._values["text-pitch-alignment"] = this.layout.get("text-rotation-alignment")), "auto" === this.layout.get("icon-pitch-alignment") && (this.layout._values["icon-pitch-alignment"] = this.layout.get("icon-rotation-alignment"));
          const r22 = this.layout.get("text-writing-mode");
          if (r22) {
            const t3 = [];
            for (const e3 of r22) t3.indexOf(e3) < 0 && t3.push(e3);
            this.layout._values["text-writing-mode"] = t3;
          } else this.layout._values["text-writing-mode"] = "point" === this.layout.get("symbol-placement") ? ["horizontal"] : ["horizontal", "vertical"];
          this._setPaintOverrides();
        }
        getColorAdjustmentMatrix(t22, e22, r22, n22) {
          return this._saturation === t22 && this._contrast === e22 && this._brightnessMin === r22 && this._brightnessMax === n22 || (this._colorAdjustmentMatrix = function(t3, e3, r3, n3) {
            t3 = te2(t3), e3 = Qt2(e3);
            const i22 = a2(), s2 = t3 / 3, o2 = 1 - 2 * s2, l22 = [o2, s2, s2, 0, s2, o2, s2, 0, s2, s2, o2, 0, 0, 0, 0, 1], u22 = 0.5 - 0.5 * e3, h22 = n3 - r3;
            return c2(i22, [h22, 0, 0, 0, 0, h22, 0, 0, 0, 0, h22, 0, r3, r3, r3, 1], [e3, 0, 0, 0, 0, e3, 0, 0, 0, 0, e3, 0, u22, u22, u22, 1]), c2(i22, i22, l22), i22;
          }(t22, e22, r22, n22), this._saturation = t22, this._contrast = e22, this._brightnessMin = r22, this._brightnessMax = n22), this._colorAdjustmentMatrix;
        }
        getValueAndResolveTokens(t22, e22, r22, n22) {
          const i22 = this.layout.get(t22).evaluate(e22, {}, r22, n22), s2 = this._unevaluatedLayout._values[t22];
          return s2.isDataDriven() || Ps(s2.value) || !i22 ? i22 : function(t3, e3) {
            return e3.replace(/{([^{}]+)}/g, (e4, r3) => r3 in t3 ? String(t3[r3]) : "");
          }(e22.properties, i22);
        }
        createBucket(t22) {
          return new Iy(t22);
        }
        queryRadius() {
          return 0;
        }
        queryIntersectsFeature() {
          return false;
        }
        _setPaintOverrides() {
          for (const t22 of Py().paint.overridableProperties) {
            if (!Ty.hasPaintOverride(this.layout, t22)) continue;
            const e22 = this.paint.get(t22), r22 = new Ey(e22), n22 = new Es(r22, e22.property.specification, this.scope, this.options);
            let i22 = null;
            i22 = "constant" === e22.value.kind || "source" === e22.value.kind ? new Bs("source", n22) : new Vs("composite", n22, e22.value.zoomStops, e22.value.interpolationType), this.paint._values[t22] = new Ao(e22.property, i22, e22.parameters);
          }
        }
        _handleOverridablePaintPropertyUpdate(t22, e22, r22) {
          return !(!this.layout || e22.isDataDriven() || r22.isDataDriven()) && Ty.hasPaintOverride(this.layout, t22);
        }
        static hasPaintOverride(t22, e22) {
          const r22 = t22.get("text-field"), n22 = Py().paint.properties[e22];
          let i22 = false;
          const s2 = (t3) => {
            for (const e3 of t3) if (n22.overrides && n22.overrides.hasOverride(e3)) return void (i22 = true);
          };
          if ("constant" === r22.value.kind && r22.value.value instanceof Tr) s2(r22.value.value.sections);
          else if ("source" === r22.value.kind) {
            const t3 = (e4) => {
              i22 || (e4 instanceof Rr && Fr(e4.value) === _r ? s2(e4.value.sections) : e4 instanceof jr ? s2(e4.sections) : e4.eachChild(t3));
            }, e3 = r22.value;
            e3._styleExpression && t3(e3._styleExpression.expression);
          }
          return i22;
        }
        getProgramIds() {
          return ["symbol"];
        }
        getDefaultProgramParams(t22, e22, r22) {
          return { config: new Ml(this, { zoom: e22, lut: r22 }), overrideFog: false };
        }
        hasElevation() {
          return this.layout && "hd-road-markup" === this.layout.get("symbol-elevation-reference");
        }
      }
      let By, Vy, Cy, Dy;
      var Fy = Qo([{ name: "a_pos", type: "Int16", components: 2 }, { name: "a_texture_pos", type: "Int16", components: 2 }]);
      function Ly(t22) {
        switch (t22) {
          case WebGL2RenderingContext.RGBA8:
            return WebGL2RenderingContext.RGBA;
          case WebGL2RenderingContext.DEPTH_COMPONENT16:
            return WebGL2RenderingContext.DEPTH_COMPONENT;
          case WebGL2RenderingContext.DEPTH24_STENCIL8:
            return WebGL2RenderingContext.DEPTH_STENCIL;
          case WebGL2RenderingContext.R8:
          case WebGL2RenderingContext.R32F:
            return WebGL2RenderingContext.RED;
        }
      }
      function Ry(t22) {
        switch (t22) {
          case WebGL2RenderingContext.RGBA8:
            return WebGL2RenderingContext.UNSIGNED_BYTE;
          case WebGL2RenderingContext.DEPTH_COMPONENT16:
            return WebGL2RenderingContext.UNSIGNED_SHORT;
          case WebGL2RenderingContext.DEPTH24_STENCIL8:
            return WebGL2RenderingContext.UNSIGNED_INT_24_8;
          case WebGL2RenderingContext.R8:
            return WebGL2RenderingContext.UNSIGNED_BYTE;
          case WebGL2RenderingContext.R32F:
            return WebGL2RenderingContext.FLOAT;
        }
      }
      class Oy {
        constructor(t22, e22, r22, n22) {
          this.context = t22, this.format = r22, this.useMipmap = n22 && n22.useMipmap, this.texture = t22.gl.createTexture(), this.update(e22, { premultiply: n22 && n22.premultiply });
        }
        update(t22, e22) {
          const r22 = t22 && t22 instanceof HTMLVideoElement && 0 === t22.width ? t22.videoWidth : t22.width, n22 = t22 && t22 instanceof HTMLVideoElement && 0 === t22.height ? t22.videoHeight : t22.height, { context: i22 } = this, { gl: s2 } = i22, { x: o2, y: a22 } = e22 && e22.position ? e22.position : { x: 0, y: 0 }, l22 = o2 + r22, u22 = a22 + n22;
          !this.size || this.size[0] === l22 && this.size[1] === u22 || (s2.bindTexture(s2.TEXTURE_2D, null), s2.deleteTexture(this.texture), this.texture = s2.createTexture(), this.size = null), s2.bindTexture(s2.TEXTURE_2D, this.texture), i22.pixelStoreUnpackFlipY.set(false), i22.pixelStoreUnpack.set(1), i22.pixelStoreUnpackPremultiplyAlpha.set(this.format === s2.RGBA8 && (!e22 || false !== e22.premultiply));
          const c22 = t22 instanceof HTMLImageElement || t22 instanceof HTMLCanvasElement || t22 instanceof HTMLVideoElement || t22 instanceof ImageData || ImageBitmap && t22 instanceof ImageBitmap;
          if (!this.size && l22 > 0 && u22 > 0) {
            const t3 = this.useMipmap ? Math.floor(Math.log2(Math.max(l22, u22))) + 1 : 1;
            s2.texStorage2D(s2.TEXTURE_2D, t3, this.format, l22, u22), this.size = [l22, u22];
          }
          if (this.size) if (c22) s2.texSubImage2D(s2.TEXTURE_2D, 0, o2, a22, Ly(this.format), Ry(this.format), t22);
          else {
            const e3 = t22.data;
            e3 && s2.texSubImage2D(s2.TEXTURE_2D, 0, o2, a22, r22, n22, Ly(this.format), Ry(this.format), e3);
          }
          this.useMipmap && s2.generateMipmap(s2.TEXTURE_2D);
        }
        bind(t22, e22, r22 = false) {
          const { context: n22 } = this, { gl: i22 } = n22;
          i22.bindTexture(i22.TEXTURE_2D, this.texture), t22 !== this.minFilter && (i22.texParameteri(i22.TEXTURE_2D, i22.TEXTURE_MAG_FILTER, t22), i22.texParameteri(i22.TEXTURE_2D, i22.TEXTURE_MIN_FILTER, this.useMipmap && !r22 ? t22 === i22.NEAREST ? i22.NEAREST_MIPMAP_NEAREST : i22.LINEAR_MIPMAP_LINEAR : t22), this.minFilter = t22), e22 !== this.wrapS && (i22.texParameteri(i22.TEXTURE_2D, i22.TEXTURE_WRAP_S, e22), i22.texParameteri(i22.TEXTURE_2D, i22.TEXTURE_WRAP_T, e22), this.wrapS = e22);
        }
        bindExtraParam(t22, e22, r22, n22) {
          const { context: i22 } = this, { gl: s2 } = i22;
          s2.bindTexture(s2.TEXTURE_2D, this.texture), e22 !== this.magFilter && (s2.texParameteri(s2.TEXTURE_2D, s2.TEXTURE_MAG_FILTER, e22), this.magFilter = e22), t22 !== this.minFilter && (s2.texParameteri(s2.TEXTURE_2D, s2.TEXTURE_MIN_FILTER, this.useMipmap ? t22 === s2.NEAREST ? s2.NEAREST_MIPMAP_NEAREST : s2.LINEAR_MIPMAP_LINEAR : t22), this.minFilter = t22), r22 !== this.wrapS && (s2.texParameteri(s2.TEXTURE_2D, s2.TEXTURE_WRAP_S, r22), this.wrapS = r22), n22 !== this.wrapT && (s2.texParameteri(s2.TEXTURE_2D, s2.TEXTURE_WRAP_T, n22), this.wrapT = n22);
        }
        destroy() {
          const { gl: t22 } = this.context;
          t22.deleteTexture(this.texture), this.texture = null;
        }
      }
      class Uy {
        constructor(t22, e22) {
          this.context = t22, this.texture = e22;
        }
        bind(t22, e22) {
          const { context: r22 } = this, { gl: n22 } = r22;
          n22.bindTexture(n22.TEXTURE_2D, this.texture), t22 !== this.minFilter && (n22.texParameteri(n22.TEXTURE_2D, n22.TEXTURE_MAG_FILTER, t22), n22.texParameteri(n22.TEXTURE_2D, n22.TEXTURE_MIN_FILTER, t22), this.minFilter = t22), e22 !== this.wrapS && (n22.texParameteri(n22.TEXTURE_2D, n22.TEXTURE_WRAP_S, e22), n22.texParameteri(n22.TEXTURE_2D, n22.TEXTURE_WRAP_T, e22), this.wrapS = e22);
        }
      }
      function Ny(t22, e22, r22, n22, i22, a22, l22, u22) {
        const c22 = [t22, e22, 1, r22, n22, 1, i22, a22, 1], h22 = [l22, u22, 1], p22 = s([], c22), [f22, d22, m22] = O(h22, h22, p22);
        return o(c22, c22, [f22, 0, 0, 0, d22, 0, 0, 0, m22]);
      }
      function jy(t22, e22, r22, n22, i22, a22, l22, u22) {
        const c22 = function(t3, e3, r3, n3, i3, a3, l3, u3) {
          const c3 = Ny(0, 0, 1, 0, 1, 1, 0, 1), h22 = Ny(t3, e3, r3, n3, i3, a3, l3, u3);
          return o(h22, h22, s([], c3));
        }(t22, e22, r22, n22, i22, a22, l22, u22);
        return [c22[2] / c22[8] / Tn, c22[5] / c22[8] / Tn];
      }
      function $y(t22) {
        return [t22[0], Math.min(Math.max(t22[1], -tu), tu)];
      }
      class Gy extends Qe {
        constructor(t22, e22, r22, n22) {
          super(), this.id = t22, this.dispatcher = r22, this.coordinates = e22.coordinates, this.type = "image", this.minzoom = 0, this.maxzoom = 22, this.tileSize = 512, this.tiles = {}, this._loaded = false, this.onNorthPole = false, this.onSouthPole = false, this.setEventedParent(n22), this.options = e22, this._dirty = false;
        }
        load(t22, e22) {
          if (this._loaded = e22 || false, this.fire(new We("dataloading", { dataType: "source" })), this.url = this.options.url, !this.url) return t22 && (this.coordinates = t22), this._loaded = true, void this._finishLoading();
          this._imageRequest = Ue(this.map._requestManager.transformRequest(this.url, Te2.Image), (e3, r22) => {
            this._imageRequest = null, this._loaded = true, e3 ? this.fire(new Ye(e3)) : r22 && (this.image = r22 instanceof HTMLImageElement ? pe.getImageData(r22) : r22, this._dirty = true, this.width = this.image.width, this.height = this.image.height, t22 && (this.coordinates = t22), this._finishLoading());
          });
        }
        loaded() {
          return this._loaded;
        }
        updateImage(t22) {
          return t22.url ? (this._imageRequest && t22.url !== this.options.url && (this._imageRequest.cancel(), this._imageRequest = null), this.options.url = t22.url, this.load(t22.coordinates, this._loaded), this) : this;
        }
        setTexture(t22) {
          if (!(t22.handle instanceof WebGLTexture)) throw new Error("The provided handle is not a WebGLTexture instance");
          return this.texture = new Uy(this.map.painter.context, t22.handle), this.width = t22.dimensions[0], this.height = t22.dimensions[1], this._dirty = false, this._loaded = true, this._finishLoading(), this;
        }
        _finishLoading() {
          this.map && (this.setCoordinates(this.coordinates), this.fire(new We("data", { dataType: "source", sourceDataType: "metadata" })));
        }
        onAdd(t22) {
          this.map = t22, this.load();
        }
        onRemove(t22) {
          this._imageRequest && (this._imageRequest.cancel(), this._imageRequest = null), !this.texture || this.texture instanceof Uy || this.texture.destroy(), this.boundsBuffer && (this.boundsBuffer.destroy(), this.elevatedGlobeVertexBuffer && this.elevatedGlobeVertexBuffer.destroy(), this.elevatedGlobeIndexBuffer && this.elevatedGlobeIndexBuffer.destroy());
        }
        setCoordinates(t22) {
          if (this.coordinates = t22, this._boundsArray = void 0, this._unsupportedCoords = false, !t22.length) return this;
          this.onNorthPole = false, this.onSouthPole = false;
          let e22 = t22[0][1], r22 = t22[0][1];
          for (const n3 of t22) n3[1] > r22 && (r22 = n3[1]), n3[1] < e22 && (e22 = n3[1]);
          const n22 = (r22 + e22) / 2;
          if (n22 > tu ? this.onNorthPole = true : n22 < -tu && (this.onSouthPole = true), !this.onNorthPole && !this.onSouthPole) {
            const e3 = t22.map(su.fromLngLat);
            this.tileID = function(t3) {
              let e4 = 1 / 0, r3 = 1 / 0, n3 = -1 / 0, i22 = -1 / 0;
              for (const s3 of t3) e4 = Math.min(e4, s3.x), r3 = Math.min(r3, s3.y), n3 = Math.max(n3, s3.x), i22 = Math.max(i22, s3.y);
              const s2 = Math.max(n3 - e4, i22 - r3), o2 = Math.max(0, Math.floor(-Math.log(s2) / Math.LN2)), a22 = Math.pow(2, o2);
              let l22 = Math.floor((e4 + n3) / 2 * a22);
              return l22 > 1 && (l22 -= 1), new Nu(o2, l22, Math.floor((r3 + i22) / 2 * a22));
            }(e3), this.minzoom = this.maxzoom = this.tileID.z;
          }
          return this.fire(new We("data", { dataType: "source", sourceDataType: "content" })), this;
        }
        _clear() {
          this._boundsArray = void 0, this._unsupportedCoords = false;
        }
        _prepareData(t22) {
          for (const t3 in this.tiles) {
            const e3 = this.tiles[t3];
            "loaded" !== e3.state && (e3.state = "loaded", e3.texture = this.texture);
          }
          if (this._boundsArray || this.onNorthPole || this.onSouthPole || this._unsupportedCoords) return;
          const e22 = Xm(new Nu(0, 0, 0), this.map.transform.projection), r22 = [e22.projection.project(this.coordinates[0][0], this.coordinates[0][1]), e22.projection.project(this.coordinates[1][0], this.coordinates[1][1]), e22.projection.project(this.coordinates[2][0], this.coordinates[2][1]), e22.projection.project(this.coordinates[3][0], this.coordinates[3][1])];
          if (!function(t3) {
            const e3 = t3[1].x - t3[0].x, r3 = t3[1].y - t3[0].y, n3 = t3[2].x - t3[1].x, i3 = t3[2].y - t3[1].y, s2 = t3[3].x - t3[2].x, o2 = t3[3].y - t3[2].y, a3 = t3[0].x - t3[3].x, l3 = t3[0].y - t3[3].y, u3 = e3 * i3 - n3 * r3, c3 = n3 * o2 - s2 * i3, h3 = s2 * l3 - a3 * o2, p3 = a3 * r3 - e3 * l3;
            return u3 > 0 && c3 > 0 && h3 > 0 && p3 > 0 || u3 < 0 && c3 < 0 && h3 < 0 && p3 < 0;
          }(r22)) return console.warn("Image source coordinates are defining non-convex area in the Mercator projection"), void (this._unsupportedCoords = true);
          const n22 = Xm(this.tileID, this.map.transform.projection), [i22, a22, l22, u22] = this.coordinates.map((t3) => {
            const e3 = n22.projection.project(t3[0], t3[1]);
            return Zm(n22, e3)._round();
          });
          this.perspectiveTransform = jy(i22.x, i22.y, a22.x, a22.y, l22.x, l22.y, u22.x, u22.y);
          const c22 = this._boundsArray = new na();
          c22.emplaceBack(i22.x, i22.y, 0, 0), c22.emplaceBack(a22.x, a22.y, Tn, 0), c22.emplaceBack(u22.x, u22.y, 0, Tn), c22.emplaceBack(l22.x, l22.y, Tn, Tn), this.boundsBuffer && (this.boundsBuffer.destroy(), this.elevatedGlobeVertexBuffer && this.elevatedGlobeVertexBuffer.destroy(), this.elevatedGlobeIndexBuffer && this.elevatedGlobeIndexBuffer.destroy()), this.boundsBuffer = t22.createVertexBuffer(c22, Fy.members), this.boundsSegments = Ka.simpleSegment(0, 0, 4, 2);
          const h22 = [], p22 = [$y((f22 = this.coordinates)[0]), $y(f22[1]), $y(f22[2]), $y(f22[3])];
          var f22;
          const [d22, m22, y22, g22] = function(t3) {
            let e3 = t3[0][0], r3 = e3, n3 = t3[0][1], i3 = n3;
            for (let s2 = 1; s2 < t3.length; s2++) t3[s2][0] < e3 ? e3 = t3[s2][0] : t3[s2][0] > r3 && (r3 = t3[s2][0]), t3[s2][1] < n3 ? n3 = t3[s2][1] : t3[s2][1] > i3 && (i3 = t3[s2][1]);
            return [e3, n3, r3 - e3, i3 - n3];
          }(p22);
          {
            const n3 = new na(), [i3, a3, l3, u3] = function(t3) {
              let e3 = t3[0].x, r3 = e3, n4 = t3[0].y, i4 = n4;
              for (let s2 = 1; s2 < t3.length; s2++) t3[s2].x < e3 ? e3 = t3[s2].x : t3[s2].x > r3 && (r3 = t3[s2].x), t3[s2].y < n4 ? n4 = t3[s2].y : t3[s2].y > i4 && (i4 = t3[s2].y);
              return [e3, n4, r3 - e3, i4 - n4];
            }(r22), c3 = (t3) => [(t3.x - i3) / l3, (t3.y - a3) / u3], [p3, f3, x22, v22] = r22.map(c3), b22 = function(t3, e3, r3, n4, i4, a4, l4, u4) {
              const c4 = Ny(0, 0, 1, 0, 1, 1, 0, 1);
              return o(c4, c4, s([], Ny(t3, e3, r3, n4, i4, a4, l4, u4)));
            }(p3[0], p3[1], f3[0], f3[1], x22[0], x22[1], v22[0], v22[1]);
            this.elevatedGlobePerspectiveTransform = jy(p3[0], p3[1], f3[0], f3[1], x22[0], x22[1], v22[0], v22[1]);
            const _22 = (t3, e3) => {
              h22.push(t3.lng);
              const r3 = Math.round((t3.lng - d22) / y22 * Tn), i4 = Math.round((t3.lat - m22) / g22 * Tn), s2 = c3(e3), o2 = O([], [s2[0], s2[1], 1], b22), a4 = Math.round(o2[0] / o2[2] * Tn), l4 = Math.round(o2[1] / o2[2] * Tn);
              n3.emplaceBack(r3, i4, a4, l4);
            }, w22 = r22[3].x - r22[0].x, A22 = r22[3].y - r22[0].y, M22 = r22[2].x - r22[1].x, I2 = r22[2].y - r22[1].y;
            for (let t3 = 0; t3 < 65; t3++) {
              const n4 = t3 / 64, i4 = [r22[0].x + n4 * w22, r22[0].y + n4 * A22], s2 = [r22[1].x + n4 * M22, r22[1].y + n4 * I2], o2 = s2[0] - i4[0], a4 = s2[1] - i4[1];
              for (let t4 = 0; t4 < 65; t4++) {
                const r3 = t4 / 64, n5 = { x: i4[0] + o2 * r3, y: i4[1] + a4 * r3, z: 0 };
                _22(e22.projection.unproject(n5.x, n5.y), n5);
              }
            }
            this.elevatedGlobeVertexBuffer = t22.createVertexBuffer(n3, Fy.members);
          }
          {
            this.maxLongitudeTriangleSize = 0;
            let e3 = [], r3 = new wa();
            const n3 = (t3, n4, i3) => {
              r3.emplaceBack(t3, n4, i3);
              const s2 = h22[t3], o2 = h22[n4], a3 = h22[i3], l3 = Math.min(Math.min(s2, o2), a3), u3 = Math.max(Math.max(s2, o2), a3) - l3;
              u3 > this.maxLongitudeTriangleSize && (this.maxLongitudeTriangleSize = u3), e3.push(l3 + u3 / 2);
            };
            for (let t3 = 0; t3 < 64; t3++) for (let e4 = 0; e4 < 64; e4++) {
              const r4 = 65 * t3 + e4, i3 = r4 + 1, s2 = r4 + 65, o2 = s2 + 1;
              n3(r4, s2, i3), n3(i3, s2, o2);
            }
            [e3, r3] = function(t3, e4) {
              const r4 = Array.from({ length: t3.length }, (t4, e5) => e5);
              r4.sort((e5, r5) => t3[e5] - t3[r5]);
              const n4 = [], i3 = new wa();
              for (let s2 = 0; s2 < r4.length; s2++) {
                const o2 = r4[s2];
                n4.push(t3[o2]);
                const a3 = 3 * o2, l3 = a3 + 1;
                i3.emplaceBack(e4.uint16[a3], e4.uint16[l3], e4.uint16[l3 + 1]);
              }
              return [n4, i3];
            }(e3, r3), this.elevatedGlobeTrianglesCenterLongitudes = e3, this.elevatedGlobeIndexBuffer = t22.createIndexBuffer(r3);
          }
          this.elevatedGlobeSegments = Ka.simpleSegment(0, 0, 4225, 8192), this.elevatedGlobeGridMatrix = new Float32Array([0, y22 / Tn, 0, g22 / Tn, 0, 0, m22, d22, 0]);
        }
        prepare() {
          const t22 = 0 !== Object.keys(this.tiles).length;
          if (this.tileID && !t22) return;
          const e22 = this.map.painter.context, r22 = e22.gl;
          !this._dirty || this.texture instanceof Uy || (this.texture ? this.texture.update(this.image) : (this.texture = new Oy(e22, this.image, r22.RGBA8), this.texture.bind(r22.LINEAR, r22.CLAMP_TO_EDGE)), this._dirty = false), t22 && this._prepareData(e22);
        }
        loadTile(t22, e22) {
          this.tileID && this.tileID.equals(t22.tileID.canonical) ? (this.tiles[String(t22.tileID.wrap)] = t22, t22.buckets = {}, e22(null)) : (t22.state = "errored", e22(null));
        }
        serialize() {
          return { type: "image", url: this.options.url, coordinates: this.coordinates };
        }
        hasTransition() {
          return false;
        }
        getSegmentsForLongitude(t22) {
          const e22 = this.elevatedGlobeSegments;
          if (!this.elevatedGlobeTrianglesCenterLongitudes || !e22) return null;
          const r22 = this.elevatedGlobeTrianglesCenterLongitudes;
          let n22 = (i22 = t22 + 180) + 360 * Math.round((r22[0] - i22) / 360);
          var i22;
          const s2 = new Ka(), o2 = (t3, r3) => {
            s2.segments.push({ vertexOffset: 0, primitiveOffset: t3, vertexLength: e22.segments[0].vertexLength, primitiveLength: r3, sortKey: void 0, vaos: {} });
          }, a22 = 0.51 * this.maxLongitudeTriangleSize;
          if (Math.abs(r22[0] - n22) <= a22) {
            const t3 = Jt2(r22, 0, r22.length, n22 + a22);
            return t3 === r22.length || o2(t3, Kt2(r22, t3 + 1, r22.length, n22 + 360 - a22) - t3), s2;
          }
          n22 < r22[0] && (n22 += 360);
          const l22 = Kt2(r22, 0, r22.length, n22 - a22);
          if (l22 === r22.length) return o2(0, r22.length), s2;
          o2(0, l22 - 0);
          const u22 = Jt2(r22, l22 + 1, r22.length, n22 + a22);
          return u22 !== r22.length && o2(u22, r22.length - u22), s2;
        }
      }
      const qy = (Math.pow(256, 2) - 1) / 16907520;
      class Hy extends Wo {
        constructor(t22, e22, r22, n22) {
          super(t22, { layout: Cy || (Cy = new ko({ visibility: new Io(Eo.layout_raster.visibility) })), paint: Dy || (Dy = new ko({ "raster-opacity": new Io(Eo.paint_raster["raster-opacity"]), "raster-color": new zo(Eo.paint_raster["raster-color"]), "raster-color-mix": new Io(Eo.paint_raster["raster-color-mix"]), "raster-color-range": new Io(Eo.paint_raster["raster-color-range"]), "raster-hue-rotate": new Io(Eo.paint_raster["raster-hue-rotate"]), "raster-brightness-min": new Io(Eo.paint_raster["raster-brightness-min"]), "raster-brightness-max": new Io(Eo.paint_raster["raster-brightness-max"]), "raster-saturation": new Io(Eo.paint_raster["raster-saturation"]), "raster-contrast": new Io(Eo.paint_raster["raster-contrast"]), "raster-resampling": new Io(Eo.paint_raster["raster-resampling"]), "raster-fade-duration": new Io(Eo.paint_raster["raster-fade-duration"]), "raster-emissive-strength": new Io(Eo.paint_raster["raster-emissive-strength"]), "raster-array-band": new Io(Eo.paint_raster["raster-array-band"]), "raster-elevation": new Io(Eo.paint_raster["raster-elevation"]), "raster-color-use-theme": new So({ type: "string", default: "default", "property-type": "data-driven" }) })) }, e22, r22, n22), this.updateColorRamp(), this._curRampRange = [NaN, NaN];
        }
        getProgramIds() {
          return ["raster"];
        }
        hasColorMap() {
          return !!this._transitionablePaint._values["raster-color"].value.value;
        }
        tileCoverLift() {
          return this.paint.get("raster-elevation");
        }
        isDraped(t22) {
          return !(t22 && t22._source instanceof Gy && (t22._source.onNorthPole || t22._source.onSouthPole)) && 0 === this.paint.get("raster-elevation");
        }
        _handleSpecialPaintPropertyUpdate(t22) {
          "raster-color" !== t22 && "raster-color-range" !== t22 || (this._curRampRange = [NaN, NaN], this.updateColorRamp());
        }
        updateColorRamp(t22) {
          if (!this.hasColorMap()) return;
          if (!this._curRampRange) return;
          const e22 = this._transitionablePaint._values["raster-color"].value.expression, [r22, n22] = t22 || this._transitionablePaint._values["raster-color-range"].value.expression.evaluate({ zoom: 0 }) || [NaN, NaN];
          isNaN(r22) && isNaN(n22) || r22 === this._curRampRange[0] && n22 === this._curRampRange[1] || (this.colorRamp = Zc({ expression: e22, evaluationKey: "rasterValue", image: this.colorRamp, clips: [{ start: r22, end: n22 }], resolution: 256 }), this.colorRampTexture = null, this._curRampRange = [r22, n22]);
        }
      }
      let Xy, Zy, Wy, Yy, Ky;
      class Jy extends Wo {
        constructor(t22, e22, r22, n22) {
          super(t22, { layout: Xy || (Xy = new ko({ visibility: new Io(Eo["layout_raster-particle"].visibility) })), paint: Zy || (Zy = new ko({ "raster-particle-array-band": new Io(Eo["paint_raster-particle"]["raster-particle-array-band"]), "raster-particle-count": new Io(Eo["paint_raster-particle"]["raster-particle-count"]), "raster-particle-color": new zo(Eo["paint_raster-particle"]["raster-particle-color"]), "raster-particle-max-speed": new Io(Eo["paint_raster-particle"]["raster-particle-max-speed"]), "raster-particle-speed-factor": new Io(Eo["paint_raster-particle"]["raster-particle-speed-factor"]), "raster-particle-fade-opacity-factor": new Io(Eo["paint_raster-particle"]["raster-particle-fade-opacity-factor"]), "raster-particle-reset-rate-factor": new Io(Eo["paint_raster-particle"]["raster-particle-reset-rate-factor"]), "raster-particle-elevation": new Io(Eo["paint_raster-particle"]["raster-particle-elevation"]), "raster-particle-color-use-theme": new So({ type: "string", default: "default", "property-type": "data-driven" }) })) }, e22, r22, n22), this._updateColorRamp(), this.lastInvalidatedAt = pe.now();
        }
        onRemove(t22) {
          this.colorRampTexture && this.colorRampTexture.destroy(), this.tileFramebuffer && this.tileFramebuffer.destroy(), this.particleFramebuffer && this.particleFramebuffer.destroy();
        }
        hasColorMap() {
          return !!this._transitionablePaint._values["raster-particle-color"].value.value;
        }
        getProgramIds() {
          return ["rasterParticle"];
        }
        hasOffscreenPass() {
          return "none" !== this.visibility;
        }
        isDraped(t22) {
          return false;
        }
        _handleSpecialPaintPropertyUpdate(t22) {
          "raster-particle-color" !== t22 && "raster-particle-max-speed" !== t22 || (this._updateColorRamp(), this._invalidateAnimationState()), "raster-particle-count" === t22 && this._invalidateAnimationState();
        }
        _updateColorRamp() {
          if (!this.hasColorMap()) return;
          const t22 = this._transitionablePaint._values["raster-particle-color"].value.expression, e22 = this._transitionablePaint._values["raster-particle-max-speed"].value.expression.evaluate({ zoom: 0 });
          this.colorRamp = Zc({ expression: t22, evaluationKey: "rasterParticleSpeed", image: this.colorRamp, clips: [{ start: 0, end: e22 }], resolution: 256 }), this.colorRampTexture = null;
        }
        _invalidateAnimationState() {
          this.lastInvalidatedAt = pe.now();
        }
        tileCoverLift() {
          return this.paint.get("raster-particle-elevation");
        }
      }
      class Qy extends Wo {
        constructor(t22, e22) {
          super(t22, {}, e22, null), this.implementation = t22, t22.slot && (this.slot = t22.slot);
        }
        is3D(t22) {
          return "3d" === this.implementation.renderingMode;
        }
        hasOffscreenPass() {
          return void 0 !== this.implementation.prerender;
        }
        isDraped(t22) {
          return void 0 !== this.implementation.renderToTile;
        }
        shouldRedrape() {
          return !!this.implementation.shouldRerenderTiles && this.implementation.shouldRerenderTiles();
        }
        recalculate() {
        }
        updateTransitions() {
        }
        hasTransition() {
          return false;
        }
        serialize() {
        }
        onAdd(t22) {
          this.implementation.onAdd && this.implementation.onAdd(t22, t22.painter.context.gl);
        }
        onRemove(t22) {
          this.implementation.onRemove && this.implementation.onRemove(t22, t22.painter.context.gl);
        }
      }
      function tg(t22, e22, r22) {
        const n22 = [0, 0, 1], i22 = Y([]);
        return J(i22, i22, r22 ? -Mt(t22) + Math.PI : Mt(t22)), K2(i22, i22, -Mt(e22)), U2(n22, n22, i22), C(n22, n22);
      }
      function eg(t22, e22) {
        const r22 = ng(t22.projection, t22.zoom, t22.width, t22.height), n22 = function(t3, e3, r3, n3, i3) {
          const s2 = new $l(r3.lng - 180 * ig, r3.lat), o2 = new $l(r3.lng + 180 * ig, r3.lat), a22 = t3.project(s2.lng, s2.lat), u22 = t3.project(o2.lng, o2.lat), h22 = -Math.atan2(u22.y - a22.y, u22.x - a22.x), f22 = su.fromLngLat(r3);
          f22.y = Pt(f22.y, -1 + ig, 1 - ig);
          const d22 = f22.toLngLat(), y22 = t3.project(d22.lng, d22.lat), g22 = su.fromLngLat(d22);
          g22.x += ig;
          const x22 = g22.toLngLat(), v22 = t3.project(x22.lng, x22.lat), b22 = og(v22.x - y22.x, v22.y - y22.y, h22), _22 = su.fromLngLat(d22);
          _22.y += ig;
          const w22 = _22.toLngLat(), A22 = t3.project(w22.lng, w22.lat), M22 = og(A22.x - y22.x, A22.y - y22.y, h22), I2 = Math.abs(b22.x) / Math.abs(M22.y), S2 = l2([]);
          m2(S2, S2, -h22 * (1 - (i3 ? 0 : n3)));
          const z22 = l2([]);
          return p2(z22, z22, [1, 1 - (1 - I2) * n3, 1]), z22[4] = -M22.x / M22.y * n3, m2(z22, z22, h22), c2(z22, S2, z22), z22;
        }(t22.projection, 0, t22.center, r22, e22), i22 = rg(t22);
        return p2(n22, n22, [i22, i22, 1]), n22;
      }
      function rg(t22) {
        const e22 = t22.projection, r22 = ng(t22.projection, t22.zoom, t22.width, t22.height), n22 = sg(e22, t22.center), i22 = sg(e22, $l.convert(e22.center));
        return Math.pow(2, n22 * r22 + (1 - r22) * i22);
      }
      function ng(t22, e22, r22, n22, i22 = 1 / 0) {
        const s2 = t22.range;
        if (!s2) return 0;
        const o2 = Math.min(i22, Math.max(r22, n22)), a22 = Math.log(o2 / 1024) / Math.LN2;
        return Tt(s2[0] + a22, s2[1] + a22, e22);
      }
      const ig = 1 / 4e4;
      function sg(t22, e22) {
        const r22 = Pt(e22.lat, -tu, tu), n22 = new $l(e22.lng - 180 * ig, r22), i22 = new $l(e22.lng + 180 * ig, r22), s2 = t22.project(n22.lng, r22), o2 = t22.project(i22.lng, r22), a22 = su.fromLngLat(n22), l22 = su.fromLngLat(i22), u22 = o2.x - s2.x, c22 = o2.y - s2.y, h22 = l22.x - a22.x, p22 = l22.y - a22.y, f22 = Math.sqrt((h22 * h22 + p22 * p22) / (u22 * u22 + c22 * c22));
        return Math.log(f22) / Math.LN2;
      }
      function og(t22, e22, r22) {
        const n22 = Math.cos(r22), i22 = Math.sin(r22);
        return { x: t22 * n22 - e22 * i22, y: t22 * i22 + e22 * n22 };
      }
      function ag(t22, e22, r22) {
        l2(t22), m2(t22, t22, Mt(e22[2])), f2(t22, t22, Mt(e22[0])), d2(t22, t22, Mt(e22[1])), p2(t22, t22, r22), c2(t22, t22, [1, 0, 0, 0, 0, 0, 1, 0, 0, 1, 0, 0, 0, 0, 0, 1]);
      }
      function lg(t22, e22, r22, n22, i22, s2, o2, a22) {
        const l22 = [r22[0] - e22[0], r22[1] - e22[1], 0], u22 = [n22[0] - e22[0], n22[1] - e22[1], 0];
        if (w2(l22) < 1e-12 || w2(u22) < 1e-12) return Y(t22);
        const c22 = F([], l22, u22);
        C(c22, c22), I(u22, n22, e22), l22[2] = (s2 - i22) * a22, u22[2] = (o2 - i22) * a22;
        const h22 = l22;
        return F(h22, l22, u22), C(h22, h22), st(t22, c22, h22);
      }
      function ug(t22, e22, r22 = false) {
        const n22 = Mc(e22.zoom), i22 = function(t3, e3, r3) {
          const n3 = e3.worldSize, i3 = [t3[12], t3[13], t3[14]], s2 = Jl(i3[1] / n3), o2 = Kl(i3[0] / n3), a22 = l2([]), u22 = Yl(1, s2) * n3, f22 = Yl(1, 0) * n3 * ru2(s2, e3.zoom), d22 = 1 / _c2(n3);
          let m22 = f22 * d22;
          if (r3) {
            const t4 = ng(e3.projection, e3.zoom, e3.width, e3.height, 1024);
            m22 = d22 * e3.projection.pixelSpaceConversion(e3.center.lat, n3, t4);
          }
          const y22 = Ul(s2, o2);
          M2(y22, y22, E2([], C([], y22), u22 * m22 * i3[2]));
          const g22 = function(t4) {
            const e4 = [t4[0], t4[1], t4[2]];
            let r4 = [0, 1, 0];
            const n4 = F([], r4, e4);
            return F(r4, e4, n4), 0 === B2(r4) && (r4 = [0, 1, 0], F(n4, e4, r4)), C(n4, n4), C(r4, r4), C(e4, e4), [n4[0], n4[1], n4[2], 0, r4[0], r4[1], r4[2], 0, e4[0], e4[1], e4[2], 0, t4[0], t4[1], t4[2], 1];
          }(y22);
          p2(a22, a22, [m22, m22, m22 * u22]), h2(a22, a22, [-i3[0], -i3[1], -i3[2]]);
          const x22 = c2([], e3.globeMatrix, g22);
          return c2(x22, x22, a22), c2(x22, x22, t3), x22;
        }(t22, e22, r22);
        if (n22 > 0) {
          const r3 = function(t3, e3) {
            const r4 = e3.worldSize, n3 = Yl(1, 0) * r4 * ru2(e3.center.lat, e3.zoom) / _c2(r4), i3 = Yl(1, e3.center.lat) * r4, s2 = l2([]);
            return d2(s2, s2, Mt(e3.center.lng)), f2(s2, s2, Mt(e3.center.lat)), h2(s2, s2, [0, 0, Tl]), p2(s2, s2, [n3, n3, n3 * i3]), h2(s2, s2, [e3.point.x - 0.5 * r4, e3.point.y - 0.5 * r4, 0]), c2(s2, s2, t3), c2(s2, e3.globeMatrix, s2);
          }(t22, e22);
          return function(t3, e3, r4) {
            const n3 = (t4, e4, r5) => {
              const n4 = w2(t4), i4 = w2(e4), s3 = hc(t4, e4, r5);
              return E2(s3, s3, 1 / w2(s3) * or(n4, i4, r5));
            }, i3 = n3([t3[0], t3[1], t3[2]], [e3[0], e3[1], e3[2]], r4), s2 = n3([t3[4], t3[5], t3[6]], [e3[4], e3[5], e3[6]], r4), o2 = n3([t3[8], t3[9], t3[10]], [e3[8], e3[9], e3[10]], r4), a22 = hc([t3[12], t3[13], t3[14]], [e3[12], e3[13], e3[14]], r4);
            return [i3[0], i3[1], i3[2], 0, s2[0], s2[1], s2[2], 0, o2[0], o2[1], o2[2], 0, a22[0], a22[1], a22[2], 1];
          }(i22, r3, n22);
        }
        return i22;
      }
      function cg(t22, e22, r22, n22) {
        const i22 = ic.projectAabbCorners(n22, r22);
        let s2 = Number.MAX_VALUE, o2 = -1;
        for (let t3 = 0; t3 < i22.length; ++t3) {
          const r3 = i22[t3];
          r3[0] = (0.5 * r3[0] + 0.5) * e22.width, r3[1] = (0.5 - 0.5 * r3[1]) * e22.height, r3[2] < s2 && (o2 = t3, s2 = r3[2]);
        }
        const a22 = (t3) => new bt(i22[t3][0], i22[t3][1]);
        let l22;
        switch (o2) {
          case 0:
          case 6:
            l22 = [a22(1), a22(5), a22(4), a22(7), a22(3), a22(2), a22(1)];
            break;
          case 1:
          case 7:
            l22 = [a22(0), a22(4), a22(5), a22(6), a22(2), a22(3), a22(0)];
            break;
          case 3:
          case 5:
            l22 = [a22(1), a22(0), a22(4), a22(7), a22(6), a22(2), a22(1)];
            break;
          default:
            l22 = [a22(1), a22(5), a22(6), a22(7), a22(3), a22(0), a22(1)];
        }
        if (xu(t22, l22)) return s2;
      }
      const hg = Qo([{ name: "a_pos_3f", components: 3, type: "Float32" }]), pg = Qo([{ name: "a_color_3f", components: 3, type: "Float32" }]), fg = Qo([{ name: "a_color_4f", components: 4, type: "Float32" }]), dg = Qo([{ name: "a_uv_2f", components: 2, type: "Float32" }]), mg = Qo([{ name: "a_normal_3f", components: 3, type: "Float32" }]), yg = Qo([{ name: "a_normal_matrix0", components: 4, type: "Float32" }, { name: "a_normal_matrix1", components: 4, type: "Float32" }, { name: "a_normal_matrix2", components: 4, type: "Float32" }, { name: "a_normal_matrix3", components: 4, type: "Float32" }]), gg = Qo([{ name: "a_pbr", components: 4, type: "Uint16" }, { name: "a_heightBasedEmissiveStrength", components: 3, type: "Float32" }]), xg = { None: 0, Model: 1, Symbol: 2, FillExtrusion: 4, All: 7 };
      class vg {
        constructor(t22, e22, r22, n22) {
          this.message = (t22 ? `${t22}: ` : "") + r22, n22 && (this.identifier = n22), null != e22 && e22.__line__ && (this.line = e22.__line__);
        }
      }
      function bg(t22, e22) {
        const r22 = -1 === t22.indexOf("://");
        try {
          return new URL(t22, r22 && e22 ? "http://example.com" : void 0), true;
        } catch (t3) {
          return false;
        }
      }
      class _g2 {
        constructor(t22, e22) {
          this.feature = t22, this.instancedDataOffset = e22, this.instancedDataCount = 0, this.rotation = [0, 0, 0], this.scale = [1, 1, 1], this.translation = [0, 0, 0];
        }
      }
      class wg {
        constructor() {
          this.instancedDataArray = new Ba(), this.instancesEvaluatedElevation = [], this.features = [], this.idToFeaturesIndex = {};
        }
      }
      class Ag {
        constructor(t22) {
          this.zoom = t22.zoom, this.canonical = t22.canonical, this.layers = t22.layers, this.layerIds = this.layers.map((t3) => t3.fqid), this.projection = t22.projection, this.index = t22.index, this.hasZoomDependentProperties = this.layers[0].isZoomDependent(), this.stateDependentLayerIds = this.layers.filter((t3) => t3.isStateDependent()).map((t3) => t3.id), this.hasPattern = false, this.instancesPerModel = {}, this.validForExaggeration = 0, this.maxVerticalOffset = 0, this.maxScale = 0, this.maxHeight = 0, this.lookupDim = this.zoom > this.canonical.z ? 256 : this.zoom > 15 ? 75 : 100, this.instanceCount = 0, this.terrainElevationMin = 0, this.terrainElevationMax = 0, this.validForDEMTile = { id: null, timestamp: 0 }, this.modelUris = [], this.modelsRequested = false, this.activeReplacements = [], this.replacementUpdateTime = 0, this.styleDefinedModelURLs = t22.styleDefinedModelURLs;
        }
        updateFootprints(t22, e22) {
        }
        populate(t22, e22, r22, n22) {
          this.tileToMeter = iu(r22);
          const i22 = this.layers[0]._featureFilter.needGeometry;
          this.lookup = new Uint8Array(this.lookupDim * this.lookupDim);
          for (const { feature: s2, id: o2, index: a22, sourceLayerIndex: l22 } of t22) {
            const t3 = null != o2 ? o2 : s2.properties && s2.properties.hasOwnProperty("id") ? s2.properties.id : void 0, u22 = du(s2, i22);
            if (!this.layers[0]._featureFilter.filter(new yo(this.zoom), u22, r22)) continue;
            const c22 = { id: t3, sourceLayerIndex: l22, index: a22, geometry: i22 ? u22.geometry : fu(s2, r22, n22), properties: s2.properties, type: s2.type, patterns: {} }, h22 = this.addFeature(c22, c22.geometry, u22);
            h22 && e22.featureIndex.insert(s2, c22.geometry, a22, l22, this.index, this.instancesPerModel[h22].instancedDataArray.length, Tn / 32);
          }
          this.lookup = null;
        }
        update(t22, e22, r22, n22) {
          for (const e3 in this.instancesPerModel) {
            const r3 = this.instancesPerModel[e3];
            for (const e4 in t22) r3.idToFeaturesIndex.hasOwnProperty(e4) && (this.evaluate(r3.features[r3.idToFeaturesIndex[e4]], t22[e4], r3, true), this.uploaded = false);
          }
          this.maxHeight = 0;
        }
        updateZoomBasedPaintProperties() {
          if (!this.hasZoomDependentProperties) return false;
          let t22 = false;
          for (const e22 in this.instancesPerModel) {
            const r22 = this.instancesPerModel[e22];
            for (const e3 of r22.features) {
              const n22 = this.layers[0], i22 = e3.feature, s2 = this.canonical, o2 = n22.paint.get("model-rotation").evaluate(i22, {}, s2), a22 = n22.paint.get("model-scale").evaluate(i22, {}, s2), l22 = n22.paint.get("model-translation").evaluate(i22, {}, s2);
              N2(e3.rotation, o2) && N2(e3.scale, a22) && N2(e3.translation, l22) || (this.evaluate(e3, e3.featureStates, r22, true), t22 = true);
            }
          }
          return t22;
        }
        updateReplacement(t22, e22, r22, n22) {
          if (e22.updateTime === this.replacementUpdateTime) return false;
          this.replacementUpdateTime = e22.updateTime;
          const i22 = e22.getReplacementRegionsForTile(t22.toUnwrapped(), true);
          if (Bp(this.activeReplacements, i22)) return false;
          this.activeReplacements = i22;
          let s2 = false;
          for (const e3 in this.instancesPerModel) {
            const i3 = this.instancesPerModel[e3], o2 = i3.instancedDataArray;
            for (const e4 of i3.features) {
              const i4 = e4.instancedDataOffset, a22 = e4.instancedDataCount;
              for (let e5 = 0; e5 < a22; e5++) {
                const a3 = 16 * (e5 + i4);
                let l22 = o2.float32[a3 + 0];
                const u22 = l22 > Tn;
                l22 = u22 ? l22 - Tn : l22;
                const c22 = Math.floor(l22), h22 = o2.float32[a3 + 1];
                let p22 = false;
                for (const e6 of this.activeReplacements) if (!kp(e6, r22, xg.Model, n22) && !(e6.min.x > c22 || c22 > e6.max.x || e6.min.y > h22 || h22 > e6.max.y) && (p22 = Rp(Lp(c22, h22, t22.canonical, e6.footprintTileId.canonical), e6.footprint), p22)) break;
                o2.float32[a3] = p22 ? l22 + Tn : l22, s2 = s2 || p22 !== u22;
              }
            }
          }
          return s2;
        }
        isEmpty() {
          for (const t22 in this.instancesPerModel) if (0 !== this.instancesPerModel[t22].instancedDataArray.length) return false;
          return true;
        }
        uploadPending() {
          return !this.uploaded;
        }
        upload(t22) {
          if (!this.uploaded) for (const e22 in this.instancesPerModel) {
            const r22 = this.instancesPerModel[e22];
            r22.instancedDataArray.length < 0 || 0 === r22.instancedDataArray.length || (r22.instancedDataBuffer ? r22.instancedDataBuffer.updateData(r22.instancedDataArray) : r22.instancedDataBuffer = t22.createVertexBuffer(r22.instancedDataArray, yg.members, true, void 0, this.instanceCount));
          }
          this.uploaded = true;
        }
        destroy() {
          for (const t3 in this.instancesPerModel) {
            const e22 = this.instancesPerModel[t3];
            0 !== e22.instancedDataArray.length && e22.instancedDataBuffer && e22.instancedDataBuffer.destroy();
          }
          const t22 = this.layers[0].modelManager;
          if (t22 && this.modelUris && this.modelsRequested) for (const e22 of this.modelUris) t22.removeModel(e22, "", true);
        }
        addFeature(t22, e22, r22) {
          const n22 = this.layers[0], i22 = n22.layout.get("model-id").evaluate(r22, {}, this.canonical);
          if (!i22) return $t2(`modelId is not evaluated for layer ${n22.id} and it is not going to get rendered.`), i22;
          (bg(i22, false) || void 0 !== this.styleDefinedModelURLs[i22]) && (this.modelUris.includes(i22) || this.modelUris.push(i22)), this.instancesPerModel[i22] || (this.instancesPerModel[i22] = new wg());
          const s2 = this.instancesPerModel[i22], o2 = s2.instancedDataArray, a22 = new _g2(r22, o2.length);
          for (const t3 of e22) for (const e3 of t3) {
            if (e3.x < 0 || e3.x >= Tn || e3.y < 0 || e3.y >= Tn) continue;
            const t4 = (this.lookupDim - 1) / Tn, r3 = this.lookupDim * (e3.y * t4 | 0) + e3.x * t4 | 0;
            if (this.lookup) {
              if (0 !== this.lookup[r3]) continue;
              this.lookup[r3] = 1;
            }
            this.instanceCount++;
            const n3 = o2.length;
            o2.resize(n3 + 1), s2.instancesEvaluatedElevation.push(0), o2.float32[16 * n3] = e3.x, o2.float32[16 * n3 + 1] = e3.y;
          }
          return a22.instancedDataCount = s2.instancedDataArray.length - a22.instancedDataOffset, a22.instancedDataCount > 0 && (t22.id && (s2.idToFeaturesIndex[t22.id] = s2.features.length), s2.features.push(a22), this.evaluate(a22, {}, s2, false)), i22;
        }
        getModelUris() {
          return this.modelUris;
        }
        evaluate(t22, e22, r22, n22) {
          const i22 = this.layers[0], s2 = t22.feature, o2 = this.canonical, a22 = t22.rotation = i22.paint.get("model-rotation").evaluate(s2, e22, o2), l22 = t22.scale = i22.paint.get("model-scale").evaluate(s2, e22, o2), u22 = t22.translation = i22.paint.get("model-translation").evaluate(s2, e22, o2), c22 = i22.paint.get("model-color").evaluate(s2, e22, o2);
          c22.a = i22.paint.get("model-color-mix-intensity").evaluate(s2, e22, o2);
          const h22 = [];
          this.maxVerticalOffset < u22[2] && (this.maxVerticalOffset = u22[2]), this.maxScale = Math.max(Math.max(this.maxScale, l22[0]), Math.max(l22[1], l22[2])), ag(h22, a22, l22);
          const p22 = Math.round(100 * c22.a) + c22.b / 1.05;
          for (let e3 = 0; e3 < t22.instancedDataCount; ++e3) {
            const i3 = t22.instancedDataOffset + e3, s3 = 16 * i3, a3 = r22.instancedDataArray.float32;
            let l3 = 0;
            n22 && (l3 = a3[s3 + 6] - r22.instancesEvaluatedElevation[i3]);
            const f22 = 0 | a3[s3 + 1];
            a3[s3] = (0 | a3[s3]) + c22.r / 1.05, a3[s3 + 1] = f22 + c22.g / 1.05, a3[s3 + 2] = p22, a3[s3 + 3] = 1 / (o2.z > 10 ? this.tileToMeter : iu(o2, f22)), a3[s3 + 4] = u22[0], a3[s3 + 5] = u22[1], a3[s3 + 6] = u22[2] + l3, a3[s3 + 7] = h22[0], a3[s3 + 8] = h22[1], a3[s3 + 9] = h22[2], a3[s3 + 10] = h22[4], a3[s3 + 11] = h22[5], a3[s3 + 12] = h22[6], a3[s3 + 13] = h22[8], a3[s3 + 14] = h22[9], a3[s3 + 15] = h22[10], r22.instancesEvaluatedElevation[i3] = u22[2];
          }
        }
      }
      let Mg, Ig;
      js(Ag, "ModelBucket", { omit: ["layers"] }), js(wg, "PerModelAttributes"), js(_g2, "ModelFeature");
      const Sg = 64, zg = { CoordinateSpaceTile: 1, CoordinateSpaceYUp: 2, HasMapboxMeshFeatures: 4, HasMeshoptCompression: 8 };
      function kg(t22, e22, r22, n22, i22, s2, o2, a22, u22, f22 = false) {
        const d22 = r22.zoom, m22 = r22.project(n22), y22 = ru2(n22.lat, d22), g22 = 1 / y22;
        l2(t22), h2(t22, t22, [m22.x + o2[0] * g22, m22.y + o2[1] * g22, o2[2]]);
        let v22 = 1, b22 = 1;
        const _22 = r22.worldSize;
        if (f22) {
          if ("mercator" === r22.projection.name) {
            let t3 = 0;
            r22.elevation && (t3 = r22.elevation.getAtPointOrZero(new su(m22.x / _22, m22.y / _22), 0));
            const e3 = Z([], [m22.x, m22.y, t3, 1], r22.projMatrix)[3] / r22.cameraToCenterDistance;
            v22 = e3, b22 = e3 * ru2(r22.center.lat, d22);
          } else if ("globe" === r22.projection.name) {
            const e3 = ug(t22, r22), i3 = [0, 0, 0, 1];
            Z(i3, i3, c2([], r22.projMatrix, e3));
            const s3 = i3[3] / r22.cameraToCenterDistance, o3 = Mc(d22), a3 = r22.projection.pixelsPerMeter(n22.lat, _22) * ru2(n22.lat, d22), l22 = r22.projection.pixelsPerMeter(r22.center.lat, _22) * ru2(r22.center.lat, d22);
            v22 = s3 / or(a3, eu(r22.center.lat), o3), b22 = s3 * y22 / a3, v22 *= l22, b22 *= l22;
          }
        } else v22 = g22;
        p2(t22, t22, [v22, v22, b22]);
        const w22 = [...t22], A22 = e22.orientation, M22 = [];
        if (ag(M22, [A22[0] + i22[0], A22[1] + i22[1], A22[2] + i22[2]], s2), c2(t22, w22, M22), a22 && r22.elevation) {
          let i3 = 0;
          const s3 = [];
          if (u22 && r22.elevation) {
            i3 = function(t3, e3, r3, n3, i4) {
              const s4 = e3.elevation;
              if (!s4) return 0;
              const o4 = ic.projectAabbCorners(r3, n3), a3 = Yl(1, i4.lat) * e3.worldSize, l22 = function(t4, e4) {
                const r4 = [0, 0, 1], n4 = [{ corners: [0, 1, 3, 2], dotProductWithUp: 0 }, { corners: [1, 5, 2, 6], dotProductWithUp: 0 }, { corners: [0, 4, 1, 5], dotProductWithUp: 0 }, { corners: [2, 6, 3, 7], dotProductWithUp: 0 }, { corners: [4, 7, 5, 6], dotProductWithUp: 0 }, { corners: [0, 3, 4, 7], dotProductWithUp: 0 }];
                for (const i5 of n4) {
                  const n5 = t4[i5.corners[0]], s5 = t4[i5.corners[1]], o5 = t4[i5.corners[2]], a4 = [s5[0] - n5[0], s5[1] - n5[1], e4 * (s5[2] - n5[2])], l3 = F(a4, a4, [o5[0] - n5[0], o5[1] - n5[1], e4 * (o5[2] - n5[2])]);
                  C(l3, l3), i5.dotProductWithUp = D2(l3, r4);
                }
                return n4.sort((t5, e5) => t5.dotProductWithUp - e5.dotProductWithUp), n4[0].corners;
              }(o4, a3), u3 = o4[l22[0]], c22 = o4[l22[1]], h22 = o4[l22[2]], p22 = o4[l22[3]], f3 = s4.getAtPointOrZero(new su(u3[0] / e3.worldSize, u3[1] / e3.worldSize), 0), d3 = s4.getAtPointOrZero(new su(c22[0] / e3.worldSize, c22[1] / e3.worldSize), 0), m3 = s4.getAtPointOrZero(new su(h22[0] / e3.worldSize, h22[1] / e3.worldSize), 0), y3 = s4.getAtPointOrZero(new su(p22[0] / e3.worldSize, p22[1] / e3.worldSize), 0), g3 = (f3 + y3) / 2, x22 = (d3 + m3) / 2;
              return g3 > x22 ? d3 < m3 ? lg(t3, c22, p22, u3, d3, y3, f3, a3) : lg(t3, h22, u3, p22, m3, f3, y3, a3) : f3 < y3 ? lg(t3, u3, c22, h22, f3, d3, m3, a3) : lg(t3, p22, h22, c22, y3, m3, d3, a3), Math.max(g3, x22);
            }(s3, r22, e22.aabb, t22, n22);
            const o3 = c2([], x2([], s3), M22);
            c2(t22, w22, o3);
          } else i3 = r22.elevation.getAtPointOrZero(new su(m22.x / _22, m22.y / _22), 0);
          0 !== i3 && (t22[14] += i3);
        }
      }
      function Eg(t22, e22, r22 = false) {
        t22.uploaded || (t22.gfxTexture = new Oy(e22, t22.image, r22 ? e22.gl.R8 : e22.gl.RGBA8, { useMipmap: t22.sampler.minFilter >= e22.gl.NEAREST_MIPMAP_NEAREST }), t22.uploaded = true, t22.image = null);
      }
      function Pg(t22, e22, r22) {
        t22.indexBuffer = e22.createIndexBuffer(t22.indexArray, false, true), t22.vertexBuffer = e22.createVertexBuffer(t22.vertexArray, hg.members, false, true), t22.normalArray && (t22.normalBuffer = e22.createVertexBuffer(t22.normalArray, mg.members, false, true)), t22.texcoordArray && (t22.texcoordBuffer = e22.createVertexBuffer(t22.texcoordArray, dg.members, false, true)), t22.colorArray && (t22.colorBuffer = e22.createVertexBuffer(t22.colorArray, (12 === t22.colorArray.bytesPerElement ? pg : fg).members, false, true)), t22.featureArray && (t22.pbrBuffer = e22.createVertexBuffer(t22.featureArray, gg.members, true)), t22.segments = Ka.simpleSegment(0, 0, t22.vertexArray.length, t22.indexArray.length);
        const n22 = t22.material;
        n22.pbrMetallicRoughness.baseColorTexture && Eg(n22.pbrMetallicRoughness.baseColorTexture, e22), n22.pbrMetallicRoughness.metallicRoughnessTexture && Eg(n22.pbrMetallicRoughness.metallicRoughnessTexture, e22), n22.normalTexture && Eg(n22.normalTexture, e22), n22.occlusionTexture && Eg(n22.occlusionTexture, e22, r22), n22.emissionTexture && Eg(n22.emissionTexture, e22);
      }
      function Tg(t22, e22, r22) {
        if (t22.meshes) for (const n22 of t22.meshes) Pg(n22, e22, r22);
        if (t22.children) for (const n22 of t22.children) Tg(n22, e22, r22);
      }
      function Bg(t22) {
        if (t22.meshes) for (const e22 of t22.meshes) e22.indexArray.destroy(), e22.vertexArray.destroy(), e22.colorArray && e22.colorArray.destroy(), e22.normalArray && e22.normalArray.destroy(), e22.texcoordArray && e22.texcoordArray.destroy(), e22.featureArray && e22.featureArray.destroy();
        if (t22.children) for (const e22 of t22.children) Bg(e22);
      }
      function Vg(t22) {
        if (t22.meshes) for (const r22 of t22.meshes) r22.vertexBuffer && (r22.vertexBuffer.destroy(), r22.indexBuffer.destroy(), r22.normalBuffer && r22.normalBuffer.destroy(), r22.texcoordBuffer && r22.texcoordBuffer.destroy(), r22.colorBuffer && r22.colorBuffer.destroy(), r22.pbrBuffer && r22.pbrBuffer.destroy(), r22.segments.destroy(), r22.material && ((e22 = r22.material).pbrMetallicRoughness.baseColorTexture && e22.pbrMetallicRoughness.baseColorTexture.gfxTexture && e22.pbrMetallicRoughness.baseColorTexture.gfxTexture.destroy(), e22.pbrMetallicRoughness.metallicRoughnessTexture && e22.pbrMetallicRoughness.metallicRoughnessTexture.gfxTexture && e22.pbrMetallicRoughness.metallicRoughnessTexture.gfxTexture.destroy(), e22.normalTexture && e22.normalTexture.gfxTexture && e22.normalTexture.gfxTexture.destroy(), e22.emissionTexture && e22.emissionTexture.gfxTexture && e22.emissionTexture.gfxTexture.destroy(), e22.occlusionTexture && e22.occlusionTexture.gfxTexture && e22.occlusionTexture.gfxTexture.destroy()));
        var e22;
        if (t22.children) for (const e3 of t22.children) Vg(e3);
      }
      class Cg {
        constructor(t22, e22, r22) {
          this._demTile = t22, this._dem = this._demTile.dem, this._scale = e22, this._offset = r22;
        }
        static create(t22, e22, r22) {
          const n22 = r22 || t22.findDEMTileFor(e22);
          if (!n22 || !n22.dem) return;
          const i22 = n22.dem, s2 = n22.tileID, o2 = 1 << e22.canonical.z - s2.canonical.z;
          return new Cg(n22, i22.dim / Tn / o2, [(e22.canonical.x / o2 - s2.canonical.x) * i22.dim, (e22.canonical.y / o2 - s2.canonical.y) * i22.dim]);
        }
        tileCoordToPixel(t22, e22) {
          const r22 = e22 * this._scale + this._offset[1], n22 = Math.floor(t22 * this._scale + this._offset[0]), i22 = Math.floor(r22);
          return new bt(n22, i22);
        }
        getElevationAt(t22, e22, r22, n22) {
          const i22 = t22 * this._scale + this._offset[0], s2 = e22 * this._scale + this._offset[1], o2 = Math.floor(i22), a22 = Math.floor(s2), l22 = this._dem;
          return n22 = !!n22, r22 ? or(or(l22.get(o2, a22, n22), l22.get(o2, a22 + 1, n22), s2 - a22), or(l22.get(o2 + 1, a22, n22), l22.get(o2 + 1, a22 + 1, n22), s2 - a22), i22 - o2) : l22.get(o2, a22, n22);
        }
        getElevationAtPixel(t22, e22, r22) {
          return this._dem.get(t22, e22, !!r22);
        }
        getMeterToDEM(t22) {
          return (1 << this._demTile.tileID.canonical.z) * Yl(1, t22) * this._dem.stride;
        }
      }
      const Dg = new Float32Array(262144), Fg = new Uint8Array(262144);
      function Lg(t22) {
        let e22 = 0;
        if (t22.meshes) for (const r22 of t22.meshes) e22 = Math.max(e22, r22.aabb.max[2]);
        if (t22.children) for (const r22 of t22.children) e22 = Math.max(e22, Lg(r22));
        return e22;
      }
      function Rg(t22, e22, r22) {
        if (t22.meshes) for (const n22 of t22.meshes) {
          if (n22.aabb.min[0] === 1 / 0) continue;
          const i22 = ic.applyTransform(n22.aabb, t22.matrix);
          r22.insert(e22, i22.min[0], i22.min[1], i22.max[0], i22.max[1]);
        }
        if (t22.children) for (const n22 of t22.children) Rg(n22, e22, r22);
      }
      const Og = ["", "wall", "door", "roof", "window", "lamp", "logo"];
      class Ug {
        constructor(t22) {
          this.node = t22, this.evaluatedRMEA = [[1, 0, 0, 1], [1, 0, 0, 1], [1, 0, 0, 1], [1, 0, 0, 1], [0.4, 1, 0, 1], [1, 0, 0, 1], [1, 0, 0, 1]], this.hiddenByReplacement = false, this.evaluatedScale = [1, 1, 1], this.evaluatedColor = [], this.emissionHeightBasedParams = [], this.cameraCollisionOpacity = 1, this.feature = { type: "Point", id: t22.id, geometry: [], properties: { height: Lg(t22) } }, this.aabb = this._getLocalBounds(), this.state = null;
        }
        _getLocalBounds() {
          if (!this.node.meshes) return new ic([1 / 0, 1 / 0, 1 / 0], [-1 / 0, -1 / 0, -1 / 0]);
          if (!this.aabb) {
            let t22 = 0;
            const e22 = new ic([1 / 0, 1 / 0, 1 / 0], [-1 / 0, -1 / 0, -1 / 0]);
            for (const r22 of this.node.meshes) this.node.lightMeshIndex !== t22 && (r22.transformedAabb = ic.applyTransformFast(r22.aabb, this.node.matrix), e22.encapsulate(r22.transformedAabb)), t22++;
            this.aabb = e22;
          }
          return this.aabb;
        }
      }
      class Ng {
        constructor(t22, e22, r22, n22, i22, s2, o2) {
          this.id = r22, this.layers = t22, this.layerIds = this.layers.map((t3) => t3.fqid), this.stateDependentLayerIds = this.layers.filter((t3) => t3.isStateDependent()).map((t3) => t3.id), this.modelTraits |= zg.CoordinateSpaceTile, this.uploaded = false, this.hasPattern = false, n22 && (this.modelTraits |= zg.HasMapboxMeshFeatures), i22 && (this.modelTraits |= zg.HasMeshoptCompression), this.zoom = -1, this.terrainExaggeration = 1, this.projection = { name: "mercator" }, this.replacementUpdateTime = 0, this.elevationReadFromZ = 255, this.brightness = s2, this.dirty = true, this.needsUpload = false, this.filter = null, this.nodesInfo = [];
          for (const t3 of e22) this.nodesInfo.push(new Ug(t3)), Rg(t3, o2.featureIndexArray.length, o2.grid), o2.featureIndexArray.emplaceBack(this.nodesInfo.length - 1, 0, o2.bucketLayerIDs.length - 1, 0);
          this.states = {};
        }
        updateFootprints(t22, e22) {
          for (const r22 of this.getNodesInfo()) {
            const n22 = r22.node;
            n22.footprint && e22.push({ footprint: n22.footprint, id: t22 });
          }
        }
        update(t22) {
          const e22 = 0 !== Object.keys(t22).length;
          if (e22 && !this.stateDependentLayers.length) return;
          const r22 = e22 ? this.stateDependentLayers : this.layers;
          if (!_t2(t22, this.states)) for (const e3 of r22) this.evaluate(e3, t22);
          this.states = structuredClone(t22);
        }
        populate() {
          console.log("populate 3D model bucket");
        }
        uploadPending() {
          return !this.uploaded || this.needsUpload;
        }
        upload(t22) {
          if (!this.needsUpload) return;
          const e22 = this.getNodesInfo();
          for (const r22 of e22) {
            const e3 = r22.node;
            this.uploaded ? this.updatePbrBuffer(e3) : Tg(e3, t22, true);
          }
          for (const t3 of e22) Bg(t3.node);
          this.uploaded = true, this.needsUpload = false;
        }
        updatePbrBuffer(t22) {
          let e22 = false;
          if (!t22.meshes) return e22;
          for (const r22 of t22.meshes) r22.pbrBuffer && (r22.pbrBuffer.updateData(r22.featureArray), e22 = true);
          return e22;
        }
        needsReEvaluation(t22, e22, r22) {
          const n22 = t22.transform.projectionOptions, i22 = t22.style.getBrightness(), s2 = this.brightness !== i22;
          if (!this.uploaded || this.dirty || n22.name !== this.projection.name || jg(r22.paint.get("model-color").value, s2) || jg(r22.paint.get("model-color-mix-intensity").value, s2) || jg(r22.paint.get("model-roughness").value, s2) || jg(r22.paint.get("model-emissive-strength").value, s2) || jg(r22.paint.get("model-height-based-emissive-strength-multiplier").value, s2)) {
            this.projection = n22, this.brightness = i22;
            const t3 = this.getNodesInfo();
            for (const e3 of t3) e3.state = null;
            return true;
          }
          return false;
        }
        evaluateScale(t22, e22) {
          if (t22.transform.zoom === this.zoom) return;
          this.zoom = t22.transform.zoom;
          const r22 = this.getNodesInfo(), n22 = this.id.canonical;
          for (const t3 of r22) {
            const r3 = t3.feature;
            t3.evaluatedScale = e22.paint.get("model-scale").evaluate(r3, {}, n22);
          }
        }
        evaluate(t22, e22) {
          const r22 = this.getNodesInfo();
          for (const n22 of r22) {
            if (!n22.node.meshes) continue;
            const r3 = n22.feature, i22 = e22 && e22[r3.id];
            if (_t2(i22, n22.state)) continue;
            n22.state = structuredClone(i22);
            const s2 = n22.node.meshes && n22.node.meshes[0].featureData, o2 = n22.evaluatedColor[2], a22 = n22.evaluatedRMEA[2], l22 = this.id.canonical;
            if (n22.hasTranslucentParts = false, s2) {
              for (let e3 = 0; e3 < Og.length; e3++) {
                const s3 = Og[e3];
                s3.length && (r3.properties.part = s3);
                const o3 = t22.paint.get("model-color").evaluate(r3, i22, l22).toRenderColor(null), a3 = t22.paint.get("model-color-mix-intensity").evaluate(r3, i22, l22);
                n22.evaluatedColor[e3] = [o3.r, o3.g, o3.b, a3], n22.evaluatedRMEA[e3][0] = t22.paint.get("model-roughness").evaluate(r3, i22, l22), n22.evaluatedRMEA[e3][2] = t22.paint.get("model-emissive-strength").evaluate(r3, i22, l22), n22.evaluatedRMEA[e3][3] = o3.a, n22.emissionHeightBasedParams[e3] = t22.paint.get("model-height-based-emissive-strength-multiplier").evaluate(r3, i22, l22), !n22.hasTranslucentParts && o3.a < 1 && (n22.hasTranslucentParts = true);
              }
              delete r3.properties.part, Gg(n22, o2 !== n22.evaluatedColor[2] || a22 !== n22.evaluatedRMEA[2], this.modelTraits);
            } else n22.evaluatedRMEA[0][2] = t22.paint.get("model-emissive-strength").evaluate(r3, i22, l22);
            n22.evaluatedScale = t22.paint.get("model-scale").evaluate(r3, i22, l22), this.updatePbrBuffer(n22.node) || (this.needsUpload = true);
          }
          this.dirty = false;
        }
        elevationUpdate(t22, e22, r22, n22) {
          const i22 = t22.findDEMTileFor(r22);
          if (i22 && (i22.tileID.canonical !== this.terrainTile || e22 !== this.terrainExaggeration)) {
            if (i22.dem && i22.tileID.overscaledZ !== this.elevationReadFromZ) {
              this.elevationReadFromZ = i22.tileID.overscaledZ;
              const e3 = Cg.create(t22, r22, i22);
              if (!e3) return;
              this.modelTraits & zg.HasMapboxMeshFeatures && this.updateDEM(t22, e3, r22, n22);
              for (const t3 of this.getNodesInfo()) {
                const r3 = t3.node;
                if (!r3.footprint || !r3.footprint.vertices || !r3.footprint.vertices.length) continue;
                const n3 = r3.footprint.vertices;
                let i3 = e3.getElevationAt(n3[0].x, n3[0].y, true, true);
                for (let t4 = 1; t4 < n3.length; t4++) i3 = Math.min(i3, e3.getElevationAt(n3[t4].x, n3[t4].y, true, true));
                r3.elevation = i3;
              }
            }
            this.terrainTile = i22.tileID.canonical, this.terrainExaggeration = e22;
          }
        }
        updateDEM(t22, e22, r22, n22) {
          let i22 = e22._dem._modifiedForSources[n22];
          if (void 0 === i22 && (e22._dem._modifiedForSources[n22] = [], i22 = e22._dem._modifiedForSources[n22]), i22.includes(r22.canonical)) return;
          const s2 = e22._dem.dim;
          i22.push(r22.canonical);
          let o2 = false;
          for (const t3 of this.getNodesInfo()) {
            const r3 = t3.node;
            if (!r3.footprint || !r3.footprint.grid) continue;
            const n3 = r3.footprint.grid, i3 = e22.tileCoordToPixel(n3.min.x, n3.min.y), a22 = e22.tileCoordToPixel(n3.max.x, n3.max.y), l22 = Math.min(Math.min(s2 - a22.y, i3.x), Math.min(i3.y, s2 - a22.x));
            if (l22 < 0) continue;
            const u22 = Pt(l22, 2, 5);
            let c22 = Math.max(0, i3.x - u22), h22 = Math.max(0, i3.y - u22), p22 = Math.min(a22.x + u22, s2 - 1), f22 = Math.min(a22.y + u22, s2 - 1);
            for (let t4 = h22; t4 <= f22; ++t4) for (let e3 = c22; e3 <= p22; ++e3) Fg[t4 * s2 + e3] = 255;
            let d22 = 0, m22 = 0;
            for (let t4 = 0; t4 < n3.cellsY; ++t4) for (let r4 = 0; r4 < n3.cellsX; ++r4) {
              if (!n3.cells[t4 * n3.cellsX + r4]) continue;
              const i4 = e22.tileCoordToPixel(n3.min.x + r4 / n3.xScale, n3.min.y + t4 / n3.yScale), o3 = e22.tileCoordToPixel(n3.min.x + (r4 + 1) / n3.xScale, n3.min.y + (t4 + 1) / n3.yScale);
              for (let t5 = i4.y; t5 <= Math.min(o3.y + 1, s2 - 1); ++t5) for (let r5 = i4.x; r5 <= Math.min(o3.x + 1, s2 - 1); ++r5) 255 === Fg[t5 * s2 + r5] && (Fg[t5 * s2 + r5] = 0, d22 += e22.getElevationAtPixel(r5, t5), m22++);
            }
            const y22 = d22 / m22;
            c22 = Math.max(1, i3.x - u22), h22 = Math.max(1, i3.y - u22), p22 = Math.min(a22.x + u22, s2 - 2), f22 = Math.min(a22.y + u22, s2 - 2), o2 = true;
            for (let t4 = h22; t4 <= f22; ++t4) for (let r4 = c22; r4 <= p22; ++r4) 0 === Fg[t4 * s2 + r4] && (Dg[t4 * s2 + r4] = e22._dem.set(r4, t4, y22));
            for (let t4 = 1; t4 < u22; ++t4) {
              c22 = Math.max(1, i3.x - t4), h22 = Math.max(1, i3.y - t4), p22 = Math.min(a22.x + t4, s2 - 2), f22 = Math.min(a22.y + t4, s2 - 2);
              for (let r4 = h22; r4 <= f22; ++r4) for (let n4 = c22; n4 <= p22; ++n4) {
                const i4 = r4 * s2 + n4;
                if (255 === Fg[i4]) {
                  let o3 = 0, a3 = 0, l3 = -1, c3 = -1;
                  for (let e3 = -1; e3 <= 1; ++e3) for (let i5 = -1; i5 <= 1; ++i5) {
                    const u3 = (r4 + e3) * s2 + n4 + i5;
                    if (Fg[u3] >= t4) continue;
                    const h3 = Dg[u3], p3 = Math.abs(h3);
                    p3 > a3 && (o3 = h3, a3 = p3, l3 = i5, c3 = e3);
                  }
                  if (a3 > 0.1) {
                    const s3 = 1 - (t4 + 0.5 * Math.abs(l3 * c3)) / u22;
                    let a4 = e22._dem.get(n4, r4) + o3 * s3;
                    const h3 = e22._dem.get(n4 + l3, r4 + c3), p3 = e22._dem.get(n4 - l3, r4 - c3, true);
                    (a4 - h3) * (a4 - p3) > 0 && (a4 = (h3 + p3) / 2), Dg[i4] = e22._dem.set(n4, r4, a4), Fg[i4] = t4;
                  }
                }
              }
            }
          }
          o2 && (e22._demTile.needsDEMTextureUpload = true, e22._dem._timestamp = pe.now());
        }
        setFilter(t22) {
          this.filter = t22 ? Vo(t22) : null;
        }
        getNodesInfo() {
          return this.filter ? this.nodesInfo.filter((t22) => this.filter.filter(new yo(this.id.overscaledZ), t22.feature, this.id.canonical)) : this.nodesInfo;
        }
        destroy() {
          const t22 = this.getNodesInfo();
          for (const e22 of t22) Bg(e22.node), Vg(e22.node);
        }
        isEmpty() {
          return !this.nodesInfo.length;
        }
        updateReplacement(t22, e22) {
          if (e22.updateTime === this.replacementUpdateTime) return;
          this.replacementUpdateTime = e22.updateTime;
          const r22 = e22.getReplacementRegionsForTile(t22.toUnwrapped()), n22 = this.getNodesInfo();
          for (let t3 = 0; t3 < this.nodesInfo.length; t3++) {
            const e3 = n22[t3].node;
            n22[t3].hiddenByReplacement = !!e3.footprint && !r22.find((t4) => t4.footprint === e3.footprint);
          }
        }
        getHeightAtTileCoord(t22, e22) {
          const r22 = this.getNodesInfo(), n22 = [], i22 = [0, 0, 0], s2 = l2([]);
          for (let o2 = 0; o2 < this.nodesInfo.length; o2++) {
            const a22 = r22[o2], l22 = a22.node.meshes[0], c22 = l22.transformedAabb;
            if (t22 < c22.min[0] || e22 < c22.min[1] || t22 > c22.max[0] || e22 > c22.max[1]) continue;
            if (true === a22.node.hidden) return { height: 1 / 0, maxHeight: a22.feature.properties.height, hidden: false, verticalScale: a22.evaluatedScale[2] };
            u2(s2, a22.node.matrix), i22[0] = t22, i22[1] = e22, R2(i22, i22, s2);
            const h22 = (i22[0] - l22.aabb.min[0]) / (l22.aabb.max[0] - l22.aabb.min[0]) * Sg | 0, p22 = Math.min(63, (i22[1] - l22.aabb.min[1]) / (l22.aabb.max[1] - l22.aabb.min[1]) * Sg | 0) * Sg + Math.min(63, h22), f22 = l22.heightmap[p22];
            if (!(f22 < 0 && a22.node.footprint)) {
              if (a22.hiddenByReplacement) return;
              return { height: f22, maxHeight: a22.feature.properties.height, hidden: false, verticalScale: a22.evaluatedScale[2] };
            }
            if (a22.node.footprint.grid.query(new bt(t22, e22), new bt(t22, e22), n22), n22.length > 0) return { height: void 0, maxHeight: a22.feature.properties.height, hidden: a22.hiddenByReplacement, verticalScale: a22.evaluatedScale[2] };
          }
        }
      }
      function jg(t22, e22) {
        return t22 instanceof Bs && !t22.isLightConstant && e22;
      }
      function $g(t22, e22, r22, n22, i22, s2, o2, a22) {
        let l22 = (61440 & e22 | (61440 & e22) >> 4) >> 8, u22 = (3840 & e22 | (3840 & e22) >> 4) >> 4, c22 = 240 & e22 | (240 & e22) >> 4;
        r22[3] > 0 && (l22 = or(l22, 255 * r22[0], r22[3]), u22 = or(u22, 255 * r22[1], r22[3]), c22 = or(c22, 255 * r22[2], r22[3]));
        const h22 = l22 << 8 | u22, p22 = c22 << 8 | Math.floor(255 * n22[3]), f22 = function(t3) {
          const e3 = Pt(t3, 0, 2);
          return Math.min(Math.round(0.5 * e3 * 255), 255);
        }(n22[2]) << 8 | 15 * n22[0] << 4 | 15 * n22[1], d22 = Pt(i22[0], 0, 1), m22 = Pt(i22[1], 0, 1), y22 = Pt(i22[2], 0, 1), g22 = Pt(i22[3], 0, 1);
        let x22, v22, b22, _22;
        if (d22 !== m22 && o2 !== s2 && m22 !== d22) {
          const t3 = o2 - s2;
          v22 = 1 / (t3 * (m22 - d22)), b22 = -(s2 + t3 * d22) / (t3 * (m22 - d22));
          const e3 = Pt(i22[4], -1, 1);
          _22 = Math.pow(10, e3), x22 = 255 * y22 << 8 | 255 * g22;
        } else x22 = 65535, v22 = 0, b22 = 1, _22 = 1;
        if (t22.emplaceBack(h22, p22, f22, x22, v22, b22, _22), a22) {
          const t3 = a22.length;
          a22.clear();
          for (let e3 = 0; e3 < t3; e3++) a22.emplaceBack(h22, p22, f22, x22, v22, b22, _22);
        }
      }
      function Gg(t22, e22, r22) {
        const n22 = t22.node;
        let i22 = 0;
        const s2 = r22 & zg.HasMeshoptCompression;
        for (const r3 of n22.meshes) {
          if (n22.lights && n22.lightMeshIndex === i22) continue;
          if (!r3.featureData) continue;
          r3.featureArray = new Va(), r3.featureArray.reserve(r3.featureData.length);
          let o2 = e22;
          for (const e3 of r3.featureData) {
            const i3 = s2 ? 65535 & e3 : e3 >> 16 & 65535, a22 = s2 ? e3 >> 16 & 65535 : 65535 & e3, l22 = (15 & a22) < 8 ? 15 & a22 : 0, u22 = t22.evaluatedRMEA[l22], c22 = t22.evaluatedColor[l22], h22 = t22.emissionHeightBasedParams[l22];
            let p22;
            if (o2 && 2 === l22 && n22.lights && (p22 = new Va(), p22.resize(10 * n22.lights.length)), $g(r3.featureArray, i3, c22, u22, h22, r3.aabb.min[2], r3.aabb.max[2], p22), p22 && o2) {
              o2 = false;
              const t3 = n22.meshes[n22.lightMeshIndex];
              t3.featureArray = p22, t3.featureArray._trim();
            }
          }
          r3.featureArray._trim(), i22++;
        }
      }
      function qg(t22, e22, r22, n22) {
        const i22 = 1 << t22.z;
        e22.lat = Jl((n22 / Tn + t22.y) / i22), e22.lng = Kl((r22 / Tn + t22.x) / i22);
      }
      js(Ng, "Tiled3dModelBucket", { omit: ["layers"] }), js(Ug, "Tiled3dModelFeature");
      const Hg = { circle: class extends Wo {
        constructor(t22, e22, r22, n22) {
          super(t22, { layout: Ru || (Ru = new ko({ "circle-sort-key": new So(Eo.layout_circle["circle-sort-key"]), "circle-elevation-reference": new Io(Eo.layout_circle["circle-elevation-reference"]), visibility: new Io(Eo.layout_circle.visibility) })), paint: Ou || (Ou = new ko({ "circle-radius": new So(Eo.paint_circle["circle-radius"]), "circle-color": new So(Eo.paint_circle["circle-color"]), "circle-blur": new So(Eo.paint_circle["circle-blur"]), "circle-opacity": new So(Eo.paint_circle["circle-opacity"]), "circle-translate": new Io(Eo.paint_circle["circle-translate"]), "circle-translate-anchor": new Io(Eo.paint_circle["circle-translate-anchor"]), "circle-pitch-scale": new Io(Eo.paint_circle["circle-pitch-scale"]), "circle-pitch-alignment": new Io(Eo.paint_circle["circle-pitch-alignment"]), "circle-stroke-width": new So(Eo.paint_circle["circle-stroke-width"]), "circle-stroke-color": new So(Eo.paint_circle["circle-stroke-color"]), "circle-stroke-opacity": new So(Eo.paint_circle["circle-stroke-opacity"]), "circle-emissive-strength": new Io(Eo.paint_circle["circle-emissive-strength"]), "circle-color-use-theme": new So({ type: "string", default: "default", "property-type": "data-driven" }), "circle-stroke-color-use-theme": new So({ type: "string", default: "default", "property-type": "data-driven" }) })) }, e22, r22, n22);
        }
        createBucket(t22) {
          return new gu(t22);
        }
        queryRadius(t22) {
          const e22 = t22;
          return Cu("circle-radius", this, e22) + Cu("circle-stroke-width", this, e22) + Du(this.paint.get("circle-translate"));
        }
        queryIntersectsFeature(t22, e22, r22, n22, i22, s2, o2, a22) {
          const l22 = Lu(this.paint.get("circle-translate"), this.paint.get("circle-translate-anchor"), s2.angle, t22.pixelToTileUnitsFactor), u22 = this.paint.get("circle-radius").evaluate(e22, r22) + this.paint.get("circle-stroke-width").evaluate(e22, r22);
          return Bc(t22, n22, s2, o2, a22, "map" === this.paint.get("circle-pitch-alignment"), "map" === this.paint.get("circle-pitch-scale"), l22, u22);
        }
        getProgramIds() {
          return ["circle"];
        }
        getDefaultProgramParams(t22, e22, r22) {
          const n22 = Tc(this);
          return { config: new Ml(this, { zoom: e22, lut: r22 }), defines: n22, overrideFog: false };
        }
        hasElevation() {
          return this.layout && "none" !== this.layout.get("circle-elevation-reference");
        }
      }, heatmap: class extends Wo {
        createBucket(t22) {
          return new Lc(t22);
        }
        constructor(t22, e22, r22, n22) {
          super(t22, { layout: Rc || (Rc = new ko({ visibility: new Io(Eo.layout_heatmap.visibility) })), paint: Oc || (Oc = new ko({ "heatmap-radius": new So(Eo.paint_heatmap["heatmap-radius"]), "heatmap-weight": new So(Eo.paint_heatmap["heatmap-weight"]), "heatmap-intensity": new Io(Eo.paint_heatmap["heatmap-intensity"]), "heatmap-color": new zo(Eo.paint_heatmap["heatmap-color"]), "heatmap-opacity": new Io(Eo.paint_heatmap["heatmap-opacity"]), "heatmap-color-use-theme": new So({ type: "string", default: "default", "property-type": "data-driven" }) })) }, e22, r22, n22), this._updateColorRamp();
        }
        _handleSpecialPaintPropertyUpdate(t22) {
          "heatmap-color" === t22 && this._updateColorRamp();
        }
        _updateColorRamp() {
          this.colorRamp = Zc({ expression: this._transitionablePaint._values["heatmap-color"].value.expression, evaluationKey: "heatmapDensity", image: this.colorRamp }), this.colorRampTexture = null;
        }
        resize() {
          this.heatmapFbo && (this.heatmapFbo.destroy(), this.heatmapFbo = null);
        }
        queryRadius(t22) {
          return Cu("heatmap-radius", this, t22);
        }
        queryIntersectsFeature(t22, e22, r22, n22, i22, s2, o2, a22) {
          const l22 = this.paint.get("heatmap-radius").evaluate(e22, r22);
          return Bc(t22, n22, s2, o2, a22, true, true, new bt(0, 0), l22);
        }
        hasOffscreenPass() {
          return 0 !== this.paint.get("heatmap-opacity") && "none" !== this.visibility;
        }
        getProgramIds() {
          return ["heatmap", "heatmapTexture"];
        }
        getDefaultProgramParams(t22, e22, r22) {
          return "heatmap" === t22 ? { config: new Ml(this, { zoom: e22, lut: r22 }), overrideFog: false } : {};
        }
      }, hillshade: class extends Wo {
        constructor(t22, e22, r22, n22) {
          super(t22, { layout: Uc || (Uc = new ko({ visibility: new Io(Eo.layout_hillshade.visibility) })), paint: Nc || (Nc = new ko({ "hillshade-illumination-direction": new Io(Eo.paint_hillshade["hillshade-illumination-direction"]), "hillshade-illumination-anchor": new Io(Eo.paint_hillshade["hillshade-illumination-anchor"]), "hillshade-exaggeration": new Io(Eo.paint_hillshade["hillshade-exaggeration"]), "hillshade-shadow-color": new Io(Eo.paint_hillshade["hillshade-shadow-color"]), "hillshade-highlight-color": new Io(Eo.paint_hillshade["hillshade-highlight-color"]), "hillshade-accent-color": new Io(Eo.paint_hillshade["hillshade-accent-color"]), "hillshade-emissive-strength": new Io(Eo.paint_hillshade["hillshade-emissive-strength"]), "hillshade-shadow-color-use-theme": new So({ type: "string", default: "default", "property-type": "data-driven" }), "hillshade-highlight-color-use-theme": new So({ type: "string", default: "default", "property-type": "data-driven" }), "hillshade-accent-color-use-theme": new So({ type: "string", default: "default", "property-type": "data-driven" }) })) }, e22, r22, n22);
        }
        shouldRedrape() {
          return this.hasOffscreenPass() && "viewport" === this.paint.get("hillshade-illumination-anchor");
        }
        hasOffscreenPass() {
          return 0 !== this.paint.get("hillshade-exaggeration") && "none" !== this.visibility;
        }
        getProgramIds() {
          return ["hillshade", "hillshadePrepare"];
        }
        getDefaultProgramParams(t22, e22, r22) {
          return { overrideFog: false };
        }
      }, fill: class extends Wo {
        constructor(t22, e22, r22, n22) {
          super(t22, { layout: fp || (fp = new ko({ "fill-sort-key": new So(Eo.layout_fill["fill-sort-key"]), visibility: new Io(Eo.layout_fill.visibility), "fill-elevation-reference": new Io(Eo.layout_fill["fill-elevation-reference"]), "fill-construct-bridge-guard-rail": new So(Eo.layout_fill["fill-construct-bridge-guard-rail"]) })), paint: dp || (dp = new ko({ "fill-antialias": new Io(Eo.paint_fill["fill-antialias"]), "fill-opacity": new So(Eo.paint_fill["fill-opacity"]), "fill-color": new So(Eo.paint_fill["fill-color"]), "fill-outline-color": new So(Eo.paint_fill["fill-outline-color"]), "fill-translate": new Io(Eo.paint_fill["fill-translate"]), "fill-translate-anchor": new Io(Eo.paint_fill["fill-translate-anchor"]), "fill-pattern": new So(Eo.paint_fill["fill-pattern"]), "fill-pattern-cross-fade": new Io(Eo.paint_fill["fill-pattern-cross-fade"]), "fill-emissive-strength": new Io(Eo.paint_fill["fill-emissive-strength"]), "fill-z-offset": new So(Eo.paint_fill["fill-z-offset"]), "fill-bridge-guard-rail-color": new So(Eo.paint_fill["fill-bridge-guard-rail-color"]), "fill-tunnel-structure-color": new So(Eo.paint_fill["fill-tunnel-structure-color"]), "fill-color-use-theme": new So({ type: "string", default: "default", "property-type": "data-driven" }), "fill-outline-color-use-theme": new So({ type: "string", default: "default", "property-type": "data-driven" }), "fill-bridge-guard-rail-color-use-theme": new So({ type: "string", default: "default", "property-type": "data-driven" }), "fill-tunnel-structure-color-use-theme": new So({ type: "string", default: "default", "property-type": "data-driven" }) })) }, e22, r22, n22);
        }
        getProgramIds() {
          const t22 = this.paint.get("fill-pattern"), e22 = t22 && t22.constantOr(1), r22 = [e22 ? "fillPattern" : "fill"];
          return this.paint.get("fill-antialias") && r22.push(e22 && !this.getPaintProperty("fill-outline-color") ? "fillOutlinePattern" : "fillOutline"), r22;
        }
        getDefaultProgramParams(t22, e22, r22) {
          return { config: new Ml(this, { zoom: e22, lut: r22 }), overrideFog: false };
        }
        recalculate(t22, e22) {
          super.recalculate(t22, e22);
          const r22 = this.paint._values["fill-outline-color"];
          "constant" === r22.value.kind && void 0 === r22.value.value && (this.paint._values["fill-outline-color"] = this.paint._values["fill-color"]);
        }
        createBucket(t22) {
          return new pp(t22);
        }
        queryRadius() {
          return Du(this.paint.get("fill-translate"));
        }
        queryIntersectsFeature(t22, e22, r22, n22, i22, s2) {
          return !t22.queryGeometry.isAboveHorizon && bu(Fu(t22.tilespaceGeometry, this.paint.get("fill-translate"), this.paint.get("fill-translate-anchor"), s2.angle, t22.pixelToTileUnitsFactor), n22);
        }
        isTileClipped() {
          return 0 === this.paint.get("fill-z-offset").constantOr(1);
        }
        is3D(t22) {
          if (0 !== this.paint.get("fill-z-offset").constantOr(1)) return true;
          const e22 = this.layout && "none" !== this.layout.get("fill-elevation-reference");
          return null != t22 ? e22 && !t22 : e22;
        }
        hasElevation() {
          return this.layout && "none" !== this.layout.get("fill-elevation-reference");
        }
        hasShadowPass() {
          return this.layout && "none" !== this.layout.get("fill-elevation-reference");
        }
      }, "fill-extrusion": class extends Wo {
        constructor(t22, e22, r22, n22) {
          super(t22, { layout: gf || (gf = new ko({ visibility: new Io(Eo["layout_fill-extrusion"].visibility), "fill-extrusion-edge-radius": new Io(Eo["layout_fill-extrusion"]["fill-extrusion-edge-radius"]) })), paint: xf || (xf = new ko({ "fill-extrusion-opacity": new Io(Eo["paint_fill-extrusion"]["fill-extrusion-opacity"]), "fill-extrusion-color": new So(Eo["paint_fill-extrusion"]["fill-extrusion-color"]), "fill-extrusion-translate": new Io(Eo["paint_fill-extrusion"]["fill-extrusion-translate"]), "fill-extrusion-translate-anchor": new Io(Eo["paint_fill-extrusion"]["fill-extrusion-translate-anchor"]), "fill-extrusion-pattern": new So(Eo["paint_fill-extrusion"]["fill-extrusion-pattern"]), "fill-extrusion-pattern-cross-fade": new Io(Eo["paint_fill-extrusion"]["fill-extrusion-pattern-cross-fade"]), "fill-extrusion-height": new So(Eo["paint_fill-extrusion"]["fill-extrusion-height"]), "fill-extrusion-base": new So(Eo["paint_fill-extrusion"]["fill-extrusion-base"]), "fill-extrusion-height-alignment": new Io(Eo["paint_fill-extrusion"]["fill-extrusion-height-alignment"]), "fill-extrusion-base-alignment": new Io(Eo["paint_fill-extrusion"]["fill-extrusion-base-alignment"]), "fill-extrusion-vertical-gradient": new Io(Eo["paint_fill-extrusion"]["fill-extrusion-vertical-gradient"]), "fill-extrusion-ambient-occlusion-intensity": new Io(Eo["paint_fill-extrusion"]["fill-extrusion-ambient-occlusion-intensity"]), "fill-extrusion-ambient-occlusion-radius": new Io(Eo["paint_fill-extrusion"]["fill-extrusion-ambient-occlusion-radius"]), "fill-extrusion-ambient-occlusion-wall-radius": new Io(Eo["paint_fill-extrusion"]["fill-extrusion-ambient-occlusion-wall-radius"]), "fill-extrusion-ambient-occlusion-ground-radius": new Io(Eo["paint_fill-extrusion"]["fill-extrusion-ambient-occlusion-ground-radius"]), "fill-extrusion-ambient-occlusion-ground-attenuation": new Io(Eo["paint_fill-extrusion"]["fill-extrusion-ambient-occlusion-ground-attenuation"]), "fill-extrusion-flood-light-color": new Io(Eo["paint_fill-extrusion"]["fill-extrusion-flood-light-color"]), "fill-extrusion-flood-light-intensity": new Io(Eo["paint_fill-extrusion"]["fill-extrusion-flood-light-intensity"]), "fill-extrusion-flood-light-wall-radius": new So(Eo["paint_fill-extrusion"]["fill-extrusion-flood-light-wall-radius"]), "fill-extrusion-flood-light-ground-radius": new So(Eo["paint_fill-extrusion"]["fill-extrusion-flood-light-ground-radius"]), "fill-extrusion-flood-light-ground-attenuation": new Io(Eo["paint_fill-extrusion"]["fill-extrusion-flood-light-ground-attenuation"]), "fill-extrusion-vertical-scale": new Io(Eo["paint_fill-extrusion"]["fill-extrusion-vertical-scale"]), "fill-extrusion-rounded-roof": new Io(Eo["paint_fill-extrusion"]["fill-extrusion-rounded-roof"]), "fill-extrusion-cutoff-fade-range": new Io(Eo["paint_fill-extrusion"]["fill-extrusion-cutoff-fade-range"]), "fill-extrusion-emissive-strength": new So(Eo["paint_fill-extrusion"]["fill-extrusion-emissive-strength"]), "fill-extrusion-line-width": new So(Eo["paint_fill-extrusion"]["fill-extrusion-line-width"]), "fill-extrusion-cast-shadows": new Io(Eo["paint_fill-extrusion"]["fill-extrusion-cast-shadows"]), "fill-extrusion-color-use-theme": new So({ type: "string", default: "default", "property-type": "data-driven" }), "fill-extrusion-flood-light-color-use-theme": new So({ type: "string", default: "default", "property-type": "data-driven" }) })) }, e22, r22, n22), this._stats = { numRenderedVerticesInShadowPass: 0, numRenderedVerticesInTransparentPass: 0 };
        }
        createBucket(t22) {
          return new of(t22);
        }
        queryRadius() {
          return Du(this.paint.get("fill-extrusion-translate"));
        }
        is3D(t22) {
          return true;
        }
        hasShadowPass() {
          return this.paint.get("fill-extrusion-cast-shadows");
        }
        cutoffRange() {
          return this.paint.get("fill-extrusion-cutoff-fade-range");
        }
        canCastShadows() {
          return true;
        }
        getProgramIds() {
          return [this.paint.get("fill-extrusion-pattern").constantOr(1) ? "fillExtrusionPattern" : "fillExtrusion"];
        }
        queryIntersectsFeature(t22, e22, r22, n22, i22, s2, o2, a22, l22) {
          const u22 = Lu(this.paint.get("fill-extrusion-translate"), this.paint.get("fill-extrusion-translate-anchor"), s2.angle, t22.pixelToTileUnitsFactor), c22 = this.paint.get("fill-extrusion-height").evaluate(e22, r22), h22 = this.paint.get("fill-extrusion-base").evaluate(e22, r22), p22 = [0, 0], f22 = a22 && s2.elevation, d22 = s2.elevation ? s2.elevation.exaggeration() : 1, m22 = t22.tile.getBucket(this);
          if (f22 && m22 instanceof of) {
            const t3 = m22.centroidVertexArray, e3 = l22 + 1;
            e3 < t3.length && (p22[0] = t3.geta_centroid_pos0(e3), p22[1] = t3.geta_centroid_pos1(e3));
          }
          if (0 === p22[0] && 1 === p22[1]) return false;
          "globe" === s2.projection.name && (n22 = mf([n22], [new bt(0, 0), new bt(Tn, Tn)], t22.tileID.canonical).map((t3) => t3.polygon).flat());
          const y22 = f22 ? a22 : null, [g22, x22] = function(t3, e3, r3, n3, i3, s3, o3, a3, l3, u3, c3) {
            return "globe" === t3.projection.name ? function(t4, e4, r4, n4, i4, s4, o4, a4, l4, u4, c4) {
              const h3 = [], p3 = [], f3 = t4.projection.upVectorScale(c4, t4.center.lat, t4.worldSize).metersToTile, d3 = [0, 0, 0, 1], m3 = [0, 0, 0, 1], y3 = (t5, e5, r5, n5) => {
                t5[0] = e5, t5[1] = r5, t5[2] = n5, t5[3] = 1;
              }, g3 = df();
              r4 > 0 && (r4 += g3), n4 += g3;
              for (const g4 of e4) {
                const e5 = [], x3 = [];
                for (const h4 of g4) {
                  const p4 = h4.x + i4.x, g5 = h4.y + i4.y, v3 = t4.projection.projectTilePoint(p4, g5, c4), b22 = t4.projection.upVector(c4, h4.x, h4.y);
                  let _22 = r4, w22 = n4;
                  if (o4) {
                    const t5 = kf(p4, g5, r4, n4, o4, a4, l4, u4);
                    _22 += t5.base, w22 += t5.top;
                  }
                  0 !== r4 ? y3(d3, v3.x + b22[0] * f3 * _22, v3.y + b22[1] * f3 * _22, v3.z + b22[2] * f3 * _22) : y3(d3, v3.x, v3.y, v3.z), y3(m3, v3.x + b22[0] * f3 * w22, v3.y + b22[1] * f3 * w22, v3.z + b22[2] * f3 * w22), R2(d3, d3, s4), R2(m3, m3, s4), e5.push(new vf(d3[0], d3[1], d3[2])), x3.push(new vf(m3[0], m3[1], m3[2]));
                }
                h3.push(e5), p3.push(x3);
              }
              return [h3, p3];
            }(t3, e3, r3, n3, i3, s3, o3, a3, l3, u3, c3) : o3 ? function(t4, e4, r4, n4, i4, s4, o4, a4, l4) {
              const u4 = [], c4 = [], h3 = [0, 0, 0, 1];
              for (const p3 of t4) {
                const t5 = [], f3 = [];
                for (const u5 of p3) {
                  const c5 = u5.x + n4.x, p4 = u5.y + n4.y, d3 = kf(c5, p4, e4, r4, s4, o4, a4, l4);
                  h3[0] = c5, h3[1] = p4, h3[2] = d3.base, h3[3] = 1, Z(h3, h3, i4), h3[3] = Math.max(h3[3], 1e-5);
                  const m3 = new vf(h3[0] / h3[3], h3[1] / h3[3], h3[2] / h3[3]);
                  h3[0] = c5, h3[1] = p4, h3[2] = d3.top, h3[3] = 1, Z(h3, h3, i4), h3[3] = Math.max(h3[3], 1e-5);
                  const y3 = new vf(h3[0] / h3[3], h3[1] / h3[3], h3[2] / h3[3]);
                  t5.push(m3), f3.push(y3);
                }
                u4.push(t5), c4.push(f3);
              }
              return [u4, c4];
            }(e3, r3, n3, i3, s3, o3, a3, l3, u3) : function(t4, e4, r4, n4, i4) {
              const s4 = [], o4 = [], a4 = i4[8] * e4, l4 = i4[9] * e4, u4 = i4[10] * e4, c4 = i4[11] * e4, h3 = i4[8] * r4, p3 = i4[9] * r4, f3 = i4[10] * r4, d3 = i4[11] * r4;
              for (const e5 of t4) {
                const t5 = [], r5 = [];
                for (const s5 of e5) {
                  const e6 = s5.x + n4.x, o5 = s5.y + n4.y, m3 = i4[0] * e6 + i4[4] * o5 + i4[12], y3 = i4[1] * e6 + i4[5] * o5 + i4[13], g3 = i4[2] * e6 + i4[6] * o5 + i4[14], x3 = i4[3] * e6 + i4[7] * o5 + i4[15], v3 = m3 + a4, b22 = y3 + l4, _22 = g3 + u4, w22 = Math.max(x3 + c4, 1e-5), A22 = m3 + h3, M22 = y3 + p3, I2 = g3 + f3, S2 = Math.max(x3 + d3, 1e-5);
                  t5.push(new vf(v3 / w22, b22 / w22, _22 / w22)), r5.push(new vf(A22 / S2, M22 / S2, I2 / S2));
                }
                s4.push(t5), o4.push(r5);
              }
              return [s4, o4];
            }(e3, r3, n3, i3, s3);
          }(s2, n22, h22, c22, u22, o2, y22, p22, d22, s2.center.lat, t22.tileID.canonical), v22 = t22.queryGeometry;
          return function(t3, e3, r3) {
            let n3 = 1 / 0;
            bu(r3, e3) && (n3 = zf(r3, e3[0]));
            for (let i3 = 0; i3 < e3.length; i3++) {
              const s3 = e3[i3], o3 = t3[i3];
              for (let t4 = 0; t4 < s3.length - 1; t4++) {
                const e4 = s3[t4], i4 = [e4, s3[t4 + 1], o3[t4 + 1], o3[t4], e4];
                xu(r3, i4) && (n3 = Math.min(n3, zf(r3, i4)));
              }
            }
            return n3 !== 1 / 0 && n3;
          }(g22, x22, v22.isPointQuery() ? v22.screenBounds : v22.screenGeometry);
        }
      }, line: class extends Wo {
        constructor(t22, e22, r22, n22) {
          const i22 = Kf();
          super(t22, i22, e22, r22, n22), i22.layout && (this.layout = new Mo(i22.layout)), this.gradientVersion = 0, this.hasElevatedBuckets = false, this.hasNonElevatedBuckets = false;
        }
        _handleSpecialPaintPropertyUpdate(t22) {
          if ("line-gradient" === t22) {
            const t3 = this._transitionablePaint._values["line-gradient"].value.expression;
            this.stepInterpolant = t3._styleExpression && t3._styleExpression.expression instanceof bi, this.gradientVersion = (this.gradientVersion + 1) % Number.MAX_SAFE_INTEGER;
          }
        }
        gradientExpression() {
          return this._transitionablePaint._values["line-gradient"].value.expression;
        }
        widthExpression() {
          return this._transitionablePaint._values["line-width"].value.expression;
        }
        recalculate(t22, e22) {
          super.recalculate(t22, e22), this.paint._values["line-floorwidth"] = (() => {
            if (Qf) return Qf;
            const t3 = Kf();
            return Qf = new Jf(t3.paint.properties["line-width"].specification), Qf.useIntegerZoom = true, Qf;
          })().possiblyEvaluate(this._transitioningPaint._values["line-width"].value, t22);
        }
        createBucket(t22) {
          return new Uf(t22);
        }
        getProgramIds() {
          return [this.paint.get("line-pattern").constantOr(1) ? "linePattern" : "line"];
        }
        getDefaultProgramParams(t22, e22, r22) {
          const n22 = Zf(this);
          return { config: new Ml(this, { zoom: e22, lut: r22 }), defines: n22, overrideFog: false };
        }
        queryRadius(t22) {
          const e22 = t22, r22 = td(Cu("line-width", this, e22), Cu("line-gap-width", this, e22)), n22 = Cu("line-offset", this, e22);
          return r22 / 2 + Math.abs(n22) + Du(this.paint.get("line-translate"));
        }
        queryIntersectsFeature(t22, e22, r22, n22, i22, s2) {
          if (t22.queryGeometry.isAboveHorizon) return false;
          const o2 = Fu(t22.tilespaceGeometry, this.paint.get("line-translate"), this.paint.get("line-translate-anchor"), s2.angle, t22.pixelToTileUnitsFactor), a22 = t22.pixelToTileUnitsFactor / 2 * td(this.paint.get("line-width").evaluate(e22, r22), this.paint.get("line-gap-width").evaluate(e22, r22)), l22 = this.paint.get("line-offset").evaluate(e22, r22);
          return l22 && (n22 = function(t3, e3) {
            const r3 = [], n3 = new bt(0, 0);
            for (let i3 = 0; i3 < t3.length; i3++) {
              const s3 = t3[i3], o3 = [];
              for (let t4 = 0; t4 < s3.length; t4++) {
                const r4 = s3[t4], i4 = s3[t4 + 1], a3 = 0 === t4 ? n3 : r4.sub(s3[t4 - 1])._unit()._perp(), l3 = t4 === s3.length - 1 ? n3 : i4.sub(r4)._unit()._perp(), u22 = a3._add(l3)._unit();
                u22._mult(1 / (u22.x * l3.x + u22.y * l3.y)), o3.push(u22._mult(e3)._add(r4));
              }
              r3.push(o3);
            }
            return r3;
          }(n22, l22 * t22.pixelToTileUnitsFactor)), function(t3, e3, r3) {
            for (let n3 = 0; n3 < e3.length; n3++) {
              const i3 = e3[n3];
              if (t3.length >= 3) {
                for (let e4 = 0; e4 < i3.length; e4++) if (Eu(t3, i3[e4])) return true;
              }
              if (_u(t3, i3, r3)) return true;
            }
            return false;
          }(o2, n22, a22);
        }
        isTileClipped() {
          return this.hasNonElevatedBuckets;
        }
        isDraped(t22) {
          return !this.hasElevatedBuckets;
        }
        hasElevation() {
          return this.layout && "none" !== this.layout.get("line-elevation-reference");
        }
      }, symbol: Ty, background: class extends Wo {
        constructor(t22, e22, r22, n22) {
          super(t22, { layout: By || (By = new ko({ visibility: new Io(Eo.layout_background.visibility) })), paint: Vy || (Vy = new ko({ "background-pitch-alignment": new Io(Eo.paint_background["background-pitch-alignment"]), "background-color": new Io(Eo.paint_background["background-color"]), "background-pattern": new Io(Eo.paint_background["background-pattern"]), "background-opacity": new Io(Eo.paint_background["background-opacity"]), "background-emissive-strength": new Io(Eo.paint_background["background-emissive-strength"]), "background-color-use-theme": new So({ type: "string", default: "default", "property-type": "data-driven" }) })) }, e22, r22, n22);
        }
        getProgramIds() {
          return [this.paint.get("background-pattern") ? "backgroundPattern" : "background"];
        }
        getDefaultProgramParams(t22, e22, r22) {
          return { overrideFog: false };
        }
        is3D(t22) {
          return "viewport" === this.paint.get("background-pitch-alignment");
        }
      }, raster: Hy, "raster-particle": Jy, sky: class extends Wo {
        constructor(t22, e22, r22, n22) {
          super(t22, { layout: Wy || (Wy = new ko({ visibility: new Io(Eo.layout_sky.visibility) })), paint: Yy || (Yy = new ko({ "sky-type": new Io(Eo.paint_sky["sky-type"]), "sky-atmosphere-sun": new Io(Eo.paint_sky["sky-atmosphere-sun"]), "sky-atmosphere-sun-intensity": new Io(Eo.paint_sky["sky-atmosphere-sun-intensity"]), "sky-gradient-center": new Io(Eo.paint_sky["sky-gradient-center"]), "sky-gradient-radius": new Io(Eo.paint_sky["sky-gradient-radius"]), "sky-gradient": new zo(Eo.paint_sky["sky-gradient"]), "sky-atmosphere-halo-color": new Io(Eo.paint_sky["sky-atmosphere-halo-color"]), "sky-atmosphere-color": new Io(Eo.paint_sky["sky-atmosphere-color"]), "sky-opacity": new Io(Eo.paint_sky["sky-opacity"]), "sky-gradient-use-theme": new So({ type: "string", default: "default", "property-type": "data-driven" }), "sky-atmosphere-halo-color-use-theme": new So({ type: "string", default: "default", "property-type": "data-driven" }), "sky-atmosphere-color-use-theme": new So({ type: "string", default: "default", "property-type": "data-driven" }) })) }, e22, r22, n22), this._updateColorRamp();
        }
        _handleSpecialPaintPropertyUpdate(t22) {
          "sky-gradient" === t22 ? this._updateColorRamp() : "sky-atmosphere-sun" !== t22 && "sky-atmosphere-halo-color" !== t22 && "sky-atmosphere-color" !== t22 && "sky-atmosphere-sun-intensity" !== t22 || (this._skyboxInvalidated = true);
        }
        _updateColorRamp() {
          this.colorRamp = Zc({ expression: this._transitionablePaint._values["sky-gradient"].value.expression, evaluationKey: "skyRadialProgress" }), this.colorRampTexture && (this.colorRampTexture.destroy(), this.colorRampTexture = null);
        }
        needsSkyboxCapture(t22) {
          if (this._skyboxInvalidated || !this.skyboxTexture || !this.skyboxGeometry) return true;
          if (!this.paint.get("sky-atmosphere-sun")) {
            const e22 = t22.style.light.properties.get("position");
            return this._lightPosition.azimuthal !== e22.azimuthal || this._lightPosition.polar !== e22.polar;
          }
          return false;
        }
        getCenter(t22, e22) {
          if ("atmosphere" === this.paint.get("sky-type")) {
            const r3 = this.paint.get("sky-atmosphere-sun"), n22 = !r3, i22 = t22.style.light, s2 = i22.properties.get("position");
            return n22 && "viewport" === i22.properties.get("anchor") && $t2("The sun direction is attached to a light with viewport anchor, lighting may behave unexpectedly."), n22 ? tg(s2.azimuthal, 90 - s2.polar, e22) : tg(r3[0], 90 - r3[1], e22);
          }
          const r22 = this.paint.get("sky-gradient-center");
          return tg(r22[0], 90 - r22[1], e22);
        }
        isSky() {
          return true;
        }
        markSkyboxValid(t22) {
          this._skyboxInvalidated = false, this._lightPosition = t22.style.light.properties.get("position");
        }
        hasOffscreenPass() {
          return true;
        }
        getProgramIds() {
          const t22 = this.paint.get("sky-type");
          return "atmosphere" === t22 ? ["skyboxCapture", "skybox"] : "gradient" === t22 ? ["skyboxGradient"] : null;
        }
      }, slot: class extends Wo {
        constructor(t22, e22, r22, n22) {
          super(t22, { paint: Ky || (Ky = new ko({})) }, e22, null);
        }
      }, model: class extends Wo {
        constructor(t22, e22, r22, n22) {
          super(t22, { layout: Mg || (Mg = new ko({ visibility: new Io(Eo.layout_model.visibility), "model-id": new So(Eo.layout_model["model-id"]) })), paint: Ig || (Ig = new ko({ "model-opacity": new So(Eo.paint_model["model-opacity"]), "model-rotation": new So(Eo.paint_model["model-rotation"]), "model-scale": new So(Eo.paint_model["model-scale"]), "model-translation": new So(Eo.paint_model["model-translation"]), "model-color": new So(Eo.paint_model["model-color"]), "model-color-mix-intensity": new So(Eo.paint_model["model-color-mix-intensity"]), "model-type": new Io(Eo.paint_model["model-type"]), "model-cast-shadows": new Io(Eo.paint_model["model-cast-shadows"]), "model-receive-shadows": new Io(Eo.paint_model["model-receive-shadows"]), "model-ambient-occlusion-intensity": new Io(Eo.paint_model["model-ambient-occlusion-intensity"]), "model-emissive-strength": new So(Eo.paint_model["model-emissive-strength"]), "model-roughness": new So(Eo.paint_model["model-roughness"]), "model-height-based-emissive-strength-multiplier": new So(Eo.paint_model["model-height-based-emissive-strength-multiplier"]), "model-cutoff-fade-range": new Io(Eo.paint_model["model-cutoff-fade-range"]), "model-front-cutoff": new Io(Eo.paint_model["model-front-cutoff"]), "model-color-use-theme": new So({ type: "string", default: "default", "property-type": "data-driven" }) })) }, e22, r22, n22), this._stats = { numRenderedVerticesInShadowPass: 0, numRenderedVerticesInTransparentPass: 0 };
        }
        createBucket(t22) {
          return new Ag(t22);
        }
        getProgramIds() {
          return ["model"];
        }
        is3D(t22) {
          return true;
        }
        hasShadowPass() {
          return true;
        }
        canCastShadows() {
          return true;
        }
        hasLightBeamPass() {
          return true;
        }
        cutoffRange() {
          return this.paint.get("model-cutoff-fade-range");
        }
        queryRadius(t22) {
          return t22 instanceof Ng ? Tn - 1 : 0;
        }
        queryIntersectsFeature(t22, e22, r22, n22, i22, s2) {
          if (!this.modelManager) return false;
          const o2 = this.modelManager, l22 = t22.tile.getBucket(this);
          if (!(l22 && l22 instanceof Ag)) return false;
          for (const r3 in l22.instancesPerModel) {
            const n3 = l22.instancesPerModel[r3], i3 = void 0 !== e22.id ? e22.id : e22.properties && e22.properties.hasOwnProperty("id") ? e22.properties.id : void 0;
            if (n3.idToFeaturesIndex.hasOwnProperty(i3)) {
              const e3 = n3.features[n3.idToFeaturesIndex[i3]], u22 = o2.getModel(r3, this.scope);
              if (!u22) return false;
              let h22 = a2();
              const p22 = new $l(0, 0), f22 = l22.canonical;
              let d22 = Number.MAX_VALUE;
              for (let r4 = 0; r4 < e3.instancedDataCount; ++r4) {
                const i4 = 16 * (e3.instancedDataOffset + r4), o3 = n3.instancedDataArray.float32, a22 = [o3[i4 + 4], o3[i4 + 5], o3[i4 + 6]];
                qg(f22, p22, o3[i4], 0 | o3[i4 + 1]), kg(h22, u22, s2, p22, e3.rotation, e3.scale, a22, false, false, false), "globe" === s2.projection.name && (h22 = ug(h22, s2));
                const l3 = c2([], s2.projMatrix, h22), m22 = t22.queryGeometry, y22 = cg(m22.isPointQuery() ? m22.screenBounds : m22.screenGeometry, s2, l3, u22.aabb);
                null != y22 && (d22 = Math.min(y22, d22));
              }
              return d22 !== Number.MAX_VALUE && d22;
            }
          }
          return false;
        }
        _handleOverridablePaintPropertyUpdate(t22, e22, r22) {
          return !(!this.layout || e22.isDataDriven() || r22.isDataDriven() || "model-color" !== t22 && "model-color-mix-intensity" !== t22 && "model-rotation" !== t22 && "model-scale" !== t22 && "model-translation" !== t22 && "model-emissive-strength" !== t22);
        }
        _isPropertyZoomDependent(t22) {
          const e22 = this._transitionablePaint._values[t22];
          return null != e22 && null != e22.value && null != e22.value.expression && e22.value.expression instanceof Vs;
        }
        isZoomDependent() {
          return this._isPropertyZoomDependent("model-scale") || this._isPropertyZoomDependent("model-rotation") || this._isPropertyZoomDependent("model-translation");
        }
      }, clip: class extends Wo {
        constructor(t22, e22, r22, n22) {
          super(t22, { layout: mp || (mp = new ko({ "clip-layer-types": new Io(Eo.layout_clip["clip-layer-types"]), "clip-layer-scope": new Io(Eo.layout_clip["clip-layer-scope"]) })), paint: yp || (yp = new ko({})) }, e22, r22, n22);
        }
        recalculate(t22, e22) {
          super.recalculate(t22, e22);
        }
        createBucket(t22) {
          return new vp(t22);
        }
        is3D(t22) {
          return true;
        }
      } };
      class Xg {
        constructor(t22) {
          this._callback = t22, this._triggered = false, "undefined" != typeof MessageChannel && (this._channel = new MessageChannel(), this._channel.port2.onmessage = () => {
            this._triggered = false, this._callback();
          });
        }
        trigger() {
          this._triggered || (this._triggered = true, this._channel ? this._channel.port1.postMessage(true) : setTimeout(() => {
            this._triggered = false, this._callback();
          }, 0));
        }
        remove() {
          this._channel = void 0, this._callback = () => {
          };
        }
      }
      class Zg {
        constructor() {
          this.tasks = {}, this.taskQueue = [], Rt(["process"], this), this.invoker = new Xg(this.process), this.nextId = 0;
        }
        add(t22, e22) {
          const r22 = this.nextId++, n22 = function({ type: t3, isSymbolTile: e3, zoom: r3 }) {
            return r3 = r3 || 0, "message" === t3 ? 0 : "maybePrepare" !== t3 || e3 ? "parseTile" !== t3 || e3 ? "parseTile" === t3 && e3 ? 300 - r3 : "maybePrepare" === t3 && e3 ? 400 - r3 : 500 : 200 - r3 : 100 - r3;
          }(e22);
          if (0 === n22) {
            try {
              t22();
            } finally {
            }
            return null;
          }
          return this.tasks[r22] = { fn: t22, metadata: e22, priority: n22, id: r22 }, this.taskQueue.push(r22), this.invoker.trigger(), { cancel: () => {
            delete this.tasks[r22];
          } };
        }
        process() {
          try {
            if (this.taskQueue = this.taskQueue.filter((t3) => !!this.tasks[t3]), !this.taskQueue.length) return;
            const t22 = this.pick();
            if (null === t22) return;
            const e22 = this.tasks[t22];
            if (delete this.tasks[t22], this.taskQueue.length && this.invoker.trigger(), !e22) return;
            e22.fn();
          } finally {
          }
        }
        pick() {
          let t22 = null, e22 = 1 / 0;
          for (let r3 = 0; r3 < this.taskQueue.length; r3++) {
            const n22 = this.tasks[this.taskQueue[r3]];
            n22.priority < e22 && (e22 = n22.priority, t22 = r3);
          }
          if (null === t22) return null;
          const r22 = this.taskQueue[t22];
          return this.taskQueue.splice(t22, 1), r22;
        }
        remove() {
          this.invoker.remove();
        }
      }
      class Wg {
        constructor(t22, e22, r22) {
          this.target = t22, this.parent = e22, this.mapId = r22, this.callbacks = {}, this.cancelCallbacks = {}, Rt(["receive"], this), this.target.addEventListener("message", this.receive, false), this.scheduler = new Zg();
        }
        send(t22, e22, r22, n22, i22 = false, s2) {
          const o2 = Math.round(1e18 * Math.random()).toString(36).substring(0, 10);
          r22 && (r22.metadata = s2, this.callbacks[o2] = r22);
          const a22 = /* @__PURE__ */ new Set();
          return this.target.postMessage({ id: o2, type: t22, hasCallback: !!r22, targetMapId: n22, mustQueue: i22, sourceMapId: this.mapId, data: qs(e22, a22) }, a22), { cancel: () => {
            r22 && delete this.callbacks[o2], this.target.postMessage({ id: o2, type: "<cancel>", targetMapId: n22, sourceMapId: this.mapId });
          } };
        }
        receive(t22) {
          const e22 = t22.data;
          if (!e22) return;
          const r22 = e22.id;
          if (r22 && (!e22.targetMapId || this.mapId === e22.targetMapId)) if ("<cancel>" === e22.type) {
            const t3 = this.cancelCallbacks[r22];
            delete this.cancelCallbacks[r22], t3 && t3.cancel();
          } else if (e22.mustQueue || Xt2(self)) {
            const t3 = this.callbacks[r22], n22 = this.scheduler.add(() => this.processTask(r22, e22), t3 && t3.metadata || { type: "message" });
            n22 && (this.cancelCallbacks[r22] = n22);
          } else this.processTask(r22, e22);
        }
        processTask(t22, e22) {
          if (delete this.cancelCallbacks[t22], "<response>" === e22.type) {
            const r22 = this.callbacks[t22];
            delete this.callbacks[t22], r22 && (e22.error ? r22(Hs(e22.error)) : r22(null, Hs(e22.data)));
          } else {
            const r22 = /* @__PURE__ */ new Set(), n22 = e22.hasCallback ? (e3, n3) => {
              this.target.postMessage({ id: t22, type: "<response>", sourceMapId: this.mapId, error: e3 ? qs(e3) : null, data: qs(n3, r22) }, r22);
            } : () => {
            }, i22 = Hs(e22.data);
            if (this.parent[e22.type]) this.parent[e22.type](e22.sourceMapId, i22, n22);
            else if (this.parent.getWorkerSource) {
              const t3 = e22.type.split("."), { source: r3, scope: s2 } = i22;
              this.parent.getWorkerSource(e22.sourceMapId, t3[0], r3, s2)[t3[1]](i22, n22);
            } else n22(new Error(`Could not find function ${e22.type}`));
          }
        }
        remove() {
          this.scheduler.remove(), this.target.removeEventListener("message", this.receive, false);
        }
      }
      var Yg = { workerUrl: "", workerClass: null, workerParams: void 0 };
      const Kg = "mapboxgl_preloaded_worker_pool";
      class Jg {
        constructor() {
          this.active = {};
        }
        acquire(t22, e22 = Jg.workerCount) {
          if (!this.workers) for (this.workers = []; this.workers.length < e22; ) this.workers.push(null != Yg.workerClass ? new Yg.workerClass() : new self.Worker(Yg.workerUrl, Yg.workerParams));
          return this.active[t22] = true, this.workers.slice();
        }
        release(t22) {
          delete this.active[t22], this.workers && 0 === this.numActive() && (this.workers.forEach((t3) => {
            t3.terminate();
          }), this.workers = null);
        }
        isPreloaded() {
          return !!this.active[Kg];
        }
        numActive() {
          return Object.keys(this.active).length;
        }
      }
      Jg.workerCount = 2;
      class Qg {
        constructor(t22, e22, r22 = "Worker", n22 = Jg.workerCount) {
          this.workerPool = t22, this.actors = [], this.currentActor = 0, this.id = Ft2();
          const i22 = this.workerPool.acquire(this.id, n22);
          for (let t3 = 0; t3 < i22.length; t3++) {
            const n3 = new Qg.Actor(i22[t3], e22, this.id);
            n3.name = `${r22} ${t3}`, this.actors.push(n3);
          }
          this.ready = false, this.broadcast("checkIfReady", null, () => {
            this.ready = true;
          });
        }
        broadcast(t22, e22, r22) {
          Vt2(this.actors, (r3, n22) => {
            r3.send(t22, e22, n22);
          }, r22 = r22 || function() {
          });
        }
        getActor() {
          return this.currentActor = (this.currentActor + 1) % this.actors.length, this.actors[this.currentActor];
        }
        remove() {
          this.actors.forEach((t22) => {
            t22.remove();
          }), this.actors = [], this.workerPool.release(this.id);
        }
      }
      let tx, ex;
      function rx() {
        return tx || (tx = new Jg()), tx;
      }
      Qg.Actor = Wg;
      const nx = new ir(0, 0, 0), ix = { PATH_RULE_UNSPECIFIED: 0, PATH_RULE_NON_ZERO: 1, PATH_RULE_EVEN_ODD: 2 }, sx = { LINE_CAP_UNSPECIFIED: 0, LINE_CAP_BUTT: 1, LINE_CAP_ROUND: 2, LINE_CAP_SQUARE: 3 }, ox = { LINE_JOIN_UNSPECIFIED: 0, LINE_JOIN_MITER: 1, LINE_JOIN_MITER_CLIP: 2, LINE_JOIN_ROUND: 3, LINE_JOIN_BEVEL: 4 }, ax = { PAINT_ORDER_UNSPECIFIED: 0, PAINT_ORDER_FILL_AND_STROKE: 1, PAINT_ORDER_STROKE_AND_FILL: 2 }, lx = { PATH_COMMAND_UNSPECIFIED: 0, PATH_COMMAND_MOVE: 1, PATH_COMMAND_LINE: 2, PATH_COMMAND_QUAD: 3, PATH_COMMAND_CUBIC: 4, PATH_COMMAND_CLOSE: 5 }, ux = { MASK_TYPE_UNSPECIFIED: 0, MASK_TYPE_LUMINANCE: 1, MASK_TYPE_ALPHA: 2 };
      function cx2(t22, e22, r22) {
        1 === t22 && e22.icons.push(function(t3, e3) {
          return function(t4) {
            if (t4.usvg_tree.height || (t4.usvg_tree.height = t4.usvg_tree.width), !t4.metadata) return t4;
            const { metadata: e4 } = t4;
            if (e4.content_area) {
              const { content_area: r3 } = e4;
              null == r3.top && (r3.top = r3.left), null == r3.width && (r3.width = t4.usvg_tree.width), null == r3.height && (r3.height = r3.width);
            }
            return e4.stretch_x && e4.stretch_x.length && hx(e4, "x"), e4.stretch_y && e4.stretch_y.length && hx(e4, "y"), t4;
          }(t3.readFields(px2, { name: void 0 }, e3));
        }(r22, r22.readVarint() + r22.pos));
      }
      function hx(t22, e22) {
        const r22 = [], n22 = t22[`stretch_${e22}`];
        let i22 = null;
        for (let t3 = 0; t3 < n22.length; t3++) null === i22 ? i22 = 0 === r22.length ? n22[0] : r22[r22.length - 1][1] + n22[t3] : (r22.push([i22, i22 + n22[t3]]), i22 = null);
        t22[`stretch_${e22}_areas`] = r22;
      }
      function px2(t22, e22, r22) {
        1 === t22 ? e22.name = r22.readString() : 2 === t22 ? e22.metadata = function(t3, e3) {
          return t3.readFields(fx, { stretch_x: null, stretch_y: null, stretch_x_areas: null, stretch_y_areas: null, variables: [] }, e3);
        }(r22, r22.readVarint() + r22.pos) : 3 === t22 && (e22.usvg_tree = function(t3, e3) {
          return t3.readFields(yx, { width: 20, children: [], linear_gradients: [], radial_gradients: [], clip_paths: [], masks: [] }, e3);
        }(r22, r22.readVarint() + r22.pos), e22.data = "usvg_tree");
      }
      function fx(t22, e22, r22) {
        1 === t22 ? e22.stretch_x = r22.readPackedVarint() : 2 === t22 ? e22.stretch_y = r22.readPackedVarint() : 3 === t22 ? e22.content_area = function(t3, e3) {
          return t3.readFields(dx, { left: 0 }, e3);
        }(r22, r22.readVarint() + r22.pos) : 4 === t22 && e22.variables.push(function(t3, e3) {
          return t3.readFields(mx, { name: void 0 }, e3);
        }(r22, r22.readVarint() + r22.pos));
      }
      function dx(t22, e22, r22) {
        1 === t22 ? e22.left = r22.readVarint() : 2 === t22 ? e22.width = r22.readVarint() : 3 === t22 ? e22.top = r22.readVarint() : 4 === t22 && (e22.height = r22.readVarint());
      }
      function mx(t22, e22, r22) {
        1 === t22 ? e22.name = r22.readString() : 2 === t22 && (e22.rgb_color = Mx(r22.readVarint()), e22.value = "rgb_color");
      }
      function yx(t22, e22, r22) {
        1 === t22 ? e22.width = e22.height = r22.readVarint() : 2 === t22 ? e22.height = r22.readVarint() : 3 === t22 ? e22.children.push(gx(r22, r22.readVarint() + r22.pos)) : 4 === t22 ? e22.linear_gradients.push(function(t3, e3) {
          return t3.readFields(Sx, { spread_method: 1, stops: [], x1: 0, y1: 0, x2: 1, y2: 0 }, e3);
        }(r22, r22.readVarint() + r22.pos)) : 5 === t22 ? e22.radial_gradients.push(function(t3, e3) {
          return t3.readFields(Ex, { spread_method: 1, stops: [], cx: 0.5, cy: 0.5, r: 0.5, fx: 0.5, fy: 0.5, fr: 0 }, e3);
        }(r22, r22.readVarint() + r22.pos)) : 7 === t22 ? e22.clip_paths.push(function(t3, e3) {
          return t3.readFields(Px, { children: [] }, e3);
        }(r22, r22.readVarint() + r22.pos)) : 8 === t22 && e22.masks.push(function(t3, e3) {
          const r3 = t3.readFields(Tx, { left: 0, width: 20, mask_type: ux.MASK_TYPE_LUMINANCE, children: [] }, e3);
          return null == r3.height && (r3.height = r3.width), null == r3.top && (r3.top = r3.left), r3;
        }(r22, r22.readVarint() + r22.pos));
      }
      function gx(t22, e22) {
        return t22.readFields(xx, {}, e22);
      }
      function xx(t22, e22, r22) {
        1 === t22 ? (e22.group = function(t3, e3) {
          return t3.readFields(vx, { opacity: 255, children: [] }, e3);
        }(r22, r22.readVarint() + r22.pos), e22.node = "group") : 2 === t22 && (e22.path = function(t3, e3) {
          return t3.readFields(wx, { paint_order: 1, commands: [], step: 1, diffs: [], rule: ix.PATH_RULE_NON_ZERO }, e3);
        }(r22, r22.readVarint() + r22.pos), e22.node = "path");
      }
      function vx(t22, e22, r22) {
        1 === t22 ? e22.transform = bx(r22, r22.readVarint() + r22.pos) : 2 === t22 ? e22.opacity = r22.readVarint() : 5 === t22 ? e22.clip_path_idx = r22.readVarint() : 6 === t22 ? e22.mask_idx = r22.readVarint() : 7 === t22 && e22.children.push(gx(r22, r22.readVarint() + r22.pos));
      }
      function bx(t22, e22) {
        return t22.readFields(_x, { sx: 1, ky: 0, kx: 0, sy: 1, tx: 0, ty: 0 }, e22);
      }
      function _x(t22, e22, r22) {
        1 === t22 ? e22.sx = r22.readFloat() : 2 === t22 ? e22.ky = r22.readFloat() : 3 === t22 ? e22.kx = r22.readFloat() : 4 === t22 ? e22.sy = r22.readFloat() : 5 === t22 ? e22.tx = r22.readFloat() : 6 === t22 && (e22.ty = r22.readFloat());
      }
      function wx(t22, e22, r22) {
        1 === t22 ? e22.fill = function(t3, e3) {
          return t3.readFields(Ax, { rgb_color: nx, paint: "rgb_color", opacity: 255 }, e3);
        }(r22, r22.readVarint() + r22.pos) : 2 === t22 ? e22.stroke = function(t3, e3) {
          return t3.readFields(Ix, { rgb_color: nx, paint: "rgb_color", dasharray: [], dashoffset: 0, miterlimit: 4, opacity: 255, width: 1, linecap: 1, linejoin: 1 }, e3);
        }(r22, r22.readVarint() + r22.pos) : 3 === t22 ? e22.paint_order = r22.readVarint() : 5 === t22 ? r22.readPackedVarint(e22.commands) : 6 === t22 ? e22.step = r22.readFloat() : 7 === t22 ? r22.readPackedSVarint(e22.diffs) : 8 === t22 && (e22.rule = r22.readVarint());
      }
      function Ax(t22, e22, r22) {
        1 === t22 ? (e22.rgb_color = Mx(r22.readVarint()), e22.paint = "rgb_color") : 2 === t22 ? (e22.linear_gradient_idx = r22.readVarint(), e22.paint = "linear_gradient_idx") : 3 === t22 ? (e22.radial_gradient_idx = r22.readVarint(), e22.paint = "radial_gradient_idx") : 5 === t22 && (e22.opacity = r22.readVarint());
      }
      function Mx(t22) {
        return new ir((t22 >> 16 & 255) / 255, (t22 >> 8 & 255) / 255, (255 & t22) / 255, 1);
      }
      function Ix(t22, e22, r22) {
        1 === t22 ? (e22.rgb_color = Mx(r22.readVarint()), e22.paint = "rgb_color") : 2 === t22 ? (e22.linear_gradient_idx = r22.readVarint(), e22.paint = "linear_gradient_idx") : 3 === t22 ? (e22.radial_gradient_idx = r22.readVarint(), e22.paint = "radial_gradient_idx") : 5 === t22 ? r22.readPackedFloat(e22.dasharray) : 6 === t22 ? e22.dashoffset = r22.readFloat() : 7 === t22 ? e22.miterlimit = r22.readFloat() : 8 === t22 ? e22.opacity = r22.readVarint() : 9 === t22 ? e22.width = r22.readFloat() : 10 === t22 ? e22.linecap = r22.readVarint() : 11 === t22 && (e22.linejoin = r22.readVarint());
      }
      function Sx(t22, e22, r22) {
        1 === t22 ? e22.transform = bx(r22, r22.readVarint() + r22.pos) : 2 === t22 ? e22.spread_method = r22.readVarint() : 3 === t22 ? e22.stops.push(zx(r22, r22.readVarint() + r22.pos)) : 4 === t22 ? e22.x1 = r22.readFloat() : 5 === t22 ? e22.y1 = r22.readFloat() : 6 === t22 ? e22.x2 = r22.readFloat() : 7 === t22 && (e22.y2 = r22.readFloat());
      }
      function zx(t22, e22) {
        return t22.readFields(kx, { offset: 0, opacity: 255, rgb_color: nx }, e22);
      }
      function kx(t22, e22, r22) {
        1 === t22 ? e22.offset = r22.readFloat() : 2 === t22 ? e22.opacity = r22.readVarint() : 3 === t22 && (e22.rgb_color = Mx(r22.readVarint()));
      }
      function Ex(t22, e22, r22) {
        1 === t22 ? e22.transform = bx(r22, r22.readVarint() + r22.pos) : 2 === t22 ? e22.spread_method = r22.readVarint() : 3 === t22 ? e22.stops.push(zx(r22, r22.readVarint() + r22.pos)) : 4 === t22 ? e22.cx = r22.readFloat() : 5 === t22 ? e22.cy = r22.readFloat() : 6 === t22 ? e22.r = r22.readFloat() : 7 === t22 ? e22.fx = r22.readFloat() : 8 === t22 ? e22.fy = r22.readFloat() : 9 === t22 && (e22.fr = r22.readFloat());
      }
      function Px(t22, e22, r22) {
        1 === t22 ? e22.transform = bx(r22, r22.readVarint() + r22.pos) : 2 === t22 ? e22.clip_path_idx = r22.readVarint() : 3 === t22 && e22.children.push(gx(r22, r22.readVarint() + r22.pos));
      }
      function Tx(t22, e22, r22) {
        1 === t22 ? e22.left = e22.top = r22.readFloat() : 2 === t22 ? e22.width = e22.height = r22.readFloat() : 3 === t22 ? e22.top = r22.readFloat() : 4 === t22 ? e22.height = r22.readFloat() : 5 === t22 ? e22.mask_type = r22.readVarint() : 6 === t22 ? e22.mask_idx = r22.readVarint() : 7 === t22 && e22.children.push(gx(r22, r22.readVarint() + r22.pos));
      }
      class Bx {
        static calculate(t22 = {}, e22 = []) {
          const r22 = /* @__PURE__ */ new Map(), n22 = /* @__PURE__ */ new Map();
          if (0 === Object.keys(t22).length) return r22;
          e22.forEach((t3) => {
            n22.set(t3.name, t3.rgb_color || new ir(0, 0, 0));
          });
          for (const [e3, i22] of Object.entries(t22)) n22.has(e3) ? r22.set(n22.get(e3).toStringPremultipliedAlpha(), i22) : console.warn(`Ignoring unknown image variable "${e3}"`);
          return r22;
        }
      }
      function Vx(t22, e22 = 255, r22) {
        const n22 = e22 / 255, i22 = t22.toStringPremultipliedAlpha(), s2 = r22.has(i22) ? r22.get(i22).clone() : t22.clone();
        return s2.a *= n22, s2.toString();
      }
      function Cx(t22, e22) {
        if (!he()) {
          const r22 = document.createElement("canvas");
          return r22.width = t22, r22.height = e22, r22;
        }
        return new OffscreenCanvas(t22, e22);
      }
      function Dx(t22, e22) {
        const r22 = Bx.calculate(e22.params, t22.metadata ? t22.metadata.variables : []), n22 = t22.usvg_tree, i22 = n22.width, s2 = n22.height, o2 = e22.transform ? e22.transform : new DOMMatrix(), a22 = Math.max(1, Math.round(i22 * o2.a)), l22 = Math.max(1, Math.round(s2 * o2.d)), u22 = new DOMMatrix([a22 / i22, 0, 0, l22 / s2, 0, 0]), c22 = Cx(a22, l22).getContext("2d");
        return Fx(c22, u22, n22, n22, r22), c22.getImageData(0, 0, a22, l22);
      }
      function Fx(t22, e22, r22, n22, i22) {
        for (const s2 of n22.children) Lx(t22, e22, r22, s2, i22);
      }
      function Lx(t22, e22, r22, n22, i22) {
        n22.group ? (t22.save(), function(t3, e3, r3, n3, i3) {
          const s2 = null != n3.mask_idx ? r3.masks[n3.mask_idx] : null, o2 = null != n3.clip_path_idx ? r3.clip_paths[n3.clip_path_idx] : null;
          if (n3.transform && (e3 = Hx(n3.transform).preMultiplySelf(e3)), !function(t4, e4, r4) {
            return 255 !== t4.opacity || e4 || r4;
          }(n3, null != o2, null != s2)) return void Fx(t3, e3, r3, n3, i3);
          const a22 = Cx(t3.canvas.width, t3.canvas.height), l22 = a22.getContext("2d");
          Fx(l22, e3, r3, n3, i3), o2 && Gx(l22, e3, r3, o2), s2 && qx(l22, e3, r3, s2, i3), t3.globalAlpha = n3.opacity / 255, t3.drawImage(a22, 0, 0);
        }(t22, e22, r22, n22.group, i22), t22.restore()) : n22.path && (t22.save(), function(t3, e3, r3, n3, i3) {
          const s2 = Xx(n3);
          t3.setTransform(e3), n3.paint_order === ax.PAINT_ORDER_FILL_AND_STROKE ? (Rx(t3, r3, n3, s2, i3), Ux(t3, r3, n3, s2, i3)) : (Ux(t3, r3, n3, s2, i3), Rx(t3, r3, n3, s2, i3));
        }(t22, e22, r22, n22.path, i22), t22.restore());
      }
      function Rx(t22, e22, r22, n22, i22) {
        const s2 = r22.fill;
        if (!s2) return;
        const o2 = s2.opacity / 255;
        switch (s2.paint) {
          case "rgb_color":
            t22.fillStyle = Vx(s2.rgb_color, s2.opacity, i22);
            break;
          case "linear_gradient_idx":
            t22.fillStyle = Nx(t22, e22.linear_gradients[s2.linear_gradient_idx], o2, i22);
            break;
          case "radial_gradient_idx":
            t22.fillStyle = jx(t22, e22.radial_gradients[s2.radial_gradient_idx], o2, i22);
        }
        t22.fill(n22, Ox(r22));
      }
      function Ox(t22) {
        return t22.rule === ix.PATH_RULE_NON_ZERO ? "nonzero" : t22.rule === ix.PATH_RULE_EVEN_ODD ? "evenodd" : void 0;
      }
      function Ux(t22, e22, r22, n22, i22) {
        const s2 = r22.stroke;
        if (!s2) return;
        t22.lineWidth = s2.width, t22.miterLimit = s2.miterlimit, t22.setLineDash(s2.dasharray), t22.lineDashOffset = s2.dashoffset;
        const o2 = s2.opacity / 255;
        switch (s2.paint) {
          case "rgb_color":
            t22.strokeStyle = Vx(s2.rgb_color, s2.opacity, i22);
            break;
          case "linear_gradient_idx":
            t22.strokeStyle = Nx(t22, e22.linear_gradients[s2.linear_gradient_idx], o2, i22);
            break;
          case "radial_gradient_idx":
            t22.strokeStyle = jx(t22, e22.radial_gradients[s2.radial_gradient_idx], o2, i22);
        }
        switch (s2.linejoin) {
          case ox.LINE_JOIN_MITER_CLIP:
          case ox.LINE_JOIN_MITER:
            t22.lineJoin = "miter";
            break;
          case ox.LINE_JOIN_ROUND:
            t22.lineJoin = "round";
            break;
          case ox.LINE_JOIN_BEVEL:
            t22.lineJoin = "bevel";
        }
        switch (s2.linecap) {
          case sx.LINE_CAP_BUTT:
            t22.lineCap = "butt";
            break;
          case sx.LINE_CAP_ROUND:
            t22.lineCap = "round";
            break;
          case sx.LINE_CAP_SQUARE:
            t22.lineCap = "square";
        }
        t22.stroke(n22);
      }
      function Nx(t22, e22, r22, n22) {
        if (1 === e22.stops.length) {
          const t3 = e22.stops[0];
          return Vx(t3.rgb_color, t3.opacity * r22, n22);
        }
        const i22 = Hx(e22.transform), { x1: s2, y1: o2, x2: a22, y2: l22 } = e22, u22 = i22.transformPoint(new DOMPoint(s2, o2)), c22 = i22.transformPoint(new DOMPoint(a22, l22)), h22 = t22.createLinearGradient(u22.x, u22.y, c22.x, c22.y);
        for (const t3 of e22.stops) h22.addColorStop(t3.offset, Vx(t3.rgb_color, t3.opacity * r22, n22));
        return h22;
      }
      function jx(t22, e22, r22, n22) {
        if (1 === e22.stops.length) {
          const t3 = e22.stops[0];
          return Vx(t3.rgb_color, t3.opacity * r22, n22);
        }
        const i22 = Hx(e22.transform), { fx: s2, fy: o2, cx: a22, cy: l22 } = e22, u22 = i22.transformPoint(new DOMPoint(s2, o2)), c22 = i22.transformPoint(new DOMPoint(a22, l22)), h22 = t22.createRadialGradient(u22.x, u22.y, 0, c22.x, c22.y, e22.r * ((i22.a + i22.d) / 2));
        for (const t3 of e22.stops) h22.addColorStop(t3.offset, Vx(t3.rgb_color, t3.opacity * r22, n22));
        return h22;
      }
      function $x(t22, e22, r22, n22) {
        const i22 = n22.transform ? Hx(n22.transform).preMultiplySelf(e22) : e22, s2 = Cx(t22.canvas.width, t22.canvas.height), o2 = s2.getContext("2d");
        for (const t3 of n22.children) if (t3.group) $x(o2, i22, r22, t3.group);
        else if (t3.path) {
          const e3 = t3.path, r3 = new Path2D();
          r3.addPath(Xx(e3), i22), o2.fill(r3, Ox(e3));
        }
        const a22 = null != n22.clip_path_idx ? r22.clip_paths[n22.clip_path_idx] : null;
        a22 && Gx(o2, i22, r22, a22), t22.globalCompositeOperation = "source-over", t22.drawImage(s2, 0, 0);
      }
      function Gx(t22, e22, r22, n22) {
        const i22 = Cx(t22.canvas.width, t22.canvas.height);
        $x(i22.getContext("2d"), e22, r22, n22), t22.globalCompositeOperation = "destination-in", t22.drawImage(i22, 0, 0);
      }
      function qx(t22, e22, r22, n22, i22) {
        if (0 === n22.children.length) return;
        const s2 = null != n22.mask_idx ? r22.masks[n22.mask_idx] : null;
        s2 && qx(t22, e22, r22, s2, i22);
        const o2 = t22.canvas.width, a22 = t22.canvas.height, l22 = Cx(o2, a22), u22 = l22.getContext("2d"), c22 = n22.width, h22 = n22.height, p22 = n22.left, f22 = n22.top, d22 = new Path2D(), m22 = new Path2D();
        m22.rect(p22, f22, c22, h22), d22.addPath(m22, e22), u22.clip(d22);
        for (const t3 of n22.children) Lx(u22, e22, r22, t3, i22);
        const y22 = u22.getImageData(0, 0, o2, a22), g22 = y22.data;
        if (n22.mask_type === ux.MASK_TYPE_LUMINANCE) for (let t3 = 0; t3 < g22.length; t3 += 4) g22[t3 + 3] = g22[t3 + 3] / 255 * (0.2126 * g22[t3] + 0.7152 * g22[t3 + 1] + 0.0722 * g22[t3 + 2]);
        u22.putImageData(y22, 0, 0), t22.globalCompositeOperation = "destination-in", t22.drawImage(l22, 0, 0);
      }
      function Hx(t22) {
        return t22 ? new DOMMatrix([t22.sx, t22.ky, t22.kx, t22.sy, t22.tx, t22.ty]) : new DOMMatrix();
      }
      function Xx(t22) {
        const e22 = new Path2D(), r22 = t22.step;
        let n22 = t22.diffs[0] * r22, i22 = t22.diffs[1] * r22;
        e22.moveTo(n22, i22);
        for (let s2 = 0, o2 = 2; s2 < t22.commands.length; s2++) switch (t22.commands[s2]) {
          case lx.PATH_COMMAND_MOVE:
            n22 += t22.diffs[o2++] * r22, i22 += t22.diffs[o2++] * r22, e22.moveTo(n22, i22);
            break;
          case lx.PATH_COMMAND_LINE:
            n22 += t22.diffs[o2++] * r22, i22 += t22.diffs[o2++] * r22, e22.lineTo(n22, i22);
            break;
          case lx.PATH_COMMAND_QUAD: {
            const s3 = n22 + t22.diffs[o2++] * r22, a22 = i22 + t22.diffs[o2++] * r22;
            n22 = s3 + t22.diffs[o2++] * r22, i22 = a22 + t22.diffs[o2++] * r22, e22.quadraticCurveTo(s3, a22, n22, i22);
            break;
          }
          case lx.PATH_COMMAND_CUBIC: {
            const s3 = n22 + t22.diffs[o2++] * r22, a22 = i22 + t22.diffs[o2++] * r22, l22 = s3 + t22.diffs[o2++] * r22, u22 = a22 + t22.diffs[o2++] * r22;
            n22 = l22 + t22.diffs[o2++] * r22, i22 = u22 + t22.diffs[o2++] * r22, e22.bezierCurveTo(s3, a22, l22, u22, n22, i22);
            break;
          }
          case lx.PATH_COMMAND_CLOSE:
            e22.closePath();
        }
        return e22;
      }
      class Zx {
        constructor(t22) {
          this.capacity = t22, this.cache = /* @__PURE__ */ new Map();
        }
        get(t22) {
          if (!this.cache.has(t22)) return;
          const e22 = this.cache.get(t22);
          return this.cache.delete(t22), this.cache.set(t22, e22), e22;
        }
        put(t22, e22) {
          this.cache.has(t22) ? this.cache.delete(t22) : this.cache.size === this.capacity && this.cache.delete(this.cache.keys().next().value), this.cache.set(t22, e22);
        }
        delete(t22) {
          this.cache.delete(t22);
        }
      }
      js(Zx, "LRUCache");
      class Wx {
        constructor() {
          this.cacheMap = /* @__PURE__ */ new Map(), this.cacheDependenciesMap = /* @__PURE__ */ new Map();
        }
        static _getImage(t22) {
          return new Hc(t22, t22.data);
        }
        getFromCache(t22, e22, r22) {
          return this.cacheMap.has(r22) || this.cacheMap.set(r22, new Zx(150)), this.cacheMap.get(r22).get(Ho(t22.toString(), e22));
        }
        setInCache(t22, e22, r22, n22) {
          this.cacheDependenciesMap.has(n22) || this.cacheDependenciesMap.set(n22, /* @__PURE__ */ new Map()), this.cacheMap.has(n22) || this.cacheMap.set(n22, new Zx(150));
          const i22 = this.cacheDependenciesMap.get(n22), s2 = Ho(t22.id.toString(), r22);
          i22.get(s2) || i22.set(s2, /* @__PURE__ */ new Set());
          const o2 = this.cacheMap.get(n22), a22 = t22.toString();
          i22.get(s2).add(a22), o2.put(Ho(t22.toString(), r22), e22);
        }
        removeImagesFromCacheByIds(t22, e22, r22 = 0) {
          if (!this.cacheMap.has(r22) || !this.cacheDependenciesMap.has(r22)) return;
          const n22 = this.cacheMap.get(r22), i22 = this.cacheDependenciesMap.get(r22);
          for (const r3 of t22) {
            const t3 = Ho(r3.toString(), e22);
            if (i22.has(t3)) {
              for (const e3 of i22.get(t3)) n22.delete(e3);
              i22.delete(t3);
            }
          }
        }
        rasterize(t22, e22, r22, n22, i22 = Dx) {
          const s2 = this.getFromCache(t22, r22, n22);
          if (s2) return s2.clone();
          const o2 = i22(e22.icon, t22.options), a22 = Wx._getImage(o2);
          return this.setInCache(t22, a22, r22, n22), a22.clone();
        }
      }
      class Yx {
        constructor(t22) {
          this.size = t22, this.minimums = [], this.maximums = [], this.leaves = [];
        }
        getElevation(t22, e22) {
          const r22 = this.toIdx(t22, e22);
          return { min: this.minimums[r22], max: this.maximums[r22] };
        }
        isLeaf(t22, e22) {
          return this.leaves[this.toIdx(t22, e22)];
        }
        toIdx(t22, e22) {
          return e22 * this.size + t22;
        }
      }
      function Kx(t22, e22, r22, n22) {
        let i22 = 0, s2 = Number.MAX_VALUE;
        for (let o2 = 0; o2 < 3; o2++) if (Math.abs(n22[o2]) < 1e-15) {
          if (r22[o2] < t22[o2] || r22[o2] > e22[o2]) return null;
        } else {
          const a22 = 1 / n22[o2];
          let l22 = (t22[o2] - r22[o2]) * a22, u22 = (e22[o2] - r22[o2]) * a22;
          if (l22 > u22) {
            const t3 = l22;
            l22 = u22, u22 = t3;
          }
          if (l22 > i22 && (i22 = l22), u22 < s2 && (s2 = u22), i22 > s2) return null;
        }
        return i22;
      }
      function Jx(t22, e22, r22, n22, i22, s2, o2, a22, l22, u22, c22) {
        const h22 = n22 - t22, p22 = i22 - e22, f22 = s2 - r22, d22 = o2 - t22, m22 = a22 - e22, y22 = l22 - r22, g22 = c22[1] * y22 - c22[2] * m22, x22 = c22[2] * d22 - c22[0] * y22, v22 = c22[0] * m22 - c22[1] * d22, b22 = h22 * g22 + p22 * x22 + f22 * v22;
        if (Math.abs(b22) < 1e-15) return null;
        const _22 = 1 / b22, w22 = u22[0] - t22, A22 = u22[1] - e22, M22 = u22[2] - r22, I2 = (w22 * g22 + A22 * x22 + M22 * v22) * _22;
        if (I2 < 0 || I2 > 1) return null;
        const S2 = A22 * f22 - M22 * p22, z22 = M22 * h22 - w22 * f22, k22 = w22 * p22 - A22 * h22, E22 = (c22[0] * S2 + c22[1] * z22 + c22[2] * k22) * _22;
        return E22 < 0 || I2 + E22 > 1 ? null : (d22 * S2 + m22 * z22 + y22 * k22) * _22;
      }
      function Qx(t22, e22, r22) {
        return (t22 - e22) / (r22 - e22);
      }
      function tv2(t22, e22, r22, n22, i22, s2, o2, a22, l22) {
        const u22 = 1 << r22, c22 = s2 - n22, h22 = o2 - i22, p22 = (t22 + 1) / u22 * c22 + n22, f22 = (e22 + 0) / u22 * h22 + i22, d22 = (e22 + 1) / u22 * h22 + i22;
        a22[0] = (t22 + 0) / u22 * c22 + n22, a22[1] = f22, l22[0] = p22, l22[1] = d22;
      }
      class ev {
        constructor(t22) {
          if (this.maximums = [], this.minimums = [], this.leaves = [], this.childOffsets = [], this.nodeCount = 0, this.dem = t22, this._siblingOffset = [[0, 0], [1, 0], [0, 1], [1, 1]], !this.dem) return;
          const e22 = function(t3) {
            const e3 = Math.ceil(Math.log2(t3.dim / 8)), r3 = [];
            let n3 = Math.ceil(Math.pow(2, e3));
            const i22 = 1 / n3, s2 = (t4, e4, r4, n4, i3) => {
              const s3 = n4 ? 1 : 0, o3 = (t4 + 1) * r4 - s3, a3 = e4 * r4, l22 = (e4 + 1) * r4 - s3;
              i3[0] = t4 * r4, i3[1] = a3, i3[2] = o3, i3[3] = l22;
            };
            let o2 = new Yx(n3);
            const a22 = [];
            for (let e4 = 0; e4 < n3 * n3; e4++) {
              s2(e4 % n3, Math.floor(e4 / n3), i22, false, a22);
              const r4 = nv(a22[0], a22[1], t3), l22 = nv(a22[2], a22[1], t3), u22 = nv(a22[2], a22[3], t3), c22 = nv(a22[0], a22[3], t3);
              o2.minimums.push(Math.min(r4, l22, u22, c22)), o2.maximums.push(Math.max(r4, l22, u22, c22)), o2.leaves.push(1);
            }
            for (r3.push(o2), n3 /= 2; n3 >= 1; n3 /= 2) {
              const t4 = r3[r3.length - 1];
              o2 = new Yx(n3);
              for (let e4 = 0; e4 < n3 * n3; e4++) {
                s2(e4 % n3, Math.floor(e4 / n3), 2, true, a22);
                const r4 = t4.getElevation(a22[0], a22[1]), i3 = t4.getElevation(a22[2], a22[1]), l22 = t4.getElevation(a22[2], a22[3]), u22 = t4.getElevation(a22[0], a22[3]), c22 = t4.isLeaf(a22[0], a22[1]), h22 = t4.isLeaf(a22[2], a22[1]), p22 = t4.isLeaf(a22[2], a22[3]), f22 = t4.isLeaf(a22[0], a22[3]), d22 = Math.min(r4.min, i3.min, l22.min, u22.min), m22 = Math.max(r4.max, i3.max, l22.max, u22.max), y22 = c22 && h22 && p22 && f22;
                o2.maximums.push(m22), o2.minimums.push(d22), o2.leaves.push(m22 - d22 <= 5 && y22 ? 1 : 0);
              }
              r3.push(o2);
            }
            return r3;
          }(this.dem), r22 = e22.length - 1, n22 = e22[r22];
          this._addNode(n22.minimums[0], n22.maximums[0], n22.leaves[0]), this._construct(e22, 0, 0, r22, 0);
        }
        raycastRoot(t22, e22, r22, n22, i22, s2, o2 = 1) {
          return Kx([t22, e22, -100], [r22, n22, this.maximums[0] * o2], i22, s2);
        }
        raycast(t22, e22, r22, n22, i22, s2, o2 = 1) {
          if (!this.nodeCount) return null;
          const a22 = this.raycastRoot(t22, e22, r22, n22, i22, s2, o2);
          if (null == a22) return null;
          const l22 = [], u22 = [], c22 = [], h22 = [], p22 = [{ idx: 0, t: a22, nodex: 0, nodey: 0, depth: 0 }];
          for (; p22.length > 0; ) {
            const { idx: a3, t: f22, nodex: d22, nodey: m22, depth: y22 } = p22.pop();
            if (this.leaves[a3]) {
              tv2(d22, m22, y22, t22, e22, r22, n22, c22, h22);
              const a4 = 1 << y22, l3 = (d22 + 0) / a4, u3 = (d22 + 1) / a4, p3 = (m22 + 0) / a4, g3 = (m22 + 1) / a4, x22 = nv(l3, p3, this.dem) * o2, v22 = nv(u3, p3, this.dem) * o2, b22 = nv(u3, g3, this.dem) * o2, _22 = nv(l3, g3, this.dem) * o2, w22 = Jx(c22[0], c22[1], x22, h22[0], c22[1], v22, h22[0], h22[1], b22, i22, s2), A22 = Jx(h22[0], h22[1], b22, c22[0], h22[1], _22, c22[0], c22[1], x22, i22, s2), M22 = Math.min(null !== w22 ? w22 : Number.MAX_VALUE, null !== A22 ? A22 : Number.MAX_VALUE);
              if (M22 !== Number.MAX_VALUE) return M22;
              {
                const t3 = P2([], i22, s2, f22);
                if (rv(x22, v22, _22, b22, Qx(t3[0], c22[0], h22[0]), Qx(t3[1], c22[1], h22[1])) >= t3[2]) return f22;
              }
              continue;
            }
            let g22 = 0;
            for (let p3 = 0; p3 < this._siblingOffset.length; p3++) {
              tv2((d22 << 1) + this._siblingOffset[p3][0], (m22 << 1) + this._siblingOffset[p3][1], y22 + 1, t22, e22, r22, n22, c22, h22), c22[2] = -100, h22[2] = this.maximums[this.childOffsets[a3] + p3] * o2;
              const f3 = Kx(c22, h22, i22, s2);
              if (null != f3) {
                const t3 = f3;
                l22[p3] = t3;
                let e3 = false;
                for (let r3 = 0; r3 < g22 && !e3; r3++) t3 >= l22[u22[r3]] && (u22.splice(r3, 0, p3), e3 = true);
                e3 || (u22[g22] = p3), g22++;
              }
            }
            for (let t3 = 0; t3 < g22; t3++) {
              const e3 = u22[t3];
              p22.push({ idx: this.childOffsets[a3] + e3, t: l22[e3], nodex: (d22 << 1) + this._siblingOffset[e3][0], nodey: (m22 << 1) + this._siblingOffset[e3][1], depth: y22 + 1 });
            }
          }
          return null;
        }
        _addNode(t22, e22, r22) {
          return this.minimums.push(t22), this.maximums.push(e22), this.leaves.push(r22), this.childOffsets.push(0), this.nodeCount++;
        }
        _construct(t22, e22, r22, n22, i22) {
          if (1 === t22[n22].isLeaf(e22, r22)) return;
          this.childOffsets[i22] || (this.childOffsets[i22] = this.nodeCount);
          const s2 = n22 - 1, o2 = t22[s2];
          let a22 = 0, l22 = 0;
          for (let t3 = 0; t3 < this._siblingOffset.length; t3++) {
            const n3 = 2 * e22 + this._siblingOffset[t3][0], i3 = 2 * r22 + this._siblingOffset[t3][1], s3 = o2.getElevation(n3, i3), u22 = o2.isLeaf(n3, i3), c22 = this._addNode(s3.min, s3.max, u22);
            u22 && (a22 |= 1 << t3), l22 || (l22 = c22);
          }
          for (let n3 = 0; n3 < this._siblingOffset.length; n3++) a22 & 1 << n3 || this._construct(t22, 2 * e22 + this._siblingOffset[n3][0], 2 * r22 + this._siblingOffset[n3][1], s2, l22 + n3);
        }
      }
      function rv(t22, e22, r22, n22, i22, s2) {
        return or(or(t22, r22, s2), or(e22, n22, s2), i22);
      }
      function nv(t22, e22, r22) {
        const n22 = r22.dim, i22 = Pt(t22 * n22 - 0.5, 0, n22 - 1), s2 = Pt(e22 * n22 - 0.5, 0, n22 - 1), o2 = Math.floor(i22), a22 = Math.floor(s2), l22 = Math.min(o2 + 1, n22 - 1), u22 = Math.min(a22 + 1, n22 - 1);
        return rv(r22.get(o2, a22), r22.get(l22, a22), r22.get(o2, u22), r22.get(l22, u22), i22 - o2, s2 - a22);
      }
      const iv = { mapbox: [6553.6, 25.6, 0.1, 1e4], terrarium: [256, 1, 1 / 256, 32768] };
      function sv(t22, e22, r22) {
        return (256 * t22 * 256 + 256 * e22 + r22) / 10 - 1e4;
      }
      function ov(t22, e22, r22) {
        return 256 * t22 + e22 + r22 / 256 - 32768;
      }
      class av {
        get tree() {
          return this._tree || this._buildQuadTree(), this._tree;
        }
        constructor(t22, e22, r22, n22 = false) {
          if (this.uid = t22, e22.height !== e22.width) throw new RangeError("DEM tiles must be square");
          if (r22 && "mapbox" !== r22 && "terrarium" !== r22) return void $t2(`"${r22}" is not a valid encoding type. Valid types include "mapbox" and "terrarium".`);
          this.stride = e22.height;
          const i22 = this.dim = e22.height - 2, s2 = new Uint32Array(e22.data.buffer);
          if (this.pixels = new Uint8Array(e22.data.buffer), this.floatView = new Float32Array(e22.data.buffer), this.borderReady = n22, this._modifiedForSources = {}, !n22) {
            for (let t3 = 0; t3 < i22; t3++) s2[this._idx(-1, t3)] = s2[this._idx(0, t3)], s2[this._idx(i22, t3)] = s2[this._idx(i22 - 1, t3)], s2[this._idx(t3, -1)] = s2[this._idx(t3, 0)], s2[this._idx(t3, i22)] = s2[this._idx(t3, i22 - 1)];
            s2[this._idx(-1, -1)] = s2[this._idx(0, 0)], s2[this._idx(i22, -1)] = s2[this._idx(i22 - 1, 0)], s2[this._idx(-1, i22)] = s2[this._idx(0, i22 - 1)], s2[this._idx(i22, i22)] = s2[this._idx(i22 - 1, i22 - 1)];
          }
          const o2 = "terrarium" === r22 ? ov : sv;
          for (let t3 = 0; t3 < s2.length; ++t3) {
            const e3 = 4 * t3;
            this.floatView[t3] = o2(this.pixels[e3], this.pixels[e3 + 1], this.pixels[e3 + 2]);
          }
          this._timestamp = pe.now();
        }
        _buildQuadTree() {
          this._tree = new ev(this);
        }
        get(t22, e22, r22 = false) {
          r22 && (t22 = Pt(t22, -1, this.dim), e22 = Pt(e22, -1, this.dim));
          const n22 = this._idx(t22, e22);
          return this.floatView[n22];
        }
        set(t22, e22, r22) {
          const n22 = this._idx(t22, e22), i22 = this.floatView[n22];
          return this.floatView[n22] = r22, r22 - i22;
        }
        static getUnpackVector(t22) {
          return iv[t22];
        }
        _idx(t22, e22) {
          if (t22 < -1 || t22 >= this.dim + 1 || e22 < -1 || e22 >= this.dim + 1) throw new RangeError("out of range source coordinates for DEM data");
          return (e22 + 1) * this.stride + (t22 + 1);
        }
        static pack(t22, e22) {
          const r22 = [0, 0, 0, 0], n22 = av.getUnpackVector(e22);
          let i22 = Math.floor((t22 + n22[3]) / n22[2]);
          return r22[2] = i22 % 256, i22 = Math.floor(i22 / 256), r22[1] = i22 % 256, i22 = Math.floor(i22 / 256), r22[0] = i22, r22;
        }
        getPixels() {
          return new Xc({ width: this.stride, height: this.stride }, this.pixels);
        }
        backfillBorder(t22, e22, r22) {
          if (this.dim !== t22.dim) throw new Error("dem dimension mismatch");
          let n22 = e22 * this.dim, i22 = e22 * this.dim + this.dim, s2 = r22 * this.dim, o2 = r22 * this.dim + this.dim;
          switch (e22) {
            case -1:
              n22 = i22 - 1;
              break;
            case 1:
              i22 = n22 + 1;
          }
          switch (r22) {
            case -1:
              s2 = o2 - 1;
              break;
            case 1:
              o2 = s2 + 1;
          }
          const a22 = -e22 * this.dim, l22 = -r22 * this.dim;
          for (let e3 = s2; e3 < o2; e3++) for (let r3 = n22; r3 < i22; r3++) {
            const n3 = 4 * this._idx(r3, e3), i3 = 4 * this._idx(r3 + a22, e3 + l22);
            this.pixels[n3 + 0] = t22.pixels[i3 + 0], this.pixels[n3 + 1] = t22.pixels[i3 + 1], this.pixels[n3 + 2] = t22.pixels[i3 + 2], this.pixels[n3 + 3] = t22.pixels[i3 + 3];
          }
        }
        onDeserialize() {
          this._tree && (this._tree.dem = this);
        }
      }
      function lv(t22, e22, r22) {
        1 === t22 ? e22.headerLength = r22.readFixed32() : 2 === t22 ? e22.x = r22.readVarint() : 3 === t22 ? e22.y = r22.readVarint() : 4 === t22 ? e22.z = r22.readVarint() : 5 === t22 && e22.layers.push(function(t3, e3) {
          return t3.readFields(fv, { version: 0, name: "", units: "", tileSize: 0, buffer: 0, pixelFormat: 0, dataIndex: [] }, e3);
        }(r22, r22.readVarint() + r22.pos));
      }
      function uv(t22, e22, r22) {
        1 === t22 ? (e22.delta_filter = function(t3, e3) {
          return t3.readFields(cv, { blockSize: 0 }, e3);
        }(r22, r22.readVarint() + r22.pos), e22.filter = "delta_filter") : 2 === t22 ? (r22.readVarint(), e22.filter = "zigzag_filter") : 3 === t22 ? (r22.readVarint(), e22.filter = "bitshuffle_filter") : 4 === t22 && (r22.readVarint(), e22.filter = "byteshuffle_filter");
      }
      function cv(t22, e22, r22) {
        1 === t22 && (e22.blockSize = r22.readVarint());
      }
      function hv(t22, e22, r22) {
        1 === t22 ? (r22.readVarint(), e22.codec = "gzip_data") : 2 === t22 ? (r22.readVarint(), e22.codec = "jpeg_image") : 3 === t22 ? (r22.readVarint(), e22.codec = "webp_image") : 4 === t22 && (r22.readVarint(), e22.codec = "png_image");
      }
      function pv(t22, e22, r22) {
        let n22 = 0, i22 = 0;
        1 === t22 ? e22.firstByte = r22.readFixed64() : 2 === t22 ? e22.lastByte = r22.readFixed64() : 3 === t22 ? e22.filters.push(function(t3, e3) {
          return t3.readFields(uv, {}, e3);
        }(r22, r22.readVarint() + r22.pos)) : 4 === t22 ? e22.codec = function(t3, e3) {
          return t3.readFields(hv, {}, e3);
        }(r22, r22.readVarint() + r22.pos) : 5 === t22 ? i22 = r22.readFloat() : 6 === t22 ? n22 = r22.readFloat() : 7 === t22 ? e22.bands.push(r22.readString()) : 8 === t22 ? e22.offset = r22.readDouble() : 9 === t22 && (e22.scale = r22.readDouble()), 0 === e22.offset && (e22.offset = i22), 0 === e22.scale && (e22.scale = n22);
      }
      function fv(t22, e22, r22) {
        1 === t22 ? e22.version = r22.readVarint() : 2 === t22 ? e22.name = r22.readString() : 3 === t22 ? e22.units = r22.readString() : 4 === t22 ? e22.tileSize = r22.readVarint() : 5 === t22 ? e22.buffer = r22.readVarint() : 6 === t22 ? e22.pixelFormat = r22.readVarint() : 7 === t22 && e22.dataIndex.push(function(t3, e3) {
          return t3.readFields(pv, { firstByte: 0, lastByte: 0, filters: [], codec: null, offset: 0, scale: 0, bands: [] }, e3);
        }(r22, r22.readVarint() + r22.pos));
      }
      function dv(t22, e22, r22) {
        if (2 === t22) !function(t3, e3, r3) {
          t3.readFields(mv, r3, e3);
        }(r22, r22.readVarint() + r22.pos, e22);
        else if (3 === t22) throw new Error("Not implemented");
      }
      function mv(t22, e22, r22) {
        if (1 === t22) {
          let t3 = 0;
          const n22 = r22.readVarint() + r22.pos;
          for (; r22.pos < n22; ) e22[t3++] = r22.readVarint();
        }
      }
      function yv(t22, e22) {
        if (4 !== e22.length) throw new Error(`Expected data of dimension 4 but got ${e22.length}.`);
        let r22 = e22[3];
        for (let n22 = 2; n22 >= 1; n22--) {
          const i22 = 1 === n22 ? 1 : 0, s2 = 2 === n22 ? 1 : 0;
          for (let n3 = 0; n3 < e22[0]; n3++) {
            const o2 = e22[1] * n3;
            for (let n4 = i22; n4 < e22[1]; n4++) {
              const i3 = e22[2] * (n4 + o2);
              for (let n5 = s2; n5 < e22[2]; n5++) {
                const s3 = e22[3] * (n5 + i3);
                for (let n6 = 0; n6 < e22[3]; n6++) {
                  const e3 = s3 + n6;
                  t22[e3] += t22[e3 - r22];
                }
              }
            }
          }
          r22 *= e22[n22];
        }
        return t22;
      }
      function gv(t22) {
        for (let e22 = 0, r22 = t22.length; e22 < r22; e22++) t22[e22] = t22[e22] >>> 1 ^ -(1 & t22[e22]);
        return t22;
      }
      function xv(t22, e22) {
        switch (e22) {
          case "uint32":
            return t22;
          case "uint16":
            for (let e3 = 0; e3 < t22.length; e3 += 2) {
              const r22 = t22[e3], n22 = t22[e3 + 1];
              t22[e3] = (240 & r22) >> 4 | (61440 & r22) >> 8 | (240 & n22) << 4 | 61440 & n22, t22[e3 + 1] = 15 & r22 | (3840 & r22) >> 4 | (15 & n22) << 8 | (3840 & n22) << 4;
            }
            return t22;
          case "uint8":
            for (let e3 = 0; e3 < t22.length; e3 += 4) {
              const r22 = t22[e3], n22 = t22[e3 + 1], i22 = t22[e3 + 2], s2 = t22[e3 + 3];
              t22[e3 + 0] = (192 & r22) >> 6 | (192 & n22) >> 4 | (192 & i22) >> 2 | 192 & s2, t22[e3 + 1] = (48 & r22) >> 4 | (48 & n22) >> 2 | 48 & i22 | (48 & s2) << 2, t22[e3 + 2] = (12 & r22) >> 2 | 12 & n22 | (12 & i22) << 2 | (12 & s2) << 4, t22[e3 + 3] = 3 & r22 | (3 & n22) << 2 | (3 & i22) << 4 | (3 & s2) << 6;
            }
            return t22;
          default:
            throw new Error(`Invalid pixel format, "${e22}"`);
        }
      }
      js(av, "DEMData"), js(ev, "DemMinMaxQuadTree", { omit: ["dem"] });
      var vv = Uint8Array, bv = Uint16Array, _v = Int32Array, wv = new vv([0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 2, 2, 2, 2, 3, 3, 3, 3, 4, 4, 4, 4, 5, 5, 5, 5, 0, 0, 0, 0]), Av = new vv([0, 0, 0, 0, 1, 1, 2, 2, 3, 3, 4, 4, 5, 5, 6, 6, 7, 7, 8, 8, 9, 9, 10, 10, 11, 11, 12, 12, 13, 13, 0, 0]), Mv = new vv([16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15]), Iv = function(t22, e22) {
        for (var r22 = new bv(31), n22 = 0; n22 < 31; ++n22) r22[n22] = e22 += 1 << t22[n22 - 1];
        var i22 = new _v(r22[30]);
        for (n22 = 1; n22 < 30; ++n22) for (var s2 = r22[n22]; s2 < r22[n22 + 1]; ++s2) i22[s2] = s2 - r22[n22] << 5 | n22;
        return { b: r22, r: i22 };
      }, Sv = Iv(wv, 2), zv = Sv.b, kv = Sv.r;
      zv[28] = 258, kv[258] = 28;
      for (var Ev = Iv(Av, 0).b, Pv = new bv(32768), Tv = 0; Tv < 32768; ++Tv) {
        var Bv = (43690 & Tv) >> 1 | (21845 & Tv) << 1;
        Pv[Tv] = ((65280 & (Bv = (61680 & (Bv = (52428 & Bv) >> 2 | (13107 & Bv) << 2)) >> 4 | (3855 & Bv) << 4)) >> 8 | (255 & Bv) << 8) >> 1;
      }
      var Vv = function(t22, e22, r22) {
        for (var n22 = t22.length, i22 = 0, s2 = new bv(e22); i22 < n22; ++i22) t22[i22] && ++s2[t22[i22] - 1];
        var o2, a22 = new bv(e22);
        for (i22 = 1; i22 < e22; ++i22) a22[i22] = a22[i22 - 1] + s2[i22 - 1] << 1;
        o2 = new bv(1 << e22);
        var l22 = 15 - e22;
        for (i22 = 0; i22 < n22; ++i22) if (t22[i22]) for (var u22 = i22 << 4 | t22[i22], c22 = e22 - t22[i22], h22 = a22[t22[i22] - 1]++ << c22, p22 = h22 | (1 << c22) - 1; h22 <= p22; ++h22) o2[Pv[h22] >> l22] = u22;
        return o2;
      }, Cv = new vv(288);
      for (Tv = 0; Tv < 144; ++Tv) Cv[Tv] = 8;
      for (Tv = 144; Tv < 256; ++Tv) Cv[Tv] = 9;
      for (Tv = 256; Tv < 280; ++Tv) Cv[Tv] = 7;
      for (Tv = 280; Tv < 288; ++Tv) Cv[Tv] = 8;
      var Dv = new vv(32);
      for (Tv = 0; Tv < 32; ++Tv) Dv[Tv] = 5;
      var Fv = Vv(Cv, 9), Lv = Vv(Dv, 5), Rv = function(t22) {
        for (var e22 = t22[0], r22 = 1; r22 < t22.length; ++r22) t22[r22] > e22 && (e22 = t22[r22]);
        return e22;
      }, Ov = function(t22, e22, r22) {
        var n22 = e22 / 8 | 0;
        return (t22[n22] | t22[n22 + 1] << 8) >> (7 & e22) & r22;
      }, Uv = function(t22, e22) {
        var r22 = e22 / 8 | 0;
        return (t22[r22] | t22[r22 + 1] << 8 | t22[r22 + 2] << 16) >> (7 & e22);
      }, Nv = ["unexpected EOF", "invalid block type", "invalid length/literal", "invalid distance", "stream finished", "no stream handler", , "no callback", "invalid UTF-8 data", "extra field too long", "date not in range 1980-2099", "filename too long", "stream finishing", "invalid zip data"], jv = function(t22, e22, r22) {
        var n22 = new Error(e22 || Nv[t22]);
        if (n22.code = t22, Error.captureStackTrace && Error.captureStackTrace(n22, jv), !r22) throw n22;
        return n22;
      }, $v = new vv(0), Gv = "undefined" != typeof TextDecoder && new TextDecoder();
      try {
        Gv.decode($v, { stream: true });
      } catch (t22) {
      }
      const qv = { gzip_data: "gzip" };
      class Hv extends Error {
        constructor(t22) {
          super(t22), this.name = "MRTError";
        }
      }
      const Xv = { 0: "uint32", 1: "uint32", 2: "uint16", 3: "uint8" }, Zv = { uint32: 1, uint16: 2, uint8: 4 }, Wv = { uint32: Uint32Array, uint16: Uint16Array, uint8: Uint8Array };
      let Yv;
      class Kv {
        constructor(t22 = 5) {
          this.x = NaN, this.y = NaN, this.z = NaN, this.layers = {}, this._cacheSize = t22;
        }
        getLayer(t22) {
          const e22 = this.layers[t22];
          if (!e22) throw new Hv(`Layer '${t22}' not found`);
          return e22;
        }
        getHeaderLength(t22) {
          const e22 = new Uint8Array(t22), r22 = new DataView(t22);
          if (13 !== e22[0]) throw new Hv("File is not a valid MRT.");
          return r22.getUint32(1, true);
        }
        parseHeader(t22) {
          const e22 = new Uint8Array(t22), r22 = this.getHeaderLength(t22);
          if (e22.length < r22) throw new Hv(`Expected header with length >= ${r22} but got buffer of length ${e22.length}`);
          const n22 = function(t3, e3) {
            return t3.readFields(lv, { headerLength: 0, x: 0, y: 0, z: 0, layers: [] }, void 0);
          }(new Yv(e22.subarray(0, r22)));
          if (!isNaN(this.x) && (this.x !== n22.x || this.y !== n22.y || this.z !== n22.z)) throw new Hv(`Invalid attempt to parse header ${n22.z}/${n22.x}/${n22.y} for tile ${this.z}/${this.x}/${this.y}`);
          this.x = n22.x, this.y = n22.y, this.z = n22.z;
          for (const t3 of n22.layers) this.layers[t3.name] = new Jv(t3, { cacheSize: this._cacheSize });
          return this;
        }
        createDecodingTask(t22) {
          const e22 = [], r22 = this.getLayer(t22.layerName);
          for (let n22 of t22.blockIndices) {
            const i22 = r22.dataIndex[n22], s2 = i22.firstByte - t22.firstByte, o2 = i22.lastByte - t22.firstByte;
            if (r22._blocksInProgress.has(n22)) continue;
            const a22 = { layerName: r22.name, firstByte: s2, lastByte: o2, pixelFormat: r22.pixelFormat, blockIndex: n22, blockShape: [i22.bands.length].concat(r22.bandShape), buffer: r22.buffer, codec: i22.codec.codec, filters: i22.filters.map((t3) => t3.filter) };
            r22._blocksInProgress.add(n22), e22.push(a22);
          }
          return new Qv(e22, () => {
            e22.forEach((t3) => r22._blocksInProgress.delete(t3.blockIndex));
          }, (t3, n22) => {
            if (e22.forEach((t4) => r22._blocksInProgress.delete(t4.blockIndex)), t3) throw t3;
            n22.forEach((t4) => {
              this.getLayer(t4.layerName).processDecodedData(t4);
            });
          });
        }
      }
      class Jv {
        constructor({ version: t22, name: e22, units: r22, tileSize: n22, pixelFormat: i22, buffer: s2, dataIndex: o2 }, a22) {
          if (this.version = t22, 1 !== this.version) throw new Hv(`Cannot parse raster layer encoded with MRT version ${t22}`);
          this.name = e22, this.units = r22, this.tileSize = n22, this.buffer = s2, this.pixelFormat = Xv[i22], this.dataIndex = o2, this.bandShape = [n22 + 2 * s2, n22 + 2 * s2, Zv[this.pixelFormat]], this._decodedBlocks = new Zx(a22 ? a22.cacheSize : 5), this._blocksInProgress = /* @__PURE__ */ new Set();
        }
        get dimension() {
          return Zv[this.pixelFormat];
        }
        get cacheSize() {
          return this._decodedBlocks.capacity;
        }
        getBandList() {
          return this.dataIndex.map(({ bands: t22 }) => t22).flat();
        }
        processDecodedData(t22) {
          const e22 = t22.blockIndex.toString();
          this._decodedBlocks.get(e22) || this._decodedBlocks.put(e22, t22.data);
        }
        getBlockForBand(t22) {
          let e22 = 0;
          switch (typeof t22) {
            case "string":
              for (const [r22, n22] of this.dataIndex.entries()) {
                for (const [i22, s2] of n22.bands.entries()) if (s2 === t22) return { bandIndex: e22 + i22, blockIndex: r22, blockBandIndex: i22 };
                e22 += n22.bands.length;
              }
              break;
            case "number":
              for (const [r22, n22] of this.dataIndex.entries()) {
                if (t22 >= e22 && t22 < e22 + n22.bands.length) return { bandIndex: t22, blockIndex: r22, blockBandIndex: t22 - e22 };
                e22 += n22.bands.length;
              }
              break;
            default:
              throw new Hv(`Invalid band \`${JSON.stringify(t22)}\`. Expected string or integer.`);
          }
          return { blockIndex: -1, blockBandIndex: -1 };
        }
        getDataRange(t22) {
          let e22 = 1 / 0, r22 = -1 / 0;
          const n22 = [], i22 = /* @__PURE__ */ new Set();
          for (const s2 of t22) {
            const { blockIndex: t3 } = this.getBlockForBand(s2);
            if (t3 < 0) throw new Hv(`Invalid band: ${JSON.stringify(s2)}`);
            const o2 = this.dataIndex[t3];
            n22.includes(t3) || n22.push(t3), i22.add(t3), e22 = Math.min(e22, o2.firstByte), r22 = Math.max(r22, o2.lastByte);
          }
          if (i22.size > this.cacheSize) throw new Hv(`Number of blocks to decode (${i22.size}) exceeds cache size (${this.cacheSize}).`);
          return { layerName: this.name, firstByte: e22, lastByte: r22, blockIndices: n22 };
        }
        hasBand(t22) {
          const { blockIndex: e22 } = this.getBlockForBand(t22);
          return e22 >= 0;
        }
        hasDataForBand(t22) {
          const { blockIndex: e22 } = this.getBlockForBand(t22);
          return e22 >= 0 && !!this._decodedBlocks.get(e22.toString());
        }
        getBandView(t22) {
          const { blockIndex: e22, blockBandIndex: r22 } = this.getBlockForBand(t22);
          if (e22 < 0) throw new Hv(`Band not found: ${JSON.stringify(t22)}`);
          const n22 = this._decodedBlocks.get(e22.toString());
          if (!n22) throw new Hv(`Data for band ${JSON.stringify(t22)} of layer "${this.name}" not decoded.`);
          const i22 = this.dataIndex[e22], s2 = this.bandShape.reduce((t3, e3) => t3 * e3, 1), o2 = r22 * s2, a22 = n22.subarray(o2, o2 + s2);
          return { data: a22, bytes: new Uint8Array(a22.buffer).subarray(a22.byteOffset, a22.byteOffset + a22.byteLength), tileSize: this.tileSize, buffer: this.buffer, pixelFormat: this.pixelFormat, dimension: this.dimension, offset: i22.offset, scale: i22.scale };
        }
      }
      Kv.setPbf = function(t22) {
        Yv = t22;
      };
      class Qv {
        constructor(t22, e22, r22) {
          this.tasks = t22, this._onCancel = e22, this._onComplete = r22, this._finalized = false;
        }
        cancel() {
          this._finalized || (this._onCancel(), this._finalized = true);
        }
        complete(t22, e22) {
          this._finalized || (this._onComplete(t22, e22), this._finalized = true);
        }
      }
      Kv.performDecoding = function(t22, e22) {
        const r22 = new Uint8Array(t22);
        return Promise.all(e22.tasks.map((t3) => {
          const { layerName: e3, firstByte: n22, lastByte: i22, pixelFormat: s2, blockShape: o2, blockIndex: a22, filters: l22, codec: u22 } = t3, c22 = r22.subarray(n22, i22 + 1), h22 = new Uint32Array(o2[0] * o2[1] * o2[2]);
          let p22;
          if ("gzip_data" !== u22) throw new Hv(`Unhandled codec: ${u22}`);
          return p22 = function(t4, e4) {
            if (!globalThis.DecompressionStream && "gzip_data" === e4) return Promise.resolve(((s3 = function(t5) {
              31 == t5[0] && 139 == t5[1] && 8 == t5[2] || jv(6, "invalid gzip data");
              var e5 = t5[3], r4 = 10;
              4 & e5 && (r4 += 2 + (t5[10] | t5[11] << 8));
              for (var n4 = (e5 >> 3 & 1) + (e5 >> 4 & 1); n4 > 0; n4 -= !t5[r4++]) ;
              return r4 + (2 & e5);
            }(i3 = t4)) + 8 > i3.length && jv(6, "invalid gzip data"), function(t5, e5, r4, n4) {
              var i4 = t5.length;
              if (!i4 || e5.f && !e5.l) return r4 || new vv(0);
              var s4 = !r4, o4 = s4 || 2 != e5.i, a4 = e5.i;
              s4 && (r4 = new vv(3 * i4));
              var l3, u3, c3 = function(t6) {
                var e6 = r4.length;
                if (t6 > e6) {
                  var n5 = new vv(Math.max(2 * e6, t6));
                  n5.set(r4), r4 = n5;
                }
              }, h3 = e5.f || 0, p3 = e5.p || 0, f22 = e5.b || 0, d22 = e5.l, m22 = e5.d, y22 = e5.m, g22 = e5.n, x22 = 8 * i4;
              do {
                if (!d22) {
                  h3 = Ov(t5, p3, 1);
                  var v22 = Ov(t5, p3 + 1, 3);
                  if (p3 += 3, !v22) {
                    var b22 = t5[(T2 = 4 + ((p3 + 7) / 8 | 0)) - 4] | t5[T2 - 3] << 8, _22 = T2 + b22;
                    if (_22 > i4) {
                      a4 && jv(0);
                      break;
                    }
                    o4 && c3(f22 + b22), r4.set(t5.subarray(T2, _22), f22), e5.b = f22 += b22, e5.p = p3 = 8 * _22, e5.f = h3;
                    continue;
                  }
                  if (1 == v22) d22 = Fv, m22 = Lv, y22 = 9, g22 = 5;
                  else if (2 == v22) {
                    var w22 = Ov(t5, p3, 31) + 257, A22 = Ov(t5, p3 + 10, 15) + 4, M22 = w22 + Ov(t5, p3 + 5, 31) + 1;
                    p3 += 14;
                    for (var I2 = new vv(M22), S2 = new vv(19), z22 = 0; z22 < A22; ++z22) S2[Mv[z22]] = Ov(t5, p3 + 3 * z22, 7);
                    p3 += 3 * A22;
                    var k22 = Rv(S2), E22 = (1 << k22) - 1, P22 = Vv(S2, k22);
                    for (z22 = 0; z22 < M22; ) {
                      var T2, B22 = P22[Ov(t5, p3, E22)];
                      if (p3 += 15 & B22, (T2 = B22 >> 4) < 16) I2[z22++] = T2;
                      else {
                        var V2 = 0, C22 = 0;
                        for (16 == T2 ? (C22 = 3 + Ov(t5, p3, 3), p3 += 2, V2 = I2[z22 - 1]) : 17 == T2 ? (C22 = 3 + Ov(t5, p3, 7), p3 += 3) : 18 == T2 && (C22 = 11 + Ov(t5, p3, 127), p3 += 7); C22--; ) I2[z22++] = V2;
                      }
                    }
                    var D22 = I2.subarray(0, w22), F2 = I2.subarray(w22);
                    y22 = Rv(D22), g22 = Rv(F2), d22 = Vv(D22, y22), m22 = Vv(F2, g22);
                  } else jv(1);
                  if (p3 > x22) {
                    a4 && jv(0);
                    break;
                  }
                }
                o4 && c3(f22 + 131072);
                for (var L22 = (1 << y22) - 1, R22 = (1 << g22) - 1, O2 = p3; ; O2 = p3) {
                  var U22 = (V2 = d22[Uv(t5, p3) & L22]) >> 4;
                  if ((p3 += 15 & V2) > x22) {
                    a4 && jv(0);
                    break;
                  }
                  if (V2 || jv(2), U22 < 256) r4[f22++] = U22;
                  else {
                    if (256 == U22) {
                      O2 = p3, d22 = null;
                      break;
                    }
                    var N22 = U22 - 254;
                    U22 > 264 && (N22 = Ov(t5, p3, (1 << (G2 = wv[z22 = U22 - 257])) - 1) + zv[z22], p3 += G2);
                    var j22 = m22[Uv(t5, p3) & R22], $2 = j22 >> 4;
                    if (j22 || jv(3), p3 += 15 & j22, F2 = Ev[$2], $2 > 3) {
                      var G2 = Av[$2];
                      F2 += Uv(t5, p3) & (1 << G2) - 1, p3 += G2;
                    }
                    if (p3 > x22) {
                      a4 && jv(0);
                      break;
                    }
                    o4 && c3(f22 + 131072);
                    var q22 = f22 + N22;
                    if (f22 < F2) {
                      var H2 = 0 - F2, X22 = Math.min(F2, q22);
                      for (H2 + f22 < 0 && jv(3); f22 < X22; ++f22) r4[f22] = (void 0)[H2 + f22];
                    }
                    for (; f22 < q22; ++f22) r4[f22] = r4[f22 - F2];
                  }
                }
                e5.l = d22, e5.p = O2, e5.b = f22, e5.f = h3, d22 && (h3 = 1, e5.m = y22, e5.d = m22, e5.n = g22);
              } while (!h3);
              return f22 != r4.length && s4 ? (l3 = r4, (null == (u3 = f22) || u3 > l3.length) && (u3 = l3.length), new vv(l3.subarray(0, u3))) : r4.subarray(0, f22);
            }(i3.subarray(s3, -8), { i: 2 }, new vv(((r3 = i3)[(n3 = r3.length) - 4] | r3[n3 - 3] << 8 | r3[n3 - 2] << 16 | r3[n3 - 1] << 24) >>> 0))));
            var r3, n3, i3, s3;
            const o3 = qv[e4];
            if (!o3) throw new Error(`Unhandled codec: ${e4}`);
            const a3 = new globalThis.DecompressionStream(o3);
            return new Response(new Blob([t4]).stream().pipeThrough(a3)).arrayBuffer().then((t5) => new Uint8Array(t5));
          }(c22, u22).then((t4) => (function(t5, e4) {
            t5.readFields(dv, e4);
          }(new Yv(t4), h22), new Wv[s2](h22.buffer))), p22.then((t4) => {
            for (let e4 = l22.length - 1; e4 >= 0; e4--) switch (l22[e4]) {
              case "delta_filter":
                yv(t4, o2);
                break;
              case "zigzag_filter":
                gv(t4);
                break;
              case "bitshuffle_filter":
                xv(t4, s2);
                break;
              default:
                throw new Hv(`Unhandled filter "${l22[e4]}"`);
            }
            return { layerName: e3, blockIndex: a22, data: t4 };
          }).catch((t4) => {
            throw t4;
          });
        }));
      }, js(Qv, "MRTDecodingBatch", { omit: ["_onCancel", "_onComplete"] }), js(Kv, "MapboxRasterTile"), js(Jv, "MapboxRasterLayer", { omit: ["_blocksInProgress"] });
      let tb, eb, rb, nb, ib, sb = null;
      function ob() {
        return Xt2(self) && self.worker.dracoUrl ? self.worker.dracoUrl : eb || re.DRACO_URL;
      }
      function ab() {
        if (Xt2(self) && self.worker.meshoptUrl) return self.worker.meshoptUrl;
        if (nb) return nb;
        const t22 = new Uint8Array([0, 97, 115, 109, 1, 0, 0, 0, 1, 4, 1, 96, 0, 0, 3, 3, 2, 0, 0, 5, 3, 1, 0, 1, 12, 1, 0, 10, 22, 2, 12, 0, 65, 0, 65, 0, 65, 0, 252, 10, 0, 0, 11, 7, 0, 65, 0, 253, 15, 26, 11]);
        if ("object" != typeof WebAssembly) throw new Error("WebAssembly not supported, cannot instantiate meshoptimizer");
        return nb = WebAssembly.validate(t22) ? re.MESHOPT_SIMD_URL : re.MESHOPT_URL, nb;
      }
      const lb = { 5120: Int8Array, 5121: Uint8Array, 5122: Int16Array, 5123: Uint16Array, 5125: Uint32Array, 5126: Float32Array }, ub = { 5120: "DT_INT8", 5121: "DT_UINT8", 5122: "DT_INT16", 5123: "DT_UINT16", 5125: "DT_UINT32", 5126: "DT_FLOAT32" }, cb = { SCALAR: 1, VEC2: 2, VEC3: 3, VEC4: 4, MAT2: 4, MAT3: 9, MAT4: 16 };
      function hb(t22, e22, r22) {
        const n22 = r22.json.bufferViews.length, i22 = r22.buffers.length;
        e22.bufferView = n22, r22.json.bufferViews[n22] = { buffer: i22, byteLength: t22.byteLength }, r22.buffers[i22] = t22;
      }
      const pb = "KHR_draco_mesh_compression";
      function fb(t22, e22) {
        const r22 = t22.extensions && t22.extensions[pb];
        if (!r22) return;
        const n22 = new rb.Decoder(), i22 = bb(e22, r22.bufferView), s2 = new rb.Mesh();
        if (!n22.DecodeArrayToMesh(i22, i22.byteLength, s2)) throw new Error("Failed to decode Draco mesh");
        const o2 = e22.json.accessors[t22.indices], a22 = lb[o2.componentType], l22 = o2.count * a22.BYTES_PER_ELEMENT, u22 = rb._malloc(l22);
        a22 === Uint16Array ? n22.GetTrianglesUInt16Array(s2, l22, u22) : n22.GetTrianglesUInt32Array(s2, l22, u22), hb(rb.memory.buffer.slice(u22, u22 + l22), o2, e22), rb._free(u22);
        for (const i3 of Object.keys(r22.attributes)) {
          const o3 = n22.GetAttributeByUniqueId(s2, r22.attributes[i3]), a3 = e22.json.accessors[t22.attributes[i3]], l3 = ub[a3.componentType], u3 = a3.count * cb[a3.type] * lb[a3.componentType].BYTES_PER_ELEMENT, c22 = rb._malloc(u3);
          n22.GetAttributeDataArrayForAllPoints(s2, o3, rb[l3], u3, c22), hb(rb.memory.buffer.slice(c22, c22 + u3), a3, e22), rb._free(c22);
        }
        n22.destroy(), s2.destroy(), delete t22.extensions[pb];
      }
      const db = "EXT_meshopt_compression";
      function mb(t22, e22) {
        if (!t22.extensions || !t22.extensions[db]) return;
        const r22 = t22.extensions[db], n22 = new Uint8Array(e22.buffers[r22.buffer], r22.byteOffset || 0, r22.byteLength || 0), i22 = new Uint8Array(r22.count * r22.byteStride);
        ib.decodeGltfBuffer(i22, r22.count, r22.byteStride, n22, r22.mode, r22.filter), t22.buffer = e22.buffers.length, t22.byteOffset = 0, e22.buffers[t22.buffer] = i22.buffer, delete t22.extensions[db];
      }
      const yb = 1179937895, gb = new TextDecoder("utf8");
      function xb(t22, e22) {
        return new URL(t22, e22).href;
      }
      function vb(t22, e22, r22, n22) {
        return fetch(xb(t22.uri, n22)).then((t3) => t3.arrayBuffer()).then((t3) => {
          e22.buffers[r22] = t3;
        });
      }
      function bb(t22, e22) {
        const r22 = t22.json.bufferViews[e22];
        return new Uint8Array(t22.buffers[r22.buffer], r22.byteOffset || 0, r22.byteLength);
      }
      function _b2(t22, e22, r22, n22) {
        if (t22.uri) {
          const i22 = xb(t22.uri, n22);
          return fetch(i22).then((t3) => t3.blob()).then((t3) => createImageBitmap(t3)).then((t3) => {
            e22.images[r22] = t3;
          });
        }
        if (void 0 !== t22.bufferView) {
          const n3 = bb(e22, t22.bufferView), i22 = new Blob([n3], { type: t22.mimeType });
          return createImageBitmap(i22).then((t3) => {
            e22.images[r22] = t3;
          });
        }
      }
      function wb(t22, e22 = 0, r22) {
        const n22 = { json: null, images: [], buffers: [] };
        if (new Uint32Array(t22, e22, 1)[0] === yb) {
          const r3 = new Uint32Array(t22, e22);
          let i3 = 2;
          const s3 = (r3[i3++] >> 2) - 3, o3 = r3[i3++] >> 2;
          if (i3++, n22.json = JSON.parse(gb.decode(r3.subarray(i3, i3 + o3))), i3 += o3, i3 < s3) {
            const s4 = r3[i3++];
            i3++;
            const o4 = e22 + (i3 << 2);
            n22.buffers[0] = t22.slice(o4, o4 + s4);
          }
        } else n22.json = JSON.parse(gb.decode(new Uint8Array(t22, e22)));
        const { buffers: i22, images: s2, meshes: o2, extensionsUsed: a22, bufferViews: l22 } = n22.json;
        let u22 = Promise.resolve();
        if (i22) {
          const t3 = [];
          for (let e3 = 0; e3 < i22.length; e3++) {
            const s3 = i22[e3];
            s3.uri ? t3.push(vb(s3, n22, e3, r22)) : n22.buffers[e3] || (n22.buffers[e3] = null);
          }
          u22 = Promise.all(t3);
        }
        return u22.then(() => {
          const t3 = [], e3 = a22 && a22.includes(pb), i3 = a22 && a22.includes(db);
          if (e3 && t3.push(function() {
            if (!rb) return null != tb ? tb : (tb = function(t4) {
              let e4, r3 = null;
              function n3() {
                e4 = new Uint8Array(r3.buffer);
              }
              function i4() {
                throw new Error("Unexpected Draco error.");
              }
              const s3 = { a: { a: i4, d: function(t5, r4, n4) {
                return e4.copyWithin(t5, r4, r4 + n4);
              }, c: function(t5) {
                const i5 = e4.length, s4 = Math.max(t5 >>> 0, Math.ceil(1.2 * i5)), o3 = Math.ceil((s4 - i5) / 65536);
                try {
                  return r3.grow(o3), n3(), true;
                } catch (t6) {
                  return false;
                }
              }, b: i4 } };
              return (WebAssembly.instantiateStreaming ? WebAssembly.instantiateStreaming(t4, s3) : t4.then((t5) => t5.arrayBuffer()).then((t5) => WebAssembly.instantiate(t5, s3))).then((t5) => {
                const { Rb: i5, Qb: s4, P: o3, T: a3, X: l3, Ja: u3, La: c22, Qa: h22, Va: p22, Wa: f22, eb: d22, jb: m22, f: y22, e: g22, yb: x22, zb: v22, Ab: b22, Bb: _22, Db: w22, Gb: A22 } = t5.instance.exports;
                r3 = g22;
                const M22 = /* @__PURE__ */ (() => {
                  let t6 = 0, r4 = 0, n4 = 0, o4 = 0;
                  return (a4) => {
                    n4 && (i5(o4), i5(t6), r4 += n4, n4 = t6 = 0), t6 || (r4 += 128, t6 = s4(r4));
                    const l4 = a4.length + 7 & -8;
                    let u4 = t6;
                    l4 >= r4 && (n4 = l4, u4 = o4 = s4(l4));
                    for (let t7 = 0; t7 < a4.length; t7++) e4[u4 + t7] = a4[t7];
                    return u4;
                  };
                })();
                return n3(), y22(), { memory: g22, _free: i5, _malloc: s4, Mesh: class {
                  constructor() {
                    this.ptr = o3();
                  }
                  destroy() {
                    a3(this.ptr);
                  }
                }, Decoder: class {
                  constructor() {
                    this.ptr = u3();
                  }
                  destroy() {
                    m22(this.ptr);
                  }
                  DecodeArrayToMesh(t6, e5, r4) {
                    const n4 = M22(t6), i6 = c22(this.ptr, n4, e5, r4.ptr);
                    return !!l3(i6);
                  }
                  GetAttributeByUniqueId(t6, e5) {
                    return { ptr: h22(this.ptr, t6.ptr, e5) };
                  }
                  GetTrianglesUInt16Array(t6, e5, r4) {
                    p22(this.ptr, t6.ptr, e5, r4);
                  }
                  GetTrianglesUInt32Array(t6, e5, r4) {
                    f22(this.ptr, t6.ptr, e5, r4);
                  }
                  GetAttributeDataArrayForAllPoints(t6, e5, r4, n4, i6) {
                    d22(this.ptr, t6.ptr, e5.ptr, r4, n4, i6);
                  }
                }, DT_INT8: x22(), DT_UINT8: v22(), DT_INT16: b22(), DT_UINT16: _22(), DT_UINT32: w22(), DT_FLOAT32: A22() };
              });
            }(fetch(ob())), tb.then((t4) => {
              rb = t4, tb = void 0;
            }));
          }()), i3 && t3.push(function() {
            if (ib) return;
            const t4 = function(t5) {
              let e4;
              const r3 = WebAssembly.instantiateStreaming(t5, {}).then((t6) => {
                e4 = t6.instance, e4.exports.__wasm_call_ctors();
              }), n3 = { NONE: "", OCTAHEDRAL: "meshopt_decodeFilterOct", QUATERNION: "meshopt_decodeFilterQuat", EXPONENTIAL: "meshopt_decodeFilterExp" }, i4 = { ATTRIBUTES: "meshopt_decodeVertexBuffer", TRIANGLES: "meshopt_decodeIndexBuffer", INDICES: "meshopt_decodeIndexSequence" };
              return { ready: r3, supported: true, decodeGltfBuffer(t6, r4, s3, o3, a3, l3) {
                !function(t7, e5, r5, n4, i5, s4, o4) {
                  const a4 = t7.exports.sbrk, l4 = n4 + 3 & -4, u3 = a4(l4 * i5), c22 = a4(s4.length), h22 = new Uint8Array(t7.exports.memory.buffer);
                  h22.set(s4, c22);
                  const p22 = e5(u3, n4, i5, c22, s4.length);
                  if (0 === p22 && o4 && o4(u3, l4, i5), r5.set(h22.subarray(u3, u3 + n4 * i5)), a4(u3 - a4(0)), 0 !== p22) throw new Error(`Malformed buffer data: ${p22}`);
                }(e4, e4.exports[i4[a3]], t6, r4, s3, o3, e4.exports[n3[l3]]);
              } };
            }(fetch(ab()));
            return t4.ready.then(() => {
              ib = t4;
            });
          }()), s2) for (let e4 = 0; e4 < s2.length; e4++) t3.push(_b2(s2[e4], n22, e4, r22));
          return (t3.length ? Promise.all(t3) : Promise.resolve()).then(() => {
            if (e3 && o2) for (const { primitives: t4 } of o2) for (const e4 of t4) fb(e4, n22);
            if (i3 && o2 && l22) for (const t4 of l22) mb(t4, n22);
            return n22;
          });
        });
      }
      function Ab(t22, e22) {
        const r22 = t22.json.bufferViews[e22.bufferView], n22 = lb[e22.componentType];
        return new n22(t22.buffers[r22.buffer], (e22.byteOffset || 0) + (r22.byteOffset || 0), e22.count * (r22.byteStride && r22.byteStride !== cb[e22.type] * n22.BYTES_PER_ELEMENT ? r22.byteStride / n22.BYTES_PER_ELEMENT : cb[e22.type]));
      }
      function Mb(t22, e22, r22, n22) {
        const i22 = lb[e22.componentType], s2 = function(t3) {
          switch (t3) {
            case Int8Array:
              return 1 / 127;
            case Uint8Array:
              return 1 / 255;
            case Int16Array:
              return 1 / 32767;
            case Uint16Array:
              return 1 / 65535;
            default:
              return 1;
          }
        }(i22), o2 = t22.json.bufferViews[e22.bufferView], a22 = o2.byteStride ? o2.byteStride / i22.BYTES_PER_ELEMENT : cb[e22.type], l22 = r22.float32, u22 = l22.length / r22.capacity;
        for (let t3 = 0, r3 = 0; t3 < e22.count * a22; t3 += a22, r3 += u22) for (let e3 = 0; e3 < u22; e3++) l22[r3 + e3] = n22[t3 + e3] * s2;
        r22._trim();
      }
      function Ib(t22, e22, r22) {
        const n22 = t22.indices, i22 = t22.attributes, s2 = {};
        s2.indexArray = new wa();
        const o2 = e22.json.accessors[n22], a22 = o2.count / 3;
        s2.indexArray.reserve(a22);
        const l22 = Ab(e22, o2);
        for (let t3 = 0; t3 < a22; t3++) s2.indexArray.emplaceBack(l22[3 * t3], l22[3 * t3 + 1], l22[3 * t3 + 2]);
        s2.indexArray._trim(), s2.vertexArray = new ua();
        const u22 = e22.json.accessors[i22.POSITION];
        s2.vertexArray.reserve(u22.count);
        const c22 = Ab(e22, u22);
        for (let t3 = 0; t3 < u22.count; t3++) s2.vertexArray.emplaceBack(c22[3 * t3], c22[3 * t3 + 1], c22[3 * t3 + 2]);
        if (s2.vertexArray._trim(), s2.aabb = new ic(u22.min, u22.max), s2.centroid = function(t3, e3) {
          const r3 = [0, 0, 0], n3 = t3.length;
          if (n3 > 0) {
            for (let i3 = 0; i3 < n3; i3++) {
              const n4 = 3 * t3[i3];
              r3[0] += e3[n4], r3[1] += e3[n4 + 1], r3[2] += e3[n4 + 2];
            }
            r3[0] /= n3, r3[1] /= n3, r3[2] /= n3;
          }
          return r3;
        }(l22, c22), void 0 !== i22.COLOR_0) {
          const t3 = e22.json.accessors[i22.COLOR_0], r3 = cb[t3.type], n3 = Ab(e22, t3);
          s2.colorArray = 3 === r3 ? new ua() : new ma(), s2.colorArray.resize(t3.count), Mb(e22, t3, s2.colorArray, n3);
        }
        if (void 0 !== i22.NORMAL) {
          s2.normalArray = new ua();
          const t3 = e22.json.accessors[i22.NORMAL];
          s2.normalArray.resize(t3.count);
          const r3 = Ab(e22, t3);
          Mb(e22, t3, s2.normalArray, r3);
        }
        if (void 0 !== i22.TEXCOORD_0 && r22.length > 0) {
          s2.texcoordArray = new Ea();
          const t3 = e22.json.accessors[i22.TEXCOORD_0];
          s2.texcoordArray.resize(t3.count);
          const r3 = Ab(e22, t3);
          Mb(e22, t3, s2.texcoordArray, r3);
        }
        if (void 0 !== i22._FEATURE_ID_RGBA4444) {
          const t3 = e22.json.accessors[i22._FEATURE_ID_RGBA4444];
          e22.json.extensionsUsed && e22.json.extensionsUsed.includes("EXT_meshopt_compression") && (s2.featureData = Ab(e22, t3));
        }
        void 0 !== i22._FEATURE_RGBA4444 && (s2.featureData = new Uint32Array(Ab(e22, e22.json.accessors[i22._FEATURE_RGBA4444]).buffer));
        const h22 = t22.material;
        return s2.material = function(t3, e3) {
          const { emissiveFactor: r3 = [0, 0, 0], alphaMode: n3 = "OPAQUE", alphaCutoff: i3 = 0.5, normalTexture: s3, occlusionTexture: o3, emissiveTexture: a3, doubleSided: l3 } = t3, { baseColorFactor: u3 = [1, 1, 1, 1], metallicFactor: c3 = 1, roughnessFactor: h3 = 1, baseColorTexture: p22, metallicRoughnessTexture: f22 } = t3.pbrMetallicRoughness || {}, d22 = o3 ? e3[o3.index] : void 0;
          if (o3 && o3.extensions && o3.extensions.KHR_texture_transform && d22) {
            const t4 = o3.extensions.KHR_texture_transform;
            d22.offsetScale = [t4.offset[0], t4.offset[1], t4.scale[0], t4.scale[1]];
          }
          return { pbrMetallicRoughness: { baseColorFactor: new ir(...u3), metallicFactor: c3, roughnessFactor: h3, baseColorTexture: p22 ? e3[p22.index] : void 0, metallicRoughnessTexture: f22 ? e3[f22.index] : void 0 }, doubleSided: l3, emissiveFactor: r3, alphaMode: n3, alphaCutoff: i3, normalTexture: s3 ? e3[s3.index] : void 0, occlusionTexture: d22, emissionTexture: a3 ? e3[a3.index] : void 0, defined: void 0 === t3.defined };
        }(void 0 !== h22 ? e22.json.materials[h22] : { defined: false }, r22), s2;
      }
      function Sb(t22, e22, r22) {
        const { matrix: n22, rotation: i22, translation: s2, scale: o2, mesh: a22, extras: l22, children: u22 } = t22, c22 = {};
        if (c22.matrix = n22 || function(t3, e3, r3, n3) {
          var i3 = e3[0], s3 = e3[1], o3 = e3[2], a3 = e3[3], l3 = i3 + i3, u3 = s3 + s3, c3 = o3 + o3, h22 = i3 * l3, p22 = i3 * u3, f22 = i3 * c3, d22 = s3 * u3, m22 = s3 * c3, y22 = o3 * c3, g22 = a3 * l3, x22 = a3 * u3, v22 = a3 * c3, b22 = n3[0], _22 = n3[1], w22 = n3[2];
          return t3[0] = (1 - (d22 + y22)) * b22, t3[1] = (p22 + v22) * b22, t3[2] = (f22 - x22) * b22, t3[3] = 0, t3[4] = (p22 - v22) * _22, t3[5] = (1 - (h22 + y22)) * _22, t3[6] = (m22 + g22) * _22, t3[7] = 0, t3[8] = (f22 + x22) * w22, t3[9] = (m22 - g22) * w22, t3[10] = (1 - (h22 + d22)) * w22, t3[11] = 0, t3[12] = r3[0], t3[13] = r3[1], t3[14] = r3[2], t3[15] = 1, t3;
        }([], i22 || [0, 0, 0, 1], s2 || [0, 0, 0], o2 || [1, 1, 1]), void 0 !== a22) {
          c22.meshes = r22[a22];
          const t3 = c22.anchor = [0, 0];
          for (const e3 of c22.meshes) {
            const { min: r3, max: n3 } = e3.aabb;
            t3[0] += r3[0] + n3[0], t3[1] += r3[1] + n3[1];
          }
          t3[0] = Math.floor(t3[0] / c22.meshes.length / 2), t3[1] = Math.floor(t3[1] / c22.meshes.length / 2);
        }
        if (l22 && (l22.id && (c22.id = l22.id), l22.lights && (c22.lights = function(t3) {
          if (!t3.length) return [];
          const e3 = function(t4) {
            const e4 = atob(t4), r4 = new Uint8Array(e4.length);
            for (let t5 = 0; t5 < e4.length; t5++) r4[t5] = e4.codePointAt(t5);
            return r4;
          }(t3), r3 = [], n3 = e3.length / 24, i3 = new Uint16Array(e3.buffer), s3 = new Float32Array(e3.buffer);
          for (let t4 = 0; t4 < n3; t4++) {
            const e4 = i3[2 * t4 * 6] / 30, n4 = i3[2 * t4 * 6 + 1] / 30, o3 = i3[2 * t4 * 6 + 10] / 100, a3 = s3[6 * t4 + 1], l3 = s3[6 * t4 + 2], u3 = s3[6 * t4 + 3], c3 = s3[6 * t4 + 4], h22 = u3 - a3, p22 = c3 - l3, f22 = Math.hypot(h22, p22);
            r3.push({ pos: [a3 + 0.5 * h22, l3 + 0.5 * p22, n4], normal: [p22 / f22, -h22 / f22, 0], width: f22, height: e4, depth: o3, points: [a3, l3, u3, c3] });
          }
          return r3;
        }(l22.lights))), u22) {
          const t3 = [];
          for (const n3 of u22) t3.push(Sb(e22.json.nodes[n3], e22, r22));
          c22.children = t3;
        }
        return c22;
      }
      function zb(t22) {
        if (0 === t22.vertices.length || 0 === t22.indices.length) return null;
        const e22 = new gp(t22.vertices, t22.indices, 8, 256), [r22, n22] = [e22.min.clone(), e22.max.clone()];
        return { vertices: t22.vertices, indices: t22.indices, grid: e22, min: r22, max: n22 };
      }
      function kb(t22) {
        if (!t22.extras || !t22.extras.ground) return null;
        const e22 = t22.extras.ground;
        if (!e22 || !Array.isArray(e22) || 0 === e22.length) return null;
        const r22 = e22[0];
        if (!r22 || !Array.isArray(r22) || 0 === r22.length) return null;
        const n22 = [];
        for (const t3 of r22) {
          if (!Array.isArray(t3) || 2 !== t3.length) continue;
          const e3 = t3[0], r3 = t3[1];
          "number" == typeof e3 && "number" == typeof r3 && n22.push(new bt(e3, r3));
        }
        if (n22.length < 3) return null;
        n22.length > 1 && n22[n22.length - 1].equals(n22[0]) && n22.pop();
        let i22 = 0;
        for (let t3 = 0; t3 < n22.length; t3++) {
          const e3 = n22[t3], r3 = n22[(t3 + 1) % n22.length], s3 = n22[(t3 + 2) % n22.length];
          i22 += (e3.x - r3.x) * (s3.y - r3.y) - (s3.x - r3.x) * (e3.y - r3.y);
        }
        i22 > 0 && n22.reverse();
        const s2 = Qc(n22.flatMap((t3) => [t3.x, t3.y]), []);
        return 0 === s2.length ? null : { vertices: n22, indices: s2 };
      }
      function Eb(t22, e22) {
        const r22 = [], n22 = [];
        let i22 = 0;
        const s2 = [];
        for (const o2 of t22) {
          i22 = r22.length;
          const t3 = o2.vertexArray.float32, a22 = o2.indexArray.uint16;
          for (let n3 = 0; n3 < o2.vertexArray.length; n3++) s2[0] = t3[3 * n3 + 0], s2[1] = t3[3 * n3 + 1], s2[2] = t3[3 * n3 + 2], R2(s2, s2, e22), r22.push(new bt(s2[0], s2[1]));
          for (let t4 = 0; t4 < 3 * o2.indexArray.length; t4++) n22.push(a22[t4] + i22);
        }
        if (n22.length % 3 != 0) return null;
        for (let t3 = 0; t3 < n22.length; t3 += 3) {
          const e3 = r22[n22[t3 + 0]], i3 = r22[n22[t3 + 1]], s3 = r22[n22[t3 + 2]];
          (e3.x - i3.x) * (s3.y - i3.y) - (s3.x - i3.x) * (e3.y - i3.y) > 0 && ([n22[t3 + 1], n22[t3 + 2]] = [n22[t3 + 2], n22[t3 + 1]]);
        }
        return { vertices: r22, indices: n22 };
      }
      function Pb(t22) {
        const e22 = function(t3, e3) {
          const r3 = [], n3 = WebGL2RenderingContext;
          if (t3.json.textures) for (const i3 of t3.json.textures) {
            const s3 = { magFilter: n3.LINEAR, minFilter: n3.NEAREST, wrapS: n3.REPEAT, wrapT: n3.REPEAT };
            void 0 !== i3.sampler && Object.assign(s3, t3.json.samplers[i3.sampler]), r3.push({ image: e3[i3.source], sampler: s3, uploaded: false });
          }
          return r3;
        }(t22, t22.images), r22 = function(t3, e3) {
          const r3 = [];
          for (const n3 of t3.json.meshes) {
            const i3 = [];
            for (const r4 of n3.primitives) i3.push(Ib(r4, t3, e3));
            r3.push(i3);
          }
          return r3;
        }(t22, e22), { scenes: n22, scene: i22, nodes: s2 } = t22.json, o2 = n22 ? n22[i22 || 0].nodes : s2, a22 = [];
        for (const e3 of o2) a22.push(Sb(s2[e3], t22, r22));
        return function(t3, e3, r3) {
          const n3 = {}, i3 = /* @__PURE__ */ new Set();
          for (let s3 = 0; s3 < t3.length; s3++) {
            const t4 = r3[e3[s3]];
            if (!t4.extras) continue;
            const o3 = t4.extras["mapbox:footprint:version"], a3 = t4.extras["mapbox:footprint:id"];
            (o3 || a3) && i3.add(s3), "1.0.0" === o3 && a3 && (n3[a3] = s3);
          }
          for (let s3 = 0; s3 < t3.length; s3++) {
            if (i3.has(s3)) continue;
            const o3 = t3[s3], a3 = r3[e3[s3]];
            if (!a3.extras) continue;
            let l22 = null;
            o3.id in n3 && (l22 = Eb(t3[n3[o3.id]].meshes, o3.matrix)), l22 || (l22 = kb(a3)), l22 && (o3.footprint = zb(l22));
          }
          if (i3.size > 0) {
            const e4 = Array.from(i3.values()).sort((t4, e5) => t4 - e5);
            for (let r4 = e4.length - 1; r4 >= 0; r4--) t3.splice(e4[r4], 1);
          }
        }(a22, o2, t22.json.nodes), a22;
      }
      function Tb(t22) {
        t22.heightmap = new Float32Array(4096), t22.heightmap.fill(-1);
        const e22 = t22.vertexArray.float32, r22 = t22.aabb.min[0] - 1, n22 = t22.aabb.min[1] - 1, i22 = Sg / (t22.aabb.max[0] - r22 + 2), s2 = Sg / (t22.aabb.max[1] - n22 + 2);
        for (let o2 = 0; o2 < e22.length; o2 += 3) {
          const a22 = e22[o2 + 2], l22 = (e22[o2 + 0] - r22) * i22 | 0, u22 = (e22[o2 + 1] - n22) * s2 | 0;
          a22 > t22.heightmap[u22 * Sg + l22] && (t22.heightmap[u22 * Sg + l22] = a22);
        }
      }
      function Bb(t22, e22) {
        const r22 = {};
        r22.indexArray = new wa(), r22.indexArray.reserve(4 * t22.length), r22.vertexArray = new ua(), r22.vertexArray.reserve(10 * t22.length), r22.colorArray = new ma(), r22.vertexArray.reserve(10 * t22.length);
        let n22 = 0;
        for (const i3 of t22) {
          const t3 = Math.min(10, Math.max(4, 1.3 * i3.height)) * e22, s3 = [-i3.normal[1], i3.normal[0], 0], o2 = Math.min(0.29, 0.1 * i3.width / i3.depth), a22 = i3.width - 2 * i3.depth * e22 * (o2 + 0.01), l22 = P2([], i3.pos, s3, a22 / 2), u22 = P2([], i3.pos, s3, -a22 / 2), c22 = [l22[0], l22[1], l22[2] + i3.height], h22 = [u22[0], u22[1], u22[2] + i3.height], p22 = P2([], i3.normal, s3, o2);
          E2(p22, p22, t3);
          const f22 = P2([], i3.normal, s3, -o2);
          E2(f22, f22, t3), M2(p22, l22, p22), M2(f22, u22, f22), l22[2] += 0.1, u22[2] += 0.1, r22.vertexArray.emplaceBack(p22[0], p22[1], p22[2]), r22.vertexArray.emplaceBack(f22[0], f22[1], f22[2]), r22.vertexArray.emplaceBack(l22[0], l22[1], l22[2]), r22.vertexArray.emplaceBack(u22[0], u22[1], u22[2]), r22.vertexArray.emplaceBack(c22[0], c22[1], c22[2]), r22.vertexArray.emplaceBack(h22[0], h22[1], h22[2]), r22.vertexArray.emplaceBack(l22[0], l22[1], l22[2]), r22.vertexArray.emplaceBack(u22[0], u22[1], u22[2]), r22.vertexArray.emplaceBack(p22[0], p22[1], p22[2]), r22.vertexArray.emplaceBack(f22[0], f22[1], f22[2]);
          const d22 = a22 / t3 / 2;
          r22.colorArray.emplaceBack(-d22 - o2, -1, d22, 0.8), r22.colorArray.emplaceBack(d22 + o2, -1, d22, 0.8), r22.colorArray.emplaceBack(-d22, 0, d22, 1.3), r22.colorArray.emplaceBack(d22, 0, d22, 1.3), r22.colorArray.emplaceBack(d22 + o2, -0.8, d22, 0.7), r22.colorArray.emplaceBack(d22 + o2, -0.8, d22, 0.7), r22.colorArray.emplaceBack(0, 0, d22, 1.3), r22.colorArray.emplaceBack(0, 0, d22, 1.3), r22.colorArray.emplaceBack(d22 + o2, -1.2, d22, 0.8), r22.colorArray.emplaceBack(d22 + o2, -1.2, d22, 0.8), r22.indexArray.emplaceBack(6 + n22, 4 + n22, 8 + n22), r22.indexArray.emplaceBack(7 + n22, 9 + n22, 5 + n22), r22.indexArray.emplaceBack(0 + n22, 1 + n22, 2 + n22), r22.indexArray.emplaceBack(1 + n22, 3 + n22, 2 + n22), n22 += 10;
        }
        const i22 = { defined: true, emissiveFactor: [0, 0, 0] }, s2 = {};
        return s2.baseColorFactor = ir.white, i22.pbrMetallicRoughness = s2, r22.material = i22, r22.aabb = new ic([1 / 0, 1 / 0, 1 / 0], [-1 / 0, -1 / 0, -1 / 0]), r22;
      }
      class Vb {
        constructor(t22) {
          this._stringToNumber = {}, this._numberToString = [];
          for (let e22 = 0; e22 < t22.length; e22++) {
            const r22 = t22[e22];
            this._stringToNumber[r22] = e22, this._numberToString[e22] = r22;
          }
        }
        encode(t22) {
          return this._stringToNumber[t22];
        }
        decode(t22) {
          return this._numberToString[t22];
        }
      }
      const Cb = ["id", "tile", "layer", "source", "sourceLayer", "state"];
      class Db {
        constructor(t22, e22, r22, n22, i22) {
          this.type = "Feature", this._vectorTileFeature = t22, this._z = e22, this._x = r22, this._y = n22, this.properties = t22.properties, this.id = i22;
        }
        clone() {
          const t22 = new Db(this._vectorTileFeature, this._z, this._x, this._y, this.id);
          return this.state && (t22.state = Object.assign({}, this.state)), this.layer && (t22.layer = Object.assign({}, this.layer)), this.source && (t22.source = this.source), this.sourceLayer && (t22.sourceLayer = this.sourceLayer), t22;
        }
        get geometry() {
          return void 0 === this._geometry && (this._geometry = this._vectorTileFeature.toGeoJSON(this._x, this._y, this._z).geometry), this._geometry;
        }
        set geometry(t22) {
          this._geometry = t22;
        }
        toJSON() {
          const t22 = { type: "Feature", state: void 0, geometry: this.geometry, properties: this.properties };
          for (const e22 of Cb) void 0 !== this[e22] && (t22[e22] = this[e22]);
          return t22;
        }
      }
      class Fb {
        constructor(t22, e22) {
          this.tileID = t22, this.x = t22.canonical.x, this.y = t22.canonical.y, this.z = t22.canonical.z, this.grid = new Us(Tn, 16, 0), this.featureIndexArray = new qa(), this.promoteId = e22, this.is3DTile = false, this.serializedLayersCache = /* @__PURE__ */ new Map();
        }
        insert(t22, e22, r22, n22, i22, s2 = 0, o2 = 0) {
          const a22 = this.featureIndexArray.length;
          this.featureIndexArray.emplaceBack(r22, n22, i22, s2);
          const l22 = this.grid;
          for (let t3 = 0; t3 < e22.length; t3++) {
            const r3 = e22[t3], n3 = [1 / 0, 1 / 0, -1 / 0, -1 / 0];
            for (let t4 = 0; t4 < r3.length; t4++) {
              const e3 = r3[t4];
              n3[0] = Math.min(n3[0], e3.x), n3[1] = Math.min(n3[1], e3.y), n3[2] = Math.max(n3[2], e3.x), n3[3] = Math.max(n3[3], e3.y);
            }
            0 !== o2 && (n3[0] -= o2, n3[1] -= o2, n3[2] += o2, n3[3] += o2), n3[0] < Tn && n3[1] < Tn && n3[2] >= 0 && n3[3] >= 0 && l22.insert(a22, n3[0], n3[1], n3[2], n3[3]);
          }
        }
        loadVTLayers() {
          if (!this.vtLayers) {
            this.vtLayers = new Nh.VectorTile(new _d2(this.rawTileData)).layers, this.sourceLayerCoder = new Vb(this.vtLayers ? Object.keys(this.vtLayers).sort() : ["_geojsonTileLayer"]), this.vtFeatures = {};
            for (const t22 in this.vtLayers) this.vtFeatures[t22] = [];
          }
          return this.vtLayers;
        }
        query(t22, e22) {
          const { tilespaceGeometry: r22, transform: n22, tileTransform: i22, pixelPosMatrix: s2, availableImages: o2 } = e22;
          this.loadVTLayers(), this.serializedLayersCache.clear();
          const a22 = r22.bufferedTilespaceBounds, l22 = this.grid.query(a22.min.x, a22.min.y, a22.max.x, a22.max.y, (t3, e3, n3, i3) => Pu(r22.bufferedTilespaceGeometry, t3, e3, n3, i3));
          l22.sort(Rb);
          let u22 = null;
          n22.elevation && l22.length > 0 && (u22 = Cg.create(n22.elevation, this.tileID));
          const c22 = {};
          let h22;
          for (let e3 = 0; e3 < l22.length; e3++) {
            const a3 = l22[e3];
            if (a3 === h22) continue;
            h22 = a3;
            const p22 = this.featureIndexArray.get(a3);
            let f22 = null;
            this.is3DTile ? this.loadMatchingModelFeature(c22, p22, t22, r22, n22) : this.loadMatchingFeature(c22, p22, t22, o2, (t3, e4, o3, a4 = 0) => (f22 || (f22 = fu(t3, this.tileID.canonical, i22)), e4.queryIntersectsFeature(r22, t3, o3, f22, this.z, n22, s2, u22, a4)));
          }
          return c22;
        }
        loadMatchingFeature(t22, e22, r22, n22, i22) {
          const { featureIndex: s2, bucketIndex: o2, sourceLayerIndex: a22, layoutVertexArrayOffset: l22 } = e22, u22 = this.bucketLayerIDs[o2], c22 = r22.layers, h22 = Object.keys(c22);
          if (h22.length && !function(t3, e3) {
            for (let r3 = 0; r3 < t3.length; r3++) if (e3.indexOf(t3[r3]) >= 0) return true;
            return false;
          }(h22, u22)) return;
          const p22 = r22.sourceCache, f22 = this.sourceLayerCoder.decode(a22), d22 = this.vtLayers[f22].feature(s2), m22 = this.getId(d22, f22);
          for (let e3 = 0; e3 < u22.length; e3++) {
            const r3 = u22[e3];
            if (!c22[r3]) continue;
            const { styleLayer: o3, targets: a3 } = c22[r3];
            let h3 = {};
            void 0 !== m22 && (h3 = p22.getFeatureState(o3.sourceLayer, m22));
            const f3 = !i22 || i22(d22, o3, h3, l22);
            if (!f3) continue;
            const y22 = new Db(d22, this.z, this.x, this.y, m22);
            y22.tile = this.tileID.canonical, y22.state = h3;
            let g22 = this.serializedLayersCache.get(r3);
            g22 || (g22 = o3.serialize(), g22.id = r3, this.serializedLayersCache.set(r3, g22)), y22.source = g22.source, y22.sourceLayer = g22["source-layer"], y22.layer = Ct2({}, g22), y22.layer.paint = Lb(g22.paint, o3.paint, d22, h3, n22), y22.layer.layout = Lb(g22.layout, o3.layout, d22, h3, n22);
            let x22 = false;
            for (const t3 of a3) {
              this.updateFeatureProperties(y22, t3);
              const { filter: e4 } = t3;
              if (e4) {
                if (d22.properties = y22.properties, e4.needGeometry) {
                  const t4 = du(d22, true);
                  if (!e4.filter(new yo(this.tileID.overscaledZ), t4, this.tileID.canonical)) continue;
                } else if (!e4.filter(new yo(this.tileID.overscaledZ), d22)) continue;
              }
              x22 = true, t3.targetId && this.addFeatureVariant(y22, t3);
            }
            x22 && this.appendToResult(t22, r3, s2, y22, f3);
          }
        }
        loadMatchingModelFeature(t22, e22, r22, n22, i22) {
          const s2 = this.bucketLayerIDs[0][0], o2 = r22.layers;
          if (!o2[s2]) return;
          const { styleLayer: a22, targets: l22 } = o2[s2];
          if ("model" !== a22.type) return;
          const u22 = n22.tile, f22 = e22.featureIndex, d22 = u22.getBucket(a22);
          if (!(d22 && d22 instanceof Ng)) return;
          const m22 = function(t3, e3, r3, n3) {
            const i3 = t3.getNodesInfo()[e3];
            if (i3.hiddenByReplacement || !i3.node.meshes) return;
            let s3 = Number.MAX_VALUE;
            const o3 = i3.node, a3 = r3.tile, l3 = n3.calculatePosMatrix(a3.tileID.toUnwrapped(), n3.worldSize), u3 = i3.evaluatedScale;
            let f3 = 0;
            n3.elevation && o3.elevation && (f3 = o3.elevation * n3.elevation.exaggeration()), h2(l3, l3, [(o3.anchor ? o3.anchor[0] : 0) * (u3[0] - 1), (o3.anchor ? o3.anchor[1] : 0) * (u3[1] - 1), f3]), p2(l3, l3, u3);
            const d3 = r3.queryGeometry, m3 = d3.isPointQuery() ? d3.screenBounds : d3.screenGeometry, y3 = function(t4) {
              const e4 = c2([], l3, t4.matrix);
              c2(e4, n3.expandedFarZProjMatrix, e4);
              for (let r4 = 0; r4 < t4.meshes.length; ++r4) {
                const i4 = t4.meshes[r4];
                if (r4 === t4.lightMeshIndex) continue;
                const o4 = cg(m3, n3, e4, i4.aabb);
                null != o4 && (s3 = Math.min(o4, s3));
              }
              if (t4.children) for (const e5 of t4.children) y3(e5);
            };
            if (y3(o3), s3 === Number.MAX_VALUE) return;
            const g3 = new $l(0, 0);
            return qg(a3.tileID.canonical, g3, i3.node.anchor[0], i3.node.anchor[1]), { intersectionZ: s3, position: g3, feature: i3.feature };
          }(d22, f22, n22, i22);
          if (!m22) return;
          const { z: y22, x: g22, y: x22 } = u22.tileID.canonical, { feature: v22, intersectionZ: b22, position: _22 } = m22;
          let w22 = {};
          void 0 !== v22.id && (w22 = r22.sourceCache.getFeatureState(a22.sourceLayer, v22.id));
          const A22 = new Db({}, y22, g22, x22, v22.id);
          A22.tile = this.tileID.canonical, A22.state = w22, A22.properties = v22.properties, A22.geometry = { type: "Point", coordinates: [_22.lng, _22.lat] };
          let M22 = this.serializedLayersCache.get(s2);
          M22 || (M22 = a22.serialize(), M22.id = s2, this.serializedLayersCache.set(s2, M22)), A22.source = M22.source, A22.sourceLayer = M22["source-layer"], A22.layer = Ct2({}, M22);
          let I2 = false;
          for (const t3 of l22) {
            this.updateFeatureProperties(A22, t3);
            const { filter: e3 } = t3;
            if (e3) {
              if (v22.properties = A22.properties, e3.needGeometry) {
                if (!e3.filter(new yo(this.tileID.overscaledZ), v22, this.tileID.canonical)) continue;
              } else if (!e3.filter(new yo(this.tileID.overscaledZ), v22)) continue;
            }
            I2 = true, t3.targetId && this.addFeatureVariant(A22, t3);
          }
          I2 && this.appendToResult(t22, s2, f22, A22, b22);
        }
        updateFeatureProperties(t22, e22, r22) {
          if (e22.properties) {
            const n22 = {};
            for (const i22 in e22.properties) {
              const s2 = e22.properties[i22].evaluate({ zoom: this.z }, t22._vectorTileFeature, t22.state, t22.tile, r22);
              null != s2 && (n22[i22] = s2);
            }
            t22.properties = n22;
          }
        }
        addFeatureVariant(t22, e22, r22) {
          const n22 = { target: e22.target, namespace: e22.namespace, uniqueFeatureID: e22.uniqueFeatureID };
          e22.properties && (n22.properties = t22.properties), t22.variants = t22.variants || {}, t22.variants[e22.targetId] = t22.variants[e22.targetId] || [], t22.variants[e22.targetId].push(n22);
        }
        appendToResult(t22, e22, r22, n22, i22) {
          let s2 = t22[e22];
          void 0 === s2 && (s2 = t22[e22] = []), s2.push({ featureIndex: r22, feature: n22, intersectionZ: i22 });
        }
        lookupSymbolFeatures(t22, e22, r22, n22, i22) {
          const s2 = {};
          this.loadVTLayers();
          for (const o2 of t22) this.loadMatchingFeature(s2, { bucketIndex: e22, sourceLayerIndex: r22, featureIndex: o2, layoutVertexArrayOffset: 0 }, n22, i22);
          return s2;
        }
        loadFeature(t22) {
          const { featureIndex: e22, sourceLayerIndex: r22 } = t22;
          this.loadVTLayers();
          const n22 = this.sourceLayerCoder.decode(r22), i22 = this.vtFeatures[n22];
          if (i22[e22]) return i22[e22];
          const s2 = this.vtLayers[n22].feature(e22);
          return i22[e22] = s2, s2;
        }
        hasLayer(t22) {
          for (const e22 of this.bucketLayerIDs) for (const r22 of e22) if (t22 === r22) return true;
          return false;
        }
        getId(t22, e22) {
          let r22 = t22.id;
          if (this.promoteId) {
            const n22 = Array.isArray(this.promoteId) || "object" != typeof this.promoteId ? this.promoteId : this.promoteId[e22];
            if (null != n22) if (Array.isArray(n22)) {
              if (!this.promoteIdExpression) {
                const t3 = Ts(n22);
                if ("success" !== t3.result) {
                  const e3 = t3.value.map((t4) => `${t4.key}: ${t4.message}`).join(", ");
                  return void $t2(`Failed to create expression for promoteId: ${e3}`);
                }
                this.promoteIdExpression = t3.value;
              }
              this.promoteIdExpression._evaluator || (this.promoteIdExpression._evaluator = new Zr()), r22 = this.promoteIdExpression.evaluate({ zoom: 0 }, t22);
            } else r22 = t22.properties[n22];
            "boolean" == typeof r22 && (r22 = Number(r22));
          }
          return r22;
        }
      }
      function Lb(t22, e22, r22, n22, i22) {
        return Ot2(t22, (t3, s2) => {
          const o2 = e22 instanceof Mo ? e22.get(s2) : null;
          return o2 && o2.evaluate ? o2.evaluate(r22, n22, void 0, i22) : o2;
        });
      }
      function Rb(t22, e22) {
        return e22 - t22;
      }
      js(Fb, "FeatureIndex", { omit: ["rawTileData", "sourceLayerCoder"] });
      const Ob = [Int8Array, Uint8Array, Uint8ClampedArray, Int16Array, Uint16Array, Int32Array, Uint32Array, Float32Array, Float64Array];
      class Ub {
        static from(t22) {
          if (!(t22 instanceof ArrayBuffer)) throw new Error("Data must be an instance of ArrayBuffer.");
          const [e22, r22] = new Uint8Array(t22, 0, 2);
          if (219 !== e22) throw new Error("Data does not appear to be in a KDBush format.");
          const n22 = r22 >> 4;
          if (1 !== n22) throw new Error(`Got v${n22} data when expected v1.`);
          const i22 = Ob[15 & r22];
          if (!i22) throw new Error("Unrecognized array type.");
          const [s2] = new Uint16Array(t22, 2, 1), [o2] = new Uint32Array(t22, 4, 1);
          return new Ub(o2, s2, i22, t22);
        }
        constructor(t22, e22 = 64, r22 = Float64Array, n22) {
          if (isNaN(t22) || t22 < 0) throw new Error(`Unpexpected numItems value: ${t22}.`);
          this.numItems = +t22, this.nodeSize = Math.min(Math.max(+e22, 2), 65535), this.ArrayType = r22, this.IndexArrayType = t22 < 65536 ? Uint16Array : Uint32Array;
          const i22 = Ob.indexOf(this.ArrayType), s2 = 2 * t22 * this.ArrayType.BYTES_PER_ELEMENT, o2 = t22 * this.IndexArrayType.BYTES_PER_ELEMENT, a22 = (8 - o2 % 8) % 8;
          if (i22 < 0) throw new Error(`Unexpected typed array class: ${r22}.`);
          n22 && n22 instanceof ArrayBuffer ? (this.data = n22, this.ids = new this.IndexArrayType(this.data, 8, t22), this.coords = new this.ArrayType(this.data, 8 + o2 + a22, 2 * t22), this._pos = 2 * t22, this._finished = true) : (this.data = new ArrayBuffer(8 + s2 + o2 + a22), this.ids = new this.IndexArrayType(this.data, 8, t22), this.coords = new this.ArrayType(this.data, 8 + o2 + a22, 2 * t22), this._pos = 0, this._finished = false, new Uint8Array(this.data, 0, 2).set([219, 16 + i22]), new Uint16Array(this.data, 2, 1)[0] = e22, new Uint32Array(this.data, 4, 1)[0] = t22);
        }
        add(t22, e22) {
          const r22 = this._pos >> 1;
          return this.ids[r22] = r22, this.coords[this._pos++] = t22, this.coords[this._pos++] = e22, r22;
        }
        finish() {
          const t22 = this._pos >> 1;
          if (t22 !== this.numItems) throw new Error(`Added ${t22} items when expected ${this.numItems}.`);
          return Nb(this.ids, this.coords, this.nodeSize, 0, this.numItems - 1, 0), this._finished = true, this;
        }
        range(t22, e22, r22, n22) {
          if (!this._finished) throw new Error("Data not yet indexed - call index.finish().");
          const { ids: i22, coords: s2, nodeSize: o2 } = this, a22 = [0, i22.length - 1, 0], l22 = [];
          for (; a22.length; ) {
            const u22 = a22.pop() || 0, c22 = a22.pop() || 0, h22 = a22.pop() || 0;
            if (c22 - h22 <= o2) {
              for (let o3 = h22; o3 <= c22; o3++) {
                const a3 = s2[2 * o3], u3 = s2[2 * o3 + 1];
                a3 >= t22 && a3 <= r22 && u3 >= e22 && u3 <= n22 && l22.push(i22[o3]);
              }
              continue;
            }
            const p22 = h22 + c22 >> 1, f22 = s2[2 * p22], d22 = s2[2 * p22 + 1];
            f22 >= t22 && f22 <= r22 && d22 >= e22 && d22 <= n22 && l22.push(i22[p22]), (0 === u22 ? t22 <= f22 : e22 <= d22) && (a22.push(h22), a22.push(p22 - 1), a22.push(1 - u22)), (0 === u22 ? r22 >= f22 : n22 >= d22) && (a22.push(p22 + 1), a22.push(c22), a22.push(1 - u22));
          }
          return l22;
        }
        within(t22, e22, r22) {
          if (!this._finished) throw new Error("Data not yet indexed - call index.finish().");
          const { ids: n22, coords: i22, nodeSize: s2 } = this, o2 = [0, n22.length - 1, 0], a22 = [], l22 = r22 * r22;
          for (; o2.length; ) {
            const u22 = o2.pop() || 0, c22 = o2.pop() || 0, h22 = o2.pop() || 0;
            if (c22 - h22 <= s2) {
              for (let r3 = h22; r3 <= c22; r3++) qb(i22[2 * r3], i22[2 * r3 + 1], t22, e22) <= l22 && a22.push(n22[r3]);
              continue;
            }
            const p22 = h22 + c22 >> 1, f22 = i22[2 * p22], d22 = i22[2 * p22 + 1];
            qb(f22, d22, t22, e22) <= l22 && a22.push(n22[p22]), (0 === u22 ? t22 - r22 <= f22 : e22 - r22 <= d22) && (o2.push(h22), o2.push(p22 - 1), o2.push(1 - u22)), (0 === u22 ? t22 + r22 >= f22 : e22 + r22 >= d22) && (o2.push(p22 + 1), o2.push(c22), o2.push(1 - u22));
          }
          return a22;
        }
      }
      function Nb(t22, e22, r22, n22, i22, s2) {
        if (i22 - n22 <= r22) return;
        const o2 = n22 + i22 >> 1;
        jb(t22, e22, o2, n22, i22, s2), Nb(t22, e22, r22, n22, o2 - 1, 1 - s2), Nb(t22, e22, r22, o2 + 1, i22, 1 - s2);
      }
      function jb(t22, e22, r22, n22, i22, s2) {
        for (; i22 > n22; ) {
          if (i22 - n22 > 600) {
            const o3 = i22 - n22 + 1, a3 = r22 - n22 + 1, l3 = Math.log(o3), u22 = 0.5 * Math.exp(2 * l3 / 3), c22 = 0.5 * Math.sqrt(l3 * u22 * (o3 - u22) / o3) * (a3 - o3 / 2 < 0 ? -1 : 1);
            jb(t22, e22, r22, Math.max(n22, Math.floor(r22 - a3 * u22 / o3 + c22)), Math.min(i22, Math.floor(r22 + (o3 - a3) * u22 / o3 + c22)), s2);
          }
          const o2 = e22[2 * r22 + s2];
          let a22 = n22, l22 = i22;
          for ($b(t22, e22, n22, r22), e22[2 * i22 + s2] > o2 && $b(t22, e22, n22, i22); a22 < l22; ) {
            for ($b(t22, e22, a22, l22), a22++, l22--; e22[2 * a22 + s2] < o2; ) a22++;
            for (; e22[2 * l22 + s2] > o2; ) l22--;
          }
          e22[2 * n22 + s2] === o2 ? $b(t22, e22, n22, l22) : (l22++, $b(t22, e22, l22, i22)), l22 <= r22 && (n22 = l22 + 1), r22 <= l22 && (i22 = l22 - 1);
        }
      }
      function $b(t22, e22, r22, n22) {
        Gb(t22, r22, n22), Gb(e22, 2 * r22, 2 * n22), Gb(e22, 2 * r22 + 1, 2 * n22 + 1);
      }
      function Gb(t22, e22, r22) {
        const n22 = t22[e22];
        t22[e22] = t22[r22], t22[r22] = n22;
      }
      function qb(t22, e22, r22, n22) {
        const i22 = t22 - r22, s2 = e22 - n22;
        return i22 * i22 + s2 * s2;
      }
      t2.$ = Wr, t2.A = We, t2.B = Br, t2.C = Ho, t2.D = Qg, t2.E = Qe, t2.F = 2, t2.G = om, t2.H = im, t2.I = tr, t2.J = class extends vg {
      }, t2.K = Gr, t2.L = cr, t2.M = Po, t2.N = bs, t2.O = gs, t2.P = bt, t2.Q = vs, t2.R = Te2, t2.S = Ps, t2.T = Oy, t2.U = To, t2.V = vg, t2.W = Cs, t2.X = Ts, t2.Y = pi, t2.Z = di, t2._ = hi, t2.a = function(t22) {
        return re.API_CDN_URL_REGEX.test(t22);
      }, t2.a$ = Ft2, t2.a0 = nr, t2.a1 = Bo, t2.a2 = _s, t2.a3 = xs, t2.a4 = function(t22) {
        const e22 = t22.value;
        let r22 = [];
        if (!e22) return r22;
        const n22 = Gr(e22);
        return "string" !== n22 ? (r22 = r22.concat([new vg(t22.key, e22, `string expected, "${n22}" found`)]), r22) : (bg(e22, true) || (r22 = r22.concat([new vg(t22.key, e22, `invalid url "${e22}"`)])), r22);
      }, t2.a5 = Eo, t2.a6 = vo, t2.a7 = ko, t2.a8 = Io, t2.a9 = class {
        constructor(t22) {
          this.specification = t22;
        }
        possiblyEvaluate(t22, e22) {
          return Ht2(t22.expression.evaluate(e22));
        }
        interpolate(t22, e22, r22) {
          return { x: or(t22.x, e22.x, r22), y: or(t22.y, e22.y, r22), z: or(t22.z, e22.z, r22), azimuthal: or(t22.azimuthal, e22.azimuthal, r22), polar: or(t22.polar, e22.polar, r22) };
        }
      }, t2.aA = Z, t2.aB = Eu, t2.aC = au, t2.aD = Pt, t2.aE = Tl, t2.aF = function(t22, e22) {
        const r22 = {};
        for (let n22 = 0; n22 < e22.length; n22++) {
          const i22 = e22[n22];
          i22 in t22 && (r22[i22] = t22[i22]);
        }
        return r22;
      }, t2.aG = Gl, t2.aH = Wl, t2.aI = class {
        constructor(t22) {
          this.entries = {}, this.scheduler = t22;
        }
        request(t22, e22, r22, n22) {
          const i22 = this.entries[t22] = this.entries[t22] || { callbacks: [] };
          if (i22.result) {
            const [t3, r3] = i22.result;
            return this.scheduler ? this.scheduler.add(() => {
              n22(t3, r3);
            }, e22) : n22(t3, r3), () => {
            };
          }
          return i22.callbacks.push(n22), i22.cancel || (i22.cancel = r22((r3, n3) => {
            i22.result = [r3, n3];
            for (const t3 of i22.callbacks) this.scheduler ? this.scheduler.add(() => {
              t3(r3, n3);
            }, e22) : t3(r3, n3);
            setTimeout(() => delete this.entries[t22], 3e3);
          })), () => {
            i22.result || (i22.callbacks = i22.callbacks.filter((t3) => t3 !== n22), i22.callbacks.length || (i22.cancel(), delete this.entries[t22]));
          };
        }
      }, t2.aJ = function(t22, e22, r22) {
        const n22 = JSON.stringify(t22.request);
        return t22.data && (this.deduped.entries[n22] = { result: [null, t22.data] }), this.deduped.request(n22, { type: "parseTile", isSymbolTile: t22.isSymbolTile, zoom: t22.tileZoom }, (e3) => {
          const n3 = De(t22.request, (t3, n4, i22, s2) => {
            t3 ? e3(t3) : n4 && e3(null, { vectorTile: r22 ? void 0 : new Nh.VectorTile(new _d2(n4)), rawData: n4, cacheControl: i22, expires: s2 });
          });
          return () => {
            n3.cancel(), e3();
          };
        }, e22);
      }, t2.aK = function(t22) {
        Ae++, Ae > ge && (t22.getActor().send("enforceCacheSizeLimit", ye), Ae = 0);
      }, t2.aL = function(t22) {
        return t22 <= 1 ? 1 : Math.pow(2, Math.floor(Math.log(t22) / Math.LN2));
      }, t2.aM = $u, t2.aN = Hy, t2.aO = Jy, t2.aP = Gy, t2.aQ = function(t22, e22) {
        const r22 = document.createElement("video");
        r22.muted = true, r22.onloadstart = function() {
          e22(null, r22);
        };
        for (let e3 = 0; e3 < t22.length; e3++) {
          const n22 = document.createElement("source");
          Fe(t22[e3]) || (r22.crossOrigin = "Anonymous"), n22.src = t22[e3], r22.appendChild(n22);
        }
        return { cancel: () => {
        } };
      }, t2.aR = Uy, t2.aS = function(t22) {
        return fetch(t22).then((t3) => t3.arrayBuffer()).then((e22) => wb(e22, 0, t22));
      }, t2.aT = Pb, t2.aU = class {
        constructor(t22, e22, r22, n22) {
          this.id = t22, this.position = null != e22 ? new $l(e22[0], e22[1]) : new $l(0, 0), this.orientation = null != r22 ? r22 : [0, 0, 0], this.nodes = n22, this.uploaded = false, this.aabb = new ic([1 / 0, 1 / 0, 1 / 0], [-1 / 0, -1 / 0, -1 / 0]), this.matrix = [];
        }
        _applyTransformations(t22, e22) {
          if (c2(t22.matrix, e22, t22.matrix), t22.meshes) for (const e3 of t22.meshes) {
            const r22 = ic.applyTransformFast(e3.aabb, t22.matrix);
            this.aabb.encapsulate(r22);
          }
          if (t22.children) for (const e3 of t22.children) this._applyTransformations(e3, t22.matrix);
        }
        computeBoundsAndApplyParent() {
          const t22 = l2([]);
          for (const e22 of this.nodes) this._applyTransformations(e22, t22);
        }
        computeModelMatrix(t22, e22, r22, n22, i22, s2, o2 = false) {
          kg(this.matrix, this, t22.transform, this.position, e22, r22, n22, i22, s2, o2);
        }
        upload(t22) {
          if (!this.uploaded) {
            for (const e22 of this.nodes) Tg(e22, t22);
            for (const t3 of this.nodes) Bg(t3);
            this.uploaded = true;
          }
        }
        destroy() {
          for (const t22 of this.nodes) Vg(t22);
        }
      }, t2.aV = Rt, t2.aW = Xm, t2.aX = Kl, t2.aY = Jl, t2.aZ = na, t2.a_ = wa, t2.aa = yo, t2.ab = Vs, t2.ac = su, t2.ad = R2, t2.ae = w2, t2.af = Tt, t2.ag = Mo, t2.ah = Mc, t2.ai = or, t2.aj = Tn, t2.ak = ar, t2.al = Mt, t2.am = ir, t2.an = class {
        constructor(t22) {
          this.specification = t22;
        }
        possiblyEvaluate(t22, e22) {
          return function([t3, e3]) {
            const r22 = Ht2([1, t3, e3]);
            return { x: r22.x, y: r22.y, z: r22.z };
          }(t22.expression.evaluate(e22));
        }
        interpolate(t22, e22, r22) {
          return { x: or(t22.x, e22.x, r22), y: or(t22.y, e22.y, r22), z: or(t22.z, e22.z, r22) };
        }
      }, t2.ao = function(t22, e22, r22 = 0, n22 = true) {
        const i22 = new bt(r22, r22), s2 = t22.sub(i22), o2 = e22.add(i22), a22 = [s2, new bt(o2.x, s2.y), o2, new bt(s2.x, o2.y)];
        return n22 && a22.push(s2.clone()), a22;
      }, t2.ap = function(t22, e22) {
        const r22 = [];
        for (let n22 = 0; n22 < t22.length; n22++) {
          const i22 = Bt(n22 - 1, -1, t22.length - 1), s2 = Bt(n22 + 1, -1, t22.length - 1), o2 = t22[n22], a22 = t22[s2], l22 = t22[i22].sub(o2).unit(), u22 = a22.sub(o2).unit(), c22 = u22.angleWithSep(l22.x, l22.y), h22 = l22.add(u22).unit().mult(-1 * e22 / Math.sin(c22 / 2));
          r22.push(o2.add(h22));
        }
        return r22;
      }, t2.aq = Zm, t2.ar = Pu, t2.as = function(t22, e22, r22 = 0) {
        return A2(((e22.x - r22) * t22.scale - t22.x) * Tn, (e22.y * t22.scale - t22.y) * Tn, Ql(e22.z, e22.y));
      }, t2.at = j2, t2.au = C, t2.av = Ku, t2.aw = Gf, t2.ax = function(t22) {
        let e22 = 1 / 0, r22 = 1 / 0, n22 = -1 / 0, i22 = -1 / 0;
        for (const s2 of t22) e22 = Math.min(e22, s2.x), r22 = Math.min(r22, s2.y), n22 = Math.max(n22, s2.x), i22 = Math.max(i22, s2.y);
        return { min: new bt(e22, r22), max: new bt(n22, i22) };
      }, t2.ay = Zl, t2.az = c2, t2.b = function(t22) {
        return re.API_FONTS_REGEX.test(t22);
      }, t2.b$ = E2, t2.b0 = La, t2.b1 = Iy, t2.b2 = function() {
        mo.isLoading() || mo.isLoaded() || "deferred" !== po() || fo();
      }, t2.b3 = Vo, t2.b4 = du, t2.b5 = Db, t2.b6 = Zt2, t2.b7 = Uf, t2.b8 = pp, t2.b9 = fu, t2.bA = function(t22, e22) {
        const { x: r22, y: n22 } = t22.point, i22 = Ac(r22, n22, t22.worldSize / t22._pixelsPerMercatorPixel, 0, 0);
        return c2(i22, i22, bc(cc(e22)));
      }, t2.bB = n2, t2.bC = function(t22) {
        return t22[0] = 0, t22[1] = 0, t22[2] = 0, t22;
      }, t2.bD = function(t22, e22) {
        return Math.hypot(e22[0] - t22[0], e22[1] - t22[1], e22[2] - t22[2]);
      }, t2.bE = D2, t2.bF = P2, t2.bG = F, t2.bH = Wd, t2.bI = zd, t2.bJ = Zd, t2.bK = function(t22, e22, r22, n22, i22) {
        const s2 = 5 * e22 + 2;
        t22.float32[s2 + 0] = r22, t22.float32[s2 + 1] = n22, t22.float32[s2 + 2] = i22;
      }, t2.bL = _y, t2.bM = Af, t2.bN = xu, t2.bO = cd, t2.bP = kp, t2.bQ = xg, t2.bR = Lp, t2.bS = Rp, t2.bT = Fm, t2.bU = Em, t2.bV = Rd, t2.bW = Ub, t2.bX = Bt, t2.bY = Y, t2.bZ = function(t22, e22, r22) {
        r22 *= 0.5;
        var n22 = e22[0], i22 = e22[1], s2 = e22[2], o2 = e22[3], a22 = Math.sin(r22), l22 = Math.cos(r22);
        return t22[0] = n22 * l22 + i22 * a22, t22[1] = i22 * l22 - n22 * a22, t22[2] = s2 * l22 + o2 * a22, t22[3] = o2 * l22 - s2 * a22, t22;
      }, t2.b_ = K2, t2.ba = ea, t2.bb = Ta, t2.bc = Wu, t2.bd = Ka, t2.be = Qc, t2.bf = Fy, t2.bg = function(t22, e22) {
        const r22 = Mc(e22.zoom);
        if (0 === r22) return cc(t22);
        const n22 = dc(t22), i22 = mc(n22), s2 = Zl(n22.getWest()) * e22.worldSize, o2 = Zl(n22.getEast()) * e22.worldSize, a22 = Wl(n22.getNorth()) * e22.worldSize, l22 = Wl(n22.getSouth()) * e22.worldSize, c22 = [s2, a22, 0], h22 = [o2, a22, 0], p22 = [s2, l22, 0], f22 = [o2, l22, 0], d22 = u2([], e22.globeMatrix);
        return R2(c22, c22, d22), R2(h22, h22, d22), R2(p22, p22, d22), R2(f22, f22, d22), i22[0] = hc(i22[0], p22, r22), i22[1] = hc(i22[1], f22, r22), i22[2] = hc(i22[2], h22, r22), i22[3] = hc(i22[3], c22, r22), ic.fromPoints(i22);
      }, t2.bh = vc, t2.bi = u2, t2.bj = yc, t2.bk = hc, t2.bl = ra, t2.bm = Zu, t2.bn = y2, t2.bo = h2, t2.bp = Kv, t2.bq = _d2, t2.br = De, t2.bs = function(t22, e22) {
        const r22 = [];
        for (const n22 in t22) n22 in e22 || r22.push(n22);
        return r22;
      }, t2.bt = Vt2, t2.bu = ["type", "source", "source-layer", "minzoom", "maxzoom", "filter", "layout"], t2.bv = _t2, t2.bw = function(t22) {
        var e22 = new r2(16);
        return e22[0] = t22[0], e22[1] = t22[1], e22[2] = t22[2], e22[3] = t22[3], e22[4] = t22[4], e22[5] = t22[5], e22[6] = t22[6], e22[7] = t22[7], e22[8] = t22[8], e22[9] = t22[9], e22[10] = t22[10], e22[11] = t22[11], e22[12] = t22[12], e22[13] = t22[13], e22[14] = t22[14], e22[15] = t22[15], e22;
      }, t2.bx = l2, t2.by = m2, t2.bz = a2, t2.c = ie2, t2.c$ = function(t22) {
        return t22({ pluginStatus: ao, pluginURL: lo }), ho.on("pluginStateChange", t22), t22;
      }, t2.c0 = G, t2.c1 = Yt, t2.c2 = function(t22, e22) {
        return t22[0] = -e22[0], t22[1] = -e22[1], t22[2] = -e22[2], t22[3] = e22[3], t22;
      }, t2.c3 = x2, t2.c4 = function(t22, e22, r22, n22, i22) {
        var s2, o2 = 1 / Math.tan(e22 / 2);
        return t22[0] = o2 / r22, t22[1] = 0, t22[2] = 0, t22[3] = 0, t22[4] = 0, t22[5] = o2, t22[6] = 0, t22[7] = 0, t22[8] = 0, t22[9] = 0, t22[11] = -1, t22[12] = 0, t22[13] = 0, t22[15] = 0, null != i22 && i22 !== 1 / 0 ? (t22[10] = (i22 + n22) * (s2 = 1 / (n22 - i22)), t22[14] = 2 * i22 * n22 * s2) : (t22[10] = -1, t22[14] = -2 * n22), t22;
      }, t2.c5 = function(t22, e22, r22, n22, i22, s2, o2) {
        var a22 = 1 / (e22 - r22), l22 = 1 / (n22 - i22), u22 = 1 / (s2 - o2);
        return t22[0] = -2 * a22, t22[1] = 0, t22[2] = 0, t22[3] = 0, t22[4] = 0, t22[5] = -2 * l22, t22[6] = 0, t22[7] = 0, t22[8] = 0, t22[9] = 0, t22[10] = 2 * u22, t22[11] = 0, t22[12] = (e22 + r22) * a22, t22[13] = (i22 + n22) * l22, t22[14] = (o2 + s2) * u22, t22[15] = 1, t22;
      }, t2.c6 = Yl, t2.c7 = function(t22, e22, r22) {
        t22[4 * e22 + 0] = r22[0], t22[4 * e22 + 1] = r22[1], t22[4 * e22 + 2] = r22[2], t22[4 * e22 + 3] = r22[3];
      }, t2.c8 = dl, t2.c9 = ul, t2.cA = ng, t2.cB = v2, t2.cC = eg, t2.cD = function(t22) {
        const e22 = eg(t22, true);
        return n2([], [e22[0], e22[1], e22[4], e22[5]]);
      }, t2.cE = p2, t2.cF = Ju, t2.cG = f2, t2.cH = function(t22) {
        const { x: e22, y: r22 } = t22.point, { lng: n22, lat: i22 } = t22._center;
        return Ac(e22, r22, t22.worldSize, n22, i22);
      }, t2.cI = S, t2.cJ = It2, t2.cK = Gu, t2.cL = Bl, t2.cM = function(t22, e22, r22) {
        let n22 = 0;
        for (let r3 = 0; r3 < 2; ++r3) {
          const i22 = 0;
          t22[r3] > i22 && (n22 += (t22[r3] - i22) * (t22[r3] - i22)), e22[r3] < i22 && (n22 += (i22 - e22[r3]) * (i22 - e22[r3]));
        }
        return n22;
      }, t2.cN = 45, t2.cO = lr, t2.cP = Xl, t2.cQ = hl, t2.cR = function(t22, e22, r22) {
        const n22 = Math.sqrt(t22 * t22 + e22 * e22 + r22 * r22), i22 = n22 > 0 ? Math.acos(r22 / n22) * At : 0;
        let s2 = 0 !== t22 || 0 !== e22 ? Math.atan2(-e22, -t22) * At + 90 : 0;
        return s2 < 0 && (s2 += 360), [n22, s2, i22];
      }, t2.cS = A2, t2.cT = iu, t2.cU = M2, t2.cV = ic, t2.cW = Ht2, t2.cX = function(t22) {
        return [Math.pow(t22[0], 1 / 2.2), Math.pow(t22[1], 1 / 2.2), Math.pow(t22[2], 1 / 2.2)];
      }, t2.cY = I, t2.cZ = bg, t2.c_ = function(t22, e22) {
        return t22.readFields(cx2, { icons: [] }, e22);
      }, t2.ca = cl, t2.cb = ll, t2.cc = al, t2.cd = $l, t2.ce = my, t2.cf = function() {
        var t22 = new r2(4);
        return r2 != Float32Array && (t22[1] = 0, t22[2] = 0), t22[0] = 1, t22[3] = 1, t22;
      }, t2.cg = function(t22, e22, r22) {
        var n22 = e22[0], i22 = e22[1], s2 = e22[2], o2 = e22[3], a22 = Math.sin(r22), l22 = Math.cos(r22);
        return t22[0] = n22 * l22 + s2 * a22, t22[1] = i22 * l22 + o2 * a22, t22[2] = n22 * -a22 + s2 * l22, t22[3] = i22 * -a22 + o2 * l22, t22;
      }, t2.ch = function(t22, e22) {
        return t22[0] === e22[0] && t22[1] === e22[1] && t22[2] === e22[2] && t22[3] === e22[3];
      }, t2.ci = N2, t2.cj = function(t22) {
        return Math.hypot(t22[0], t22[1], t22[2], t22[3]);
      }, t2.ck = it, t2.cl = U2, t2.cm = ju, t2.cn = nc, t2.co = rg, t2.cp = Nu, t2.cq = fc, t2.cr = function(t22, e22, r22, n22, i22, s2, o2, a22, l22) {
        if ("globe" === l22.name) return fc(t22, e22, new Nu(r22, n22, i22), false);
        const u22 = Xm({ z: r22, x: n22, y: i22 }, l22);
        return new ic([(s2 + u22.x / u22.scale) * e22, e22 * (u22.y / u22.scale), o2], [(s2 + u22.x2 / u22.scale) * e22, e22 * (u22.y2 / u22.scale), a22]);
      }, t2.cs = function(t22, e22, r22) {
        return t22[0] = Math.min(e22[0], r22[0]), t22[1] = Math.min(e22[1], r22[1]), t22[2] = Math.min(e22[2], r22[2]), t22[3] = Math.min(e22[3], r22[3]), t22;
      }, t2.ct = function(t22, e22, r22) {
        return t22[0] = Math.max(e22[0], r22[0]), t22[1] = Math.max(e22[1], r22[1]), t22[2] = Math.max(e22[2], r22[2]), t22[3] = Math.max(e22[3], r22[3]), t22;
      }, t2.cu = function(t22) {
        const e22 = Math.round((t22 + 45 + 360) % 360 / 90) % 4;
        return St[e22];
      }, t2.cv = tu, t2.cw = H, t2.cx = Vl, t2.cy = function(t22) {
        const e22 = l2(new Float64Array(16));
        c2(e22, t22.pixelMatrix, t22.globeMatrix);
        const r22 = [0, Ll, 0], n22 = [0, Rl, 0];
        return R2(r22, r22, e22), R2(n22, n22, e22), [r22[0] > 0 && r22[0] <= t22.width && r22[1] > 0 && r22[1] <= t22.height && !Sc(t22, new $l(t22.center.lat, 90)), n22[0] > 0 && n22[0] <= t22.width && n22[1] > 0 && n22[1] <= t22.height && !Sc(t22, new $l(t22.center.lat, -90))];
      }, t2.cz = function(t22, e22) {
        const { scale: r22 } = t22.tileTransform, n22 = r22 * Tn / (t22.tileSize * Math.pow(2, e22.zoom - t22.tileID.overscaledZ + t22.tileID.canonical.z));
        return function(t3, e3, r3) {
          var n3 = e3[1], i22 = e3[2], s2 = e3[3], o2 = r3[0], a22 = r3[1];
          return t3[0] = e3[0] * o2, t3[1] = n3 * o2, t3[2] = i22 * a22, t3[3] = s2 * a22, t3;
        }(new Float32Array(4), e22.inverseAdjustmentMatrix, [n22, n22]);
      }, t2.d = function(t22) {
        return re.API_TILEJSON_REGEX.test(t22);
      }, t2.d$ = Ca, t2.d0 = rx, t2.d1 = dm, t2.d2 = fm, t2.d3 = Ve, t2.d4 = uo, t2.d5 = de, t2.d6 = Ze, t2.d7 = Nt, t2.d8 = function(t22) {
        const e22 = t22.indexOf(qo);
        return e22 >= 0 ? t22.slice(0, e22) : t22;
      }, t2.d9 = function(t22) {
        return t22.indexOf(qo) >= 0;
      }, t2.dA = wc, t2.dB = te2, t2.dC = Qt2, t2.dD = 256, t2.dE = function(t22, e22) {
        const r22 = [0, 0, 0];
        return R2(r22, r22, vc(cc(e22.canonical))), R2(r22, r22, t22), r22;
      }, t2.dF = (t22) => ({ u_camera_to_center_distance: new ll(t22), u_extrude_scale: new gl(t22), u_device_pixel_ratio: new ll(t22), u_matrix: new dl(t22), u_inv_rot_matrix: new dl(t22), u_merc_center: new ul(t22), u_tile_id: new cl(t22), u_zoom_transition: new ll(t22), u_up_dir: new cl(t22), u_emissive_strength: new ll(t22) }), t2.dG = (t22) => ({ u_matrix: new dl(t22), u_pixels_to_tile_units: new gl(t22), u_device_pixel_ratio: new ll(t22), u_width_scale: new ll(t22), u_floor_width_scale: new ll(t22), u_units_to_pixels: new ul(t22), u_dash_image: new al(t22), u_gradient_image: new al(t22), u_image_height: new ll(t22), u_texsize: new ul(t22), u_tile_units_to_pixels: new ll(t22), u_alpha_discard_threshold: new ll(t22), u_trim_offset: new ul(t22), u_trim_fade_range: new ul(t22), u_trim_color: new hl(t22), u_emissive_strength: new ll(t22), u_zbias_factor: new ll(t22), u_tile_to_meter: new ll(t22), u_ground_shadow_factor: new cl(t22) }), t2.dH = (t22) => ({ u_matrix: new dl(t22), u_texsize: new ul(t22), u_pixels_to_tile_units: new gl(t22), u_device_pixel_ratio: new ll(t22), u_width_scale: new ll(t22), u_floor_width_scale: new ll(t22), u_image: new al(t22), u_units_to_pixels: new ul(t22), u_tile_units_to_pixels: new ll(t22), u_alpha_discard_threshold: new ll(t22), u_trim_offset: new ul(t22), u_trim_fade_range: new ul(t22), u_trim_color: new hl(t22), u_emissive_strength: new ll(t22), u_zbias_factor: new ll(t22), u_tile_to_meter: new ll(t22), u_ground_shadow_factor: new cl(t22), u_pattern_transition: new ll(t22) }), t2.dI = ba, t2.dJ = ud, t2.dK = Tc, t2.dL = (t22, e22, r22, n22, i22, s2) => {
        const o2 = t22.transform, a22 = "globe" === o2.projection.name;
        let l22;
        if ("map" === s2.paint.get("circle-pitch-alignment")) if (a22) {
          const t3 = wc(o2.zoom, e22.canonical) * o2._pixelsPerMercatorPixel;
          l22 = Float32Array.from([t3, 0, 0, t3]);
        } else l22 = o2.calculatePixelsToTileUnitsMatrix(r22);
        else l22 = new Float32Array([o2.pixelsToGLUnits[0], 0, 0, o2.pixelsToGLUnits[1]]);
        const u22 = { u_camera_to_center_distance: t22.transform.getCameraToCenterDistance(o2.projection), u_matrix: t22.translatePosMatrix(e22.projMatrix, r22, s2.paint.get("circle-translate"), s2.paint.get("circle-translate-anchor")), u_device_pixel_ratio: pe.devicePixelRatio, u_extrude_scale: l22, u_inv_rot_matrix: Pc, u_merc_center: [0, 0], u_tile_id: [0, 0, 0], u_zoom_transition: 0, u_up_dir: [0, 0, 0], u_emissive_strength: s2.paint.get("circle-emissive-strength") };
        if (a22) {
          u22.u_inv_rot_matrix = n22, u22.u_merc_center = i22, u22.u_tile_id = [e22.canonical.x, e22.canonical.y, 1 << e22.canonical.z], u22.u_zoom_transition = Mc(o2.zoom);
          const t3 = i22[0] * Tn, r3 = i22[1] * Tn;
          u22.u_up_dir = o2.projection.upVector(new Nu(0, 0, 0), t3, r3);
        }
        return u22;
      }, t2.dM = Zf, t2.dN = Vr, t2.dO = (t22, e22, r22, n22, i22, s2, o2, a22, l22, u22) => {
        const c22 = t22.transform, h22 = c22.pitch < 15 ? qf(0.07, 0.7, Pt((14 - c22.zoom) / 5, 0, 1)) : 0.07, p22 = "none" === r22.paint.get("line-trim-color-use-theme").constantOr("default");
        return { u_matrix: Xf(t22, e22, r22, n22), u_texsize: e22.imageAtlasTexture ? e22.imageAtlasTexture.size : [0, 0], u_pixels_to_tile_units: c22.calculatePixelsToTileUnitsMatrix(e22), u_device_pixel_ratio: i22, u_width_scale: s2, u_floor_width_scale: o2, u_image: 0, u_tile_units_to_pixels: Hf(e22, c22), u_units_to_pixels: [1 / c22.pixelsToGLUnits[0], 1 / c22.pixelsToGLUnits[1]], u_alpha_discard_threshold: 0, u_trim_offset: a22, u_trim_fade_range: r22.paint.get("line-trim-fade-range"), u_trim_color: r22.paint.get("line-trim-color").toRenderColor(p22 ? null : r22.lut).toArray01(), u_emissive_strength: r22.paint.get("line-emissive-strength"), u_zbias_factor: h22, u_tile_to_meter: iu(e22.tileID.canonical, 0), u_ground_shadow_factor: l22, u_pattern_transition: u22 };
      }, t2.dP = (t22, e22, r22, n22, i22, s2, o2, a22, l22, u22) => {
        const c22 = t22.transform, h22 = c22.calculatePixelsToTileUnitsMatrix(e22), p22 = "none" === r22.paint.get("line-trim-color-use-theme").constantOr("default"), f22 = c22.pitch < 15 ? qf(0.07, 0.7, Pt((14 - c22.zoom) / 5, 0, 1)) : 0.07;
        return { u_matrix: Xf(t22, e22, r22, n22), u_pixels_to_tile_units: h22, u_device_pixel_ratio: s2, u_width_scale: o2, u_floor_width_scale: a22, u_units_to_pixels: [1 / c22.pixelsToGLUnits[0], 1 / c22.pixelsToGLUnits[1]], u_dash_image: 0, u_gradient_image: 1, u_image_height: i22, u_texsize: Wf(r22) && e22.lineAtlasTexture ? e22.lineAtlasTexture.size : [0, 0], u_tile_units_to_pixels: Hf(e22, t22.transform), u_alpha_discard_threshold: 0, u_trim_offset: l22, u_trim_fade_range: r22.paint.get("line-trim-fade-range"), u_trim_color: r22.paint.get("line-trim-color").toRenderColor(p22 ? null : r22.lut).toArray01(), u_emissive_strength: r22.paint.get("line-emissive-strength"), u_zbias_factor: f22, u_tile_to_meter: iu(e22.tileID.canonical, 0), u_ground_shadow_factor: u22 };
      }, t2.dQ = Lt, t2.dR = Zc, t2.dS = Ql, t2.dT = df, t2.dU = qu, t2.dV = of, t2.dW = Xp, t2.dX = 450, t2.dY = 7, t2.dZ = qy, t2.d_ = Qo, t2.da = function(t22) {
        const e22 = t22.lastIndexOf(qo);
        return e22 >= 0 ? t22.slice(e22 + 1) : "";
      }, t2.db = function(t22) {
        const e22 = [], r22 = t22.id;
        return void 0 === r22 && e22.push({ message: `layers.${r22}: missing required property "id"` }), void 0 === t22.render && e22.push({ message: `layers.${r22}: missing required method "render"` }), t22.renderingMode && "2d" !== t22.renderingMode && "3d" !== t22.renderingMode && e22.push({ message: `layers.${r22}: property "renderingMode" must be either "2d" or "3d"` }), e22;
      }, t2.dc = function(t22, e22, r22, n22) {
        return "custom" === t22.type ? new Qy(t22, e22) : new Hg[t22.type](t22, e22, r22, n22);
      }, t2.dd = Ut2, t2.de = function(t22) {
        const e22 = t22.indexOf(qo);
        return e22 >= 0 ? t22.slice(e22 + 1) : "";
      }, t2.df = class extends Db {
        constructor(t22, e22) {
          super(t22._vectorTileFeature, t22._z, t22._x, t22._y, t22.id), t22.state && (this.state = Object.assign({}, t22.state)), this.target = e22.target, this.namespace = e22.namespace, e22.properties && (this.properties = e22.properties), this.target && ("featuresetId" in this.target && !this.target.importId || "layerId" in this.target) && (this.source = t22.source, this.sourceLayer = t22.sourceLayer, this.layer = t22.layer);
        }
        toJSON() {
          const t22 = super.toJSON();
          return t22.target = this.target, t22.namespace = this.namespace, t22;
        }
      }, t2.dg = ho, t2.dh = Ce, t2.di = pl, t2.dj = class extends ol {
        constructor(t22) {
          super(t22), this.current = ml;
        }
        set(t22, e22, r22) {
          if (this.fetchUniformLocation(t22, e22)) {
            for (let t3 = 0; t3 < 9; t3++) if (r22[t3] !== this.current[t3]) {
              this.current = r22, this.gl.uniformMatrix3fv(this.location, false, r22);
              break;
            }
          }
        }
      }, t2.dk = zt, t2.dl = function(t22, e22, r22) {
        const n22 = Mc(r22.zoom), i22 = t22.style.map._antialias, s2 = t22.terrain && t22.terrain.exaggeration() > 0;
        return 0 === n22 && !i22 && !s2;
      }, t2.dm = function(t22) {
        const e22 = t22.pixelsPerMeter, r22 = e22 / Yl(1, t22.center.lat), n22 = l2(new Float64Array(16));
        return h2(n22, n22, [t22.point.x, t22.point.y, 0]), p2(n22, n22, [r22, r22, e22]), Float32Array.from(n22);
      }, t2.dn = dc, t2.dp = function(t22) {
        const e22 = tu - 5;
        t22 = Pt(t22, -e22, e22) / e22 * 90;
        const r22 = Math.pow(Math.abs(Math.sin(Mt(t22))), 3);
        return Math.round(r22 * (Fl.length - 1));
      }, t2.dq = function(t22, e22, r22, n22) {
        const i22 = e22.getNorth(), s2 = e22.getSouth(), a22 = e22.getWest(), l22 = e22.getEast(), u22 = 1 << t22.z, c22 = l22 - a22, h22 = i22 - s2, p22 = c22 / Dl, f22 = -h22 / Fl[r22], d22 = [0, p22, 0, f22, 0, 0, i22, a22, 0];
        if (t22.z > 0) {
          const t3 = 180 / n22;
          o(d22, d22, [t3 / c22 + 1, 0, 0, 0, t3 / h22 + 1, 0, -0.5 * t3 / p22, 0.5 * t3 / f22, 1]);
        }
        return d22[2] = u22, d22[5] = t22.x, d22[8] = t22.y, d22;
      }, t2.dr = cc, t2.ds = function(t22, e22, r22) {
        const n22 = l2(new Float64Array(16)), i22 = (e22 / (1 << t22) - 0.5) * Math.PI * 2;
        return d2(n22, r22.globeMatrix, i22), Float32Array.from(n22);
      }, t2.dt = class {
        isDataAvailableAtPoint(t22) {
          const e22 = this._source();
          if (this.isUsingMockSource() || !e22 || t22.y < 0 || t22.y > 1) return false;
          const r22 = e22.getSource().maxzoom, n22 = 1 << r22, i22 = Math.floor(t22.x), s2 = Math.floor((t22.x - i22) * n22), o2 = Math.floor(t22.y * n22), a22 = this.findDEMTileFor(new $u(r22, i22, r22, s2, o2));
          return !(!a22 || !a22.dem);
        }
        getAtPointOrZero(t22, e22 = 0) {
          return this.getAtPoint(t22, e22) || 0;
        }
        getAtPoint(t22, e22, r22 = true) {
          if (this.isUsingMockSource()) return null;
          null == e22 && (e22 = null);
          const n22 = this._source();
          if (!n22) return e22;
          if (t22.y < 0 || t22.y > 1) return e22;
          const i22 = n22.getSource().maxzoom, s2 = 1 << i22, o2 = Math.floor(t22.x), a22 = t22.x - o2, l22 = new $u(i22, o2, i22, Math.floor(a22 * s2), Math.floor(t22.y * s2)), u22 = this.findDEMTileFor(l22);
          if (!u22 || !u22.dem) return e22;
          const c22 = u22.dem, h22 = 1 << u22.tileID.canonical.z, p22 = (a22 * h22 - u22.tileID.canonical.x) * c22.dim, f22 = (t22.y * h22 - u22.tileID.canonical.y) * c22.dim, d22 = Math.floor(p22), m22 = Math.floor(f22);
          return (r22 ? this.exaggeration() : 1) * or(or(c22.get(d22, m22), c22.get(d22, m22 + 1), f22 - m22), or(c22.get(d22 + 1, m22), c22.get(d22 + 1, m22 + 1), f22 - m22), p22 - d22);
        }
        getAtTileOffset(t22, e22, r22) {
          const n22 = 1 << t22.canonical.z;
          return this.getAtPointOrZero(new su(t22.wrap + (t22.canonical.x + e22 / Tn) / n22, (t22.canonical.y + r22 / Tn) / n22));
        }
        getAtTileOffsetFunc(t22, e22, r22, n22) {
          return (i22) => {
            const s2 = this.getAtTileOffset(t22, i22.x, i22.y), o2 = n22.upVector(t22.canonical, i22.x, i22.y);
            return E2(o2, o2, s2 * n22.upVectorScale(t22.canonical, e22, r22).metersToTile), o2;
          };
        }
        getForTilePoints(t22, e22, r22, n22) {
          if (this.isUsingMockSource()) return false;
          const i22 = Cg.create(this, t22, n22);
          return !!i22 && (e22.forEach((t3) => {
            t3[2] = this.exaggeration() * i22.getElevationAt(t3[0], t3[1], r22);
          }), true);
        }
        getMinMaxForTile(t22) {
          if (this.isUsingMockSource()) return null;
          const e22 = this.findDEMTileFor(t22);
          if (!e22 || !e22.dem) return null;
          const r22 = e22.dem.tree, n22 = e22.tileID, i22 = 1 << t22.canonical.z - n22.canonical.z;
          let s2 = t22.canonical.x / i22 - n22.canonical.x, o2 = t22.canonical.y / i22 - n22.canonical.y, a22 = 0;
          for (let e3 = 0; e3 < t22.canonical.z - n22.canonical.z && !r22.leaves[a22]; e3++) {
            s2 *= 2, o2 *= 2;
            const t3 = 2 * Math.floor(o2) + Math.floor(s2);
            a22 = r22.childOffsets[a22] + t3, s2 %= 1, o2 %= 1;
          }
          return { min: this.exaggeration() * r22.minimums[a22], max: this.exaggeration() * r22.maximums[a22] };
        }
        getMinElevationBelowMSL() {
          throw new Error("Pure virtual method called.");
        }
        raycast(t22, e22, r22) {
          throw new Error("Pure virtual method called.");
        }
        pointCoordinate(t22) {
          throw new Error("Pure virtual method called.");
        }
        _source() {
          throw new Error("Pure virtual method called.");
        }
        isUsingMockSource() {
          throw new Error("Pure virtual method called.");
        }
        exaggeration() {
          throw new Error("Pure virtual method called.");
        }
        findDEMTileFor(t22) {
          throw new Error("Pure virtual method called.");
        }
        get visibleDemTiles() {
          throw new Error("Getter must be implemented in subclass.");
        }
        getMinMaxForVisibleTiles() {
          const t22 = this.visibleDemTiles;
          if (0 === t22.length) return null;
          let e22 = false, r22 = Number.MAX_VALUE, n22 = Number.MIN_VALUE;
          for (const i22 of t22) {
            const t3 = this.getMinMaxForTile(i22.tileID);
            t3 && (r22 = Math.min(r22, t3.min), n22 = Math.max(n22, t3.max), e22 = true);
          }
          return e22 ? { min: r22, max: n22 } : null;
        }
      }, t2.du = Xc, t2.dv = sc, t2.dw = function(t22, e22) {
        return [Math.pow(t22[0], 2.2) * e22, Math.pow(t22[1], 2.2) * e22, Math.pow(t22[2], 2.2) * e22];
      }, t2.dx = i2, t2.dy = function(t22, e22) {
        var r22 = Math.sin(e22), n22 = Math.cos(e22);
        return t22[0] = n22, t22[1] = r22, t22[2] = 0, t22[3] = -r22, t22[4] = n22, t22[5] = 0, t22[6] = 0, t22[7] = 0, t22[8] = 1, t22;
      }, t2.dz = O, t2.e = re, t2.e$ = Vb, t2.e0 = 256, t2.e1 = bc, t2.e2 = ua, t2.e3 = d2, t2.e4 = function(t22, e22) {
        return t22[0] = e22[0], t22[1] = e22[1], t22[2] = e22[2], t22[3] = e22[4], t22[4] = e22[5], t22[5] = e22[6], t22[6] = e22[8], t22[7] = e22[9], t22[8] = e22[10], t22;
      }, t2.e5 = Ia, t2.e6 = Sa, t2.e7 = function(t22, e22, r22, n22, i22) {
        return Pt((t22 - e22) / (r22 - e22) * (i22 - n22) + n22, n22, i22);
      }, t2.e8 = J, t2.e9 = function(t22, e22) {
        var r22 = e22[0], n22 = e22[1], i22 = e22[2], s2 = e22[3], o2 = e22[4], a22 = e22[5], l22 = e22[6], u22 = e22[7], c22 = e22[8], h22 = c22 * o2 - a22 * u22, p22 = -c22 * s2 + a22 * l22, f22 = u22 * s2 - o2 * l22, d22 = r22 * h22 + n22 * p22 + i22 * f22;
        return d22 ? (t22[0] = h22 * (d22 = 1 / d22), t22[1] = (-c22 * n22 + i22 * u22) * d22, t22[2] = (a22 * n22 - i22 * o2) * d22, t22[3] = p22 * d22, t22[4] = (c22 * r22 - i22 * l22) * d22, t22[5] = (-a22 * r22 + i22 * s2) * d22, t22[6] = f22 * d22, t22[7] = (-u22 * r22 + n22 * l22) * d22, t22[8] = (o2 * r22 - n22 * s2) * d22, t22) : null;
      }, t2.eA = function(t22, e22, r22) {
        return t22[0] = e22[0] / r22[0], t22[1] = e22[1] / r22[1], t22[2] = e22[2] / r22[2], t22;
      }, t2.eB = $, t2.eC = Ul, t2.eD = B2, t2.eE = function(t22, e22, r22, n22) {
        return t22[0] = e22, t22[1] = r22, t22[2] = n22, t22;
      }, t2.eF = function([t22, e22, r22]) {
        const n22 = Math.hypot(t22, e22, r22), i22 = Math.atan2(t22, r22), s2 = 0.5 * Math.PI - Math.acos(-e22 / n22);
        return new $l(It2(i22), It2(s2));
      }, t2.eG = X2, t2.eH = sg, t2.eI = function(t22) {
        const e22 = t22.navigator ? t22.navigator.userAgent : null;
        return !!function(t3) {
          if (null == Wt2) {
            const e3 = t3.navigator ? t3.navigator.userAgent : null;
            Wt2 = !!t3.safari || !(!e3 || !(/\b(iPad|iPhone|iPod)\b/.test(e3) || e3.match("Safari") && !e3.match("Chrome")));
          }
          return Wt2;
        }(t22) && !(!e22 || !(e22.match("Version/15.4") || e22.match("Version/15.5") || e22.match(/CPU (OS|iPhone OS) (15_4|15_5) like Mac OS X/)));
      }, t2.eJ = function(t22, e22) {
        ye = t22, ge = e22;
      }, t2.eK = Sc, t2.eL = Ic, t2.eM = function(t22) {
        const e22 = [0, 0, 0], r22 = l2(new Float64Array(16));
        return c2(r22, t22.pixelMatrix, t22.globeMatrix), R2(e22, e22, r22), new bt(e22[0], e22[1]);
      }, t2.eN = function(t22, e22, r22 = false) {
        if (ao === no || ao === io || ao === so) throw new Error("setRTLTextPlugin cannot be called multiple times.");
        lo = pe.resolveURL(t22), ao = no, oo = e22, co(), r22 || fo();
      }, t2.eO = po, t2.eP = function() {
        rx().acquire(Kg);
      }, t2.eQ = function() {
        const t22 = tx;
        t22 && (t22.isPreloaded() && 1 === t22.numActive() ? (t22.release(Kg), tx = null) : console.warn("Could not clear WebWorkers since there are active Map instances that still reference it. The pre-warmed WebWorker pool can only be cleared when all map instances have been removed with map.remove()"));
      }, t2.eR = Jg, t2.eS = function(t22) {
        const e22 = _e2();
        if (!e22) return;
        const r22 = e22.delete(me);
        t22 && r22.then(() => t22()).catch(t22);
      }, t2.eT = Yg, t2.eU = ob, t2.eV = function(t22) {
        eb = pe.resolveURL(t22), sb || (sb = new Qg(rx(), new Qe())), sb.broadcast("setDracoUrl", eb);
      }, t2.eW = ab, t2.eX = function(t22) {
        nb = pe.resolveURL(t22), sb || (sb = new Qg(rx(), new Qe())), sb.broadcast("setMeshoptUrl", nb);
      }, t2.eY = js, t2.eZ = qc, t2.e_ = pm, t2.ea = as, t2.eb = V, t2.ec = ru2, t2.ed = class {
        constructor(t22, e22, r22, n22) {
          this.context = t22, this.format = n22, this.size = r22, this.texture = t22.gl.createTexture();
          const [i22, s2, o2] = this.size, { gl: a22 } = t22;
          a22.bindTexture(a22.TEXTURE_3D, this.texture), t22.pixelStoreUnpackFlipY.set(false), t22.pixelStoreUnpack.set(1), t22.pixelStoreUnpackPremultiplyAlpha.set(false), a22.texImage3D(a22.TEXTURE_3D, 0, this.format, i22, s2, o2, 0, Ly(this.format), Ry(this.format), e22.data);
        }
        bind(t22, e22) {
          const { context: r22 } = this, { gl: n22 } = r22;
          n22.bindTexture(n22.TEXTURE_3D, this.texture), t22 !== this.minFilter && (n22.texParameteri(n22.TEXTURE_3D, n22.TEXTURE_MAG_FILTER, t22), n22.texParameteri(n22.TEXTURE_3D, n22.TEXTURE_MIN_FILTER, t22), this.minFilter = t22), e22 !== this.wrapS && (n22.texParameteri(n22.TEXTURE_3D, n22.TEXTURE_WRAP_S, e22), n22.texParameteri(n22.TEXTURE_3D, n22.TEXTURE_WRAP_T, e22), this.wrapS = e22);
        }
        destroy() {
          const { gl: t22 } = this.context;
          t22.deleteTexture(this.texture), this.texture = null;
        }
      }, t2.ee = function(t22, e22) {
        if (t22 === e22) {
          var r22 = e22[1], n22 = e22[2], i22 = e22[3], s2 = e22[6], o2 = e22[7], a22 = e22[11];
          t22[1] = e22[4], t22[2] = e22[8], t22[3] = e22[12], t22[4] = r22, t22[6] = e22[9], t22[7] = e22[13], t22[8] = n22, t22[9] = s2, t22[11] = e22[14], t22[12] = i22, t22[13] = o2, t22[14] = a22;
        } else t22[0] = e22[0], t22[1] = e22[4], t22[2] = e22[8], t22[3] = e22[12], t22[4] = e22[1], t22[5] = e22[5], t22[6] = e22[9], t22[7] = e22[13], t22[8] = e22[2], t22[9] = e22[6], t22[10] = e22[10], t22[11] = e22[14], t22[12] = e22[3], t22[13] = e22[7], t22[14] = e22[11], t22[15] = e22[15];
        return t22;
      }, t2.ef = ug, t2.eg = b2, t2.eh = [1, 1, 1], t2.ei = function(t22, e22, n22, i22) {
        var s2 = new r2(4);
        return s2[0] = t22, s2[1] = e22, s2[2] = n22, s2[3] = i22, s2;
      }, t2.ej = q2, t2.ek = function(t22, e22, r22, n22) {
        var i22 = e22[0], s2 = e22[1], o2 = e22[2], a22 = e22[3];
        return t22[0] = i22 + n22 * (r22[0] - i22), t22[1] = s2 + n22 * (r22[1] - s2), t22[2] = o2 + n22 * (r22[2] - o2), t22[3] = a22 + n22 * (r22[3] - a22), t22;
      }, t2.el = Cg, t2.em = zg, t2.en = ga, t2.eo = Ea, t2.ep = function(t22, e22, n22, i22, s2, o2, a22, l22, u22, c22, h22, p22, f22, d22, m22, y22) {
        var g22 = new r2(16);
        return g22[0] = t22, g22[1] = e22, g22[2] = n22, g22[3] = i22, g22[4] = s2, g22[5] = o2, g22[6] = a22, g22[7] = l22, g22[8] = u22, g22[9] = c22, g22[10] = h22, g22[11] = p22, g22[12] = f22, g22[13] = d22, g22[14] = m22, g22[15] = y22, g22;
      }, t2.eq = Nl, t2.er = ka, t2.es = za, t2.et = class {
        constructor() {
          this._updateTime = 0, this._sourceIds = [], this._activeRegions = [], this._prevRegions = [], this._globalClipBounds = { min: new bt(1 / 0, 1 / 0), max: new bt(-1 / 0, -1 / 0) };
        }
        clear() {
          this._activeRegions.length > 0 && ++this._updateTime, this._activeRegions = [], this._prevRegions = [];
        }
        get updateTime() {
          return this._updateTime;
        }
        getReplacementRegionsForTile(t22, e22 = false) {
          const r22 = Vp(new bt(0, 0), new bt(Tn, Tn), t22), n22 = [];
          if (e22 && !Tp(r22, this._globalClipBounds)) return n22;
          for (const e3 of this._activeRegions) {
            if (e3.hiddenByOverlap) continue;
            if (!Tp(r22, e3)) continue;
            const i22 = Cp(e3.min, e3.max, t22);
            n22.push({ min: i22.min, max: i22.max, sourceId: this._sourceIds[e3.priority], footprint: e3.footprint, footprintTileId: e3.tileId, order: e3.order, clipMask: e3.clipMask, clipScope: e3.clipScope });
          }
          return n22;
        }
        setSources(t22) {
          this._setSources(t22.map((t3) => ({ getSourceId: () => t3.cache.id, getFootprints: () => {
            const e22 = [];
            for (const r22 of t3.cache.getVisibleCoordinates()) {
              const n22 = t3.cache.getTile(r22).buckets[t3.layer];
              n22 && n22.updateFootprints(r22.toUnwrapped(), e22);
            }
            return e22;
          }, getOrder: () => t3.order, getClipMask: () => t3.clipMask, getClipScope: () => t3.clipScope })));
        }
        _addSource(t22) {
          const e22 = t22.getFootprints();
          if (0 === e22.length) return;
          const r22 = t22.getOrder(), n22 = t22.getClipMask(), i22 = t22.getClipScope();
          for (const t3 of e22) {
            if (!t3.footprint) continue;
            const e3 = Vp(t3.footprint.min, t3.footprint.max, t3.id);
            this._activeRegions.push({ min: e3.min, max: e3.max, hiddenByOverlap: false, priority: this._sourceIds.length, tileId: t3.id, footprint: t3.footprint, order: r22, clipMask: n22, clipScope: i22 });
          }
          this._sourceIds.push(t22.getSourceId());
        }
        _computeReplacement() {
          this._activeRegions.sort((t3, e22) => t3.priority - e22.priority || Ep(t3.min, e22.min) || Ep(t3.max, e22.max) || t3.order - e22.order || t3.clipMask - e22.clipMask || function(t4, e3) {
            const r22 = (t5, e4) => t5 + e4;
            return t4.length - e3.length || t4.reduce(r22, "").localeCompare(e3.reduce(r22, ""));
          }(t3.clipScope, e22.clipScope));
          let t22 = this._activeRegions.length !== this._prevRegions.length;
          if (!t22) {
            let e22 = 0;
            for (; !t22 && e22 !== this._activeRegions.length; ) {
              const r22 = this._activeRegions[e22], n22 = this._prevRegions[e22];
              t22 = r22.priority !== n22.priority || !Pp(r22, n22) || r22.order !== n22.order || r22.clipMask !== n22.clipMask || !_t2(r22.clipScope, n22.clipScope), ++e22;
            }
          }
          if (t22) {
            ++this._updateTime;
            for (const t4 of this._activeRegions) t4.order !== zp && (this._globalClipBounds.min.x = Math.min(this._globalClipBounds.min.x, t4.min.x), this._globalClipBounds.min.y = Math.min(this._globalClipBounds.min.y, t4.min.y), this._globalClipBounds.max.x = Math.max(this._globalClipBounds.max.x, t4.max.x), this._globalClipBounds.max.y = Math.max(this._globalClipBounds.max.y, t4.max.y));
            const t3 = (t4) => {
              const e22 = this._activeRegions;
              if (t4 >= e22.length) return t4;
              const r22 = e22[t4].priority;
              for (; t4 < e22.length && e22[t4].priority === r22; ) ++t4;
              return t4;
            };
            if (this._sourceIds.length > 1) {
              let e22 = 0, r22 = t3(e22);
              for (; e22 !== r22; ) {
                let n22 = e22;
                const i22 = e22;
                for (; n22 !== r22; ) {
                  const t4 = this._activeRegions[n22];
                  t4.hiddenByOverlap = false;
                  for (let e3 = 0; e3 < i22; e3++) {
                    const r3 = this._activeRegions[e3];
                    if (!r3.hiddenByOverlap && t4.order === zp && Tp(t4, r3) && (t4.hiddenByOverlap = Fp(t4.footprint, t4.tileId, r3.footprint, r3.tileId), t4.hiddenByOverlap)) break;
                  }
                  ++n22;
                }
                e22 = r22, r22 = t3(e22);
              }
            }
          }
        }
        _setSources(t22) {
          [this._prevRegions, this._activeRegions] = [this._activeRegions, []], this._sourceIds = [];
          for (let e22 = t22.length - 1; e22 >= 0; e22--) this._addSource(t22[e22]);
          this._computeReplacement();
        }
      }, t2.eu = class {
        constructor(t22) {
          this._createGrid(t22), this._createPoles(t22);
        }
        destroy() {
          this._poleIndexBuffer.destroy(), this._gridBuffer.destroy(), this._gridIndexBuffer.destroy(), this._poleNorthVertexBuffer.destroy(), this._poleSouthVertexBuffer.destroy();
          for (const t22 of this._poleSegments) t22.destroy();
          for (const t22 of this._gridSegments) t22.withSkirts.destroy(), t22.withoutSkirts.destroy();
        }
        _fillGridMeshWithLods(t22, e22) {
          const r22 = new ea(), n22 = new wa(), i22 = [], s2 = t22 + 1 + 2, o2 = e22[0] + 1, a22 = e22[0] + 1 + (1 + e22.length), l22 = (t3, e3, r3) => {
            let n3 = t3 === s2 - 1 ? t3 - 2 : 0 === t3 ? t3 : t3 - 1;
            return n3 += r3 ? 24575 : 0, [n3, e3];
          };
          for (let t3 = 0; t3 < s2; ++t3) r22.emplaceBack(...l22(t3, 0, true));
          for (let t3 = 0; t3 < o2; ++t3) for (let e3 = 0; e3 < s2; ++e3) r22.emplaceBack(...l22(e3, t3, (0 === e3 || e3 === s2 - 1) && true));
          for (let t3 = 0; t3 < e22.length; ++t3) {
            const n3 = e22[t3];
            for (let t4 = 0; t4 < s2; ++t4) r22.emplaceBack(...l22(t4, n3, true));
          }
          for (let t3 = 0; t3 < e22.length; ++t3) {
            const o3 = n22.length, l3 = e22[t3] + 1 + 2, u22 = new wa();
            for (let r3 = 0; r3 < l3 - 1; r3++) {
              const i3 = r3 === l3 - 2, o4 = i3 ? s2 * (a22 - e22.length + t3 - r3) : s2;
              for (let t4 = 0; t4 < s2 - 1; t4++) {
                const e3 = r3 * s2 + t4;
                0 === r3 || i3 || 0 === t4 || t4 === s2 - 2 ? (u22.emplaceBack(e3 + 1, e3, e3 + o4), u22.emplaceBack(e3 + o4, e3 + o4 + 1, e3 + 1)) : (n22.emplaceBack(e3 + 1, e3, e3 + o4), n22.emplaceBack(e3 + o4, e3 + o4 + 1, e3 + 1));
              }
            }
            const c22 = Ka.simpleSegment(0, o3, r22.length, n22.length - o3);
            for (let t4 = 0; t4 < u22.uint16.length; t4 += 3) n22.emplaceBack(u22.uint16[t4], u22.uint16[t4 + 1], u22.uint16[t4 + 2]);
            const h22 = Ka.simpleSegment(0, o3, r22.length, n22.length - o3);
            i22.push({ withoutSkirts: c22, withSkirts: h22 });
          }
          return { vertices: r22, indices: n22, segments: i22 };
        }
        _createGrid(t22) {
          const e22 = this._fillGridMeshWithLods(Dl, Fl);
          this._gridSegments = e22.segments, this._gridBuffer = t22.createVertexBuffer(e22.vertices, Wu.members), this._gridIndexBuffer = t22.createIndexBuffer(e22.indices, true);
        }
        _createPoles(t22) {
          const e22 = new wa();
          for (let t3 = 0; t3 <= Dl; t3++) e22.emplaceBack(0, t3 + 1, t3 + 2);
          this._poleIndexBuffer = t22.createIndexBuffer(e22, true);
          const r22 = new Ia(), n22 = new Ia(), i22 = new Ia(), s2 = new Ia();
          this._poleSegments = [];
          for (let t3 = 0, e3 = 0; t3 < Bl; t3++) {
            const o2 = 360 / (1 << t3);
            r22.emplaceBack(0, -Tl, 0, 0.5, 0), n22.emplaceBack(0, -Tl, 0, 0.5, 1), i22.emplaceBack(0, -Tl, 0, 0.5, 0.5), s2.emplaceBack(0, -Tl, 0, 0.5, 0.5);
            for (let t4 = 0; t4 <= Dl; t4++) {
              let e4 = t4 / Dl, a22 = 0;
              const l22 = or(0, o2, e4), [u22, c22, h22] = Ol(kc, Ec, l22, Tl);
              r22.emplaceBack(u22, c22, h22, e4, a22), n22.emplaceBack(u22, c22, h22, e4, 1 - a22);
              const p22 = Mt(l22);
              e4 = 0.5 + 0.5 * Math.sin(p22), a22 = 0.5 + 0.5 * Math.cos(p22), i22.emplaceBack(u22, c22, h22, e4, a22), s2.emplaceBack(u22, c22, h22, e4, 1 - a22);
            }
            this._poleSegments.push(Ka.simpleSegment(e3, 0, 66, 64)), e3 += 66;
          }
          this._poleNorthVertexBuffer = t22.createVertexBuffer(r22, Xu, false), this._poleSouthVertexBuffer = t22.createVertexBuffer(n22, Xu, false), this._texturedPoleNorthVertexBuffer = t22.createVertexBuffer(i22, Xu, false), this._texturedPoleSouthVertexBuffer = t22.createVertexBuffer(s2, Xu, false);
        }
        getGridBuffers(t22, e22) {
          return [this._gridBuffer, this._gridIndexBuffer, e22 ? this._gridSegments[t22].withSkirts : this._gridSegments[t22].withoutSkirts];
        }
        getPoleBuffers(t22, e22) {
          return [e22 ? this._texturedPoleNorthVertexBuffer : this._poleNorthVertexBuffer, e22 ? this._texturedPoleSouthVertexBuffer : this._poleSouthVertexBuffer, this._poleIndexBuffer, this._poleSegments[t22]];
        }
      }, t2.ev = zp, t2.ew = kt, t2.ex = function() {
        return !!document.fullscreenElement || !!document.webkitFullscreenElement;
      }, t2.ey = Et, t2.ez = nu, t2.f = function(t22) {
        return 0 === t22.indexOf("mapbox:");
      }, t2.f0 = Fb, t2.f1 = Ff, t2.f2 = jh, t2.f3 = "hd_road_elevation", t2.f4 = Kh, t2.f5 = Ot2, t2.f6 = tp, t2.f7 = am, t2.f8 = sm, t2.f9 = function(t22, e22, r22, n22, i22, s2, o2, a22 = 1, l22, u22) {
        t22.createArrays(), t22.tilePixelRatio = Tn / (512 * t22.overscaling), t22.compareText = {}, t22.iconsNeedLinear = false;
        const c22 = t22.layers[0].layout, h22 = t22.layers[0]._unevaluatedLayout._values, p22 = {};
        p22.scaleFactor = a22, p22.textSizeScaleRange = c22.get("text-size-scale-range"), p22.iconSizeScaleRange = c22.get("icon-size-scale-range");
        const [f22, d22] = p22.textSizeScaleRange, [m22, y22] = p22.iconSizeScaleRange;
        p22.textScaleFactor = Pt(p22.scaleFactor, f22, d22), p22.iconScaleFactor = Pt(p22.scaleFactor, m22, y22);
        const g22 = h22["text-size"], x22 = h22["icon-size"];
        if ("composite" === t22.textSizeData.kind) {
          const { minZoom: e3, maxZoom: r3 } = t22.textSizeData;
          p22.compositeTextSizes = [g22.possiblyEvaluate(new yo(e3), s2), g22.possiblyEvaluate(new yo(r3), s2)];
        }
        if ("composite" === t22.iconSizeData.kind) {
          const { minZoom: e3, maxZoom: r3 } = t22.iconSizeData;
          p22.compositeIconSizes = [x22.possiblyEvaluate(new yo(e3), s2), x22.possiblyEvaluate(new yo(r3), s2)];
        }
        p22.layoutTextSize = g22.possiblyEvaluate(new yo(o2 + 1), s2), p22.layoutIconSize = x22.possiblyEvaluate(new yo(o2 + 1), s2), p22.textMaxSize = g22.possiblyEvaluate(new yo(18), s2);
        const v22 = c22.get("symbol-placement"), b22 = "map" === c22.get("text-rotation-alignment") && "point" !== v22, _22 = c22.get("text-size");
        let w22 = false;
        const A22 = [];
        for (const o3 of t22.features) {
          const a3 = c22.get("text-font").evaluate(o3, {}, s2).join(","), f3 = _22.evaluate(o3, {}, s2) * p22.textScaleFactor, d3 = p22.layoutTextSize.evaluate(o3, {}, s2) * p22.textScaleFactor, m3 = p22.layoutIconSize.evaluate(o3, {}, s2) * p22.iconScaleFactor, y3 = { horizontal: {}, vertical: void 0 }, g3 = o3.text;
          let x3, M22 = [0, 0];
          if (g3) {
            const n3 = g3.toString(), u3 = c22.get("text-letter-spacing").evaluate(o3, {}, s2) * cd, h3 = c22.get("text-line-height").evaluate(o3, {}, s2) * cd, p3 = Ws(n3) ? u3 : 0, m4 = c22.get("text-anchor").evaluate(o3, {}, s2), x4 = c22.get("text-variable-anchor");
            if (!x4) {
              const t3 = c22.get("text-radial-offset").evaluate(o3, {}, s2);
              if (t3) M22 = Em(m4, [t3 * cd, zm]);
              else {
                const t4 = c22.get("text-offset").evaluate(o3, {}, s2);
                M22 = [t4[0] * cd, t4[1] * cd];
              }
            }
            let _3 = b22 ? "center" : c22.get("text-justify").evaluate(o3, {}, s2);
            const w3 = "point" === v22, A3 = w3 ? c22.get("text-max-width").evaluate(o3, {}, s2) * cd : 1 / 0, I3 = (s3) => {
              t22.allowVerticalPlacement && Zs(n3) && (y3.vertical = Pd(g3, e22, r22, i22, a3, A3, h3, m4, s3, p3, M22, zd.vertical, true, d3, f3, l22));
            };
            if (!b22 && x4) {
              const t3 = "auto" === _3 ? x4.map((t4) => Fm(t4)) : [_3];
              let n4 = false;
              for (let s3 = 0; s3 < t3.length; s3++) {
                const o4 = t3[s3];
                if (!y3.horizontal[o4]) if (n4) y3.horizontal[o4] = y3.horizontal[0];
                else {
                  const t4 = Pd(g3, e22, r22, i22, a3, A3, h3, "center", o4, p3, M22, zd.horizontal, false, d3, f3, l22);
                  t4 && (y3.horizontal[o4] = t4, n4 = 1 === t4.positionedLines.length);
                }
              }
              I3("left");
            } else {
              if ("auto" === _3 && (_3 = Fm(m4)), w3 || c22.get("text-writing-mode").indexOf("horizontal") >= 0 || !Zs(n3)) {
                const t3 = Pd(g3, e22, r22, i22, a3, A3, h3, m4, _3, p3, M22, zd.horizontal, false, d3, f3, l22);
                t3 && (y3.horizontal[_3] = t3);
              }
              I3(w3 ? "left" : _3);
            }
          }
          let I2, S2, z22, k22, E22, P22, T2, B22 = false;
          if (o3.icon && o3.icon.hasPrimary()) {
            const e3 = Bm(o3.icon, t22.iconSizeData, h22["icon-size"], s2, t22.zoom, o3, l22, p22.iconScaleFactor);
            I2 = e3.iconPrimary, z22 = e3.iconSecondary;
            const r3 = I2.toString();
            if (S2 = n22.get(r3), S2 && (E22 = c22.get("icon-offset").evaluate(o3, {}, s2), P22 = c22.get("icon-anchor").evaluate(o3, {}, s2), T2 = c22.get("icon-text-fit").evaluate(o3, {}, s2), x3 = Nd(i22.get(r3), z22 ? i22.get(z22.toString()) : void 0, E22, P22), B22 = S2.sdf, void 0 === t22.sdfIcons ? t22.sdfIcons = S2.sdf : t22.sdfIcons !== S2.sdf && $t2("Style sheet warning: Cannot mix SDF and non-SDF icons in one buffer"), (S2.pixelRatio !== t22.pixelRatio || 0 !== c22.get("icon-rotate").constantOr(1)) && (t22.iconsNeedLinear = true)), z22) {
              const t3 = z22.toString();
              k22 = n22.get(t3);
            }
          }
          w22 = w22 || !(!o3.icon || !o3.icon.hasSecondary());
          const V2 = jm(y3.horizontal) || y3.vertical;
          t22.iconsInText || (t22.iconsInText = !!V2 && V2.iconsInText);
          const C22 = d3 * p22.textScaleFactor / cd, { defaultShapedIcon: D22, verticallyShapedIcon: F2 } = Lm(t22, x3, c22, o3, s2, y3, C22, E22, T2);
          "none" !== T2 && x3 && ($d(x3) || Gd(x3)) && (Pm(0, S2, I2, x3, D22, T2, u22, n22, i22), Pm(0, k22, z22, x3, D22, T2, u22, n22, i22), F2 && (Pm(0, S2, I2, x3, F2, T2, u22, n22, i22), Pm(0, k22, z22, x3, F2, T2, u22, n22, i22))), x3 = D22, A22.push({ feature: o3, shapedTextOrientations: y3, shapedText: V2, shapedIcon: x3, iconPrimary: I2, iconSecondary: z22, iconOffset: E22, iconAnchor: P22, verticallyShapedIcon: F2, layoutTextSize: d3, layoutIconSize: m3, textOffset: M22, isSDFIcon: B22, iconTextFit: T2 });
        }
        return { featureData: A22, sizes: p22, hasAnySecondaryIcon: w22, textAlongLine: b22, symbolPlacement: v22 };
      }, t2.fa = lm, t2.fb = function(t22, e22, r22, n22, i22, s2, o2, a22, l22, u22) {
        const { featureData: c22, hasAnySecondaryIcon: h22, sizes: p22, textAlongLine: f22, symbolPlacement: d22 } = e22;
        for (const e3 of c22) {
          const { shapedIcon: r3, verticallyShapedIcon: s3, feature: c3, shapedTextOrientations: m22, shapedText: y22, layoutTextSize: g22, textOffset: x22, isSDFIcon: v22, iconPrimary: b22, iconSecondary: _22, iconTextFit: w22, iconOffset: A22 } = e3;
          Vm(r3, u22.iconPositions, b22, _22), Vm(s3, u22.iconPositions, b22, _22), Cm(m22, u22.iconPositions), (y22 || r3) && Rm(t22, c3, m22, r3, s3, l22, p22, g22, 0, x22, v22, n22, i22, o2, a22, h22, w22, A22, f22, d22);
        }
        r22 && t22.generateCollisionDebugBuffers(s2, t22.collisionBoxArray, p22.textScaleFactor);
      }, t2.fc = Nh, t2.fd = av, t2.fe = vt, t2.ff = Uh, t2.fg = bd, t2.fh = dt, t2.fi = function(t22) {
        let e22 = 0;
        if (new Uint32Array(t22, 0, 1)[0] !== yb) {
          const r22 = new Uint32Array(t22, 0, 7), [, , n22, i22, s2, o2] = r22;
          e22 = r22.byteLength + i22 + s2 + o2 + s2, (n22 !== t22.byteLength || e22 >= t22.byteLength) && $t2("Invalid b3dm header information.");
        }
        return wb(t22, e22);
      }, t2.fj = function(t22, e22) {
        const r22 = Pb(t22);
        for (const t3 of r22) {
          for (const e3 of t3.meshes) Tb(e3);
          t3.lights && (t3.lightMeshIndex = t3.meshes.length, t3.meshes.push(Bb(t3.lights, e22)));
        }
        return r22;
      }, t2.fk = Ng, t2.fl = Xt2, t2.fm = Wg, t2.fn = mo, t2.fo = function(t22) {
        we(), null != ve && ve.then((e22) => {
          e22.keys().then((r22) => {
            for (let n22 = 0; n22 < r22.length - t22; n22++) e22.delete(r22[n22]).catch((t3) => $t2(t3.message));
          }).catch((t3) => $t2(t3.message));
        }).catch((t3) => $t2(t3.message));
      }, t2.g = function(t22, e22) {
        return Ce(Ct2(t22, { method: "GET" }), e22);
      }, t2.h = ne2, t2.i = function(t22) {
        return re.API_STYLE_REGEX.test(t22) && !ie2(t22);
      }, t2.j = function(t22) {
        return decodeURIComponent(atob(t22).split("").map((t3) => "%" + ("00" + t3.charCodeAt(0).toString(16)).slice(-2)).join(""));
      }, t2.k = function(t22) {
        return btoa(encodeURIComponent(t22).replace(/%([0-9A-F]{2})/g, (t3, e22) => String.fromCharCode(Number("0x" + e22))));
      }, t2.l = Ct2, t2.m = Me, t2.n = function(t22, e22) {
        return Ce(Ct2(t22, { type: "json" }), e22);
      }, t2.o = Ue, t2.p = function(t22, e22) {
        return Ce(Ct2(t22, { method: "POST" }), e22);
      }, t2.q = pe, t2.r = Hc, t2.s = function(t22) {
        try {
          const e22 = self[t22];
          return e22.setItem("_mapbox_test_", 1), e22.removeItem("_mapbox_test_"), true;
        } catch (t3) {
          return false;
        }
      }, t2.t = he, t2.u = function() {
        return function t22(e22) {
          return e22 ? (e22 ^ Math.random() * (16 >> e22 / 4)).toString(16) : ([1e7] + -[1e3] + -4e3 + -8e3 + -1e11).replace(/[018]/g, t22);
        }();
      }, t2.v = function(t22) {
        return !!t22 && /^[0-9a-f]{8}-[0-9a-f]{4}-[4][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}$/i.test(t22);
      }, t2.w = $t2, t2.x = function() {
        return ex || (ex = new Jg()), ex;
      }, t2.y = Wx, t2.z = Ye;
    });
    define2(["./shared"], function(e2) {
      function t2(e22) {
        const t22 = e22 ? e22.url.toString() : void 0;
        return t22 ? performance.getEntriesByName(t22) : [];
      }
      function s(e22) {
        if ("number" == typeof e22 || "boolean" == typeof e22 || "string" == typeof e22 || null == e22) return JSON.stringify(e22);
        if (Array.isArray(e22)) {
          let t3 = "[";
          for (const i22 of e22) t3 += `${s(i22)},`;
          return `${t3}]`;
        }
        let t22 = "{";
        for (const i22 of Object.keys(e22).sort()) t22 += `${i22}:${s(e22[i22])},`;
        return `${t22}}`;
      }
      function i2(t22) {
        let i22 = "";
        for (const o2 of e2.bu) ("model" !== t22.type || "minzoom" !== o2 && "maxzoom" !== o2) && (i22 += `/${s(t22[o2])}`);
        return i22;
      }
      class o {
        constructor(e22) {
          this.keyCache = {}, this._layers = {}, this._layerConfigs = {}, e22 && this.replace(e22);
        }
        replace(e22, t22) {
          this._layerConfigs = {}, this._layers = {}, this.update(e22, [], t22);
        }
        update(t22, o2, n22) {
          this._options = n22;
          for (const s2 of t22) this._layerConfigs[s2.id] = s2, (this._layers[s2.id] = e2.dc(s2, this.scope, null, this._options)).compileFilter(n22), this.keyCache[s2.id] && delete this.keyCache[s2.id];
          for (const e22 of o2) delete this.keyCache[e22], delete this._layerConfigs[e22], delete this._layers[e22];
          this.familiesBySource = {};
          const r22 = function(e22, t3) {
            const o3 = {};
            for (let n4 = 0; n4 < e22.length; n4++) {
              const r3 = e22[n4];
              let a22 = t3 && t3[r3.id];
              a22 || ("symbol" === r3.type ? a22 = r3.id : (a22 = i2(r3), "line" === r3.type && r3.paint && function e3(t4) {
                return "string" == typeof t4 && "line-progress" === t4 || (Array.isArray(t4) ? t4.some(e3) : !(!t4 || "object" != typeof t4) && Object.values(t4).some(e3));
              }(r3.paint["line-width"]) && (a22 += `/${s(r3.paint["line-width"])}`))), t3 && (t3[r3.id] = a22);
              let l22 = o3[a22];
              l22 || (l22 = o3[a22] = []), l22.push(r3);
            }
            const n3 = [];
            for (const e3 in o3) n3.push(o3[e3]);
            return n3;
          }(Object.values(this._layerConfigs), this.keyCache);
          for (const e22 of r22) {
            const t3 = e22.map((e3) => this._layers[e3.id]), s2 = t3[0];
            if ("none" === s2.visibility) continue;
            const i22 = s2.source || "";
            let o3 = this.familiesBySource[i22];
            o3 || (o3 = this.familiesBySource[i22] = {});
            const n3 = s2.sourceLayer || "_geojsonTileLayer";
            let r3 = o3[n3];
            r3 || (r3 = o3[n3] = []), r3.push(t3);
          }
        }
      }
      const n2 = 1 * e2.e_;
      class r2 {
        constructor(t22) {
          const s2 = {}, i22 = [];
          for (const e22 in t22) {
            const o3 = t22[e22], r3 = s2[e22] = {};
            for (const e3 in o3.glyphs) {
              const t3 = o3.glyphs[+e3];
              if (!t3 || 0 === t3.bitmap.width || 0 === t3.bitmap.height) continue;
              const s3 = t3.metrics.localGlyph ? n2 : 1, a3 = { x: 0, y: 0, w: t3.bitmap.width + 2 * s3, h: t3.bitmap.height + 2 * s3 };
              i22.push(a3), r3[e3] = a3;
            }
          }
          const { w: o2, h: r22 } = e2.H(i22), a22 = new e2.eZ({ width: o2 || 1, height: r22 || 1 });
          for (const i3 in t22) {
            const o3 = t22[i3];
            for (const t3 in o3.glyphs) {
              const r3 = o3.glyphs[+t3];
              if (!r3 || 0 === r3.bitmap.width || 0 === r3.bitmap.height) continue;
              const l22 = s2[i3][t3], c22 = r3.metrics.localGlyph ? n2 : 1;
              e2.eZ.copy(r3.bitmap, a22, { x: 0, y: 0 }, { x: l22.x + c22, y: l22.y + c22 }, r3.bitmap);
            }
          }
          this.image = a22, this.positions = s2;
        }
      }
      e2.eY(r2, "GlyphAtlas");
      class a2 {
        constructor(t22) {
          this.tileID = new e2.aM(t22.tileID.overscaledZ, t22.tileID.wrap, t22.tileID.canonical.z, t22.tileID.canonical.x, t22.tileID.canonical.y), this.tileZoom = t22.tileZoom, this.uid = t22.uid, this.zoom = t22.zoom, this.lut = t22.lut, this.canonical = t22.tileID.canonical, this.pixelRatio = t22.pixelRatio, this.tileSize = t22.tileSize, this.source = t22.source, this.scope = t22.scope, this.overscaling = this.tileID.overscaleFactor(), this.showCollisionBoxes = t22.showCollisionBoxes, this.collectResourceTiming = !!t22.request && t22.request.collectResourceTiming, this.promoteId = t22.promoteId, this.isSymbolTile = t22.isSymbolTile, this.tileTransform = e2.aW(t22.tileID.canonical, t22.projection), this.projection = t22.projection, this.worldview = t22.worldview, this.localizableLayerIds = t22.localizableLayerIds, this.brightness = t22.brightness, this.extraShadowCaster = !!t22.extraShadowCaster, this.tessellationStep = t22.tessellationStep, this.scaleFactor = t22.scaleFactor;
        }
        parse(t22, s2, i22, o2, n22, a22) {
          this.status = "parsing", this.data = t22, this.collisionBoxArray = new e2.b0();
          const c22 = new e2.e$(Object.keys(t22.layers).sort()), h22 = new e2.f0(this.tileID, this.promoteId);
          h22.bucketLayerIDs = [];
          const u22 = {}, d22 = new e2.f1(256, 256), f22 = { featureIndex: h22, iconDependencies: /* @__PURE__ */ new Map(), patternDependencies: /* @__PURE__ */ new Map(), glyphDependencies: {}, lineAtlas: d22, availableImages: i22, brightness: this.brightness, scaleFactor: this.scaleFactor, elevationFeatures: void 0 }, p22 = s2.familiesBySource[this.source];
          for (const s3 in p22) {
            const n3 = t22.layers[s3];
            if (!n3) continue;
            let r22 = false, a3 = false, d3 = false;
            for (const e22 of p22[s3]) "symbol" === e22[0].type ? r22 = true : a3 = true, e22[0].is3D() && "model" !== e22[0].type && (d3 = true);
            if (this.extraShadowCaster && !d3) continue;
            if (true === this.isSymbolTile && !r22) continue;
            if (false === this.isSymbolTile && !a3) continue;
            1 === n3.version && e2.w(`Vector tile source "${this.source}" layer "${s3}" does not use vector tile spec v2 and therefore may have some rendering errors.`);
            const g3 = c22.encode(s3), m3 = [];
            let y3 = false;
            for (let t3 = 0, i3 = 0; t3 < n3.length; t3++) {
              const o3 = n3.feature(t3), r3 = h22.getId(o3, s3);
              if (this.localizableLayerIds && this.localizableLayerIds.has(s3)) {
                const e22 = o3.properties ? o3.properties.worldview : null;
                if (this.worldview && "string" == typeof e22) if ("all" === e22) o3.properties.$localized = true;
                else {
                  if (!e22.split(",").includes(this.worldview)) continue;
                  o3.properties.$localized = true, o3.properties.worldview = this.worldview;
                }
              }
              !y3 && o3.properties && o3.properties.hasOwnProperty(e2.f2) && (y3 = true), m3.push({ feature: o3, id: r3, index: i3, sourceLayerIndex: g3 }), i3++;
            }
            y3 && !f22.elevationFeatures && t22.layers.hasOwnProperty(e2.f3) && (f22.elevationFeatures = e2.f4.parseFrom(t22.layers[e2.f3], this.canonical));
            for (const t3 of p22[s3]) {
              const s4 = t3[0];
              (!this.extraShadowCaster || s4.is3D() && "model" !== s4.type) && (void 0 !== this.isSymbolTile && "symbol" === s4.type !== this.isSymbolTile || s4.minzoom && this.zoom < Math.floor(s4.minzoom) || s4.maxzoom && this.zoom >= s4.maxzoom || "none" !== s4.visibility && (l2(t3, this.zoom, f22.brightness, i22), (u22[s4.id] = s4.createBucket({ index: h22.bucketLayerIDs.length, layers: t3, zoom: this.zoom, lut: this.lut, canonical: this.canonical, pixelRatio: this.pixelRatio, overscaling: this.overscaling, collisionBoxArray: this.collisionBoxArray, sourceLayerIndex: g3, sourceID: this.source, projection: this.projection.spec, tessellationStep: this.tessellationStep, styleDefinedModelURLs: o2 })).populate(m3, f22, this.tileID.canonical, this.tileTransform), h22.bucketLayerIDs.push(t3.map((t4) => e2.C(t4.id, t4.scope)))));
            }
          }
          let g22, m22, y22, w22, x22, b22;
          d22.trim();
          const v22 = { type: "maybePrepare", isSymbolTile: this.isSymbolTile, zoom: this.zoom }, I2 = () => {
            if (g22) return this.status = "done", a22(g22);
            if (this.extraShadowCaster) this.status = "done", a22(null, { buckets: Object.values(u22).filter((e22) => !e22.isEmpty()), featureIndex: h22, collisionBoxArray: null, glyphAtlasImage: null, lineAtlas: null, imageAtlas: null, brightness: f22.brightness, glyphMap: null, iconMap: null, glyphPositions: null });
            else if (m22 && y22 && w22) {
              const t3 = new r2(m22), s3 = /* @__PURE__ */ new Map();
              for (const [t4, i3] of y22.entries()) {
                const { imagePosition: o4 } = e2.f7(t4, i3, e2.f8);
                s3.set(t4, o4);
              }
              const o3 = {};
              for (const n3 in u22) {
                const r22 = u22[n3];
                r22 instanceof e2.b1 && (l2(r22.layers, this.zoom, f22.brightness, i22), o3[n3] = e2.f9(r22, m22, t3.positions, y22, s3, this.tileID.canonical, this.tileZoom, this.scaleFactor, this.pixelRatio, x22));
              }
              const a3 = { iconsPending: true, patternsPending: true };
              this.rasterizeIfNeeded(n22, y22, x22, () => {
                a3.iconsPending = false, M22(o3, t3, a3);
              }), this.rasterizeIfNeeded(n22, w22, b22, () => {
                a3.patternsPending = false, M22(o3, t3, a3);
              });
            }
          }, M22 = (t3, s3, o3, n3) => {
            if (o3.iconsPending || o3.patternsPending) return;
            const r22 = new e2.fa(y22, w22, this.lut);
            for (const s4 in u22) {
              const o4 = u22[s4];
              if (s4 in t3) e2.fb(o4, t3[s4], this.showCollisionBoxes, i22, this.tileID.canonical, this.tileZoom, this.projection, this.brightness, y22, r22);
              else if (o4.hasPattern && (o4 instanceof e2.b7 || o4 instanceof e2.b8 || o4 instanceof e2.dV)) {
                l2(o4.layers, this.zoom, f22.brightness, i22);
                const e22 = Object.fromEntries(r22.patternPositions);
                o4.addFeatures(f22, this.tileID.canonical, e22, i22, this.tileTransform, this.brightness);
              }
            }
            this.status = "done", a22(null, { buckets: Object.values(u22).filter((e22) => !e22.isEmpty()), featureIndex: h22, collisionBoxArray: this.collisionBoxArray, glyphAtlasImage: s3.image, lineAtlas: d22, imageAtlas: r22, brightness: f22.brightness });
          };
          if (!this.extraShadowCaster) {
            const t3 = e2.f5(f22.glyphDependencies, (e22) => Object.keys(e22).map(Number));
            Object.keys(t3).length ? n22.send("getGlyphs", { uid: this.uid, stacks: t3, scope: this.scope }, (e22, t4) => {
              g22 || (g22 = e22, m22 = t4, I2());
            }, void 0, false, v22) : m22 = {};
            const s3 = Array.from(f22.iconDependencies.keys()).map((t4) => e2.I.parse(t4));
            s3.length ? n22.send("getImages", { images: s3, source: this.source, scope: this.scope, tileID: this.tileID, type: "icons" }, (e22, t4) => {
              g22 || (g22 = e22, y22 = /* @__PURE__ */ new Map(), x22 = this.updateImageMapAndGetImageTaskQueue(y22, t4, f22.iconDependencies), I2());
            }, void 0, false, v22) : (y22 = /* @__PURE__ */ new Map(), x22 = /* @__PURE__ */ new Map());
            const i3 = Array.from(f22.patternDependencies.keys()).map((t4) => e2.I.parse(t4));
            i3.length ? n22.send("getImages", { images: i3, source: this.source, scope: this.scope, tileID: this.tileID, type: "patterns" }, (e22, t4) => {
              g22 || (g22 = e22, w22 = /* @__PURE__ */ new Map(), b22 = this.updateImageMapAndGetImageTaskQueue(w22, t4, f22.patternDependencies), I2());
            }, void 0, false, v22) : (w22 = /* @__PURE__ */ new Map(), b22 = /* @__PURE__ */ new Map());
          }
          if (f22.elevationFeatures && f22.elevationFeatures.length > 0) {
            const t3 = [];
            for (const s4 of Object.values(u22)) if (s4 instanceof e2.b8) {
              const e22 = s4.getUnevaluatedPortalGraph();
              e22 && t3.push(e22);
            }
            const s3 = e2.f6.evaluate(t3);
            for (const t4 of Object.values(u22)) t4 instanceof e2.b8 && t4.setEvaluatedPortalGraph(s3);
          }
          I2();
        }
        rasterizeIfNeeded(e22, t22, s2, i22) {
          Array.from(t22.values()).some((e3) => e3.usvg) ? this.rasterize(e22, t22, s2, i22) : i22();
        }
        updateImageMapAndGetImageTaskQueue(e22, t22, s2) {
          const i22 = /* @__PURE__ */ new Map();
          for (const o2 of t22.keys()) {
            const n22 = s2.get(o2) || [];
            for (const s3 of n22) {
              const o3 = s3.toString(), n3 = t22.get(s3.id.toString());
              n3.usvg ? i22.has(o3) || (i22.set(o3, s3), e22.set(o3, Object.assign({}, n3))) : e22.set(o3, n3);
            }
          }
          return i22;
        }
        rasterize(e22, t22, s2, i22) {
          this.rasterizeTask = e22.send("rasterizeImages", { scope: this.scope, tasks: s2 }, (e3, s3) => {
            if (!e3) for (const [e4, i3] of s3.entries()) {
              const s4 = Object.assign(t22.get(e4), { data: i3 });
              t22.set(e4, s4);
            }
            i22();
          });
        }
        cancelRasterize() {
          this.rasterizeTask && this.rasterizeTask.cancel();
        }
      }
      function l2(t22, s2, i22, o2) {
        const n22 = new e2.aa(s2, { brightness: i22 });
        for (const e22 of t22) e22.recalculate(n22, o2);
      }
      class c2 extends e2.E {
        constructor(t22, s2, i22, o2, n22, r22, a22) {
          super(), this.actor = t22, this.layerIndex = s2, this.availableImages = i22, this.availableModels = o2, this.loadVectorData = r22 || e2.aJ, this.loading = {}, this.loaded = {}, this.deduped = new e2.aI(t22.scheduler), this.isSpriteLoaded = n22, this.scheduler = t22.scheduler, this.brightness = a22;
        }
        loadTile(s2, i22) {
          const o2 = s2.uid, n22 = s2 && s2.request, r22 = n22 && n22.collectResourceTiming, l22 = this.loading[o2] = new a2(s2);
          l22.abort = this.loadVectorData(s2, (a22, c22) => {
            const h22 = !this.loading[o2];
            if (delete this.loading[o2], l22.cancelRasterize(), h22 || a22 || !c22) return l22.status = "done", h22 || (this.loaded[o2] = l22), i22(a22);
            const u22 = c22.rawData, d22 = {};
            c22.expires && (d22.expires = c22.expires), c22.cacheControl && (d22.cacheControl = c22.cacheControl), l22.vectorTile = c22.vectorTile || new e2.fc.VectorTile(new e2.bq(u22));
            const f22 = () => {
              l22.parse(l22.vectorTile, this.layerIndex, this.availableImages, this.availableModels, this.actor, (s3, o3) => {
                if (s3 || !o3) return i22(s3);
                const a3 = {};
                if (r22) {
                  const e22 = t2(n22);
                  e22.length > 0 && (a3.resourceTiming = JSON.parse(JSON.stringify(e22)));
                }
                i22(null, e2.l({ rawTileData: u22.slice(0) }, o3, d22, a3));
              });
            };
            this.isSpriteLoaded ? f22() : this.once("isSpriteLoaded", () => {
              this.scheduler ? this.scheduler.add(f22, { type: "parseTile", isSymbolTile: s2.isSymbolTile, zoom: s2.tileZoom }) : f22();
            }), this.loaded = this.loaded || {}, this.loaded[o2] = l22;
          });
        }
        reloadTile(t22, s2) {
          const i22 = this.loaded, o2 = t22.uid;
          if (i22 && i22[o2]) {
            const n22 = i22[o2];
            n22.scaleFactor = t22.scaleFactor, n22.showCollisionBoxes = t22.showCollisionBoxes, n22.projection = t22.projection, n22.brightness = t22.brightness, n22.tileTransform = e2.aW(t22.tileID.canonical, t22.projection), n22.extraShadowCaster = t22.extraShadowCaster, n22.lut = t22.lut;
            const r22 = (e22, t3) => {
              const i3 = n22.reloadCallback;
              i3 && (delete n22.reloadCallback, n22.parse(n22.vectorTile, this.layerIndex, this.availableImages, this.availableModels, this.actor, i3)), s2(e22, t3);
            };
            "parsing" === n22.status ? n22.reloadCallback = r22 : "done" === n22.status && (n22.vectorTile ? n22.parse(n22.vectorTile, this.layerIndex, this.availableImages, this.availableModels, this.actor, r22) : r22());
          } else s2(null, void 0);
        }
        abortTile(e22, t22) {
          const s2 = e22.uid, i22 = this.loading[s2];
          i22 && (i22.abort && i22.abort(), delete this.loading[s2]), t22();
        }
        removeTile(e22, t22) {
          const s2 = this.loaded, i22 = e22.uid;
          s2 && s2[i22] && delete s2[i22], t22();
        }
      }
      class h2 {
        loadTile(t22, s2) {
          const { uid: i22, encoding: o2, rawImageData: n22, padding: r22 } = t22, a22 = ImageBitmap && n22 instanceof ImageBitmap ? this.getImageData(n22, r22) : n22;
          s2(null, new e2.fd(i22, a22, o2, r22 < 1));
        }
        reloadTile(e22, t22) {
          t22(null, null);
        }
        abortTile(e22, t22) {
          t22();
        }
        removeTile(e22, t22) {
          t22();
        }
        getImageData(e22, t22) {
          this.offscreenCanvas && this.offscreenCanvasContext || (this.offscreenCanvas = new OffscreenCanvas(e22.width, e22.height), this.offscreenCanvasContext = this.offscreenCanvas.getContext("2d", { willReadFrequently: true })), this.offscreenCanvas.width = e22.width, this.offscreenCanvas.height = e22.height, this.offscreenCanvasContext.drawImage(e22, 0, 0, e22.width, e22.height);
          const s2 = this.offscreenCanvasContext.getImageData(-t22, -t22, e22.width + 2 * t22, e22.height + 2 * t22);
          return this.offscreenCanvasContext.clearRect(0, 0, this.offscreenCanvas.width, this.offscreenCanvas.height), s2;
        }
      }
      e2.bp.setPbf(e2.bq);
      class u2 {
        constructor(t22) {
          this._mrt = new e2.bp(t22.partial ? 30 : 1 / 0), this._isHeaderLoaded = false, this.uid = t22.uid, this.tileID = t22.tileID, this.source = t22.source;
        }
        parse(t22, s2) {
          const i22 = this._mrt;
          this.status = "parsing", this._entireBuffer = t22;
          try {
            i22.parseHeader(t22), this._isHeaderLoaded = true;
            const o2 = [];
            for (const s3 in i22.layers) {
              const n22 = i22.getLayer(s3), r22 = n22.getDataRange(n22.getBandList()), a22 = i22.createDecodingTask(r22), l22 = t22.slice(r22.firstByte, r22.lastByte + 1), c22 = e2.bp.performDecoding(l22, a22).then((e22) => a22.complete(null, e22)).catch((e22) => a22.complete(e22, null));
              o2.push(c22);
            }
            Promise.allSettled(o2).then(() => s2(null, i22)).catch((e22) => s2(e22));
          } catch (e22) {
            s2(e22);
          }
        }
      }
      class d2 {
        constructor(e22) {
          this.actor = e22, this.loading = {}, this.loaded = {};
        }
        loadTile(t22, s2) {
          const i22 = t22.uid, o2 = t22.request, n22 = this.loading[i22] = new u2(t22), { cancel: r22 } = e2.br(o2, (e22, t3, o3, r3) => {
            const a22 = !this.loading[i22];
            if (delete this.loading[i22], a22 || e22 || !t3) return n22.status = "done", a22 || (this.loaded[i22] = n22), s2(e22);
            n22.parse(t3, (e3, t4) => {
              if (e3 || !t4) return s2(e3);
              s2(null, t4, o3, r3);
            }), this.loaded[i22] = n22;
          });
          n22.abort = r22;
        }
        reloadTile(e22, t22) {
          t22(null, void 0);
        }
        abortTile(e22, t22) {
          const s2 = e22.uid, i22 = this.loading[s2];
          i22 && (i22.abort && i22.abort(), delete this.loading[s2]), t22();
        }
        removeTile(e22, t22) {
          const s2 = e22.uid;
          this.loaded[s2] && delete this.loaded[s2], t22();
        }
        decodeRasterArray(t22, s2) {
          e2.bp.performDecoding(t22.buffer, t22.task).then((e22) => s2(null, e22)).catch((e22) => s2(e22));
        }
      }
      const f2 = e2.fc.VectorTileFeature.prototype.toGeoJSON;
      class p2 {
        constructor(t22) {
          this._feature = t22, this.extent = e2.aj, this.type = t22.type, this.properties = t22.tags, "id" in t22 && !isNaN(t22.id) && (this.id = parseInt(t22.id, 10));
        }
        loadGeometry() {
          if (1 === this._feature.type) {
            const t22 = [];
            for (const s2 of this._feature.geometry) t22.push([new e2.P(s2[0], s2[1])]);
            return t22;
          }
          {
            const t22 = [];
            for (const s2 of this._feature.geometry) {
              const i22 = [];
              for (const t3 of s2) i22.push(new e2.P(t3[0], t3[1]));
              t22.push(i22);
            }
            return t22;
          }
        }
        toGeoJSON(e22, t22, s2) {
          return f2.call(this, e22, t22, s2);
        }
      }
      class g2 {
        constructor(t22) {
          this.layers = { _geojsonTileLayer: this }, this.name = "_geojsonTileLayer", this.extent = e2.aj, this.length = t22.length, this._features = t22;
        }
        feature(e22) {
          return new p2(this._features[e22]);
        }
      }
      const m2 = 64 / 4096, y2 = 128;
      class w2 {
        constructor() {
          this.features = /* @__PURE__ */ new Map();
        }
        clear() {
          this.features.clear();
        }
        load(e22 = [], t22) {
          for (const s2 of e22) {
            const e3 = s2.id;
            if (null == e3) continue;
            let i22 = this.features.get(e3);
            i22 && this.updateCache(i22, t22), s2.geometry ? (i22 = b2(s2), this.updateCache(i22, t22), this.features.set(e3, i22)) : this.features.delete(e3), this.updateCache(i22, t22);
          }
        }
        updateCache(e22, t22) {
          for (const { canonical: s2, uid: i22 } of Object.values(t22)) {
            const { z: o2, x: n22, y: r22 } = s2;
            x2(e22, Math.pow(2, o2), n22, r22) && delete t22[i22];
          }
        }
        getTile(e22, t22, s2) {
          const i22 = Math.pow(2, e22), o2 = [];
          for (const e3 of this.features.values()) x2(e3, i22, t22, s2) && o2.push(S(e3, i22, t22, s2));
          return { features: o2 };
        }
        getFeatures() {
          return [...this.features.values()];
        }
      }
      function x2({ minX: e22, minY: t22, maxX: s2, maxY: i22 }, o2, n22, r22) {
        return e22 < (n22 + 1 + m2) / o2 && t22 < (r22 + 1 + m2) / o2 && s2 > (n22 - m2) / o2 && i22 > (r22 - m2) / o2;
      }
      function b2(e22) {
        const { id: t22, geometry: s2, properties: i22 } = e22;
        if (!s2) return;
        if ("GeometryCollection" === s2.type) throw new Error("GeometryCollection not supported in dynamic mode.");
        const { type: o2, coordinates: n22 } = s2, r22 = { id: t22, type: 1, geometry: [], tags: i22, minX: 1 / 0, minY: 1 / 0, maxX: -1 / 0, maxY: -1 / 0 }, a22 = r22.geometry;
        if ("Point" === o2) v2(n22, a22, r22);
        else if ("MultiPoint" === o2) for (const e3 of n22) v2(e3, a22, r22);
        else if ("LineString" === o2) r22.type = 2, I(n22, a22, r22);
        else if ("MultiLineString" === o2) r22.type = 2, M2(n22, a22, r22);
        else if ("Polygon" === o2) r22.type = 3, M2(n22, a22, r22, true);
        else {
          if ("MultiPolygon" !== o2) throw new Error("Input data is not a valid GeoJSON object.");
          r22.type = 3;
          for (const e3 of n22) M2(e3, a22, r22, true);
        }
        return r22;
      }
      function v2([t22, s2], i22, o2) {
        const n22 = e2.ay(t22);
        let r22 = e2.aH(s2);
        r22 = r22 < 0 ? 0 : r22 > 1 ? 1 : r22, i22.push(n22, r22), o2.minX = Math.min(o2.minX, n22), o2.minY = Math.min(o2.minY, r22), o2.maxX = Math.max(o2.maxX, n22), o2.maxY = Math.max(o2.maxY, r22);
      }
      function I(e22, t22, s2, i22 = false, o2 = false) {
        const n22 = [];
        for (const t3 of e22) v2(t3, n22, s2);
        t22.push(n22), i22 && function(e3, t3) {
          let s3 = 0;
          for (let t4 = 0, i3 = e3.length, o3 = i3 - 2; t4 < i3; o3 = t4, t4 += 2) s3 += (e3[t4] - e3[o3]) * (e3[t4 + 1] + e3[o3 + 1]);
          if (s3 > 0 === t3) for (let t4 = 0, s4 = e3.length; t4 < s4 / 2; t4 += 2) {
            const i3 = e3[t4], o3 = e3[t4 + 1];
            e3[t4] = e3[s4 - 2 - t4], e3[t4 + 1] = e3[s4 - 1 - t4], e3[s4 - 2 - t4] = i3, e3[s4 - 1 - t4] = o3;
          }
        }(n22, o2);
      }
      function M2(e22, t22, s2, i22 = false) {
        for (let o2 = 0; o2 < e22.length; o2++) I(e22[o2], t22, s2, i22, 0 === o2);
      }
      function S(t22, s2, i22, o2) {
        const { id: n22, type: r22, geometry: a22, tags: l22 } = t22, c22 = [];
        if (1 === r22) !function(t3, s3, i3, o3, n3) {
          for (let r3 = 0; r3 < t3.length; r3 += 2) {
            const a3 = Math.round(e2.aj * (t3[r3 + 0] * s3 - i3)), l3 = Math.round(e2.aj * (t3[r3 + 1] * s3 - o3));
            n3.push([a3, l3]);
          }
        }(a22, s2, i22, o2, c22);
        else for (const e22 of a22) T(e22, s2, i22, o2, c22);
        return { id: n22, type: r22, geometry: c22, tags: l22 };
      }
      function T(t22, s2, i22, o2, n22) {
        const r22 = -y2, a22 = e2.aj + y2;
        let l22;
        for (let c22 = 0; c22 < t22.length - 2; c22 += 2) {
          let h22 = Math.round(e2.aj * (t22[c22 + 0] * s2 - i22)), u22 = Math.round(e2.aj * (t22[c22 + 1] * s2 - o2)), d22 = Math.round(e2.aj * (t22[c22 + 2] * s2 - i22)), f22 = Math.round(e2.aj * (t22[c22 + 3] * s2 - o2));
          const p22 = d22 - h22, g22 = f22 - u22;
          h22 < r22 && d22 < r22 || (h22 < r22 ? (u22 += Math.round(g22 * ((r22 - h22) / p22)), h22 = r22) : d22 < r22 && (f22 = u22 + Math.round(g22 * ((r22 - h22) / p22)), d22 = r22), u22 < r22 && f22 < r22 || (u22 < r22 ? (h22 += Math.round(p22 * ((r22 - u22) / g22)), u22 = r22) : f22 < r22 && (d22 = h22 + Math.round(p22 * ((r22 - u22) / g22)), f22 = r22), h22 >= a22 && d22 >= a22 || (h22 >= a22 ? (u22 += Math.round(g22 * ((a22 - h22) / p22)), h22 = a22) : d22 >= a22 && (f22 = u22 + Math.round(g22 * ((a22 - h22) / p22)), d22 = a22), u22 >= a22 && f22 >= a22 || (u22 >= a22 ? (h22 += Math.round(p22 * ((a22 - u22) / g22)), u22 = a22) : f22 >= a22 && (d22 = h22 + Math.round(p22 * ((a22 - u22) / g22)), f22 = a22), l22 && h22 === l22[l22.length - 1][0] && u22 === l22[l22.length - 1][1] || (l22 = [[h22, u22]], n22.push(l22)), l22.push([d22, f22])))));
        }
      }
      var P2, k2, C, _2 = { exports: {} }, L2 = function() {
        if (C) return _2.exports;
        C = 1;
        var t22 = e2.fg(), s2 = function() {
          if (k2) return P2;
          k2 = 1;
          var t3 = e2.fe(), s3 = e2.ff().VectorTileFeature;
          function i3(e22, t4) {
            this.options = t4 || {}, this.features = e22, this.length = e22.length;
          }
          function o3(e22, t4) {
            this.id = "number" == typeof e22.id ? e22.id : void 0, this.type = e22.type, this.rawGeometry = 1 === e22.type ? [e22.geometry] : e22.geometry, this.properties = e22.tags, this.extent = t4 || 4096;
          }
          return P2 = i3, i3.prototype.feature = function(e22) {
            return new o3(this.features[e22], this.options.extent);
          }, o3.prototype.loadGeometry = function() {
            var e22 = this.rawGeometry;
            this.geometry = [];
            for (var s4 = 0; s4 < e22.length; s4++) {
              for (var i4 = e22[s4], o4 = [], n3 = 0; n3 < i4.length; n3++) o4.push(new t3(i4[n3][0], i4[n3][1]));
              this.geometry.push(o4);
            }
            return this.geometry;
          }, o3.prototype.bbox = function() {
            this.geometry || this.loadGeometry();
            for (var e22 = this.geometry, t4 = 1 / 0, s4 = -1 / 0, i4 = 1 / 0, o4 = -1 / 0, n3 = 0; n3 < e22.length; n3++) for (var r3 = e22[n3], a3 = 0; a3 < r3.length; a3++) {
              var l3 = r3[a3];
              t4 = Math.min(t4, l3.x), s4 = Math.max(s4, l3.x), i4 = Math.min(i4, l3.y), o4 = Math.max(o4, l3.y);
            }
            return [t4, i4, s4, o4];
          }, o3.prototype.toGeoJSON = s3.prototype.toGeoJSON, P2;
        }();
        function i22(e22) {
          var s3 = new t22();
          return function(e3, t3) {
            for (var s4 in e3.layers) t3.writeMessage(3, o2, e3.layers[s4]);
          }(e22, s3), s3.finish();
        }
        function o2(e22, t3) {
          var s3;
          t3.writeVarintField(15, e22.version || 1), t3.writeStringField(1, e22.name || ""), t3.writeVarintField(5, e22.extent || 4096);
          var i3 = { keys: [], values: [], keycache: {}, valuecache: {} };
          for (s3 = 0; s3 < e22.length; s3++) i3.feature = e22.feature(s3), t3.writeMessage(2, n22, i3);
          var o3 = i3.keys;
          for (s3 = 0; s3 < o3.length; s3++) t3.writeStringField(3, o3[s3]);
          var r3 = i3.values;
          for (s3 = 0; s3 < r3.length; s3++) t3.writeMessage(4, h22, r3[s3]);
        }
        function n22(e22, t3) {
          var s3 = e22.feature;
          void 0 !== s3.id && t3.writeVarintField(1, s3.id), t3.writeMessage(2, r22, e22), t3.writeVarintField(3, s3.type), t3.writeMessage(4, c22, s3);
        }
        function r22(e22, t3) {
          var s3 = e22.feature, i3 = e22.keys, o3 = e22.values, n3 = e22.keycache, r3 = e22.valuecache;
          for (var a3 in s3.properties) {
            var l3 = s3.properties[a3], c3 = n3[a3];
            if (null !== l3) {
              void 0 === c3 && (i3.push(a3), n3[a3] = c3 = i3.length - 1), t3.writeVarint(c3);
              var h3 = typeof l3;
              "string" !== h3 && "boolean" !== h3 && "number" !== h3 && (l3 = JSON.stringify(l3));
              var u22 = h3 + ":" + l3, d22 = r3[u22];
              void 0 === d22 && (o3.push(l3), r3[u22] = d22 = o3.length - 1), t3.writeVarint(d22);
            }
          }
        }
        function a22(e22, t3) {
          return (t3 << 3) + (7 & e22);
        }
        function l22(e22) {
          return e22 << 1 ^ e22 >> 31;
        }
        function c22(e22, t3) {
          for (var s3 = e22.loadGeometry(), i3 = e22.type, o3 = 0, n3 = 0, r3 = s3.length, c3 = 0; c3 < r3; c3++) {
            var h3 = s3[c3], u22 = 1;
            1 === i3 && (u22 = h3.length), t3.writeVarint(a22(1, u22));
            for (var d22 = 3 === i3 ? h3.length - 1 : h3.length, f22 = 0; f22 < d22; f22++) {
              1 === f22 && 1 !== i3 && t3.writeVarint(a22(2, d22 - 1));
              var p22 = h3[f22].x - o3, g22 = h3[f22].y - n3;
              t3.writeVarint(l22(p22)), t3.writeVarint(l22(g22)), o3 += p22, n3 += g22;
            }
            3 === i3 && t3.writeVarint(a22(7, 1));
          }
        }
        function h22(e22, t3) {
          var s3 = typeof e22;
          "string" === s3 ? t3.writeStringField(1, e22) : "boolean" === s3 ? t3.writeBooleanField(7, e22) : "number" === s3 && (e22 % 1 != 0 ? t3.writeDoubleField(3, e22) : e22 < 0 ? t3.writeSVarintField(6, e22) : t3.writeVarintField(5, e22));
        }
        return _2.exports = i22, _2.exports.fromVectorTileJs = i22, _2.exports.fromGeojsonVt = function(e22, t3) {
          t3 = t3 || {};
          var o3 = {};
          for (var n3 in e22) o3[n3] = new s2(e22[n3].features, t3), o3[n3].name = n3, o3[n3].version = t3.version, o3[n3].extent = t3.extent;
          return i22({ layers: o3 });
        }, _2.exports.GeoJSONWrapper = s2, _2.exports;
      }(), j2 = e2.fh(L2);
      const z2 = { minZoom: 0, maxZoom: 16, minPoints: 2, radius: 40, extent: 512, nodeSize: 64, log: false, generateId: false, reduce: null, map: (e22) => e22 }, D2 = Math.fround || (O = new Float32Array(1), (e22) => (O[0] = +e22, O[0]));
      var O;
      const F = 3, A2 = 5, Z = 6;
      class N2 {
        constructor(e22) {
          this.options = Object.assign(Object.create(z2), e22), this.trees = new Array(this.options.maxZoom + 1), this.stride = this.options.reduce ? 7 : 6, this.clusterProps = [];
        }
        load(e22) {
          const { log: t22, minZoom: s2, maxZoom: i22 } = this.options;
          t22 && console.time("total time");
          const o2 = `prepare ${e22.length} points`;
          t22 && console.time(o2), this.points = e22;
          const n22 = [];
          for (let t3 = 0; t3 < e22.length; t3++) {
            const s3 = e22[t3];
            if (!s3.geometry) continue;
            const [i3, o3] = s3.geometry.coordinates, r3 = D2(X2(i3)), a22 = D2(Y(o3));
            n22.push(r3, a22, 1 / 0, t3, -1, 1), this.options.reduce && n22.push(0);
          }
          let r22 = this.trees[i22 + 1] = this._createTree(n22);
          t22 && console.timeEnd(o2);
          for (let e3 = i22; e3 >= s2; e3--) {
            const s3 = +Date.now();
            r22 = this.trees[e3] = this._createTree(this._cluster(r22, e3)), t22 && console.log("z%d: %d clusters in %dms", e3, r22.numItems, +Date.now() - s3);
          }
          return t22 && console.timeEnd("total time"), this;
        }
        getClusters(e22, t22) {
          let s2 = ((e22[0] + 180) % 360 + 360) % 360 - 180;
          const i22 = Math.max(-90, Math.min(90, e22[1]));
          let o2 = 180 === e22[2] ? 180 : ((e22[2] + 180) % 360 + 360) % 360 - 180;
          const n22 = Math.max(-90, Math.min(90, e22[3]));
          if (e22[2] - e22[0] >= 360) s2 = -180, o2 = 180;
          else if (s2 > o2) {
            const e3 = this.getClusters([s2, i22, 180, n22], t22), r3 = this.getClusters([-180, i22, o2, n22], t22);
            return e3.concat(r3);
          }
          const r22 = this.trees[this._limitZoom(t22)], a22 = r22.range(X2(s2), Y(n22), X2(o2), Y(i22)), l22 = r22.data, c22 = [];
          for (const e3 of a22) {
            const t3 = this.stride * e3;
            c22.push(l22[t3 + A2] > 1 ? B2(l22, t3, this.clusterProps) : this.points[l22[t3 + F]]);
          }
          return c22;
        }
        getChildren(e22) {
          const t22 = this._getOriginId(e22), s2 = this._getOriginZoom(e22), i22 = "No cluster with the specified id.", o2 = this.trees[s2];
          if (!o2) throw new Error(i22);
          const n22 = o2.data;
          if (t22 * this.stride >= n22.length) throw new Error(i22);
          const r22 = this.options.radius / (this.options.extent * Math.pow(2, s2 - 1)), a22 = o2.within(n22[t22 * this.stride], n22[t22 * this.stride + 1], r22), l22 = [];
          for (const t3 of a22) {
            const s3 = t3 * this.stride;
            n22[s3 + 4] === e22 && l22.push(n22[s3 + A2] > 1 ? B2(n22, s3, this.clusterProps) : this.points[n22[s3 + F]]);
          }
          if (0 === l22.length) throw new Error(i22);
          return l22;
        }
        getLeaves(e22, t22, s2) {
          const i22 = [];
          return this._appendLeaves(i22, e22, t22 = t22 || 10, s2 = s2 || 0, 0), i22;
        }
        getTile(e22, t22, s2) {
          const i22 = this.trees[this._limitZoom(e22)], o2 = Math.pow(2, e22), { extent: n22, radius: r22 } = this.options, a22 = r22 / n22, l22 = (s2 - a22) / o2, c22 = (s2 + 1 + a22) / o2, h22 = { features: [] };
          return this._addTileFeatures(i22.range((t22 - a22) / o2, l22, (t22 + 1 + a22) / o2, c22), i22.data, t22, s2, o2, h22), 0 === t22 && this._addTileFeatures(i22.range(1 - a22 / o2, l22, 1, c22), i22.data, o2, s2, o2, h22), t22 === o2 - 1 && this._addTileFeatures(i22.range(0, l22, a22 / o2, c22), i22.data, -1, s2, o2, h22), h22.features.length ? h22 : null;
        }
        getClusterExpansionZoom(e22) {
          let t22 = this._getOriginZoom(e22) - 1;
          for (; t22 <= this.options.maxZoom; ) {
            const s2 = this.getChildren(e22);
            if (t22++, 1 !== s2.length) break;
            e22 = s2[0].properties.cluster_id;
          }
          return t22;
        }
        _appendLeaves(e22, t22, s2, i22, o2) {
          const n22 = this.getChildren(t22);
          for (const t3 of n22) {
            const n3 = t3.properties;
            if (n3 && n3.cluster ? o2 + n3.point_count <= i22 ? o2 += n3.point_count : o2 = this._appendLeaves(e22, n3.cluster_id, s2, i22, o2) : o2 < i22 ? o2++ : e22.push(t3), e22.length === s2) break;
          }
          return o2;
        }
        _createTree(t22) {
          const s2 = new e2.bW(t22.length / this.stride | 0, this.options.nodeSize, Float32Array);
          for (let e22 = 0; e22 < t22.length; e22 += this.stride) s2.add(t22[e22], t22[e22 + 1]);
          return s2.finish(), s2.data = t22, s2;
        }
        _addTileFeatures(e22, t22, s2, i22, o2, n22) {
          for (const r22 of e22) {
            const e3 = r22 * this.stride, a22 = t22[e3 + A2] > 1;
            let l22, c22, h22;
            if (a22) l22 = E2(t22, e3, this.clusterProps), c22 = t22[e3], h22 = t22[e3 + 1];
            else {
              const s3 = this.points[t22[e3 + F]];
              l22 = s3.properties;
              const [i3, o3] = s3.geometry.coordinates;
              c22 = X2(i3), h22 = Y(o3);
            }
            const u22 = { type: 1, geometry: [[Math.round(this.options.extent * (c22 * o2 - s2)), Math.round(this.options.extent * (h22 * o2 - i22))]], tags: l22 };
            let d22;
            d22 = a22 || this.options.generateId ? t22[e3 + F] : this.points[t22[e3 + F]].id, void 0 !== d22 && (u22.id = d22), n22.features.push(u22);
          }
        }
        _limitZoom(e22) {
          return Math.max(this.options.minZoom, Math.min(Math.floor(+e22), this.options.maxZoom + 1));
        }
        _cluster(e22, t22) {
          const { radius: s2, extent: i22, reduce: o2, minPoints: n22 } = this.options, r22 = s2 / (i22 * Math.pow(2, t22)), a22 = e22.data, l22 = [], c22 = this.stride;
          for (let s3 = 0; s3 < a22.length; s3 += c22) {
            if (a22[s3 + 2] <= t22) continue;
            a22[s3 + 2] = t22;
            const i3 = a22[s3], h22 = a22[s3 + 1], u22 = e22.within(a22[s3], a22[s3 + 1], r22), d22 = a22[s3 + A2];
            let f22 = d22;
            for (const e3 of u22) {
              const s4 = e3 * c22;
              a22[s4 + 2] > t22 && (f22 += a22[s4 + A2]);
            }
            if (f22 > d22 && f22 >= n22) {
              let e3, n3 = i3 * d22, r3 = h22 * d22, p22 = -1;
              const g22 = (s3 / c22 << 5) + (t22 + 1) + this.points.length;
              for (const i4 of u22) {
                const l3 = i4 * c22;
                if (a22[l3 + 2] <= t22) continue;
                a22[l3 + 2] = t22;
                const h3 = a22[l3 + A2];
                n3 += a22[l3] * h3, r3 += a22[l3 + 1] * h3, a22[l3 + 4] = g22, o2 && (e3 || (e3 = this._map(a22, s3, true), p22 = this.clusterProps.length, this.clusterProps.push(e3)), o2(e3, this._map(a22, l3)));
              }
              a22[s3 + 4] = g22, l22.push(n3 / f22, r3 / f22, 1 / 0, g22, -1, f22), o2 && l22.push(p22);
            } else {
              for (let e3 = 0; e3 < c22; e3++) l22.push(a22[s3 + e3]);
              if (f22 > 1) for (const e3 of u22) {
                const s4 = e3 * c22;
                if (!(a22[s4 + 2] <= t22)) {
                  a22[s4 + 2] = t22;
                  for (let e4 = 0; e4 < c22; e4++) l22.push(a22[s4 + e4]);
                }
              }
            }
          }
          return l22;
        }
        _getOriginId(e22) {
          return e22 - this.points.length >> 5;
        }
        _getOriginZoom(e22) {
          return (e22 - this.points.length) % 32;
        }
        _map(e22, t22, s2) {
          if (e22[t22 + A2] > 1) {
            const i3 = this.clusterProps[e22[t22 + Z]];
            return s2 ? Object.assign({}, i3) : i3;
          }
          const i22 = this.points[e22[t22 + F]].properties, o2 = this.options.map(i22);
          return s2 && o2 === i22 ? Object.assign({}, o2) : o2;
        }
      }
      function B2(e22, t22, s2) {
        return { type: "Feature", id: e22[t22 + F], properties: E2(e22, t22, s2), geometry: { type: "Point", coordinates: [(i22 = e22[t22], 360 * (i22 - 0.5)), G(e22[t22 + 1])] } };
        var i22;
      }
      function E2(e22, t22, s2) {
        const i22 = e22[t22 + A2], o2 = i22 >= 1e4 ? `${Math.round(i22 / 1e3)}k` : i22 >= 1e3 ? Math.round(i22 / 100) / 10 + "k" : i22, n22 = e22[t22 + Z], r22 = -1 === n22 ? {} : Object.assign({}, s2[n22]);
        return Object.assign(r22, { cluster: true, cluster_id: e22[t22 + F], point_count: i22, point_count_abbreviated: o2 });
      }
      function X2(e22) {
        return e22 / 360 + 0.5;
      }
      function Y(e22) {
        const t22 = Math.sin(e22 * Math.PI / 180), s2 = 0.5 - 0.25 * Math.log((1 + t22) / (1 - t22)) / Math.PI;
        return s2 < 0 ? 0 : s2 > 1 ? 1 : s2;
      }
      function G(e22) {
        const t22 = (180 - 360 * e22) * Math.PI / 180;
        return 360 * Math.atan(Math.exp(t22)) / Math.PI - 90;
      }
      function R2(e22, t22, s2, i22) {
        let o2 = i22;
        const n22 = t22 + (s2 - t22 >> 1);
        let r22, a22 = s2 - t22;
        const l22 = e22[t22], c22 = e22[t22 + 1], h22 = e22[s2], u22 = e22[s2 + 1];
        for (let i3 = t22 + 3; i3 < s2; i3 += 3) {
          const t3 = J(e22[i3], e22[i3 + 1], l22, c22, h22, u22);
          if (t3 > o2) r22 = i3, o2 = t3;
          else if (t3 === o2) {
            const e3 = Math.abs(i3 - n22);
            e3 < a22 && (r22 = i3, a22 = e3);
          }
        }
        o2 > i22 && (r22 - t22 > 3 && R2(e22, t22, r22, i22), e22[r22 + 2] = o2, s2 - r22 > 3 && R2(e22, r22, s2, i22));
      }
      function J(e22, t22, s2, i22, o2, n22) {
        let r22 = o2 - s2, a22 = n22 - i22;
        if (0 !== r22 || 0 !== a22) {
          const l22 = ((e22 - s2) * r22 + (t22 - i22) * a22) / (r22 * r22 + a22 * a22);
          l22 > 1 ? (s2 = o2, i22 = n22) : l22 > 0 && (s2 += r22 * l22, i22 += a22 * l22);
        }
        return r22 = e22 - s2, a22 = t22 - i22, r22 * r22 + a22 * a22;
      }
      function V(e22, t22, s2, i22) {
        const o2 = { id: e22 ?? null, type: t22, geometry: s2, tags: i22, minX: 1 / 0, minY: 1 / 0, maxX: -1 / 0, maxY: -1 / 0 };
        if ("Point" === t22 || "MultiPoint" === t22 || "LineString" === t22) $(o2, s2);
        else if ("Polygon" === t22) $(o2, s2[0]);
        else if ("MultiLineString" === t22) for (const e3 of s2) $(o2, e3);
        else if ("MultiPolygon" === t22) for (const e3 of s2) $(o2, e3[0]);
        return o2;
      }
      function $(e22, t22) {
        for (let s2 = 0; s2 < t22.length; s2 += 3) e22.minX = Math.min(e22.minX, t22[s2]), e22.minY = Math.min(e22.minY, t22[s2 + 1]), e22.maxX = Math.max(e22.maxX, t22[s2]), e22.maxY = Math.max(e22.maxY, t22[s2 + 1]);
      }
      function W(e22, t22, s2, i22) {
        if (!t22.geometry) return;
        const o2 = t22.geometry.coordinates;
        if (o2 && 0 === o2.length) return;
        const n22 = t22.geometry.type, r22 = Math.pow(s2.tolerance / ((1 << s2.maxZoom) * s2.extent), 2);
        let a22 = [], l22 = t22.id;
        if (s2.promoteId ? l22 = t22.properties[s2.promoteId] : s2.generateId && (l22 = i22 || 0), "Point" === n22) q2(o2, a22);
        else if ("MultiPoint" === n22) for (const e3 of o2) q2(e3, a22);
        else if ("LineString" === n22) U2(o2, a22, r22, false);
        else if ("MultiLineString" === n22) {
          if (s2.lineMetrics) {
            for (const s3 of o2) a22 = [], U2(s3, a22, r22, false), e22.push(V(l22, "LineString", a22, t22.properties));
            return;
          }
          H(o2, a22, r22, false);
        } else if ("Polygon" === n22) H(o2, a22, r22, true);
        else {
          if ("MultiPolygon" !== n22) {
            if ("GeometryCollection" === n22) {
              for (const o3 of t22.geometry.geometries) W(e22, { id: l22, geometry: o3, properties: t22.properties }, s2, i22);
              return;
            }
            throw new Error("Input data is not a valid GeoJSON object.");
          }
          for (const e3 of o2) {
            const t3 = [];
            H(e3, t3, r22, true), a22.push(t3);
          }
        }
        e22.push(V(l22, n22, a22, t22.properties));
      }
      function q2(e22, t22) {
        t22.push(Q(e22[0]), K2(e22[1]), 0);
      }
      function U2(e22, t22, s2, i22) {
        let o2, n22, r22 = 0;
        for (let s3 = 0; s3 < e22.length; s3++) {
          const a3 = Q(e22[s3][0]), l22 = K2(e22[s3][1]);
          t22.push(a3, l22, 0), s3 > 0 && (r22 += i22 ? (o2 * l22 - a3 * n22) / 2 : Math.sqrt(Math.pow(a3 - o2, 2) + Math.pow(l22 - n22, 2))), o2 = a3, n22 = l22;
        }
        const a22 = t22.length - 3;
        t22[2] = 1, R2(t22, 0, a22, s2), t22[a22 + 2] = 1, t22.size = Math.abs(r22), t22.start = 0, t22.end = t22.size;
      }
      function H(e22, t22, s2, i22) {
        for (let o2 = 0; o2 < e22.length; o2++) {
          const n22 = [];
          U2(e22[o2], n22, s2, i22), t22.push(n22);
        }
      }
      function Q(e22) {
        return e22 / 360 + 0.5;
      }
      function K2(e22) {
        const t22 = Math.sin(e22 * Math.PI / 180), s2 = 0.5 - 0.25 * Math.log((1 + t22) / (1 - t22)) / Math.PI;
        return s2 < 0 ? 0 : s2 > 1 ? 1 : s2;
      }
      function ee2(e22, t22, s2, i22, o2, n22, r22, a22) {
        if (i22 /= t22, n22 >= (s2 /= t22) && r22 < i22) return e22;
        if (r22 < s2 || n22 >= i22) return null;
        const l22 = [];
        for (const t3 of e22) {
          const e3 = t3.geometry;
          let n3 = t3.type;
          const r3 = 0 === o2 ? t3.minX : t3.minY, c22 = 0 === o2 ? t3.maxX : t3.maxY;
          if (r3 >= s2 && c22 < i22) {
            l22.push(t3);
            continue;
          }
          if (c22 < s2 || r3 >= i22) continue;
          let h22 = [];
          if ("Point" === n3 || "MultiPoint" === n3) te2(e3, h22, s2, i22, o2);
          else if ("LineString" === n3) se2(e3, h22, s2, i22, o2, false, a22.lineMetrics);
          else if ("MultiLineString" === n3) oe2(e3, h22, s2, i22, o2, false);
          else if ("Polygon" === n3) oe2(e3, h22, s2, i22, o2, true);
          else if ("MultiPolygon" === n3) for (const t4 of e3) {
            const e4 = [];
            oe2(t4, e4, s2, i22, o2, true), e4.length && h22.push(e4);
          }
          if (h22.length) {
            if (a22.lineMetrics && "LineString" === n3) {
              for (const e4 of h22) l22.push(V(t3.id, n3, e4, t3.tags));
              continue;
            }
            "LineString" !== n3 && "MultiLineString" !== n3 || (1 === h22.length ? (n3 = "LineString", h22 = h22[0]) : n3 = "MultiLineString"), "Point" !== n3 && "MultiPoint" !== n3 || (n3 = 3 === h22.length ? "Point" : "MultiPoint"), l22.push(V(t3.id, n3, h22, t3.tags));
          }
        }
        return l22.length ? l22 : null;
      }
      function te2(e22, t22, s2, i22, o2) {
        for (let n22 = 0; n22 < e22.length; n22 += 3) {
          const r22 = e22[n22 + o2];
          r22 >= s2 && r22 <= i22 && ne2(t22, e22[n22], e22[n22 + 1], e22[n22 + 2]);
        }
      }
      function se2(e22, t22, s2, i22, o2, n22, r22) {
        let a22 = ie2(e22);
        const l22 = 0 === o2 ? re : ae2;
        let c22, h22, u22 = e22.start;
        for (let d3 = 0; d3 < e22.length - 3; d3 += 3) {
          const f3 = e22[d3], p3 = e22[d3 + 1], g3 = e22[d3 + 2], m22 = e22[d3 + 3], y22 = e22[d3 + 4], w22 = 0 === o2 ? f3 : p3, x22 = 0 === o2 ? m22 : y22;
          let b22 = false;
          r22 && (c22 = Math.sqrt(Math.pow(f3 - m22, 2) + Math.pow(p3 - y22, 2))), w22 < s2 ? x22 > s2 && (h22 = l22(a22, f3, p3, m22, y22, s2), r22 && (a22.start = u22 + c22 * h22)) : w22 > i22 ? x22 < i22 && (h22 = l22(a22, f3, p3, m22, y22, i22), r22 && (a22.start = u22 + c22 * h22)) : ne2(a22, f3, p3, g3), x22 < s2 && w22 >= s2 && (h22 = l22(a22, f3, p3, m22, y22, s2), b22 = true), x22 > i22 && w22 <= i22 && (h22 = l22(a22, f3, p3, m22, y22, i22), b22 = true), !n22 && b22 && (r22 && (a22.end = u22 + c22 * h22), t22.push(a22), a22 = ie2(e22)), r22 && (u22 += c22);
        }
        let d22 = e22.length - 3;
        const f22 = e22[d22], p22 = e22[d22 + 1], g22 = 0 === o2 ? f22 : p22;
        g22 >= s2 && g22 <= i22 && ne2(a22, f22, p22, e22[d22 + 2]), d22 = a22.length - 3, n22 && d22 >= 3 && (a22[d22] !== a22[0] || a22[d22 + 1] !== a22[1]) && ne2(a22, a22[0], a22[1], a22[2]), a22.length && t22.push(a22);
      }
      function ie2(e22) {
        const t22 = [];
        return t22.size = e22.size, t22.start = e22.start, t22.end = e22.end, t22;
      }
      function oe2(e22, t22, s2, i22, o2, n22) {
        for (const r22 of e22) se2(r22, t22, s2, i22, o2, n22, false);
      }
      function ne2(e22, t22, s2, i22) {
        e22.push(t22, s2, i22);
      }
      function re(e22, t22, s2, i22, o2, n22) {
        const r22 = (n22 - t22) / (i22 - t22);
        return ne2(e22, n22, s2 + (o2 - s2) * r22, 1), r22;
      }
      function ae2(e22, t22, s2, i22, o2, n22) {
        const r22 = (n22 - s2) / (o2 - s2);
        return ne2(e22, t22 + (i22 - t22) * r22, n22, 1), r22;
      }
      function le(e22, t22) {
        const s2 = [];
        for (let i22 = 0; i22 < e22.length; i22++) {
          const o2 = e22[i22], n22 = o2.type;
          let r22;
          if ("Point" === n22 || "MultiPoint" === n22 || "LineString" === n22) r22 = ce2(o2.geometry, t22);
          else if ("MultiLineString" === n22 || "Polygon" === n22) {
            r22 = [];
            for (const e3 of o2.geometry) r22.push(ce2(e3, t22));
          } else if ("MultiPolygon" === n22) {
            r22 = [];
            for (const e3 of o2.geometry) {
              const s3 = [];
              for (const i3 of e3) s3.push(ce2(i3, t22));
              r22.push(s3);
            }
          }
          s2.push(V(o2.id, n22, r22, o2.tags));
        }
        return s2;
      }
      function ce2(e22, t22) {
        const s2 = [];
        s2.size = e22.size, void 0 !== e22.start && (s2.start = e22.start, s2.end = e22.end);
        for (let i22 = 0; i22 < e22.length; i22 += 3) s2.push(e22[i22] + t22, e22[i22 + 1], e22[i22 + 2]);
        return s2;
      }
      function he(e22, t22) {
        if (e22.transformed) return e22;
        const s2 = 1 << e22.z, i22 = e22.x, o2 = e22.y;
        for (const n22 of e22.features) {
          const e3 = n22.geometry, r22 = n22.type;
          if (n22.geometry = [], 1 === r22) for (let r3 = 0; r3 < e3.length; r3 += 2) n22.geometry.push(ue(e3[r3], e3[r3 + 1], t22, s2, i22, o2));
          else for (let r3 = 0; r3 < e3.length; r3++) {
            const a22 = [];
            for (let n3 = 0; n3 < e3[r3].length; n3 += 2) a22.push(ue(e3[r3][n3], e3[r3][n3 + 1], t22, s2, i22, o2));
            n22.geometry.push(a22);
          }
        }
        return e22.transformed = true, e22;
      }
      function ue(e22, t22, s2, i22, o2, n22) {
        return [Math.round(s2 * (e22 * i22 - o2)), Math.round(s2 * (t22 * i22 - n22))];
      }
      function de(e22, t22, s2, i22, o2) {
        const n22 = t22 === o2.maxZoom ? 0 : o2.tolerance / ((1 << t22) * o2.extent), r22 = { features: [], numPoints: 0, numSimplified: 0, numFeatures: e22.length, source: null, x: s2, y: i22, z: t22, transformed: false, minX: 2, minY: 1, maxX: -1, maxY: 0 };
        for (const t3 of e22) fe(r22, t3, n22, o2);
        return r22;
      }
      function fe(e22, t22, s2, i22) {
        const o2 = t22.geometry, n22 = t22.type, r22 = [];
        if (e22.minX = Math.min(e22.minX, t22.minX), e22.minY = Math.min(e22.minY, t22.minY), e22.maxX = Math.max(e22.maxX, t22.maxX), e22.maxY = Math.max(e22.maxY, t22.maxY), "Point" === n22 || "MultiPoint" === n22) for (let t3 = 0; t3 < o2.length; t3 += 3) r22.push(o2[t3], o2[t3 + 1]), e22.numPoints++, e22.numSimplified++;
        else if ("LineString" === n22) pe(r22, o2, e22, s2, false, false);
        else if ("MultiLineString" === n22 || "Polygon" === n22) for (let t3 = 0; t3 < o2.length; t3++) pe(r22, o2[t3], e22, s2, "Polygon" === n22, 0 === t3);
        else if ("MultiPolygon" === n22) for (let t3 = 0; t3 < o2.length; t3++) {
          const i3 = o2[t3];
          for (let t4 = 0; t4 < i3.length; t4++) pe(r22, i3[t4], e22, s2, true, 0 === t4);
        }
        if (r22.length) {
          let s3 = t22.tags || null;
          if ("LineString" === n22 && i22.lineMetrics) {
            s3 = {};
            for (const e3 in t22.tags) s3[e3] = t22.tags[e3];
            s3.mapbox_clip_start = o2.start / o2.size, s3.mapbox_clip_end = o2.end / o2.size;
          }
          const a22 = { geometry: r22, type: "Polygon" === n22 || "MultiPolygon" === n22 ? 3 : "LineString" === n22 || "MultiLineString" === n22 ? 2 : 1, tags: s3 };
          null !== t22.id && (a22.id = t22.id), e22.features.push(a22);
        }
      }
      function pe(e22, t22, s2, i22, o2, n22) {
        const r22 = i22 * i22;
        if (i22 > 0 && t22.size < (o2 ? r22 : i22)) return void (s2.numPoints += t22.length / 3);
        const a22 = [];
        for (let e3 = 0; e3 < t22.length; e3 += 3) (0 === i22 || t22[e3 + 2] > r22) && (s2.numSimplified++, a22.push(t22[e3], t22[e3 + 1])), s2.numPoints++;
        o2 && function(e3, t3) {
          let s3 = 0;
          for (let t4 = 0, i3 = e3.length, o3 = i3 - 2; t4 < i3; o3 = t4, t4 += 2) s3 += (e3[t4] - e3[o3]) * (e3[t4 + 1] + e3[o3 + 1]);
          if (s3 > 0 === t3) for (let t4 = 0, s4 = e3.length; t4 < s4 / 2; t4 += 2) {
            const i3 = e3[t4], o3 = e3[t4 + 1];
            e3[t4] = e3[s4 - 2 - t4], e3[t4 + 1] = e3[s4 - 1 - t4], e3[s4 - 2 - t4] = i3, e3[s4 - 1 - t4] = o3;
          }
        }(a22, n22), e22.push(a22);
      }
      const ge = { maxZoom: 14, indexMaxZoom: 5, indexMaxPoints: 1e5, tolerance: 3, extent: 4096, buffer: 64, lineMetrics: false, promoteId: null, generateId: false, debug: 0 };
      class me {
        constructor(e22, t22) {
          const s2 = (t22 = this.options = function(e3, t3) {
            for (const s3 in t3) e3[s3] = t3[s3];
            return e3;
          }(Object.create(ge), t22)).debug;
          if (s2 && console.time("preprocess data"), t22.maxZoom < 0 || t22.maxZoom > 24) throw new Error("maxZoom should be in the 0-24 range");
          if (t22.promoteId && t22.generateId) throw new Error("promoteId and generateId cannot be used together.");
          let i22 = function(e3, t3) {
            const s3 = [];
            if ("FeatureCollection" === e3.type) for (let i3 = 0; i3 < e3.features.length; i3++) W(s3, e3.features[i3], t3, i3);
            else W(s3, "Feature" === e3.type ? e3 : { geometry: e3 }, t3);
            return s3;
          }(e22, t22);
          this.tiles = {}, this.tileCoords = [], s2 && (console.timeEnd("preprocess data"), console.log("index: maxZoom: %d, maxPoints: %d", t22.indexMaxZoom, t22.indexMaxPoints), console.time("generate tiles"), this.stats = {}, this.total = 0), i22 = function(e3, t3) {
            const s3 = t3.buffer / t3.extent;
            let i3 = e3;
            const o2 = ee2(e3, 1, -1 - s3, s3, 0, -1, 2, t3), n22 = ee2(e3, 1, 1 - s3, 2 + s3, 0, -1, 2, t3);
            return (o2 || n22) && (i3 = ee2(e3, 1, -s3, 1 + s3, 0, -1, 2, t3) || [], o2 && (i3 = le(o2, 1).concat(i3)), n22 && (i3 = i3.concat(le(n22, -1)))), i3;
          }(i22, t22), i22.length && this.splitTile(i22, 0, 0, 0), s2 && (i22.length && console.log("features: %d, points: %d", this.tiles[0].numFeatures, this.tiles[0].numPoints), console.timeEnd("generate tiles"), console.log("tiles generated:", this.total, JSON.stringify(this.stats)));
        }
        splitTile(e22, t22, s2, i22, o2, n22, r22) {
          const a22 = [e22, t22, s2, i22], l22 = this.options, c22 = l22.debug;
          for (; a22.length; ) {
            i22 = a22.pop(), s2 = a22.pop(), t22 = a22.pop(), e22 = a22.pop();
            const h22 = 1 << t22, u22 = ye(t22, s2, i22);
            let d22 = this.tiles[u22];
            if (!d22 && (c22 > 1 && console.time("creation"), d22 = this.tiles[u22] = de(e22, t22, s2, i22, l22), this.tileCoords.push({ z: t22, x: s2, y: i22 }), c22)) {
              c22 > 1 && (console.log("tile z%d-%d-%d (features: %d, points: %d, simplified: %d)", t22, s2, i22, d22.numFeatures, d22.numPoints, d22.numSimplified), console.timeEnd("creation"));
              const e3 = `z${t22}`;
              this.stats[e3] = (this.stats[e3] || 0) + 1, this.total++;
            }
            if (d22.source = e22, null == o2) {
              if (t22 === l22.indexMaxZoom || d22.numPoints <= l22.indexMaxPoints) continue;
            } else {
              if (t22 === l22.maxZoom || t22 === o2) continue;
              if (null != o2) {
                const e3 = o2 - t22;
                if (s2 !== n22 >> e3 || i22 !== r22 >> e3) continue;
              }
            }
            if (d22.source = null, 0 === e22.length) continue;
            c22 > 1 && console.time("clipping");
            const f22 = 0.5 * l22.buffer / l22.extent, p22 = 0.5 - f22, g22 = 0.5 + f22, m22 = 1 + f22;
            let y22 = null, w22 = null, x22 = null, b22 = null, v22 = ee2(e22, h22, s2 - f22, s2 + g22, 0, d22.minX, d22.maxX, l22), I2 = ee2(e22, h22, s2 + p22, s2 + m22, 0, d22.minX, d22.maxX, l22);
            e22 = null, v22 && (y22 = ee2(v22, h22, i22 - f22, i22 + g22, 1, d22.minY, d22.maxY, l22), w22 = ee2(v22, h22, i22 + p22, i22 + m22, 1, d22.minY, d22.maxY, l22), v22 = null), I2 && (x22 = ee2(I2, h22, i22 - f22, i22 + g22, 1, d22.minY, d22.maxY, l22), b22 = ee2(I2, h22, i22 + p22, i22 + m22, 1, d22.minY, d22.maxY, l22), I2 = null), c22 > 1 && console.timeEnd("clipping"), a22.push(y22 || [], t22 + 1, 2 * s2, 2 * i22), a22.push(w22 || [], t22 + 1, 2 * s2, 2 * i22 + 1), a22.push(x22 || [], t22 + 1, 2 * s2 + 1, 2 * i22), a22.push(b22 || [], t22 + 1, 2 * s2 + 1, 2 * i22 + 1);
          }
        }
        getTile(e22, t22, s2) {
          e22 = +e22, t22 = +t22, s2 = +s2;
          const i22 = this.options, { extent: o2, debug: n22 } = i22;
          if (e22 < 0 || e22 > 24) return null;
          const r22 = 1 << e22, a22 = ye(e22, t22 = t22 + r22 & r22 - 1, s2);
          if (this.tiles[a22]) return he(this.tiles[a22], o2);
          n22 > 1 && console.log("drilling down to z%d-%d-%d", e22, t22, s2);
          let l22, c22 = e22, h22 = t22, u22 = s2;
          for (; !l22 && c22 > 0; ) c22--, h22 >>= 1, u22 >>= 1, l22 = this.tiles[ye(c22, h22, u22)];
          return l22 && l22.source ? (n22 > 1 && (console.log("found parent tile z%d-%d-%d", c22, h22, u22), console.time("drilling down")), this.splitTile(l22.source, c22, h22, u22, e22, t22, s2), n22 > 1 && console.timeEnd("drilling down"), this.tiles[a22] ? he(this.tiles[a22], o2) : null) : null;
        }
      }
      function ye(e22, t22, s2) {
        return 32 * ((1 << e22) * s2 + t22) + e22;
      }
      function we(e22, t22) {
        const s2 = e22.tileID.canonical;
        if (!this._geoJSONIndex) return void t22(null, null);
        const i22 = this._geoJSONIndex.getTile(s2.z, s2.x, s2.y);
        if (!i22) return void t22(null, null);
        const o2 = new g2(i22.features);
        let n22 = j2(o2);
        0 === n22.byteOffset && n22.byteLength === n22.buffer.byteLength || (n22 = new Uint8Array(n22)), t22(null, { vectorTile: o2, rawData: n22.buffer });
      }
      class xe extends c2 {
        constructor(e22, t22, s2, i22, o2, n22, r22) {
          super(e22, t22, s2, i22, o2, we, r22), n22 && (this.loadGeoJSON = n22), this._dynamicIndex = new w2();
        }
        loadData(s2, i22) {
          const o2 = s2 && s2.request, n22 = o2 && o2.collectResourceTiming;
          this.loadGeoJSON(s2, (r22, a22) => {
            if (r22 || !a22) return i22(r22);
            if ("object" != typeof a22) return i22(new Error(`Input data given to '${s2.source}' is not a valid GeoJSON object.`));
            {
              try {
                if (s2.filter) {
                  const t22 = e2.X(s2.filter, { type: "boolean", "property-type": "data-driven", overridable: false, transition: false });
                  if ("error" === t22.result) throw new Error(t22.value.map((e22) => `${e22.key}: ${e22.message}`).join(", "));
                  a22.features = a22.features.filter((e22) => t22.value.evaluate({ zoom: 0 }, e22));
                }
                s2.dynamic ? ("Feature" === a22.type && (a22 = { type: "FeatureCollection", features: [a22] }), s2.append || (this._dynamicIndex.clear(), this.loaded = {}), this._dynamicIndex.load(a22.features, this.loaded), s2.cluster && (a22.features = this._dynamicIndex.getFeatures())) : this.loaded = {}, this._geoJSONIndex = s2.cluster ? new N2(function({ superclusterOptions: t22, clusterProperties: s3 }) {
                  if (!s3 || !t22) return t22;
                  const i3 = {}, o3 = {}, n3 = { accumulated: null, zoom: 0 }, r4 = { properties: null }, a3 = Object.keys(s3);
                  for (const t3 of a3) {
                    const [n4, r5] = s3[t3], a4 = e2.X(r5), l22 = e2.X("string" == typeof n4 ? [n4, ["accumulated"], ["get", t3]] : n4);
                    i3[t3] = a4.value, o3[t3] = l22.value;
                  }
                  return t22.map = (e22) => {
                    r4.properties = e22;
                    const t3 = {};
                    for (const e3 of a3) t3[e3] = i3[e3].evaluate(n3, r4);
                    return t3;
                  }, t22.reduce = (e22, t3) => {
                    r4.properties = t3;
                    for (const t4 of a3) n3.accumulated = e22[t4], e22[t4] = o3[t4].evaluate(n3, r4);
                  }, t22;
                }(s2)).load(a22.features) : s2.dynamic ? this._dynamicIndex : function(e22, t22) {
                  return new me(e22, t22);
                }(a22, s2.geojsonVtOptions);
              } catch (e22) {
                return i22(e22);
              }
              const r3 = {};
              if (n22) {
                const e22 = t2(o2);
                e22 && (r3.resourceTiming = {}, r3.resourceTiming[s2.source] = JSON.parse(JSON.stringify(e22)));
              }
              i22(null, r3);
            }
          });
        }
        reloadTile(e22, t22) {
          const s2 = this.loaded;
          return s2 && s2[e22.uid] ? e22.partial ? t22(null, void 0) : super.reloadTile(e22, t22) : this.loadTile(e22, t22);
        }
        loadGeoJSON(t22, s2) {
          if (t22.request) e2.n(t22.request, s2);
          else {
            if ("string" != typeof t22.data) return s2(new Error(`Input data given to '${t22.source}' is not a valid GeoJSON object.`));
            try {
              return s2(null, JSON.parse(t22.data));
            } catch (e22) {
              return s2(new Error(`Input data given to '${t22.source}' is not a valid GeoJSON object.`));
            }
          }
        }
        getClusterExpansionZoom(e22, t22) {
          try {
            t22(null, this._geoJSONIndex.getClusterExpansionZoom(e22.clusterId));
          } catch (e3) {
            t22(e3);
          }
        }
        getClusterChildren(e22, t22) {
          try {
            t22(null, this._geoJSONIndex.getChildren(e22.clusterId));
          } catch (e3) {
            t22(e3);
          }
        }
        getClusterLeaves(e22, t22) {
          try {
            t22(null, this._geoJSONIndex.getLeaves(e22.clusterId, e22.limit, e22.offset));
          } catch (e3) {
            t22(e3);
          }
        }
      }
      class be {
        constructor(t22, s2) {
          this.tileID = new e2.aM(t22.tileID.overscaledZ, t22.tileID.wrap, t22.tileID.canonical.z, t22.tileID.canonical.x, t22.tileID.canonical.y), this.tileZoom = t22.tileZoom, this.uid = t22.uid, this.zoom = t22.zoom, this.canonical = t22.tileID.canonical, this.pixelRatio = t22.pixelRatio, this.tileSize = t22.tileSize, this.source = t22.source, this.overscaling = this.tileID.overscaleFactor(), this.projection = t22.projection, this.brightness = s2;
        }
        parse(t22, s2, i22, o2) {
          this.status = "parsing";
          const n22 = new e2.aM(i22.tileID.overscaledZ, i22.tileID.wrap, i22.tileID.canonical.z, i22.tileID.canonical.x, i22.tileID.canonical.y), r22 = [], a22 = s2.familiesBySource[i22.source], l22 = new e2.f0(n22, i22.promoteId);
          l22.bucketLayerIDs = [], l22.is3DTile = true, e2.fi(t22).then((t3) => {
            if (!t3) return o2(new Error("Could not parse tile"));
            const s3 = e2.fj(t3, 1 / e2.cT(i22.tileID.canonical)), c22 = t3.json.extensionsUsed && t3.json.extensionsUsed.includes("MAPBOX_mesh_features") || t3.json.asset.extras && t3.json.asset.extras.MAPBOX_mesh_features, h22 = t3.json.extensionsUsed && t3.json.extensionsUsed.includes("EXT_meshopt_compression"), u22 = new e2.aa(this.zoom, { brightness: this.brightness });
            for (const t4 in a22) for (const i3 of a22[t4]) {
              const t5 = i3[0];
              l22.bucketLayerIDs.push(i3.map((t6) => e2.C(t6.id, t6.scope))), t5.recalculate(u22, []);
              const o3 = new e2.fk(i3, s3, n22, c22, h22, this.brightness, l22);
              c22 || (o3.needsUpload = true), r22.push(o3), o3.evaluate(t5);
            }
            this.status = "done", o2(null, { buckets: r22, featureIndex: l22, collisionBoxArray: null, glyphAtlasImage: null, lineAtlas: null, imageAtlas: null, brightness: null });
          }).catch((e22) => o2(new Error(e22.message)));
        }
      }
      class ve {
        constructor(e22, t22, s2, i22, o2, n22, r22) {
          this.actor = e22, this.layerIndex = t22, this.availableImages = s2, this.availableModels = i22, this.brightness = r22, this.loading = {}, this.loaded = {};
        }
        loadTile(t22, s2) {
          const i22 = t22.uid, o2 = this.loading[i22] = new be(t22, this.brightness);
          e2.br(t22.request, (e22, n22) => {
            const r22 = !this.loading[i22];
            return delete this.loading[i22], r22 || e22 ? (o2.status = "done", r22 || (this.loaded[i22] = o2), s2(e22)) : n22 && 0 !== n22.byteLength ? void o2.parse(n22, this.layerIndex, t22, (e3, t3) => {
              o2.status = "done", this.loaded = this.loaded || {}, this.loaded[i22] = o2, e3 || !t3 ? s2(e3) : s2(null, t3);
            }) : (o2.status = "done", this.loaded[i22] = o2, s2());
          });
        }
        reloadTile(e22, t22) {
          const s2 = this.loaded, i22 = e22.uid;
          if (s2 && s2[i22]) {
            const o2 = s2[i22];
            o2.projection = e22.projection, o2.brightness = e22.brightness;
            const n22 = (s3, i3) => {
              o2.reloadCallback && (delete o2.reloadCallback, this.loadTile(e22, t22)), t22(s3, i3);
            };
            "parsing" === o2.status ? o2.reloadCallback = n22 : "done" === o2.status && this.loadTile(e22, t22);
          }
        }
        abortTile(e22, t22) {
          const s2 = e22.uid;
          this.loading[s2] && delete this.loading[s2], t22();
        }
        removeTile(e22, t22) {
          const s2 = this.loaded, i22 = e22.uid;
          s2 && s2[i22] && delete s2[i22], t22();
        }
      }
      class Ie {
        constructor(t22) {
          this.self = t22, this.actor = new e2.fm(t22, this), this.layerIndexes = {}, this.availableImages = {}, this.availableModels = {}, this.isSpriteLoaded = {}, this.imageRasterizer = new e2.y(), this.projections = {}, this.defaultProjection = e2.ce({ name: "mercator" }), this.workerSourceTypes = { vector: c2, geojson: xe, "raster-dem": h2, "raster-array": d2, "batched-model": ve }, this.workerSources = {}, this.self.registerWorkerSource = (e22, t3) => {
            if (this.workerSourceTypes[e22]) throw new Error(`Worker source with name "${e22}" already registered.`);
            this.workerSourceTypes[e22] = t3;
          }, this.self.registerRTLTextPlugin = (t3) => {
            if (e2.fn.isParsed()) throw new Error("RTL text plugin already registered.");
            e2.fn.applyArabicShaping = t3.applyArabicShaping, e2.fn.processBidirectionalText = t3.processBidirectionalText, e2.fn.processStyledBidirectionalText = t3.processStyledBidirectionalText;
          };
        }
        clearCaches(e22, t22, s2) {
          delete this.layerIndexes[e22], delete this.availableImages[e22], delete this.availableModels[e22], delete this.workerSources[e22], s2();
        }
        checkIfReady(e22, t22, s2) {
          s2();
        }
        setReferrer(e22, t22) {
          this.referrer = t22;
        }
        spriteLoaded(t22, s2) {
          this.isSpriteLoaded[t22] || (this.isSpriteLoaded[t22] = {});
          const { scope: i22, isLoaded: o2 } = s2;
          if (this.isSpriteLoaded[t22][i22] = o2, this.workerSources[t22] && this.workerSources[t22][i22]) for (const s3 in this.workerSources[t22][i22]) {
            const n22 = this.workerSources[t22][i22][s3];
            for (const t3 in n22) {
              const s4 = n22[t3];
              s4 instanceof c2 && (s4.isSpriteLoaded = o2, s4.fire(new e2.A("isSpriteLoaded")));
            }
          }
        }
        setImages(e22, t22, s2) {
          this.availableImages[e22] || (this.availableImages[e22] = {});
          const { scope: i22, images: o2 } = t22;
          if (this.availableImages[e22][i22] = o2, this.workerSources[e22] && this.workerSources[e22][i22]) {
            for (const t3 in this.workerSources[e22][i22]) {
              const s3 = this.workerSources[e22][i22][t3];
              for (const e3 in s3) s3[e3].availableImages = o2;
            }
            s2();
          } else s2();
        }
        setModels(e22, { scope: t22, models: s2 }, i22) {
          if (this.availableModels[e22] || (this.availableModels[e22] = {}), this.availableModels[e22][t22] = s2, this.workerSources[e22] && this.workerSources[e22][t22]) {
            for (const i3 in this.workerSources[e22][t22]) {
              const o2 = this.workerSources[e22][t22][i3];
              for (const e3 in o2) o2[e3].availableModels = s2;
            }
            i22();
          } else i22();
        }
        setProjection(t22, s2) {
          this.projections[t22] = e2.ce(s2);
        }
        setBrightness(e22, t22, s2) {
          this.brightness = t22, s2();
        }
        setLayers(e22, t22, s2) {
          this.getLayerIndex(e22, t22.scope).replace(t22.layers, t22.options), s2();
        }
        updateLayers(e22, t22, s2) {
          this.getLayerIndex(e22, t22.scope).update(t22.layers, t22.removedIds, t22.options), s2();
        }
        loadTile(e22, t22, s2) {
          t22.projection = this.projections[e22] || this.defaultProjection, this.getWorkerSource(e22, t22.type, t22.source, t22.scope).loadTile(t22, s2);
        }
        decodeRasterArray(e22, t22, s2) {
          this.getWorkerSource(e22, t22.type, t22.source, t22.scope).decodeRasterArray(t22, s2);
        }
        reloadTile(e22, t22, s2) {
          t22.projection = this.projections[e22] || this.defaultProjection, this.getWorkerSource(e22, t22.type, t22.source, t22.scope).reloadTile(t22, s2);
        }
        abortTile(e22, t22, s2) {
          this.getWorkerSource(e22, t22.type, t22.source, t22.scope).abortTile(t22, s2);
        }
        removeTile(e22, t22, s2) {
          this.getWorkerSource(e22, t22.type, t22.source, t22.scope).removeTile(t22, s2);
        }
        removeSource(e22, t22, s2) {
          if (!(this.workerSources[e22] && this.workerSources[e22][t22.scope] && this.workerSources[e22][t22.scope][t22.type] && this.workerSources[e22][t22.scope][t22.type][t22.source])) return;
          const i22 = this.workerSources[e22][t22.scope][t22.type][t22.source];
          delete this.workerSources[e22][t22.scope][t22.type][t22.source], void 0 !== i22.removeSource ? i22.removeSource(t22, s2) : s2();
        }
        loadWorkerSource(e22, t22, s2) {
          try {
            this.self.importScripts(t22.url), s2();
          } catch (e3) {
            s2(e3.toString());
          }
        }
        syncRTLPluginState(t22, s2, i22) {
          try {
            e2.fn.setState(s2);
            const t3 = e2.fn.getPluginURL();
            if (e2.fn.isLoaded() && !e2.fn.isParsed() && null != t3) {
              this.self.importScripts(t3);
              const s3 = e2.fn.isParsed();
              i22(s3 ? void 0 : new Error(`RTL Text Plugin failed to import scripts from ${t3}`), s3);
            }
          } catch (e22) {
            i22(e22.toString());
          }
        }
        setDracoUrl(e22, t22) {
          this.dracoUrl = t22;
        }
        getAvailableImages(e22, t22) {
          this.availableImages[e22] || (this.availableImages[e22] = {});
          let s2 = this.availableImages[e22][t22];
          return s2 || (s2 = []), s2;
        }
        getAvailableModels(e22, t22) {
          this.availableModels[e22] || (this.availableModels[e22] = {});
          let s2 = this.availableModels[e22][t22];
          return s2 || (s2 = {}), s2;
        }
        getLayerIndex(e22, t22) {
          this.layerIndexes[e22] || (this.layerIndexes[e22] = {});
          let s2 = this.layerIndexes[e22][t22];
          return s2 || (s2 = this.layerIndexes[e22][t22] = new o(), s2.scope = t22), s2;
        }
        getWorkerSource(e22, t22, s2, i22) {
          const o2 = this.workerSources;
          return o2[e22] || (o2[e22] = {}), o2[e22][i22] || (o2[e22][i22] = {}), o2[e22][i22][t22] || (o2[e22][i22][t22] = {}), this.isSpriteLoaded[e22] || (this.isSpriteLoaded[e22] = {}), o2[e22][i22][t22][s2] || (o2[e22][i22][t22][s2] = new this.workerSourceTypes[t22]({ send: (t3, s3, i3, o3, n22, r22) => this.actor.send(t3, s3, i3, e22, n22, r22), scheduler: this.actor.scheduler }, this.getLayerIndex(e22, i22), this.getAvailableImages(e22, i22), this.getAvailableModels(e22, i22), this.isSpriteLoaded[e22][i22], void 0, this.brightness)), o2[e22][i22][t22][s2];
        }
        rasterizeImagesWorker(e22, t22, s2) {
          const i22 = /* @__PURE__ */ new Map();
          for (const [s3, { image: o2, imageVariant: n22 }] of t22.tasks.entries()) {
            const r22 = this.imageRasterizer.rasterize(n22, o2, t22.scope, e22);
            i22.set(s3, r22);
          }
          s2(void 0, i22);
        }
        removeRasterizedImages(e22, t22, s2) {
          this.imageRasterizer.removeImagesFromCacheByIds(t22.imageIds, t22.scope, e22), s2();
        }
        enforceCacheSizeLimit(t22, s2) {
          e2.fo(s2);
        }
        getWorkerPerformanceMetrics(e22, t22, s2) {
          s2(void 0, void 0);
        }
      }
      return e2.fl(self) && (self.worker = new Ie(self)), Ie;
    });
    define2(["./shared"], function(e2) {
      var t2 = "3.12.0";
      const i2 = { create: "create", load: "load", fullLoad: "fullLoad" }, o = { mark(e22) {
        performance.mark(e22);
      }, measure(e22, t22, i22) {
        performance.measure(e22, t22, i22);
      } };
      function s(t22) {
        const i22 = t22.name.split("?")[0];
        return e2.a(i22) && i22.includes("mapbox-gl.js") ? "javascript" : e2.a(i22) && i22.includes("mapbox-gl.css") ? "css" : e2.b(i22) ? "fontRange" : e2.c(i22) ? "sprite" : e2.i(i22) ? "style" : e2.d(i22) ? "tilejson" : "other";
      }
      var r2, n2 = {}, a2 = function() {
        if (r2) return n2;
        function e22(e3) {
          return !t22(e3);
        }
        function t22(t3) {
          return "undefined" == typeof window || "undefined" == typeof document ? "not a browser" : function() {
            if (!("Worker" in window && "Blob" in window && "URL" in window)) return false;
            var e3, t4, i3 = new Blob([""], { type: "text/javascript" }), o3 = URL.createObjectURL(i3);
            try {
              t4 = new Worker(o3), e3 = true;
            } catch (t5) {
              e3 = false;
            }
            return t4 && t4.terminate(), URL.revokeObjectURL(o3), e3;
          }() ? function() {
            var e3 = document.createElement("canvas");
            e3.width = e3.height = 1;
            var t4 = e3.getContext("2d");
            if (!t4) return false;
            var i3 = t4.getImageData(0, 0, 1, 1);
            return i3 && i3.width === e3.width;
          }() ? (void 0 === i22[o2 = t3 && t3.failIfMajorPerformanceCaveat] && (i22[o2] = function(t4) {
            var i3, o3 = function(t5) {
              var i4 = document.createElement("canvas"), o4 = Object.create(e22.webGLContextAttributes);
              return o4.failIfMajorPerformanceCaveat = t5, i4.getContext("webgl2", o4);
            }(t4);
            if (!o3) return false;
            try {
              i3 = o3.createShader(o3.VERTEX_SHADER);
            } catch (e3) {
              return false;
            }
            return !(!i3 || o3.isContextLost()) && (o3.shaderSource(i3, "void main() {}"), o3.compileShader(i3), true === o3.getShaderParameter(i3, o3.COMPILE_STATUS));
          }(o2)), i22[o2] ? document.documentMode ? "insufficient ECMAScript 6 support" : void 0 : "insufficient WebGL2 support") : "insufficient Canvas/getImageData support" : "insufficient worker support";
          var o2;
        }
        r2 = 1, n2.supported = e22, n2.notSupportedReason = t22;
        var i22 = {};
        return e22.webGLContextAttributes = { antialias: false, alpha: true, stencil: true, depth: true }, n2;
      }();
      function l2(e22, t22, i22) {
        const o2 = document.createElement(e22);
        return null != t22 && (o2.className = t22), i22 && i22.appendChild(o2), o2;
      }
      function c2(e22, t22, i22) {
        const o2 = document.createElementNS("http://www.w3.org/2000/svg", e22);
        for (const e3 of Object.keys(t22)) o2.setAttributeNS(null, e3, String(t22[e3]));
        return i22 && i22.appendChild(o2), o2;
      }
      const h2 = "undefined" != typeof document ? document.documentElement && document.documentElement.style : null, d2 = h2 && void 0 !== h2.userSelect ? "userSelect" : "WebkitUserSelect";
      let u2;
      function _2() {
        h2 && d2 && (u2 = h2[d2], h2[d2] = "none");
      }
      function p2() {
        h2 && d2 && (h2[d2] = u2);
      }
      function f2(e22) {
        e22.preventDefault(), e22.stopPropagation(), window.removeEventListener("click", f2, true);
      }
      function m2() {
        window.addEventListener("click", f2, true), window.setTimeout(() => {
          window.removeEventListener("click", f2, true);
        }, 0);
      }
      function g2(e22, t22) {
        const i22 = e22.getBoundingClientRect();
        return x2(e22, i22, t22);
      }
      function v2(e22, t22) {
        const i22 = e22.getBoundingClientRect(), o2 = [];
        for (let s2 = 0; s2 < t22.length; s2++) o2.push(x2(e22, i22, t22[s2]));
        return o2;
      }
      function y2(e22) {
        return /firefox/i.test(navigator.userAgent) && /macintosh/i.test(navigator.userAgent) && 2 === e22.button && e22.ctrlKey ? 0 : e22.button;
      }
      function x2(t22, i22, o2) {
        const s2 = t22.offsetWidth === i22.width ? 1 : t22.offsetWidth / i22.width;
        return new e2.P((o2.clientX - i22.left) * s2, (o2.clientY - i22.top) * s2);
      }
      const b2 = "01", w2 = "NO_ACCESS_TOKEN";
      class T {
        constructor(e22, t22, i22) {
          this._transformRequestFn = e22, this._customAccessToken = t22, this._silenceAuthErrors = !!i22, this._createSkuToken();
        }
        _createSkuToken() {
          const e22 = function() {
            let e3 = "";
            for (let t22 = 0; t22 < 10; t22++) e3 += "0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ"[Math.floor(62 * Math.random())];
            return { token: ["1", b2, e3].join(""), tokenExpiresAt: Date.now() + 432e5 };
          }();
          this._skuToken = e22.token, this._skuTokenExpiresAt = e22.tokenExpiresAt;
        }
        _isSkuTokenExpired() {
          return Date.now() > this._skuTokenExpiresAt;
        }
        transformRequest(e22, t22) {
          return this._transformRequestFn && this._transformRequestFn(e22, t22) || { url: e22 };
        }
        normalizeStyleURL(i22, o2) {
          if (!e2.f(i22)) return i22;
          const s2 = S(i22);
          return s2.params.push(`sdk=js-${t2}`), s2.path = `/styles/v1${s2.path}`, this._makeAPIURL(s2, this._customAccessToken || o2);
        }
        normalizeGlyphsURL(t22, i22) {
          if (!e2.f(t22)) return t22;
          const o2 = S(t22);
          return o2.path = `/fonts/v1${o2.path}`, this._makeAPIURL(o2, this._customAccessToken || i22);
        }
        normalizeModelURL(t22, i22) {
          if (!e2.f(t22)) return t22;
          const o2 = S(t22);
          return o2.path = `/models/v1${o2.path}`, this._makeAPIURL(o2, this._customAccessToken || i22);
        }
        normalizeSourceURL(t22, i22, o2, s2) {
          if (!e2.f(t22)) return t22;
          const r22 = S(t22);
          return r22.path = `/v4/${r22.authority}.json`, r22.params.push("secure"), o2 && r22.params.push(`language=${o2}`), s2 && r22.params.push(`worldview=${s2}`), this._makeAPIURL(r22, this._customAccessToken || i22);
        }
        normalizeIconsetURL(t22, i22) {
          const o2 = S(t22);
          return e2.f(t22) ? (o2.path = `/styles/v1${o2.path}/iconset.pbf`, this._makeAPIURL(o2, this._customAccessToken || i22)) : I(o2);
        }
        normalizeSpriteURL(t22, i22, o2, s2) {
          const r22 = S(t22);
          return e2.f(t22) ? (r22.path = `/styles/v1${r22.path}/sprite${i22}${o2}`, this._makeAPIURL(r22, this._customAccessToken || s2)) : (r22.path += `${i22}${o2}`, I(r22));
        }
        normalizeTileURL(t22, i22, o2) {
          if (this._isSkuTokenExpired() && this._createSkuToken(), t22 && !e2.f(t22)) return t22;
          const s2 = S(t22);
          s2.path = s2.path.replace(/(\.(png|jpg)\d*)(?=$)/, `${i22 || o2 && "raster" !== s2.authority && 512 === o2 ? "@2x" : ""}${e2.m.supported ? ".webp" : "$1"}`), "raster" === s2.authority ? s2.path = `/${e2.e.RASTER_URL_PREFIX}${s2.path}` : "rasterarrays" === s2.authority ? s2.path = `/${e2.e.RASTERARRAYS_URL_PREFIX}${s2.path}` : "3dtiles" === s2.authority ? s2.path = `/${e2.e.TILES3D_URL_PREFIX}${s2.path}` : (s2.path = s2.path.replace(/^.+\/v4\//, "/"), s2.path = `/${e2.e.TILE_URL_VERSION}${s2.path}`);
          const r22 = this._customAccessToken || function(e22) {
            for (const t3 of e22) {
              const e3 = t3.match(/^access_token=(.*)$/);
              if (e3) return e3[1];
            }
            return null;
          }(s2.params) || e2.e.ACCESS_TOKEN;
          return e2.e.REQUIRE_ACCESS_TOKEN && r22 && this._skuToken && s2.params.push(`sku=${this._skuToken}`), this._makeAPIURL(s2, r22);
        }
        canonicalizeTileURL(t22, i22) {
          const o2 = S(t22);
          if (!o2.path.match(/^(\/v4\/|\/(raster|rasterarrays)\/v1\/)/) || !o2.path.match(/\.[\w]+$/)) return t22;
          let s2 = "mapbox://";
          o2.path.match(/^\/raster\/v1\//) ? s2 += `raster/${o2.path.replace(`/${e2.e.RASTER_URL_PREFIX}/`, "")}` : o2.path.match(/^\/rasterarrays\/v1\//) ? s2 += `rasterarrays/${o2.path.replace(`/${e2.e.RASTERARRAYS_URL_PREFIX}/`, "")}` : s2 += `tiles/${o2.path.replace(`/${e2.e.TILE_URL_VERSION}/`, "")}`;
          let r22 = o2.params;
          return i22 && (r22 = r22.filter((e22) => !e22.match(/^access_token=/))), r22.length && (s2 += `?${r22.join("&")}`), s2;
        }
        canonicalizeTileset(t22, i22) {
          const o2 = !!i22 && e2.f(i22), s2 = [];
          for (const i3 of t22.tiles || []) e2.h(i3) ? s2.push(this.canonicalizeTileURL(i3, o2)) : s2.push(i3);
          return s2;
        }
        _makeAPIURL(t22, i22) {
          const o2 = "See https://docs.mapbox.com/api/overview/#access-tokens-and-token-scopes", s2 = S(e2.e.API_URL);
          if (t22.protocol = s2.protocol, t22.authority = s2.authority, "http" === t22.protocol) {
            const e22 = t22.params.indexOf("secure");
            e22 >= 0 && t22.params.splice(e22, 1);
          }
          if ("/" !== s2.path && (t22.path = `${s2.path}${t22.path}`), !e2.e.REQUIRE_ACCESS_TOKEN) return I(t22);
          if (i22 = i22 || e2.e.ACCESS_TOKEN, !this._silenceAuthErrors) {
            if (!i22) throw new Error(`An API access token is required to use Mapbox GL. ${o2}`);
            if ("s" === i22[0]) throw new Error(`Use a public access token (pk.*) with Mapbox GL, not a secret access token (sk.*). ${o2}`);
          }
          return t22.params = t22.params.filter((e22) => -1 === e22.indexOf("access_token")), t22.params.push(`access_token=${i22 || ""}`), I(t22);
        }
      }
      const E2 = /^(\w+):\/\/([^/?]*)(\/[^?]+)?\??(.+)?/;
      function S(e22) {
        const t22 = e22.match(E2);
        if (!t22) throw new Error("Unable to parse URL object");
        return { protocol: t22[1], authority: t22[2], path: t22[3] || "/", params: t22[4] ? t22[4].split("&") : [] };
      }
      function I(e22) {
        const t22 = e22.params.length ? `?${e22.params.join("&")}` : "";
        return `${e22.protocol}://${e22.authority}${e22.path}${t22}`;
      }
      const C = "mapbox.eventData";
      function R2(t22) {
        if (!t22) return null;
        const i22 = t22.split(".");
        if (!i22 || 3 !== i22.length) return null;
        try {
          return JSON.parse(e2.j(i22[1]));
        } catch (e22) {
          return null;
        }
      }
      class D2 {
        constructor(e22) {
          this.type = e22, this.anonId = null, this.eventData = {}, this.queue = [], this.pendingRequest = null;
        }
        getStorageKey(t22) {
          const i22 = R2(e2.e.ACCESS_TOKEN);
          let o2 = "";
          return o2 = i22 && i22.u ? e2.k(i22.u) : e2.e.ACCESS_TOKEN || "", t22 ? `${C}.${t22}:${o2}` : `${C}:${o2}`;
        }
        fetchEventData() {
          const t22 = e2.s("localStorage"), i22 = this.getStorageKey(), o2 = this.getStorageKey("uuid");
          if (t22) try {
            const e22 = localStorage.getItem(i22);
            e22 && (this.eventData = JSON.parse(e22));
            const t3 = localStorage.getItem(o2);
            t3 && (this.anonId = t3);
          } catch (t3) {
            e2.w("Unable to read from LocalStorage");
          }
        }
        saveEventData() {
          const t22 = e2.s("localStorage"), i22 = this.getStorageKey(), o2 = this.getStorageKey("uuid"), s2 = this.anonId;
          if (t22 && s2) try {
            localStorage.setItem(o2, s2), Object.keys(this.eventData).length >= 1 && localStorage.setItem(i22, JSON.stringify(this.eventData));
          } catch (t3) {
            e2.w("Unable to write to LocalStorage");
          }
        }
        processRequests(e22) {
        }
        postEvent(t22, i22, o2, s2) {
          if (!e2.e.EVENTS_URL) return;
          const r22 = S(e2.e.EVENTS_URL);
          r22.params.push(`access_token=${s2 || e2.e.ACCESS_TOKEN || ""}`);
          const n22 = { event: this.type, created: new Date(t22).toISOString() }, a22 = i22 ? e2.l(n22, i22) : n22, l22 = { url: I(r22), headers: { "Content-Type": "text/plain" }, body: JSON.stringify([a22]) };
          this.pendingRequest = e2.p(l22, (e22) => {
            this.pendingRequest = null, o2(e22), this.saveEventData(), this.processRequests(s2);
          });
        }
        queueRequest(e22, t22) {
          this.queue.push(e22), this.processRequests(t22);
        }
      }
      const A2 = new class extends D2 {
        constructor(e22) {
          super("appUserTurnstile"), this._customAccessToken = e22;
        }
        postTurnstileEvent(t22, i22) {
          e2.e.EVENTS_URL && e2.e.ACCESS_TOKEN && Array.isArray(t22) && t22.some((t3) => e2.f(t3) || e2.h(t3)) && this.queueRequest(Date.now(), i22);
        }
        processRequests(i22) {
          if (this.pendingRequest || 0 === this.queue.length) return;
          this.anonId && this.eventData.lastSuccess && this.eventData.tokenU || this.fetchEventData();
          const o2 = R2(e2.e.ACCESS_TOKEN), s2 = o2 ? o2.u : e2.e.ACCESS_TOKEN;
          let r22 = s2 !== this.eventData.tokenU;
          e2.v(this.anonId) || (this.anonId = e2.u(), r22 = true);
          const n22 = this.queue.shift();
          if (this.eventData.lastSuccess) {
            const e22 = new Date(this.eventData.lastSuccess), t22 = new Date(n22), i3 = (n22 - this.eventData.lastSuccess) / 864e5;
            r22 = r22 || i3 >= 1 || i3 < -1 || e22.getDate() !== t22.getDate();
          } else r22 = true;
          r22 ? this.postEvent(n22, { sdkIdentifier: "mapbox-gl-js", sdkVersion: t2, skuId: b2, "enabled.telemetry": false, userId: this.anonId }, (e22) => {
            e22 || (this.eventData.lastSuccess = n22, this.eventData.tokenU = s2);
          }, i22) : this.processRequests();
        }
      }(), L2 = A2.postTurnstileEvent.bind(A2), P2 = new class extends D2 {
        constructor() {
          super("map.load"), this.success = {}, this.skuToken = "";
        }
        postMapLoadEvent(t22, i22, o2, s2) {
          this.skuToken = i22, this.errorCb = s2, e2.e.EVENTS_URL && (o2 || e2.e.ACCESS_TOKEN ? this.queueRequest({ id: t22, timestamp: Date.now() }, o2) : this.errorCb(new Error(w2)));
        }
        processRequests(i22) {
          if (this.pendingRequest || 0 === this.queue.length) return;
          const { id: o2, timestamp: s2 } = this.queue.shift();
          o2 && this.success[o2] || (this.anonId || this.fetchEventData(), e2.v(this.anonId) || (this.anonId = e2.u()), this.postEvent(s2, { sdkIdentifier: "mapbox-gl-js", sdkVersion: t2, skuId: b2, skuToken: this.skuToken, userId: this.anonId }, (e22) => {
            e22 ? this.errorCb(e22) : o2 && (this.success[o2] = true);
          }, i22));
        }
        remove() {
          this.errorCb = null;
        }
      }(), z2 = P2.postMapLoadEvent.bind(P2), M2 = new class extends D2 {
        constructor() {
          super("style.load"), this.eventIdPerMapInstanceMap = /* @__PURE__ */ new Map(), this.mapInstanceIdMap = /* @__PURE__ */ new WeakMap();
        }
        getMapInstanceId(t22) {
          let i22 = this.mapInstanceIdMap.get(t22);
          return i22 || (i22 = e2.u(), this.mapInstanceIdMap.set(t22, i22)), i22;
        }
        getEventId(e22) {
          const t22 = this.eventIdPerMapInstanceMap.get(e22) || 0;
          return this.eventIdPerMapInstanceMap.set(e22, t22 + 1), t22;
        }
        postStyleLoadEvent(t22, i22) {
          const { map: o2, style: s2, importedStyles: r22 } = i22;
          if (!e2.e.EVENTS_URL || !t22 && !e2.e.ACCESS_TOKEN) return;
          const n22 = this.getMapInstanceId(o2), a22 = { mapInstanceId: n22, eventId: this.getEventId(n22), style: s2 };
          r22.length && (a22.importedStyles = r22), this.queueRequest({ timestamp: Date.now(), payload: a22 }, t22);
        }
        processRequests(e22) {
          if (this.pendingRequest || 0 === this.queue.length) return;
          const { timestamp: t22, payload: i22 } = this.queue.shift();
          this.postEvent(t22, i22, () => {
          }, e22);
        }
      }(), O = M2.postStyleLoadEvent.bind(M2), F = new class extends D2 {
        constructor() {
          super("gljs.performance");
        }
        postPerformanceEvent(t22, i22) {
          e2.e.EVENTS_URL && (t22 || e2.e.ACCESS_TOKEN) && this.queueRequest({ timestamp: Date.now(), performanceData: i22 }, t22);
        }
        processRequests(o2) {
          if (this.pendingRequest || 0 === this.queue.length) return;
          const { timestamp: r22, performanceData: n22 } = this.queue.shift(), a22 = function(o3) {
            const r3 = performance.getEntriesByType("resource"), n3 = performance.getEntriesByType("mark"), a3 = function(e22) {
              const t22 = {};
              if (e22) {
                for (const i22 in e22) if ("other" !== i22) for (const o4 of e22[i22]) {
                  const e3 = `${i22}ResolveRangeMin`, s2 = `${i22}ResolveRangeMax`, r4 = `${i22}RequestCount`, n4 = `${i22}RequestCachedCount`;
                  t22[e3] = Math.min(t22[e3] || 1 / 0, o4.startTime), t22[s2] = Math.max(t22[s2] || -1 / 0, o4.responseEnd);
                  const a4 = (e4) => {
                    void 0 === t22[e4] && (t22[e4] = 0), ++t22[e4];
                  };
                  void 0 !== o4.transferSize && 0 === o4.transferSize && a4(n4), a4(r4);
                }
              }
              return t22;
            }(function(e22, t22) {
              const i22 = {};
              if (e22) for (const o4 of e22) {
                const e3 = t22(o4);
                void 0 === i22[e3] && (i22[e3] = []), i22[e3].push(o4);
              }
              return i22;
            }(r3, s)), l22 = window.devicePixelRatio, c22 = navigator.connection || navigator.mozConnection || navigator.webkitConnection, h22 = c22 ? c22.effectiveType : void 0, d22 = { counters: [], metadata: [], attributes: [] }, u22 = (e22, t22, i22) => {
              null != i22 && e22.push({ name: t22, value: i22.toString() });
            };
            for (const e22 in a3) u22(d22.counters, e22, a3[e22]);
            if (o3.interactionRange[0] !== 1 / 0 && o3.interactionRange[1] !== -1 / 0 && (u22(d22.counters, "interactionRangeMin", o3.interactionRange[0]), u22(d22.counters, "interactionRangeMax", o3.interactionRange[1])), n3) for (const e22 of Object.keys(i2)) {
              const t22 = i2[e22], o4 = n3.find((e3) => e3.name === t22);
              o4 && u22(d22.counters, t22, o4.startTime);
            }
            return u22(d22.counters, "visibilityHidden", o3.visibilityHidden), u22(d22.attributes, "style", function(t22) {
              if (t22) for (const i22 of t22) {
                const t3 = i22.name.split("?")[0];
                if (e2.i(t3)) {
                  const e22 = t3.split("/").slice(-2);
                  if (2 === e22.length) return `mapbox://styles/${e22[0]}/${e22[1]}`;
                }
              }
            }(r3)), u22(d22.attributes, "terrainEnabled", o3.terrainEnabled ? "true" : "false"), u22(d22.attributes, "fogEnabled", o3.fogEnabled ? "true" : "false"), u22(d22.attributes, "projection", o3.projection), u22(d22.attributes, "zoom", o3.zoom), u22(d22.metadata, "devicePixelRatio", l22), u22(d22.metadata, "connectionEffectiveType", h22), u22(d22.metadata, "navigatorUserAgent", navigator.userAgent), u22(d22.metadata, "screenWidth", window.screen.width), u22(d22.metadata, "screenHeight", window.screen.height), u22(d22.metadata, "windowWidth", window.innerWidth), u22(d22.metadata, "windowHeight", window.innerHeight), u22(d22.metadata, "mapWidth", o3.width / l22), u22(d22.metadata, "mapHeight", o3.height / l22), u22(d22.metadata, "webglRenderer", o3.renderer), u22(d22.metadata, "webglVendor", o3.vendor), u22(d22.metadata, "sdkVersion", t2), u22(d22.metadata, "sdkIdentifier", "mapbox-gl-js"), d22;
          }(n22);
          for (const e22 of a22.metadata) ;
          for (const e22 of a22.counters) ;
          for (const e22 of a22.attributes) ;
          this.postEvent(r22, a22, () => {
          }, o2);
        }
      }(), B2 = F.postPerformanceEvent.bind(F), k2 = new class extends D2 {
        constructor() {
          super("map.auth"), this.success = {}, this.skuToken = "";
        }
        getSession(t22, i22, o2, s2) {
          if (!e2.e.API_URL || !e2.e.SESSION_PATH) return;
          const r22 = S(e2.e.API_URL + e2.e.SESSION_PATH);
          r22.params.push(`sku=${i22 || ""}`), r22.params.push(`access_token=${s2 || e2.e.ACCESS_TOKEN || ""}`);
          const n22 = { url: I(r22), headers: { "Content-Type": "text/plain" } };
          this.pendingRequest = e2.g(n22, (e22) => {
            this.pendingRequest = null, o2(e22), this.saveEventData(), this.processRequests(s2);
          });
        }
        getSessionAPI(t22, i22, o2, s2) {
          this.skuToken = i22, this.errorCb = s2, e2.e.SESSION_PATH && e2.e.API_URL && (o2 || e2.e.ACCESS_TOKEN ? this.queueRequest({ id: t22, timestamp: Date.now() }, o2) : this.errorCb(new Error(w2)));
        }
        processRequests(e22) {
          if (this.pendingRequest || 0 === this.queue.length) return;
          const { id: t22, timestamp: i22 } = this.queue.shift();
          t22 && this.success[t22] || this.getSession(i22, this.skuToken, (e3) => {
            e3 ? this.errorCb(e3) : t22 && (this.success[t22] = true);
          }, e22);
        }
        remove() {
          this.errorCb = null;
        }
      }(), N2 = k2.getSessionAPI.bind(k2), U2 = /* @__PURE__ */ new Set();
      function j2(e22, t22) {
        t22 ? U2.add(e22) : U2.delete(e22);
      }
      class V {
        constructor() {
          this._changed = false, this._updatedLayers = {}, this._removedLayers = {}, this._updatedSourceCaches = {}, this._updatedPaintProps = /* @__PURE__ */ new Set(), this._updatedImages = {};
        }
        isDirty() {
          return this._changed;
        }
        setDirty() {
          this._changed = true;
        }
        getUpdatedSourceCaches() {
          return this._updatedSourceCaches;
        }
        updateSourceCache(e22, t22) {
          this._updatedSourceCaches[e22] = t22, this.setDirty();
        }
        discardSourceCacheUpdate(e22) {
          delete this._updatedSourceCaches[e22];
        }
        updateLayer(e22) {
          const t22 = e22.scope;
          this._updatedLayers[t22] = this._updatedLayers[t22] || /* @__PURE__ */ new Set(), this._updatedLayers[t22].add(e22.id), this.setDirty();
        }
        removeLayer(e22) {
          const t22 = e22.scope;
          this._removedLayers[t22] = this._removedLayers[t22] || {}, this._updatedLayers[t22] = this._updatedLayers[t22] || /* @__PURE__ */ new Set(), this._removedLayers[t22][e22.id] = e22, this._updatedLayers[t22].delete(e22.id), this._updatedPaintProps.delete(e22.fqid), this.setDirty();
        }
        getRemovedLayer(e22) {
          return this._removedLayers[e22.scope] ? this._removedLayers[e22.scope][e22.id] : null;
        }
        discardLayerRemoval(e22) {
          this._removedLayers[e22.scope] && delete this._removedLayers[e22.scope][e22.id];
        }
        getLayerUpdatesByScope() {
          const e22 = {};
          for (const t22 in this._updatedLayers) e22[t22] = e22[t22] || {}, e22[t22].updatedIds = Array.from(this._updatedLayers[t22].values());
          for (const t22 in this._removedLayers) e22[t22] = e22[t22] || {}, e22[t22].removedIds = Object.keys(this._removedLayers[t22]);
          return e22;
        }
        getUpdatedPaintProperties() {
          return this._updatedPaintProps;
        }
        updatePaintProperties(e22) {
          this._updatedPaintProps.add(e22.fqid), this.setDirty();
        }
        getUpdatedImages(e22) {
          return this._updatedImages[e22] ? Array.from(this._updatedImages[e22].values()) : [];
        }
        updateImage(t22, i22) {
          this._updatedImages[i22] = this._updatedImages[i22] || /* @__PURE__ */ new Set(), this._updatedImages[i22].add(e2.I.toString(t22)), this.setDirty();
        }
        resetUpdatedImages(e22) {
          this._updatedImages[e22] && this._updatedImages[e22].clear();
        }
        reset() {
          this._changed = false, this._updatedLayers = {}, this._removedLayers = {}, this._updatedSourceCaches = {}, this._updatedPaintProps.clear(), this._updatedImages = {};
        }
      }
      function G(e22) {
        const { userImage: t22 } = e22;
        return !!(t22 && t22.render && t22.render()) && (e22.data.replace(new Uint8Array(t22.data.buffer)), true);
      }
      class q2 extends e2.E {
        constructor(t22) {
          super(), this.imageProviders = /* @__PURE__ */ new Map(), this.images = /* @__PURE__ */ new Map(), this.updatedImages = /* @__PURE__ */ new Map(), this.callbackDispatchedThisFrame = /* @__PURE__ */ new Map(), this.loaded = /* @__PURE__ */ new Map(), this.requestors = [], this.patterns = /* @__PURE__ */ new Map(), this.patternsInFlight = /* @__PURE__ */ new Set(), this.atlasImage = /* @__PURE__ */ new Map(), this.atlasTexture = /* @__PURE__ */ new Map(), this.dirty = true, this.spriteFormat = t22, "raster" !== t22 && e2.t() && (this.imageRasterizerDispatcher = new e2.D(e2.x(), this, "Image Rasterizer Worker", 1));
        }
        addScope(t22) {
          this.loaded.set(t22, false), this.imageProviders.set(t22, /* @__PURE__ */ new Map()), this.images.set(t22, /* @__PURE__ */ new Map()), this.updatedImages.set(t22, /* @__PURE__ */ new Set()), this.callbackDispatchedThisFrame.set(t22, /* @__PURE__ */ new Set()), this.patterns.set(t22, /* @__PURE__ */ new Map()), this.atlasImage.set(t22, new e2.r({ width: 1, height: 1 }));
        }
        removeScope(e22) {
          this.loaded.delete(e22), this.imageProviders.delete(e22), this.images.delete(e22), this.updatedImages.delete(e22), this.callbackDispatchedThisFrame.delete(e22), this.patterns.delete(e22), this.atlasImage.delete(e22);
          const t22 = this.atlasTexture.get(e22);
          t22 && (t22.destroy(), this.atlasTexture.delete(e22));
        }
        addImageProvider(e22, t22) {
          this.imageProviders.has(t22) || this.imageProviders.set(t22, /* @__PURE__ */ new Map()), this.imageProviders.get(t22).set(e22.id, e22);
        }
        removeImageProvider(e22, t22) {
          this.imageProviders.has(t22) && this.imageProviders.get(t22).delete(e22);
        }
        getPendingImageProviders() {
          const e22 = [];
          for (const t22 of this.imageProviders.values()) for (const i22 of t22.values()) i22.hasPendingRequests() && e22.push(i22);
          return e22;
        }
        get imageRasterizer() {
          return this._imageRasterizer || (this._imageRasterizer = new e2.y()), this._imageRasterizer;
        }
        isLoaded() {
          for (const e22 of this.loaded.keys()) if (!this.loaded.get(e22)) return false;
          return true;
        }
        setLoaded(e22, t22) {
          if (this.loaded.get(t22) !== e22 && (this.loaded.set(t22, e22), e22)) {
            for (const { ids: e3, callback: i22 } of this.requestors) this._notify(e3, t22, i22);
            this.requestors = [];
          }
        }
        hasImage(e22, t22) {
          return !!this.getImage(e22, t22);
        }
        getImage(e22, t22) {
          return this.images.get(t22).get(e22.toString());
        }
        addImage(e22, t22, i22) {
          this._validate(e22, i22) && this.images.get(t22).set(e22.toString(), i22);
        }
        _validate(t22, i22) {
          let o2 = true;
          return this._validateStretch(i22.stretchX, i22.data && i22.data.width) || (this.fire(new e2.z(new Error(`Image "${t22.name}" has invalid "stretchX" value`))), o2 = false), this._validateStretch(i22.stretchY, i22.data && i22.data.height) || (this.fire(new e2.z(new Error(`Image "${t22.name}" has invalid "stretchY" value`))), o2 = false), this._validateContent(i22.content, i22) || (this.fire(new e2.z(new Error(`Image "${t22.name}" has invalid "content" value`))), o2 = false), o2;
        }
        _validateStretch(e22, t22) {
          if (!e22) return true;
          let i22 = 0;
          for (const o2 of e22) {
            if (o2[0] < i22 || o2[1] < o2[0] || t22 < o2[1]) return false;
            i22 = o2[1];
          }
          return true;
        }
        _validateContent(e22, t22) {
          if (!e22) return true;
          if (4 !== e22.length) return false;
          if (!t22.usvg) {
            if (e22[0] < 0 || t22.data.width < e22[0]) return false;
            if (e22[1] < 0 || t22.data.height < e22[1]) return false;
            if (e22[2] < 0 || t22.data.width < e22[2]) return false;
            if (e22[3] < 0 || t22.data.height < e22[3]) return false;
          }
          return !(e22[2] < e22[0] || e22[3] < e22[1]);
        }
        updateImage(e22, t22, i22) {
          const o2 = this.images.get(t22).get(e22.toString());
          i22.version = o2.version + 1, this.images.get(t22).set(e22.toString(), i22), this.updatedImages.get(t22).add(e22), this.removeFromImageRasterizerCache(e22, t22);
        }
        clearUpdatedImages(e22) {
          this.updatedImages.get(e22).clear();
        }
        removeFromImageRasterizerCache(t22, i22) {
          "raster" !== this.spriteFormat && (e2.t() ? this.imageRasterizerDispatcher.getActor().send("removeRasterizedImages", { imageIds: [t22], scope: i22 }) : this.imageRasterizer.removeImagesFromCacheByIds([t22], i22));
        }
        removeImage(e22, t22) {
          const i22 = this.images.get(t22), o2 = i22.get(e22.toString());
          i22.delete(e22.toString()), this.patterns.get(t22).delete(e22.toString()), this.removeFromImageRasterizerCache(e22, t22), o2.userImage && o2.userImage.onRemove && o2.userImage.onRemove();
        }
        listImages(t22) {
          return Array.from(this.images.get(t22).keys()).map((t3) => e2.I.from(t3));
        }
        getImages(e22, t22, i22) {
          const o2 = [], s2 = [], r22 = this.imageProviders.get(t22);
          for (const i3 of e22) {
            if (!i3.iconsetId) {
              o2.push(i3);
              continue;
            }
            const e3 = r22.get(i3.iconsetId);
            e3 && (this.getImage(i3, t22) ? s2.push(i3) : e3.addPendingRequest(i3));
          }
          if (0 === o2.length) return void this._notify(s2, t22, i22);
          let n22 = true;
          const a22 = !!this.loaded.get(t22), l22 = this.images.get(t22);
          if (!a22) for (const e3 of o2) l22.has(e3.toString()) || (n22 = false);
          a22 || n22 ? this._notify(o2, t22, i22) : this.requestors.push({ ids: o2, scope: t22, callback: i22 });
        }
        rasterizeImages(e22, t22) {
          const i22 = /* @__PURE__ */ new Map(), { tasks: o2, scope: s2 } = e22;
          for (const [e3, t3] of o2.entries()) {
            const o3 = this.getImage(t3.id, s2);
            o3 && i22.set(e3, { image: o3, imageVariant: t3 });
          }
          this._rasterizeImages(s2, i22, t22);
        }
        _rasterizeImages(t22, i22, o2) {
          if (e2.t()) this.imageRasterizerDispatcher.getActor().send("rasterizeImagesWorker", { tasks: i22, scope: t22 }, o2);
          else {
            const e22 = /* @__PURE__ */ new Map();
            for (const [o3, { image: s2, imageVariant: r22 }] of i22.entries()) e22.set(o3, this.imageRasterizer.rasterize(r22, s2, t22, 0));
            o2(void 0, e22);
          }
        }
        getUpdatedImages(e22) {
          return this.updatedImages.get(e22) || /* @__PURE__ */ new Set();
        }
        _notify(t22, i22, o2) {
          const s2 = this.images.get(i22), r22 = /* @__PURE__ */ new Map();
          for (const i3 of t22) {
            if (!s2.get(i3.toString())) {
              if (i3.iconsetId) continue;
              this.fire(new e2.A("styleimagemissing", { id: i3.name }));
            }
            const t3 = s2.get(i3.toString());
            if (!t3) {
              e2.w(`Image "${i3.name}" could not be loaded. Please make sure you have added the image with map.addImage() or a "sprite" property in your style. You can provide missing images by listening for the "styleimagemissing" map event.`);
              continue;
            }
            const o3 = { data: t3.usvg ? null : t3.data.clone(), pixelRatio: t3.pixelRatio, sdf: t3.sdf, usvg: t3.usvg, version: t3.version, stretchX: t3.stretchX, stretchY: t3.stretchY, content: t3.content, hasRenderCallback: Boolean(t3.userImage && t3.userImage.render) };
            t3.usvg && Object.assign(o3, { width: t3.icon.usvg_tree.width, height: t3.icon.usvg_tree.height }), r22.set(e2.I.toString(i3), o3);
          }
          o2(null, r22);
        }
        getPixelSize(e22) {
          const { width: t22, height: i22 } = this.atlasImage.get(e22);
          return { width: t22, height: i22 };
        }
        getPattern(t22, i22, o2) {
          const s2 = t22.toString(), r22 = this.patterns.get(i22), n22 = r22.get(s2), a22 = this.getImage(t22, i22);
          if (!a22) return null;
          if (n22) {
            if (n22.position.version === a22.version) return n22.position;
            n22.position.version = a22.version;
          } else {
            if (a22.usvg && !a22.data) {
              const r3 = this.getPatternInFlightId(s2, i22);
              if (this.patternsInFlight.has(r3)) return null;
              this.patternsInFlight.add(r3);
              const n3 = new e2.B(t22).scaleSelf(e2.q.devicePixelRatio), l22 = /* @__PURE__ */ new Map([[n3.toString(), { image: a22, imageVariant: n3 }]]);
              return this._rasterizeImages(i22, l22, (e22, t3) => this.storePatternImage(n3, i22, a22, o2, t3)), null;
            }
            this.storePattern(t22, i22, a22);
          }
          return this._updatePatternAtlas(i22, o2), r22.get(s2).position;
        }
        getPatternInFlightId(t22, i22) {
          return e2.C(t22, i22);
        }
        hasPatternsInFlight() {
          return 0 !== this.patternsInFlight.size;
        }
        storePatternImage(e22, t22, i22, o2, s2) {
          const r22 = e22.toString(), n22 = s2 ? s2.get(r22) : void 0;
          n22 && (i22.data = n22, this.storePattern(e22.id, t22, i22), this._updatePatternAtlas(t22, o2), this.patternsInFlight.delete(this.getPatternInFlightId(e22.id.toString(), t22)));
        }
        storePattern(t22, i22, o2) {
          const s2 = { w: o2.data.width + 2 * e2.F, h: o2.data.height + 2 * e2.F, x: 0, y: 0 }, r22 = new e2.G(s2, o2, e2.F);
          this.patterns.get(i22).set(t22.toString(), { bin: s2, position: r22 });
        }
        bind(t22, i22) {
          const o2 = t22.gl;
          let s2 = this.atlasTexture.get(i22);
          s2 ? this.dirty && (s2.update(this.atlasImage.get(i22)), this.dirty = false) : (s2 = new e2.T(t22, this.atlasImage.get(i22), o2.RGBA8), this.atlasTexture.set(i22, s2)), s2.bind(o2.LINEAR, o2.CLAMP_TO_EDGE);
        }
        _updatePatternAtlas(t22, i22) {
          const o2 = this.patterns.get(t22), s2 = Array.from(o2.values()).map(({ bin: e22 }) => e22), { w: r22, h: n22 } = e2.H(s2), a22 = this.atlasImage.get(t22);
          a22.resize({ width: r22 || 1, height: n22 || 1 });
          const l22 = this.images.get(t22);
          for (const [t3, { bin: s3, position: r3 }] of o2.entries()) {
            let o3 = r3.padding;
            const n3 = s3.x + o3, c22 = s3.y + o3, h22 = l22.get(t3).data, d22 = h22.width, u22 = h22.height;
            o3 = o3 > 1 ? o3 - 1 : o3, e2.r.copy(h22, a22, { x: 0, y: 0 }, { x: n3, y: c22 }, { width: d22, height: u22 }, i22), e2.r.copy(h22, a22, { x: 0, y: u22 - o3 }, { x: n3, y: c22 - o3 }, { width: d22, height: o3 }, i22), e2.r.copy(h22, a22, { x: 0, y: 0 }, { x: n3, y: c22 + u22 }, { width: d22, height: o3 }, i22), e2.r.copy(h22, a22, { x: d22 - o3, y: 0 }, { x: n3 - o3, y: c22 }, { width: o3, height: u22 }, i22), e2.r.copy(h22, a22, { x: 0, y: 0 }, { x: n3 + d22, y: c22 }, { width: o3, height: u22 }, i22), e2.r.copy(h22, a22, { x: d22 - o3, y: u22 - o3 }, { x: n3 - o3, y: c22 - o3 }, { width: o3, height: o3 }, i22), e2.r.copy(h22, a22, { x: 0, y: u22 - o3 }, { x: n3 + d22, y: c22 - o3 }, { width: o3, height: o3 }, i22), e2.r.copy(h22, a22, { x: 0, y: 0 }, { x: n3 + d22, y: c22 + u22 }, { width: o3, height: o3 }, i22), e2.r.copy(h22, a22, { x: d22 - o3, y: 0 }, { x: n3 - o3, y: c22 + u22 }, { width: o3, height: o3 }, i22);
          }
          this.dirty = true;
        }
        beginFrame() {
          for (const e22 of this.images.keys()) this.callbackDispatchedThisFrame.set(e22, /* @__PURE__ */ new Set());
        }
        dispatchRenderCallbacks(e22, t22) {
          const i22 = this.images.get(t22);
          for (const o2 of e22) {
            if (this.callbackDispatchedThisFrame.get(t22).has(o2.toString())) continue;
            this.callbackDispatchedThisFrame.get(t22).add(o2.toString());
            const e3 = i22.get(o2.toString());
            G(e3) && this.updateImage(o2, t22, e3);
          }
        }
      }
      function Z(t22) {
        const i22 = t22.key, o2 = t22.value, s2 = t22.valueSpec || {}, r22 = t22.objectElementValidators || {}, n22 = t22.style, a22 = t22.styleSpec;
        let l22 = [];
        const c22 = e2.K(o2);
        if ("object" !== c22) return [new e2.V(i22, o2, `object expected, ${c22} found`)];
        for (const t3 in o2) {
          const c3 = t3.split(".")[0];
          let h22;
          r22[c3] ? h22 = r22[c3] : s2[c3] ? h22 = _e2 : r22["*"] ? h22 = r22["*"] : s2["*"] && (h22 = _e2), h22 ? l22 = l22.concat(h22({ key: (i22 ? `${i22}.` : i22) + t3, value: o2[t3], valueSpec: s2[c3] || s2["*"], style: n22, styleSpec: a22, object: o2, objectKey: t3 }, o2)) : l22.push(new e2.J(i22, o2[t3], `unknown property "${t3}"`));
        }
        for (const t3 in s2) r22[t3] || s2[t3].required && void 0 === s2[t3].default && void 0 === o2[t3] && l22.push(new e2.V(i22, o2, `missing required property "${t3}"`));
        return l22;
      }
      function H(t22) {
        const i22 = t22.value, o2 = t22.valueSpec, s2 = t22.style, r22 = t22.styleSpec, n22 = t22.key, a22 = t22.arrayElementValidator || _e2;
        if ("array" !== e2.K(i22)) return [new e2.V(n22, i22, `array expected, ${e2.K(i22)} found`)];
        if (o2.length && i22.length !== o2.length) return [new e2.V(n22, i22, `array length ${o2.length} expected, length ${i22.length} found`)];
        if (o2["min-length"] && i22.length < o2["min-length"]) return [new e2.V(n22, i22, `array length at least ${o2["min-length"]} expected, length ${i22.length} found`)];
        let l22 = { type: o2.value, values: o2.values, minimum: o2.minimum, maximum: o2.maximum, function: void 0 };
        r22.$version < 7 && (l22.function = o2.function), "object" === e2.K(o2.value) && (l22 = o2.value);
        let c22 = [];
        for (let e22 = 0; e22 < i22.length; e22++) c22 = c22.concat(a22({ array: i22, arrayIndex: e22, value: i22[e22], valueSpec: l22, style: s2, styleSpec: r22, key: `${n22}[${e22}]` }, true));
        return c22;
      }
      function W(t22) {
        const i22 = t22.key, o2 = t22.value, s2 = t22.valueSpec;
        let r22 = e2.K(o2);
        if ("number" === r22 && o2 != o2 && (r22 = "NaN"), "number" !== r22) return [new e2.V(i22, o2, `number expected, ${r22} found`)];
        if ("minimum" in s2) {
          let r3 = s2.minimum;
          if ("array" === e2.K(s2.minimum) && (r3 = s2.minimum[t22.arrayIndex]), o2 < r3) return [new e2.V(i22, o2, `${o2} is less than the minimum value ${r3}`)];
        }
        if ("maximum" in s2) {
          let r3 = s2.maximum;
          if ("array" === e2.K(s2.maximum) && (r3 = s2.maximum[t22.arrayIndex]), o2 > r3) return [new e2.V(i22, o2, `${o2} is greater than the maximum value ${r3}`)];
        }
        return [];
      }
      function $(t22) {
        const i22 = t22.valueSpec, o2 = e2.M(t22.value.type);
        let s2, r22, n22, a22 = {};
        const l22 = "categorical" !== o2 && void 0 === t22.value.property, c22 = !l22, h22 = "array" === e2.K(t22.value.stops) && "array" === e2.K(t22.value.stops[0]) && "object" === e2.K(t22.value.stops[0][0]), d22 = Z({ key: t22.key, value: t22.value, valueSpec: t22.styleSpec.function, style: t22.style, styleSpec: t22.styleSpec, objectElementValidators: { stops: function(t3) {
          if ("identity" === o2) return [new e2.V(t3.key, t3.value, 'identity function may not have a "stops" property')];
          let i3 = [];
          const s3 = t3.value;
          return i3 = i3.concat(H({ key: t3.key, value: s3, valueSpec: t3.valueSpec, style: t3.style, styleSpec: t3.styleSpec, arrayElementValidator: u22 })), "array" === e2.K(s3) && 0 === s3.length && i3.push(new e2.V(t3.key, s3, "array must have at least one stop")), i3;
        }, default: function(e22) {
          return _e2({ key: e22.key, value: e22.value, valueSpec: i22, style: e22.style, styleSpec: e22.styleSpec });
        } } });
        return "identity" === o2 && l22 && d22.push(new e2.V(t22.key, t22.value, 'missing required property "property"')), "identity" === o2 || t22.value.stops || d22.push(new e2.V(t22.key, t22.value, 'missing required property "stops"')), "exponential" === o2 && t22.valueSpec.expression && !e2.N(t22.valueSpec) && d22.push(new e2.V(t22.key, t22.value, "exponential functions not supported")), t22.styleSpec.$version >= 8 && (c22 && !e2.O(t22.valueSpec) ? d22.push(new e2.V(t22.key, t22.value, "property functions not supported")) : l22 && !e2.Q(t22.valueSpec) && d22.push(new e2.V(t22.key, t22.value, "zoom functions not supported"))), "categorical" !== o2 && !h22 || void 0 !== t22.value.property || d22.push(new e2.V(t22.key, t22.value, '"property" property is required')), d22;
        function u22(t3) {
          let o3 = [];
          const s3 = t3.value, l3 = t3.key;
          if ("array" !== e2.K(s3)) return [new e2.V(l3, s3, `array expected, ${e2.K(s3)} found`)];
          if (2 !== s3.length) return [new e2.V(l3, s3, `array length 2 expected, length ${s3.length} found`)];
          if (h22) {
            if ("object" !== e2.K(s3[0])) return [new e2.V(l3, s3, `object expected, ${e2.K(s3[0])} found`)];
            if (void 0 === s3[0].zoom) return [new e2.V(l3, s3, "object stop key must have zoom")];
            if (void 0 === s3[0].value) return [new e2.V(l3, s3, "object stop key must have value")];
            const i3 = e2.M(s3[0].zoom);
            if ("number" != typeof i3) return [new e2.V(l3, s3[0].zoom, "stop zoom values must be numbers")];
            if (n22 && n22 > i3) return [new e2.V(l3, s3[0].zoom, "stop zoom values must appear in ascending order")];
            i3 !== n22 && (n22 = i3, r22 = void 0, a22 = {}), o3 = o3.concat(Z({ key: `${l3}[0]`, value: s3[0], valueSpec: { zoom: {} }, style: t3.style, styleSpec: t3.styleSpec, objectElementValidators: { zoom: W, value: _22 } }));
          } else o3 = o3.concat(_22({ key: `${l3}[0]`, value: s3[0], valueSpec: {}, style: t3.style, styleSpec: t3.styleSpec }, s3));
          return e2.S(e2.U(s3[1])) ? o3.concat([new e2.V(`${l3}[1]`, s3[1], "expressions are not allowed in function stops.")]) : o3.concat(_e2({ key: `${l3}[1]`, value: s3[1], valueSpec: i22, style: t3.style, styleSpec: t3.styleSpec }));
        }
        function _22(t3, n3) {
          const l3 = e2.K(t3.value), c3 = e2.M(t3.value), h3 = null !== t3.value ? t3.value : n3;
          if (s2) {
            if (l3 !== s2) return [new e2.V(t3.key, h3, `${l3} stop domain type must match previous stop domain type ${s2}`)];
          } else s2 = l3;
          if ("number" !== l3 && "string" !== l3 && "boolean" !== l3 && "number" != typeof c3 && "string" != typeof c3 && "boolean" != typeof c3) return [new e2.V(t3.key, h3, "stop domain value must be a number, string, or boolean")];
          if ("number" !== l3 && "categorical" !== o2) {
            let s3 = `number expected, ${l3} found`;
            return e2.O(i22) && void 0 === o2 && (s3 += '\nIf you intended to use a categorical function, specify `"type": "categorical"`.'), [new e2.V(t3.key, h3, s3)];
          }
          return "categorical" !== o2 || "number" !== l3 || "number" == typeof c3 && isFinite(c3) && Math.floor(c3) === c3 ? "categorical" !== o2 && "number" === l3 && "number" == typeof c3 && "number" == typeof r22 && void 0 !== r22 && c3 < r22 ? [new e2.V(t3.key, h3, "stop domain values must appear in ascending order")] : (r22 = c3, "categorical" === o2 && c3 in a22 ? [new e2.V(t3.key, h3, "stop domain values must be unique")] : (a22[c3] = true, [])) : [new e2.V(t3.key, h3, `integer expected, found ${String(c3)}`)];
        }
      }
      function X2(t22) {
        const i22 = ("property" === t22.expressionContext ? e2.W : e2.X)(e2.U(t22.value), t22.valueSpec);
        if ("error" === i22.result) return i22.value.map((i3) => new e2.V(`${t22.key}${i3.key}`, t22.value, i3.message));
        const o2 = i22.value.expression || i22.value._styleExpression.expression;
        if ("property" === t22.expressionContext && "text-font" === t22.propertyKey && !o2.outputDefined()) return [new e2.V(t22.key, t22.value, `Invalid data expression for "${t22.propertyKey}". Output values must be contained as literals within the expression.`)];
        if ("property" === t22.expressionContext && "layout" === t22.propertyType && !e2.Y(o2)) return [new e2.V(t22.key, t22.value, '"feature-state" data expressions are not supported with layout properties.')];
        if ("filter" === t22.expressionContext) return Y(o2, t22);
        if (t22.expressionContext && 0 === t22.expressionContext.indexOf("cluster")) {
          if (!e2.Z(o2, ["zoom", "feature-state"])) return [new e2.V(t22.key, t22.value, '"zoom" and "feature-state" expressions are not supported with cluster properties.')];
          if ("cluster-initial" === t22.expressionContext && !e2._(o2)) return [new e2.V(t22.key, t22.value, "Feature data expressions are not supported with initial expression part of cluster properties.")];
        }
        return [];
      }
      function Y(t22, i22) {
        const o2 = /* @__PURE__ */ new Set(["zoom", "feature-state", "pitch", "distance-from-center"]);
        if (i22.valueSpec && i22.valueSpec.expression) for (const e22 of i22.valueSpec.expression.parameters) o2.delete(e22);
        if (0 === o2.size) return [];
        const s2 = [];
        return t22 instanceof e2.$ && o2.has(t22.name) ? [new e2.V(i22.key, i22.value, `["${t22.name}"] expression is not supported in a filter for a ${i22.object.type} layer with id: ${i22.object.id}`)] : (t22.eachChild((e22) => {
          s2.push(...Y(e22, i22));
        }), s2);
      }
      function K2(t22) {
        const i22 = t22.key, o2 = t22.value, s2 = t22.valueSpec, r22 = [];
        return Array.isArray(s2.values) ? -1 === s2.values.indexOf(e2.M(o2)) && r22.push(new e2.V(i22, o2, `expected one of [${s2.values.join(", ")}], ${JSON.stringify(o2)} found`)) : -1 === Object.keys(s2.values).indexOf(e2.M(o2)) && r22.push(new e2.V(i22, o2, `expected one of [${Object.keys(s2.values).join(", ")}], ${JSON.stringify(o2)} found`)), r22;
      }
      function J(t22) {
        return e2.a1(e2.U(t22.value)) ? X2(e2.L({}, t22, { expressionContext: "filter", valueSpec: t22.styleSpec[`filter_${t22.layerType || "fill"}`] })) : Q(t22);
      }
      function Q(t22) {
        const i22 = t22.value, o2 = t22.key;
        if ("array" !== e2.K(i22)) return [new e2.V(o2, i22, `array expected, ${e2.K(i22)} found`)];
        const s2 = t22.styleSpec;
        let r22, n22 = [];
        if (i22.length < 1) return [new e2.V(o2, i22, "filter array must have at least 1 element")];
        switch (n22 = n22.concat(K2({ key: `${o2}[0]`, value: i22[0], valueSpec: s2.filter_operator, style: t22.style, styleSpec: t22.styleSpec })), e2.M(i22[0])) {
          case "<":
          case "<=":
          case ">":
          case ">=":
            i22.length >= 2 && "$type" === e2.M(i22[1]) && n22.push(new e2.V(o2, i22, `"$type" cannot be use with operator "${i22[0]}"`));
          case "==":
          case "!=":
            3 !== i22.length && n22.push(new e2.V(o2, i22, `filter array for operator "${i22[0]}" must have 3 elements`));
          case "in":
          case "!in":
            i22.length >= 2 && (r22 = e2.K(i22[1]), "string" !== r22 && n22.push(new e2.V(`${o2}[1]`, i22[1], `string expected, ${r22} found`)));
            for (let a22 = 2; a22 < i22.length; a22++) r22 = e2.K(i22[a22]), "$type" === e2.M(i22[1]) ? n22 = n22.concat(K2({ key: `${o2}[${a22}]`, value: i22[a22], valueSpec: s2.geometry_type, style: t22.style, styleSpec: t22.styleSpec })) : "string" !== r22 && "number" !== r22 && "boolean" !== r22 && n22.push(new e2.V(`${o2}[${a22}]`, i22[a22], `string, number, or boolean expected, ${r22} found`));
            break;
          case "any":
          case "all":
          case "none":
            for (let e22 = 1; e22 < i22.length; e22++) n22 = n22.concat(Q({ key: `${o2}[${e22}]`, value: i22[e22], style: t22.style, styleSpec: t22.styleSpec }));
            break;
          case "has":
          case "!has":
            r22 = e2.K(i22[1]), 2 !== i22.length ? n22.push(new e2.V(o2, i22, `filter array for "${i22[0]}" operator must have 2 elements`)) : "string" !== r22 && n22.push(new e2.V(`${o2}[1]`, i22[1], `string expected, ${r22} found`));
        }
        return n22;
      }
      function ee2(t22, i22) {
        const o2 = t22.key, s2 = t22.style, r22 = t22.layer, n22 = t22.styleSpec, a22 = t22.value, l22 = t22.objectKey, c22 = n22[`${i22}_${t22.layerType}`];
        if (!c22) return [];
        const h22 = l22.match(/^(.*)-use-theme$/);
        if ("paint" === i22 && h22 && c22[h22[1]]) return e2.S(a22) ? [].concat(_e2({ key: t22.key, value: a22, valueSpec: { type: "string", expression: { interpolated: false, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, style: s2, styleSpec: n22, expressionContext: "property", propertyType: i22, propertyKey: l22 })) : _e2({ key: o2, value: a22, valueSpec: { type: "string" }, style: s2, styleSpec: n22 });
        const d22 = l22.match(/^(.*)-transition$/);
        if ("paint" === i22 && d22 && c22[d22[1]] && c22[d22[1]].transition) return _e2({ key: o2, value: a22, valueSpec: n22.transition, style: s2, styleSpec: n22 });
        const u22 = t22.valueSpec || c22[l22];
        if (!u22) return [new e2.J(o2, a22, `unknown property "${l22}"`)];
        let _22;
        if ("string" === e2.K(a22) && e2.O(u22) && !u22.tokens && (_22 = /^{([^}]+)}$/.exec(a22))) {
          const t3 = `\`{ "type": "identity", "property": ${_22 ? JSON.stringify(_22[1]) : '"_"'} }\``;
          return [new e2.V(o2, a22, `"${l22}" does not support interpolation syntax
Use an identity property function instead: ${t3}.`)];
        }
        const p22 = [];
        if ("symbol" === t22.layerType) "text-field" !== l22 || !s2 || s2.glyphs || s2.imports || p22.push(new e2.V(o2, a22, 'use of "text-field" requires a style "glyphs" property')), "text-font" === l22 && e2.a2(e2.U(a22)) && "identity" === e2.M(a22.type) && p22.push(new e2.V(o2, a22, '"text-font" does not support identity functions'));
        else if ("model" === t22.layerType && "paint" === i22 && r22 && r22.layout && r22.layout.hasOwnProperty("model-id") && e2.O(u22) && (e2.a3(u22) || e2.Q(u22))) {
          const t3 = e2.W(e2.U(a22), u22), i3 = t3.value.expression || t3.value._styleExpression.expression;
          i3 && !e2.Z(i3, ["measure-light"]) && ("model-emissive-strength" === l22 && e2._(i3) && e2.Y(i3) || p22.push(new e2.V(o2, a22, `${l22} does not support measure-light expressions when the model layer source is vector tile or GeoJSON.`)));
        }
        return p22.concat(_e2({ key: t22.key, value: a22, valueSpec: u22, style: s2, styleSpec: n22, expressionContext: "property", propertyType: i22, propertyKey: l22 }));
      }
      function te2(e22) {
        return ee2(e22, "paint");
      }
      function ie2(e22) {
        return ee2(e22, "layout");
      }
      function oe2(t22) {
        let i22 = [];
        const o2 = t22.value, s2 = t22.key, r22 = t22.style, n22 = t22.styleSpec;
        o2.type || o2.ref || i22.push(new e2.V(s2, o2, 'either "type" or "ref" is required'));
        let a22 = e2.M(o2.type);
        const l22 = e2.M(o2.ref);
        if (o2.id) {
          const n3 = e2.M(o2.id);
          for (let a3 = 0; a3 < t22.arrayIndex; a3++) {
            const t3 = r22.layers[a3];
            e2.M(t3.id) === n3 && i22.push(new e2.V(s2, o2.id, `duplicate layer id "${o2.id}", previously used at line ${t3.id.__line__}`));
          }
        }
        if ("ref" in o2) {
          let t3;
          ["type", "source", "source-layer", "filter", "layout"].forEach((t4) => {
            t4 in o2 && i22.push(new e2.V(s2, o2[t4], `"${t4}" is prohibited for ref layers`));
          }), r22.layers.forEach((i3) => {
            e2.M(i3.id) === l22 && (t3 = i3);
          }), t3 ? t3.ref ? i22.push(new e2.V(s2, o2.ref, "ref cannot reference another ref layer")) : a22 = e2.M(t3.type) : "string" == typeof l22 && i22.push(new e2.V(s2, o2.ref, `ref layer "${l22}" not found`));
        } else if ("background" !== a22 && "sky" !== a22 && "slot" !== a22) if (o2.source) {
          const t3 = r22.sources && r22.sources[o2.source], n3 = t3 && e2.M(t3.type);
          t3 ? "vector" === n3 && "raster" === a22 ? i22.push(new e2.V(s2, o2.source, `layer "${o2.id}" requires a raster source`)) : "raster" === n3 && "raster" !== a22 ? i22.push(new e2.V(s2, o2.source, `layer "${o2.id}" requires a vector source`)) : "vector" !== n3 || o2["source-layer"] ? "raster-dem" === n3 && "hillshade" !== a22 ? i22.push(new e2.V(s2, o2.source, "raster-dem source can only be used with layer type 'hillshade'.")) : "raster-array" !== n3 || ["raster", "raster-particle"].includes(a22) ? "line" === a22 && o2.paint && (o2.paint["line-gradient"] || o2.paint["line-trim-offset"]) && "geojson" === n3 && !t3.lineMetrics ? i22.push(new e2.V(s2, o2, `layer "${o2.id}" specifies a line-gradient, which requires the GeoJSON source to have \`lineMetrics\` enabled.`)) : "raster-particle" === a22 && "raster-array" !== n3 && i22.push(new e2.V(s2, o2.source, `layer "${o2.id}" requires a 'raster-array' source.`)) : i22.push(new e2.V(s2, o2.source, "raster-array source can only be used with layer type 'raster'.")) : i22.push(new e2.V(s2, o2, `layer "${o2.id}" must specify a "source-layer"`)) : i22.push(new e2.V(s2, o2.source, `source "${o2.source}" not found`));
        } else i22.push(new e2.V(s2, o2, 'missing required property "source"'));
        return i22 = i22.concat(Z({ key: s2, value: o2, valueSpec: n22.layer, style: t22.style, styleSpec: t22.styleSpec, objectElementValidators: { "*": () => [], type: () => _e2({ key: `${s2}.type`, value: o2.type, valueSpec: n22.layer.type, style: t22.style, styleSpec: t22.styleSpec, object: o2, objectKey: "type" }), filter: (t3) => J(e2.L({ layerType: a22 }, t3)), layout: (t3) => Z({ layer: o2, key: t3.key, value: t3.value, valueSpec: {}, style: t3.style, styleSpec: t3.styleSpec, objectElementValidators: { "*": (t4) => ie2(e2.L({ layerType: a22 }, t4)) } }), paint: (t3) => Z({ layer: o2, key: t3.key, value: t3.value, valueSpec: {}, style: t3.style, styleSpec: t3.styleSpec, objectElementValidators: { "*": (t4) => te2(e2.L({ layerType: a22, layer: o2 }, t4)) } }) } })), i22;
      }
      function se2(t22) {
        const i22 = t22.value, o2 = t22.key, s2 = e2.K(i22);
        return "string" !== s2 ? [new e2.V(o2, i22, `string expected, ${s2} found`)] : [];
      }
      const re = { promoteId: function t22({ key: i22, value: o2 }) {
        if ("string" === e2.K(o2)) return se2({ key: i22, value: o2 });
        if (Array.isArray(o2)) {
          const t3 = [], s2 = e2.U(o2), r22 = e2.X(s2);
          return "error" === r22.result && r22.value.forEach((o3) => {
            t3.push(new e2.V(`${i22}${o3.key}`, null, `${o3.message}`));
          }), e2.Z(r22.value.expression, ["zoom", "heatmap-density", "line-progress", "raster-value", "sky-radial-progress", "accumulated", "is-supported-script", "pitch", "distance-from-center", "measure-light", "raster-particle-speed"]) || t3.push(new e2.V(`${i22}`, null, "promoteId expression should be only feature dependent")), t3;
        }
        {
          const e22 = [];
          for (const s2 in o2) e22.push(...t22({ key: `${i22}.${s2}`, value: o2[s2] }));
          return e22;
        }
      } };
      function ne2(t22) {
        const i22 = t22.value, o2 = t22.key, s2 = t22.styleSpec, r22 = t22.style;
        if (!i22.type) return [new e2.V(o2, i22, '"type" is required')];
        const n22 = e2.M(i22.type);
        let a22 = [];
        switch (["vector", "raster", "raster-dem", "raster-array"].includes(n22) && (i22.url || i22.tiles || a22.push(new e2.J(o2, i22, 'Either "url" or "tiles" is required.'))), n22) {
          case "vector":
          case "raster":
          case "raster-dem":
          case "raster-array":
            return a22 = a22.concat(Z({ key: o2, value: i22, valueSpec: s2[`source_${n22.replace("-", "_")}`], style: t22.style, styleSpec: s2, objectElementValidators: re })), a22;
          case "geojson":
            if (a22 = Z({ key: o2, value: i22, valueSpec: s2.source_geojson, style: r22, styleSpec: s2, objectElementValidators: re }), i22.cluster) for (const e22 in i22.clusterProperties) {
              const [t3, s3] = i22.clusterProperties[e22], r3 = "string" == typeof t3 ? [t3, ["accumulated"], ["get", e22]] : t3;
              a22.push(...X2({ key: `${o2}.${e22}.map`, value: s3, expressionContext: "cluster-map" })), a22.push(...X2({ key: `${o2}.${e22}.reduce`, value: r3, expressionContext: "cluster-reduce" }));
            }
            return a22;
          case "video":
            return Z({ key: o2, value: i22, valueSpec: s2.source_video, style: r22, styleSpec: s2 });
          case "image":
            return Z({ key: o2, value: i22, valueSpec: s2.source_image, style: r22, styleSpec: s2 });
          case "canvas":
            return [new e2.V(o2, null, "Please use runtime APIs to add canvas sources, rather than including them in stylesheets.", "source.canvas")];
          default:
            return K2({ key: `${o2}.type`, value: i22.type, valueSpec: { values: ae2(s2) }, style: r22, styleSpec: s2 });
        }
      }
      function ae2(e22) {
        return e22.source.reduce((t22, i22) => {
          const o2 = e22[i22];
          return "enum" === o2.type.type && (t22 = t22.concat(Object.keys(o2.type.values))), t22;
        }, []);
      }
      function le(t22) {
        const i22 = t22.value, o2 = t22.styleSpec, s2 = o2.light, r22 = t22.style;
        let n22 = [];
        const a22 = e2.K(i22);
        if (void 0 === i22) return n22;
        if ("object" !== a22) return n22 = n22.concat([new e2.V("light", i22, `object expected, ${a22} found`)]), n22;
        for (const t3 in i22) {
          const a3 = t3.match(/^(.*)-transition$/), l22 = t3.match(/^(.*)-use-theme$/);
          n22 = n22.concat(l22 && s2[l22[1]] ? _e2({ key: t3, value: i22[t3], valueSpec: { type: "string" }, style: r22, styleSpec: o2 }) : a3 && s2[a3[1]] && s2[a3[1]].transition ? _e2({ key: t3, value: i22[t3], valueSpec: o2.transition, style: r22, styleSpec: o2 }) : s2[t3] ? _e2({ key: t3, value: i22[t3], valueSpec: s2[t3], style: r22, styleSpec: o2 }) : [new e2.V(t3, i22[t3], `unknown property "${t3}"`)]);
        }
        return n22;
      }
      function ce2(t22) {
        const i22 = t22.value;
        let o2 = [];
        if (!i22) return o2;
        const s2 = e2.K(i22);
        if ("object" !== s2) return o2 = o2.concat([new e2.V("light-3d", i22, `object expected, ${s2} found`)]), o2;
        const r22 = t22.styleSpec, n22 = r22["light-3d"], a22 = t22.key, l22 = t22.style, c22 = t22.style.lights;
        for (const t3 of ["type", "id"]) if (!(t3 in i22)) return o2 = o2.concat([new e2.V("light-3d", i22, `missing property ${t3} on light`)]), o2;
        if (i22.type && c22) for (let s3 = 0; s3 < t22.arrayIndex; s3++) {
          const t3 = e2.M(i22.type), r3 = c22[s3];
          e2.M(r3.type) === t3 && o2.push(new e2.V(a22, i22.id, `duplicate light type "${i22.type}", previously defined at line ${r3.id.__line__}`));
        }
        const h22 = `properties_light_${i22.type}`;
        if (!(h22 in r22)) return o2 = o2.concat([new e2.V("light-3d", i22, `Invalid light type ${i22.type}`)]), o2;
        const d22 = r22[h22];
        for (const s3 in i22) if ("properties" === s3) {
          const n3 = i22[s3], a3 = e2.K(n3);
          if ("object" !== a3) return o2 = o2.concat([new e2.V("properties", n3, `object expected, ${a3} found`)]), o2;
          for (const i3 in n3) o2 = o2.concat(d22[i3] ? _e2({ key: i3, value: n3[i3], valueSpec: d22[i3], style: l22, styleSpec: r22 }) : [new e2.J(t22.key, n3[i3], `unknown property "${i3}"`)]);
        } else {
          const t3 = s3.match(/^(.*)-transition$/), a3 = s3.match(/^(.*)-use-theme$/);
          o2 = o2.concat(a3 && n22[a3[1]] ? _e2({ key: s3, value: i22[s3], valueSpec: { type: "string" }, style: l22, styleSpec: r22 }) : t3 && n22[t3[1]] && n22[t3[1]].transition ? _e2({ key: s3, value: i22[s3], valueSpec: r22.transition, style: l22, styleSpec: r22 }) : n22[s3] ? _e2({ key: s3, value: i22[s3], valueSpec: n22[s3], style: l22, styleSpec: r22 }) : [new e2.J(s3, i22[s3], `unknown property "${s3}"`)]);
        }
        return o2;
      }
      function he(t22) {
        const i22 = t22.value, o2 = t22.key, s2 = t22.style, r22 = t22.styleSpec, n22 = r22.terrain;
        let a22 = [];
        const l22 = e2.K(i22);
        if (void 0 === i22) return a22;
        if ("null" === l22) return a22;
        if ("object" !== l22) return a22 = a22.concat([new e2.V("terrain", i22, `object expected, ${l22} found`)]), a22;
        for (const t3 in i22) {
          const o3 = t3.match(/^(.*)-transition$/), l3 = t3.match(/^(.*)-use-theme$/);
          a22 = a22.concat(l3 && n22[l3[1]] ? _e2({ key: t3, value: i22[t3], valueSpec: { type: "string" }, style: s2, styleSpec: r22 }) : o3 && n22[o3[1]] && n22[o3[1]].transition ? _e2({ key: t3, value: i22[t3], valueSpec: r22.transition, style: s2, styleSpec: r22 }) : n22[t3] ? _e2({ key: t3, value: i22[t3], valueSpec: n22[t3], style: s2, styleSpec: r22 }) : [new e2.J(t3, i22[t3], `unknown property "${t3}"`)]);
        }
        if (i22.source) {
          const t3 = s2.sources && s2.sources[i22.source], r3 = t3 && e2.M(t3.type);
          t3 ? "raster-dem" !== r3 && a22.push(new e2.V(o2, i22.source, `terrain cannot be used with a source of type ${String(r3)}, it only be used with a "raster-dem" source type`)) : a22.push(new e2.V(o2, i22.source, `source "${i22.source}" not found`));
        } else a22.push(new e2.V(o2, i22, 'terrain is missing required property "source"'));
        return a22;
      }
      function de(t22) {
        const i22 = t22.value, o2 = t22.style, s2 = t22.styleSpec, r22 = s2.fog;
        let n22 = [];
        const a22 = e2.K(i22);
        if (void 0 === i22) return n22;
        if ("object" !== a22) return n22 = n22.concat([new e2.V("fog", i22, `object expected, ${a22} found`)]), n22;
        for (const t3 in i22) {
          const a3 = t3.match(/^(.*)-transition$/), l22 = t3.match(/^(.*)-use-theme$/);
          n22 = n22.concat(l22 && r22[l22[1]] ? _e2({ key: t3, value: i22[t3], valueSpec: { type: "string" }, style: o2, styleSpec: s2 }) : a3 && r22[a3[1]] && r22[a3[1]].transition ? _e2({ key: t3, value: i22[t3], valueSpec: s2.transition, style: o2, styleSpec: s2 }) : r22[t3] ? _e2({ key: t3, value: i22[t3], valueSpec: r22[t3], style: o2, styleSpec: s2 }) : [new e2.J(t3, i22[t3], `unknown property "${t3}"`)]);
        }
        return n22;
      }
      const ue = { "*": () => [], array: H, boolean: function(t22) {
        const i22 = t22.value, o2 = t22.key, s2 = e2.K(i22);
        return "boolean" !== s2 ? [new e2.V(o2, i22, `boolean expected, ${s2} found`)] : [];
      }, number: W, color: function(t22) {
        const i22 = t22.key, o2 = t22.value, s2 = e2.K(o2);
        return "string" !== s2 ? [new e2.V(i22, o2, `color expected, ${s2} found`)] : null === e2.a0.parseCSSColor(o2) ? [new e2.V(i22, o2, `color expected, "${o2}" found`)] : [];
      }, enum: K2, filter: J, function: $, layer: oe2, object: Z, source: ne2, model: e2.a4, light: le, "light-3d": ce2, terrain: he, fog: de, string: se2, formatted: function(e22) {
        return 0 === se2(e22).length ? [] : X2(e22);
      }, resolvedImage: function(e22) {
        return 0 === se2(e22).length ? [] : X2(e22);
      }, projection: function(t22) {
        const i22 = t22.value, o2 = t22.styleSpec, s2 = o2.projection, r22 = t22.style;
        let n22 = [];
        const a22 = e2.K(i22);
        if ("object" === a22) for (const e22 in i22) n22 = n22.concat(_e2({ key: e22, value: i22[e22], valueSpec: s2[e22], style: r22, styleSpec: o2 }));
        else "string" !== a22 && (n22 = n22.concat([new e2.V("projection", i22, `object or string expected, ${a22} found`)]));
        return n22;
      }, import: function(t22) {
        const { value: i22, styleSpec: o2 } = t22, { data: s2, ...r22 } = i22;
        Object.defineProperty(r22, "__line__", { value: i22.__line__, enumerable: false });
        let n22 = Z(e2.L({}, t22, { value: r22, valueSpec: o2.import }));
        return "" === e2.M(r22.id) && n22.push(new e2.V(`${t22.key}.id`, r22, "import id can't be an empty string")), s2 && (n22 = n22.concat(fe(s2, o2, { key: `${t22.key}.data` }))), n22;
      }, iconset: function(t22) {
        const i22 = t22.value, o2 = t22.key, s2 = t22.styleSpec, r22 = t22.style;
        if (!i22.type) return [new e2.V(o2, i22, '"type" is required')];
        const n22 = e2.M(i22.type);
        let a22 = [];
        if (a22 = a22.concat(Z({ key: o2, value: i22, valueSpec: s2[`iconset_${n22}`], style: r22, styleSpec: s2 })), "source" === n22 && i22.source) {
          const t3 = r22.sources && r22.sources[i22.source], s3 = t3 && e2.M(t3.type);
          t3 ? "raster-array" !== s3 && a22.push(new e2.V(o2, i22.source, `iconset cannot be used with a source of type ${String(s3)}, it only be used with a "raster-array" source type`)) : a22.push(new e2.V(o2, i22.source, `source "${i22.source}" not found`));
        }
        return a22;
      } };
      function _e2(t22, i22 = false) {
        const o2 = t22.value, s2 = t22.valueSpec, r22 = t22.styleSpec;
        if (s2.expression && e2.a2(e2.M(o2))) return $(t22);
        if (s2.expression && e2.S(e2.U(o2))) return X2(t22);
        if (s2.type && ue[s2.type]) {
          const o3 = ue[s2.type](t22);
          return true === i22 && o3.length > 0 && "array" === e2.K(t22.value) ? X2(t22) : o3;
        }
        return Z(e2.L({}, t22, { valueSpec: s2.type ? r22[s2.type] : s2 }));
      }
      function pe(t22) {
        const i22 = t22.value, o2 = t22.key, s2 = se2(t22);
        return s2.length || (-1 === i22.indexOf("{fontstack}") && s2.push(new e2.V(o2, i22, '"glyphs" url must include a "{fontstack}" token')), -1 === i22.indexOf("{range}") && s2.push(new e2.V(o2, i22, '"glyphs" url must include a "{range}" token'))), s2;
      }
      function fe(t22, i22 = e2.a5, o2 = {}) {
        return _e2({ key: o2.key || "", value: t22, valueSpec: i22.$root, styleSpec: i22, style: t22, objectElementValidators: { glyphs: pe, "*": () => [] } });
      }
      function me(t22, i22 = e2.a5) {
        return De(fe(t22, i22));
      }
      const ge = (e22) => De(ne2(e22)), ve = (e22) => De(le(e22)), ye = (e22) => De(ce2(e22)), xe = (e22) => De(he(e22)), be = (e22) => De(de(e22)), we = (t22) => De(function(t3) {
        const i22 = t3.value, o2 = t3.style, s2 = t3.styleSpec, r22 = s2.snow;
        let n22 = [];
        const a22 = e2.K(i22);
        if (void 0 === i22) return n22;
        if ("object" !== a22) return n22 = n22.concat([new e2.V("snow", i22, `object expected, ${a22} found`)]), n22;
        for (const t4 in i22) {
          const a3 = t4.match(/^(.*)-transition$/);
          n22 = n22.concat(a3 && r22[a3[1]] && r22[a3[1]].transition ? _e2({ key: t4, value: i22[t4], valueSpec: s2.transition, style: o2, styleSpec: s2 }) : r22[t4] ? _e2({ key: t4, value: i22[t4], valueSpec: r22[t4], style: o2, styleSpec: s2 }) : [new e2.J(t4, i22[t4], `unknown property "${t4}"`)]);
        }
        return n22;
      }(t22)), Te2 = (t22) => De(function(t3) {
        const i22 = t3.value, o2 = t3.style, s2 = t3.styleSpec, r22 = s2.rain;
        let n22 = [];
        const a22 = e2.K(i22);
        if (void 0 === i22) return n22;
        if ("object" !== a22) return n22 = n22.concat([new e2.V("rain", i22, `object expected, ${a22} found`)]), n22;
        for (const t4 in i22) {
          const a3 = t4.match(/^(.*)-transition$/);
          n22 = n22.concat(a3 && r22[a3[1]] && r22[a3[1]].transition ? _e2({ key: t4, value: i22[t4], valueSpec: s2.transition, style: o2, styleSpec: s2 }) : r22[t4] ? _e2({ key: t4, value: i22[t4], valueSpec: r22[t4], style: o2, styleSpec: s2 }) : [new e2.J(t4, i22[t4], `unknown property "${t4}"`)]);
        }
        return n22;
      }(t22)), Ee = (e22) => De(oe2(e22)), Se = (e22) => De(J(e22)), Ie = (e22) => De(te2(e22)), Ce = (e22) => De(ie2(e22)), Re = (t22) => De(e2.a4(t22));
      function De(e22) {
        return e22.slice().sort((e3, t22) => e3.line && t22.line ? e3.line - t22.line : 0);
      }
      function Ae(t22, i22) {
        let o2 = false;
        if (i22 && i22.length) for (const s2 of i22) s2 instanceof e2.J ? e2.w(s2.message) : (t22.fire(new e2.z(new Error(s2.message))), o2 = true);
        return o2;
      }
      let Le;
      class Pe extends e2.E {
        constructor(t22, i22 = "flat") {
          super(), this._transitionable = new e2.a6(Le || (Le = new e2.a7({ anchor: new e2.a8(e2.a5.light.anchor), position: new e2.a9(e2.a5.light.position), color: new e2.a8(e2.a5.light.color), intensity: new e2.a8(e2.a5.light.intensity) }))), this.setLight(t22, i22), this._transitioning = this._transitionable.untransitioned();
        }
        getLight() {
          return this._transitionable.serialize();
        }
        setLight(e22, t22, i22 = {}) {
          this._validate(ve, e22, i22) || (this._transitionable.setTransitionOrValue(e22), this.id = t22);
        }
        updateTransitions(e22) {
          this._transitioning = this._transitionable.transitioned(e22, this._transitioning);
        }
        hasTransition() {
          return this._transitioning.hasTransition();
        }
        recalculate(e22) {
          this.properties = this._transitioning.possiblyEvaluate(e22);
        }
        _validate(t22, i22, o2) {
          return (!o2 || false !== o2.validate) && Ae(this, t22.call(me, e2.l({ value: i22, style: { glyphs: true, sprite: true }, styleSpec: e2.a5 })));
        }
      }
      let ze = class extends e2.E {
        constructor(t22, i22, o2, s2) {
          super(), this.scope = o2, this._transitionable = new e2.a6(new e2.a7({ source: new e2.a8(e2.a5.terrain.source), exaggeration: new e2.a8(e2.a5.terrain.exaggeration) }), o2, s2), this._transitionable.setTransitionOrValue(t22, s2), this._transitioning = this._transitionable.untransitioned(), this.drapeRenderMode = i22;
        }
        get() {
          return this._transitionable.serialize();
        }
        set(e22, t22) {
          this._transitionable.setTransitionOrValue(e22, t22);
        }
        updateTransitions(e22) {
          this._transitioning = this._transitionable.transitioned(e22, this._transitioning);
        }
        hasTransition() {
          return this._transitioning.hasTransition();
        }
        recalculate(e22) {
          this.properties = this._transitioning.possiblyEvaluate(e22);
        }
        getExaggeration(t22) {
          return this._transitioning.possiblyEvaluate(new e2.aa(t22)).get("exaggeration");
        }
        getAttenuationRange() {
          if (!this.isZoomDependent()) return null;
          const t22 = this._transitionable._values.exaggeration;
          if (!t22) return null;
          const i22 = t22.value.expression;
          if (!i22) return null;
          let o2 = -1, s2 = -1, r22 = 1;
          for (const t3 of i22.zoomStops) r22 = i22.evaluate(new e2.aa(t3)), r22 > 0.01 ? (o2 = t3, s2 = -1) : s2 = t3;
          return r22 < 0.01 && o2 > 0 && s2 > o2 ? [o2, s2] : null;
        }
        isZoomDependent() {
          const t22 = this._transitionable._values.exaggeration;
          return null != t22 && null != t22.value && null != t22.value.expression && t22.value.expression instanceof e2.ab;
        }
      };
      const Me = 45, Oe = 65, Fe = 0.05;
      function Be(t22, i22, o2, s2) {
        const r22 = e2.af(Me, Oe, o2), [n22, a22] = ke(t22, s2);
        let l22 = 1 - Math.min(1, Math.exp((i22 - n22) / (a22 - n22) * -6));
        return l22 *= l22 * l22, l22 = Math.min(1, 1.00747 * l22), l22 * r22 * t22.alpha;
      }
      function ke(e22, t22) {
        const i22 = 0.5 / Math.tan(0.5 * t22);
        return [e22.range[0] + i22, e22.range[1] + i22];
      }
      function Ne(t22, i22, o2, s2, r22) {
        const n22 = e2.ad([], [i22, o2, s2], r22.mercatorFogMatrix);
        return Be(t22, e2.ae(n22), r22.pitch, r22._fov);
      }
      function Ue(t22, i22, o2, s2, r22, n22, a22) {
        const l22 = [[o2, s2, 0], [r22, s2, 0], [r22, n22, 0], [o2, n22, 0]];
        let c22 = Number.MAX_VALUE, h22 = -Number.MAX_VALUE;
        for (const t3 of l22) {
          const o3 = e2.ad([], t3, i22), s3 = e2.ae(o3);
          c22 = Math.min(c22, s3), h22 = Math.max(h22, s3);
        }
        return [Be(t22, c22, a22.pitch, a22._fov), Be(t22, h22, a22.pitch, a22._fov)];
      }
      class je extends e2.E {
        constructor(t22, i22, o2, s2) {
          super();
          const r22 = new e2.a7({ range: new e2.a8(e2.a5.fog.range), color: new e2.a8(e2.a5.fog.color), "color-use-theme": new e2.a8({ type: "string", "property-type": "data-constant", default: "default" }), "high-color": new e2.a8(e2.a5.fog["high-color"]), "high-color-use-theme": new e2.a8({ type: "string", "property-type": "data-constant", default: "default" }), "space-color": new e2.a8(e2.a5.fog["space-color"]), "space-color-use-theme": new e2.a8({ type: "string", "property-type": "data-constant", default: "default" }), "horizon-blend": new e2.a8(e2.a5.fog["horizon-blend"]), "star-intensity": new e2.a8(e2.a5.fog["star-intensity"]), "vertical-range": new e2.a8(e2.a5.fog["vertical-range"]) });
          this._transitionable = new e2.a6(r22, o2, new Map(s2)), this.set(t22, s2), this._transitioning = this._transitionable.untransitioned(), this._transform = i22, this.properties = new e2.ag(r22), this.scope = o2;
        }
        get state() {
          const t22 = this._transform, i22 = "globe" === t22.projection.name, o2 = e2.ah(t22.zoom), s2 = this.properties.get("range"), r22 = [0.5, 3];
          return { range: i22 ? [e2.ai(r22[0], s2[0], o2), e2.ai(r22[1], s2[1], o2)] : s2, horizonBlend: this.properties.get("horizon-blend"), alpha: this.properties.get("color").a };
        }
        get() {
          return this._transitionable.serialize();
        }
        set(t22, i22, o2 = {}) {
          if (this._validate(be, t22, o2)) return;
          const s2 = e2.l({}, t22);
          for (const t3 of Object.keys(e2.a5.fog)) void 0 === s2[t3] && (s2[t3] = e2.a5.fog[t3].default);
          this._options = s2, this._transitionable.setTransitionOrValue(this._options, i22);
        }
        getOpacity(t22) {
          if (!this._transform.projection.supportsFog) return 0;
          const i22 = this.properties && this.properties.get("color") || 1;
          return ("globe" === this._transform.projection.name ? 1 : e2.af(Me, Oe, t22)) * i22.a;
        }
        getOpacityAtLatLng(t22, i22) {
          return this._transform.projection.supportsFog ? function(t3, i3, o2) {
            const s2 = e2.ac.fromLngLat(i3), r22 = o2.elevation ? o2.elevation.getAtPointOrZero(s2) : 0;
            return Ne(t3, s2.x, s2.y, r22, o2);
          }(this.state, t22, i22) : 0;
        }
        getOpacityForTile(t22) {
          if (!this._transform.projection.supportsFog) return [1, 1];
          const i22 = this._transform.calculateFogTileMatrix(t22.toUnwrapped());
          return Ue(this.state, i22, 0, 0, e2.aj, e2.aj, this._transform);
        }
        getOpacityForBounds(e22, t22, i22, o2, s2) {
          return this._transform.projection.supportsFog ? Ue(this.state, e22, t22, i22, o2, s2, this._transform) : [1, 1];
        }
        getFovAdjustedRange(e22) {
          return this._transform.projection.supportsFog ? ke(this.state, e22) : [0, 1];
        }
        isVisibleOnFrustum(t22) {
          if (!this._transform.projection.supportsFog) return false;
          const i22 = [4, 5, 6, 7];
          for (const o2 of i22) {
            const i3 = t22.points[o2];
            let s2;
            if (i3[2] >= 0) s2 = i3;
            else {
              const r22 = t22.points[o2 - 4];
              s2 = e2.ak(r22, i3, r22[2] / (r22[2] - i3[2]));
            }
            if (Ne(this.state, s2[0], s2[1], 0, this._transform) >= Fe) return true;
          }
          return false;
        }
        updateConfig(e22) {
          this._transitionable.setTransitionOrValue(this._options, new Map(e22));
        }
        updateTransitions(e22) {
          this._transitioning = this._transitionable.transitioned(e22, this._transitioning);
        }
        hasTransition() {
          return this._transitioning.hasTransition();
        }
        recalculate(e22) {
          this.properties = this._transitioning.possiblyEvaluate(e22);
        }
        _validate(t22, i22, o2) {
          return (!o2 || false !== o2.validate) && Ae(this, t22.call(me, e2.l({ value: i22, style: { glyphs: true, sprite: true }, styleSpec: e2.a5 })));
        }
      }
      let Ve, Ge, qe, Ze, He = class extends e2.E {
        constructor(t22, i22, o2, s2) {
          super();
          const r22 = Ve || (Ve = new e2.a7({ density: new e2.a8(e2.a5.snow.density), intensity: new e2.a8(e2.a5.snow.intensity), color: new e2.a8(e2.a5.snow.color), opacity: new e2.a8(e2.a5.snow.opacity), vignette: new e2.a8(e2.a5.snow.vignette), "vignette-color": new e2.a8(e2.a5.snow["vignette-color"]), "center-thinning": new e2.a8(e2.a5.snow["center-thinning"]), direction: new e2.a8(e2.a5.snow.direction), "flake-size": new e2.a8(e2.a5.snow["flake-size"]) }));
          this._transitionable = new e2.a6(r22, o2, new Map(s2)), this.set(t22, s2), this._transitioning = this._transitionable.untransitioned(), this.properties = new e2.ag(r22), this.scope = o2;
        }
        get state() {
          const t22 = this.properties.get("opacity"), i22 = this.properties.get("color"), o2 = this.properties.get("direction"), s2 = e2.al(o2[0]), r22 = -Math.max(e2.al(o2[1]), 0.01), n22 = [Math.cos(s2) * Math.cos(r22), Math.sin(s2) * Math.cos(r22), Math.sin(r22)], a22 = this.properties.get("vignette"), l22 = this.properties.get("vignette-color");
          return l22.a = a22, { density: this.properties.get("density"), intensity: this.properties.get("intensity"), color: new e2.am(i22.r, i22.g, i22.b, i22.a * t22), direction: n22, centerThinning: this.properties.get("center-thinning"), flakeSize: this.properties.get("flake-size"), vignetteColor: l22 };
        }
        get() {
          return this._transitionable.serialize();
        }
        set(t22, i22, o2 = {}) {
          if (this._validate(we, t22, o2)) return;
          const s2 = e2.l({}, t22);
          for (const t3 of Object.keys(e2.a5.snow)) void 0 === s2[t3] && (s2[t3] = e2.a5.snow[t3].default);
          this._options = s2, this._transitionable.setTransitionOrValue(this._options, i22);
        }
        updateConfig(e22) {
          this._transitionable.setTransitionOrValue(this._options, new Map(e22));
        }
        updateTransitions(e22) {
          this._transitioning = this._transitionable.transitioned(e22, this._transitioning);
        }
        hasTransition() {
          return this._transitioning.hasTransition();
        }
        recalculate(e22) {
          this.properties = this._transitioning.possiblyEvaluate(e22);
        }
        _validate(t22, i22, o2) {
          return (!o2 || false !== o2.validate) && Ae(this, t22.call(me, e2.l({ value: i22, style: { glyphs: true, sprite: true }, styleSpec: e2.a5 })));
        }
      }, We = class extends e2.E {
        constructor(t22, i22, o2, s2) {
          super();
          const r22 = Ge || (Ge = new e2.a7({ density: new e2.a8(e2.a5.rain.density), intensity: new e2.a8(e2.a5.rain.intensity), color: new e2.a8(e2.a5.rain.color), opacity: new e2.a8(e2.a5.rain.opacity), vignette: new e2.a8(e2.a5.rain.vignette), "vignette-color": new e2.a8(e2.a5.rain["vignette-color"]), "center-thinning": new e2.a8(e2.a5.rain["center-thinning"]), direction: new e2.a8(e2.a5.rain.direction), "droplet-size": new e2.a8(e2.a5.rain["droplet-size"]), "distortion-strength": new e2.a8(e2.a5.rain["distortion-strength"]) }));
          this._transitionable = new e2.a6(r22, o2, new Map(s2)), this.set(t22, s2), this._transitioning = this._transitionable.untransitioned(), this.properties = new e2.ag(r22), this.scope = o2;
        }
        get state() {
          const t22 = this.properties.get("opacity"), i22 = this.properties.get("color"), o2 = this.properties.get("direction"), s2 = e2.al(o2[0]), r22 = -Math.max(e2.al(o2[1]), 0.01), n22 = [Math.cos(s2) * Math.cos(r22), Math.sin(s2) * Math.cos(r22), Math.sin(r22)], a22 = this.properties.get("vignette-color");
          return a22.a = this.properties.get("vignette"), { density: this.properties.get("density"), intensity: this.properties.get("intensity"), color: new e2.am(i22.r, i22.g, i22.b, i22.a * t22), direction: n22, centerThinning: this.properties.get("center-thinning"), dropletSize: this.properties.get("droplet-size"), distortionStrength: this.properties.get("distortion-strength"), vignetteColor: a22 };
        }
        get() {
          return this._transitionable.serialize();
        }
        set(t22, i22, o2 = {}) {
          if (this._validate(Te2, t22, o2)) return;
          const s2 = e2.l({}, t22);
          for (const t3 of Object.keys(e2.a5.rain)) void 0 === s2[t3] && (s2[t3] = e2.a5.rain[t3].default);
          this._options = s2, this._transitionable.setTransitionOrValue(this._options, i22);
        }
        updateConfig(e22) {
          this._transitionable.setTransitionOrValue(this._options, new Map(e22));
        }
        updateTransitions(e22) {
          this._transitioning = this._transitionable.transitioned(e22, this._transitioning);
        }
        hasTransition() {
          return this._transitioning.hasTransition();
        }
        recalculate(e22) {
          this.properties = this._transitioning.possiblyEvaluate(e22);
        }
        _validate(t22, i22, o2) {
          return (!o2 || false !== o2.validate) && Ae(this, t22.call(me, e2.l({ value: i22, style: { glyphs: true, sprite: true }, styleSpec: e2.a5 })));
        }
      };
      class $e extends e2.E {
        constructor(t22, i22, o2, s2) {
          super(), this.scope = o2, this._options = t22, this.properties = new e2.ag(i22), this._transitionable = new e2.a6(i22, o2, new Map(s2)), this._transitionable.setTransitionOrValue(t22.properties), this._transitioning = this._transitionable.untransitioned();
        }
        updateConfig(e22) {
          this._transitionable.setTransitionOrValue(this._options.properties, new Map(e22));
        }
        updateTransitions(e22) {
          this._transitioning = this._transitionable.transitioned(e22, this._transitioning);
        }
        hasTransition() {
          return this._transitioning.hasTransition();
        }
        recalculate(e22) {
          this.properties = this._transitioning.possiblyEvaluate(e22);
        }
        get() {
          return this._options.properties = this._transitionable.serialize(), this._options;
        }
        set(e22, t22) {
          this._options = e22, this._transitionable.setTransitionOrValue(e22.properties, t22);
        }
        shadowsEnabled() {
          return !!this.properties && true === this.properties.get("cast-shadows");
        }
      }
      class Xe {
        constructor(e22, t22, i22, o2) {
          this.screenBounds = e22, this.cameraPoint = t22, this._screenRaycastCache = {}, this._cameraRaycastCache = {}, this.isAboveHorizon = i22, this.screenGeometry = this.bufferedScreenGeometry(0), this.screenGeometryMercator = this._bufferedScreenMercator(0, o2);
        }
        static createFromScreenPoints(t22, i22) {
          let o2, s2;
          if (t22 instanceof e2.P || "number" == typeof t22[0]) {
            const r22 = e2.P.convert(t22);
            o2 = [r22], s2 = i22.isPointAboveHorizon(r22);
          } else {
            const r22 = e2.P.convert(t22[0]), n22 = e2.P.convert(t22[1]), a22 = r22.add(n22)._div(2);
            o2 = [r22, n22], s2 = e2.ao(r22, n22).every((e22) => i22.isPointAboveHorizon(e22)) && i22.isPointAboveHorizon(a22);
          }
          return new Xe(o2, i22.getCameraPoint(), s2, i22);
        }
        isPointQuery() {
          return 1 === this.screenBounds.length;
        }
        bufferedScreenGeometry(t22) {
          return e2.ao(this.screenBounds[0], 1 === this.screenBounds.length ? this.screenBounds[0] : this.screenBounds[1], t22);
        }
        bufferedCameraGeometry(t22) {
          const i22 = this.screenBounds[0], o2 = 1 === this.screenBounds.length ? this.screenBounds[0].add(new e2.P(1, 1)) : this.screenBounds[1], s2 = e2.ao(i22, o2, 0, false);
          return this.cameraPoint.y > o2.y && (this.cameraPoint.x > i22.x && this.cameraPoint.x < o2.x ? s2.splice(3, 0, this.cameraPoint) : this.cameraPoint.x >= o2.x ? s2[2] = this.cameraPoint : this.cameraPoint.x <= i22.x && (s2[3] = this.cameraPoint)), e2.ap(s2, t22);
        }
        bufferedCameraGeometryGlobe(t22) {
          const i22 = this.screenBounds[0], o2 = 1 === this.screenBounds.length ? this.screenBounds[0].add(new e2.P(1, 1)) : this.screenBounds[1], s2 = e2.ao(i22, o2, t22), r22 = this.cameraPoint.clone();
          switch (3 * ((r22.y > i22.y) + (r22.y > o2.y)) + ((r22.x > i22.x) + (r22.x > o2.x))) {
            case 0:
              s2[0] = r22, s2[4] = r22.clone();
              break;
            case 1:
              s2.splice(1, 0, r22);
              break;
            case 2:
              s2[1] = r22;
              break;
            case 3:
              s2.splice(4, 0, r22);
              break;
            case 5:
              s2.splice(2, 0, r22);
              break;
            case 6:
              s2[3] = r22;
              break;
            case 7:
              s2.splice(3, 0, r22);
              break;
            case 8:
              s2[2] = r22;
          }
          return s2;
        }
        containsTile(t22, i22, o2, s2 = 0) {
          const r22 = t22.queryPadding / i22._pixelsPerMercatorPixel + 1, n22 = o2 ? this._bufferedCameraMercator(r22, i22) : this._bufferedScreenMercator(r22, i22);
          let a22 = t22.tileID.wrap + (n22.unwrapped ? s2 : 0);
          const l22 = n22.polygon.map((i3) => e2.aq(t22.tileTransform, i3, a22));
          if (!e2.ar(l22, 0, 0, e2.aj, e2.aj)) return;
          a22 = t22.tileID.wrap + (this.screenGeometryMercator.unwrapped ? s2 : 0);
          const c22 = this.screenGeometryMercator.polygon.map((i3) => e2.as(t22.tileTransform, i3, a22)), h22 = c22.map((t3) => new e2.P(t3[0], t3[1])), d22 = i22.getFreeCameraOptions().position || new e2.ac(0, 0, 0), u22 = e2.as(t22.tileTransform, d22, a22), _22 = c22.map((t3) => {
            const i3 = e2.at(t3, t3, u22);
            return e2.au(i3, i3), new e2.av(u22, i3);
          }), p22 = e2.aw(t22, 1, i22.zoom) * i22._pixelsPerMercatorPixel;
          return { queryGeometry: this, tilespaceGeometry: h22, tilespaceRays: _22, bufferedTilespaceGeometry: l22, bufferedTilespaceBounds: (f22 = e2.ax(l22), f22.min.x = e2.aD(f22.min.x, 0, e2.aj), f22.min.y = e2.aD(f22.min.y, 0, e2.aj), f22.max.x = e2.aD(f22.max.x, 0, e2.aj), f22.max.y = e2.aD(f22.max.y, 0, e2.aj), f22), tile: t22, tileID: t22.tileID, pixelToTileUnitsFactor: p22 };
          var f22;
        }
        _bufferedScreenMercator(e22, t22) {
          const i22 = Je(e22);
          if (this._screenRaycastCache[i22]) return this._screenRaycastCache[i22];
          {
            let o2;
            return o2 = "globe" === t22.projection.name ? this._projectAndResample(this.bufferedScreenGeometry(e22), t22) : { polygon: this.bufferedScreenGeometry(e22).map((e3) => t22.pointCoordinate3D(e3)), unwrapped: true }, this._screenRaycastCache[i22] = o2, o2;
          }
        }
        _bufferedCameraMercator(e22, t22) {
          const i22 = Je(e22);
          if (this._cameraRaycastCache[i22]) return this._cameraRaycastCache[i22];
          {
            let o2;
            return o2 = "globe" === t22.projection.name ? this._projectAndResample(this.bufferedCameraGeometryGlobe(e22), t22) : { polygon: this.bufferedCameraGeometry(e22).map((e3) => t22.pointCoordinate3D(e3)), unwrapped: true }, this._cameraRaycastCache[i22] = o2, o2;
          }
        }
        _projectAndResample(t22, i22) {
          const o2 = function(t3, i3) {
            const o3 = e2.az([], i3.pixelMatrix, i3.globeMatrix), s3 = [0, -e2.aE, 0, 1], r22 = [0, e2.aE, 0, 1], n22 = [0, 0, 0, 1];
            e2.aA(s3, s3, o3), e2.aA(r22, r22, o3), e2.aA(n22, n22, o3);
            const a22 = new e2.P(s3[0] / s3[3], s3[1] / s3[3]), l22 = new e2.P(r22[0] / r22[3], r22[1] / r22[3]), c22 = e2.aB(t3, a22) && s3[3] < n22[3], h22 = e2.aB(t3, l22) && r22[3] < n22[3];
            if (!c22 && !h22) return null;
            const d22 = function(e22, t4, i4) {
              for (let o4 = 1; o4 < e22.length; o4++) {
                const s4 = Ke(t4.pointCoordinate3D(e22[o4 - 1]).x), r3 = Ke(t4.pointCoordinate3D(e22[o4]).x);
                if (i4 < 0) {
                  if (s4 < r3) return { idx: o4, t: -s4 / (r3 - 1 - s4) };
                } else if (r3 < s4) return { idx: o4, t: (1 - s4) / (r3 + 1 - s4) };
              }
              return null;
            }(t3, i3, c22 ? -1 : 1);
            if (!d22) return null;
            const { idx: u22, t: _22 } = d22;
            let p22 = u22 > 1 ? Ye(t3.slice(0, u22), i3) : [], f22 = u22 < t3.length ? Ye(t3.slice(u22), i3) : [];
            p22 = p22.map((t4) => new e2.P(Ke(t4.x), t4.y)), f22 = f22.map((t4) => new e2.P(Ke(t4.x), t4.y));
            const m22 = [...p22];
            0 === m22.length && m22.push(f22[f22.length - 1]);
            const g22 = e2.ai(m22[m22.length - 1].y, (0 === f22.length ? p22[0] : f22[0]).y, _22);
            let v22;
            return v22 = c22 ? [new e2.P(0, g22), new e2.P(0, 0), new e2.P(1, 0), new e2.P(1, g22)] : [new e2.P(1, g22), new e2.P(1, 1), new e2.P(0, 1), new e2.P(0, g22)], m22.push(...v22), 0 === f22.length ? m22.push(p22[0]) : m22.push(...f22), { polygon: m22.map((t4) => new e2.ac(t4.x, t4.y)), unwrapped: false };
          }(t22, i22);
          if (o2) return o2;
          const s2 = function(t3, i3) {
            let o3 = false, s3 = -1 / 0, r22 = 0;
            for (let e22 = 0; e22 < t3.length - 1; e22++) t3[e22].x > s3 && (s3 = t3[e22].x, r22 = e22);
            for (let e22 = 0; e22 < t3.length - 1; e22++) {
              const i4 = (r22 + e22) % (t3.length - 1), s4 = t3[i4], n3 = t3[i4 + 1];
              Math.abs(s4.x - n3.x) > 0.5 && (s4.x < n3.x ? (s4.x += 1, 0 === i4 && (t3[t3.length - 1].x += 1)) : (n3.x += 1, i4 + 1 === t3.length - 1 && (t3[0].x += 1)), o3 = true);
            }
            const n22 = e2.ay(i3.center.lng);
            return o3 && n22 < Math.abs(n22 - 1) && t3.forEach((e22) => {
              e22.x -= 1;
            }), { polygon: t3, unwrapped: o3 };
          }(Ye(t22, i22).map((t3) => new e2.P(Ke(t3.x), t3.y)), i22);
          return { polygon: s2.polygon.map((t3) => new e2.ac(t3.x, t3.y)), unwrapped: s2.unwrapped };
        }
      }
      function Ye(t22, i22) {
        return e2.aC(t22, (e22) => {
          const t3 = i22.pointCoordinate3D(e22);
          e22.x = t3.x, e22.y = t3.y;
        }, 1 / 256);
      }
      function Ke(e22) {
        return e22 < 0 ? 1 + e22 % 1 : e22 % 1;
      }
      function Je(e22) {
        return 100 * e22 | 0;
      }
      function Qe(t22, i22, o2, s2, r22) {
        const n22 = function(o3, s3) {
          if (o3) return r22(o3);
          if (s3) {
            if (t22.url && s3.tiles && t22.tiles && delete t22.tiles, s3.variants) {
              if (!Array.isArray(s3.variants)) return r22(new Error("variants must be an array"));
              for (const t3 of s3.variants) {
                if (null == t3 || "object" != typeof t3 || t3.constructor !== Object) return r22(new Error("variant must be an object"));
                if (!Array.isArray(t3.capabilities)) return r22(new Error("capabilities must be an array"));
                if (1 === t3.capabilities.length && "meshopt" === t3.capabilities[0]) {
                  s3 = e2.l(s3, t3);
                  break;
                }
              }
            }
            const o4 = e2.aF(e2.l({}, s3, t22), ["tilejson", "tiles", "minzoom", "maxzoom", "attribution", "mapbox_logo", "bounds", "extra_bounds", "scheme", "tileSize", "encoding", "vector_layers", "raster_layers", "worldview_options", "worldview_default", "worldview"]);
            o4.tiles = i22.canonicalizeTileset(o4, t22.url), r22(null, o4);
          }
        }, a22 = function(e22, t3, i3) {
          if (!e22) return null;
          if (!t3 && !i3) return e22;
          i3 = i3 || e22.worldview_default;
          const o3 = Object.values(e22.language || {});
          if (0 === o3.length) return null;
          const s3 = Object.values(e22.worldview || {});
          if (0 === s3.length) return null;
          const r3 = o3.every((e3) => e3 === t3), n3 = s3.every((e3) => e3 === i3);
          return r3 && n3 ? e22 : t3 in (e22.language_options || {}) || i3 in (e22.worldview_options || {}) ? null : e22.language_options && e22.worldview_options ? e22 : null;
        }(t22.data, o2, s2);
        return a22 ? e2.q.frame(() => n22(null, a22)) : t22.url ? e2.n(i22.transformRequest(i22.normalizeSourceURL(t22.url, null, o2, s2), e2.R.Source), n22) : e2.q.frame(() => {
          const { data: e22, ...i3 } = t22;
          n22(null, i3);
        });
      }
      function et(t22, i22) {
        const o2 = Math.pow(2, i22.z), s2 = Math.floor(e2.ay(t22.getWest()) * o2), r22 = Math.floor(e2.aH(t22.getNorth()) * o2), n22 = Math.ceil(e2.ay(t22.getEast()) * o2), a22 = Math.ceil(e2.aH(t22.getSouth()) * o2);
        return i22.x >= s2 && i22.x < n22 && i22.y >= r22 && i22.y < a22;
      }
      class tt {
        constructor(t22, i22, o2) {
          this.bounds = t22 ? e2.aG.convert(this.validateBounds(t22)) : null, this.minzoom = i22 || 0, this.maxzoom = o2 || 24;
        }
        validateBounds(e22) {
          return Array.isArray(e22) && 4 === e22.length ? [Math.max(-180, e22[0]), Math.max(-90, e22[1]), Math.min(180, e22[2]), Math.min(90, e22[3])] : [-180, -90, 180, 90];
        }
        addExtraBounds(t22) {
          if (t22) {
            this.extraBounds || (this.extraBounds = []);
            for (const i22 of t22) this.extraBounds.push(e2.aG.convert(this.validateBounds(i22)));
          }
        }
        contains(e22) {
          if (e22.z > this.maxzoom || e22.z < this.minzoom) return false;
          if (this.bounds && !et(this.bounds, e22)) return false;
          if (!this.extraBounds) return true;
          for (const t22 of this.extraBounds) if (et(t22, e22)) return true;
          return false;
        }
        static fromTileJSON(e22) {
          if (!e22.bounds && !e22.extra_bounds) return null;
          const t22 = new tt(e22.bounds, e22.minzoom, e22.maxzoom);
          return t22.addExtraBounds(e22.extra_bounds), t22;
        }
      }
      class it extends e2.E {
        constructor(t22, i22, o2, s2) {
          if (super(), this.id = t22, this.dispatcher = o2, this.type = "vector", this.minzoom = 0, this.maxzoom = 22, this.scheme = "xyz", this.tileSize = 512, this.reparseOverscaled = true, this.isTileClipped = true, this._loaded = false, e2.l(this, e2.aF(i22, ["url", "scheme", "tileSize", "promoteId"])), this._options = e2.l({ type: "vector" }, i22), this._collectResourceTiming = !!i22.collectResourceTiming, 512 !== this.tileSize) throw new Error("vector tile sources must have a tileSize of 512");
          this.setEventedParent(s2), this._tileWorkers = {}, this._deduped = new e2.aI();
        }
        load(t22) {
          this._loaded = false, this.fire(new e2.A("dataloading", { dataType: "source" }));
          const i22 = Array.isArray(this.map._language) ? this.map._language.join() : this.map._language, o2 = this.map.getWorldview();
          this._tileJSONRequest = Qe(this._options, this.map._requestManager, i22, o2, (s2, r22) => {
            if (this._tileJSONRequest = null, this._loaded = true, s2) i22 && console.warn(`Ensure that your requested language string is a valid BCP-47 code or list of codes. Found: ${i22}`), o2 && console.warn(`Requested worldview strings must be a valid ISO alpha-2 code. Found: ${o2}`), this.fire(new e2.z(s2));
            else if (r22) {
              if (e2.l(this, r22), this.hasWorldviews = !!r22.worldview_options, r22.worldview_default && (this.worldviewDefault = r22.worldview_default), r22.vector_layers) {
                this.vectorLayers = r22.vector_layers, this.vectorLayerIds = [], this.localizableLayerIds = /* @__PURE__ */ new Set();
                for (const e22 of r22.vector_layers) this.vectorLayerIds.push(e22.id), r22.worldview && r22.worldview[e22.source] && this.localizableLayerIds.add(e22.id);
              }
              this.tileBounds = tt.fromTileJSON(r22), L2(r22.tiles, this.map._requestManager._customAccessToken), this.fire(new e2.A("data", { dataType: "source", sourceDataType: "metadata" })), this.fire(new e2.A("data", { dataType: "source", sourceDataType: "content" }));
            }
            t22 && t22(s2);
          });
        }
        loaded() {
          return this._loaded;
        }
        hasTile(e22) {
          return !this.tileBounds || this.tileBounds.contains(e22.canonical);
        }
        onAdd(e22) {
          this.map = e22, this.load();
        }
        reload() {
          this.cancelTileJSONRequest();
          const t22 = e2.C(this.id, this.scope);
          this.load(() => this.map.style.clearSource(t22));
        }
        setTiles(e22) {
          return this._options.tiles = e22, this.reload(), this;
        }
        setUrl(e22) {
          return this.url = e22, this._options.url = e22, this.reload(), this;
        }
        onRemove(e22) {
          this.cancelTileJSONRequest();
        }
        serialize() {
          return e2.l({}, this._options);
        }
        loadTile(t22, i22) {
          const o2 = t22.tileID.canonical.url(this.tiles, this.scheme), s2 = this.map._requestManager.normalizeTileURL(o2), r22 = this.map._requestManager.transformRequest(s2, e2.R.Tile), n22 = this.map.style ? this.map.style.getLut(this.scope) : null, a22 = n22 ? { image: n22.image.clone() } : null, l22 = { request: r22, data: void 0, uid: t22.uid, tileID: t22.tileID, tileZoom: t22.tileZoom, zoom: t22.tileID.overscaledZ, maxZoom: this.maxzoom, lut: a22, tileSize: this.tileSize * t22.tileID.overscaleFactor(), type: this.type, source: this.id, scope: this.scope, pixelRatio: e2.q.devicePixelRatio, showCollisionBoxes: this.map.showCollisionBoxes, promoteId: this.promoteId, isSymbolTile: t22.isSymbolTile, brightness: this.map.style && this.map.style.getBrightness() || 0, extraShadowCaster: t22.isExtraShadowCaster, tessellationStep: this.map._tessellationStep, scaleFactor: this.map.getScaleFactor() };
          if (this.hasWorldviews && e2.f(o2) && (l22.worldview = this.map.getWorldview() || this.worldviewDefault, l22.localizableLayerIds = this.localizableLayerIds), l22.request.collectResourceTiming = this._collectResourceTiming, t22.actor && "expired" !== t22.state) "loading" === t22.state ? t22.reloadCallback = i22 : t22.request = t22.actor.send("reloadTile", l22, c22.bind(this));
          else if (t22.actor = this._tileWorkers[s2] = this._tileWorkers[s2] || this.dispatcher.getActor(), this.dispatcher.ready) t22.request = t22.actor.send("loadTile", l22, c22.bind(this), void 0, true);
          else {
            const i3 = e2.aJ.call({ deduped: this._deduped }, l22, (e22, i4) => {
              e22 || !i4 ? c22.call(this, e22) : (l22.data = { cacheControl: i4.cacheControl, expires: i4.expires, rawData: i4.rawData.slice(0) }, t22.actor && t22.actor.send("loadTile", l22, c22.bind(this), void 0, true));
            }, true);
            t22.request = { cancel: i3 };
          }
          function c22(o3, s3) {
            return delete t22.request, t22.aborted ? i22(null) : o3 && 404 !== o3.status ? i22(o3) : (s3 && s3.resourceTiming && (t22.resourceTiming = s3.resourceTiming), this.map._refreshExpiredTiles && s3 && t22.setExpiryData(s3), t22.loadVectorData(s3, this.map.painter), e2.aK(this.dispatcher), i22(null), void (t22.reloadCallback && (this.loadTile(t22, t22.reloadCallback), t22.reloadCallback = null)));
          }
        }
        abortTile(e22) {
          e22.request && (e22.request.cancel(), delete e22.request), e22.actor && e22.actor.send("abortTile", { uid: e22.uid, type: this.type, source: this.id, scope: this.scope });
        }
        unloadTile(e22, t22) {
          e22.actor && e22.actor.send("removeTile", { uid: e22.uid, type: this.type, source: this.id, scope: this.scope }), e22.destroy();
        }
        hasTransition() {
          return false;
        }
        afterUpdate() {
          this._tileWorkers = {};
        }
        cancelTileJSONRequest() {
          this._tileJSONRequest && (this._tileJSONRequest.cancel(), this._tileJSONRequest = null);
        }
      }
      class ot extends e2.E {
        constructor(t22, i22, o2, s2) {
          super(), this.id = t22, this.dispatcher = o2, this.setEventedParent(s2), this.type = "raster", this.minzoom = 0, this.maxzoom = 22, this.roundZoom = true, this.scheme = "xyz", this.tileSize = 512, this._loaded = false, this._options = e2.l({ type: "raster" }, i22), e2.l(this, e2.aF(i22, ["url", "scheme", "tileSize"]));
        }
        load(t22) {
          this._loaded = false, this.fire(new e2.A("dataloading", { dataType: "source" })), this._tileJSONRequest = Qe(this._options, this.map._requestManager, null, null, (i22, o2) => {
            this._tileJSONRequest = null, this._loaded = true, i22 ? this.fire(new e2.z(i22)) : o2 && (e2.l(this, o2), o2.raster_layers && (this.rasterLayers = o2.raster_layers, this.rasterLayerIds = this.rasterLayers.map((e22) => e22.id)), this.tileBounds = tt.fromTileJSON(o2), L2(o2.tiles), this.fire(new e2.A("data", { dataType: "source", sourceDataType: "metadata" })), this.fire(new e2.A("data", { dataType: "source", sourceDataType: "content" }))), t22 && t22(i22);
          });
        }
        loaded() {
          return this._loaded;
        }
        onAdd(e22) {
          this.map = e22, this.load();
        }
        reload() {
          this.cancelTileJSONRequest();
          const t22 = e2.C(this.id, this.scope);
          this.load(() => this.map.style.clearSource(t22));
        }
        setTiles(e22) {
          return this._options.tiles = e22, this.reload(), this;
        }
        setUrl(e22) {
          return this.url = e22, this._options.url = e22, this.reload(), this;
        }
        onRemove(e22) {
          this.cancelTileJSONRequest();
        }
        serialize() {
          return e2.l({}, this._options);
        }
        hasTile(e22) {
          return !this.tileBounds || this.tileBounds.contains(e22.canonical);
        }
        loadTile(t22, i22) {
          const o2 = e2.q.devicePixelRatio >= 2, s2 = this.map._requestManager.normalizeTileURL(t22.tileID.canonical.url(this.tiles, this.scheme), o2, this.tileSize);
          t22.request = e2.o(this.map._requestManager.transformRequest(s2, e2.R.Tile), (o3, s3, r22, n22) => (delete t22.request, t22.aborted ? (t22.state = "unloaded", i22(null)) : o3 ? (t22.state = "errored", i22(o3)) : s3 ? (this.map._refreshExpiredTiles && t22.setExpiryData({ cacheControl: r22, expires: n22 }), t22.setTexture(s3, this.map.painter), t22.state = "loaded", e2.aK(this.dispatcher), void i22(null)) : i22(null)));
        }
        abortTile(e22, t22) {
          e22.request && (e22.request.cancel(), delete e22.request), t22 && t22();
        }
        unloadTile(t22, i22) {
          t22.texture && t22.texture instanceof e2.T ? (t22.destroy(true), t22.texture && t22.texture instanceof e2.T && this.map.painter.saveTileTexture(t22.texture)) : t22.destroy(), i22 && i22();
        }
        hasTransition() {
          return false;
        }
        cancelTileJSONRequest() {
          this._tileJSONRequest && (this._tileJSONRequest.cancel(), this._tileJSONRequest = null);
        }
      }
      class st extends ot {
        constructor(t22, i22, o2, s2) {
          super(t22, i22, o2, s2), this.type = "raster-array", this.maxzoom = 22, this.partial = true, this._options = e2.l({ type: "raster-array" }, i22);
        }
        triggerRepaint(e22) {
          const t22 = this.map.painter._terrain, i22 = this.map.style.getSourceCache(this.id);
          t22 && t22.enabled && i22 && t22._clearRenderCacheForTile(i22.id, e22.tileID), this.map.triggerRepaint();
        }
        loadTile(t22, i22) {
          const o2 = this.map._requestManager.normalizeTileURL(t22.tileID.canonical.url(this.tiles, this.scheme), false, this.tileSize), s2 = this.map._requestManager.transformRequest(o2, e2.R.Tile), r22 = { request: s2, uid: t22.uid, tileID: t22.tileID, type: this.type, source: this.id, scope: this.scope, partial: this.partial };
          t22.source = this.id, t22.scope = this.scope, t22.requestParams = s2, t22.actor || (t22.actor = this.dispatcher.getActor());
          const n22 = (e22, o3, s3, r3) => {
            if (delete t22.request, t22.aborted) return t22.state = "unloaded", i22(null);
            if (e22) {
              if ("AbortError" === e22.name) return;
              return t22.state = "errored", i22(e22);
            }
            if (this.map._refreshExpiredTiles && o3 && t22.setExpiryData({ cacheControl: s3, expires: r3 }), this.partial) t22.state = "empty";
            else {
              if (!o3) return i22(null);
              t22.state = "loaded", t22._isHeaderLoaded = true, t22._mrt = o3;
            }
            i22(null);
          };
          t22.request = this.partial ? t22.fetchHeader(void 0, n22.bind(this)) : t22.actor.send("loadTile", r22, n22.bind(this), void 0, true);
        }
        abortTile(e22) {
          e22.request && (e22.request.cancel(), delete e22.request), e22.actor && e22.actor.send("abortTile", { uid: e22.uid, type: this.type, source: this.id, scope: this.scope });
        }
        unloadTile(t22, i22) {
          const o2 = t22.texture;
          o2 && o2 instanceof e2.T ? (t22.destroy(true), this.map.painter.saveTileTexture(o2)) : (t22.destroy(), t22.flushQueues(), t22._isHeaderLoaded = false, delete t22._mrt, delete t22.textureDescriptor), t22.fbo && (t22.fbo.destroy(), delete t22.fbo), delete t22.request, delete t22.requestParams, delete t22.neighboringTiles, t22.state = "unloaded";
        }
        prepareTile(t22, i22, o2) {
          t22._isHeaderLoaded && ("empty" !== t22.state && (t22.state = "reloading"), t22.fetchBand(i22, o2, (i3, o3) => {
            if (i3) return t22.state = "errored", this.fire(new e2.z(i3)), void this.triggerRepaint(t22);
            o3 && (t22._isHeaderLoaded = true, t22.setTexture(o3, this.map.painter), t22.state = "loaded", this.triggerRepaint(t22));
          }));
        }
        getInitialBand(e22) {
          if (!this.rasterLayers) return 0;
          const t22 = this.rasterLayers.find(({ id: t3 }) => t3 === e22), i22 = t22 && t22.fields, o2 = i22 && i22.bands && i22.bands;
          return o2 ? o2[0] : 0;
        }
        getTextureDescriptor(t22, i22, o2) {
          if (!t22) return;
          const s2 = i22.sourceLayer || this.rasterLayerIds && this.rasterLayerIds[0];
          if (!s2) return;
          let r22 = null;
          i22 instanceof e2.aN ? r22 = i22.paint.get("raster-array-band") : i22 instanceof e2.aO && (r22 = i22.paint.get("raster-particle-array-band"));
          const n22 = r22 || this.getInitialBand(s2);
          if (null != n22) if (t22.textureDescriptor) {
            if (!t22.updateNeeded(s2, n22) || o2) return Object.assign({}, t22.textureDescriptor, { texture: t22.texture });
          } else this.prepareTile(t22, s2, n22);
        }
        getImages(t22, i22) {
          const o2 = /* @__PURE__ */ new Map();
          for (const s2 of t22) for (const t3 of i22) {
            const [i3, r22] = t3.split("/"), n22 = s2.getLayer(i3);
            if (!n22) continue;
            if (!n22.hasBand(r22) || !n22.hasDataForBand(r22)) continue;
            const { bytes: a22, tileSize: l22, buffer: c22 } = n22.getBandView(r22), h22 = l22 + 2 * c22, d22 = { data: new e2.r({ width: h22, height: h22 }, a22), pixelRatio: 2, sdf: false, usvg: false, version: 0 };
            o2.set(t3, d22);
          }
          return o2;
        }
      }
      const rt = { vector: it, raster: ot, "raster-dem": class extends ot {
        constructor(t22, i22, o2, s2) {
          super(t22, i22, o2, s2), this.type = "raster-dem", this.maxzoom = 22, this._options = e2.l({ type: "raster-dem" }, i22), this.encoding = i22.encoding || "mapbox";
        }
        loadTile(t22, i22) {
          const o2 = this.map._requestManager.normalizeTileURL(t22.tileID.canonical.url(this.tiles, this.scheme), false, this.tileSize);
          function s2(e22, o3) {
            e22 && (t22.state = "errored", i22(e22)), o3 && (t22.dem = o3, t22.dem.onDeserialize(), t22.needsHillshadePrepare = true, t22.needsDEMTextureUpload = true, t22.state = "loaded", i22(null));
          }
          t22.request = e2.o(this.map._requestManager.transformRequest(o2, e2.R.Tile), function(o3, r22, n22, a22) {
            if (delete t22.request, t22.aborted) t22.state = "unloaded", i22(null);
            else if (o3) t22.state = "errored", i22(o3);
            else if (r22) {
              this.map._refreshExpiredTiles && t22.setExpiryData({ cacheControl: n22, expires: a22 });
              const i3 = ImageBitmap && r22 instanceof ImageBitmap && e2.t(), o4 = 1 - (r22.width - e2.aL(r22.width)) / 2;
              o4 < 1 || t22.neighboringTiles || (t22.neighboringTiles = this._getNeighboringTiles(t22.tileID));
              const l22 = i3 ? r22 : e2.q.getImageData(r22, o4), c22 = { uid: t22.uid, tileID: t22.tileID, source: this.id, type: this.type, scope: this.scope, rawImageData: l22, encoding: this.encoding, padding: o4 };
              t22.actor && "expired" !== t22.state || (t22.actor = this.dispatcher.getActor(), t22.actor.send("loadTile", c22, s2.bind(this), void 0, true));
            }
          }.bind(this));
        }
        _getNeighboringTiles(t22) {
          const i22 = t22.canonical, o2 = Math.pow(2, i22.z), s2 = (i22.x - 1 + o2) % o2, r22 = 0 === i22.x ? t22.wrap - 1 : t22.wrap, n22 = (i22.x + 1 + o2) % o2, a22 = i22.x + 1 === o2 ? t22.wrap + 1 : t22.wrap, l22 = {};
          return l22[new e2.aM(t22.overscaledZ, r22, i22.z, s2, i22.y).key] = { backfilled: false }, l22[new e2.aM(t22.overscaledZ, a22, i22.z, n22, i22.y).key] = { backfilled: false }, i22.y > 0 && (l22[new e2.aM(t22.overscaledZ, r22, i22.z, s2, i22.y - 1).key] = { backfilled: false }, l22[new e2.aM(t22.overscaledZ, t22.wrap, i22.z, i22.x, i22.y - 1).key] = { backfilled: false }, l22[new e2.aM(t22.overscaledZ, a22, i22.z, n22, i22.y - 1).key] = { backfilled: false }), i22.y + 1 < o2 && (l22[new e2.aM(t22.overscaledZ, r22, i22.z, s2, i22.y + 1).key] = { backfilled: false }, l22[new e2.aM(t22.overscaledZ, t22.wrap, i22.z, i22.x, i22.y + 1).key] = { backfilled: false }, l22[new e2.aM(t22.overscaledZ, a22, i22.z, n22, i22.y + 1).key] = { backfilled: false }), l22;
        }
      }, "raster-array": st, geojson: class extends e2.E {
        constructor(t22, i22, o2, s2) {
          super(), this.id = t22, this.type = "geojson", this.minzoom = 0, this.maxzoom = 18, this.tileSize = 512, this.isTileClipped = true, this.reparseOverscaled = true, this._loaded = false, this.actor = o2.getActor(), this.setEventedParent(s2), this._data = i22.data, this._options = e2.l({}, i22), this._collectResourceTiming = i22.collectResourceTiming, void 0 !== i22.maxzoom && (this.maxzoom = i22.maxzoom), void 0 !== i22.minzoom && (this.minzoom = i22.minzoom), i22.type && (this.type = i22.type), i22.attribution && (this.attribution = i22.attribution), this.promoteId = i22.promoteId;
          const r22 = e2.aj / this.tileSize;
          this.workerOptions = e2.l({ source: this.id, scope: this.scope, cluster: i22.cluster || false, geojsonVtOptions: { buffer: (void 0 !== i22.buffer ? i22.buffer : 128) * r22, tolerance: (void 0 !== i22.tolerance ? i22.tolerance : 0.375) * r22, extent: e2.aj, maxZoom: this.maxzoom, lineMetrics: i22.lineMetrics || false, generateId: i22.generateId || false }, superclusterOptions: { maxZoom: void 0 !== i22.clusterMaxZoom ? i22.clusterMaxZoom : this.maxzoom - 1, minPoints: Math.max(2, i22.clusterMinPoints || 2), extent: e2.aj, radius: (void 0 !== i22.clusterRadius ? i22.clusterRadius : 50) * r22, log: false, generateId: i22.generateId || false }, clusterProperties: i22.clusterProperties, filter: i22.filter, dynamic: i22.dynamic }, i22.workerOptions);
        }
        onAdd(e22) {
          this.map = e22, this.setData(this._data);
        }
        setData(e22) {
          return this._data = e22, this._updateWorkerData(), this;
        }
        updateData(t22) {
          if (!this._options.dynamic) return this.fire(new e2.z(new Error("Can't call updateData on a GeoJSON source with dynamic set to false.")));
          if ("string" != typeof t22 && ("Feature" === t22.type && (t22 = { type: "FeatureCollection", features: [t22] }), "FeatureCollection" !== t22.type)) return this.fire(new e2.z(new Error("Data to update should be a feature or a feature collection.")));
          if (this._coalesce && "string" != typeof t22 && "string" != typeof this._data && "FeatureCollection" === this._data.type) {
            const e22 = /* @__PURE__ */ new Map();
            for (const t3 of this._data.features) e22.set(t3.id, t3);
            for (const i22 of t22.features) e22.set(i22.id, i22);
            this._data.features = [...e22.values()];
          } else this._data = t22;
          return this._updateWorkerData(true), this;
        }
        getClusterExpansionZoom(e22, t22) {
          return this.actor.send("geojson.getClusterExpansionZoom", { clusterId: e22, source: this.id, scope: this.scope }, t22), this;
        }
        getClusterChildren(e22, t22) {
          return this.actor.send("geojson.getClusterChildren", { clusterId: e22, source: this.id, scope: this.scope }, t22), this;
        }
        getClusterLeaves(e22, t22, i22, o2) {
          return this.actor.send("geojson.getClusterLeaves", { source: this.id, scope: this.scope, clusterId: e22, limit: t22, offset: i22 }, o2), this;
        }
        _updateWorkerData(t22 = false) {
          if (this._pendingLoad) return void (this._coalesce = true);
          this.fire(new e2.A("dataloading", { dataType: "source" })), this._loaded = false;
          const i22 = e2.l({ append: t22 }, this.workerOptions);
          i22.scope = this.scope;
          const o2 = this._data;
          "string" == typeof o2 ? (i22.request = this.map._requestManager.transformRequest(e2.q.resolveURL(o2), e2.R.Source), i22.request.collectResourceTiming = this._collectResourceTiming) : i22.data = JSON.stringify(o2), this._pendingLoad = this.actor.send(`${this.type}.loadData`, i22, (i3, o3) => {
            if (this._loaded = true, this._pendingLoad = null, i3) this.fire(new e2.z(i3));
            else {
              const i4 = { dataType: "source", sourceDataType: this._metadataFired ? "content" : "metadata" };
              this._collectResourceTiming && o3 && o3.resourceTiming && o3.resourceTiming[this.id] && (i4.resourceTiming = o3.resourceTiming[this.id]), t22 && (this._partialReload = true), this.fire(new e2.A("data", i4)), this._partialReload = false, this._metadataFired = true;
            }
            this._coalesce && (this._updateWorkerData(t22), this._coalesce = false);
          });
        }
        loaded() {
          return this._loaded;
        }
        reload() {
          const t22 = e2.C(this.id, this.scope);
          this.map.style.clearSource(t22), this._updateWorkerData();
        }
        loadTile(t22, i22) {
          const o2 = t22.actor ? "reloadTile" : "loadTile";
          t22.actor = this.actor;
          const s2 = this.map.style ? this.map.style.getLut(this.scope) : null, r22 = s2 ? { image: s2.image.clone() } : null, n22 = this._partialReload, a22 = { type: this.type, uid: t22.uid, tileID: t22.tileID, tileZoom: t22.tileZoom, zoom: t22.tileID.overscaledZ, maxZoom: this.maxzoom, tileSize: this.tileSize, source: this.id, lut: r22, scope: this.scope, pixelRatio: e2.q.devicePixelRatio, showCollisionBoxes: this.map.showCollisionBoxes, promoteId: this.promoteId, brightness: this.map.style && this.map.style.getBrightness() || 0, extraShadowCaster: t22.isExtraShadowCaster, scaleFactor: this.map.getScaleFactor(), partial: n22 };
          t22.request = this.actor.send(o2, a22, (e22, s3) => n22 && !s3 ? (t22.state = "loaded", i22(null)) : (delete t22.request, t22.destroy(), t22.aborted ? i22(null) : e22 ? i22(e22) : (t22.loadVectorData(s3, this.map.painter, "reloadTile" === o2), i22(null))), void 0, "loadTile" === o2);
        }
        abortTile(e22) {
          e22.request && (e22.request.cancel(), delete e22.request), e22.aborted = true;
        }
        unloadTile(e22, t22) {
          this.actor.send("removeTile", { uid: e22.uid, type: this.type, source: this.id, scope: this.scope }), e22.destroy();
        }
        onRemove(e22) {
          this._pendingLoad && this._pendingLoad.cancel();
        }
        serialize() {
          return e2.l({}, this._options, { type: this.type, data: this._data });
        }
        hasTransition() {
          return false;
        }
      }, video: class extends e2.aP {
        constructor(e22, t22, i22, o2) {
          super(e22, t22, i22, o2), this.roundZoom = true, this.type = "video", this.options = t22;
        }
        load() {
          this._loaded = false;
          const t22 = this.options;
          this.urls = [];
          for (const i22 of t22.urls) this.urls.push(this.map._requestManager.transformRequest(i22, e2.R.Source).url);
          e2.aQ(this.urls, (t3, i22) => {
            this._loaded = true, t3 ? this.fire(new e2.z(t3)) : i22 && (this.video = i22, this.video.loop = true, this.video.setAttribute("playsinline", ""), this.video.addEventListener("playing", () => {
              this.map.triggerRepaint();
            }), this.map && this.video.play(), this._finishLoading());
          });
        }
        pause() {
          this.video && this.video.pause();
        }
        play() {
          this.video && this.video.play();
        }
        seek(t22) {
          if (this.video) {
            const i22 = this.video.seekable;
            t22 < i22.start(0) || t22 > i22.end(0) ? this.fire(new e2.z(new e2.V(`sources.${this.id}`, null, `Playback for this video can be set only between the ${i22.start(0)} and ${i22.end(0)}-second mark.`))) : this.video.currentTime = t22;
          }
        }
        getVideo() {
          return this.video;
        }
        onAdd(e22) {
          this.map || (this.map = e22, this.load(), this.video && (this.video.play(), this.setCoordinates(this.coordinates)));
        }
        prepare() {
          if (0 === Object.keys(this.tiles).length || this.video.readyState < 2) return;
          const t22 = this.map.painter.context, i22 = t22.gl;
          this.texture ? this.video.paused || (this.texture.bind(i22.LINEAR, i22.CLAMP_TO_EDGE), i22.texSubImage2D(i22.TEXTURE_2D, 0, 0, 0, i22.RGBA, i22.UNSIGNED_BYTE, this.video)) : (this.texture = new e2.T(t22, this.video, i22.RGBA8), this.texture.bind(i22.LINEAR, i22.CLAMP_TO_EDGE), this.width = this.video.videoWidth, this.height = this.video.videoHeight), this._prepareData(t22);
        }
        serialize() {
          return { type: "video", urls: this.urls, coordinates: this.coordinates };
        }
        hasTransition() {
          return this.video && !this.video.paused;
        }
      }, image: e2.aP, model: class extends e2.E {
        constructor(e22, t22, i22, o2) {
          super(), this.id = e22, this.type = "model", this.models = [], this._loaded = false, this._options = t22;
        }
        load() {
          const t22 = [];
          for (const i22 in this._options.models) {
            const o2 = this._options.models[i22], s2 = e2.aS(this.map._requestManager.transformRequest(o2.uri, e2.R.Model).url).then((t3) => {
              if (!t3) return;
              const s3 = e2.aT(t3), r22 = new e2.aU(i22, o2.position, o2.orientation, s3);
              r22.computeBoundsAndApplyParent(), this.models.push(r22);
            }).catch((t3) => {
              this.fire(new e2.z(new Error(`Could not load model ${i22} from ${o2.uri}: ${t3.message}`)));
            });
            t22.push(s2);
          }
          Promise.allSettled(t22).then(() => {
            this._loaded = true, this.fire(new e2.A("data", { dataType: "source", sourceDataType: "metadata" }));
          }).catch((t3) => {
            this._loaded = true, this.fire(new e2.z(new Error(`Could not load models: ${t3.message}`)));
          });
        }
        onAdd(e22) {
          this.map = e22, this.load();
        }
        hasTransition() {
          return false;
        }
        loaded() {
          return this._loaded;
        }
        getModels() {
          return this.models;
        }
        loadTile(e22, t22) {
        }
        serialize() {
          return this._options;
        }
      }, "batched-model": class extends e2.E {
        constructor(e22, t22, i22, o2) {
          super(), this.type = "batched-model", this.id = e22, this.tileSize = 512, this._options = t22, this.tiles = this._options.tiles, this.maxzoom = t22.maxzoom || 19, this.minzoom = t22.minzoom || 0, this.roundZoom = true, this.usedInConflation = true, this.dispatcher = i22, this.reparseOverscaled = false, this.scheme = "xyz", this._loaded = false, this.setEventedParent(o2);
        }
        onAdd(e22) {
          this.map = e22, this.load();
        }
        reload() {
          this.cancelTileJSONRequest();
          const t22 = e2.C(this.id, this.scope);
          this.load(() => this.map.style.clearSource(t22));
        }
        cancelTileJSONRequest() {
          this._tileJSONRequest && (this._tileJSONRequest.cancel(), this._tileJSONRequest = null);
        }
        load(t22) {
          this._loaded = false, this.fire(new e2.A("dataloading", { dataType: "source" }));
          const i22 = Array.isArray(this.map._language) ? this.map._language.join() : this.map._language, o2 = this.map.getWorldview();
          this._tileJSONRequest = Qe(this._options, this.map._requestManager, i22, o2, (s2, r22) => {
            this._tileJSONRequest = null, this._loaded = true, s2 ? (i22 && console.warn(`Ensure that your requested language string is a valid BCP-47 code or list of codes. Found: ${i22}`), o2 && 2 !== o2.length && console.warn(`Requested worldview strings must be a valid ISO alpha-2 code. Found: ${o2}`), this.fire(new e2.z(s2))) : r22 && (e2.l(this, r22), r22.bounds && (this.tileBounds = new tt(r22.bounds, this.minzoom, this.maxzoom)), L2(r22.tiles, this.map._requestManager._customAccessToken), this.fire(new e2.A("data", { dataType: "source", sourceDataType: "metadata" })), this.fire(new e2.A("data", { dataType: "source", sourceDataType: "content" }))), t22 && t22(s2);
          });
        }
        hasTransition() {
          return false;
        }
        hasTile(e22) {
          return !this.tileBounds || this.tileBounds.contains(e22.canonical);
        }
        loaded() {
          return this._loaded;
        }
        loadTile(t22, i22) {
          const o2 = this.map._requestManager.normalizeTileURL(t22.tileID.canonical.url(this.tiles, this.scheme)), s2 = { request: this.map._requestManager.transformRequest(o2, e2.R.Tile), data: void 0, uid: t22.uid, tileID: t22.tileID, tileZoom: t22.tileZoom, zoom: t22.tileID.overscaledZ, tileSize: this.tileSize * t22.tileID.overscaleFactor(), type: this.type, source: this.id, scope: this.scope, showCollisionBoxes: this.map.showCollisionBoxes, isSymbolTile: t22.isSymbolTile, brightness: this.map.style && this.map.style.getBrightness() || 0, pixelRatio: e2.q.devicePixelRatio, promoteId: this.promoteId };
          if (t22.actor && "expired" !== t22.state) if ("loading" === t22.state) t22.reloadCallback = i22;
          else {
            if (t22.buckets) {
              const e22 = Object.values(t22.buckets);
              for (const t3 of e22) t3.dirty = true;
              return void (t22.state = "loaded");
            }
            t22.request = t22.actor.send("reloadTile", s2, r22.bind(this));
          }
          else t22.actor = this.dispatcher.getActor(), t22.request = t22.actor.send("loadTile", s2, r22.bind(this), void 0, true);
          function r22(e22, o3) {
            return t22.aborted ? i22(null) : e22 && 404 !== e22.status ? i22(e22) : (this.map._refreshExpiredTiles && o3 && t22.setExpiryData(o3), t22.loadModelData(o3, this.map.painter), t22.state = "loaded", void i22(null));
          }
        }
        serialize() {
          return e2.l({}, this._options);
        }
      }, canvas: class extends e2.aP {
        constructor(t22, i22, o2, s2) {
          super(t22, i22, o2, s2), i22.coordinates ? Array.isArray(i22.coordinates) && 4 === i22.coordinates.length && !i22.coordinates.some((e22) => !Array.isArray(e22) || 2 !== e22.length || e22.some((e3) => "number" != typeof e3)) || this.fire(new e2.z(new e2.V(`sources.${t22}`, null, '"coordinates" property must be an array of 4 longitude/latitude array pairs'))) : this.fire(new e2.z(new e2.V(`sources.${t22}`, null, 'missing required property "coordinates"'))), i22.animate && "boolean" != typeof i22.animate && this.fire(new e2.z(new e2.V(`sources.${t22}`, null, 'optional "animate" property must be a boolean value'))), i22.canvas ? "string" == typeof i22.canvas || i22.canvas instanceof HTMLCanvasElement || this.fire(new e2.z(new e2.V(`sources.${t22}`, null, '"canvas" must be either a string representing the ID of the canvas element from which to read, or an HTMLCanvasElement instance'))) : this.fire(new e2.z(new e2.V(`sources.${t22}`, null, 'missing required property "canvas"'))), this.options = i22, this.animate = void 0 === i22.animate || i22.animate;
        }
        load() {
          this._loaded = true, this.canvas || (this.canvas = this.options.canvas instanceof HTMLCanvasElement ? this.options.canvas : document.getElementById(this.options.canvas)), this.width = this.canvas.width, this.height = this.canvas.height, this._hasInvalidDimensions() ? this.fire(new e2.z(new Error("Canvas dimensions cannot be less than or equal to zero."))) : (this.play = function() {
            this._playing = true, this.map.triggerRepaint();
          }, this.pause = function() {
            this._playing && (this.prepare(), this._playing = false);
          }, this._finishLoading());
        }
        getCanvas() {
          return this.canvas;
        }
        onAdd(e22) {
          this.map = e22, this.load(), this.canvas && this.animate && this.play();
        }
        onRemove(e22) {
          this.pause();
        }
        prepare() {
          let t22 = false;
          if (this.canvas.width !== this.width && (this.width = this.canvas.width, t22 = true), this.canvas.height !== this.height && (this.height = this.canvas.height, t22 = true), this._hasInvalidDimensions()) return;
          if (0 === Object.keys(this.tiles).length) return;
          const i22 = this.map.painter.context;
          this.texture ? !t22 && !this._playing || this.texture instanceof e2.aR || this.texture.update(this.canvas, { premultiply: true }) : this.texture = new e2.T(i22, this.canvas, i22.gl.RGBA8, { premultiply: true }), this._prepareData(i22);
        }
        serialize() {
          return { type: "canvas", coordinates: this.coordinates };
        }
        hasTransition() {
          return this._playing;
        }
        _hasInvalidDimensions() {
          for (const e22 of [this.canvas.width, this.canvas.height]) if (isNaN(e22) || e22 <= 0) return true;
          return false;
        }
      }, custom: class extends e2.E {
        constructor(t22, i22, o2, s2) {
          super(), this.id = t22, this.type = "custom", this._dataType = "raster", this._dispatcher = o2, this._implementation = i22, this.setEventedParent(s2), this.scheme = "xyz", this.minzoom = 0, this.maxzoom = 22, this.tileSize = 512, this._loaded = false, this.roundZoom = true, this._implementation || this.fire(new e2.z(new Error(`Missing implementation for ${this.id} custom source`))), this._implementation.loadTile || this.fire(new e2.z(new Error(`Missing loadTile implementation for ${this.id} custom source`))), this._implementation.bounds && (this.tileBounds = new tt(this._implementation.bounds, this.minzoom, this.maxzoom)), i22.update = this._update.bind(this), i22.clearTiles = this._clearTiles.bind(this), i22.coveringTiles = this._coveringTiles.bind(this), e2.l(this, e2.aF(i22, ["dataType", "scheme", "minzoom", "maxzoom", "tileSize", "attribution", "minTileCacheSize", "maxTileCacheSize"]));
        }
        serialize() {
          return e2.aF(this, ["type", "scheme", "minzoom", "maxzoom", "tileSize", "attribution"]);
        }
        load() {
          this._loaded = true, this.fire(new e2.A("data", { dataType: "source", sourceDataType: "metadata" })), this.fire(new e2.A("data", { dataType: "source", sourceDataType: "content" }));
        }
        loaded() {
          return this._loaded;
        }
        onAdd(t22) {
          this.map = t22, this._loaded = false, this.fire(new e2.A("dataloading", { dataType: "source" })), this._implementation.onAdd && this._implementation.onAdd(t22), this.load();
        }
        onRemove(e22) {
          this._implementation.onRemove && this._implementation.onRemove(e22);
        }
        hasTile(e22) {
          if (this._implementation.hasTile) {
            const { x: t22, y: i22, z: o2 } = e22.canonical;
            return this._implementation.hasTile({ x: t22, y: i22, z: o2 });
          }
          return !this.tileBounds || this.tileBounds.contains(e22.canonical);
        }
        loadTile(e22, t22) {
          const { x: i22, y: o2, z: s2 } = e22.tileID.canonical, r22 = new AbortController();
          e22.request = Promise.resolve(this._implementation.loadTile({ x: i22, y: o2, z: s2 }, { signal: r22.signal })).then(function(i3) {
            return delete e22.request, e22.aborted ? (e22.state = "unloaded", t22(null)) : void 0 === i3 ? (e22.state = "errored", t22(null)) : null === i3 ? (this.loadTileData(e22, { width: this.tileSize, height: this.tileSize, data: null }), e22.state = "loaded", t22(null)) : function(e3) {
              return e3 instanceof ImageData || e3 instanceof HTMLCanvasElement || e3 instanceof ImageBitmap || e3 instanceof HTMLImageElement;
            }(i3) ? (this.loadTileData(e22, i3), e22.state = "loaded", void t22(null)) : (e22.state = "errored", t22(new Error(`Can't infer data type for ${this.id}, only raster data supported at the moment`)));
          }.bind(this)).catch((i3) => {
            "AbortError" !== i3.name && (e22.state = "errored", t22(i3));
          }), e22.request.cancel = () => r22.abort();
        }
        loadTileData(e22, t22) {
          e22.setTexture(t22, this.map.painter);
        }
        unloadTile(t22, i22) {
          if (t22.texture && t22.texture instanceof e2.T ? (t22.destroy(true), t22.texture && t22.texture instanceof e2.T && this.map.painter.saveTileTexture(t22.texture)) : t22.destroy(), this._implementation.unloadTile) {
            const { x: e22, y: i3, z: o2 } = t22.tileID.canonical;
            this._implementation.unloadTile({ x: e22, y: i3, z: o2 });
          }
          i22 && i22();
        }
        abortTile(e22, t22) {
          e22.request && e22.request.cancel && (e22.request.cancel(), delete e22.request), t22 && t22();
        }
        hasTransition() {
          return false;
        }
        _coveringTiles() {
          return this.map.transform.coveringTiles({ tileSize: this.tileSize, minzoom: this.minzoom, maxzoom: this.maxzoom, roundZoom: this.roundZoom }).map((e22) => ({ x: e22.canonical.x, y: e22.canonical.y, z: e22.canonical.z }));
        }
        _clearTiles() {
          const t22 = e2.C(this.id, this.scope);
          this.map.style.clearSource(t22);
        }
        _update() {
          this.fire(new e2.A("data", { dataType: "source", sourceDataType: "content" }));
        }
      } }, nt = function(t22, i22, o2, s2) {
        const r22 = new rt[i22.type](t22, i22, o2, s2);
        if (r22.id !== t22) throw new Error(`Expected Source id to be ${t22} instead of ${r22.id}`);
        return e2.aV(["load", "abort", "unload", "serialize", "prepare"], r22), r22;
      };
      function at(e22, t22, i22 = "") {
        return `${i22}:${t22.id || ""}:${t22.layer.id}:${function(e3) {
          if ("layerId" in e3) return `layer:${e3.layerId}`;
          {
            const { featuresetId: t3, importId: i3 } = e3;
            return `featureset:${t3}${i3 ? `:import:${i3}` : ""}`;
          }
        }(e22.target)}`;
      }
      function lt(e22, t22, i22, o2 = "") {
        if (e22.uniqueFeatureID) {
          const s2 = at(e22, t22, o2);
          if (i22.has(s2)) return true;
          i22.add(s2);
        }
        return false;
      }
      function ct2(e22, t22, i22, o2, s2 = false) {
        const r22 = t22.sourceCache.transform, n22 = t22.sourceCache.tilesIn(e22, t22.has3DLayers, s2);
        n22.sort(ut2);
        const a22 = [];
        for (const e3 of n22) {
          const n3 = e3.tile.queryRenderedFeatures(t22, e3, i22, o2, r22, s2);
          Object.keys(n3).length && a22.push({ wrappedTileID: e3.tile.tileID.wrapped().key, queryResults: n3 });
        }
        return 0 === a22.length ? {} : function(e3) {
          const t3 = {}, i3 = {};
          for (const o3 of e3) {
            const e4 = o3.queryResults, s3 = o3.wrappedTileID, r3 = i3[s3] = i3[s3] || {};
            for (const i4 in e4) {
              const o4 = e4[i4], s4 = r3[i4] = r3[i4] || {}, n3 = t3[i4] = t3[i4] || [];
              for (const e5 of o4) s4[e5.featureIndex] || (s4[e5.featureIndex] = true, n3.push(e5));
            }
          }
          return t3;
        }(a22);
      }
      function ht(e22, t22, i22, o2, s2) {
        const r22 = {}, n22 = o2.queryRenderedSymbols(e22), a22 = [];
        for (const e3 of Object.keys(n22).map(Number)) a22.push(s2[e3]);
        a22.sort(ut2);
        for (const e3 of a22) {
          const o3 = e3.featureIndex.lookupSymbolFeatures(n22[e3.bucketInstanceId], e3.bucketIndex, e3.sourceLayerIndex, t22, i22);
          for (const t3 in o3) {
            const i3 = r22[t3] = r22[t3] || [], s3 = o3[t3];
            s3.sort((t4, i4) => {
              const o4 = e3.featureSortOrder;
              if (o4) {
                const e4 = o4.indexOf(t4.featureIndex);
                return o4.indexOf(i4.featureIndex) - e4;
              }
              return i4.featureIndex - t4.featureIndex;
            });
            for (const e4 of s3) i3.push(e4);
          }
        }
        return r22;
      }
      function dt(e22, t22) {
        const i22 = e22.getRenderableIds().map((t3) => e22.getTileByID(t3)), o2 = [], s2 = {};
        for (let e3 = 0; e3 < i22.length; e3++) {
          const r22 = i22[e3], n22 = r22.tileID.canonical.key;
          s2[n22] || (s2[n22] = true, r22.querySourceFeatures(o2, t22));
        }
        return o2;
      }
      function ut2(e22, t22) {
        const i22 = e22.tileID, o2 = t22.tileID;
        return i22.overscaledZ - o2.overscaledZ || i22.canonical.y - o2.canonical.y || i22.wrap - o2.wrap || i22.canonical.x - o2.canonical.x;
      }
      function _t2(e22, t22) {
        const i22 = {};
        if (!t22) return i22;
        for (const o2 of e22) {
          const e3 = o2.layerIds.map((e4) => t22.getLayer(e4)).filter(Boolean);
          if (0 !== e3.length) {
            o2.layers = e3, o2.stateDependentLayerIds && (o2.stateDependentLayers = o2.stateDependentLayerIds.map((t3) => e3.filter((e4) => e4.id === t3)[0]));
            for (const t3 of e3) i22[t3.fqid] = o2;
          }
        }
        return i22;
      }
      const pt = 32, ft2 = 33, mt = new Uint16Array(8184);
      for (let e22 = 0; e22 < 2046; e22++) {
        let t22 = e22 + 2, i22 = 0, o2 = 0, s2 = 0, r22 = 0, n22 = 0, a22 = 0;
        for (1 & t22 ? s2 = r22 = n22 = pt : i22 = o2 = a22 = pt; (t22 >>= 1) > 1; ) {
          const e3 = i22 + s2 >> 1, l3 = o2 + r22 >> 1;
          1 & t22 ? (s2 = i22, r22 = o2, i22 = n22, o2 = a22) : (i22 = s2, o2 = r22, s2 = n22, r22 = a22), n22 = e3, a22 = l3;
        }
        const l22 = 4 * e22;
        mt[l22 + 0] = i22, mt[l22 + 1] = o2, mt[l22 + 2] = s2, mt[l22 + 3] = r22;
      }
      const gt = new Uint16Array(2178), vt = new Uint8Array(1089), yt = new Uint16Array(1089);
      function xt(e22) {
        return 0 === e22 ? -0.03125 : 32 === e22 ? 0.03125 : 0;
      }
      const bt = (() => ({ type: 2, extent: e2.aj, loadGeometry: () => [[new e2.P(0, 0), new e2.P(e2.aj + 1, 0), new e2.P(e2.aj + 1, e2.aj + 1), new e2.P(0, e2.aj + 1), new e2.P(0, 0)]] }))();
      class wt {
        constructor(t22, i22, o2, s2, r22) {
          this.tileID = t22, this.uid = e2.a$(), this.uses = 0, this.tileSize = i22, this.tileZoom = o2, this.buckets = {}, this.expirationTime = null, this.queryPadding = 0, this.hasSymbolBuckets = false, this.hasRTLText = false, this.dependencies = {}, this.isRaster = r22, s2 && s2.style && (this._lastUpdatedBrightness = s2.style.getBrightness()), this.expiredRequestCount = 0, this.state = "loading", s2 && s2.transform && (this.projection = s2.transform.projection);
        }
        registerFadeDuration(t22) {
          const i22 = t22 + this.timeAdded;
          i22 < e2.q.now() || this.fadeEndTime && i22 < this.fadeEndTime || (this.fadeEndTime = i22);
        }
        wasRequested() {
          return "errored" === this.state || "loaded" === this.state || "reloading" === this.state;
        }
        get tileTransform() {
          return this._tileTransform || (this._tileTransform = e2.aW(this.tileID.canonical, this.projection)), this._tileTransform;
        }
        loadVectorData(t22, i22, o2) {
          if (this.unloadVectorData(), this.state = "loaded", t22) {
            t22.featureIndex && (this.latestFeatureIndex = t22.featureIndex, t22.rawTileData ? (this.latestRawTileData = t22.rawTileData, this.latestFeatureIndex.rawTileData = t22.rawTileData) : this.latestRawTileData && (this.latestFeatureIndex.rawTileData = this.latestRawTileData)), this.collisionBoxArray = t22.collisionBoxArray, this.buckets = _t2(t22.buckets, i22.style), this.hasSymbolBuckets = false;
            for (const t3 in this.buckets) {
              const i3 = this.buckets[t3];
              if (i3 instanceof e2.b1) {
                if (this.hasSymbolBuckets = true, !o2) break;
                i3.justReloaded = true;
              }
            }
            if (this.hasRTLText = false, this.hasSymbolBuckets) for (const t3 in this.buckets) {
              const i3 = this.buckets[t3];
              if (i3 instanceof e2.b1 && i3.hasRTLText) {
                this.hasRTLText = true, e2.b2();
                break;
              }
            }
            this.queryPadding = 0;
            for (const e22 in this.buckets) {
              const t3 = this.buckets[e22], o3 = i22.style.getOwnLayer(e22);
              if (!o3) continue;
              const s2 = o3.queryRadius(t3);
              this.queryPadding = Math.max(this.queryPadding, s2);
            }
            t22.imageAtlas && (this.imageAtlas = t22.imageAtlas), t22.glyphAtlasImage && (this.glyphAtlasImage = t22.glyphAtlasImage), t22.lineAtlas && (this.lineAtlas = t22.lineAtlas), this._lastUpdatedBrightness = t22.brightness;
          } else this.collisionBoxArray = new e2.b0();
        }
        unloadVectorData() {
          if (this.hasData()) {
            for (const e22 in this.buckets) this.buckets[e22].destroy();
            this.buckets = {}, this.imageAtlas && (this.imageAtlas = null), this.lineAtlas && (this.lineAtlas = null), this.imageAtlasTexture && this.imageAtlasTexture.destroy(), this.glyphAtlasTexture && this.glyphAtlasTexture.destroy(), this.lineAtlasTexture && this.lineAtlasTexture.destroy(), this._tileBoundsBuffer && (this._tileBoundsBuffer.destroy(), this._tileBoundsIndexBuffer.destroy(), this._tileBoundsSegments.destroy(), this._tileBoundsBuffer = null), this._tileDebugBuffer && (this._tileDebugBuffer.destroy(), this._tileDebugSegments.destroy(), this._tileDebugBuffer = null), this._tileDebugIndexBuffer && (this._tileDebugIndexBuffer.destroy(), this._tileDebugIndexBuffer = null), this._globeTileDebugBorderBuffer && (this._globeTileDebugBorderBuffer.destroy(), this._globeTileDebugBorderBuffer = null), this._tileDebugTextBuffer && (this._tileDebugTextBuffer.destroy(), this._tileDebugTextSegments.destroy(), this._tileDebugTextIndexBuffer.destroy(), this._tileDebugTextBuffer = null), this._globeTileDebugTextBuffer && (this._globeTileDebugTextBuffer.destroy(), this._globeTileDebugTextBuffer = null), this.latestFeatureIndex = null, this.state = "unloaded";
          }
        }
        loadModelData(e22, t22, i22) {
          e22 && (e22.resourceTiming && (this.resourceTiming = e22.resourceTiming), this.buckets = Object.assign({}, this.buckets, _t2(e22.buckets, t22.style)), e22.featureIndex && (this.latestFeatureIndex = e22.featureIndex));
        }
        getBucket(e22) {
          return this.buckets[e22.fqid];
        }
        upload(t22) {
          for (const e22 in this.buckets) {
            const i3 = this.buckets[e22];
            i3.uploadPending() && i3.upload(t22);
          }
          const i22 = t22.gl, o2 = this.imageAtlas;
          o2 && !o2.uploaded && (this.imageAtlasTexture = new e2.T(t22, o2.image, i22.RGBA8, { useMipmap: !!o2.patternPositions.size }), this.imageAtlas.uploaded = true), this.glyphAtlasImage && (this.glyphAtlasTexture = new e2.T(t22, this.glyphAtlasImage, i22.R8), this.glyphAtlasImage = null), this.lineAtlas && !this.lineAtlas.uploaded && (this.lineAtlasTexture = new e2.T(t22, this.lineAtlas.image, i22.R8), this.lineAtlas.uploaded = true);
        }
        prepare(e22, t22, i22) {
          if (this.imageAtlas && this.imageAtlasTexture && this.imageAtlas.patchUpdatedImages(e22, this.imageAtlasTexture, i22), !t22 || !this.latestFeatureIndex || !this.latestFeatureIndex.rawTileData) return;
          const o2 = t22.style.getBrightness();
          (this._lastUpdatedBrightness || o2) && (this._lastUpdatedBrightness && o2 && Math.abs(this._lastUpdatedBrightness - o2) < 1e-3 || (this.updateBuckets(t22, this._lastUpdatedBrightness !== o2), this._lastUpdatedBrightness = o2));
        }
        queryRenderedFeatures(t22, i22, o2, s2, r22, n22) {
          if (!this.latestFeatureIndex || !this.latestFeatureIndex.rawTileData && !this.latestFeatureIndex.is3DTile) return {};
          const a22 = function(t3, i3) {
            const o3 = e2.bn([], [0.5 * t3.width, 0.5 * -t3.height, 1]);
            return e2.bo(o3, o3, [1, -1, 0]), e2.az(o3, o3, t3.calculateProjMatrix(i3.toUnwrapped())), Float32Array.from(o3);
          }(r22, this.tileID);
          return this.latestFeatureIndex.query(t22, { tilespaceGeometry: i22, pixelPosMatrix: a22, transform: s2, availableImages: o2, tileTransform: this.tileTransform });
        }
        querySourceFeatures(t22, i22) {
          const o2 = this.latestFeatureIndex;
          if (!o2 || !o2.rawTileData) return;
          const s2 = o2.loadVTLayers(), r22 = i22 ? i22.sourceLayer : "", n22 = s2._geojsonTileLayer || s2[r22];
          if (!n22) return;
          const a22 = e2.b3(i22 && i22.filter), { z: l22, x: c22, y: h22 } = this.tileID.canonical, d22 = { z: l22, x: c22, y: h22 };
          for (let i3 = 0; i3 < n22.length; i3++) {
            const s3 = n22.feature(i3);
            if (a22.needGeometry) {
              const t3 = e2.b4(s3, true);
              if (!a22.filter(new e2.aa(this.tileID.overscaledZ), t3, this.tileID.canonical)) continue;
            } else if (!a22.filter(new e2.aa(this.tileID.overscaledZ), s3)) continue;
            const u22 = o2.getId(s3, r22), _22 = new e2.b5(s3, l22, c22, h22, u22);
            _22.tile = d22, t22.push(_22);
          }
        }
        loaded() {
          return "loaded" === this.state || "errored" === this.state;
        }
        hasData() {
          return "loaded" === this.state || "reloading" === this.state || "expired" === this.state;
        }
        patternsLoaded() {
          return !!this.imageAtlas && !!this.imageAtlas.patternPositions.size;
        }
        setExpiryData(t22) {
          const i22 = this.expirationTime;
          if (t22.cacheControl) {
            const i3 = e2.b6(t22.cacheControl);
            i3["max-age"] && (this.expirationTime = Date.now() + 1e3 * i3["max-age"]);
          } else t22.expires && (this.expirationTime = new Date(t22.expires).getTime());
          if (this.expirationTime) {
            const e22 = Date.now();
            let t3 = false;
            if (this.expirationTime > e22) t3 = false;
            else if (i22) if (this.expirationTime < i22) t3 = true;
            else {
              const o2 = this.expirationTime - i22;
              o2 ? this.expirationTime = e22 + Math.max(o2, 3e4) : t3 = true;
            }
            else t3 = true;
            t3 ? (this.expiredRequestCount++, this.state = "expired") : this.expiredRequestCount = 0;
          }
        }
        getExpiryTimeout() {
          if (this.expirationTime) return this.expiredRequestCount ? 1e3 * (1 << Math.min(this.expiredRequestCount - 1, 31)) : Math.min(this.expirationTime - (/* @__PURE__ */ new Date()).getTime(), Math.pow(2, 31) - 1);
        }
        refreshFeatureState(e22) {
          this.latestFeatureIndex && (this.latestFeatureIndex.rawTileData || this.latestFeatureIndex.is3DTile) && e22 && this.updateBuckets(e22);
        }
        updateBuckets(t22, i22) {
          if (!this.latestFeatureIndex) return;
          if (!t22.style) return;
          const o2 = this.latestFeatureIndex.loadVTLayers(), s2 = t22.style.listImages(), r22 = t22.style.getBrightness();
          for (const n22 in this.buckets) {
            if (!t22.style.hasLayer(n22)) continue;
            const a22 = this.buckets[n22], l22 = a22.layers[0], c22 = l22.sourceLayer || "_geojsonTileLayer", h22 = o2[c22], d22 = t22.style.getLayerSourceCache(l22);
            let u22 = {};
            d22 && (u22 = d22._state.getState(c22, void 0));
            const _22 = this.imageAtlas ? Object.fromEntries(this.imageAtlas.patternPositions) : {}, p22 = Object.keys(u22).length > 0 && !i22;
            p22 && !a22.stateDependentLayers.length && !i22 || a22.update(u22, h22, s2, _22, p22 ? a22.stateDependentLayers : a22.layers, i22, r22), (a22 instanceof e2.b7 || a22 instanceof e2.b8) && t22._terrain && t22._terrain.enabled && d22 && a22.uploadPending() && t22._terrain._clearRenderCacheForTile(d22.id, this.tileID);
            const f22 = t22 && t22.style && t22.style.getOwnLayer(n22);
            f22 && (this.queryPadding = Math.max(this.queryPadding, f22.queryRadius(a22)));
          }
        }
        holdingForFade() {
          return void 0 !== this.symbolFadeHoldUntil;
        }
        symbolFadeFinished() {
          return !this.symbolFadeHoldUntil || this.symbolFadeHoldUntil < e2.q.now();
        }
        clearFadeHold() {
          this.symbolFadeHoldUntil = void 0;
        }
        setHoldDuration(t22) {
          this.symbolFadeHoldUntil = e2.q.now() + t22;
        }
        setTexture(t22, i22) {
          const o2 = i22.context, s2 = o2.gl;
          this.texture = this.texture || i22.getTileTexture(t22.width), this.texture && this.texture instanceof e2.T ? this.texture.update(t22) : (this.texture = new e2.T(o2, t22, s2.RGBA8, { useMipmap: true }), this.texture.bind(s2.LINEAR, s2.CLAMP_TO_EDGE));
        }
        setDependencies(e22, t22) {
          const i22 = {};
          for (const e3 of t22) i22[e3] = true;
          this.dependencies[e22] = i22;
        }
        hasDependency(e22, t22) {
          for (const i22 of e22) {
            const e3 = this.dependencies[i22];
            if (e3) {
              for (const i3 of t22) if (e3[i3]) return true;
            }
          }
          return false;
        }
        clearQueryDebugViz() {
        }
        _makeDebugTileBoundsBuffers(t22, i22) {
          if (!i22 || "mercator" === i22.name || this._tileDebugBuffer) return;
          const o2 = e2.b9(bt, this.tileID.canonical, this.tileTransform)[0], s2 = new e2.ba(), r22 = new e2.bb();
          for (let e22 = 0; e22 < o2.length; e22++) {
            const { x: t3, y: i3 } = o2[e22];
            s2.emplaceBack(t3, i3), r22.emplaceBack(e22);
          }
          r22.emplaceBack(0), this._tileDebugIndexBuffer = t22.createIndexBuffer(r22), this._tileDebugBuffer = t22.createVertexBuffer(s2, e2.bc.members), this._tileDebugSegments = e2.bd.simpleSegment(0, 0, s2.length, r22.length);
        }
        _makeTileBoundsBuffers(t22, i22) {
          if (this._tileBoundsBuffer || !i22 || "mercator" === i22.name) return;
          const o2 = e2.b9(bt, this.tileID.canonical, this.tileTransform)[0];
          let s2, r22;
          if (this.isRaster) {
            const t3 = function(t4, i3) {
              const o3 = e2.aW(t4, i3), s3 = Math.pow(2, t4.z);
              for (let r4 = 0; r4 < ft2; r4++) for (let n3 = 0; n3 < ft2; n3++) {
                const a3 = e2.aX((t4.x + (n3 + xt(n3)) / pt) / s3), l3 = e2.aY((t4.y + (r4 + xt(r4)) / pt) / s3), c3 = i3.project(a3, l3), h22 = r4 * ft2 + n3;
                gt[2 * h22 + 0] = Math.round((c3.x * o3.scale - o3.x) * e2.aj), gt[2 * h22 + 1] = Math.round((c3.y * o3.scale - o3.y) * e2.aj);
              }
              vt.fill(0), yt.fill(0);
              for (let e22 = 2045; e22 >= 0; e22--) {
                const t5 = 4 * e22, i4 = mt[t5 + 0], o4 = mt[t5 + 1], s4 = mt[t5 + 2], r4 = mt[t5 + 3], n3 = i4 + s4 >> 1, a3 = o4 + r4 >> 1, l3 = n3 + a3 - o4, c3 = a3 + i4 - n3, h22 = o4 * ft2 + i4, d22 = r4 * ft2 + s4, u22 = a3 * ft2 + n3, _22 = Math.hypot((gt[2 * h22 + 0] + gt[2 * d22 + 0]) / 2 - gt[2 * u22 + 0], (gt[2 * h22 + 1] + gt[2 * d22 + 1]) / 2 - gt[2 * u22 + 1]) >= 16;
                vt[u22] = vt[u22] || (_22 ? 1 : 0), e22 < 1022 && (vt[u22] = vt[u22] || vt[(o4 + c3 >> 1) * ft2 + (i4 + l3 >> 1)] || vt[(r4 + c3 >> 1) * ft2 + (s4 + l3 >> 1)]);
              }
              const r3 = new e2.aZ(), n22 = new e2.a_();
              let a22 = 0;
              function l22(t5, i4) {
                const o4 = i4 * ft2 + t5;
                return 0 === yt[o4] && (r3.emplaceBack(gt[2 * o4 + 0], gt[2 * o4 + 1], t5 * e2.aj / pt, i4 * e2.aj / pt), yt[o4] = ++a22), yt[o4] - 1;
              }
              function c22(e22, t5, i4, o4, s4, r4) {
                const a3 = e22 + i4 >> 1, h22 = t5 + o4 >> 1;
                if (Math.abs(e22 - s4) + Math.abs(t5 - r4) > 1 && vt[h22 * ft2 + a3]) c22(s4, r4, e22, t5, a3, h22), c22(i4, o4, s4, r4, a3, h22);
                else {
                  const a4 = l22(e22, t5), c3 = l22(i4, o4), h3 = l22(s4, r4);
                  n22.emplaceBack(a4, c3, h3);
                }
              }
              return c22(0, 0, pt, pt, pt, 0), c22(pt, pt, 0, 0, 0, pt), { vertices: r3, indices: n22 };
            }(this.tileID.canonical, i22);
            s2 = t3.vertices, r22 = t3.indices;
          } else {
            s2 = new e2.aZ(), r22 = new e2.a_();
            for (const { x: e22, y: t4 } of o2) s2.emplaceBack(e22, t4, 0, 0);
            const t3 = e2.be(s2.int16.subarray(0, 4 * s2.length), void 0, 4);
            for (let e22 = 0; e22 < t3.length; e22 += 3) r22.emplaceBack(t3[e22], t3[e22 + 1], t3[e22 + 2]);
          }
          this._tileBoundsBuffer = t22.createVertexBuffer(s2, e2.bf.members), this._tileBoundsIndexBuffer = t22.createIndexBuffer(r22), this._tileBoundsSegments = e2.bd.simpleSegment(0, 0, s2.length, r22.length);
        }
        _makeGlobeTileDebugBuffers(t22, i22) {
          const o2 = i22.projection;
          if (!o2 || "globe" !== o2.name || i22.freezeTileCoverage) return;
          const s2 = this.tileID.canonical, r22 = e2.bg(s2, i22), n22 = e2.bh(r22), a22 = e2.ah(i22.zoom);
          let l22;
          a22 > 0 && (l22 = e2.bi(new Float64Array(16), i22.globeMatrix)), this._makeGlobeTileDebugBorderBuffer(t22, s2, i22, n22, l22, a22), this._makeGlobeTileDebugTextBuffer(t22, s2, i22, n22, l22, a22);
        }
        _globePoint(t22, i22, o2, s2, r22, n22, a22) {
          let l22 = e2.bj(t22, i22, o2);
          if (n22) {
            const r3 = 1 << o2.z, c22 = e2.ay(s2.center.lng), h22 = e2.aH(s2.center.lat), d22 = (o2.x + 0.5) / r3 - c22;
            let u22 = 0;
            d22 > 0.5 ? u22 = -1 : d22 < -0.5 && (u22 = 1);
            let _22 = (t22 / e2.aj + o2.x) / r3 + u22, p22 = (i22 / e2.aj + o2.y) / r3;
            _22 = (_22 - c22) * s2._pixelsPerMercatorPixel + c22, p22 = (p22 - h22) * s2._pixelsPerMercatorPixel + h22;
            const f22 = [_22 * s2.worldSize, p22 * s2.worldSize, 0];
            e2.ad(f22, f22, n22), l22 = e2.bk(l22, f22, a22);
          }
          return e2.ad(l22, l22, r22);
        }
        _makeGlobeTileDebugBorderBuffer(t22, i22, o2, s2, r22, n22) {
          const a22 = new e2.ba(), l22 = new e2.bb(), c22 = new e2.bl(), h22 = (e22, t3, h3, d3, u22) => {
            const _22 = (h3 - e22) / (u22 - 1), p22 = (d3 - t3) / (u22 - 1), f22 = a22.length;
            for (let h4 = 0; h4 < u22; h4++) {
              const d4 = e22 + h4 * _22, u3 = t3 + h4 * p22;
              a22.emplaceBack(d4, u3);
              const m22 = this._globePoint(d4, u3, i22, o2, s2, r22, n22);
              c22.emplaceBack(m22[0], m22[1], m22[2]), l22.emplaceBack(f22 + h4);
            }
          }, d22 = e2.aj;
          h22(0, 0, d22, 0, 16), h22(d22, 0, d22, d22, 16), h22(d22, d22, 0, d22, 16), h22(0, d22, 0, 0, 16), this._tileDebugIndexBuffer = t22.createIndexBuffer(l22), this._tileDebugBuffer = t22.createVertexBuffer(a22, e2.bc.members), this._globeTileDebugBorderBuffer = t22.createVertexBuffer(c22, e2.bm.members), this._tileDebugSegments = e2.bd.simpleSegment(0, 0, a22.length, l22.length);
        }
        _makeGlobeTileDebugTextBuffer(t22, i22, o2, s2, r22, n22) {
          const a22 = e2.aj / 4, l22 = new e2.ba(), c22 = new e2.a_(), h22 = new e2.bl(), d22 = 25;
          c22.reserve(32), l22.reserve(d22), h22.reserve(d22);
          const u22 = (e22, t3) => d22 * e22 + t3;
          for (let e22 = 0; e22 < d22; e22++) {
            const t3 = e22 * a22;
            for (let e3 = 0; e3 < d22; e3++) {
              const c3 = e3 * a22;
              l22.emplaceBack(c3, t3);
              const d3 = this._globePoint(c3, t3, i22, o2, s2, r22, n22);
              h22.emplaceBack(d3[0], d3[1], d3[2]);
            }
          }
          for (let e22 = 0; e22 < 4; e22++) for (let t3 = 0; t3 < 4; t3++) {
            const i3 = u22(e22, t3), o3 = u22(e22, t3 + 1), s3 = u22(e22 + 1, t3), r3 = u22(e22 + 1, t3 + 1);
            c22.emplaceBack(i3, o3, s3), c22.emplaceBack(s3, o3, r3);
          }
          this._tileDebugTextIndexBuffer = t22.createIndexBuffer(c22), this._tileDebugTextBuffer = t22.createVertexBuffer(l22, e2.bc.members), this._globeTileDebugTextBuffer = t22.createVertexBuffer(h22, e2.bm.members), this._tileDebugTextSegments = e2.bd.simpleSegment(0, 0, d22, 32);
        }
        destroy(t22 = false) {
          for (const e22 in this.buckets) this.buckets[e22].destroy();
          this.buckets = {}, this.imageAtlas && (this.imageAtlas = null), this.lineAtlas && (this.lineAtlas = null), this.imageAtlasTexture && (this.imageAtlasTexture.destroy(), delete this.imageAtlasTexture), this.glyphAtlasTexture && (this.glyphAtlasTexture.destroy(), delete this.glyphAtlasTexture), this.lineAtlasTexture && (this.lineAtlasTexture.destroy(), delete this.lineAtlasTexture), this._tileBoundsBuffer && (this._tileBoundsBuffer.destroy(), this._tileBoundsIndexBuffer.destroy(), this._tileBoundsSegments.destroy(), this._tileBoundsBuffer = null), this._tileDebugBuffer && (this._tileDebugBuffer.destroy(), this._tileDebugSegments.destroy(), this._tileDebugBuffer = null), this._tileDebugIndexBuffer && (this._tileDebugIndexBuffer.destroy(), this._tileDebugIndexBuffer = null), this._globeTileDebugBorderBuffer && (this._globeTileDebugBorderBuffer.destroy(), this._globeTileDebugBorderBuffer = null), this._tileDebugTextBuffer && (this._tileDebugTextBuffer.destroy(), this._tileDebugTextSegments.destroy(), this._tileDebugTextIndexBuffer.destroy(), this._tileDebugTextBuffer = null), this._globeTileDebugTextBuffer && (this._globeTileDebugTextBuffer.destroy(), this._globeTileDebugTextBuffer = null), !t22 && this.texture && this.texture instanceof e2.T && (this.texture.destroy(), delete this.texture), this.hillshadeFBO && (this.hillshadeFBO.destroy(), delete this.hillshadeFBO), this.dem && delete this.dem, this.neighboringTiles && delete this.neighboringTiles, this.demTexture && (this.demTexture.destroy(), delete this.demTexture), this.rasterParticleState && (this.rasterParticleState.destroy(), delete this.rasterParticleState), this.latestFeatureIndex = null, this.state = "unloaded";
        }
      }
      e2.bp.setPbf(e2.bq);
      class Tt extends wt {
        constructor(e22, t22, i22, o2, s2) {
          super(e22, t22, i22, o2, s2), this._workQueue = [], this._fetchQueue = [], this._isHeaderLoaded = false;
        }
        getLayers() {
          return this._mrt ? Object.values(this._mrt.layers) : [];
        }
        getLayer(e22) {
          return this._mrt && this._mrt.getLayer(e22);
        }
        setTexture(t22, i22) {
          const o2 = i22.context, s2 = o2.gl;
          this.texture = this.texture || i22.getTileTexture(t22.width), this.texture && this.texture instanceof e2.T ? this.texture.update(t22, { premultiply: false }) : this.texture = new e2.T(o2, t22, s2.RGBA8, { premultiply: false });
        }
        flushQueues() {
          for (; this._workQueue.length; ) this._workQueue.pop()();
          for (; this._fetchQueue.length; ) this._fetchQueue.pop()();
        }
        fetchHeader(t22 = 16384, i22) {
          const o2 = this._mrt = new e2.bp(30), s2 = Object.assign({}, this.requestParams, { headers: { Range: "bytes=0-" + (t22 - 1) } });
          return this.entireBuffer = null, this.request = e2.br(s2, (e22, s3, r22, n22) => {
            if (e22) i22(e22);
            else try {
              const e3 = o2.getHeaderLength(s3);
              if (e3 > t22) return void (this.request = this.fetchHeader(e3, i22));
              o2.parseHeader(s3), this._isHeaderLoaded = true;
              let a22 = 0;
              for (const e4 of Object.values(o2.layers)) a22 = Math.max(a22, e4.dataIndex[e4.dataIndex.length - 1].lastByte);
              s3.byteLength >= a22 && (this.entireBuffer = s3), i22(null, this.entireBuffer || s3, r22, n22);
            } catch (e3) {
              i22(e3);
            }
          }), this.request;
        }
        fetchBand(t22, i22, o2) {
          const s2 = this._mrt;
          if (!this._isHeaderLoaded || !s2) return void o2(new Error("Tile header is not ready"));
          const r22 = this.actor;
          if (!r22) return void o2(new Error("Can't fetch tile band without an actor"));
          let n22;
          const a22 = (e22, s3) => {
            n22.complete(e22, s3), e22 ? o2(e22) : (this.updateTextureDescriptor(t22, i22), o2(null, this.textureDescriptor && this.textureDescriptor.img));
          }, l22 = (e22, t3) => {
            if (e22) return o2(e22);
            const i3 = r22.send("decodeRasterArray", { type: "raster-array", source: this.source, scope: this.scope, tileID: this.tileID, uid: this.uid, buffer: t3, task: n22 }, a22, void 0, true);
            this._workQueue.push(() => {
              i3 && i3.cancel(), n22.cancel();
            });
          }, c22 = s2.getLayer(t22);
          if (!c22) return void o2(new Error(`Unknown sourceLayer "${t22}"`));
          if (c22.hasDataForBand(i22)) return this.updateTextureDescriptor(t22, i22), void o2(null, this.textureDescriptor ? this.textureDescriptor.img : null);
          const h22 = c22.getDataRange([i22]);
          if (n22 = s2.createDecodingTask(h22), !n22 || n22.tasks.length) if (this.flushQueues(), this.entireBuffer) l22(null, this.entireBuffer.slice(h22.firstByte, h22.lastByte + 1));
          else {
            const t3 = Object.assign({}, this.requestParams, { headers: { Range: `bytes=${h22.firstByte}-${h22.lastByte}` } }), i3 = e2.br(t3, l22);
            this._fetchQueue.push(() => {
              i3.cancel(), n22.cancel();
            });
          }
          else o2(null);
        }
        updateNeeded(e22, t22) {
          return (!this.textureDescriptor || this.textureDescriptor.band !== t22 || this.textureDescriptor.layer !== e22) && "errored" !== this.state;
        }
        updateTextureDescriptor(t22, i22) {
          if (!this._mrt) return;
          const o2 = this._mrt.getLayer(t22);
          if (!o2 || !o2.hasBand(i22) || !o2.hasDataForBand(i22)) return;
          const { bytes: s2, tileSize: r22, buffer: n22, offset: a22, scale: l22 } = o2.getBandView(i22), c22 = r22 + 2 * n22, h22 = new e2.r({ width: c22, height: c22 }, s2), d22 = this.texture;
          d22 && d22 instanceof e2.T && d22.update(h22, { premultiply: false }), this.textureDescriptor = { layer: t22, band: i22, img: h22, buffer: n22, offset: a22, tileSize: r22, format: o2.pixelFormat, mix: [l22, 256 * l22, 65536 * l22, 16777216 * l22] };
        }
      }
      class Et {
        constructor(e22, t22) {
          this.max = e22, this.onRemove = t22, this.reset();
        }
        reset() {
          for (const e22 in this.data) for (const t22 of this.data[e22]) t22.timeout && clearTimeout(t22.timeout), this.onRemove(t22.value);
          return this.data = {}, this.order = [], this;
        }
        add(e22, t22, i22) {
          const o2 = e22.wrapped().key;
          void 0 === this.data[o2] && (this.data[o2] = []);
          const s2 = { value: t22, timeout: void 0 };
          if (void 0 !== i22 && (s2.timeout = setTimeout(() => {
            this.remove(e22, s2);
          }, i22)), this.data[o2].push(s2), this.order.push(o2), this.order.length > this.max) {
            const e3 = this._getAndRemoveByKey(this.order[0]);
            e3 && this.onRemove(e3);
          }
          return this;
        }
        has(e22) {
          return e22.wrapped().key in this.data;
        }
        getAndRemove(e22) {
          return this.has(e22) ? this._getAndRemoveByKey(e22.wrapped().key) : null;
        }
        _getAndRemoveByKey(e22) {
          const t22 = this.data[e22].shift();
          return t22.timeout && clearTimeout(t22.timeout), 0 === this.data[e22].length && delete this.data[e22], this.order.splice(this.order.indexOf(e22), 1), t22.value;
        }
        getByKey(e22) {
          const t22 = this.data[e22];
          return t22 ? t22[0].value : null;
        }
        get(e22) {
          return this.has(e22) ? this.data[e22.wrapped().key][0].value : null;
        }
        remove(e22, t22) {
          if (!this.has(e22)) return this;
          const i22 = e22.wrapped().key, o2 = void 0 === t22 ? 0 : this.data[i22].indexOf(t22), s2 = this.data[i22][o2];
          return this.data[i22].splice(o2, 1), s2.timeout && clearTimeout(s2.timeout), 0 === this.data[i22].length && delete this.data[i22], this.onRemove(s2.value), this.order.splice(this.order.indexOf(i22), 1), this;
        }
        setMaxSize(e22) {
          for (this.max = e22; this.order.length > this.max; ) {
            const e3 = this._getAndRemoveByKey(this.order[0]);
            e3 && this.onRemove(e3);
          }
          return this;
        }
        filter(e22) {
          const t22 = [];
          for (const i22 in this.data) for (const o2 of this.data[i22]) e22(o2.value) || t22.push(o2);
          for (const e3 of t22) this.remove(e3.value.tileID, e3);
        }
      }
      class St {
        constructor() {
          this.state = {}, this.stateChanges = {}, this.deletedStates = {};
        }
        updateState(t22, i22, o2) {
          const s2 = String(i22);
          if (this.stateChanges[t22] = this.stateChanges[t22] || {}, this.stateChanges[t22][s2] = this.stateChanges[t22][s2] || {}, e2.l(this.stateChanges[t22][s2], o2), null === this.deletedStates[t22]) {
            this.deletedStates[t22] = {};
            for (const e22 in this.state[t22]) e22 !== s2 && (this.deletedStates[t22][e22] = null);
          } else if (this.deletedStates[t22] && null === this.deletedStates[t22][s2]) {
            this.deletedStates[t22][s2] = {};
            for (const e22 in this.state[t22][s2]) o2[e22] || (this.deletedStates[t22][s2][e22] = null);
          } else for (const e22 in o2) this.deletedStates[t22] && this.deletedStates[t22][s2] && null === this.deletedStates[t22][s2][e22] && delete this.deletedStates[t22][s2][e22];
        }
        removeFeatureState(e22, t22, i22) {
          if (null === this.deletedStates[e22]) return;
          const o2 = String(t22);
          if (this.deletedStates[e22] = this.deletedStates[e22] || {}, i22 && void 0 !== t22) null !== this.deletedStates[e22][o2] && (this.deletedStates[e22][o2] = this.deletedStates[e22][o2] || {}, this.deletedStates[e22][o2][i22] = null);
          else if (void 0 !== t22) if (this.stateChanges[e22] && this.stateChanges[e22][o2]) for (i22 in this.deletedStates[e22][o2] = {}, this.stateChanges[e22][o2]) this.deletedStates[e22][o2][i22] = null;
          else this.deletedStates[e22][o2] = null;
          else this.deletedStates[e22] = null;
        }
        getState(t22, i22) {
          const o2 = this.state[t22] || {}, s2 = this.stateChanges[t22] || {}, r22 = this.deletedStates[t22];
          if (null === r22) return {};
          if (void 0 !== i22) {
            const t3 = String(i22), n3 = e2.l({}, o2[t3], s2[t3]);
            if (r22) {
              const e22 = r22[i22];
              if (null === e22) return {};
              for (const t4 in e22) delete n3[t4];
            }
            return n3;
          }
          const n22 = e2.l({}, o2, s2);
          if (r22) for (const e22 in r22) delete n22[e22];
          return n22;
        }
        initializeTileState(e22, t22) {
          e22.refreshFeatureState(t22);
        }
        coalesceChanges(t22, i22) {
          const o2 = {};
          for (const t3 in this.stateChanges) {
            this.state[t3] = this.state[t3] || {};
            const i3 = {};
            for (const o3 in this.stateChanges[t3]) this.state[t3][o3] || (this.state[t3][o3] = {}), e2.l(this.state[t3][o3], this.stateChanges[t3][o3]), i3[o3] = this.state[t3][o3];
            o2[t3] = i3;
          }
          for (const t3 in this.deletedStates) {
            this.state[t3] = this.state[t3] || {};
            const i3 = {};
            if (null === this.deletedStates[t3]) for (const e22 in this.state[t3]) i3[e22] = {}, this.state[t3][e22] = {};
            else for (const e22 in this.deletedStates[t3]) {
              if (null === this.deletedStates[t3][e22]) this.state[t3][e22] = {};
              else if (this.state[t3][e22]) for (const i4 of Object.keys(this.deletedStates[t3][e22])) delete this.state[t3][e22][i4];
              i3[e22] = this.state[t3][e22];
            }
            o2[t3] = o2[t3] || {}, e2.l(o2[t3], i3);
          }
          if (this.stateChanges = {}, this.deletedStates = {}, 0 !== Object.keys(o2).length) for (const e22 in t22) t22[e22].refreshFeatureState(i22);
        }
      }
      class It2 extends e2.E {
        constructor(e22, t22, i22) {
          super(), this.id = e22, this._onlySymbols = i22, t22.on("data", (e3) => {
            "source" === e3.dataType && "metadata" === e3.sourceDataType && (this._sourceLoaded = true), this._sourceLoaded && !this._paused && "source" === e3.dataType && "content" === e3.sourceDataType && (this.reload(), this.transform && this.update(this.transform));
          }), t22.on("error", () => {
            this._sourceErrored = true;
          }), this._source = t22, this._tiles = {}, this._cache = new Et(0, this._unloadTile.bind(this)), this._timers = {}, this._cacheTimers = {}, this._minTileCacheSize = t22.minTileCacheSize, this._maxTileCacheSize = t22.maxTileCacheSize, this._loadedParentTiles = {}, this.castsShadows = false, this.tileCoverLift = 0, this._coveredTiles = {}, this._shadowCasterTiles = {}, this._state = new St(), this._isRaster = "raster" === this._source.type || "raster-dem" === this._source.type || "raster-array" === this._source.type || "custom" === this._source.type && "raster" === this._source._dataType;
        }
        onAdd(e22) {
          this.map = e22, this._minTileCacheSize = void 0 === this._minTileCacheSize && e22 ? e22._minTileCacheSize : this._minTileCacheSize, this._maxTileCacheSize = void 0 === this._maxTileCacheSize && e22 ? e22._maxTileCacheSize : this._maxTileCacheSize;
        }
        loaded() {
          if (this._sourceErrored) return true;
          if (!this._sourceLoaded) return false;
          if (!this._source.loaded()) return false;
          for (const e22 in this._tiles) if (!this._tiles[e22].loaded()) return false;
          return true;
        }
        getSource() {
          return this._source;
        }
        pause() {
          this._paused = true;
        }
        resume() {
          if (!this._paused) return;
          const e22 = this._shouldReloadOnResume;
          this._paused = false, this._shouldReloadOnResume = false, e22 && this.reload(), this.transform && this.update(this.transform);
        }
        _loadTile(e22, t22) {
          return e22.isSymbolTile = this._onlySymbols, e22.isExtraShadowCaster = this._shadowCasterTiles[e22.tileID.key], this._source.loadTile(e22, t22);
        }
        _unloadTile(e22) {
          if (this._source.unloadTile) return this._source.unloadTile(e22);
        }
        _abortTile(e22) {
          if (this._source.abortTile) return this._source.abortTile(e22);
        }
        serialize() {
          return this._source.serialize();
        }
        prepare(e22) {
          this._source.prepare && this._source.prepare(), this._state.coalesceChanges(this._tiles, this.map ? this.map.painter : null);
          for (const t22 in this._tiles) {
            const i22 = this._tiles[t22];
            i22.upload(e22), i22.prepare(this.map.style.imageManager, this.map ? this.map.painter : null, this._source.scope);
          }
        }
        getIds() {
          return Object.values(this._tiles).map((e22) => e22.tileID).sort(Ct2).map((e22) => e22.key);
        }
        getRenderableIds(t22, i22) {
          const o2 = [];
          for (const e22 in this._tiles) this._isIdRenderable(+e22, t22, i22) && o2.push(this._tiles[e22]);
          return t22 ? o2.sort((t3, i3) => {
            const o3 = t3.tileID, s2 = i3.tileID, r22 = new e2.P(o3.canonical.x, o3.canonical.y)._rotate(this.transform.angle), n22 = new e2.P(s2.canonical.x, s2.canonical.y)._rotate(this.transform.angle);
            return o3.overscaledZ - s2.overscaledZ || n22.y - r22.y || n22.x - r22.x;
          }).map((e22) => e22.tileID.key) : o2.map((e22) => e22.tileID).sort(Ct2).map((e22) => e22.key);
        }
        hasRenderableParent(e22) {
          const t22 = this.findLoadedParent(e22, 0);
          return !!t22 && this._isIdRenderable(t22.tileID.key);
        }
        _isIdRenderable(e22, t22, i22) {
          return this._tiles[e22] && this._tiles[e22].hasData() && !this._coveredTiles[e22] && (t22 || !this._tiles[e22].holdingForFade()) && (i22 || !this._shadowCasterTiles[e22]);
        }
        reload() {
          if (this._paused) this._shouldReloadOnResume = true;
          else {
            this._cache.reset();
            for (const e22 in this._tiles) "errored" !== this._tiles[e22].state && this._reloadTile(+e22, "reloading");
          }
        }
        _reloadTile(e22, t22) {
          const i22 = this._tiles[e22];
          i22 && ("loading" !== i22.state && (i22.state = t22), this._loadTile(i22, this._tileLoaded.bind(this, i22, e22, t22)));
        }
        _tileLoaded(t22, i22, o2, s2) {
          if (s2) if (t22.state = "errored", 404 !== s2.status) this._source.fire(new e2.z(s2, { tile: t22 }));
          else {
            if (this._source.fire(new e2.A("data", { dataType: "source", sourceDataType: "error", sourceId: this._source.id, tile: t22 })), !(t22.tileID.key in this._loadedParentTiles)) return;
            if ("raster-dem" === this._source.type && this.usedForTerrain && this.map.painter.terrain) {
              const e22 = this.map.painter.terrain;
              this.update(this.transform, e22.getScaledDemTileSize(), true), e22.resetTileLookupCache(this.id);
            } else this.update(this.transform);
          }
          else t22.timeAdded = e2.q.now(), "expired" === o2 && (t22.refreshedUponExpiration = true), this._setTileReloadTimer(i22, t22), "raster-dem" === this._source.type && t22.dem && this._backfillDEM(t22), this._state.initializeTileState(t22, this.map ? this.map.painter : null), this._source.fire(new e2.A("data", { dataType: "source", tile: t22, coord: t22.tileID, sourceCacheId: this.id }));
        }
        _backfillDEM(e22) {
          const t22 = this.getRenderableIds();
          for (let o2 = 0; o2 < t22.length; o2++) {
            const s2 = t22[o2];
            if (e22.neighboringTiles && e22.neighboringTiles[s2]) {
              const t3 = this.getTileByID(s2);
              i22(e22, t3), i22(t3, e22);
            }
          }
          function i22(e3, t3) {
            if (!e3.dem || e3.dem.borderReady) return;
            e3.needsHillshadePrepare = true, e3.needsDEMTextureUpload = true;
            let i3 = t3.tileID.canonical.x - e3.tileID.canonical.x;
            const o2 = t3.tileID.canonical.y - e3.tileID.canonical.y, s2 = Math.pow(2, e3.tileID.canonical.z), r22 = t3.tileID.key;
            0 === i3 && 0 === o2 || Math.abs(o2) > 1 || (Math.abs(i3) > 1 && (1 === Math.abs(i3 + s2) ? i3 += s2 : 1 === Math.abs(i3 - s2) && (i3 -= s2)), t3.dem && e3.dem && (e3.dem.backfillBorder(t3.dem, i3, o2), e3.neighboringTiles && e3.neighboringTiles[r22] && (e3.neighboringTiles[r22].backfilled = true)));
          }
        }
        getTile(e22) {
          return this.getTileByID(e22.key);
        }
        getTileByID(e22) {
          return this._tiles[e22];
        }
        _retainLoadedChildren(e22, t22, i22, o2) {
          for (const s2 in this._tiles) {
            let r22 = this._tiles[s2];
            if (o2[s2] || !r22.hasData() || r22.tileID.overscaledZ <= t22 || r22.tileID.overscaledZ > i22) continue;
            let n22 = r22.tileID;
            for (; r22 && r22.tileID.overscaledZ > t22 + 1; ) {
              const e3 = r22.tileID.scaledTo(r22.tileID.overscaledZ - 1);
              r22 = this._tiles[e3.key], r22 && r22.hasData() && (n22 = e3);
            }
            let a22 = n22;
            for (; a22.overscaledZ > t22; ) if (a22 = a22.scaledTo(a22.overscaledZ - 1), e22[a22.key]) {
              o2[n22.key] = n22;
              break;
            }
          }
        }
        findLoadedParent(e22, t22) {
          if (e22.key in this._loadedParentTiles) {
            const i22 = this._loadedParentTiles[e22.key];
            return i22 && i22.tileID.overscaledZ >= t22 ? i22 : null;
          }
          for (let i22 = e22.overscaledZ - 1; i22 >= t22; i22--) {
            const t3 = e22.scaledTo(i22), o2 = this._getLoadedTile(t3);
            if (o2) return o2;
          }
        }
        _getLoadedTile(e22) {
          const t22 = this._tiles[e22.key];
          return t22 && t22.hasData() ? t22 : this._cache.getByKey(this._source.reparseOverscaled ? e22.wrapped().key : e22.canonical.key);
        }
        updateCacheSize(e22, t22) {
          t22 = t22 || this._source.tileSize;
          const i22 = Math.ceil(e22.width / t22) + 1, o2 = Math.ceil(e22.height / t22) + 1, s2 = Math.floor(i22 * o2 * 5), r22 = "number" == typeof this._minTileCacheSize ? Math.max(this._minTileCacheSize, s2) : s2, n22 = "number" == typeof this._maxTileCacheSize ? Math.min(this._maxTileCacheSize, r22) : r22;
          this._cache.setMaxSize(n22);
        }
        handleWrapJump(e22) {
          const t22 = Math.round((e22 - (void 0 === this._prevLng ? e22 : this._prevLng)) / 360);
          if (this._prevLng = e22, t22) {
            const e3 = {};
            for (const i22 in this._tiles) {
              const o2 = this._tiles[i22];
              o2.tileID = o2.tileID.unwrapTo(o2.tileID.wrap + t22), e3[o2.tileID.key] = o2;
            }
            this._tiles = e3;
            for (const e4 in this._timers) clearTimeout(this._timers[e4]), delete this._timers[e4];
            for (const e4 in this._tiles) this._setTileReloadTimer(+e4, this._tiles[e4]);
          }
        }
        update(t22, i22, o2, s2, r22) {
          if (this.transform = t22, !this._sourceLoaded || this._paused || this.transform.freezeTileCoverage) return;
          if (this.usedForTerrain && !o2) return;
          this.updateCacheSize(t22, i22), "globe" !== this.transform.projection.name && this.handleWrapJump(this.transform.center.lng), this._shadowCasterTiles = {}, this._coveredTiles = {};
          const n22 = "batched-model" === this._source.type;
          let a22, l22 = this._source.maxzoom;
          const c22 = this.map && this.map.painter ? this.map.painter._terrain : null;
          if (c22 && c22.sourceCache === this && c22.attenuationRange()) {
            const e22 = c22.attenuationRange()[0], t3 = Math.floor(e22) - Math.log2(c22.getDemUpscale());
            l22 > t3 && (l22 = t3);
          }
          if (this.used || this.usedForTerrain) {
            if (this._source.tileID) a22 = t22.getVisibleUnwrappedCoordinates(this._source.tileID).map((t3) => new e2.aM(t3.canonical.z, t3.wrap, t3.canonical.z, t3.canonical.x, t3.canonical.y));
            else if (0 !== this.tileCoverLift) {
              const s3 = t22.clone();
              s3.tileCoverLift = this.tileCoverLift, a22 = s3.coveringTiles({ tileSize: i22 || this._source.tileSize, minzoom: this._source.minzoom, maxzoom: l22, roundZoom: this._source.roundZoom && !o2, reparseOverscaled: this._source.reparseOverscaled, isTerrainDEM: this.usedForTerrain, calculateQuadrantVisibility: n22 }), this._source.minzoom <= 1 && "globe" === t22.projection.name && (a22.push(new e2.aM(1, 0, 1, 0, 0)), a22.push(new e2.aM(1, 0, 1, 1, 0)), a22.push(new e2.aM(1, 0, 1, 0, 1)), a22.push(new e2.aM(1, 0, 1, 1, 1)));
            } else if (a22 = t22.coveringTiles({ tileSize: i22 || this._source.tileSize, minzoom: this._source.minzoom, maxzoom: l22, roundZoom: this._source.roundZoom && !o2, reparseOverscaled: this._source.reparseOverscaled, isTerrainDEM: this.usedForTerrain, calculateQuadrantVisibility: n22 }), this._source.hasTile) {
              const e22 = this._source.hasTile.bind(this._source);
              a22 = a22.filter((t3) => e22(t3));
            }
          } else a22 = [];
          if (a22.length > 0 && "globe" !== this.transform.projection.name && !this.usedForTerrain && !Rt(this._source.type)) {
            const e22 = t22.coveringZoomLevel({ tileSize: i22 || this._source.tileSize, roundZoom: this._source.roundZoom && !o2 }), l3 = Math.min(e22, this._source.maxzoom);
            if (n22) {
              const e3 = t22.extendTileCover(a22, l3);
              for (const t3 of e3) a22.push(t3);
            } else if (r22) {
              const e3 = t22.extendTileCover(a22, l3, this.transform._camera.forward());
              for (const t3 of e3) a22.push(t3);
            } else if (this.castsShadows && s2) {
              const e3 = t22.extendTileCover(a22, l3, s2);
              for (const t3 of e3) this._shadowCasterTiles[t3.key] = true, a22.push(t3);
            }
          }
          const h22 = this._updateRetainedTiles(a22);
          if (Rt(this._source.type) && 0 !== a22.length) {
            const t3 = {}, i3 = {}, o3 = Object.keys(h22);
            for (const s4 of o3) {
              const o4 = h22[s4], r3 = this._tiles[s4];
              if (!r3 || r3.fadeEndTime && r3.fadeEndTime <= e2.q.now()) continue;
              const n3 = this.findLoadedParent(o4, Math.max(o4.overscaledZ - It2.maxOverzooming, this._source.minzoom));
              n3 && (this._addTile(n3.tileID), t3[n3.tileID.key] = n3.tileID), i3[s4] = o4;
            }
            const s3 = a22[a22.length - 1].overscaledZ;
            for (const e22 in this._tiles) {
              const t4 = this._tiles[e22];
              if (h22[e22] || !t4.hasData()) continue;
              let o4 = t4.tileID;
              for (; o4.overscaledZ > s3; ) {
                o4 = o4.scaledTo(o4.overscaledZ - 1);
                const s4 = this._tiles[o4.key];
                if (s4 && s4.hasData() && i3[o4.key]) {
                  h22[e22] = t4.tileID;
                  break;
                }
              }
            }
            for (const e22 in t3) h22[e22] || (this._coveredTiles[e22] = true, h22[e22] = t3[e22]);
          }
          for (const e22 in h22) this._tiles[e22].clearFadeHold();
          const d22 = e2.bs(this._tiles, h22);
          for (const e22 of d22) {
            const t3 = this._tiles[e22];
            t3.hasSymbolBuckets && !t3.holdingForFade() ? t3.setHoldDuration(this.map._fadeDuration) : t3.hasSymbolBuckets && !t3.symbolFadeFinished() || this._removeTile(+e22);
          }
          this._updateLoadedParentTileCache(), this._onlySymbols && this._source.afterUpdate && this._source.afterUpdate();
        }
        releaseSymbolFadeTiles() {
          for (const e22 in this._tiles) this._tiles[e22].holdingForFade() && this._removeTile(+e22);
        }
        _updateRetainedTiles(e22) {
          const t22 = {};
          if (0 === e22.length) return t22;
          const i22 = {}, o2 = e22.reduce((e3, t3) => Math.min(e3, t3.overscaledZ), 1 / 0), s2 = e22[0].overscaledZ, r22 = Math.max(s2 - It2.maxOverzooming, this._source.minzoom), n22 = Math.max(s2 + It2.maxUnderzooming, this._source.minzoom), a22 = {};
          for (const i3 of e22) {
            const e3 = this._addTile(i3);
            t22[i3.key] = i3, e3.hasData() || o2 < this._source.maxzoom && (a22[i3.key] = i3);
          }
          this._retainLoadedChildren(a22, o2, n22, t22);
          for (const o3 of e22) {
            let e3 = this._tiles[o3.key];
            if (e3.hasData()) continue;
            if (o3.canonical.z >= this._source.maxzoom) {
              const e4 = o3.children(this._source.maxzoom)[0], i3 = this.getTile(e4);
              if (i3 && i3.hasData()) {
                t22[e4.key] = e4;
                continue;
              }
            } else {
              const e4 = o3.children(this._source.maxzoom);
              if (t22[e4[0].key] && t22[e4[1].key] && t22[e4[2].key] && t22[e4[3].key]) continue;
            }
            let s3 = e3.wasRequested();
            for (let n3 = o3.overscaledZ - 1; n3 >= r22; --n3) {
              const r3 = o3.scaledTo(n3);
              if (i22[r3.key]) break;
              if (i22[r3.key] = true, e3 = this.getTile(r3), !e3 && s3 && (e3 = this._addTile(r3)), e3 && (t22[r3.key] = r3, s3 = e3.wasRequested(), e3.hasData())) break;
            }
          }
          return t22;
        }
        _updateLoadedParentTileCache() {
          this._loadedParentTiles = {};
          for (const e22 in this._tiles) {
            const t22 = [];
            let i22, o2 = this._tiles[e22].tileID;
            for (; o2.overscaledZ > 0; ) {
              if (o2.key in this._loadedParentTiles) {
                i22 = this._loadedParentTiles[o2.key];
                break;
              }
              t22.push(o2.key);
              const e3 = o2.scaledTo(o2.overscaledZ - 1);
              if (i22 = this._getLoadedTile(e3), i22) break;
              o2 = e3;
            }
            for (const e3 of t22) this._loadedParentTiles[e3] = i22;
          }
        }
        _addTile(t22) {
          let i22 = this._tiles[t22.key];
          if (i22) return true !== i22.isExtraShadowCaster || !!this._shadowCasterTiles[t22.key] || this._reloadTile(t22.key, "reloading"), i22;
          i22 = this._cache.getAndRemove(t22), i22 && (this._setTileReloadTimer(t22.key, i22), i22.tileID = t22, this._state.initializeTileState(i22, this.map ? this.map.painter : null), this._cacheTimers[t22.key] && (clearTimeout(this._cacheTimers[t22.key]), delete this._cacheTimers[t22.key], this._setTileReloadTimer(t22.key, i22)));
          const o2 = Boolean(i22);
          if (!o2) {
            const e22 = this.map ? this.map.painter : null, o3 = this._source.tileSize * t22.overscaleFactor();
            i22 = "raster-array" === this._source.type ? new Tt(t22, o3, this.transform.tileZoom, e22, this._isRaster) : new wt(t22, o3, this.transform.tileZoom, e22, this._isRaster), this._loadTile(i22, this._tileLoaded.bind(this, i22, t22.key, i22.state));
          }
          return i22.uses++, this._tiles[t22.key] = i22, o2 || this._source.fire(new e2.A("dataloading", { tile: i22, coord: i22.tileID, dataType: "source" })), i22;
        }
        _setTileReloadTimer(e22, t22) {
          e22 in this._timers && (clearTimeout(this._timers[e22]), delete this._timers[e22]);
          const i22 = t22.getExpiryTimeout();
          i22 && (this._timers[e22] = setTimeout(() => {
            this._reloadTile(e22, "expired"), delete this._timers[e22];
          }, i22));
        }
        _removeTile(e22) {
          const t22 = this._tiles[e22];
          t22 && (t22.uses--, delete this._tiles[e22], this._timers[e22] && (clearTimeout(this._timers[e22]), delete this._timers[e22]), t22.uses > 0 || (t22.hasData() && "reloading" !== t22.state || "empty" === t22.state ? this._cache.add(t22.tileID, t22, t22.getExpiryTimeout()) : (t22.aborted = true, this._abortTile(t22), this._unloadTile(t22))));
        }
        clearTiles() {
          this._shouldReloadOnResume = false, this._paused = false;
          for (const e22 in this._tiles) this._removeTile(+e22);
          this._source._clear && this._source._clear(), this._cache.reset(), this.map && this.usedForTerrain && this.map.painter.terrain && this.map.painter.terrain.resetTileLookupCache(this.id);
        }
        tilesIn(t22, i22, o2) {
          const s2 = [], r22 = this.transform;
          if (!r22) return s2;
          const n22 = "globe" === r22.projection.name, a22 = e2.ay(r22.center.lng);
          for (const l22 in this._tiles) {
            const c22 = this._tiles[l22];
            if (o2 && c22.clearQueryDebugViz(), c22.holdingForFade()) continue;
            let h22;
            if (n22) {
              const t3 = c22.tileID.canonical;
              if (0 === t3.z) {
                const i3 = [Math.abs(e2.aD(a22, ...Dt2(t3, -1)) - a22), Math.abs(e2.aD(a22, ...Dt2(t3, 1)) - a22)];
                h22 = [0, 2 * i3.indexOf(Math.min(...i3)) - 1];
              } else {
                const i3 = [Math.abs(e2.aD(a22, ...Dt2(t3, -1)) - a22), Math.abs(e2.aD(a22, ...Dt2(t3, 0)) - a22), Math.abs(e2.aD(a22, ...Dt2(t3, 1)) - a22)];
                h22 = [i3.indexOf(Math.min(...i3)) - 1];
              }
            } else h22 = [0];
            for (const e22 of h22) {
              const o3 = t22.containsTile(c22, r22, i22, e22);
              o3 && s2.push(o3);
            }
          }
          return s2;
        }
        getShadowCasterCoordinates() {
          return this._getRenderableCoordinates(false, true);
        }
        getVisibleCoordinates(e22) {
          return this._getRenderableCoordinates(e22);
        }
        _getRenderableCoordinates(e22, t22) {
          const i22 = this.getRenderableIds(e22, t22).map((e3) => this._tiles[e3].tileID), o2 = "globe" === this.transform.projection.name;
          for (const e3 of i22) e3.projMatrix = this.transform.calculateProjMatrix(e3.toUnwrapped()), e3.expandedProjMatrix = o2 ? this.transform.calculateProjMatrix(e3.toUnwrapped(), false, true) : e3.projMatrix;
          return i22;
        }
        sortCoordinatesByDistance(e22) {
          const t22 = e22.slice(), i22 = this.transform._camera.position, o2 = this.transform._camera.forward(), s2 = {};
          for (const e3 of t22) {
            const t3 = 1 / (1 << e3.canonical.z);
            s2[e3.key] = ((e3.canonical.x + 0.5) * t3 + e3.wrap - i22[0]) * o2[0] + ((e3.canonical.y + 0.5) * t3 - i22[1]) * o2[1] - i22[2] * o2[2];
          }
          return t22.sort((e3, t3) => s2[e3.key] - s2[t3.key]), t22;
        }
        hasTransition() {
          if (this._source.hasTransition()) return true;
          if (Rt(this._source.type)) for (const t22 in this._tiles) {
            const i22 = this._tiles[t22];
            if (void 0 !== i22.fadeEndTime && i22.fadeEndTime >= e2.q.now()) return true;
          }
          return false;
        }
        setFeatureState(e22, t22, i22) {
          this._state.updateState(e22 = e22 || "_geojsonTileLayer", t22, i22);
        }
        removeFeatureState(e22, t22, i22) {
          this._state.removeFeatureState(e22 = e22 || "_geojsonTileLayer", t22, i22);
        }
        getFeatureState(e22, t22) {
          return this._state.getState(e22 = e22 || "_geojsonTileLayer", t22);
        }
        setDependencies(e22, t22, i22) {
          const o2 = this._tiles[e22];
          o2 && o2.setDependencies(t22, i22);
        }
        reloadTilesForDependencies(e22, t22) {
          for (const i22 in this._tiles) this._tiles[i22].hasDependency(e22, t22) && this._reloadTile(+i22, "reloading");
          this._cache.filter((i22) => !i22.hasDependency(e22, t22));
        }
        _preloadTiles(t22, i22) {
          if (!this._sourceLoaded) {
            const e22 = () => {
              this._sourceLoaded && (this._source.off("data", e22), this._preloadTiles(t22, i22));
            };
            return void this._source.on("data", e22);
          }
          const o2 = /* @__PURE__ */ new Map(), s2 = Array.isArray(t22) ? t22 : [t22], r22 = this.map.painter.terrain, n22 = this.usedForTerrain && r22 ? r22.getScaledDemTileSize() : this._source.tileSize;
          for (const e22 of s2) {
            const t3 = e22.coveringTiles({ tileSize: n22, minzoom: this._source.minzoom, maxzoom: this._source.maxzoom, roundZoom: this._source.roundZoom && !this.usedForTerrain, reparseOverscaled: this._source.reparseOverscaled, isTerrainDEM: this.usedForTerrain });
            for (const e3 of t3) o2.set(e3.key, e3);
            this.usedForTerrain && e22.updateElevation(false);
          }
          const a22 = Array.from(o2.values());
          e2.bt(a22, (e22, t3) => {
            const i3 = new wt(e22, this._source.tileSize * e22.overscaleFactor(), this.transform.tileZoom, this.map.painter, this._isRaster);
            this._loadTile(i3, (e3) => {
              "raster-dem" === this._source.type && i3.dem && this._backfillDEM(i3), t3(e3, i3);
            });
          }, i22);
        }
      }
      function Ct2(e22, t22) {
        const i22 = Math.abs(2 * e22.wrap) - +(e22.wrap < 0), o2 = Math.abs(2 * t22.wrap) - +(t22.wrap < 0);
        return e22.overscaledZ - t22.overscaledZ || o2 - i22 || t22.canonical.y - e22.canonical.y || t22.canonical.x - e22.canonical.x;
      }
      function Rt(e22) {
        return "raster" === e22 || "image" === e22 || "video" === e22 || "custom" === e22;
      }
      function Dt2(e22, t22) {
        const i22 = 1 << e22.z;
        return [e22.x / i22 + t22, (e22.x + 1) / i22 + t22];
      }
      It2.maxOverzooming = 10, It2.maxUnderzooming = 3;
      class At {
        constructor(e22) {
          this.style = e22, this.layersGotHidden = false, this.layers = [];
        }
        processLayersChanged() {
          this.layers = [];
          const e22 = false, t22 = false;
          for (const i22 in this.style._mergedLayers) {
            const o2 = this.style._mergedLayers[i22];
            if ("fill-extrusion" === o2.type) this.layers.push({ layer: o2, visible: e22, visibilityChanged: t22 });
            else if ("model" === o2.type) {
              const i3 = this.style.getLayerSource(o2);
              i3 && "batched-model" === i3.type && this.layers.push({ layer: o2, visible: e22, visibilityChanged: t22 });
            }
          }
        }
        onNewFrame(e22) {
          this.layersGotHidden = false;
          for (const t22 of this.layers) {
            const i22 = t22.layer;
            let o2 = false;
            "fill-extrusion" === i22.type ? o2 = !i22.isHidden(e22) && i22.paint.get("fill-extrusion-opacity") > 0 : "model" === i22.type && (o2 = !i22.isHidden(e22) && i22.paint.get("model-opacity").constantOr(1) > 0), this.layersGotHidden = this.layersGotHidden || !o2 && t22.visible, t22.visible = o2;
          }
        }
        updateZOffset(e22, t22) {
          this.currentBuildingBuckets = [];
          for (const e3 of this.layers) {
            const i3 = e3.layer, o2 = this.style.getLayerSourceCache(i3);
            let s2 = 1;
            "fill-extrusion" === i3.type && (s2 = e3.visible ? i3.paint.get("fill-extrusion-vertical-scale") : 0);
            let r22 = o2 ? o2.getTile(t22) : null;
            if (!r22 && o2 && t22.canonical.z > o2.getSource().minzoom) {
              let e4 = t22.scaledTo(Math.min(o2.getSource().maxzoom, t22.overscaledZ - 1));
              for (; e4.overscaledZ >= o2.getSource().minzoom && (r22 = o2.getTile(e4), !r22 && 0 !== e4.overscaledZ); ) e4 = e4.scaledTo(e4.overscaledZ - 1);
            }
            this.currentBuildingBuckets.push({ bucket: r22 ? r22.getBucket(i3) : null, tileID: r22 ? r22.tileID : t22, verticalScale: s2 });
          }
          e22.hasAnyZOffset = false;
          let i22 = false;
          for (let o2 = 0; o2 < e22.symbolInstances.length; o2++) {
            const s2 = e22.symbolInstances.get(o2), r22 = s2.zOffset, n22 = this._getHeightAtTileOffset(t22, s2.tileAnchorX, s2.tileAnchorY);
            s2.zOffset = n22 !== Number.NEGATIVE_INFINITY ? n22 : r22, i22 || r22 === s2.zOffset || (i22 = true), e22.hasAnyZOffset || 0 === s2.zOffset || (e22.hasAnyZOffset = true);
          }
          i22 && (e22.zOffsetBuffersNeedUpload = true, e22.zOffsetSortDirty = true);
        }
        _mapCoordToOverlappingTile(t22, i22, o2, s2) {
          let r22 = i22, n22 = o2;
          if (t22.canonical.z !== s2.canonical.z) {
            const a22 = s2.canonical, l22 = 1 / (1 << t22.canonical.z - a22.z);
            r22 = (i22 + t22.canonical.x * e2.aj) * l22 - a22.x * e2.aj | 0, n22 = (o2 + t22.canonical.y * e2.aj) * l22 - a22.y * e2.aj | 0;
          }
          return { tileX: r22, tileY: n22 };
        }
        _getHeightAtTileOffset(e22, t22, i22) {
          let o2, s2;
          for (let r22 = 0; r22 < this.layers.length; ++r22) {
            if ("fill-extrusion" !== this.layers[r22].layer.type) continue;
            const { bucket: n22, tileID: a22, verticalScale: l22 } = this.currentBuildingBuckets[r22];
            if (!n22) continue;
            const { tileX: c22, tileY: h22 } = this._mapCoordToOverlappingTile(e22, t22, i22, a22), d22 = n22.getHeightAtTileCoord(c22, h22);
            d22 && void 0 !== d22.height && (d22.hidden ? o2 = d22.height : s2 = Math.max(d22.height * l22, s2 || 0));
          }
          if (void 0 !== s2) return s2;
          for (let s3 = 0; s3 < this.layers.length; ++s3) {
            const r22 = this.layers[s3];
            if ("model" !== r22.layer.type || !r22.visible) continue;
            const { bucket: n22, tileID: a22 } = this.currentBuildingBuckets[s3];
            if (!n22) continue;
            const { tileX: l22, tileY: c22 } = this._mapCoordToOverlappingTile(e22, t22, i22, a22), h22 = n22.getHeightAtTileCoord(l22, c22);
            if (h22 && !h22.hidden) return void 0 === h22.height && void 0 !== o2 ? Math.min(h22.maxHeight, o2) * h22.verticalScale : h22.height ? h22.height * h22.verticalScale : Number.NEGATIVE_INFINITY;
          }
          return this.layersGotHidden ? 0 : Number.NEGATIVE_INFINITY;
        }
      }
      function Lt(t22, i22) {
        const o2 = {};
        for (const e22 in t22) "ref" !== e22 && (o2[e22] = t22[e22]);
        return e2.bu.forEach((e22) => {
          e22 in i22 && (o2[e22] = i22[e22]);
        }), o2;
      }
      function Pt(e22) {
        e22 = e22.slice();
        const t22 = /* @__PURE__ */ Object.create(null);
        for (let i22 = 0; i22 < e22.length; i22++) t22[e22[i22].id] = e22[i22];
        for (let i22 = 0; i22 < e22.length; i22++) "ref" in e22[i22] && (e22[i22] = Lt(e22[i22], t22[e22[i22].ref]));
        return e22;
      }
      const zt = { setStyle: "setStyle", addLayer: "addLayer", removeLayer: "removeLayer", setPaintProperty: "setPaintProperty", setLayoutProperty: "setLayoutProperty", setSlot: "setSlot", setFilter: "setFilter", addSource: "addSource", removeSource: "removeSource", setGeoJSONSourceData: "setGeoJSONSourceData", setLayerZoomRange: "setLayerZoomRange", setLayerProperty: "setLayerProperty", setCenter: "setCenter", setZoom: "setZoom", setBearing: "setBearing", setPitch: "setPitch", setSprite: "setSprite", setGlyphs: "setGlyphs", setTransition: "setTransition", setLight: "setLight", setTerrain: "setTerrain", setFog: "setFog", setSnow: "setSnow", setRain: "setRain", setCamera: "setCamera", setLights: "setLights", setProjection: "setProjection", addImport: "addImport", removeImport: "removeImport", updateImport: "updateImport", addIconset: "addIconset", removeIconset: "removeIconset" };
      function Mt(e22, t22, i22) {
        i22.push({ command: zt.addSource, args: [e22, t22[e22]] });
      }
      function Ot2(e22, t22, i22) {
        t22.push({ command: zt.removeSource, args: [e22] }), i22[e22] = true;
      }
      function Ft2(e22, t22, i22, o2) {
        Ot2(e22, i22, o2), Mt(e22, t22, i22);
      }
      function Bt(t22, i22, o2) {
        let s2;
        for (s2 in t22[o2]) if (t22[o2].hasOwnProperty(s2) && "data" !== s2 && !e2.bv(t22[o2][s2], i22[o2][s2])) return false;
        for (s2 in i22[o2]) if (i22[o2].hasOwnProperty(s2) && "data" !== s2 && !e2.bv(t22[o2][s2], i22[o2][s2])) return false;
        return true;
      }
      function kt(t22, i22, o2, s2, r22, n22) {
        let a22;
        for (a22 in i22 = i22 || {}, t22 = t22 || {}) t22.hasOwnProperty(a22) && (e2.bv(t22[a22], i22[a22]) || o2.push({ command: n22, args: [s2, a22, i22[a22], r22] }));
        for (a22 in i22) i22.hasOwnProperty(a22) && !t22.hasOwnProperty(a22) && (e2.bv(t22[a22], i22[a22]) || o2.push({ command: n22, args: [s2, a22, i22[a22], r22] }));
      }
      function Nt(e22) {
        return e22.id;
      }
      function Ut2(e22, t22) {
        return e22[t22.id] = t22, e22;
      }
      class jt {
        constructor(e22, t22) {
          this.reset(e22, t22);
        }
        reset(e22, t22) {
          this.points = e22 || [], this._distances = [0];
          for (let e3 = 1; e3 < this.points.length; e3++) this._distances[e3] = this._distances[e3 - 1] + this.points[e3].dist(this.points[e3 - 1]);
          this.length = this._distances[this._distances.length - 1], this.padding = Math.min(t22 || 0, 0.5 * this.length), this.paddedLength = this.length - 2 * this.padding;
        }
        lerp(t22) {
          if (1 === this.points.length) return this.points[0];
          t22 = e2.aD(t22, 0, 1);
          let i22 = 1, o2 = this._distances[i22];
          const s2 = t22 * this.paddedLength + this.padding;
          for (; o2 < s2 && i22 < this._distances.length; ) o2 = this._distances[++i22];
          const r22 = i22 - 1, n22 = this._distances[r22], a22 = o2 - n22, l22 = a22 > 0 ? (s2 - n22) / a22 : 0;
          return this.points[r22].mult(1 - l22).add(this.points[i22].mult(l22));
        }
      }
      class Vt2 {
        constructor(e22, t22, i22) {
          const o2 = this.boxCells = [], s2 = this.circleCells = [];
          this.xCellCount = Math.ceil(e22 / i22), this.yCellCount = Math.ceil(t22 / i22);
          for (let e3 = 0; e3 < this.xCellCount * this.yCellCount; e3++) o2.push([]), s2.push([]);
          this.circleKeys = [], this.boxKeys = [], this.bboxes = [], this.circles = [], this.width = e22, this.height = t22, this.xScale = this.xCellCount / e22, this.yScale = this.yCellCount / t22, this.boxUid = 0, this.circleUid = 0;
        }
        keysLength() {
          return this.boxKeys.length + this.circleKeys.length;
        }
        insert(e22, t22, i22, o2, s2) {
          this._forEachCell(t22, i22, o2, s2, this._insertBoxCell, this.boxUid++), this.boxKeys.push(e22), this.bboxes.push(t22), this.bboxes.push(i22), this.bboxes.push(o2), this.bboxes.push(s2);
        }
        insertCircle(e22, t22, i22, o2) {
          this._forEachCell(t22 - o2, i22 - o2, t22 + o2, i22 + o2, this._insertCircleCell, this.circleUid++), this.circleKeys.push(e22), this.circles.push(t22), this.circles.push(i22), this.circles.push(o2);
        }
        _insertBoxCell(e22, t22, i22, o2, s2, r22) {
          this.boxCells[s2].push(r22);
        }
        _insertCircleCell(e22, t22, i22, o2, s2, r22) {
          this.circleCells[s2].push(r22);
        }
        _query(e22, t22, i22, o2, s2, r22) {
          if (i22 < 0 || e22 > this.width || o2 < 0 || t22 > this.height) return !s2 && [];
          const n22 = [];
          if (e22 <= 0 && t22 <= 0 && this.width <= i22 && this.height <= o2) {
            if (s2) return true;
            for (let e3 = 0; e3 < this.boxKeys.length; e3++) n22.push({ key: this.boxKeys[e3], x1: this.bboxes[4 * e3], y1: this.bboxes[4 * e3 + 1], x2: this.bboxes[4 * e3 + 2], y2: this.bboxes[4 * e3 + 3] });
            for (let e3 = 0; e3 < this.circleKeys.length; e3++) {
              const t3 = this.circles[3 * e3], i3 = this.circles[3 * e3 + 1], o3 = this.circles[3 * e3 + 2];
              n22.push({ key: this.circleKeys[e3], x1: t3 - o3, y1: i3 - o3, x2: t3 + o3, y2: i3 + o3 });
            }
            return r22 ? n22.filter(r22) : n22;
          }
          return this._forEachCell(e22, t22, i22, o2, this._queryCell, n22, { hitTest: s2, seenUids: { box: {}, circle: {} } }, r22), s2 ? n22.length > 0 : n22;
        }
        _queryCircle(e22, t22, i22, o2, s2) {
          const r22 = e22 - i22, n22 = e22 + i22, a22 = t22 - i22, l22 = t22 + i22;
          if (n22 < 0 || r22 > this.width || l22 < 0 || a22 > this.height) return !o2 && [];
          const c22 = [];
          return this._forEachCell(r22, a22, n22, l22, this._queryCellCircle, c22, { hitTest: o2, circle: { x: e22, y: t22, radius: i22 }, seenUids: { box: {}, circle: {} } }, s2), o2 ? c22.length > 0 : c22;
        }
        query(e22, t22, i22, o2, s2) {
          return this._query(e22, t22, i22, o2, false, s2);
        }
        hitTest(e22, t22, i22, o2, s2) {
          return this._query(e22, t22, i22, o2, true, s2);
        }
        hitTestCircle(e22, t22, i22, o2) {
          return this._queryCircle(e22, t22, i22, true, o2);
        }
        _queryCell(e22, t22, i22, o2, s2, r22, n22, a22) {
          const l22 = n22.seenUids, c22 = this.boxCells[s2];
          if (null !== c22) {
            const s3 = this.bboxes;
            for (const h3 of c22) if (!l22.box[h3]) {
              l22.box[h3] = true;
              const c3 = 4 * h3;
              if (e22 <= s3[c3 + 2] && t22 <= s3[c3 + 3] && i22 >= s3[c3 + 0] && o2 >= s3[c3 + 1] && (!a22 || a22(this.boxKeys[h3]))) {
                if (n22.hitTest) return r22.push(true), true;
                r22.push({ key: this.boxKeys[h3], x1: s3[c3], y1: s3[c3 + 1], x2: s3[c3 + 2], y2: s3[c3 + 3] });
              }
            }
          }
          const h22 = this.circleCells[s2];
          if (null !== h22) {
            const s3 = this.circles;
            for (const c3 of h22) if (!l22.circle[c3]) {
              l22.circle[c3] = true;
              const h3 = 3 * c3;
              if (this._circleAndRectCollide(s3[h3], s3[h3 + 1], s3[h3 + 2], e22, t22, i22, o2) && (!a22 || a22(this.circleKeys[c3]))) {
                if (n22.hitTest) return r22.push(true), true;
                {
                  const e3 = s3[h3], t3 = s3[h3 + 1], i3 = s3[h3 + 2];
                  r22.push({ key: this.circleKeys[c3], x1: e3 - i3, y1: t3 - i3, x2: e3 + i3, y2: t3 + i3 });
                }
              }
            }
          }
        }
        _queryCellCircle(e22, t22, i22, o2, s2, r22, n22, a22) {
          const l22 = n22.circle, c22 = n22.seenUids, h22 = this.boxCells[s2];
          if (null !== h22) {
            const e3 = this.bboxes;
            for (const t3 of h22) if (!c22.box[t3]) {
              c22.box[t3] = true;
              const i3 = 4 * t3;
              if (this._circleAndRectCollide(l22.x, l22.y, l22.radius, e3[i3 + 0], e3[i3 + 1], e3[i3 + 2], e3[i3 + 3]) && (!a22 || a22(this.boxKeys[t3]))) return r22.push(true), true;
            }
          }
          const d22 = this.circleCells[s2];
          if (null !== d22) {
            const e3 = this.circles;
            for (const t3 of d22) if (!c22.circle[t3]) {
              c22.circle[t3] = true;
              const i3 = 3 * t3;
              if (this._circlesCollide(e3[i3], e3[i3 + 1], e3[i3 + 2], l22.x, l22.y, l22.radius) && (!a22 || a22(this.circleKeys[t3]))) return r22.push(true), true;
            }
          }
        }
        _forEachCell(e22, t22, i22, o2, s2, r22, n22, a22) {
          const l22 = this._convertToXCellCoord(e22), c22 = this._convertToYCellCoord(t22), h22 = this._convertToXCellCoord(i22), d22 = this._convertToYCellCoord(o2);
          for (let u22 = l22; u22 <= h22; u22++) for (let l3 = c22; l3 <= d22; l3++) if (s2.call(this, e22, t22, i22, o2, this.xCellCount * l3 + u22, r22, n22, a22)) return;
        }
        _convertToXCellCoord(e22) {
          return Math.max(0, Math.min(this.xCellCount - 1, Math.floor(e22 * this.xScale)));
        }
        _convertToYCellCoord(e22) {
          return Math.max(0, Math.min(this.yCellCount - 1, Math.floor(e22 * this.yScale)));
        }
        _circlesCollide(e22, t22, i22, o2, s2, r22) {
          const n22 = o2 - e22, a22 = s2 - t22, l22 = i22 + r22;
          return l22 * l22 > n22 * n22 + a22 * a22;
        }
        _circleAndRectCollide(e22, t22, i22, o2, s2, r22, n22) {
          const a22 = (r22 - o2) / 2, l22 = Math.abs(e22 - (o2 + a22));
          if (l22 > a22 + i22) return false;
          const c22 = (n22 - s2) / 2, h22 = Math.abs(t22 - (s2 + c22));
          if (h22 > c22 + i22) return false;
          if (l22 <= a22 || h22 <= c22) return true;
          const d22 = l22 - a22, u22 = h22 - c22;
          return d22 * d22 + u22 * u22 <= i22 * i22;
        }
      }
      const Gt = { unknown: 0, flipRequired: 1, flipNotRequired: 2 }, qt2 = Math.tan(85 * Math.PI / 180);
      function Zt2(t22, i22, o2, s2, r22, n22, a22) {
        const l22 = e2.bz();
        if (o2) if ("globe" === n22.name) {
          const t3 = e2.bA(r22, i22);
          e2.az(l22, l22, t3);
        } else {
          const t3 = e2.bB([], a22);
          l22[0] = t3[0], l22[1] = t3[1], l22[4] = t3[2], l22[5] = t3[3], s2 || e2.by(l22, l22, r22.angle);
        }
        else e2.az(l22, r22.labelPlaneMatrix, t22);
        return l22;
      }
      function Ht2(e22, t22, i22, o2, s2, r22, n22) {
        const a22 = Zt2(e22, t22, i22, o2, s2, r22, n22);
        return "globe" === r22.name && i22 || (a22[2] = a22[6] = a22[10] = a22[14] = 0), a22;
      }
      function Wt2(t22, i22, o2, s2, r22, n22, a22) {
        if (o2) {
          if ("globe" === n22.name) {
            const l22 = Zt2(t22, i22, o2, s2, r22, n22, a22);
            return e2.bi(l22, l22), e2.az(l22, t22, l22), l22;
          }
          {
            const i3 = e2.bw(t22), o3 = e2.bx([]);
            return o3[0] = a22[0], o3[1] = a22[1], o3[4] = a22[2], o3[5] = a22[3], e2.az(i3, i3, o3), s2 || e2.by(i3, i3, -r22.angle), i3;
          }
        }
        return r22.glCoordMatrix;
      }
      function $t2(t22, i22, o2, s2) {
        const r22 = [t22, i22, o2, 1];
        o2 ? e2.aA(r22, r22, s2) : ri(r22, r22, s2);
        const n22 = r22[3];
        return r22[0] /= n22, r22[1] /= n22, r22[2] /= n22, r22;
      }
      function Xt2(e22, t22) {
        return Math.min(0.5 + e22 / t22 * 0.5, 1.5);
      }
      function Yt(e22, t22) {
        const i22 = e22[0] / e22[3], o2 = e22[1] / e22[3];
        return i22 >= -t22[0] && i22 <= t22[0] && o2 >= -t22[1] && o2 <= t22[1];
      }
      function Kt2(t22, i22, o2, s2, r22, n22, a22, l22, c22, h22) {
        const d22 = o2.transform, u22 = s2 ? t22.textSizeData : t22.iconSizeData, _22 = e2.bH(u22, o2.transform.zoom), p22 = "globe" === d22.projection.name, f22 = [256 / o2.width * 2 + 1, 256 / o2.height * 2 + 1], m22 = s2 ? t22.text.dynamicLayoutVertexArray : t22.icon.dynamicLayoutVertexArray;
        m22.clear();
        let g22 = null;
        p22 && (g22 = s2 ? t22.text.globeExtVertexArray : t22.icon.globeExtVertexArray);
        const v22 = t22.lineVertexArray, y22 = s2 ? t22.text.placedSymbolArray : t22.icon.placedSymbolArray, x22 = o2.transform.width / o2.transform.height;
        let b22, w22 = false;
        for (let s3 = 0; s3 < y22.length; s3++) {
          const p3 = y22.get(s3), { numGlyphs: T2, writingMode: E22 } = p3;
          if (E22 !== e2.bI.vertical || w22 || b22 === e2.bI.horizontal || (w22 = true), b22 = E22, (p3.hidden || E22 === e2.bI.vertical) && !w22) {
            si(T2, m22);
            continue;
          }
          w22 = false;
          const S2 = new e2.P(p3.tileAnchorX, p3.tileAnchorY);
          let { x: I2, y: C22, z: R22 } = d22.projection.projectTilePoint(S2.x, S2.y, h22.canonical);
          if (c22) {
            const [e22, t3, i3] = c22(S2);
            I2 += e22, C22 += t3, R22 += i3;
          }
          const D22 = [I2, C22, R22, 1];
          if (e2.aA(D22, D22, i22), !Yt(D22, f22)) {
            si(T2, m22);
            continue;
          }
          const A22 = D22[3], L22 = Xt2(o2.transform.getCameraToCenterDistance(d22.projection), A22), P22 = e2.bJ(u22, _22, p3), z22 = a22 ? P22 / L22 : P22 * L22, M22 = $t2(I2, C22, R22, r22);
          if (M22[3] <= 0) {
            si(T2, m22);
            continue;
          }
          let O2 = {};
          const F2 = e2.al(t22.layers[0].layout.get("text-max-angle")), B22 = Math.cos(F2), k22 = a22 ? null : c22, N22 = ei(p3, z22, false, l22, i22, r22, n22, t22.glyphOffsetArray, v22, m22, g22, M22, S2, O2, x22, k22, d22.projection, h22, a22, B22);
          w22 = N22.useVertical, k22 && N22.needsFlipping && (O2 = {}), (N22.notEnoughRoom || w22 || N22.needsFlipping && ei(p3, z22, true, l22, i22, r22, n22, t22.glyphOffsetArray, v22, m22, g22, M22, S2, O2, x22, k22, d22.projection, h22, a22, B22).notEnoughRoom) && si(T2, m22);
        }
        s2 ? (t22.text.dynamicLayoutVertexBuffer.updateData(m22), g22 && t22.text.globeExtVertexBuffer && t22.text.globeExtVertexBuffer.updateData(g22)) : (t22.icon.dynamicLayoutVertexBuffer.updateData(m22), g22 && t22.icon.globeExtVertexBuffer && t22.icon.globeExtVertexBuffer.updateData(g22));
      }
      function Jt2(e22, t22, i22, o2, s2, r22, n22, a22, l22, c22, h22, d22, u22, _22, p22, f22, m22) {
        const { lineStartIndex: g22, glyphStartIndex: v22, segment: y22 } = a22, x22 = v22 + a22.numGlyphs, b22 = g22 + a22.lineLength, w22 = t22.getoffsetX(v22), T2 = t22.getoffsetX(x22 - 1), E22 = oi(e22 * w22, i22, o2, s2, r22, n22, y22, g22, b22, l22, c22, h22, d22, u22, true, _22, p22, f22, m22);
        if (!E22) return null;
        const S2 = oi(e22 * T2, i22, o2, s2, r22, n22, y22, g22, b22, l22, c22, h22, d22, u22, true, _22, p22, f22, m22);
        return S2 ? { first: E22, last: S2 } : null;
      }
      function Qt2(t22, i22, o2, s2) {
        return t22 === e2.bI.horizontal && Math.abs(s2) > Math.abs(o2) ? { useVertical: true } : t22 === e2.bI.vertical ? s2 > 0 ? { needsFlipping: true } : null : i22 !== Gt.unknown && function(e22, t3) {
          return 0 === e22 || Math.abs(t3 / e22) > qt2;
        }(o2, s2) ? i22 === Gt.flipRequired ? { needsFlipping: true } : null : o2 < 0 ? { needsFlipping: true } : null;
      }
      function ei(t22, i22, o2, s2, r22, n22, a22, l22, c22, h22, d22, u22, _22, p22, f22, m22, g22, v22, y22, x22) {
        const b22 = i22 / 24, w22 = t22.lineOffsetX * b22, T2 = t22.lineOffsetY * b22, { lineStartIndex: E22, glyphStartIndex: S2, numGlyphs: I2, segment: C22, writingMode: R22, flipState: D22 } = t22, A22 = E22 + t22.lineLength, L22 = (t3) => {
          if (d22) {
            const [i4, o4, s4] = t3.up, r3 = h22.length;
            e2.bK(d22, r3 + 0, i4, o4, s4), e2.bK(d22, r3 + 1, i4, o4, s4), e2.bK(d22, r3 + 2, i4, o4, s4), e2.bK(d22, r3 + 3, i4, o4, s4);
          }
          const [i3, o3, s3] = t3.point;
          e2.bL(h22, i3, o3, s3, t3.angle);
        };
        if (I2 > 1) {
          const e22 = Jt2(b22, l22, w22, T2, o2, u22, _22, t22, c22, n22, p22, m22, false, g22, v22, y22, x22);
          if (!e22) return { notEnoughRoom: true };
          if (s2 && !o2) {
            let [i3, o3, s3] = e22.first.point, [r3, n3, l3] = e22.last.point;
            [i3, o3] = $t2(i3, o3, s3, a22), [r3, n3] = $t2(r3, n3, l3, a22);
            const c3 = Qt2(R22, D22, (r3 - i3) * f22, n3 - o3);
            if (t22.flipState = c3 && c3.needsFlipping ? Gt.flipRequired : Gt.flipNotRequired, c3) return c3;
          }
          L22(e22.first);
          for (let e3 = S2 + 1; e3 < S2 + I2 - 1; e3++) {
            const t3 = oi(b22 * l22.getoffsetX(e3), w22, T2, o2, u22, _22, C22, E22, A22, c22, n22, p22, m22, false, false, g22, v22, y22, x22);
            if (!t3) return h22.length -= 4 * (e3 - S2), { notEnoughRoom: true };
            L22(t3);
          }
          L22(e22.last);
        } else {
          if (s2 && !o2) {
            const i4 = $t2(_22.x, _22.y, 0, r22), o3 = E22 + C22 + 1, s3 = new e2.P(c22.getx(o3), c22.gety(o3)), n3 = $t2(s3.x, s3.y, 0, r22), a3 = n3[3] > 0 ? n3 : ii(_22, s3, i4, 1, r22, void 0, g22, v22.canonical), l3 = Qt2(R22, D22, (a3[0] - i4[0]) * f22, a3[1] - i4[1]);
            if (t22.flipState = l3 && l3.needsFlipping ? Gt.flipRequired : Gt.flipNotRequired, l3) return l3;
          }
          const i3 = oi(b22 * l22.getoffsetX(S2), w22, T2, o2, u22, _22, C22, E22, A22, c22, n22, p22, m22, false, false, g22, v22, y22, x22);
          if (!i3) return { notEnoughRoom: true };
          L22(i3);
        }
        return {};
      }
      function ti(e22, t22, i22, o2, s2) {
        const { x: r22, y: n22, z: a22 } = o2.projectTilePoint(e22.x, e22.y, t22);
        if (!s2) return $t2(r22, n22, a22, i22);
        const [l22, c22, h22] = s2(e22);
        return $t2(r22 + l22, n22 + c22, a22 + h22, i22);
      }
      function ii(t22, i22, o2, s2, r22, n22, a22, l22) {
        const c22 = ti(t22.sub(i22)._unit()._add(t22), l22, r22, a22, n22);
        return e2.at(c22, o2, c22), e2.au(c22, c22), e2.bF(c22, o2, c22, s2);
      }
      function oi(t22, i22, o2, s2, r22, n22, a22, l22, c22, h22, d22, u22, _22, p22, f22, m22, g22, v22, y22) {
        const x22 = s2 ? t22 - i22 : t22 + i22;
        let b22 = x22 > 0 ? 1 : -1, w22 = 0;
        s2 && (b22 *= -1, w22 = Math.PI), b22 < 0 && (w22 += Math.PI);
        let T2 = l22 + a22 + (b22 > 0 ? 0 : 1) | 0, E22 = r22, S2 = r22, I2 = 0, C22 = 0;
        const R22 = Math.abs(x22), D22 = [], A22 = [];
        let L22 = n22, P22 = L22, z22 = e2.bC([]);
        const M22 = () => ii(P22, L22, S2, R22 - I2 + 1, d22, _22, m22, g22.canonical);
        for (; I2 + C22 <= R22; ) {
          if (T2 += b22, T2 < l22 || T2 >= c22) return null;
          if (S2 = E22, P22 = L22, D22.push(S2), p22 && A22.push(P22), L22 = new e2.P(h22.getx(T2), h22.gety(T2)), E22 = u22[T2], !E22) {
            const e22 = ti(L22, g22.canonical, d22, m22, _22);
            E22 = e22[3] > 0 ? u22[T2] = e22 : M22();
          }
          I2 += C22;
          const t3 = e2.at([], E22, S2), i3 = e2.bD(S2, E22);
          if (o2 && i3 > 0 && C22 > 0 && e2.bE(z22, t3) / (C22 * i3) < y22) return null;
          C22 = i3, z22 = t3;
        }
        f22 && _22 && (u22[T2] && (E22 = M22(), C22 = e2.bD(S2, E22), z22 = e2.at([], E22, S2)), u22[T2] = E22);
        const O2 = (R22 - I2) / C22, F2 = L22.sub(P22)._mult(O2)._add(P22), B22 = e2.bF([], S2, z22, O2);
        let k22 = [0, 0, 1], N22 = z22[0], U22 = z22[1];
        if (v22 && (k22 = m22.upVector(g22.canonical, F2.x, F2.y), 0 !== k22[0] || 0 !== k22[1] || 1 !== k22[2])) {
          const t3 = [k22[2], 0, -k22[0]], i3 = e2.bG([], k22, t3);
          e2.au(t3, t3), e2.au(i3, i3), N22 = e2.bE(z22, t3), U22 = e2.bE(z22, i3);
        }
        if (o2) {
          const t3 = e2.bG([], k22, z22);
          e2.au(t3, t3), e2.bF(B22, B22, t3, o2 * b22);
        }
        const j22 = w22 + Math.atan2(U22, N22);
        return D22.push(B22), p22 && A22.push(F2), { point: B22, angle: j22, path: D22, tilePath: A22, up: k22 };
      }
      function si(e22, t22) {
        const i22 = t22.length, o2 = i22 + 4 * e22;
        t22.resize(o2), t22.float32.fill(-1 / 0, 4 * i22, 4 * o2);
      }
      function ri(e22, t22, i22) {
        const o2 = t22[0], s2 = t22[1];
        return e22[0] = i22[0] * o2 + i22[4] * s2 + i22[12], e22[1] = i22[1] * o2 + i22[5] * s2 + i22[13], e22[3] = i22[3] * o2 + i22[7] * s2 + i22[15], e22;
      }
      const ni = 100;
      class ai {
        constructor(e22, t22, i22 = new Vt2(e22.width + 200, e22.height + 200, 25), o2 = new Vt2(e22.width + 200, e22.height + 200, 25)) {
          this.transform = e22, this.grid = i22, this.ignoredGrid = o2, this.pitchfactor = Math.cos(e22._pitch) * e22.cameraToCenterDistance, this.screenRightBoundary = e22.width + ni, this.screenBottomBoundary = e22.height + ni, this.gridRightBoundary = e22.width + 200, this.gridBottomBoundary = e22.height + 200, this.fogState = t22;
        }
        placeCollisionBox(e22, t22, i22, o2, s2, r22, n22, a22) {
          let l22 = i22.projectedAnchorX, c22 = i22.projectedAnchorY, h22 = i22.projectedAnchorZ;
          const d22 = i22.elevation, u22 = i22.tileID, _22 = e22.getProjection();
          if (d22 && u22) {
            const [e3, t3, o3] = _22.upVector(u22.canonical, i22.tileAnchorX, i22.tileAnchorY), s3 = _22.upVectorScale(u22.canonical, this.transform.center.lat, this.transform.worldSize).metersToTile;
            l22 += e3 * d22 * s3, c22 += t3 * d22 * s3, h22 += o3 * d22 * s3;
          }
          const p22 = this.projectAndGetPerspectiveRatio(n22, l22, c22, h22, i22.tileID, "globe" === _22.name || !!d22 || this.transform.pitch > 0, _22), f22 = r22 * p22.perspectiveRatio, m22 = (i22.x1 * t22 + o2.x - i22.padding) * f22 + p22.point.x, g22 = (i22.y1 * t22 + o2.y - i22.padding) * f22 + p22.point.y, v22 = (i22.x2 * t22 + o2.x + i22.padding) * f22 + p22.point.x, y22 = (i22.y2 * t22 + o2.y + i22.padding) * f22 + p22.point.y, x22 = p22.perspectiveRatio <= 0.55 || p22.occluded;
          return !this.isInsideGrid(m22, g22, v22, y22) || !s2 && this.grid.hitTest(m22, g22, v22, y22, a22) || x22 ? { box: [], offscreen: false, occluded: p22.occluded } : { box: [m22, g22, v22, y22], offscreen: this.isOffscreen(m22, g22, v22, y22), occluded: false };
        }
        placeCollisionCircles(t22, i22, o2, s2, r22, n22, a22, l22, c22, h22, d22, u22, _22, p22, f22) {
          const m22 = [], g22 = this.transform.elevation, v22 = t22.getProjection(), y22 = g22 ? g22.getAtTileOffsetFunc(f22, this.transform.center.lat, this.transform.worldSize, v22) : null, x22 = new e2.P(o2.tileAnchorX, o2.tileAnchorY);
          let { x: b22, y: w22, z: T2 } = v22.projectTilePoint(x22.x, x22.y, f22.canonical);
          if (y22) {
            const [e22, t3, i3] = y22(x22);
            b22 += e22, w22 += t3, T2 += i3;
          }
          const E22 = "globe" === v22.name, S2 = this.projectAndGetPerspectiveRatio(a22, b22, w22, T2, f22, E22 || !!g22 || this.transform.pitch > 0, v22), { perspectiveRatio: I2 } = S2, C22 = (d22 ? n22 / I2 : n22 * I2) / e2.bO, R22 = $t2(b22, w22, T2, l22), D22 = o2.lineOffsetX * C22, A22 = o2.lineOffsetY * C22, L22 = e2.al(t22.layers[0].layout.get("text-max-angle")), P22 = Math.cos(L22), z22 = S2.signedDistanceFromCamera > 0 ? Jt2(C22, r22, D22, A22, false, R22, x22, o2, s2, l22, {}, g22 && !d22 ? y22 : null, d22 && !!g22, v22, f22, d22, P22) : null;
          let M22 = false, O2 = false, F2 = true;
          if (z22 && !S2.occluded) {
            const t3 = 0.5 * _22 * I2 + p22, o3 = new e2.P(-100, -100), s3 = new e2.P(this.screenRightBoundary, this.screenBottomBoundary), r3 = new jt(), { first: n3, last: a3 } = z22, l3 = n3.path.length;
            let d3 = [];
            for (let e22 = l3 - 1; e22 >= 1; e22--) d3.push(n3.path[e22]);
            for (let e22 = 1; e22 < a3.path.length; e22++) d3.push(a3.path[e22]);
            const f3 = 2.5 * t3;
            c22 && (d3 = d3.map(([e22, t4, i3], o4) => (y22 && !E22 && (i3 = y22(o4 < l3 - 1 ? n3.tilePath[l3 - 1 - o4] : a3.tilePath[o4 - l3 + 2])[2]), $t2(e22, t4, i3, c22))), d3.some((e22) => e22[3] <= 0) && (d3 = []));
            let g3 = [];
            if (d3.length > 0) {
              let t4 = 1 / 0, i3 = -1 / 0, r4 = 1 / 0, n4 = -1 / 0;
              for (const e22 of d3) t4 = Math.min(t4, e22[0]), r4 = Math.min(r4, e22[1]), i3 = Math.max(i3, e22[0]), n4 = Math.max(n4, e22[1]);
              i3 >= o3.x && t4 <= s3.x && n4 >= o3.y && r4 <= s3.y && (g3 = [d3.map((t5) => new e2.P(t5[0], t5[1]))], (t4 < o3.x || i3 > s3.x || r4 < o3.y || n4 > s3.y) && (g3 = e2.bM(g3, o3.x, o3.y, s3.x, s3.y)));
            }
            for (const e22 of g3) {
              r3.reset(e22, 0.25 * t3);
              let o4 = 0;
              o4 = r3.length <= 0.5 * t3 ? 1 : Math.ceil(r3.paddedLength / f3) + 1;
              for (let e3 = 0; e3 < o4; e3++) {
                const s4 = e3 / Math.max(o4 - 1, 1), n4 = r3.lerp(s4), a4 = n4.x + ni, l4 = n4.y + ni;
                m22.push(a4, l4, t3, 0);
                const c3 = a4 - t3, d4 = l4 - t3, _3 = a4 + t3, p3 = l4 + t3;
                if (F2 = F2 && this.isOffscreen(c3, d4, _3, p3), O2 = O2 || this.isInsideGrid(c3, d4, _3, p3), !i22 && this.grid.hitTestCircle(a4, l4, t3, u22) && (M22 = true, !h22)) return { circles: [], offscreen: false, collisionDetected: M22, occluded: false };
              }
            }
          }
          return { circles: !h22 && M22 || !O2 ? [] : m22, offscreen: F2, collisionDetected: M22, occluded: S2.occluded };
        }
        queryRenderedSymbols(t22) {
          if (0 === t22.length || 0 === this.grid.keysLength() && 0 === this.ignoredGrid.keysLength()) return {};
          const i22 = [];
          let o2 = 1 / 0, s2 = 1 / 0, r22 = -1 / 0, n22 = -1 / 0;
          for (const a3 of t22) {
            const t3 = new e2.P(a3.x + ni, a3.y + ni);
            o2 = Math.min(o2, t3.x), s2 = Math.min(s2, t3.y), r22 = Math.max(r22, t3.x), n22 = Math.max(n22, t3.y), i22.push(t3);
          }
          const a22 = this.grid.query(o2, s2, r22, n22).concat(this.ignoredGrid.query(o2, s2, r22, n22)), l22 = {}, c22 = {};
          for (const t3 of a22) {
            const o3 = t3.key;
            if (void 0 === l22[o3.bucketInstanceId] && (l22[o3.bucketInstanceId] = {}), l22[o3.bucketInstanceId][o3.featureIndex]) continue;
            const s3 = [new e2.P(t3.x1, t3.y1), new e2.P(t3.x2, t3.y1), new e2.P(t3.x2, t3.y2), new e2.P(t3.x1, t3.y2)];
            e2.bN(i22, s3) && (l22[o3.bucketInstanceId][o3.featureIndex] = true, void 0 === c22[o3.bucketInstanceId] && (c22[o3.bucketInstanceId] = []), c22[o3.bucketInstanceId].push(o3.featureIndex));
          }
          return c22;
        }
        insertCollisionBox(e22, t22, i22, o2, s2) {
          (t22 ? this.ignoredGrid : this.grid).insert({ bucketInstanceId: i22, featureIndex: o2, collisionGroupID: s2 }, e22[0], e22[1], e22[2], e22[3]);
        }
        insertCollisionCircles(e22, t22, i22, o2, s2) {
          const r22 = t22 ? this.ignoredGrid : this.grid, n22 = { bucketInstanceId: i22, featureIndex: o2, collisionGroupID: s2 };
          for (let t3 = 0; t3 < e22.length; t3 += 4) r22.insertCircle(n22, e22[t3], e22[t3 + 1], e22[t3 + 2]);
        }
        projectAndGetPerspectiveRatio(t22, i22, o2, s2, r22, n22, a22) {
          const l22 = [i22, o2, s2, 1];
          let c22 = false;
          if (s2 || this.transform.pitch > 0) {
            if (e2.aA(l22, l22, t22), this.fogState && r22 && "globe" !== a22.name) {
              const t3 = function(t4, i3, o3, s3, r3, n3) {
                const a3 = n3.calculateFogTileMatrix(r3), l3 = [i3, o3, s3];
                return e2.ad(l3, l3, a3), Be(t4, e2.ae(l3), n3.pitch, n3._fov);
              }(this.fogState, i22, o2, s2, r22.toUnwrapped(), this.transform);
              c22 = t3 > 0.9;
            }
          } else ri(l22, l22, t22);
          const h22 = l22[3];
          return { point: new e2.P((l22[0] / h22 + 1) / 2 * this.transform.width + ni, (-l22[1] / h22 + 1) / 2 * this.transform.height + ni), perspectiveRatio: Math.min(0.5 + this.transform.getCameraToCenterDistance(a22) / h22 * 0.5, 1.5), signedDistanceFromCamera: h22, occluded: n22 && l22[2] > h22 || c22 };
        }
        isOffscreen(e22, t22, i22, o2) {
          return i22 < ni || e22 >= this.screenRightBoundary || o2 < ni || t22 > this.screenBottomBoundary;
        }
        isInsideGrid(e22, t22, i22, o2) {
          return i22 >= 0 && e22 < this.gridRightBoundary && o2 >= 0 && t22 < this.gridBottomBoundary;
        }
        getViewportMatrix() {
          const t22 = e2.bx([]);
          return e2.bo(t22, t22, [-100, -100, 0]), t22;
        }
      }
      function li(t22, i22, o2) {
        const s2 = i22.createTileMatrix(t22, t22.worldSize, o2.toUnwrapped());
        return e2.az(new Float32Array(16), t22.projMatrix, s2);
      }
      function ci(e22, t22, i22) {
        if (t22.projection.name === i22.projection.name) return e22.projMatrix;
        const o2 = i22.clone();
        return o2.setProjection(t22.projection), li(o2, t22.getProjection(), e22);
      }
      function hi(e22, t22, i22) {
        return t22.name === i22.projection.name ? e22.projMatrix : li(i22, t22, e22);
      }
      class di {
        constructor(e22, t22, i22, o2) {
          this.opacity = e22 ? Math.max(0, Math.min(1, e22.opacity + (e22.placed ? t22 : -t22))) : o2 && i22 ? 1 : 0, this.placed = i22;
        }
        isHidden() {
          return 0 === this.opacity && !this.placed;
        }
      }
      class ui {
        constructor(e22, t22, i22, o2, s2, r22 = false) {
          this.text = new di(e22 ? e22.text : null, t22, i22, s2), this.icon = new di(e22 ? e22.icon : null, t22, o2, s2), this.clipped = r22;
        }
        isHidden() {
          return this.text.isHidden() && this.icon.isHidden();
        }
      }
      class _i2 {
        constructor(e22, t22, i22, o2 = false) {
          this.text = e22, this.icon = t22, this.skipFade = i22, this.clipped = o2;
        }
      }
      class pi {
        constructor() {
          this.invProjMatrix = e2.bz(), this.viewportMatrix = e2.bz(), this.circles = [];
        }
      }
      class fi {
        constructor(e22, t22, i22, o2, s2) {
          this.bucketInstanceId = e22, this.featureIndex = t22, this.sourceLayerIndex = i22, this.bucketIndex = o2, this.tileID = s2;
        }
      }
      class mi {
        constructor(e22) {
          this.crossSourceCollisions = e22, this.maxGroupID = 0, this.collisionGroups = {};
        }
        get(e22) {
          if (this.crossSourceCollisions) return { ID: 0, predicate: null };
          if (!this.collisionGroups[e22]) {
            const t22 = ++this.maxGroupID;
            this.collisionGroups[e22] = { ID: t22, predicate: (e3) => e3.collisionGroupID === t22 };
          }
          return this.collisionGroups[e22];
        }
      }
      function gi(t22, i22, o2, s2, r22) {
        const { horizontalAlign: n22, verticalAlign: a22 } = e2.bV(t22), l22 = -(n22 - 0.5) * i22, c22 = -(a22 - 0.5) * o2, h22 = e2.bU(t22, s2);
        return new e2.P(l22 + h22[0] * r22, c22 + h22[1] * r22);
      }
      function vi(t22, i22, o2, s2, r22) {
        const n22 = new e2.P(t22, i22);
        return o2 && n22._rotate(s2 ? r22 : -r22), n22;
      }
      class yi {
        constructor(e22, t22, i22, o2, s2, r22) {
          this.transform = e22.clone(), this.projection = e22.projection.name, this.collisionIndex = new ai(this.transform, s2), this.buildingIndex = r22, this.placements = {}, this.opacities = {}, this.variableOffsets = {}, this.stale = false, this.commitTime = 0, this.fadeDuration = t22, this.retainedQueryData = {}, this.collisionGroups = new mi(i22), this.collisionCircleArrays = {}, this.prevPlacement = o2, o2 && (o2.prevPlacement = void 0), this.placedOrientations = {};
        }
        getBucketParts(t22, i22, o2, s2, r22 = 1) {
          const n22 = o2.getBucket(i22), a22 = o2.latestFeatureIndex;
          if (!n22 || !a22 || i22.fqid !== n22.layerIds[0]) return;
          const l22 = n22.layers[0].layout, c22 = n22.layers[0].paint, h22 = o2.collisionBoxArray, d22 = Math.pow(2, this.transform.zoom - o2.tileID.overscaledZ), u22 = o2.tileSize / e2.aj, _22 = o2.tileID.toUnwrapped();
          this.transform.setProjection(n22.projection);
          const p22 = (f22 = o2.tileID, m22 = n22.getProjection(), g22 = this.transform, m22.name === this.projection ? g22.calculateProjMatrix(f22.toUnwrapped()) : li(g22, m22, f22));
          var f22, m22, g22;
          const v22 = "map" === l22.get("text-pitch-alignment"), y22 = "map" === l22.get("text-rotation-alignment");
          i22.compileFilter(i22.options);
          const x22 = i22.dynamicFilter(), b22 = i22.dynamicFilterNeedsFeature(), w22 = this.transform.calculatePixelsToTileUnitsMatrix(o2), T2 = Ht2(p22, o2.tileID.canonical, v22, y22, this.transform, n22.getProjection(), w22);
          let E22 = null;
          if (v22) {
            const t3 = Wt2(p22, o2.tileID.canonical, v22, y22, this.transform, n22.getProjection(), w22);
            E22 = e2.az([], this.transform.labelPlaneMatrix, t3);
          }
          let S2 = null;
          x22 && o2.latestFeatureIndex && (S2 = { unwrappedTileID: _22, dynamicFilter: x22, dynamicFilterNeedsFeature: b22 }), this.retainedQueryData[n22.bucketInstanceId] = new fi(n22.bucketInstanceId, a22, n22.sourceLayerIndex, n22.index, o2.tileID);
          const [I2, C22] = n22.layers[0].layout.get("text-size-scale-range"), R22 = e2.aD(r22, I2, C22), [D22, A22] = l22.get("icon-size-scale-range"), L22 = e2.aD(r22, D22, A22), P22 = { bucket: n22, layout: l22, paint: c22, posMatrix: p22, textLabelPlaneMatrix: T2, labelToScreenMatrix: E22, clippingData: S2, scale: d22, textPixelRatio: u22, holdingForFade: o2.holdingForFade(), collisionBoxArray: h22, partiallyEvaluatedTextSize: e2.bH(n22.textSizeData, this.transform.zoom, R22), partiallyEvaluatedIconSize: e2.bH(n22.iconSizeData, this.transform.zoom, L22), collisionGroup: this.collisionGroups.get(n22.sourceID), latestFeatureIndex: o2.latestFeatureIndex };
          if (s2) for (const e22 of n22.sortKeyRanges) {
            const { sortKey: i3, symbolInstanceStart: o3, symbolInstanceEnd: s3 } = e22;
            t22.push({ sortKey: i3, symbolInstanceStart: o3, symbolInstanceEnd: s3, parameters: P22 });
          }
          else t22.push({ symbolInstanceStart: 0, symbolInstanceEnd: n22.symbolInstances.length, parameters: P22 });
        }
        attemptAnchorPlacement(e22, t22, i22, o2, s2, r22, n22, a22, l22, c22, h22, d22, u22, _22, p22, f22, m22, g22) {
          const { textOffset0: v22, textOffset1: y22, crossTileID: x22 } = d22, b22 = [v22, y22], w22 = gi(e22, i22, o2, b22, s2), T2 = this.collisionIndex.placeCollisionBox(_22, s2, t22, vi(w22.x, w22.y, r22, n22, this.transform.angle), h22, a22, l22, c22.predicate);
          if (f22) {
            const e3 = _22.getSymbolInstanceIconSize(g22, this.transform.zoom, d22.placedIconSymbolIndex);
            if (0 === this.collisionIndex.placeCollisionBox(_22, e3, f22, vi(w22.x, w22.y, r22, n22, this.transform.angle), h22, a22, l22, c22.predicate).box.length) return;
          }
          if (T2.box.length > 0) {
            let t3;
            return this.prevPlacement && this.prevPlacement.variableOffsets[x22] && this.prevPlacement.placements[x22] && this.prevPlacement.placements[x22].text && (t3 = this.prevPlacement.variableOffsets[x22].anchor), this.variableOffsets[x22] = { textOffset: b22, width: i22, height: o2, anchor: e22, textScale: s2, prevAnchor: t3 }, this.markUsedJustification(_22, e22, d22, p22), _22.allowVerticalPlacement && (this.markUsedOrientation(_22, p22, d22), this.placedOrientations[x22] = p22), { shift: w22, placedGlyphBoxes: T2 };
          }
        }
        placeLayerBucketPart(t22, i22, o2, s2, r22 = 1) {
          const { bucket: n22, layout: a22, paint: l22, posMatrix: c22, textLabelPlaneMatrix: h22, labelToScreenMatrix: d22, clippingData: u22, textPixelRatio: _22, holdingForFade: p22, collisionBoxArray: f22, partiallyEvaluatedTextSize: m22, partiallyEvaluatedIconSize: g22, collisionGroup: v22, latestFeatureIndex: y22 } = t22.parameters, x22 = a22.get("text-optional"), b22 = a22.get("icon-optional"), w22 = a22.get("text-allow-overlap"), T2 = a22.get("icon-allow-overlap"), E22 = "map" === a22.get("text-rotation-alignment"), S2 = "map" === a22.get("text-pitch-alignment"), I2 = l22.get("symbol-z-offset"), C22 = "sea" === a22.get("symbol-elevation-reference"), [R22, D22] = a22.get("text-size-scale-range"), [A22, L22] = a22.get("icon-size-scale-range"), P22 = e2.aD(r22, R22, D22), z22 = e2.aD(r22, A22, L22);
          this.transform.setProjection(n22.projection);
          let M22 = w22 && (T2 || !n22.hasIconData() || b22), O2 = T2 && (w22 || !n22.hasTextData() || x22);
          const F2 = !I2.isConstant();
          !n22.collisionArrays && f22 && n22.deserializeCollisionBoxes(f22), o2 && s2 && n22.updateCollisionDebugBuffers(this.transform.zoom, f22, P22, z22);
          const B22 = (t3, s3, l3) => {
            const { crossTileID: f3, numVerticalGlyphVertices: R3 } = t3;
            let D3 = null;
            if (u22 && u22.dynamicFilterNeedsFeature || F2) {
              const e22 = this.retainedQueryData[n22.bucketInstanceId];
              D3 = y22.loadFeature({ featureIndex: t3.featureIndex, bucketIndex: e22.bucketIndex, sourceLayerIndex: e22.sourceLayerIndex, layoutVertexArrayOffset: 0 });
            }
            if (u22 && !(0, u22.dynamicFilter)({ zoom: this.transform.zoom, pitch: this.transform.pitch }, D3, this.retainedQueryData[n22.bucketInstanceId].tileID.canonical, new e2.P(t3.tileAnchorX, t3.tileAnchorY), this.transform.calculateDistanceTileData(u22.unwrappedTileID))) return this.placements[f3] = new _i2(false, false, false, true), void i22.add(f3);
            const A3 = I2.evaluate(D3, {});
            if (i22.has(f3)) return;
            if (p22) return void (this.placements[f3] = new _i2(false, false, false));
            let L3 = false, P3 = false, z3 = true, B3 = false, k22 = false, N22 = null, U22 = { box: null, offscreen: null, occluded: null }, j22 = { box: null, offscreen: null, occluded: null }, V2 = null, G2 = null, q22 = null, Z2 = 0, H2 = 0, W2 = 0;
            l3.textFeatureIndex ? Z2 = l3.textFeatureIndex : t3.useRuntimeCollisionCircles && (Z2 = t3.featureIndex), l3.verticalTextFeatureIndex && (H2 = l3.verticalTextFeatureIndex);
            const $2 = (e22) => {
              e22.tileID = this.retainedQueryData[n22.bucketInstanceId].tileID;
              const i3 = this.transform.elevation;
              e22.elevation = C22 ? A3 : A3 + (i3 ? i3.getAtTileOffset(e22.tileID, e22.tileAnchorX, e22.tileAnchorY) : 0), e22.elevation += t3.zOffset;
            }, X22 = l3.textBox;
            if (X22) {
              $2(X22);
              const i3 = (i4) => {
                let o4 = e2.bI.horizontal;
                if (n22.allowVerticalPlacement && !i4 && this.prevPlacement) {
                  const e22 = this.prevPlacement.placedOrientations[f3];
                  e22 && (this.placedOrientations[f3] = e22, o4 = e22, this.markUsedOrientation(n22, o4, t3));
                }
                return o4;
              }, o3 = (t4, i4) => {
                if (n22.allowVerticalPlacement && R3 > 0 && l3.verticalTextBox) {
                  for (const o4 of n22.writingModes) if (o4 === e2.bI.vertical ? (U22 = i4(), j22 = U22) : U22 = t4(), U22 && U22.box && U22.box.length) break;
                } else U22 = t4();
              };
              if (a22.get("text-variable-anchor")) {
                let r3 = a22.get("text-variable-anchor");
                if (this.prevPlacement && this.prevPlacement.variableOffsets[f3]) {
                  const e22 = this.prevPlacement.variableOffsets[f3];
                  r3.indexOf(e22.anchor) > 0 && (r3 = r3.filter((t4) => t4 !== e22.anchor), r3.unshift(e22.anchor));
                }
                const h3 = (e22, i4, o4) => {
                  const a3 = n22.getSymbolInstanceTextSize(m22, t3, this.transform.zoom, s3), l4 = (e22.x2 - e22.x1) * a3 + 2 * e22.padding, h4 = (e22.y2 - e22.y1) * a3 + 2 * e22.padding, d4 = t3.hasIconTextFit && !T2 ? i4 : null;
                  d4 && $2(d4);
                  let u3 = { box: [], offscreen: false, occluded: false };
                  const p3 = w22 ? 2 * r3.length : r3.length;
                  for (let i5 = 0; i5 < p3; ++i5) {
                    const p4 = this.attemptAnchorPlacement(r3[i5 % r3.length], e22, l4, h4, a3, E22, S2, _22, c22, v22, i5 >= r3.length, t3, s3, n22, o4, d4, m22, g22);
                    if (p4 && (u3 = p4.placedGlyphBoxes, u3 && u3.box && u3.box.length)) {
                      L3 = true, N22 = p4.shift;
                      break;
                    }
                  }
                  return u3;
                };
                o3(() => h3(X22, l3.iconBox, e2.bI.horizontal), () => {
                  const t4 = l3.verticalTextBox;
                  return t4 && $2(t4), n22.allowVerticalPlacement && !(U22 && U22.box && U22.box.length) && R3 > 0 && t4 ? h3(t4, l3.verticalIconBox, e2.bI.vertical) : { box: null, offscreen: null, occluded: null };
                }), U22 && (L3 = U22.box, z3 = U22.offscreen, B3 = U22.occluded);
                const d3 = i3(!(!U22 || !U22.box));
                if (!L3 && this.prevPlacement) {
                  const e22 = this.prevPlacement.variableOffsets[f3];
                  e22 && (this.variableOffsets[f3] = e22, this.markUsedJustification(n22, e22.anchor, t3, d3));
                }
              } else {
                const a3 = (i4, o4) => {
                  const a4 = n22.getSymbolInstanceTextSize(m22, t3, this.transform.zoom, s3, r22), l4 = this.collisionIndex.placeCollisionBox(n22, a4, i4, new e2.P(0, 0), w22, _22, c22, v22.predicate);
                  return l4 && l4.box && l4.box.length && (this.markUsedOrientation(n22, o4, t3), this.placedOrientations[f3] = o4), l4;
                };
                o3(() => a3(X22, e2.bI.horizontal), () => {
                  const t4 = l3.verticalTextBox;
                  return n22.allowVerticalPlacement && R3 > 0 && t4 ? ($2(t4), a3(t4, e2.bI.vertical)) : { box: null, offscreen: null, occluded: null };
                }), i3(!!(U22 && U22.box && U22.box.length));
              }
            }
            if (V2 = U22, L3 = V2 && V2.box && V2.box.length > 0, z3 = V2 && V2.offscreen, B3 = V2 && V2.occluded, t3.useRuntimeCollisionCircles) {
              const i3 = n22.text.placedSymbolArray.get(t3.centerJustifiedTextSymbolIndex >= 0 ? t3.centerJustifiedTextSymbolIndex : t3.verticalPlacedTextSymbolIndex), s4 = e2.bJ(n22.textSizeData, m22, i3), r3 = a22.get("text-padding");
              G2 = this.collisionIndex.placeCollisionCircles(n22, w22, i3, n22.lineVertexArray, n22.glyphOffsetArray, s4, c22, h22, d22, o2, S2, v22.predicate, t3.collisionCircleDiameter * s4 / e2.bO, r3, this.retainedQueryData[n22.bucketInstanceId].tileID), L3 = w22 || G2.circles.length > 0 && !G2.collisionDetected, z3 = z3 && G2.offscreen, B3 = G2.occluded;
            }
            if (l3.iconFeatureIndex && (W2 = l3.iconFeatureIndex), l3.iconBox) {
              const i3 = (i4) => {
                $2(i4);
                const o3 = t3.hasIconTextFit && N22 ? vi(N22.x, N22.y, E22, S2, this.transform.angle) : new e2.P(0, 0), s4 = n22.getSymbolInstanceIconSize(g22, this.transform.zoom, t3.placedIconSymbolIndex);
                return this.collisionIndex.placeCollisionBox(n22, s4, i4, o3, T2, _22, c22, v22.predicate);
              };
              j22 && j22.box && j22.box.length && l3.verticalIconBox ? (q22 = i3(l3.verticalIconBox), P3 = q22.box.length > 0) : (q22 = i3(l3.iconBox), P3 = q22.box.length > 0), z3 = z3 && q22.offscreen, k22 = q22.occluded;
            }
            const Y2 = x22 || 0 === t3.numHorizontalGlyphVertices && 0 === R3, K22 = b22 || 0 === t3.numIconVertices;
            if (Y2 || K22 ? K22 ? Y2 || (P3 = P3 && L3) : L3 = P3 && L3 : P3 = L3 = P3 && L3, L3 && V2 && V2.box && this.collisionIndex.insertCollisionBox(V2.box, a22.get("text-ignore-placement"), n22.bucketInstanceId, j22 && j22.box && H2 ? H2 : Z2, v22.ID), P3 && q22 && this.collisionIndex.insertCollisionBox(q22.box, a22.get("icon-ignore-placement"), n22.bucketInstanceId, W2, v22.ID), G2 && (L3 && this.collisionIndex.insertCollisionCircles(G2.circles, a22.get("text-ignore-placement"), n22.bucketInstanceId, Z2, v22.ID), o2)) {
              const e22 = n22.bucketInstanceId;
              let t4 = this.collisionCircleArrays[e22];
              void 0 === t4 && (t4 = this.collisionCircleArrays[e22] = new pi());
              for (let e3 = 0; e3 < G2.circles.length; e3 += 4) t4.circles.push(G2.circles[e3 + 0]), t4.circles.push(G2.circles[e3 + 1]), t4.circles.push(G2.circles[e3 + 2]), t4.circles.push(G2.collisionDetected ? 1 : 0);
            }
            const J2 = "globe" !== n22.projection.name;
            M22 = M22 && (J2 || !B3), O2 = O2 && (J2 || !k22), this.placements[f3] = new _i2(L3 || M22, P3 || O2, z3 || n22.justReloaded), i22.add(f3);
          };
          if ("offset" === n22.elevationType && this.buildingIndex && this.buildingIndex.updateZOffset(n22, this.retainedQueryData[n22.bucketInstanceId].tileID), "road" === n22.elevationType && n22.updateRoadElevation(), n22.updateZOffset(), n22.sortFeaturesByY) {
            const t3 = n22.getSortedSymbolIndexes(this.transform.angle);
            for (let e22 = t3.length - 1; e22 >= 0; --e22) {
              const i3 = t3[e22];
              B22(n22.symbolInstances.get(i3), i3, n22.collisionArrays[i3]);
            }
            n22.hasAnyZOffset && e2.w(`${n22.layerIds[0]} layer symbol-z-elevate: symbols are not sorted by elevation if symbol-z-order is evaluated to viewport-y`);
          } else if (n22.hasAnyZOffset) {
            const e22 = n22.getSortedIndexesByZOffset();
            for (let t3 = 0; t3 < e22.length; ++t3) {
              const i3 = e22[t3];
              B22(n22.symbolInstances.get(i3), i3, n22.collisionArrays[i3]);
            }
          } else for (let e22 = t22.symbolInstanceStart; e22 < t22.symbolInstanceEnd; e22++) B22(n22.symbolInstances.get(e22), e22, n22.collisionArrays[e22]);
          if (o2 && n22.bucketInstanceId in this.collisionCircleArrays) {
            const t3 = this.collisionCircleArrays[n22.bucketInstanceId];
            e2.bi(t3.invProjMatrix, c22), t3.viewportMatrix = this.collisionIndex.getViewportMatrix();
          }
          n22.justReloaded = false;
        }
        markUsedJustification(t22, i22, o2, s2) {
          const { leftJustifiedTextSymbolIndex: r22, centerJustifiedTextSymbolIndex: n22, rightJustifiedTextSymbolIndex: a22, verticalPlacedTextSymbolIndex: l22, crossTileID: c22 } = o2, h22 = e2.bT(i22), d22 = s2 === e2.bI.vertical ? l22 : "left" === h22 ? r22 : "center" === h22 ? n22 : "right" === h22 ? a22 : -1;
          r22 >= 0 && (t22.text.placedSymbolArray.get(r22).crossTileID = d22 >= 0 && r22 !== d22 ? 0 : c22), n22 >= 0 && (t22.text.placedSymbolArray.get(n22).crossTileID = d22 >= 0 && n22 !== d22 ? 0 : c22), a22 >= 0 && (t22.text.placedSymbolArray.get(a22).crossTileID = d22 >= 0 && a22 !== d22 ? 0 : c22), l22 >= 0 && (t22.text.placedSymbolArray.get(l22).crossTileID = d22 >= 0 && l22 !== d22 ? 0 : c22);
        }
        markUsedOrientation(t22, i22, o2) {
          const s2 = i22 === e2.bI.horizontal || i22 === e2.bI.horizontalOnly ? i22 : 0, r22 = i22 === e2.bI.vertical ? i22 : 0, { leftJustifiedTextSymbolIndex: n22, centerJustifiedTextSymbolIndex: a22, rightJustifiedTextSymbolIndex: l22, verticalPlacedTextSymbolIndex: c22 } = o2, h22 = t22.text.placedSymbolArray;
          n22 >= 0 && (h22.get(n22).placedOrientation = s2), a22 >= 0 && (h22.get(a22).placedOrientation = s2), l22 >= 0 && (h22.get(l22).placedOrientation = s2), c22 >= 0 && (h22.get(c22).placedOrientation = r22);
        }
        commit(e22) {
          this.commitTime = e22, this.zoomAtLastRecencyCheck = this.transform.zoom;
          const t22 = this.prevPlacement;
          let i22 = false;
          this.prevZoomAdjustment = t22 ? t22.zoomAdjustment(this.transform.zoom) : 0;
          const o2 = t22 ? t22.symbolFadeChange(e22) : 1, s2 = t22 ? t22.opacities : {}, r22 = t22 ? t22.variableOffsets : {}, n22 = t22 ? t22.placedOrientations : {};
          for (const e3 in this.placements) {
            const t3 = this.placements[e3], r3 = s2[e3];
            r3 ? (this.opacities[e3] = new ui(r3, o2, t3.text, t3.icon, null, t3.clipped), i22 = i22 || t3.text !== r3.text.placed || t3.icon !== r3.icon.placed) : (this.opacities[e3] = new ui(null, o2, t3.text, t3.icon, t3.skipFade, t3.clipped), i22 = i22 || t3.text || t3.icon);
          }
          for (const e3 in s2) {
            const t3 = s2[e3];
            if (!this.opacities[e3]) {
              const s3 = new ui(t3, o2, false, false);
              s3.isHidden() || (this.opacities[e3] = s3, i22 = i22 || t3.text.placed || t3.icon.placed);
            }
          }
          for (const e3 in r22) this.variableOffsets[e3] || !this.opacities[e3] || this.opacities[e3].isHidden() || (this.variableOffsets[e3] = r22[e3]);
          for (const e3 in n22) this.placedOrientations[e3] || !this.opacities[e3] || this.opacities[e3].isHidden() || (this.placedOrientations[e3] = n22[e3]);
          i22 ? this.lastPlacementChangeTime = e22 : "number" != typeof this.lastPlacementChangeTime && (this.lastPlacementChangeTime = t22 ? t22.lastPlacementChangeTime : e22);
        }
        updateLayerOpacities(e22, t22, i22, o2) {
          const s2 = /* @__PURE__ */ new Set();
          for (const r22 of t22) {
            const t3 = r22.getBucket(e22);
            t3 && r22.latestFeatureIndex && e22.fqid === t3.layerIds[0] && (this.updateBucketOpacities(t3, s2, r22, r22.collisionBoxArray, i22, o2, r22.tileID, e22.scope), "offset" === t3.elevationType && this.buildingIndex && this.buildingIndex.updateZOffset(t3, r22.tileID), "road" === t3.elevationType && t3.updateRoadElevation(), t3.updateZOffset());
          }
        }
        updateBucketOpacities(t22, i22, o2, s2, r22, n22, a22, l22) {
          t22.hasTextData() && t22.text.opacityVertexArray.clear(), t22.hasIconData() && t22.icon.opacityVertexArray.clear(), t22.hasIconCollisionBoxData() && t22.iconCollisionBox.collisionVertexArray.clear(), t22.hasTextCollisionBoxData() && t22.textCollisionBox.collisionVertexArray.clear();
          const c22 = t22.layers[0].layout, h22 = t22.layers[0].paint, d22 = !!t22.layers[0].dynamicFilter(), u22 = new ui(null, 0, false, false, true), _22 = c22.get("text-allow-overlap"), p22 = c22.get("icon-allow-overlap"), f22 = c22.get("text-variable-anchor"), m22 = "map" === c22.get("text-rotation-alignment"), g22 = "map" === c22.get("text-pitch-alignment"), v22 = h22.get("symbol-z-offset"), y22 = "sea" === c22.get("symbol-elevation-reference"), x22 = !v22.isConstant(), b22 = new ui(null, 0, _22 && (p22 || !t22.hasIconData() || c22.get("icon-optional")), p22 && (_22 || !t22.hasTextData() || c22.get("text-optional")), true);
          !t22.collisionArrays && s2 && (t22.hasIconCollisionBoxData() || t22.hasTextCollisionBoxData()) && t22.deserializeCollisionBoxes(s2);
          const w22 = (e22, t3, i3) => {
            for (let o3 = 0; o3 < t3 / 4; o3++) e22.opacityVertexArray.emplaceBack(i3);
          };
          let T2 = 0;
          n22 && t22.updateReplacement(a22, n22);
          for (let s3 = 0; s3 < t22.symbolInstances.length; s3++) {
            const c3 = t22.symbolInstances.get(s3), { numHorizontalGlyphVertices: h3, numVerticalGlyphVertices: _3, crossTileID: p3, numIconVertices: E22, tileAnchorX: S2, tileAnchorY: I2 } = c3;
            let C22 = null;
            const R22 = this.retainedQueryData[t22.bucketInstanceId];
            x22 && c3 && R22 && (C22 = o2.latestFeatureIndex.loadFeature({ featureIndex: c3.featureIndex, bucketIndex: R22.bucketIndex, sourceLayerIndex: R22.sourceLayerIndex, layoutVertexArrayOffset: 0 }));
            const D22 = v22.evaluate(C22, {}), A22 = i22.has(p3);
            let L22 = this.opacities[p3];
            A22 ? L22 = u22 : L22 || (L22 = b22, this.opacities[p3] = L22), i22.add(p3);
            const P22 = h3 > 0 || _3 > 0, z22 = E22 > 0, M22 = this.placedOrientations[p3], O2 = M22 === e2.bI.vertical, F2 = M22 === e2.bI.horizontal || M22 === e2.bI.horizontalOnly;
            !P22 && !z22 || L22.isHidden() || T2++;
            let B22 = false;
            if ((P22 || z22) && n22) for (const i3 of t22.activeReplacements) {
              if (e2.bP(i3, r22, e2.bQ.Symbol, l22)) continue;
              if (i3.min.x > S2 || S2 > i3.max.x || i3.min.y > I2 || I2 > i3.max.y) continue;
              const t3 = e2.bR(S2, I2, a22.canonical, i3.footprintTileId.canonical);
              if (B22 = e2.bS(t3, i3.footprint), B22) break;
            }
            if (P22) {
              const e22 = B22 ? Di : Ri(L22.text);
              w22(t22.text, h3, O2 ? Di : e22), w22(t22.text, _3, F2 ? Di : e22);
              const i3 = L22.text.isHidden(), { leftJustifiedTextSymbolIndex: o3, centerJustifiedTextSymbolIndex: s4, rightJustifiedTextSymbolIndex: r3, verticalPlacedTextSymbolIndex: n3 } = c3, a3 = t22.text.placedSymbolArray, l3 = i3 || O2 ? 1 : 0;
              o3 >= 0 && (a3.get(o3).hidden = l3), s4 >= 0 && (a3.get(s4).hidden = l3), r3 >= 0 && (a3.get(r3).hidden = l3), n3 >= 0 && (a3.get(n3).hidden = i3 || F2 ? 1 : 0);
              const d3 = this.variableOffsets[p3];
              d3 && this.markUsedJustification(t22, d3.anchor, c3, M22);
              const u3 = this.placedOrientations[p3];
              u3 && (this.markUsedJustification(t22, "left", c3, u3), this.markUsedOrientation(t22, u3, c3));
            }
            if (z22) {
              const e22 = B22 ? Di : Ri(L22.icon), { placedIconSymbolIndex: i3, verticalPlacedIconSymbolIndex: o3 } = c3, s4 = t22.icon.placedSymbolArray, r3 = L22.icon.isHidden() ? 1 : 0;
              i3 >= 0 && (w22(t22.icon, E22, O2 ? Di : e22), s4.get(i3).hidden = r3), o3 >= 0 && (w22(t22.icon, c3.numVerticalIconVertices, F2 ? Di : e22), s4.get(o3).hidden = r3);
            }
            if (t22.hasIconCollisionBoxData() || t22.hasTextCollisionBoxData()) {
              const i3 = t22.collisionArrays[s3];
              if (i3) {
                let o3 = new e2.P(0, 0), s4 = true;
                if (i3.textBox || i3.verticalTextBox) {
                  if (f22) {
                    const e22 = this.variableOffsets[p3];
                    e22 ? (o3 = gi(e22.anchor, e22.width, e22.height, e22.textOffset, e22.textScale), m22 && o3._rotate(g22 ? this.transform.angle : -this.transform.angle)) : s4 = false;
                  }
                  d22 && (s4 = !L22.clipped), i3.textBox && xi(t22.textCollisionBox.collisionVertexArray, L22.text.placed, !s4 || O2, D22, y22, o3.x, o3.y), i3.verticalTextBox && xi(t22.textCollisionBox.collisionVertexArray, L22.text.placed, !s4 || F2, D22, y22, o3.x, o3.y);
                }
                const r3 = s4 && Boolean(!F2 && i3.verticalIconBox);
                i3.iconBox && xi(t22.iconCollisionBox.collisionVertexArray, L22.icon.placed, r3, D22, y22, c3.hasIconTextFit ? o3.x : 0, c3.hasIconTextFit ? o3.y : 0), i3.verticalIconBox && xi(t22.iconCollisionBox.collisionVertexArray, L22.icon.placed, !r3, D22, y22, c3.hasIconTextFit ? o3.x : 0, c3.hasIconTextFit ? o3.y : 0);
              }
            }
          }
          if (t22.fullyClipped = 0 === T2, t22.sortFeatures(this.transform.angle), this.retainedQueryData[t22.bucketInstanceId] && (this.retainedQueryData[t22.bucketInstanceId].featureSortOrder = t22.featureSortOrder), t22.hasTextData() && t22.text.opacityVertexBuffer && t22.text.opacityVertexBuffer.updateData(t22.text.opacityVertexArray), t22.hasIconData() && t22.icon.opacityVertexBuffer && t22.icon.opacityVertexBuffer.updateData(t22.icon.opacityVertexArray), t22.hasIconCollisionBoxData() && t22.iconCollisionBox.collisionVertexBuffer && t22.iconCollisionBox.collisionVertexBuffer.updateData(t22.iconCollisionBox.collisionVertexArray), t22.hasTextCollisionBoxData() && t22.textCollisionBox.collisionVertexBuffer && t22.textCollisionBox.collisionVertexBuffer.updateData(t22.textCollisionBox.collisionVertexArray), t22.bucketInstanceId in this.collisionCircleArrays) {
            const e22 = this.collisionCircleArrays[t22.bucketInstanceId];
            t22.placementInvProjMatrix = e22.invProjMatrix, t22.placementViewportMatrix = e22.viewportMatrix, t22.collisionCircleArray = e22.circles, delete this.collisionCircleArrays[t22.bucketInstanceId];
          }
        }
        symbolFadeChange(e22) {
          return 0 === this.fadeDuration ? 1 : (e22 - this.commitTime) / this.fadeDuration + this.prevZoomAdjustment;
        }
        zoomAdjustment(e22) {
          return Math.max(0, (this.transform.zoom - e22) / 1.5);
        }
        hasTransitions(e22) {
          return this.stale || e22 - this.lastPlacementChangeTime < this.fadeDuration;
        }
        stillRecent(e22, t22) {
          const i22 = this.zoomAtLastRecencyCheck === t22 ? 1 - this.zoomAdjustment(t22) : 1;
          return this.zoomAtLastRecencyCheck = t22, this.commitTime + this.fadeDuration * i22 > e22;
        }
        setStale() {
          this.stale = true;
        }
      }
      function xi(e22, t22, i22, o2, s2, r22, n22) {
        e22.emplaceBack(t22 ? 1 : 0, i22 ? 1 : 0, r22 || 0, n22 || 0, o2, s2 ? 1 : 0), e22.emplaceBack(t22 ? 1 : 0, i22 ? 1 : 0, r22 || 0, n22 || 0, o2, s2 ? 1 : 0), e22.emplaceBack(t22 ? 1 : 0, i22 ? 1 : 0, r22 || 0, n22 || 0, o2, s2 ? 1 : 0), e22.emplaceBack(t22 ? 1 : 0, i22 ? 1 : 0, r22 || 0, n22 || 0, o2, s2 ? 1 : 0);
      }
      const bi = Math.pow(2, 25), wi = Math.pow(2, 24), Ti = Math.pow(2, 17), Ei = Math.pow(2, 16), Si = Math.pow(2, 9), Ii = Math.pow(2, 8), Ci = Math.pow(2, 1);
      function Ri(e22) {
        if (0 === e22.opacity && !e22.placed) return 0;
        if (1 === e22.opacity && e22.placed) return 4294967295;
        const t22 = e22.placed ? 1 : 0, i22 = Math.floor(127 * e22.opacity);
        return i22 * bi + t22 * wi + i22 * Ti + t22 * Ei + i22 * Si + t22 * Ii + i22 * Ci + t22;
      }
      const Di = 0;
      class Ai {
        constructor(e22) {
          this._sortAcrossTiles = "viewport-y" !== e22.layout.get("symbol-z-order") && void 0 !== e22.layout.get("symbol-sort-key").constantOr(1), this._currentTileIndex = 0, this._currentPartIndex = 0, this._seenCrossTileIDs = /* @__PURE__ */ new Set(), this._bucketParts = [];
        }
        continuePlacement(e22, t22, i22, o2, s2, r22) {
          const n22 = this._bucketParts;
          for (; this._currentTileIndex < e22.length; ) if (t22.getBucketParts(n22, o2, e22[this._currentTileIndex], this._sortAcrossTiles, r22), this._currentTileIndex++, s2()) return true;
          for (this._sortAcrossTiles && (this._sortAcrossTiles = false, n22.sort((e3, t3) => e3.sortKey - t3.sortKey)); this._currentPartIndex < n22.length; ) {
            const e3 = n22[this._currentPartIndex];
            if (t22.placeLayerBucketPart(e3, this._seenCrossTileIDs, i22, 0 === e3.symbolInstanceStart, r22), this._currentPartIndex++, s2()) return true;
          }
          return false;
        }
      }
      class Li {
        constructor(e22, t22, i22, o2, s2, r22, n22, a22, l22) {
          this.placement = new yi(e22, s2, r22, n22, a22, l22), this._currentPlacementIndex = t22.length - 1, this._forceFullPlacement = i22, this._showCollisionBoxes = o2, this._done = false;
        }
        isDone() {
          return this._done;
        }
        continuePlacement(t22, i22, o2, s2, r22) {
          const n22 = e2.q.now(), a22 = () => {
            const t3 = e2.q.now() - n22;
            return !this._forceFullPlacement && t3 > 2;
          };
          for (; this._currentPlacementIndex >= 0; ) {
            const n3 = i22[t22[this._currentPlacementIndex]], l22 = this.placement.collisionIndex.transform.zoom;
            if ("symbol" === n3.type && (!n3.minzoom || n3.minzoom <= l22) && (!n3.maxzoom || n3.maxzoom > l22)) {
              const t3 = n3, i3 = t3.layout.get("symbol-z-elevate"), l3 = void 0 !== t3.layout.get("symbol-sort-key").constantOr(1), c22 = t3.layout.get("symbol-z-order"), h22 = "viewport-y" === c22 || "auto" === c22 && !("viewport-y" !== c22 && l3), d22 = t3.layout.get("text-allow-overlap") || t3.layout.get("icon-allow-overlap") || t3.layout.get("text-ignore-placement") || t3.layout.get("icon-ignore-placement"), u22 = h22 && d22, _22 = this._inProgressLayer = this._inProgressLayer || new Ai(t3), p22 = e2.C(n3.source, n3.scope);
              if (_22.continuePlacement(i3 || u22 ? s2[p22] : o2[p22], this.placement, this._showCollisionBoxes, n3, a22, r22)) return;
              delete this._inProgressLayer;
            }
            this._currentPlacementIndex--;
          }
          this._done = true;
        }
        commit(e22) {
          return this.placement.commit(e22), this.placement;
        }
      }
      const Pi = 512 / e2.aj / 2;
      class zi {
        constructor(t22, i22, o2) {
          this.tileID = t22, this.bucketInstanceId = o2, this.index = new e2.bW(i22.length, 16, Int32Array), this.keys = [], this.crossTileIDs = [];
          const s2 = t22.canonical.x * e2.aj, r22 = t22.canonical.y * e2.aj;
          for (let e22 = 0; e22 < i22.length; e22++) {
            const { key: t3, crossTileID: o3, tileAnchorX: n22, tileAnchorY: a22 } = i22.get(e22), l22 = Math.floor((s2 + n22) * Pi), c22 = Math.floor((r22 + a22) * Pi);
            this.index.add(l22, c22), this.keys.push(t3), this.crossTileIDs.push(o3);
          }
          this.index.finish();
        }
        findMatches(t22, i22, o2) {
          const s2 = this.tileID.canonical.z < i22.canonical.z ? 1 : Math.pow(2, this.tileID.canonical.z - i22.canonical.z), r22 = Pi / Math.pow(2, i22.canonical.z - this.tileID.canonical.z), n22 = i22.canonical.x * e2.aj, a22 = i22.canonical.y * e2.aj;
          for (let e22 = 0; e22 < t22.length; e22++) {
            const i3 = t22.get(e22);
            if (i3.crossTileID) continue;
            const { key: l22, tileAnchorX: c22, tileAnchorY: h22 } = i3, d22 = Math.floor((n22 + c22) * r22), u22 = Math.floor((a22 + h22) * r22), _22 = this.index.range(d22 - s2, u22 - s2, d22 + s2, u22 + s2).sort((e3, t3) => e3 - t3);
            for (const e3 of _22) {
              const t3 = this.crossTileIDs[e3];
              if (this.keys[e3] === l22 && !o2.has(t3)) {
                o2.add(t3), i3.crossTileID = t3;
                break;
              }
            }
          }
        }
      }
      class Mi {
        constructor() {
          this.maxCrossTileID = 0;
        }
        generate() {
          return ++this.maxCrossTileID;
        }
      }
      class Oi {
        constructor() {
          this.indexes = {}, this.usedCrossTileIDs = {}, this.lng = 0;
        }
        handleWrapJump(e22) {
          const t22 = Math.round((e22 - this.lng) / 360);
          if (0 !== t22) for (const e3 in this.indexes) {
            const i22 = this.indexes[e3], o2 = {};
            for (const e4 in i22) {
              const s2 = i22[e4];
              s2.tileID = s2.tileID.unwrapTo(s2.tileID.wrap + t22), o2[s2.tileID.key] = s2;
            }
            this.indexes[e3] = o2;
          }
          this.lng = e22;
        }
        addBucket(e22, t22, i22) {
          if (this.indexes[e22.overscaledZ] && this.indexes[e22.overscaledZ][e22.key]) {
            if (this.indexes[e22.overscaledZ][e22.key].bucketInstanceId === t22.bucketInstanceId) return false;
            this.removeBucketCrossTileIDs(e22.overscaledZ, this.indexes[e22.overscaledZ][e22.key]);
          }
          for (let e3 = 0; e3 < t22.symbolInstances.length; e3++) t22.symbolInstances.get(e3).crossTileID = 0;
          this.usedCrossTileIDs[e22.overscaledZ] || (this.usedCrossTileIDs[e22.overscaledZ] = /* @__PURE__ */ new Set());
          const o2 = this.usedCrossTileIDs[e22.overscaledZ];
          for (const i3 in this.indexes) {
            const s2 = this.indexes[i3];
            if (Number(i3) > e22.overscaledZ) for (const i4 in s2) {
              const r22 = s2[i4];
              r22.tileID.isChildOf(e22) && r22.findMatches(t22.symbolInstances, e22, o2);
            }
            else {
              const r22 = s2[e22.scaledTo(Number(i3)).key];
              r22 && r22.findMatches(t22.symbolInstances, e22, o2);
            }
          }
          for (let e3 = 0; e3 < t22.symbolInstances.length; e3++) {
            const s2 = t22.symbolInstances.get(e3);
            s2.crossTileID || (s2.crossTileID = i22.generate(), o2.add(s2.crossTileID));
          }
          return void 0 === this.indexes[e22.overscaledZ] && (this.indexes[e22.overscaledZ] = {}), this.indexes[e22.overscaledZ][e22.key] = new zi(e22, t22.symbolInstances, t22.bucketInstanceId), true;
        }
        removeBucketCrossTileIDs(e22, t22) {
          for (const i22 of t22.crossTileIDs) this.usedCrossTileIDs[e22].delete(i22);
        }
        removeStaleBuckets(e22) {
          let t22 = false;
          for (const i22 in this.indexes) {
            const o2 = this.indexes[i22];
            for (const s2 in o2) e22[o2[s2].bucketInstanceId] || (this.removeBucketCrossTileIDs(i22, o2[s2]), delete o2[s2], t22 = true);
          }
          return t22;
        }
      }
      class Fi {
        constructor() {
          this.layerIndexes = {}, this.crossTileIDs = new Mi(), this.maxBucketInstanceId = 0, this.bucketsInCurrentPlacement = {};
        }
        addLayer(e22, t22, i22, o2) {
          let s2 = this.layerIndexes[e22.fqid];
          void 0 === s2 && (s2 = this.layerIndexes[e22.fqid] = new Oi());
          let r22 = false;
          const n22 = {};
          "globe" !== o2.name && s2.handleWrapJump(i22);
          for (const i3 of t22) {
            const t3 = i3.getBucket(e22);
            t3 && e22.fqid === t3.layerIds[0] && (t3.bucketInstanceId || (t3.bucketInstanceId = ++this.maxBucketInstanceId), s2.addBucket(i3.tileID, t3, this.crossTileIDs) && (r22 = true), n22[t3.bucketInstanceId] = true);
          }
          return s2.removeStaleBuckets(n22) && (r22 = true), r22;
        }
        pruneUnusedLayers(e22) {
          const t22 = {};
          e22.forEach((e3) => {
            t22[e3] = true;
          });
          for (const e3 in this.layerIndexes) t22[e3] || delete this.layerIndexes[e3];
        }
      }
      const Bi = 771;
      class ki {
        constructor(e22, t22, i22, o2) {
          this.blendFunction = e22, this.blendColor = t22, this.mask = i22, this.blendEquation = o2;
        }
      }
      ki.Replace = [1, 0, 1, 0], ki.disabled = new ki(ki.Replace, e2.am.transparent, [false, false, false, false]), ki.unblended = new ki(ki.Replace, e2.am.transparent, [true, true, true, true]), ki.alphaBlended = new ki([1, Bi, 1, Bi], e2.am.transparent, [true, true, true, true]), ki.alphaBlendedNonPremultiplied = new ki([770, Bi, 770, Bi], e2.am.transparent, [true, true, true, true]), ki.multiply = new ki([774, 0, 774, 0], e2.am.transparent, [true, true, true, true]);
      class Ni {
        constructor(e22, t22, i22) {
          this.func = e22, this.mask = t22, this.range = i22;
        }
      }
      Ni.ReadOnly = false, Ni.ReadWrite = true, Ni.disabled = new Ni(519, Ni.ReadOnly, [0, 1]);
      const Ui = 7680;
      class ji {
        constructor(e22, t22, i22, o2, s2, r22) {
          this.test = e22, this.ref = t22, this.mask = i22, this.fail = o2, this.depthFail = s2, this.pass = r22;
        }
      }
      ji.disabled = new ji({ func: 519, mask: 0 }, 0, 0, Ui, Ui, Ui);
      const Vi = 1029, Gi = 2305;
      class qi {
        constructor(e22, t22, i22) {
          this.enable = e22, this.mode = t22, this.frontFace = i22;
        }
      }
      function Zi(t22, i22) {
        const o2 = e2.c1(t22, 3);
        e2.c3(t22, i22), e2.c7(t22, 3, o2);
      }
      function Hi(t22, i22) {
        const o2 = e2.bY([]);
        return e2.bZ(o2, o2, -i22), e2.b_(o2, o2, -t22), o2;
      }
      function Wi(t22, i22) {
        const o2 = [t22[0], t22[1], 0], s2 = [i22[0], i22[1], 0];
        if (e2.ae(o2) >= 1e-15) {
          const t3 = e2.au([], o2);
          e2.b$(s2, t3, e2.bE(s2, t3)), i22[0] = s2[0], i22[1] = s2[1];
        }
        const r22 = e2.bG([], i22, t22);
        if (e2.c0(r22) < 1e-15) return null;
        const n22 = Math.atan2(-r22[1], r22[0]);
        return Hi(Math.atan2(Math.sqrt(t22[0] * t22[0] + t22[1] * t22[1]), -t22[2]), n22);
      }
      qi.disabled = new qi(false, Vi, Gi), qi.backCCW = new qi(true, Vi, Gi), qi.backCW = new qi(true, Vi, 2304), qi.frontCW = new qi(true, 1028, 2304), qi.frontCCW = new qi(true, 1028, Gi);
      class $i {
        constructor(e22, t22) {
          this.position = e22, this.orientation = t22;
        }
        get position() {
          return this._position;
        }
        set position(t22) {
          if (t22) {
            const i22 = t22 instanceof e2.ac ? t22 : new e2.ac(t22[0], t22[1], t22[2]);
            this._renderWorldCopies && (i22.x = e2.bX(i22.x, 0, 1)), this._position = i22;
          } else this._position = null;
        }
        lookAtPoint(t22, i22) {
          if (this.orientation = null, !this.position) return;
          const o2 = this.position, s2 = this._elevation ? this._elevation.getAtPointOrZero(e2.ac.fromLngLat(t22)) : 0, r22 = e2.ac.fromLngLat(t22, s2), n22 = [r22.x - o2.x, r22.y - o2.y, r22.z - o2.z];
          i22 || (i22 = [0, 0, 1]), i22[2] = Math.abs(i22[2]), this.orientation = Wi(n22, i22);
        }
        setPitchBearing(t22, i22) {
          this.orientation = Hi(e2.al(t22), e2.al(-i22));
        }
      }
      class Xi {
        constructor(t22, i22) {
          this._transform = e2.bx([]), this.orientation = i22, this.position = t22;
        }
        get mercatorPosition() {
          const t22 = this.position;
          return new e2.ac(t22[0], t22[1], t22[2]);
        }
        get position() {
          const t22 = e2.c1(this._transform, 3);
          return [t22[0], t22[1], t22[2]];
        }
        set position(t22) {
          var i22;
          t22 && e2.c7(this._transform, 3, [(i22 = t22)[0], i22[1], i22[2], 1]);
        }
        get orientation() {
          return this._orientation;
        }
        set orientation(t22) {
          this._orientation = t22 || e2.bY([]), t22 && Zi(this._transform, this._orientation);
        }
        getPitchBearing() {
          const e22 = this.forward(), t22 = this.right();
          return { bearing: Math.atan2(-t22[1], t22[0]), pitch: Math.atan2(Math.sqrt(e22[0] * e22[0] + e22[1] * e22[1]), -e22[2]) };
        }
        setPitchBearing(e22, t22) {
          this._orientation = Hi(e22, t22), Zi(this._transform, this._orientation);
        }
        forward() {
          const t22 = e2.c1(this._transform, 2);
          return [-t22[0], -t22[1], -t22[2]];
        }
        up() {
          const t22 = e2.c1(this._transform, 1);
          return [-t22[0], -t22[1], -t22[2]];
        }
        right() {
          const t22 = e2.c1(this._transform, 0);
          return [t22[0], t22[1], t22[2]];
        }
        getCameraToWorld(t22, i22) {
          const o2 = new Float64Array(16);
          return e2.bi(o2, this.getWorldToCamera(t22, i22)), o2;
        }
        getCameraToWorldMercator() {
          return this._transform;
        }
        getWorldToCameraPosition(t22, i22, o2) {
          const s2 = this.position;
          e2.b$(s2, s2, -t22);
          const r22 = new Float64Array(16);
          return e2.bn(r22, [o2, o2, o2]), e2.bo(r22, r22, s2), r22[10] *= i22, r22;
        }
        getWorldToCamera(t22, i22) {
          const o2 = new Float64Array(16), s2 = new Float64Array(4), r22 = this.position;
          return e2.c2(s2, this._orientation), e2.b$(r22, r22, -t22), e2.c3(o2, s2), e2.bo(o2, o2, r22), o2[1] *= -1, o2[5] *= -1, o2[9] *= -1, o2[13] *= -1, o2[8] *= i22, o2[9] *= i22, o2[10] *= i22, o2[11] *= i22, o2;
        }
        getCameraToClipPerspective(t22, i22, o2, s2) {
          const r22 = new Float64Array(16);
          return e2.c4(r22, t22, i22, o2, s2), r22;
        }
        getCameraToClipOrthographic(t22, i22, o2, s2, r22, n22) {
          const a22 = new Float64Array(16);
          return e2.c5(a22, t22, i22, o2, s2, r22, n22), a22;
        }
        getDistanceToElevation(t22, i22 = false) {
          const o2 = 0 === t22 ? 0 : e2.c6(t22, i22 ? e2.aY(this.position[1]) : this.position[1]), s2 = this.forward();
          return (o2 - this.position[2]) / s2[2];
        }
        clone() {
          return new Xi([...this.position], [...this.orientation]);
        }
      }
      const Yi = { BaseColor: 5, MetallicRoughness: 6, Normal: 7, Occlusion: 8, Emission: 9, LUT: 10, ShadowMap0: 11 };
      class Ki {
        constructor(e22 = 0, t22 = 0, i22 = 0, o2 = 0) {
          if (isNaN(e22) || e22 < 0 || isNaN(t22) || t22 < 0 || isNaN(i22) || i22 < 0 || isNaN(o2) || o2 < 0) throw new Error("Invalid value for edge-insets, top, bottom, left and right must all be numbers");
          this.top = e22, this.bottom = t22, this.left = i22, this.right = o2;
        }
        interpolate(t22, i22, o2) {
          return null != i22.top && null != t22.top && (this.top = e2.ai(t22.top, i22.top, o2)), null != i22.bottom && null != t22.bottom && (this.bottom = e2.ai(t22.bottom, i22.bottom, o2)), null != i22.left && null != t22.left && (this.left = e2.ai(t22.left, i22.left, o2)), null != i22.right && null != t22.right && (this.right = e2.ai(t22.right, i22.right, o2)), this;
        }
        getCenter(t22, i22) {
          const o2 = e2.aD((this.left + t22 - this.right) / 2, 0, t22), s2 = e2.aD((this.top + i22 - this.bottom) / 2, 0, i22);
          return new e2.P(o2, s2);
        }
        equals(e22) {
          return this.top === e22.top && this.bottom === e22.bottom && this.left === e22.left && this.right === e22.right;
        }
        clone() {
          return new Ki(this.top, this.bottom, this.left, this.right);
        }
        toJSON() {
          return { top: this.top, bottom: this.bottom, left: this.left, right: this.right };
        }
      }
      const Ji = 15;
      class Qi {
        constructor(t22, i22, o2, s2, r22, n22, a22) {
          this.tileSize = 512, this._renderWorldCopies = void 0 === r22 || r22, this._minZoom = t22 || 0, this._maxZoom = i22 || 22, this._minPitch = o2 ?? 0, this._maxPitch = s2 ?? 60, this.setProjection(n22), this.setMaxBounds(a22), this.width = 0, this.height = 0, this._center = new e2.cd(0, 0), this.zoom = 0, this.angle = 0, this._fov = 0.6435011087932844, this._pitch = 0, this._nearZ = 0, this._farZ = 0, this._unmodified = true, this._edgeInsets = new Ki(), this._projMatrixCache = {}, this._alignedProjMatrixCache = {}, this._fogTileMatrixCache = {}, this._expandedProjMatrixCache = {}, this._distanceTileDataCache = {}, this._camera = new Xi(), this._centerAltitude = 0, this._averageElevation = 0, this.cameraElevationReference = "ground", this._pixelsPerMercatorPixel = 1, this.globeRadius = 0, this.globeCenterInViewSpace = [0, 0, 0], this._tileCoverLift = 0, this.freezeTileCoverage = false, this._horizonShift = 0.1, this._orthographicProjectionAtLowPitch = false, this._allowWorldUnderZoom = false;
        }
        clone() {
          const e22 = new Qi(this._minZoom, this._maxZoom, this._minPitch, this.maxPitch, this._renderWorldCopies, this.getProjection(), this.maxBounds);
          return e22._elevation = this._elevation, e22._centerAltitude = this._centerAltitude, e22._centerAltitudeValidForExaggeration = this._centerAltitudeValidForExaggeration, e22.tileSize = this.tileSize, e22.mercatorFromTransition = this.mercatorFromTransition, e22.width = this.width, e22.height = this.height, e22.cameraElevationReference = this.cameraElevationReference, e22._center = this._center, e22._setZoom(this.zoom), e22._seaLevelZoom = this._seaLevelZoom, e22.angle = this.angle, e22._fov = this._fov, e22._pitch = this._pitch, e22._nearZ = this._nearZ, e22._farZ = this._farZ, e22._averageElevation = this._averageElevation, e22._orthographicProjectionAtLowPitch = this._orthographicProjectionAtLowPitch, e22._unmodified = this._unmodified, e22._edgeInsets = this._edgeInsets.clone(), e22._camera = this._camera.clone(), e22._calcMatrices(), e22.freezeTileCoverage = this.freezeTileCoverage, e22.frustumCorners = this.frustumCorners, e22._allowWorldUnderZoom = this._allowWorldUnderZoom, e22;
        }
        get isOrthographic() {
          return "globe" !== this.projection.name && this._orthographicProjectionAtLowPitch && this.pitch < Ji;
        }
        get elevation() {
          return this._elevation;
        }
        set elevation(e22) {
          this._elevation !== e22 && (this._elevation = e22, this._updateCameraOnTerrain(), this._calcMatrices());
        }
        get depthOcclusionForSymbolsAndCircles() {
          return "globe" !== this.projection.name && !this.isOrthographic;
        }
        updateElevation(e22, t22 = false) {
          const i22 = this._elevation && this._elevation.exaggeration() !== this._centerAltitudeValidForExaggeration;
          (null == this._seaLevelZoom || i22) && this._updateCameraOnTerrain(), (e22 || i22) && this._constrainCamera(t22), this._calcMatrices();
        }
        getProjection() {
          return e2.aF(this.projection, ["name", "center", "parallels"]);
        }
        setProjection(t22) {
          this.projectionOptions = t22 || { name: "mercator" };
          const i22 = this.projection ? this.getProjection() : void 0;
          this.projection = e2.ce(this.projectionOptions);
          const o2 = this.getProjection(), s2 = !e2.bv(i22, o2);
          return s2 && this._calcMatrices(), this.mercatorFromTransition = false, s2;
        }
        setOrthographicProjectionAtLowPitch(e22) {
          return this._orthographicProjectionAtLowPitch !== e22 && (this._orthographicProjectionAtLowPitch = e22, this._calcMatrices(), true);
        }
        setMercatorFromTransition() {
          const t22 = this.projection.name;
          this.mercatorFromTransition = true, this.projectionOptions = { name: "mercator" }, this.projection = e2.ce({ name: "mercator" });
          const i22 = t22 !== this.projection.name;
          return i22 && this._calcMatrices(), i22;
        }
        get minZoom() {
          return this._minZoom;
        }
        set minZoom(e22) {
          this._minZoom !== e22 && (this._minZoom = e22, this.zoom = Math.max(this.zoom, e22));
        }
        get maxZoom() {
          return this._maxZoom;
        }
        set maxZoom(e22) {
          this._maxZoom !== e22 && (this._maxZoom = e22, this.zoom = Math.min(this.zoom, e22));
        }
        get minPitch() {
          return this._minPitch;
        }
        set minPitch(e22) {
          this._minPitch !== e22 && (this._minPitch = e22, this.pitch = Math.max(this.pitch, e22));
        }
        get maxPitch() {
          return this._maxPitch;
        }
        set maxPitch(e22) {
          this._maxPitch !== e22 && (this._maxPitch = e22, this.pitch = Math.min(this.pitch, e22));
        }
        get renderWorldCopies() {
          return this._renderWorldCopies && true === this.projection.supportsWorldCopies;
        }
        set renderWorldCopies(e22) {
          void 0 === e22 ? e22 = true : null === e22 && (e22 = false), this._renderWorldCopies = e22;
        }
        get worldSize() {
          return this.tileSize * this.scale;
        }
        get cameraWorldSizeForFog() {
          const e22 = Math.max(this._camera.getDistanceToElevation(this._averageElevation), Number.EPSILON);
          return this._worldSizeFromZoom(this._zoomFromMercatorZ(e22));
        }
        get cameraWorldSize() {
          const e22 = Math.max(this._camera.getDistanceToElevation(this._averageElevation, true), Number.EPSILON);
          return this._worldSizeFromZoom(this._zoomFromMercatorZ(e22));
        }
        get pixelsPerMeter() {
          return this.projection.pixelsPerMeter(this.center.lat, this.worldSize);
        }
        get cameraPixelsPerMeter() {
          return e2.c6(1, this.center.lat) * this.cameraWorldSizeForFog;
        }
        get centerOffset() {
          return this.centerPoint._sub(this.size._div(2));
        }
        get size() {
          return new e2.P(this.width, this.height);
        }
        get bearing() {
          return e2.bX(this.rotation, -180, 180);
        }
        set bearing(e22) {
          this.rotation = e22;
        }
        get rotation() {
          return -this.angle / Math.PI * 180;
        }
        set rotation(t22) {
          const i22 = -t22 * Math.PI / 180;
          this.angle !== i22 && (this._unmodified = false, this.angle = i22, this._calcMatrices(), this.rotationMatrix = e2.cf(), e2.cg(this.rotationMatrix, this.rotationMatrix, this.angle));
        }
        get pitch() {
          return this._pitch / Math.PI * 180;
        }
        set pitch(t22) {
          const i22 = e2.aD(t22, this.minPitch, this.maxPitch) / 180 * Math.PI;
          this._pitch !== i22 && (this._unmodified = false, this._pitch = i22, this._calcMatrices());
        }
        get aspect() {
          return this.width / this.height;
        }
        get fov() {
          return this._fov / Math.PI * 180;
        }
        set fov(t22) {
          t22 = Math.max(0.01, Math.min(60, t22)), this._fov !== t22 && (this._unmodified = false, this._fov = e2.al(t22), this._calcMatrices());
        }
        get fovX() {
          return this._fov;
        }
        get fovY() {
          const e22 = 1 / Math.tan(0.5 * this.fovX);
          return 2 * Math.atan(1 / this.aspect / e22);
        }
        get averageElevation() {
          return this._averageElevation;
        }
        set averageElevation(e22) {
          this._averageElevation = e22, this._calcFogMatrices(), this._distanceTileDataCache = {};
        }
        get zoom() {
          return this._zoom;
        }
        set zoom(e22) {
          const t22 = Math.min(Math.max(e22, this.minZoom), this.maxZoom);
          this._zoom !== t22 && (this._unmodified = false, this._setZoom(t22), this._updateSeaLevelZoom(), this._constrain(), this._calcMatrices());
        }
        _setZoom(e22) {
          this._zoom = e22, this.scale = this.zoomScale(e22), this.tileZoom = Math.floor(e22), this.zoomFraction = e22 - this.tileZoom;
        }
        get tileCoverLift() {
          return this._tileCoverLift;
        }
        set tileCoverLift(e22) {
          this._tileCoverLift !== e22 && (this._tileCoverLift = e22);
        }
        _updateCameraOnTerrain() {
          const e22 = this.elevation ? this.elevation.getAtPoint(this.locationCoordinate(this.center), Number.NEGATIVE_INFINITY) : Number.NEGATIVE_INFINITY, t22 = this.elevation && e22 === Number.NEGATIVE_INFINITY && this.elevation.visibleDemTiles.length > 0 && this.elevation.exaggeration() > 0 && this._centerAltitudeValidForExaggeration;
          if (!this._elevation || e22 === Number.NEGATIVE_INFINITY && (!t22 || !this._centerAltitude)) return this._centerAltitude = 0, this._seaLevelZoom = null, void (this._centerAltitudeValidForExaggeration = void 0);
          const i22 = this._elevation;
          t22 || this._centerAltitude && this._centerAltitudeValidForExaggeration && i22.exaggeration() && this._centerAltitudeValidForExaggeration !== i22.exaggeration() ? (this._centerAltitude = this._centerAltitude / this._centerAltitudeValidForExaggeration * i22.exaggeration(), this._centerAltitudeValidForExaggeration = i22.exaggeration()) : (this._centerAltitude = e22 || 0, this._centerAltitudeValidForExaggeration = i22.exaggeration()), this._updateSeaLevelZoom();
        }
        _updateSeaLevelZoom() {
          void 0 !== this._centerAltitudeValidForExaggeration && (this._seaLevelZoom = this._zoomFromMercatorZ((this.pixelsPerMeter * this._centerAltitude + this.cameraToCenterDistance) / this.worldSize));
        }
        sampleAverageElevation() {
          if (!this._elevation) return 0;
          const t22 = this._elevation, i22 = [[0.5, 0.2], [0.3, 0.5], [0.5, 0.5], [0.7, 0.5], [0.5, 0.8]], o2 = this.horizonLineFromTop();
          let s2 = 0, r22 = 0;
          for (let n22 = 0; n22 < i22.length; n22++) {
            const a22 = new e2.P(i22[n22][0] * this.width, o2 + i22[n22][1] * (this.height - o2)), l22 = t22.pointCoordinate(a22);
            if (!l22) continue;
            const c22 = 1 / Math.hypot(l22[0] - this._camera.position[0], l22[1] - this._camera.position[1]);
            s2 += l22[3] * c22, r22 += c22;
          }
          return 0 === r22 ? NaN : s2 / r22;
        }
        get center() {
          return this._center;
        }
        set center(e22) {
          e22.lat === this._center.lat && e22.lng === this._center.lng || (this._unmodified = false, this._center = e22, this._terrainEnabled() && ("ground" === this.cameraElevationReference ? this._updateCameraOnTerrain() : this._updateZoomFromElevation()), this._constrain(), this._calcMatrices());
        }
        _updateZoomFromElevation() {
          if (null == this._seaLevelZoom || !this._elevation) return;
          const e22 = this._seaLevelZoom, t22 = this._elevation.getAtPointOrZero(this.locationCoordinate(this.center)), i22 = this.pixelsPerMeter / this.worldSize * t22, o2 = this._mercatorZfromZoom(e22), s2 = this._mercatorZfromZoom(this._maxZoom), r22 = Math.max(o2 - i22, s2);
          this._setZoom(this._zoomFromMercatorZ(r22));
        }
        get padding() {
          return this._edgeInsets.toJSON();
        }
        set padding(e22) {
          this._edgeInsets.equals(e22) || (this._unmodified = false, this._edgeInsets.interpolate(this._edgeInsets, e22, 1), this._calcMatrices());
        }
        computeZoomRelativeTo(t22) {
          const i22 = this.rayIntersectionCoordinate(this.pointRayIntersection(this.centerPoint, t22.toAltitude()));
          let o2;
          o2 = t22.z < this._camera.position[2] ? [i22.x, i22.y, i22.z] : [t22.x, t22.y, t22.z];
          const s2 = e2.ae(e2.at([], this._camera.position, o2));
          return e2.aD(this._zoomFromMercatorZ(s2), this._minZoom, this._maxZoom);
        }
        setFreeCameraOptions(t22) {
          if (!this.height) return;
          if (!t22.position && !t22.orientation) return;
          this._updateCameraState();
          let i22 = false;
          if (t22.orientation && !e2.ch(t22.orientation, this._camera.orientation) && (i22 = this._setCameraOrientation(t22.orientation)), t22.position) {
            const o2 = [t22.position.x, t22.position.y, t22.position.z];
            e2.ci(o2, this._camera.position) || (this._setCameraPosition(o2), i22 = true);
          }
          i22 && (this._updateStateFromCamera(), this.recenterOnTerrain());
        }
        getFreeCameraOptions() {
          this._updateCameraState();
          const t22 = this._camera.position, i22 = new $i();
          return i22.position = new e2.ac(t22[0], t22[1], t22[2]), i22.orientation = this._camera.orientation, i22._elevation = this.elevation, i22._renderWorldCopies = this.renderWorldCopies, i22;
        }
        _setCameraOrientation(t22) {
          if (!e2.cj(t22)) return false;
          e2.ck(t22, t22);
          const i22 = e2.cl([], [0, 0, -1], t22), o2 = e2.cl([], [0, -1, 0], t22);
          if (o2[2] < 0) return false;
          const s2 = Wi(i22, o2);
          return !!s2 && (this._camera.orientation = s2, true);
        }
        _setCameraPosition(t22) {
          const i22 = this.zoomScale(this.minZoom) * this.tileSize, o2 = this.zoomScale(this.maxZoom) * this.tileSize, s2 = this.cameraToCenterDistance;
          t22[2] = e2.aD(t22[2], s2 / o2, s2 / i22), this._camera.position = t22;
        }
        get centerPoint() {
          return this._edgeInsets.getCenter(this.width, this.height);
        }
        get fovAboveCenter() {
          return this._fov * (0.5 + this.centerOffset.y / this.height);
        }
        isPaddingEqual(e22) {
          return this._edgeInsets.equals(e22);
        }
        interpolatePadding(e22, t22, i22) {
          this._unmodified = false, this._edgeInsets.interpolate(e22, t22, i22), this._constrain(), this._calcMatrices();
        }
        coveringZoomLevel(e22) {
          const t22 = (e22.roundZoom ? Math.round : Math.floor)(this.zoom + this.scaleZoom(this.tileSize / e22.tileSize));
          return Math.max(0, t22);
        }
        getVisibleUnwrappedCoordinates(t22) {
          const i22 = [new e2.cm(0, t22)];
          if (this.renderWorldCopies) {
            const o2 = this.pointCoordinate(new e2.P(0, 0)), s2 = this.pointCoordinate(new e2.P(this.width, 0)), r22 = this.pointCoordinate(new e2.P(this.width, this.height)), n22 = this.pointCoordinate(new e2.P(0, this.height)), a22 = Math.floor(Math.min(o2.x, s2.x, r22.x, n22.x)), l22 = Math.floor(Math.max(o2.x, s2.x, r22.x, n22.x)), c22 = 1;
            for (let o3 = a22 - c22; o3 <= l22 + c22; o3++) 0 !== o3 && i22.push(new e2.cm(o3, t22));
          }
          return i22;
        }
        isLODDisabled(e22) {
          return (!e22 || this.pitch <= 60) && this._edgeInsets.top <= this._edgeInsets.bottom && !this._elevation && !this.projection.isReprojectedInTileSpace;
        }
        extendTileCover(t22, i22, o2) {
          let s2 = [];
          const r22 = null != o2, n22 = !r22;
          if (n22 && this.zoom < i22) return s2;
          if (r22 && 0 === o2[0] && 0 === o2[1]) return s2;
          const a22 = /* @__PURE__ */ new Set(), l22 = (t3, i3, o3, r3, n3) => {
            const l3 = e2.cK(i3, t3, o3, r3, n3);
            a22.has(l3) || (s2.push(new e2.aM(t3, i3, o3, r3, n3)), a22.add(l3));
          };
          for (let e22 = 0; e22 < t22.length; e22++) {
            const s3 = t22[e22];
            if (n22 && s3.canonical.z !== i22) continue;
            const a3 = s3.canonical, c3 = s3.overscaledZ, h22 = s3.wrap, d22 = 1 << a3.z, u22 = a3.x + 1 < d22, _22 = a3.x > 0, p22 = a3.y + 1 < d22, f22 = a3.y > 0, m22 = s3.wrap - (_22 ? 0 : 1), g22 = s3.wrap + (u22 ? 0 : 1), v22 = _22 ? a3.x - 1 : d22 - 1, y22 = u22 ? a3.x + 1 : 0;
            if (r22) o2[0] < 0 ? (l22(c3, g22, a3.z, y22, a3.y), o2[1] < 0 && p22 && (l22(c3, h22, a3.z, a3.x, a3.y + 1), l22(c3, g22, a3.z, y22, a3.y + 1)), o2[1] > 0 && f22 && (l22(c3, h22, a3.z, a3.x, a3.y - 1), l22(c3, g22, a3.z, y22, a3.y - 1))) : o2[0] > 0 ? (l22(c3, m22, a3.z, v22, a3.y), o2[1] < 0 && p22 && (l22(c3, h22, a3.z, a3.x, a3.y + 1), l22(c3, m22, a3.z, v22, a3.y + 1)), o2[1] > 0 && f22 && (l22(c3, h22, a3.z, a3.x, a3.y - 1), l22(c3, m22, a3.z, v22, a3.y - 1))) : o2[1] < 0 && p22 ? l22(c3, h22, a3.z, a3.x, a3.y + 1) : f22 && l22(c3, h22, a3.z, a3.x, a3.y - 1);
            else {
              const e3 = s3.visibleQuadrants;
              1 & e3 && (l22(c3, m22, a3.z, v22, a3.y), f22 && (l22(c3, h22, a3.z, a3.x, a3.y - 1), l22(c3, m22, a3.z, v22, a3.y - 1))), 2 & e3 && (l22(c3, g22, a3.z, y22, a3.y), f22 && (l22(c3, h22, a3.z, a3.x, a3.y - 1), l22(c3, g22, a3.z, y22, a3.y - 1))), 4 & e3 && (l22(c3, m22, a3.z, v22, a3.y), p22 && (l22(c3, h22, a3.z, a3.x, a3.y + 1), l22(c3, m22, a3.z, v22, a3.y + 1))), 8 & e3 && (l22(c3, g22, a3.z, y22, a3.y), p22 && (l22(c3, h22, a3.z, a3.x, a3.y + 1), l22(c3, g22, a3.z, y22, a3.y + 1)));
            }
          }
          const c22 = [];
          for (const e22 of s2) s2.some((t3) => e22.isChildOf(t3)) || c22.push(e22);
          if (s2 = c22.filter((e22) => !t22.some((t3) => !!(e22.overscaledZ < i22 && t3.isChildOf(e22)) || e22.equals(t3) || e22.isChildOf(t3))), n22) {
            const e22 = 1 << i22, t3 = "globe" === this.projection.name ? this._camera.mercatorPosition : this.pointCoordinate(this.getCameraPoint()), o3 = [e22 * t3.x, e22 * t3.y], r3 = 4, n3 = r3 * r3;
            s2 = s2.filter((e3) => {
              const t4 = e3.canonical.x + 0.5 - o3[0], i3 = e3.canonical.y + 0.5 - o3[1];
              return t4 * t4 + i3 * i3 < n3;
            });
          }
          return s2;
        }
        coveringTiles(t22) {
          let i22 = this.coveringZoomLevel(t22);
          const o2 = i22, s2 = this.elevation && this.elevation.exaggeration(), r22 = s2 && !t22.isTerrainDEM, n22 = "mercator" === this.projection.name;
          if (void 0 !== t22.minzoom && i22 < t22.minzoom) return [];
          void 0 !== t22.maxzoom && i22 > t22.maxzoom && (i22 = t22.maxzoom);
          const a22 = this.locationCoordinate(this.center), l22 = this.center.lat, c22 = 1 << i22, h22 = [c22 * a22.x, c22 * a22.y, 0], d22 = "globe" === this.projection.name, u22 = !d22, _22 = e2.cn.fromInvProjectionMatrix(this.invProjMatrix, this.worldSize, i22, u22), p22 = d22 ? this._camera.mercatorPosition : this.pointCoordinate(this.getCameraPoint()), f22 = c22 * e2.c6(1, this.center.lat), m22 = this._camera.position[2] / e2.c6(1, this.center.lat), g22 = [c22 * p22.x, c22 * p22.y, m22 * (u22 ? 1 : f22)], v22 = d22 || s2, y22 = this.cameraToCenterDistance / t22.tileSize * (t22.roundZoom ? 1 : 0.502), x22 = this.isLODDisabled(true) ? i22 : 0;
          let b22;
          if (this._elevation && t22.isTerrainDEM) b22 = 1e4 * this._elevation.exaggeration();
          else if (this._elevation) {
            const e22 = this._elevation.getMinMaxForVisibleTiles();
            b22 = e22 ? e22.max : this._centerAltitude;
          } else b22 = this._centerAltitude;
          const w22 = t22.isTerrainDEM ? -b22 : this._elevation ? this._elevation.getMinElevationBelowMSL() : 0, T2 = this.projection.isReprojectedInTileSpace ? e2.co(this) : 1, E22 = (t3) => {
            const i3 = 1 / 4e4, o3 = new e2.ac(t3.x + i3, t3.y, t3.z), s3 = new e2.ac(t3.x, t3.y + i3, t3.z), r3 = t3.toLngLat(), n3 = o3.toLngLat(), a3 = s3.toLngLat(), l3 = this.locationCoordinate(r3), c3 = this.locationCoordinate(n3), h3 = this.locationCoordinate(a3), d3 = Math.hypot(c3.x - l3.x, c3.y - l3.y), u3 = Math.hypot(h3.x - l3.x, h3.y - l3.y);
            return Math.sqrt(d3 * u3) * T2 / i3;
          }, S2 = (t3) => {
            const i3 = b22, o3 = w22;
            return { aabb: e2.cr(this, c22, 0, 0, 0, t3, o3, i3, this.projection), zoom: 0, x: 0, y: 0, minZ: o3, maxZ: i3, wrap: t3, fullyVisible: false };
          }, I2 = [];
          let C22 = [];
          const R22 = i22, D22 = t22.reparseOverscaled ? o2 : i22, A22 = (m22 - this._centerAltitude) * f22, L22 = (e22) => {
            if (!this._elevation || !e22.tileID || !n22) return;
            const t3 = this._elevation.getMinMaxForTile(e22.tileID), i3 = e22.aabb;
            t3 ? (i3.min[2] = t3.min, i3.max[2] = t3.max, i3.center[2] = (i3.min[2] + i3.max[2]) / 2) : (e22.shouldSplit = z22(e22), e22.shouldSplit || (i3.min[2] = i3.max[2] = i3.center[2] = this._centerAltitude));
          }, P22 = (e22, t3) => {
            if (0.707 * t3 < e22) return 1;
            const i3 = t3 / e22;
            return i3 / (1.4144271570014144 + (Math.pow(1.1, i3 - 1.4144271570014144 + 1) - 1) / (1.1 - 1) - 1);
          }, z22 = (t3) => {
            if (t3.zoom < x22) return true;
            if (t3.zoom === R22) return false;
            if (null != t3.shouldSplit) return t3.shouldSplit;
            const i3 = t3.aabb.distanceX(g22), s3 = t3.aabb.distanceY(g22);
            let a3 = A22, c3 = 1;
            if (d22) {
              a3 = t3.aabb.distanceZ(g22);
              const i4 = Math.pow(2, t3.zoom), o3 = e2.aY((t3.y + 1) / i4), s4 = e2.aY(t3.y / i4), r3 = Math.min(Math.max(l22, o3), s4), n3 = e2.cP(r3) / e2.cP(l22);
              if (c3 = r3 === l22 ? 1 / Math.max(1, this._mercatorScaleRatio - 0.3) : Math.min(1, n3 / this._mercatorScaleRatio), this.zoom <= e2.cL && t3.zoom === R22 - 1 && n3 >= 0.9) return true;
            } else if (r22 && (a3 = t3.aabb.distanceZ(g22) * f22), this.projection.isReprojectedInTileSpace && o2 <= 5) {
              const i4 = Math.pow(2, t3.zoom), o3 = E22(new e2.ac((t3.x + 0.5) / i4, (t3.y + 0.5) / i4));
              c3 = o3 > 0.85 ? 1 : o3;
            }
            if (!n22) {
              const e22 = Math.sqrt(i3 * i3 + s3 * s3 + a3 * a3);
              let o3 = (1 << R22 - t3.zoom) * y22 * c3;
              return o3 *= P22(Math.max(a3, A22), e22), e22 < o3;
            }
            let u3 = Number.MAX_VALUE, _3 = 0;
            const p3 = t3.aabb.getCorners(), m3 = [];
            for (const t4 of p3) {
              e2.at(m3, t4, g22), d22 || (r22 ? m3[2] *= f22 : m3[2] = A22);
              const i4 = e2.bE(m3, this._camera.forward());
              i4 < u3 && (u3 = i4, _3 = Math.abs(m3[2]));
            }
            let v3 = (1 << R22 - t3.zoom) * y22 * c3;
            if (v3 *= P22(Math.max(_3, A22), u3), u3 < v3) return true;
            const b3 = t3.aabb.closestPoint(h22);
            return b3[0] === h22[0] && b3[1] === h22[1];
          };
          if (this.renderWorldCopies) for (let e22 = 1; e22 <= 3; e22++) I2.push(S2(-e22)), I2.push(S2(e22));
          for (I2.push(S2(0)); I2.length > 0; ) {
            const o3 = I2.pop(), s3 = o3.x, a3 = o3.y;
            let l3 = o3.fullyVisible;
            const u3 = () => "globe" === this.projection.name && (0 === o3.y || o3.y === (1 << o3.zoom) - 1);
            if (!l3) {
              let t3 = v22 ? o3.aabb.intersects(_22) : o3.aabb.intersectsFlat(_22);
              if (0 === t3 && u3()) {
                const i3 = new e2.cp(o3.zoom, s3, a3);
                t3 = e2.cq(this, c22, i3, true).intersects(_22);
              }
              if (0 === t3) continue;
              l3 = 2 === t3;
            }
            if (o3.zoom !== R22 && z22(o3)) for (let t3 = 0; t3 < 4; t3++) {
              const i3 = (s3 << 1) + t3 % 2, h3 = (a3 << 1) + (t3 >> 1), u4 = { aabb: n22 ? o3.aabb.quadrant(t3) : e2.cr(this, c22, o3.zoom + 1, i3, h3, o3.wrap, o3.minZ, o3.maxZ, this.projection), zoom: o3.zoom + 1, x: i3, y: h3, wrap: o3.wrap, fullyVisible: l3, tileID: void 0, shouldSplit: void 0, minZ: o3.minZ, maxZ: o3.maxZ };
              r22 && !d22 && (u4.tileID = new e2.aM(o3.zoom + 1 === R22 ? D22 : o3.zoom + 1, o3.wrap, o3.zoom + 1, i3, h3), L22(u4)), I2.push(u4);
            }
            else {
              const r3 = o3.zoom === R22 ? D22 : o3.zoom;
              if (t22.minzoom && t22.minzoom > r3) continue;
              let n3 = 0;
              if (!l3) {
                let i3 = v22 ? o3.aabb.intersectsPrecise(_22) : o3.aabb.intersectsPreciseFlat(_22);
                if (0 === i3 && u3()) {
                  const t3 = new e2.cp(o3.zoom, s3, a3);
                  i3 = e2.cq(this, c22, t3, true).intersectsPrecise(_22);
                }
                if (0 === i3) continue;
                if (t22.calculateQuadrantVisibility) if (_22.containsPoint(o3.aabb.center)) n3 = 15;
                else for (let e22 = 0; e22 < 4; e22++) 0 !== o3.aabb.quadrant(e22).intersects(_22) && (n3 |= 1 << e22);
              }
              const d3 = h22[0] - (0.5 + s3 + (o3.wrap << o3.zoom)) * (1 << i22 - o3.zoom), p3 = h22[1] - 0.5 - a3, f3 = o3.tileID ? o3.tileID : new e2.aM(r3, o3.wrap, o3.zoom, s3, a3);
              t22.calculateQuadrantVisibility && (f3.visibleQuadrants = n3), C22.push({ tileID: f3, distanceSq: d3 * d3 + p3 * p3 });
            }
          }
          if (this.fogCullDistSq) {
            const i3 = this.fogCullDistSq, o3 = this.horizonLineFromTop();
            C22 = C22.filter((s3) => {
              const r3 = [0, 0, 0, 1], n3 = [e2.aj, e2.aj, 0, 1], a3 = this.calculateFogTileMatrix(s3.tileID.toUnwrapped());
              e2.aA(r3, r3, a3), e2.aA(n3, n3, a3);
              const l3 = e2.cs([], r3, n3), c3 = e2.ct([], r3, n3), h3 = e2.cM(l3, c3);
              if (0 === h3) return true;
              let d3 = false;
              const u3 = this._elevation;
              if (u3 && h3 > i3 && 0 !== o3) {
                const i4 = this.calculateProjMatrix(s3.tileID.toUnwrapped());
                let r4;
                t22.isTerrainDEM || (r4 = u3.getMinMaxForTile(s3.tileID)), r4 || (r4 = { min: w22, max: b22 });
                const n4 = e2.cu(this.rotation), a4 = [n4[0] * e2.aj, n4[1] * e2.aj, r4.max];
                e2.ad(a4, a4, i4), d3 = (1 - a4[1]) * this.height * 0.5 < o3;
              }
              return h3 < i3 || d3;
            });
          }
          return C22.sort((e22, t3) => e22.distanceSq - t3.distanceSq).map((e22) => e22.tileID);
        }
        resize(e22, t22) {
          this.width = e22, this.height = t22, this.pixelsToGLUnits = [2 / e22, -2 / t22], this._constrain(), this._calcMatrices();
        }
        get unmodified() {
          return this._unmodified;
        }
        zoomScale(e22) {
          return Math.pow(2, e22);
        }
        scaleZoom(e22) {
          return Math.log(e22) / Math.LN2;
        }
        project(t22) {
          const i22 = e2.aD(t22.lat, -e2.cv, e2.cv), o2 = this.projection.project(t22.lng, i22);
          return new e2.P(o2.x * this.worldSize, o2.y * this.worldSize);
        }
        unproject(e22) {
          return this.projection.unproject(e22.x / this.worldSize, e22.y / this.worldSize);
        }
        get point() {
          return this.project(this.center);
        }
        get pointMerc() {
          return this.point._div(this.worldSize);
        }
        get pixelsPerMeterRatio() {
          return this.pixelsPerMeter / e2.c6(1, this.center.lat) / this.worldSize;
        }
        setLocationAtPoint(t22, i22) {
          let o2, s2;
          const r22 = this.centerPoint;
          if ("globe" === this.projection.name) {
            const e22 = this.worldSize;
            o2 = (i22.x - r22.x) / e22, s2 = (i22.y - r22.y) / e22;
          } else {
            const e22 = this.pointCoordinate(i22), t3 = this.pointCoordinate(r22);
            o2 = e22.x - t3.x, s2 = e22.y - t3.y;
          }
          const n22 = this.locationCoordinate(t22);
          this.setLocation(new e2.ac(n22.x - o2, n22.y - s2));
        }
        setLocation(e22) {
          this.center = this.coordinateLocation(e22), this.projection.wrap && (this.center = this.center.wrap());
        }
        locationPoint(e22, t22) {
          return this.projection.locationPoint(this, e22, t22);
        }
        locationPoint3D(e22, t22) {
          return this.projection.locationPoint(this, e22, t22, true);
        }
        pointLocation(e22) {
          return this.coordinateLocation(this.pointCoordinate(e22));
        }
        pointLocation3D(e22, t22) {
          return this.coordinateLocation(this.pointCoordinate3D(e22, t22));
        }
        locationCoordinate(t22, i22) {
          const o2 = i22 ? e2.c6(i22, t22.lat) : void 0, s2 = this.projection.project(t22.lng, t22.lat);
          return new e2.ac(s2.x, s2.y, o2);
        }
        coordinateLocation(e22) {
          return this.projection.unproject(e22.x, e22.y);
        }
        pointRayIntersection(t22, i22) {
          const o2 = null != i22 ? i22 : this._centerAltitude, s2 = [t22.x, t22.y, 0, 1], r22 = [t22.x, t22.y, 1, 1];
          e2.aA(s2, s2, this.pixelMatrixInverse), e2.aA(r22, r22, this.pixelMatrixInverse);
          const n22 = r22[3];
          e2.cw(s2, s2, 1 / s2[3]), e2.cw(r22, r22, 1 / n22);
          const a22 = s2[2], l22 = r22[2];
          return { p0: s2, p1: r22, t: a22 === l22 ? 0 : (o2 - a22) / (l22 - a22) };
        }
        screenPointToMercatorRay(t22) {
          const i22 = [t22.x, t22.y, 0, 1], o2 = [t22.x, t22.y, 1, 1];
          return e2.aA(i22, i22, this.pixelMatrixInverse), e2.aA(o2, o2, this.pixelMatrixInverse), e2.cw(i22, i22, 1 / i22[3]), e2.cw(o2, o2, 1 / o2[3]), i22[2] = e2.c6(i22[2], this._center.lat) * this.worldSize, o2[2] = e2.c6(o2[2], this._center.lat) * this.worldSize, e2.cw(i22, i22, 1 / this.worldSize), e2.cw(o2, o2, 1 / this.worldSize), new e2.av([i22[0], i22[1], i22[2]], e2.au([], e2.at([], o2, i22)));
        }
        rayIntersectionCoordinate(t22) {
          const { p0: i22, p1: o2, t: s2 } = t22, r22 = e2.c6(i22[2], this._center.lat), n22 = e2.c6(o2[2], this._center.lat);
          return new e2.ac(e2.ai(i22[0], o2[0], s2) / this.worldSize, e2.ai(i22[1], o2[1], s2) / this.worldSize, e2.ai(r22, n22, s2));
        }
        pointCoordinate(e22, t22 = this._centerAltitude) {
          return this.projection.pointCoordinate(this, e22.x, e22.y, t22);
        }
        pointCoordinate3D(t22, i22) {
          if (!this.elevation) return this.pointCoordinate(t22, i22);
          let o2 = this.projection.pointCoordinate3D(this, t22.x, t22.y);
          if (o2) return new e2.ac(o2[0], o2[1], o2[2]);
          let s2 = 0, r22 = this.horizonLineFromTop();
          if (t22.y > r22) return this.pointCoordinate(t22, i22);
          const n22 = 0.02 * r22, a22 = t22.clone();
          for (let t3 = 0; t3 < 10 && r22 - s2 > n22; t3++) {
            a22.y = e2.ai(s2, r22, 0.66);
            const t4 = this.projection.pointCoordinate3D(this, a22.x, a22.y);
            t4 ? (r22 = a22.y, o2 = t4) : s2 = a22.y;
          }
          return o2 ? new e2.ac(o2[0], o2[1], o2[2]) : this.pointCoordinate(t22);
        }
        isPointAboveHorizon(e22) {
          return this.projection.isPointAboveHorizon(this, e22);
        }
        isPointOnSurface(t22) {
          if (t22.y < 0 || t22.y > this.height || t22.x < 0 || t22.x > this.width) return false;
          if (this.elevation || this.zoom >= e2.cx) return !this.isPointAboveHorizon(t22);
          const i22 = this.pointCoordinate(t22);
          return i22.y >= 0 && i22.y <= 1;
        }
        _coordinatePoint(t22, i22) {
          const o2 = i22 && this.elevation ? this.elevation.getAtPointOrZero(t22, this._centerAltitude) : this._centerAltitude, s2 = [t22.x * this.worldSize, t22.y * this.worldSize, o2 + t22.toAltitude(), 1];
          return e2.aA(s2, s2, this.pixelMatrix), s2[3] > 0 ? new e2.P(s2[0] / s2[3], s2[1] / s2[3]) : new e2.P(Number.MAX_VALUE, Number.MAX_VALUE);
        }
        _getBoundsNonRectangular() {
          const { top: t22, left: i22 } = this._edgeInsets, o2 = this.height - this._edgeInsets.bottom, s2 = this.width - this._edgeInsets.right, r22 = this.pointLocation3D(new e2.P(i22, t22)), n22 = this.pointLocation3D(new e2.P(s2, t22)), a22 = this.pointLocation3D(new e2.P(s2, o2)), l22 = this.pointLocation3D(new e2.P(i22, o2));
          let c22 = Math.min(r22.lng, n22.lng, a22.lng, l22.lng), h22 = Math.max(r22.lng, n22.lng, a22.lng, l22.lng), d22 = Math.min(r22.lat, n22.lat, a22.lat, l22.lat), u22 = Math.max(r22.lat, n22.lat, a22.lat, l22.lat);
          const _22 = Math.pow(2, -this.zoom) / 16 * 270, p22 = "globe" === this.projection.name ? 1 : 4, f22 = (t3, i3, o3, s3, r3) => {
            const n3 = (t3 + o3) / 2, a3 = (i3 + s3) / 2, l3 = new e2.P(n3, a3), { lng: m22, lat: g22 } = this.pointLocation3D(l3), v22 = Math.max(0, c22 - m22, d22 - g22, m22 - h22, g22 - u22);
            c22 = Math.min(c22, m22), h22 = Math.max(h22, m22), d22 = Math.min(d22, g22), u22 = Math.max(u22, g22), (r3 < p22 || v22 > _22) && (f22(t3, i3, n3, a3, r3 + 1), f22(n3, a3, o3, s3, r3 + 1));
          };
          if (f22(i22, t22, s2, t22, 1), f22(s2, t22, s2, o2, 1), f22(s2, o2, i22, o2, 1), f22(i22, o2, i22, t22, 1), "globe" === this.projection.name) {
            const [t3, i3] = e2.cy(this);
            t3 ? (u22 = 90, h22 = 180, c22 = -180) : i3 && (d22 = -90, h22 = 180, c22 = -180);
          }
          return new e2.aG(new e2.cd(c22, d22), new e2.cd(h22, u22));
        }
        _getBoundsRectangular(t22, i22) {
          const { top: o2, left: s2 } = this._edgeInsets, r22 = this.height - this._edgeInsets.bottom, n22 = this.width - this._edgeInsets.right, a22 = new e2.P(s2, o2), l22 = new e2.P(n22, o2), c22 = new e2.P(n22, r22), h22 = new e2.P(s2, r22);
          let d22 = this.pointCoordinate(a22, t22), u22 = this.pointCoordinate(l22, t22);
          const _22 = this.pointCoordinate(c22, i22), p22 = this.pointCoordinate(h22, i22), f22 = (e22, t3) => (t3.y - e22.y) / (t3.x - e22.x);
          return d22.y > 1 && u22.y >= 0 ? d22 = new e2.ac((1 - p22.y) / f22(p22, d22) + p22.x, 1) : d22.y < 0 && u22.y <= 1 && (d22 = new e2.ac(-p22.y / f22(p22, d22) + p22.x, 0)), u22.y > 1 && d22.y >= 0 ? u22 = new e2.ac((1 - _22.y) / f22(_22, u22) + _22.x, 1) : u22.y < 0 && d22.y <= 1 && (u22 = new e2.ac(-_22.y / f22(_22, u22) + _22.x, 0)), new e2.aG().extend(this.coordinateLocation(d22)).extend(this.coordinateLocation(u22)).extend(this.coordinateLocation(p22)).extend(this.coordinateLocation(_22));
        }
        _getBoundsRectangularTerrain() {
          const e22 = this.elevation;
          if (!e22.visibleDemTiles.length || e22.isUsingMockSource()) return this._getBoundsRectangular(0, 0);
          const t22 = e22.visibleDemTiles.reduce((e3, t3) => {
            if (t3.dem) {
              const i22 = t3.dem.tree;
              e3.min = Math.min(e3.min, i22.minimums[0]), e3.max = Math.max(e3.max, i22.maximums[0]);
            }
            return e3;
          }, { min: Number.MAX_VALUE, max: 0 });
          return this._getBoundsRectangular(t22.min * e22.exaggeration(), t22.max * e22.exaggeration());
        }
        getBounds() {
          return "mercator" === this.projection.name || "equirectangular" === this.projection.name ? this._terrainEnabled() ? this._getBoundsRectangularTerrain() : this._getBoundsRectangular(0, 0) : this._getBoundsNonRectangular();
        }
        horizonLineFromTop(e22 = true) {
          const t22 = this.height / 2 / Math.tan(this._fov / 2) / Math.tan(Math.max(this._pitch, 0.1)) - this.centerOffset.y, i22 = this.height / 2 - t22 * (1 - this._horizonShift);
          return e22 ? Math.max(0, i22) : i22;
        }
        getMaxBounds() {
          return this.maxBounds;
        }
        setMaxBounds(t22) {
          this.maxBounds = t22, this.minLat = -e2.cv, this.maxLat = e2.cv, this.minLng = -180, this.maxLng = 180, t22 && (this.minLat = t22.getSouth(), this.maxLat = t22.getNorth(), this.minLng = t22.getWest(), this.maxLng = t22.getEast(), this.maxLng < this.minLng && (this.maxLng += 360)), this.worldMinX = e2.ay(this.minLng) * this.tileSize, this.worldMaxX = e2.ay(this.maxLng) * this.tileSize, this.worldMinY = e2.aH(this.maxLat) * this.tileSize, this.worldMaxY = e2.aH(this.minLat) * this.tileSize, this._constrain();
        }
        calculatePosMatrix(e22, t22) {
          return this.projection.createTileMatrix(this, t22, e22);
        }
        calculateDistanceTileData(t22) {
          const i22 = t22.key, o2 = this._distanceTileDataCache;
          if (o2[i22]) return o2[i22];
          const s2 = t22.canonical, r22 = 1 / this.height, n22 = this.cameraWorldSize, a22 = n22 / this.zoomScale(s2.z), l22 = (s2.x + Math.pow(2, s2.z) * t22.wrap) * a22, c22 = s2.y * a22, h22 = this.point;
          h22.x *= n22 / this.worldSize, h22.y *= n22 / this.worldSize;
          const d22 = this.angle, u22 = Math.sin(-d22), _22 = -Math.cos(-d22);
          return o2[i22] = { bearing: [u22, _22], center: [(h22.x - l22) * r22, (h22.y - c22) * r22], scale: a22 / e2.aj * r22 }, o2[i22];
        }
        calculateFogTileMatrix(t22) {
          const i22 = t22.key, o2 = this._fogTileMatrixCache;
          if (o2[i22]) return o2[i22];
          const s2 = this.projection.createTileMatrix(this, this.cameraWorldSizeForFog, t22);
          return e2.az(s2, this.worldToFogMatrix, s2), o2[i22] = new Float32Array(s2), o2[i22];
        }
        calculateProjMatrix(t22, i22 = false, o2 = false) {
          const s2 = t22.key;
          let r22;
          if (r22 = o2 ? this._expandedProjMatrixCache : i22 ? this._alignedProjMatrixCache : this._projMatrixCache, r22[s2]) return r22[s2];
          const n22 = this.calculatePosMatrix(t22, this.worldSize);
          let a22;
          return a22 = this.projection.isReprojectedInTileSpace ? this.mercatorMatrix : o2 ? this.expandedFarZProjMatrix : i22 ? this.alignedProjMatrix : this.projMatrix, e2.az(n22, a22, n22), r22[s2] = new Float32Array(n22), r22[s2];
        }
        calculatePixelsToTileUnitsMatrix(t22) {
          const i22 = t22.tileID.key, o2 = this._pixelsToTileUnitsCache;
          if (o2[i22]) return o2[i22];
          const s2 = e2.cz(t22, this);
          return o2[i22] = s2, o2[i22];
        }
        customLayerMatrix() {
          return this.mercatorMatrix.slice();
        }
        globeToMercatorMatrix() {
          if ("globe" === this.projection.name) {
            const t22 = 1 / this.worldSize, i22 = e2.bn([], [t22, t22, t22]);
            return e2.az(i22, i22, this.globeMatrix), i22;
          }
        }
        recenterOnTerrain() {
          if (!this._elevation || "globe" === this.projection.name) return;
          const t22 = this._elevation;
          this._updateCameraState();
          const i22 = e2.c6(1, this._center.lat) * this.worldSize, o2 = this._computeCameraPosition(i22), s2 = this._camera.forward(), r22 = e2.c6(1, this._center.lat);
          o2[2] /= r22, s2[2] /= r22, e2.au(s2, s2);
          const n22 = t22.raycast(o2, s2, t22.exaggeration());
          if (n22) {
            const t3 = e2.bF([], o2, s2, n22), i3 = new e2.ac(t3[0], t3[1], e2.c6(t3[2], e2.aY(t3[1]))), a22 = (i3.z + e2.ae([i3.x - o2[0], i3.y - o2[1], i3.z - o2[2] * r22])) * this._pixelsPerMercatorPixel;
            this._seaLevelZoom = this._zoomFromMercatorZ(a22), this._centerAltitude = i3.toAltitude(), this._center = this.coordinateLocation(i3), this._updateZoomFromElevation(), this._constrain(), this._calcMatrices();
          }
        }
        _constrainCamera(t22 = false) {
          if (!this._elevation) return;
          const i22 = this._elevation, o2 = e2.c6(1, this._center.lat) * this.worldSize, s2 = this._computeCameraPosition(o2), r22 = i22.getAtPointOrZero(new e2.ac(...s2)), n22 = this.pixelsPerMeter / this.worldSize * r22, a22 = this._minimumHeightOverTerrain(), l22 = s2[2] - n22;
          if (l22 <= a22) if (l22 < 0 || t22) {
            const t3 = this.locationCoordinate(this._center, this._centerAltitude), i3 = [s2[0], s2[1], t3.z - s2[2]], o3 = e2.ae(i3);
            i3[2] -= (a22 - l22) / this._pixelsPerMercatorPixel;
            const r3 = e2.ae(i3);
            if (0 === r3) return;
            e2.b$(i3, i3, o3 / r3 * this._pixelsPerMercatorPixel), this._camera.position = [s2[0], s2[1], t3.z * this._pixelsPerMercatorPixel - i3[2]], this._updateStateFromCamera();
          } else this._isCameraConstrained = true;
        }
        _constrain() {
          if (!this.center || !this.width || !this.height || this._constraining) return;
          this._constraining = true;
          const t22 = "globe" === this.projection.name || this.mercatorFromTransition;
          if (this.projection.isReprojectedInTileSpace || t22) {
            const i3 = this.center;
            return i3.lat = e2.aD(i3.lat, this.minLat, this.maxLat), (this.maxBounds || !this.renderWorldCopies && !t22) && (i3.lng = e2.aD(i3.lng, this.minLng, this.maxLng)), this.center = i3, void (this._constraining = false);
          }
          const i22 = this._unmodified, { x: o2, y: s2 } = this.point;
          let r22 = 0, n22 = o2, a22 = s2;
          const l22 = this.width / 2, c22 = this.height / 2, h22 = this.worldMinY * this.scale, d22 = this.worldMaxY * this.scale;
          if (s2 - c22 < h22 && (a22 = h22 + c22), s2 + c22 > d22 && (a22 = d22 - c22), d22 - h22 < this.height && (r22 = Math.max(r22, this.height / (d22 - h22)), a22 = (d22 + h22) / 2), this.maxBounds || !this._renderWorldCopies || !this.projection.wrap) {
            const e22 = this.worldMinX * this.scale, t3 = this.worldMaxX * this.scale, i3 = this.worldSize / 2 - (e22 + t3) / 2;
            n22 = (o2 + i3 + this.worldSize) % this.worldSize - i3, n22 - l22 < e22 && (n22 = e22 + l22), n22 + l22 > t3 && (n22 = t3 - l22), t3 - e22 < this.width && (r22 = Math.max(r22, this.width / (t3 - e22)), n22 = (t3 + e22) / 2);
          }
          n22 === o2 && a22 === s2 || this._allowWorldUnderZoom || (this.center = this.unproject(new e2.P(n22, a22))), r22 && !this._allowWorldUnderZoom && (this.zoom += this.scaleZoom(r22)), this._constrainCamera(), this._unmodified = i22, this._constraining = false;
        }
        _minZoomForBounds() {
          let e22 = Math.max(0, this.scaleZoom(this.height / (this.worldMaxY - this.worldMinY)));
          return this.maxBounds && (e22 = Math.max(e22, this.scaleZoom(this.width / (this.worldMaxX - this.worldMinX)))), e22;
        }
        _maxCameraBoundsDistance() {
          return this._mercatorZfromZoom(this._minZoomForBounds());
        }
        _calcMatrices() {
          if (!this.height) return;
          const t22 = this.centerOffset, i22 = "globe" === this.projection.name, o2 = this.pixelsPerMeter;
          "globe" === this.projection.name && (this._mercatorScaleRatio = e2.c6(1, this.center.lat) / e2.c6(1, e2.cN));
          const s2 = e2.cA(this.projection, this.zoom, this.width, this.height, 1024);
          this._pixelsPerMercatorPixel = this.projection.pixelSpaceConversion(this.center.lat, this.worldSize, s2), this.cameraToCenterDistance = 0.5 / Math.tan(0.5 * this._fov) * this.height * this._pixelsPerMercatorPixel, this._updateCameraState(), this._farZ = this.projection.farthestPixelDistance(this), this._nearZ = this.height / 50;
          const r22 = "meters" === this.projection.zAxisUnit ? o2 : 1, n22 = this._camera.getWorldToCamera(this.worldSize, r22);
          let a22;
          const l22 = this._camera.getCameraToClipPerspective(this._fov, this.width / this.height, this._nearZ, this._farZ);
          if (l22[8] = 2 * -t22.x / this.width, l22[9] = 2 * t22.y / this.height, this.isOrthographic) {
            let i3 = 0.5 * this.height / Math.tan(this._fov / 2) * 1 * Math.tan(0.5 * this._fov), o3 = i3 * this.aspect, s3 = -o3, r3 = -i3;
            o3 -= t22.x, s3 -= t22.x, i3 += t22.y, r3 += t22.y, a22 = this._camera.getCameraToClipOrthographic(s3, o3, r3, i3, this._nearZ, this._farZ), ((t3, i4, o4, s4) => {
              for (let r4 = 0; r4 < 16; r4++) t3[r4] = e2.ai(i4[r4], o4[r4], s4);
            })(a22, a22, l22, e2.cO(this.pitch >= Ji ? 1 : this.pitch / Ji));
          } else a22 = l22;
          const c22 = e2.cB([], l22, n22);
          let h22 = e2.cB([], a22, n22);
          if (this.projection.isReprojectedInTileSpace) {
            const t3 = this.locationCoordinate(this.center), i3 = e2.bx([]);
            e2.bo(i3, i3, [t3.x * this.worldSize, t3.y * this.worldSize, 0]), e2.az(i3, i3, e2.cC(this)), e2.bo(i3, i3, [-t3.x * this.worldSize, -t3.y * this.worldSize, 0]), e2.az(h22, h22, i3), e2.az(c22, c22, i3), this.inverseAdjustmentMatrix = e2.cD(this);
          } else this.inverseAdjustmentMatrix = [1, 0, 0, 1];
          if (this.mercatorMatrix = e2.cE([], h22, [this.worldSize, this.worldSize, this.worldSize / r22, 1]), this.projMatrix = h22, this.invProjMatrix = e2.bi(new Float64Array(16), this.projMatrix), i22) {
            const i3 = this._camera.getCameraToClipPerspective(this._fov, this.width / this.height, this._nearZ, 1 / 0);
            i3[8] = 2 * -t22.x / this.width, i3[9] = 2 * t22.y / this.height, this.expandedFarZProjMatrix = e2.cB([], i3, n22);
          } else this.expandedFarZProjMatrix = this.projMatrix;
          const d22 = e2.bi([], a22);
          this.frustumCorners = e2.cF.fromInvProjectionMatrix(d22, this.horizonLineFromTop(), this.height), this.cameraFrustum = e2.cn.fromInvProjectionMatrix(this.invProjMatrix, this.worldSize, 0, !i22);
          const u22 = new Float32Array(16);
          e2.bx(u22), e2.cE(u22, u22, [1, -1, 1]), e2.cG(u22, u22, this._pitch), e2.by(u22, u22, this.angle);
          const _22 = e2.c4(new Float32Array(16), this._fov, this.width / this.height, this._nearZ, this._farZ);
          this.starsProjMatrix = e2.bw(_22);
          const p22 = (Math.PI / 2 - this._pitch) * (this.height / this._fov) * this._horizonShift;
          _22[8] = 2 * -t22.x / this.width, _22[9] = 2 * (t22.y + p22) / this.height, this.skyboxMatrix = e2.az(u22, _22, u22);
          const f22 = this.point, m22 = f22.x, g22 = f22.y, v22 = this.width % 2 / 2, y22 = this.height % 2 / 2, x22 = Math.cos(this.angle), b22 = Math.sin(this.angle), w22 = m22 - Math.round(m22) + x22 * v22 + b22 * y22, T2 = g22 - Math.round(g22) + x22 * y22 + b22 * v22, E22 = new Float64Array(h22);
          if (e2.bo(E22, E22, [w22 > 0.5 ? w22 - 1 : w22, T2 > 0.5 ? T2 - 1 : T2, 0]), this.alignedProjMatrix = E22, h22 = e2.bz(), e2.cE(h22, h22, [this.width / 2, -this.height / 2, 1]), e2.bo(h22, h22, [1, -1, 0]), this.labelPlaneMatrix = h22, h22 = e2.bz(), e2.cE(h22, h22, [1, -1, 1]), e2.bo(h22, h22, [-1, -1, 0]), e2.cE(h22, h22, [2 / this.width, 2 / this.height, 1]), this.glCoordMatrix = h22, this.pixelMatrix = e2.az(new Float64Array(16), this.labelPlaneMatrix, c22), this._calcFogMatrices(), this._distanceTileDataCache = {}, h22 = e2.bi(new Float64Array(16), this.pixelMatrix), !h22) throw new Error("failed to invert matrix");
          if (this.pixelMatrixInverse = h22, "globe" === this.projection.name || this.mercatorFromTransition) {
            this.globeMatrix = e2.cH(this);
            const t3 = [this.globeMatrix[12], this.globeMatrix[13], this.globeMatrix[14]];
            this.globeCenterInViewSpace = e2.ad(t3, t3, n22), this.globeRadius = this.worldSize / 2 / Math.PI - 1;
          } else this.globeMatrix = h22;
          this._projMatrixCache = {}, this._alignedProjMatrixCache = {}, this._pixelsToTileUnitsCache = {}, this._expandedProjMatrixCache = {};
        }
        _calcFogMatrices() {
          this._fogTileMatrixCache = {};
          const t22 = this.cameraWorldSizeForFog, i22 = this.cameraPixelsPerMeter, o2 = this._camera.position, s2 = 1 / this.height / this._pixelsPerMercatorPixel, r22 = [t22, t22, i22];
          e2.b$(r22, r22, s2), e2.b$(o2, o2, -1), e2.cI(o2, o2, r22);
          const n22 = e2.bz();
          e2.bo(n22, n22, o2), e2.cE(n22, n22, r22), this.mercatorFogMatrix = n22, this.worldToFogMatrix = this._camera.getWorldToCameraPosition(t22, i22, s2);
        }
        _computeCameraPosition(e22) {
          const t22 = (e22 = e22 || this.pixelsPerMeter) / this.pixelsPerMeter, i22 = this._camera.forward(), o2 = this.point, s2 = this._mercatorZfromZoom(this._seaLevelZoom ? this._seaLevelZoom : this._zoom) * t22 - e22 / this.worldSize * this._centerAltitude;
          return [o2.x / this.worldSize - i22[0] * s2, o2.y / this.worldSize - i22[1] * s2, e22 / this.worldSize * this._centerAltitude - i22[2] * s2];
        }
        _updateCameraState() {
          this.height && (this._camera.setPitchBearing(this._pitch, this.angle), this._camera.position = this._computeCameraPosition());
        }
        _translateCameraConstrained(t22) {
          const i22 = this._maxCameraBoundsDistance() * Math.cos(this._pitch), o2 = this._camera.position[2], s2 = t22[2];
          let r22 = 1;
          this.projection.wrap && (this.center = this.center.wrap()), s2 > 0 && (r22 = Math.min((i22 - o2) / s2, 1)), this._camera.position = e2.bF([], this._camera.position, t22, r22), this._updateStateFromCamera();
        }
        _updateStateFromCamera() {
          const t22 = this._camera.position, i22 = this._camera.forward(), { pitch: o2, bearing: s2 } = this._camera.getPitchBearing(), r22 = e2.c6(this._centerAltitude, this.center.lat) * this._pixelsPerMercatorPixel, n22 = this._mercatorZfromZoom(this._maxZoom) * Math.cos(e2.al(this._maxPitch)), a22 = Math.max((t22[2] - r22) / Math.cos(o2), n22), l22 = this._zoomFromMercatorZ(a22);
          e2.bF(t22, t22, i22, a22), this._pitch = e2.aD(o2, e2.al(this.minPitch), e2.al(this.maxPitch)), this.angle = e2.bX(s2, -Math.PI, Math.PI), this._setZoom(e2.aD(l22, this._minZoom, this._maxZoom)), this._updateSeaLevelZoom(), this._center = this.coordinateLocation(new e2.ac(t22[0], t22[1], t22[2])), this._unmodified = false, this._constrain(), this._calcMatrices();
        }
        _worldSizeFromZoom(e22) {
          return Math.pow(2, e22) * this.tileSize;
        }
        _mercatorZfromZoom(e22) {
          return this.cameraToCenterDistance / this._worldSizeFromZoom(e22);
        }
        _minimumHeightOverTerrain() {
          const e22 = Math.min(null != this._seaLevelZoom ? this._seaLevelZoom : this._zoom, this._maxZoom) + 4;
          return this._mercatorZfromZoom(e22);
        }
        _zoomFromMercatorZ(e22) {
          return this.scaleZoom(this.cameraToCenterDistance / (e22 * this.tileSize));
        }
        zoomFromMercatorZAdjusted(t22) {
          let i22 = 0, o2 = e2.cx, s2 = 0, r22 = 1 / 0;
          for (; o2 - i22 > 1e-6 && o2 > i22; ) {
            const e22 = i22 + 0.5 * (o2 - i22), n22 = this.tileSize * Math.pow(2, e22), a22 = this.getCameraToCenterDistance(this.projection, e22, n22), l22 = this.scaleZoom(a22 / (t22 * this.tileSize)), c22 = Math.abs(e22 - l22);
            c22 < r22 && (r22 = c22, s2 = e22), e22 < l22 ? i22 = e22 : o2 = e22;
          }
          return s2;
        }
        _terrainEnabled() {
          return !(!this._elevation || !this.projection.supportsTerrain && (e2.w("Terrain is not yet supported with alternate projections. Use mercator or globe to enable terrain."), 1));
        }
        anyCornerOffEdge(t22, i22) {
          const o2 = Math.min(t22.x, i22.x), s2 = Math.max(t22.x, i22.x), r22 = Math.min(t22.y, i22.y), n22 = Math.max(t22.y, i22.y);
          if (r22 < this.horizonLineFromTop(false)) return true;
          if ("mercator" !== this.projection.name) return false;
          const a22 = [new e2.P(o2, r22), new e2.P(s2, n22), new e2.P(o2, n22), new e2.P(s2, r22)], l22 = this.renderWorldCopies ? -3 : 0, c22 = this.renderWorldCopies ? 4 : 1;
          for (const e22 of a22) {
            const t3 = this.pointRayIntersection(e22);
            if (t3.t < 0) return true;
            const i3 = this.rayIntersectionCoordinate(t3);
            if (i3.x < l22 || i3.y < 0 || i3.x > c22 || i3.y > 1) return true;
          }
          return false;
        }
        isHorizonVisible() {
          return this.pitch + e2.cJ(this.fovAboveCenter) > 88 || this.anyCornerOffEdge(new e2.P(0, 0), new e2.P(this.width, this.height));
        }
        zoomDeltaToMovement(t22, i22) {
          const o2 = e2.ae(e2.at([], this._camera.position, t22)), s2 = this._zoomFromMercatorZ(o2) + i22;
          return o2 - this._mercatorZfromZoom(s2);
        }
        getCameraPoint() {
          if ("globe" === this.projection.name) {
            const t22 = function([t3, i22, o2], s2) {
              const r22 = [t3, i22, o2, 1];
              e2.aA(r22, r22, s2);
              const n22 = r22[3] = Math.max(r22[3], 1e-6);
              return r22[0] /= n22, r22[1] /= n22, r22[2] /= n22, r22;
            }([this.globeMatrix[12], this.globeMatrix[13], this.globeMatrix[14]], this.pixelMatrix);
            return new e2.P(t22[0], t22[1]);
          }
          {
            const t22 = Math.tan(this._pitch) * (this.cameraToCenterDistance || 1);
            return this.centerPoint.add(new e2.P(0, t22));
          }
        }
        getCameraToCenterDistance(t22, i22 = this.zoom, o2 = this.worldSize) {
          const s2 = e2.cA(t22, i22, this.width, this.height, 1024), r22 = t22.pixelSpaceConversion(this.center.lat, o2, s2);
          let n22 = 0.5 / Math.tan(0.5 * this._fov) * this.height * r22;
          return this.isOrthographic && (n22 = e2.ai(1, n22, e2.cO(this.pitch >= Ji ? 1 : this.pitch / Ji))), n22;
        }
        getWorldToCameraMatrix() {
          const t22 = this._camera.getWorldToCamera(this.worldSize, "meters" === this.projection.zAxisUnit ? this.pixelsPerMeter : 1);
          return "globe" === this.projection.name && e2.az(t22, t22, this.globeMatrix), t22;
        }
        getFrustum(t22) {
          return e2.cn.fromInvProjectionMatrix(this.invProjMatrix, this.worldSize, t22, "meters" === this.projection.zAxisUnit);
        }
      }
      const eo = (t22, i22) => {
        if (i22 > 0 && t22.terrain && e2.w("Cutoff is currently disabled on terrain"), i22 <= 0 || t22.terrain) return { shouldRenderCutoff: false, uniformValues: { u_cutoff_params: [0, 0, 0, 1] } };
        const o2 = t22.transform, s2 = Math.max(Math.abs(o2._zoom - (t22.minCutoffZoom - 1)), 1), r22 = o2.isLODDisabled(false) ? e2.af(60, 45, o2.pitch) : e2.af(30, 15, o2.pitch), n22 = o2._farZ - o2._nearZ, a22 = i22 * o2.height, l22 = ((1 - (c22 = r22)) * o2.cameraToCenterDistance + c22 * (o2._farZ + a22)) * s2;
        var c22;
        return { shouldRenderCutoff: r22 < 1, uniformValues: { u_cutoff_params: [o2._nearZ, o2._farZ, (l22 - o2._nearZ) / n22, (l22 - a22 - o2._nearZ) / n22] } };
      }, to = { cascadeCount: 2, normalOffset: 3, shadowMapResolution: 2048 };
      class io {
        constructor(e22, t22) {
          this.aabb = e22, this.lastCascade = t22;
        }
      }
      class oo {
        add(e22, t22) {
          const i22 = this.receivers[e22.key];
          void 0 !== i22 ? (i22.aabb.min[0] = Math.min(i22.aabb.min[0], t22.min[0]), i22.aabb.min[1] = Math.min(i22.aabb.min[1], t22.min[1]), i22.aabb.min[2] = Math.min(i22.aabb.min[2], t22.min[2]), i22.aabb.max[0] = Math.max(i22.aabb.max[0], t22.max[0]), i22.aabb.max[1] = Math.max(i22.aabb.max[1], t22.max[1]), i22.aabb.max[2] = Math.max(i22.aabb.max[2], t22.max[2])) : this.receivers[e22.key] = new io(t22, null);
        }
        clear() {
          this.receivers = {};
        }
        get(e22) {
          return this.receivers[e22.key];
        }
        computeRequiredCascades(t22, i22, o2) {
          const s2 = e2.cV.fromPoints(t22.points);
          let r22 = 0;
          for (const t3 in this.receivers) {
            const n22 = this.receivers[t3];
            if (!n22) continue;
            if (!s2.intersectsAabb(n22.aabb)) continue;
            n22.aabb.min = s2.closestPoint(n22.aabb.min), n22.aabb.max = s2.closestPoint(n22.aabb.max);
            const a22 = n22.aabb.getCorners();
            for (let t4 = 0; t4 < o2.length; t4++) {
              let s3 = true;
              for (const r3 of a22) {
                const n3 = [r3[0] * i22, r3[1] * i22, r3[2]];
                if (e2.ad(n3, n3, o2[t4].matrix), n3[0] < -1 || n3[0] > 1 || n3[1] < -1 || n3[1] > 1) {
                  s3 = false;
                  break;
                }
              }
              if (n22.lastCascade = t4, r22 = Math.max(r22, t4), s3) break;
            }
          }
          return r22 + 1;
        }
      }
      class so {
        constructor(e22) {
          this.painter = e22, this._enabled = false, this._shadowLayerCount = 0, this._numCascadesToRender = 0, this._cascades = [], this._groundShadowTiles = [], this._receivers = new oo(), this._depthMode = new Ni(e22.context.gl.LEQUAL, Ni.ReadWrite, [0, 1]), this._uniformValues = { u_light_matrix_0: new Float32Array(16), u_light_matrix_1: new Float32Array(16), u_shadow_intensity: 0, u_fade_range: [0, 0], u_shadow_normal_offset: [1, 1, 1], u_shadow_texel_size: 1, u_shadow_map_resolution: 1, u_shadow_direction: [0, 0, 1], u_shadow_bias: [36e-5, 12e-4, 0.012], u_shadowmap_0: 0, u_shadowmap_1: 0 }, this._forceDisable = false, this.useNormalOffset = false, e22.tp.registerParameter(this, ["Shadows"], "_forceDisable", { label: "forceDisable" }, () => {
            this.painter.style.map.triggerRepaint();
          }), e22.tp.registerParameter(to, ["Shadows"], "cascadeCount", { min: 1, max: 2, step: 1 }), e22.tp.registerParameter(to, ["Shadows"], "normalOffset", { min: 0, max: 10, step: 0.05 }), e22.tp.registerParameter(to, ["Shadows"], "shadowMapResolution", { min: 32, max: 2048, step: 32 }), e22.tp.registerBinding(this, ["Shadows"], "_numCascadesToRender", { readonly: true, label: "numCascadesToRender" });
        }
        destroy() {
          for (const e22 of this._cascades) e22.texture.destroy(), e22.framebuffer.destroy();
          this._cascades = [];
        }
        updateShadowParameters(t22, i22) {
          const o2 = this.painter;
          if (this._enabled = false, this._shadowLayerCount = 0, this._receivers.clear(), !i22 || !i22.properties) return;
          const s2 = i22.properties.get("shadow-intensity");
          if (!i22.shadowsEnabled() || s2 <= 0) return;
          if (this._shadowLayerCount = o2.style.order.reduce((e22, i3) => {
            const s3 = o2.style._mergedLayers[i3];
            return e22 + (s3.hasShadowPass() && !s3.isHidden(t22.zoom) ? 1 : 0);
          }, 0), this._enabled = this._shadowLayerCount > 0, !this.enabled) return;
          const r22 = o2.context, n22 = to.shadowMapResolution, a22 = to.shadowMapResolution;
          if (0 === this._cascades.length || to.shadowMapResolution !== this._cascades[0].texture.size[0]) {
            this._cascades = [];
            for (let t3 = 0; t3 < to.cascadeCount; ++t3) {
              const t4 = o2._shadowMapDebug, i3 = r22.gl, s3 = r22.createFramebuffer(n22, a22, t4, "texture"), l3 = new e2.T(r22, { width: n22, height: a22, data: null }, i3.DEPTH_COMPONENT16);
              if (s3.depthAttachment.set(l3.texture), t4) {
                const t5 = new e2.T(r22, { width: n22, height: a22, data: null }, i3.RGBA8);
                s3.colorAttachment.set(t5.texture);
              }
              this._cascades.push({ framebuffer: s3, texture: l3, matrix: [], far: 0, boundingSphereRadius: 0, frustum: new e2.cn(), scale: 0 });
            }
          }
          this.shadowDirection = no(i22);
          let l22 = 0;
          if (t22.elevation) {
            const e22 = t22.elevation, i3 = [1e4, -1e4];
            e22.visibleDemTiles.filter((e3) => e3.dem).forEach((e3) => {
              const t3 = e3.dem.tree;
              i3[0] = Math.min(i3[0], t3.minimums[0]), i3[1] = Math.max(i3[1], t3.maximums[0]);
            }), 1e4 !== i3[0] && (l22 = (i3[1] - i3[0]) * e22.exaggeration());
          }
          const c22 = 1.5 * t22.cameraToCenterDistance, h22 = 3 * c22, d22 = new Float64Array(16);
          for (let i3 = 0; i3 < this._cascades.length; ++i3) {
            const o3 = this._cascades[i3];
            let s3 = t22.height / 50, r3 = 1;
            1 === to.cascadeCount ? r3 = h22 : 0 === i3 ? r3 = c22 : (s3 = c22, r3 = h22);
            const [n3, a3] = lo(t22, this.shadowDirection, s3, r3, to.shadowMapResolution, l22);
            o3.scale = t22.scale, o3.matrix = n3, o3.boundingSphereRadius = a3, e2.bi(d22, o3.matrix), o3.frustum = e2.cn.fromInvProjectionMatrix(d22, 1, 0, true), o3.far = r3;
          }
          const u22 = this._cascades.length - 1;
          this._uniformValues.u_fade_range = [0.75 * this._cascades[u22].far, this._cascades[u22].far], this._uniformValues.u_shadow_intensity = s2, this._uniformValues.u_shadow_direction = [this.shadowDirection[0], this.shadowDirection[1], this.shadowDirection[2]], this._uniformValues.u_shadow_texel_size = 1 / to.shadowMapResolution, this._uniformValues.u_shadow_map_resolution = to.shadowMapResolution, this._uniformValues.u_shadowmap_0 = Yi.ShadowMap0, this._uniformValues.u_shadowmap_1 = Yi.ShadowMap0 + 1, this._groundShadowTiles = o2.transform.coveringTiles({ tileSize: 512, renderWorldCopies: true });
          const _22 = o2.transform.elevation;
          for (const e22 of this._groundShadowTiles) {
            let t3 = { min: 0, max: 0 };
            if (_22) {
              const i3 = _22.getMinMaxForTile(e22);
              i3 && (t3 = i3);
            }
            this.addShadowReceiver(e22.toUnwrapped(), t3.min, t3.max);
          }
        }
        get enabled() {
          return this._enabled && !this._forceDisable;
        }
        set enabled(e22) {
          this._enabled = e22;
        }
        drawShadowPass(t22, i22) {
          if (!this.enabled) return;
          const o2 = this.painter, s2 = o2.context;
          this._numCascadesToRender = this._receivers.computeRequiredCascades(o2.transform.getFrustum(0), o2.transform.worldSize, this._cascades), s2.viewport.set([0, 0, to.shadowMapResolution, to.shadowMapResolution]);
          for (let r22 = 0; r22 < this._numCascadesToRender; ++r22) {
            o2.currentShadowCascade = r22, s2.bindFramebuffer.set(this._cascades[r22].framebuffer.framebuffer), s2.clear({ color: e2.am.white, depth: 1 });
            for (const e22 of t22.order) {
              const s3 = t22._mergedLayers[e22];
              if (!s3.hasShadowPass() || s3.isHidden(o2.transform.zoom)) continue;
              const r3 = t22.getLayerSourceCache(s3), n22 = r3 ? i22[r3.id] : void 0;
              ("model" === s3.type || n22 && n22.length) && o2.renderLayer(o2, r3, s3, n22);
            }
          }
          o2.currentShadowCascade = 0;
        }
        drawGroundShadows() {
          if (!this.enabled) return;
          const e22 = this.painter, t22 = e22.style, i22 = e22.context, o2 = t22.directionalLight, s2 = t22.ambientLight;
          if (!o2 || !s2) return;
          const r22 = [], n22 = eo(e22, e22.longestCutoffRange);
          n22.shouldRenderCutoff && r22.push("RENDER_CUTOFF"), r22.push("RENDER_SHADOWS", "DEPTH_TEXTURE"), this.useNormalOffset && r22.push("NORMAL_OFFSET");
          const a22 = ao(t22, o2, s2), l22 = new Ni(i22.gl.LEQUAL, Ni.ReadOnly, e22.depthRangeFor3D);
          for (const t3 of this._groundShadowTiles) {
            const o3 = t3.toUnwrapped(), s3 = e22.isTileAffectedByFog(t3), c22 = e22.getOrCreateProgram("groundShadow", { defines: r22, overrideFog: s3 });
            this.setupShadows(o3, c22), e22.uploadCommonUniforms(i22, c22, o3, null, n22);
            const h22 = { u_matrix: e22.transform.calculateProjMatrix(o3), u_ground_shadow_factor: a22 };
            c22.draw(e22, i22.gl.TRIANGLES, l22, ji.disabled, ki.multiply, qi.disabled, h22, "ground_shadow", e22.tileExtentBuffer, e22.quadTriangleIndexBuffer, e22.tileExtentSegments, null, e22.transform.zoom, null, null);
          }
        }
        getShadowPassColorMode() {
          return this.painter._shadowMapDebug ? ki.unblended : ki.disabled;
        }
        getShadowPassDepthMode() {
          return this._depthMode;
        }
        getShadowCastingLayerCount() {
          return this._shadowLayerCount;
        }
        calculateShadowPassMatrixFromTile(t22) {
          const i22 = this.painter.transform, o2 = i22.calculatePosMatrix(t22, i22.worldSize);
          return e2.az(o2, this._cascades[this.painter.currentShadowCascade].matrix, o2), Float32Array.from(o2);
        }
        calculateShadowPassMatrixFromMatrix(t22) {
          return e2.az(t22, this._cascades[this.painter.currentShadowCascade].matrix, t22), Float32Array.from(t22);
        }
        setupShadows(t22, i22, o2, s2 = 0) {
          if (!this.enabled) return;
          const r22 = this.painter.transform, n22 = this.painter.context, a22 = n22.gl, l22 = this._uniformValues, c22 = new Float64Array(16), h22 = r22.calculatePosMatrix(t22, r22.worldSize);
          for (let t3 = 0; t3 < this._cascades.length; t3++) e2.az(c22, this._cascades[t3].matrix, h22), l22[0 === t3 ? "u_light_matrix_0" : "u_light_matrix_1"] = Float32Array.from(c22), n22.activeTexture.set(a22.TEXTURE0 + Yi.ShadowMap0 + t3), this._cascades[t3].texture.bind(a22.NEAREST, a22.CLAMP_TO_EDGE);
          if (this.useNormalOffset = !!o2, this.useNormalOffset) {
            const i3 = e2.cT(t22.canonical), n3 = 2 / r22.tileSize * e2.aj / to.shadowMapResolution, a3 = n3 * this._cascades[0].boundingSphereRadius, c3 = n3 * this._cascades[this._cascades.length - 1].boundingSphereRadius, h3 = ("vector-tile" === o2 ? 1 : 3) / Math.pow(2, s2 - t22.canonical.z - (1 - r22.zoom + Math.floor(r22.zoom)));
            l22.u_shadow_normal_offset = [i3, a3 * h3, c3 * h3], l22.u_shadow_bias = [6e-5, 12e-4, 0.012];
          } else l22.u_shadow_bias = [36e-5, 12e-4, 0.012];
          i22.setShadowUniformValues(n22, l22);
        }
        setupShadowsFromMatrix(t22, i22, o2 = false) {
          if (!this.enabled) return;
          const s2 = this.painter.context, r22 = s2.gl, n22 = this._uniformValues, a22 = new Float64Array(16);
          for (let i3 = 0; i3 < to.cascadeCount; i3++) e2.az(a22, this._cascades[i3].matrix, t22), n22[0 === i3 ? "u_light_matrix_0" : "u_light_matrix_1"] = Float32Array.from(a22), s2.activeTexture.set(r22.TEXTURE0 + Yi.ShadowMap0 + i3), this._cascades[i3].texture.bind(r22.NEAREST, r22.CLAMP_TO_EDGE);
          if (this.useNormalOffset = o2, o2) {
            const e22 = to.normalOffset;
            n22.u_shadow_normal_offset = [1, e22, e22], n22.u_shadow_bias = [6e-5, 12e-4, 0.012];
          } else n22.u_shadow_bias = [36e-5, 12e-4, 0.012];
          i22.setShadowUniformValues(s2, n22);
        }
        getShadowUniformValues() {
          return this._uniformValues;
        }
        getCurrentCascadeFrustum() {
          return this._cascades[this.painter.currentShadowCascade].frustum;
        }
        computeSimplifiedTileShadowVolume(t22, i22, o2, s2) {
          if (s2[2] >= 0) return {};
          const r22 = function(t3, i3, o3) {
            const s3 = o3 / (1 << t3.canonical.z);
            return new e2.cV([t3.canonical.x * s3 + t3.wrap * o3, t3.canonical.y * s3 + t3.wrap * o3, 0], [(t3.canonical.x + 1) * s3 + t3.wrap * o3, (t3.canonical.y + 1) * s3 + t3.wrap * o3, i3]);
          }(t22, i22, o2).getCorners(), n22 = i22 / -s2[2];
          s2[0] < 0 ? (e2.cU(r22[0], r22[0], [s2[0] * n22, 0, 0]), e2.cU(r22[3], r22[3], [s2[0] * n22, 0, 0])) : s2[0] > 0 && (e2.cU(r22[1], r22[1], [s2[0] * n22, 0, 0]), e2.cU(r22[2], r22[2], [s2[0] * n22, 0, 0])), s2[1] < 0 ? (e2.cU(r22[0], r22[0], [0, s2[1] * n22, 0]), e2.cU(r22[1], r22[1], [0, s2[1] * n22, 0])) : s2[1] > 0 && (e2.cU(r22[2], r22[2], [0, s2[1] * n22, 0]), e2.cU(r22[3], r22[3], [0, s2[1] * n22, 0]));
          const a22 = {};
          return a22.vertices = r22, a22.planes = [ro(r22[1], r22[0], r22[4]), ro(r22[2], r22[1], r22[5]), ro(r22[3], r22[2], r22[6]), ro(r22[0], r22[3], r22[7])], a22;
        }
        addShadowReceiver(t22, i22, o2) {
          this._receivers.add(t22, e2.cV.fromTileIdAndHeight(t22, i22, o2));
        }
        getMaxCascadeForTile(e22) {
          const t22 = this._receivers.get(e22);
          return t22 && t22.lastCascade ? t22.lastCascade : 0;
        }
      }
      function ro(t22, i22, o2) {
        const s2 = e2.at([], o2, i22), r22 = e2.at([], t22, i22), n22 = e2.bG([], s2, r22), a22 = e2.ae(n22);
        return 0 === a22 ? [0, 0, 1, 0] : (e2.b$(n22, n22, 1 / a22), [n22[0], n22[1], n22[2], -e2.bE(n22, i22)]);
      }
      function no(t22) {
        const i22 = t22.properties.get("direction"), o2 = e2.cR(i22.x, i22.y, i22.z);
        o2[2] = e2.aD(o2[2], 0, 75);
        const s2 = e2.cW([o2[0], o2[1], o2[2]]);
        return e2.cS(s2.x, s2.y, s2.z);
      }
      function ao(t22, i22, o2) {
        const s2 = "none" === i22.properties.get("color-use-theme"), r22 = i22.properties.get("color"), n22 = i22.properties.get("intensity"), a22 = i22.properties.get("direction"), l22 = [a22.x, a22.y, a22.z], c22 = "none" === o2.properties.get("color-use-theme"), h22 = o2.properties.get("color"), d22 = o2.properties.get("intensity"), u22 = Math.max(e2.bE([0, 0, 1], l22), 0), _22 = [0, 0, 0];
        e2.b$(_22, h22.toRenderColor(c22 ? null : t22.getLut(i22.scope)).toArray01Linear().slice(0, 3), d22);
        const p22 = [0, 0, 0];
        return e2.b$(p22, r22.toRenderColor(s2 ? null : t22.getLut(o2.scope)).toArray01Linear().slice(0, 3), u22 * n22), e2.cX([_22[0] > 0 ? _22[0] / (_22[0] + p22[0]) : 0, _22[1] > 0 ? _22[1] / (_22[1] + p22[1]) : 0, _22[2] > 0 ? _22[2] / (_22[2] + p22[2]) : 0]);
      }
      function lo(t22, i22, o2, s2, r22, n22) {
        const a22 = t22.zoom, l22 = t22.scale, c22 = t22.worldSize, h22 = 1 / c22, d22 = t22.aspect, u22 = Math.sqrt(1 + d22 * d22) * Math.tan(0.5 * t22.fovX), _22 = u22 * u22, p22 = s2 - o2, f22 = s2 + o2;
        let m22, g22;
        _22 > p22 / f22 ? (m22 = s2, g22 = s2 * u22) : (m22 = 0.5 * f22 * (1 + _22), g22 = 0.5 * Math.sqrt(p22 * p22 + 2 * (s2 * s2 + o2 * o2) * _22 + f22 * f22 * _22 * _22));
        const v22 = t22.projection.pixelsPerMeter(t22.center.lat, c22), y22 = t22._camera.getCameraToWorldMercator(), x22 = [0, 0, -m22 * h22];
        e2.ad(x22, x22, y22);
        let b22 = g22 * h22;
        const w22 = t22._edgeInsets;
        if (!(0 === w22.left && 0 === w22.top && 0 === w22.right && 0 === w22.bottom || w22.left === w22.right && w22.top === w22.bottom)) {
          const i3 = t22._camera.getWorldToCamera(t22.worldSize, "meters" === t22.projection.zAxisUnit ? v22 : 1), r3 = t22._camera.getCameraToClipPerspective(t22._fov, t22.width / t22.height, o2, s2);
          r3[8] = 2 * -t22.centerOffset.x / t22.width, r3[9] = 2 * t22.centerOffset.y / t22.height;
          const n3 = new Float64Array(16);
          e2.cB(n3, r3, i3);
          const h3 = new Float64Array(16);
          e2.bi(h3, n3);
          const d3 = e2.cn.fromInvProjectionMatrix(h3, c22, a22, true);
          for (const i4 of d3.points) {
            const o3 = ((T2 = i4)[0] /= l22, T2[1] /= l22, T2[2] = e2.c6(T2[2], t22._center.lat), T2);
            b22 = Math.max(b22, e2.c0(e2.cY([], x22, o3)));
          }
        }
        var T2;
        b22 *= r22 / (r22 - 1);
        const E22 = Math.acos(i22[2]), S2 = Math.atan2(-i22[0], -i22[1]), I2 = new Xi();
        I2.position = x22, I2.setPitchBearing(E22, S2);
        const C22 = I2.getWorldToCamera(c22, v22), R22 = b22 * c22, D22 = Math.min(t22._mercatorZfromZoom(17) * c22 * -2, -2 * R22), A22 = I2.getCameraToClipOrthographic(-R22, R22, -R22, R22, D22, (R22 + n22 * v22) / i22[2]), L22 = new Float64Array(16);
        e2.az(L22, A22, C22);
        const P22 = e2.cS(Math.floor(1e6 * x22[0]) / 1e6 * c22, Math.floor(1e6 * x22[1]) / 1e6 * c22, 0), z22 = 0.5 * r22, M22 = [0, 0, 0];
        e2.ad(M22, P22, L22), e2.b$(M22, M22, z22);
        const O2 = [Math.floor(M22[0]), Math.floor(M22[1]), Math.floor(M22[2])], F2 = [0, 0, 0];
        e2.at(F2, M22, O2), e2.b$(F2, F2, -1 / z22);
        const B22 = new Float64Array(16);
        return e2.bx(B22), e2.bo(B22, B22, F2), e2.az(L22, B22, L22), [L22, R22];
      }
      class co extends e2.E {
        constructor(e22) {
          super(), this.requestManager = e22, this.models = { "": {} }, this.modelUris = { "": {} }, this.modelByURL = {}, this.numModelsLoading = {};
        }
        loadModel(t22, i22) {
          return e2.aS(this.requestManager.transformRequest(i22, e2.R.Model).url).then((i3) => {
            if (!i3) return;
            const o2 = e2.aT(i3), s2 = new e2.aU(t22, void 0, void 0, o2);
            return s2.computeBoundsAndApplyParent(), s2;
          }).catch((o2) => {
            if (o2 && 404 === o2.status) return null;
            this.fire(new e2.z(new Error(`Could not load model ${t22} from ${i22}: ${o2.message}`)));
          });
        }
        load(t22, i22, o2 = { forceReload: false }) {
          this.models[i22] || (this.models[i22] = {});
          const s2 = Object.keys(t22), r22 = [], n22 = [];
          for (const e22 of s2) {
            const s3 = t22[e22];
            this.hasURLBeenRequested(s3) && !o2.forceReload || (this.modelByURL[s3] = { modelId: e22, scope: i22 }, r22.push(this.loadModel(e22, s3)), n22.push(e22)), this.models[i22][e22] || (this.models[i22][e22] = { model: null, numReferences: 1 });
          }
          this.numModelsLoading[i22] = (this.numModelsLoading[i22] || 0) + n22.length, Promise.allSettled(r22).then((t3) => {
            for (let e22 = 0; e22 < t3.length; e22++) {
              const { status: o3 } = t3[e22];
              if ("rejected" === o3) continue;
              const { value: s3 } = t3[e22];
              this.models[i22][n22[e22]] || (this.models[i22][n22[e22]] = { model: null, numReferences: 1 }), this.models[i22][n22[e22]].model = s3;
            }
            this.numModelsLoading[i22] -= n22.length, this.fire(new e2.A("data", { dataType: "style" }));
          }).catch((t3) => {
            this.fire(new e2.z(new Error(`Could not load models: ${t3.message}`)));
          });
        }
        isLoaded() {
          for (const e22 in this.numModelsLoading) if (this.numModelsLoading[e22] > 0) return false;
          return true;
        }
        hasModel(e22, t22, i22 = { exactIdMatch: false }) {
          return !!(i22.exactIdMatch ? this.getModel(e22, t22) : this.getModelByURL(this.modelUris[t22][e22]));
        }
        getModel(e22, t22) {
          return this.models[t22] || (this.models[t22] = {}), this.models[t22][e22] ? this.models[t22][e22].model : void 0;
        }
        getModelByURL(e22) {
          if (!e22) return null;
          const t22 = this.modelByURL[e22];
          return t22 ? this.models[t22.scope][t22.modelId].model : null;
        }
        hasModelBeenAdded(e22, t22) {
          return this.models[t22] && void 0 !== this.models[t22][e22];
        }
        getModelURIs(e22) {
          return this.modelUris[e22] || {};
        }
        addModel(e22, t22, i22) {
          this.models[i22] || (this.models[i22] = {}), this.modelUris[i22] || (this.modelUris[i22] = {});
          const o2 = this.requestManager.normalizeModelURL(t22);
          if ((this.hasModel(e22, i22, { exactIdMatch: true }) || this.hasModelBeenAdded(e22, i22)) && this.modelUris[i22][e22] === o2) this.models[i22][e22].numReferences++;
          else if (this.hasURLBeenRequested(o2)) {
            const { scope: e3, modelId: t3 } = this.modelByURL[o2];
            this.models[e3][t3].numReferences++;
          } else this.modelUris[i22][e22] = o2, this.load({ [e22]: this.modelUris[i22][e22] }, i22);
        }
        addModelURLs(e22, t22) {
          this.models[t22] || (this.models[t22] = {}), this.modelUris[t22] || (this.modelUris[t22] = {});
          const i22 = this.modelUris[t22];
          for (const t3 in e22) i22[t3] = this.requestManager.normalizeModelURL(e22[t3]);
        }
        reloadModels(e22) {
          this.load(this.modelUris[e22], e22, { forceReload: true });
        }
        addModelsFromBucket(t22, i22) {
          this.models[i22] || (this.models[i22] = {}), this.modelUris[i22] || (this.modelUris[i22] = {});
          const o2 = {};
          for (const s2 of t22) this.hasModel(s2, i22, { exactIdMatch: true }) || this.hasURLBeenRequested(s2) ? this.models[i22][s2].numReferences++ : this.modelUris[i22][s2] && !this.hasURLBeenRequested(s2) ? o2[s2] = this.modelUris[i22][s2] : !this.hasURLBeenRequested(s2) && e2.cZ(s2, false) && (this.modelUris[i22][s2] = this.requestManager.normalizeModelURL(s2), o2[s2] = this.modelUris[i22][s2]);
          this.load(o2, i22);
        }
        hasURLBeenRequested(e22) {
          return void 0 !== this.modelByURL[e22];
        }
        removeModel(e22, t22, i22 = false) {
          if (this.models[t22] && this.models[t22][e22] && (this.models[t22][e22].numReferences--, 0 === this.models[t22][e22].numReferences)) {
            const o2 = this.modelUris[t22][e22];
            i22 || delete this.modelUris[t22][e22], delete this.modelByURL[o2];
            const s2 = this.models[t22][e22].model;
            if (!s2) return;
            delete this.models[t22][e22], s2.destroy();
          }
        }
        destroy() {
          for (const e22 of Object.keys(this.models)) for (const t22 of Object.keys(this.models[e22])) {
            const i22 = this.models[e22][t22].model;
            delete this.models[e22][t22], i22 && i22.destroy();
          }
          this.models = { "": {} }, this.modelUris = { "": {} }, this.modelByURL = {}, this.numModelsLoading = {};
        }
        listModels(e22) {
          return this.models[e22] || (this.models[e22] = {}), Object.keys(this.models[e22]);
        }
        upload(e22, t22) {
          this.models[t22] || (this.models[t22] = {});
          for (const i22 in this.models[t22]) this.models[t22][i22].model && this.models[t22][i22].model.upload(e22.context);
        }
      }
      const ho = new e2.a7({ data: new e2.a8(e2.a5.colorTheme.data) }), uo = { "mbx-indoor-active-floorplans": { default: ["literal", []] }, "mbx-indoor-underground": { default: ["literal", false] }, "mbx-indoor-loaded-levels": { default: ["literal", []] }, "mbx-indoor-level-height": { default: ["literal", {}] }, "mbx-indoor-level-base": { default: ["literal", {}] }, "mbx-indoor-level-selected": { default: ["literal", {}] }, "mbx-indoor-level-overlapped": { default: ["literal", {}] } };
      function _o(e22) {
        return e22 = e22 || {}, Object.assign(e22, uo);
      }
      class po extends e2.E {
        constructor(t22) {
          super(), this.mergeFloors = true, this._scope = void 0, this._queryFeatureSetId = void 0, this._buildingEntryFeatureSetId = void 0, this._selectedFloorplan = void 0, this._indoorData = void 0, this._selectedLevel = void 0, this._floorplanStates = {}, e2.aV(["_onLoad", "_onMove", "_checkFloorplanVisible"], this), this._map = t22, this._checkFloorplanVisible(true), this._map.on("load", this._onLoad), this._map.on("move", this._onMove);
        }
        destroy() {
          this._map.indoor.off("load", this._onLoad), this._map.indoor.off("move", this._onMove), this._map = void 0;
        }
        _onLoad() {
          this._map.style.forEachFragmentStyle((t22) => {
            t22.stylesheet.indoor && (this._queryFeatureSetId ? this.fire(new e2.z(new Error("Multiple indoor map styles detected, simultaneous usage is not allowed currently."))) : (this._queryFeatureSetId = t22.stylesheet.indoor.floorplanFeaturesetId, this._buildingEntryFeatureSetId = t22.stylesheet.indoor.buildingFeaturesetId, this._scope = t22.scope));
          }), this._queryFeatureSetId && this._buildingEntryFeatureSetId && this._map.addInteraction("mbx-indoor-buildingclick", { type: "click", target: { featuresetId: this._buildingEntryFeatureSetId, importId: this._scope }, handler: (e22) => (e22.feature && e22.feature.properties.floorplan && this.selectFloorplan(e22.feature.properties.floorplan), true) }), this._checkFloorplanVisible(true);
        }
        _onMove() {
          this._checkFloorplanVisible(false);
        }
        _checkFloorplanVisible(t22) {
          if (!this._queryFeatureSetId) return;
          if (!this._map.isStyleLoaded()) return;
          if (this._map.transform.zoom < 13) return;
          this._indoorData && !function(e22, t3) {
            const [i3, o3] = e22, { center: s3, radius: r3 } = t3, [n22, a22] = s3, l22 = Math.abs(i3 - n22);
            return Math.sqrt((l22 > 180 ? 360 - l22 : l22) ** 2 + (o3 - a22) ** 2) <= r3;
          }([this._map.getCenter().lng, this._map.getCenter().lat], this._indoorData.circumCircle) && (this._indoorData = void 0, this._selectedFloorplan = void 0, this._map.setConfigProperty(this._scope, "mbx-indoor-underground", false), this._map.setConfigProperty(this._scope, "mbx-indoor-active-floorplans", ["literal", []]), this.fire(new e2.A("floorplangone")));
          const i22 = { target: { featuresetId: this._queryFeatureSetId, importId: this._scope } }, o2 = new e2.P(this._map.transform.width / 2, this._map.transform.height / 2), s2 = [new e2.P(0, 0), new e2.P(this._map.transform.width, this._map.transform.height)], r22 = this._map.queryRenderedFeatures(t22 ? s2 : o2, i22);
          r22.length > 0 && (this._selectedFloorplan && r22[0].properties.id === this._selectedFloorplan.properties.id || (this._selectedFloorplan = r22[0], this._floorplanSelected(false)));
        }
        _floorplanSelected(t22) {
          this._indoorData = JSON.parse(this._selectedFloorplan.properties["indoor-data"]), this._indoorData.id = this._selectedFloorplan.properties.id, this._indoorData.circumCircle = function(e22) {
            const [[t3, i3], [o3, s3]] = e22, r22 = (o3 - t3 + 360) % 360, n22 = r22 > 180 ? 360 - r22 : r22;
            return { center: [(t3 + n22 / 2 + 360) % 360, (i3 + s3) / 2], radius: Math.sqrt(n22 ** 2 + (s3 - i3) ** 2) / 2 };
          }(this._indoorData.extent), this._floorplanStates[this._indoorData.id] || (this._floorplanStates[this._indoorData.id] = {});
          const i22 = this._floorplanStates[this._indoorData.id].selectedBuilding, o2 = this._floorplanStates[this._indoorData.id].selectedLevel;
          let s2;
          if (this._map.setConfigProperty(this._scope, "mbx-indoor-active-floorplans", this._indoorData.floorplanIDs), this._selectedLevel) for (const e22 of this._indoorData.levels) e22.id === this._selectedLevel.id && (s2 = e22.id);
          if (this.fire(new e2.A("floorplanselected", { buildings: this._indoorData.buildings, levels: this._indoorData.levels, selectedLevelId: s2 })), i22) {
            const e22 = this._indoorData.buildings.find((e3) => e3.id === i22);
            this._buildingSelected(e22, false);
          } else this._indoorData.buildings.length > 0 && this._buildingSelected(this._indoorData.buildings[0], false);
          if (o2) {
            const e22 = this._indoorData.levels.find((e3) => e3.id === o2);
            this._updateLevels(e22, t22);
          } else t22 && this._indoorData["default-levels"].length > 0 && this.selectLevel(this._indoorData["default-levels"][0]);
        }
        _buildingSelected(t22, i22) {
          i22 && t22 && t22.extent && this._map.fitBounds(t22.extent, { pitch: this._map.getPitch(), bearing: this._map.getBearing() }), this._floorplanStates[this._indoorData.id].selectedBuilding = t22 ? t22.id : void 0;
          const o2 = this._indoorData.levels.filter((e22) => t22.levels.includes(e22.id));
          this.fire(new e2.A("buildingselected", { buildingId: t22.id, levels: o2 }));
        }
        _levelSelected(t22) {
          if ("overview" === t22) this._updateLevels(void 0, true);
          else {
            const e22 = this._indoorData.levels.find((e3) => e3.id === t22);
            this._updateLevels(e22, true);
          }
          this.fire(new e2.A("levelselected", { levelId: "overview" === t22 ? void 0 : t22 }));
        }
        _updateLevels(e22, t22) {
          if (!e22) return this._map.setConfigProperty(this._scope, "mbx-indoor-loaded-levels", ["literal", []]), this._map.setConfigProperty(this._scope, "mbx-indoor-underground", false), this._floorplanStates[this._indoorData.id].selectedLevel = void 0, void (t22 && this._indoorData.extent && this._map.fitBounds(this._indoorData.extent, { pitch: this._map.getPitch(), bearing: this._map.getBearing() }));
          function i22(e3) {
            const t3 = e3.indexOf("/floor/");
            if (-1 === t3) return e3;
            const i3 = t3 + 7, o3 = e3.indexOf("/", i3);
            return -1 === o3 ? e3.slice(i3) : e3.slice(i3, o3);
          }
          this._selectedLevel = e22, this._floorplanStates[this._indoorData.id].selectedLevel = e22 ? e22.id : void 0;
          const o2 = [], s2 = {}, r22 = {}, n22 = {}, a22 = {};
          for (const t3 of this._indoorData.levels) if (o2.push(t3.id), s2[t3.id] = t3.height, r22[t3.id] = t3.base, e22) {
            if (this.mergeFloors) {
              const o3 = i22(e22.id), s3 = i22(t3.id);
              n22[t3.id] = s3 === o3 ? "true" : "false";
            } else n22[t3.id] = t3.id === e22.id ? "true" : "false";
            a22[t3.id] = t3.base < e22.base ? "true" : "false";
          } else a22[t3.id] = true;
          if (this._map.setConfigProperty(this._scope, "mbx-indoor-loaded-levels", ["literal", o2]), this._map.setConfigProperty(this._scope, "mbx-indoor-level-height", ["literal", s2]), this._map.setConfigProperty(this._scope, "mbx-indoor-level-base", ["literal", r22]), this._map.setConfigProperty(this._scope, "mbx-indoor-level-selected", ["literal", n22]), this._map.setConfigProperty(this._scope, "mbx-indoor-level-overlapped", ["literal", a22]), e22 && (this._map.setConfigProperty(this._scope, "mbx-indoor-underground", !!e22.isUnderground), t22 && e22.extent)) {
            const t3 = this._map.cameraForBounds(e22.extent, { pitch: this._map.getPitch(), bearing: this._map.getBearing() }), i3 = this._map.getZoom(), o3 = t3.zoom ? Math.abs(i3 - t3.zoom) : 0;
            this._map.fitBounds(e22.extent, o3 >= 1 ? { pitch: this._map.getPitch(), bearing: this._map.getBearing() } : { pitch: this._map.getPitch(), bearing: this._map.getBearing(), zoom: i3 });
          }
        }
        selectFloorplan(t22) {
          const i22 = { target: { featuresetId: this._queryFeatureSetId, importId: this._scope } }, o2 = [new e2.P(0, 0), new e2.P(this._map.transform.width, this._map.transform.height)], s2 = this._map.queryRenderedFeatures(o2, i22);
          if (s2.length > 0) {
            for (const e22 of s2) if (JSON.parse(e22.properties["indoor-data"]).floorplanIDs.includes(t22)) {
              this._selectedFloorplan = e22, this._floorplanSelected(true);
              break;
            }
          }
        }
        selectBuilding(e22) {
          const t22 = this._indoorData.buildings.find((t3) => t3.id === e22);
          this._buildingSelected(t22, true);
        }
        selectLevel(e22) {
          this._levelSelected(e22);
        }
      }
      function fo(t22) {
        if (!t22.metadata || !t22.metadata.content_area) return;
        const i22 = e2.q.devicePixelRatio, { left: o2, top: s2, width: r22, height: n22 } = t22.metadata.content_area, a22 = o2 * i22, l22 = s2 * i22;
        return [a22, l22, a22 + r22 * i22, l22 + n22 * i22];
      }
      function mo(t22) {
        if (t22) return t22.map(([t3, i22]) => [t3 * e2.q.devicePixelRatio, i22 * e2.q.devicePixelRatio]);
      }
      class go {
        constructor(e22, t22, i22) {
          this.id = e22, this.scope = t22, this.sourceCache = i22, this.pendingRequests = /* @__PURE__ */ new Set(), this.missingRequests = /* @__PURE__ */ new Set();
        }
        addPendingRequest(e22) {
          this.missingRequests.has(e22.name) || this.pendingRequests.has(e22.name) || this.pendingRequests.add(e22.name);
        }
        hasPendingRequests() {
          return this.pendingRequests.size > 0;
        }
        resolvePendingRequests() {
          const t22 = /* @__PURE__ */ new Map();
          if (!this.sourceCache.loaded()) return t22;
          const i22 = this.sourceCache.getVisibleCoordinates();
          if (0 === i22.length) return t22;
          const o2 = this.sourceCache.getSource();
          if (!(o2 instanceof st)) return t22;
          const s2 = i22.map((e22) => this.sourceCache.getTile(e22)), r22 = o2.getImages(s2, Array.from(this.pendingRequests));
          for (const [i3, o3] of r22) t22.set(e2.I.from({ name: i3, iconsetId: this.id }), o3), this.pendingRequests.delete(i3);
          for (const e22 of this.pendingRequests) this.missingRequests.add(e22);
          return this.pendingRequests.clear(), t22;
        }
      }
      const vo = (e22, t22) => Ae(e22, t22 && t22.filter((e3) => "source.canvas" !== e3.identifier)), yo = e2.aF(zt, ["addLayer", "removeLayer", "setLights", "setPaintProperty", "setLayoutProperty", "setSlot", "setFilter", "addSource", "removeSource", "setLayerZoomRange", "setLight", "setTransition", "setGeoJSONSourceData", "setTerrain", "setFog", "setSnow", "setRain", "setProjection", "setCamera", "addImport", "removeImport", "updateImport", "addIconset", "removeIconset"]), xo = e2.aF(zt, ["setCenter", "setZoom", "setBearing", "setPitch"]), bo = /* @__PURE__ */ new Set(["background", "sky", "slot", "custom"]), wo = { version: 8, layers: [], sources: {} }, To = { duration: 300, delay: 0 };
      class Eo extends e2.E {
        constructor(t22, i22 = {}) {
          super(), this.map = t22, this.scope = i22.scope || "", this.globalId = null, this.fragments = [], this.importDepth = i22.importDepth || 0, this.importsCache = i22.importsCache || /* @__PURE__ */ new Map(), this.resolvedImports = i22.resolvedImports || /* @__PURE__ */ new Set(), this.transition = e2.l({}, To), this._buildingIndex = new At(this), this.crossTileSymbolIndex = new Fi(), this._mergedOrder = [], this._drapedFirstOrder = [], this._mergedLayers = {}, this._mergedSourceCaches = {}, this._mergedOtherSourceCaches = {}, this._mergedSymbolSourceCaches = {}, this._clipLayerPresent = false, this._has3DLayers = false, this._hasCircleLayers = false, this._hasSymbolLayers = false, this._changes = i22.styleChanges || new V(), this.dispatcher = i22.dispatcher ? i22.dispatcher : new e2.D(e2.d0(), this), i22.imageManager ? this.imageManager = i22.imageManager : (this.imageManager = new q2(this.map._spriteFormat), this.imageManager.setEventedParent(this)), this.imageManager.addScope(this.scope), this.glyphManager = i22.glyphManager ? i22.glyphManager : new e2.d1(t22._requestManager, i22.localFontFamily ? e2.d2.all : i22.localIdeographFontFamily ? e2.d2.ideographs : e2.d2.none, i22.localFontFamily || i22.localIdeographFontFamily), i22.modelManager ? this.modelManager = i22.modelManager : (this.modelManager = new co(t22._requestManager), this.modelManager.setEventedParent(this)), this._layers = {}, this._sourceCaches = {}, this._otherSourceCaches = {}, this._symbolSourceCaches = {}, this._loaded = false, this._precompileDone = false, this._shouldPrecompile = false, this._availableImages = [], this._availableModels = {}, this._order = [], this._markersNeedUpdate = false, this.options = i22.configOptions ? i22.configOptions : /* @__PURE__ */ new Map(), this._configDependentLayers = i22.configDependentLayers ? i22.configDependentLayers : /* @__PURE__ */ new Set(), this._config = i22.config, this._styleColorTheme = { lut: null, lutLoading: false, lutLoadingCorrelationID: 0, colorTheme: null, colorThemeOverride: i22.colorThemeOverride }, this._styleColorThemeForScope = {}, this._initialConfig = i22.initialConfig, this.dispatcher.broadcast("setReferrer", e2.d3());
          const o2 = this;
          this._rtlTextPluginCallback = Eo.registerForPluginStateChange((t3) => {
            o2.dispatcher.broadcast("syncRTLPluginState", { pluginStatus: t3.pluginStatus, pluginURL: t3.pluginURL }, (t4, i3) => {
              if (e2.d4(t4), i3 && i3.every((e22) => e22)) for (const e22 in o2._sourceCaches) {
                const t5 = o2._sourceCaches[e22], i4 = t5.getSource().type;
                "vector" !== i4 && "geojson" !== i4 || t5.reload();
              }
            });
          }), this.on("data", (e22) => {
            if ("source" !== e22.dataType || "metadata" !== e22.sourceDataType) return;
            const t3 = this.getOwnSource(e22.sourceId);
            if (t3 && t3.vectorLayerIds) for (const e3 in this._layers) {
              const i3 = this._layers[e3];
              i3.source === t3.id && this._validateLayer(i3);
            }
          });
        }
        load(e22) {
          return e22 ? ("string" == typeof e22 ? this.loadURL(e22) : this.loadJSON(e22), this) : this;
        }
        _getGlobalId(t22) {
          if (!t22) return null;
          if ("string" == typeof t22) {
            if (e2.f(t22)) return t22;
            const i22 = e2.d5(t22);
            if (!i22.startsWith("http")) try {
              return new URL(i22, location.href).toString();
            } catch (e22) {
              return i22;
            }
            return i22;
          }
          return `json://${e2.d6(JSON.stringify(t22))}`;
        }
        _diffStyle(t22, i22, o2) {
          this.globalId = this._getGlobalId(t22);
          const s2 = (e22, t3) => {
            try {
              t3(null, this.setState(e22, o2));
            } catch (e3) {
              t3(e3, false);
            }
          };
          if ("string" == typeof t22) {
            const o3 = this.map._requestManager.normalizeStyleURL(t22), r22 = this.map._requestManager.transformRequest(o3, e2.R.Style);
            e2.n(r22, (t3, o4) => {
              t3 ? this.fire(new e2.z(t3)) : o4 && s2(o4, i22);
            });
          } else "object" == typeof t22 && s2(t22, i22);
        }
        loadURL(t22, i22 = {}) {
          this.fire(new e2.A("dataloading", { dataType: "style" }));
          const o2 = "boolean" == typeof i22.validate ? i22.validate : !e2.f(t22);
          this.globalId = this._getGlobalId(t22), t22 = this.map._requestManager.normalizeStyleURL(t22, i22.accessToken), this.resolvedImports.add(t22);
          const s2 = this.importsCache.get(t22);
          if (s2) return this._load(s2, o2);
          const r22 = this.map._requestManager.transformRequest(t22, e2.R.Style);
          this._request = e2.n(r22, (i3, s3) => {
            if (this._request = null, i3) this.fire(new e2.z(i3));
            else if (s3) return this.importsCache.set(t22, s3), this._load(s3, o2);
          });
        }
        loadJSON(t22, i22 = {}) {
          this.fire(new e2.A("dataloading", { dataType: "style" })), this.globalId = this._getGlobalId(t22), this._request = e2.q.frame(() => {
            this._request = null, this._load(t22, false !== i22.validate);
          });
        }
        loadEmpty() {
          this.fire(new e2.A("dataloading", { dataType: "style" })), this._load(wo, false);
        }
        _loadImports(t22, i22, o2) {
          if (this.importDepth >= 4) return e2.w("Style doesn't support nesting deeper than 5"), Promise.resolve();
          const s2 = [];
          for (const e22 of t22) {
            const t3 = this._createFragmentStyle(e22), r22 = new Promise((e3) => {
              t3.once("style.import.load", e3), t3.once("error", e3);
            }).then(() => this.mergeAll());
            if (s2.push(r22), this.resolvedImports.has(e22.url)) {
              t3.loadEmpty();
              continue;
            }
            const n22 = e22.data || this.importsCache.get(e22.url);
            n22 ? (t3.loadJSON(n22, { validate: i22 }), this._isInternalStyle(n22) && (t3.globalId = null)) : e22.url ? t3.loadURL(e22.url, { validate: i22 }) : t3.loadEmpty();
            const a22 = { style: t3, id: e22.id, config: e22.config };
            if (o2) {
              const e3 = this.fragments.findIndex(({ id: e4 }) => e4 === o2);
              this.fragments = this.fragments.slice(0, e3).concat(a22).concat(this.fragments.slice(e3));
            } else this.fragments.push(a22);
          }
          return Promise.allSettled(s2);
        }
        getImportGlobalIds(e22 = this, t22 = /* @__PURE__ */ new Set()) {
          for (const i22 of e22.fragments) i22.style.globalId && t22.add(i22.style.globalId), this.getImportGlobalIds(i22.style, t22);
          return [...t22.values()];
        }
        _createFragmentStyle(t22) {
          const i22 = this.scope ? e2.C(t22.id, this.scope) : t22.id;
          let o2;
          const s2 = this._initialConfig && this._initialConfig[i22];
          (t22.config || s2) && (o2 = e2.l({}, t22.config, s2));
          const r22 = new Eo(this.map, { scope: i22, styleChanges: this._changes, importDepth: this.importDepth + 1, importsCache: this.importsCache, resolvedImports: new Set(this.resolvedImports), dispatcher: this.dispatcher, imageManager: this.imageManager, glyphManager: this.glyphManager, modelManager: this.modelManager, config: o2, configOptions: this.options, colorThemeOverride: t22["color-theme"], configDependentLayers: this._configDependentLayers });
          return r22.setEventedParent(this.map, { style: r22 }), r22;
        }
        _reloadImports() {
          this.mergeAll(), this._updateMapProjection(), this.updateConfigDependencies(), this.map._triggerCameraUpdate(this.camera), this.dispatcher.broadcast("setLayers", { layers: this._serializeLayers(this._order), scope: this.scope, options: this.options }), this._shouldPrecompile = this.map._precompilePrograms && this.isRootStyle();
        }
        _isInternalStyle(e22) {
          return this.isRootStyle() && (e22.fragment || !!e22.schema && false !== e22.fragment);
        }
        _load(t22, i22) {
          const o2 = t22.indoor ? _o(t22.schema) : t22.schema;
          if (this._isInternalStyle(t22)) {
            const o3 = e2.l({}, wo, { imports: [{ id: "basemap", data: t22, url: "" }] });
            return void this._load(o3, i22);
          }
          if (this.updateConfig(this._config, o2), i22 && vo(this, me(t22))) return;
          this._loaded = true, this.stylesheet = e2.d7(t22);
          const s2 = () => {
            for (const e22 in t22.sources) this.addSource(e22, t22.sources[e22], { validate: false, isInitialLoad: true });
            if (t22.iconsets) for (const e22 in t22.iconsets) this.addIconset(e22, t22.iconsets[e22]);
            t22.sprite ? this._loadIconset(t22.sprite) : (this.imageManager.setLoaded(true, this.scope), this.dispatcher.broadcast("spriteLoaded", { scope: this.scope, isLoaded: true })), this.setGlyphsUrl(t22.glyphs);
            const o3 = Pt(this.stylesheet.layers);
            if (this._order = o3.map((e22) => e22.id), this.stylesheet.light && e2.w("The `light` root property is deprecated, prefer using `lights` with `flat` light type instead."), this.stylesheet.lights) if (1 === this.stylesheet.lights.length && "flat" === this.stylesheet.lights[0].type) {
              const e22 = this.stylesheet.lights[0];
              this.light = new Pe(e22.properties, e22.id);
            } else this.setLights(this.stylesheet.lights);
            this.light || (this.light = new Pe(this.stylesheet.light)), this._layers = {};
            for (const t3 of o3) {
              const i3 = e2.dc(t3, this.scope, this._styleColorTheme.lut, this.options);
              0 !== i3.configDependencies.size && this._configDependentLayers.add(i3.fqid), i3.setEventedParent(this, { layer: { id: i3.id } }), this._layers[i3.id] = i3;
              const o4 = this.getOwnLayerSourceCache(i3), s4 = !!this.directionalLight && this.directionalLight.shadowsEnabled();
              o4 && i3.canCastShadows() && s4 && (o4.castsShadows = true);
            }
            this.stylesheet.featuresets && this.setFeaturesetSelectors(this.stylesheet.featuresets), this.stylesheet.models && this.addModelURLs(this.stylesheet.models);
            const s3 = this.stylesheet.terrain;
            s3 && (this.checkCanvasFingerprintNoise(), this.disableElevatedTerrain || this.terrainSetForDrapingOnly() || this._createTerrain(s3, 1)), this.stylesheet.fog && this._createFog(this.stylesheet.fog), this.stylesheet.snow && this._createSnow(this.stylesheet.snow), this.stylesheet.rain && this._createRain(this.stylesheet.rain), this.stylesheet.transition && this.setTransition(this.stylesheet.transition), this.fire(new e2.A("data", { dataType: "style" }));
            const r3 = this.isRootStyle();
            t22.imports ? this._loadImports(t22.imports, i22).then(() => {
              this._reloadImports(), this.fire(new e2.A(r3 ? "style.load" : "style.import.load"));
            }).catch((t3) => {
              this.fire(new e2.z(new Error("Failed to load imports", t3))), this.fire(new e2.A(r3 ? "style.load" : "style.import.load"));
            }) : (this._reloadImports(), this.fire(new e2.A(r3 ? "style.load" : "style.import.load")));
          };
          this._styleColorTheme.colorTheme = this.stylesheet["color-theme"];
          const r22 = this._styleColorTheme.colorThemeOverride ? this._styleColorTheme.colorThemeOverride : this._styleColorTheme.colorTheme;
          if (r22) {
            const t3 = this._evaluateColorThemeData(r22);
            this._loadColorTheme(t3).then(() => {
              s2();
            }).catch((t4) => {
              e2.w(`Couldn't load color theme from the stylesheet: ${t4}`), s2();
            });
          } else this._styleColorTheme.lut = null, s2();
        }
        isRootStyle() {
          return 0 === this.importDepth;
        }
        mergeAll() {
          let t22, i22, o2, s2, r22, n22, a22, l22, c22, h22;
          const d22 = {};
          this.terrain && this.terrain.scope !== this.scope && delete this.terrain, this.forEachFragmentStyle((e22) => {
            if (e22.stylesheet) {
              if (null != e22.light && (t22 = e22.light), e22.stylesheet.lights) for (const t3 of e22.stylesheet.lights) "ambient" === t3.type && null != e22.ambientLight && (i22 = e22.ambientLight), "directional" === t3.type && null != e22.directionalLight && (o2 = e22.directionalLight);
              s2 = this._prioritizeTerrain(s2, e22.terrain, e22.stylesheet.terrain), e22.stylesheet.fog && null != e22.fog && (r22 = e22.fog), e22.stylesheet.snow && null != e22.snow && (n22 = e22.snow), e22.stylesheet.rain && null != e22.rain && (a22 = e22.rain), null != e22.stylesheet.camera && (h22 = e22.stylesheet.camera), null != e22.stylesheet.projection && (l22 = e22.stylesheet.projection), null != e22.stylesheet.transition && (c22 = e22.stylesheet.transition), d22[e22.scope] = e22._styleColorTheme;
            }
          }), this.light = t22, this.ambientLight = i22, this.directionalLight = o2, this.fog = r22, this.snow = n22, this.rain = a22, this._styleColorThemeForScope = d22, null === s2 ? delete this.terrain : this.terrain = s2, this.camera = h22 || { "camera-projection": "perspective" }, this.projection = l22 || { name: "mercator" }, this.transition = e2.l({}, To, c22), this.mergeSources(), this.mergeLayers();
        }
        forEachFragmentStyle(e22) {
          const t22 = (i22) => {
            for (const e3 of i22.fragments) t22(e3.style);
            e22(i22);
          };
          t22(this);
        }
        _prioritizeTerrain(e22, t22, i22) {
          const o2 = e22 && 0 === e22.drapeRenderMode;
          return null === i22 ? t22 && 0 === t22.drapeRenderMode ? t22 : o2 ? e22 : null : null != t22 && (!e22 || o2 || t22 && 1 === t22.drapeRenderMode) ? t22 : e22;
        }
        mergeTerrain() {
          let e22;
          this.terrain && this.terrain.scope !== this.scope && delete this.terrain, this.forEachFragmentStyle((t22) => {
            e22 = this._prioritizeTerrain(e22, t22.terrain, t22.stylesheet.terrain);
          }), null === e22 ? delete this.terrain : this.terrain = e22;
        }
        mergeProjection() {
          let e22;
          this.forEachFragmentStyle((t22) => {
            null != t22.stylesheet.projection && (e22 = t22.stylesheet.projection);
          }), this.projection = e22 || { name: "mercator" };
        }
        mergeSources() {
          const t22 = {}, i22 = {}, o2 = {};
          this.forEachFragmentStyle((s2) => {
            for (const i3 in s2._sourceCaches) {
              const o3 = e2.C(i3, s2.scope);
              t22[o3] = s2._sourceCaches[i3];
            }
            for (const t3 in s2._otherSourceCaches) {
              const o3 = e2.C(t3, s2.scope);
              i22[o3] = s2._otherSourceCaches[t3];
            }
            for (const t3 in s2._symbolSourceCaches) {
              const i3 = e2.C(t3, s2.scope);
              o2[i3] = s2._symbolSourceCaches[t3];
            }
          }), this._mergedSourceCaches = t22, this._mergedOtherSourceCaches = i22, this._mergedSymbolSourceCaches = o2;
        }
        mergeLayers() {
          const t22 = {}, i22 = [], o2 = {};
          this._mergedSlots = [], this._has3DLayers = false, this._hasCircleLayers = false, this._hasSymbolLayers = false, this.forEachFragmentStyle((o3) => {
            for (const s3 of o3._order) {
              const r22 = o3._layers[s3];
              if ("slot" === r22.type) {
                const i3 = e2.d8(s3);
                if (t22[i3]) continue;
                t22[i3] = [];
              }
              r22.slot && t22[r22.slot] ? t22[r22.slot].push(r22) : i22.push(r22);
            }
          }), this._mergedOrder = [];
          const s2 = (i3 = []) => {
            for (const r22 of i3) if ("slot" === r22.type) {
              const i4 = e2.d8(r22.id);
              t22[i4] && s2(t22[i4]), this._mergedSlots.push(i4);
            } else {
              const t3 = e2.C(r22.id, r22.scope);
              this._mergedOrder.push(t3), o2[t3] = r22, r22.is3D(!!this.terrain) && (this._has3DLayers = true), "circle" === r22.type && (this._hasCircleLayers = true), "symbol" === r22.type && (this._hasSymbolLayers = true), "clip" === r22.type && (this._clipLayerPresent = true);
            }
          };
          s2(i22), this._mergedOrder.sort((e22, t3) => {
            const i3 = o2[e22], s3 = o2[t3];
            return i3.hasInitialOcclusionOpacityProperties ? s3.is3D(!!this.terrain) ? 1 : 0 : i3.is3D(!!this.terrain) && s3.hasInitialOcclusionOpacityProperties ? -1 : 0;
          }), this._mergedLayers = o2, this.updateDrapeFirstLayers(), this._buildingIndex.processLayersChanged();
        }
        terrainSetForDrapingOnly() {
          return !!this.terrain && 0 === this.terrain.drapeRenderMode;
        }
        getCamera() {
          return this.stylesheet.camera;
        }
        setCamera(t22) {
          return this.stylesheet.camera = e2.l({}, this.stylesheet.camera, t22), this.camera = this.stylesheet.camera, this;
        }
        _evaluateColorThemeData(t22) {
          return t22.data ? function(t3, i22, o2) {
            const s2 = e2.l({}, i22);
            for (const t4 of Object.keys(e2.a5.colorTheme)) void 0 === s2[t4] && (s2[t4] = e2.a5.colorTheme[t4].default);
            const r22 = new e2.a6(ho, t3, new Map(o2));
            return r22.setTransitionOrValue(s2, o2), r22.untransitioned().possiblyEvaluate(new e2.aa(0));
          }(this.scope, t22, this.options).get("data") : null;
        }
        _loadColorTheme(t22) {
          this._styleColorTheme.lutLoading = true, this._styleColorTheme.lutLoadingCorrelationID += 1;
          const i22 = this._styleColorTheme.lutLoadingCorrelationID;
          return new Promise((o2, s2) => {
            const r22 = "data:image/png;base64,";
            if (!t22 || 0 === t22.length) return this._styleColorTheme.lut = null, this._styleColorTheme.lutLoading = false, void o2();
            let n22 = t22;
            n22.startsWith(r22) || (n22 = r22 + n22);
            const a22 = e2.I.from("mapbox-reserved-lut"), l22 = new Image();
            l22.src = n22, l22.onerror = () => {
              this._styleColorTheme.lutLoading = false, s2(new Error("Failed to load image data"));
            }, l22.onload = () => {
              if (this._styleColorTheme.lutLoadingCorrelationID !== i22) return void o2();
              this._styleColorTheme.lutLoading = false;
              const { width: r3, height: n3, data: c22 } = e2.q.getImageData(l22);
              if (n3 > 32) return void s2(new Error("The height of the image must be less than or equal to 32 pixels."));
              if (r3 !== n3 * n3) return void s2(new Error("The width of the image must be equal to the height squared."));
              this.getImage(a22) && this.removeImage(a22), this.addImage(a22, { data: new e2.r({ width: r3, height: n3 }, c22), pixelRatio: 1, sdf: false, usvg: false, version: 0 });
              const h22 = this.imageManager.getImage(a22, this.scope);
              h22 ? (this._styleColorTheme.lut = { image: h22.data, data: t22 }, o2()) : s2(new Error("Missing LUT image."));
            };
          });
        }
        getLut(e22) {
          const t22 = this._styleColorThemeForScope[e22];
          return t22 ? t22.lut : null;
        }
        setProjection(e22) {
          e22 ? this.stylesheet.projection = e22 : delete this.stylesheet.projection, this.mergeProjection(), this._updateMapProjection();
        }
        applyProjectionUpdate() {
          this._loaded && (this.dispatcher.broadcast("setProjection", this.map.transform.projectionOptions), this.map.transform.projection.requiresDraping ? (this.getTerrain() || this.stylesheet.terrain) && !this.disableElevatedTerrain || this.setTerrainForDraping() : this.terrainSetForDrapingOnly() && this.setTerrain(null, 0));
        }
        _updateMapProjection() {
          this.isRootStyle() && (this.map._useExplicitProjection ? this.applyProjectionUpdate() : this.map._prioritizeAndUpdateProjection(null, this.projection));
        }
        _loadSprite(t22) {
          this._spriteRequest = function(t3, i22, o2) {
            let s2, r22, n22;
            const a22 = e2.q.devicePixelRatio > 1 ? "@2x" : "";
            let l22 = e2.n(i22.transformRequest(i22.normalizeSpriteURL(t3, a22, ".json"), e2.R.SpriteJSON), (e22, t4) => {
              l22 = null, n22 || (n22 = e22, s2 = t4, h22());
            }), c22 = e2.o(i22.transformRequest(i22.normalizeSpriteURL(t3, a22, ".png"), e2.R.SpriteImage), (e22, t4) => {
              c22 = null, n22 || (n22 = e22, r22 = t4, h22());
            });
            function h22() {
              if (n22) o2(n22);
              else if (s2 && r22) {
                const t4 = e2.q.getImageData(r22), i3 = {};
                for (const o3 in s2) {
                  const { width: r3, height: n3, x: a3, y: l3, sdf: c3, pixelRatio: h3, stretchX: d22, stretchY: u22, content: _22 } = s2[o3], p22 = new e2.r({ width: r3, height: n3 });
                  e2.r.copy(t4, p22, { x: a3, y: l3 }, { x: 0, y: 0 }, { width: r3, height: n3 }, null), i3[o3] = { data: p22, pixelRatio: h3, sdf: c3, stretchX: d22, stretchY: u22, content: _22, usvg: false };
                }
                o2(null, i3);
              }
            }
            return { cancel() {
              l22 && (l22.cancel(), l22 = null), c22 && (c22.cancel(), c22 = null);
            } };
          }(t22, this.map._requestManager, (t3, i22) => {
            if (this._spriteRequest = null, t3) this.fire(new e2.z(t3));
            else if (i22) {
              const t4 = /* @__PURE__ */ new Map();
              for (const o2 in i22) t4.set(e2.I.from(o2), i22[o2]);
              this.addImages(t4);
            }
            this.imageManager.setLoaded(true, this.scope), this.dispatcher.broadcast("spriteLoaded", { scope: this.scope, isLoaded: true }), this.fire(new e2.A("data", { dataType: "style" }));
          });
        }
        addIconset(t22, i22) {
          if ("sprite" === i22.type) return void this._loadSprite(i22.url);
          const o2 = this.getOwnSourceCache(i22.source);
          if (!o2) return void this.fire(new e2.z(new Error(`Source "${i22.source}" as specified by iconset "${t22}" does not exist and cannot be used as an iconset source`)));
          const s2 = o2.getSource();
          if ("raster-array" !== s2.type) return void this.fire(new e2.z(new Error(`Source "${i22.source}" as specified by iconset "${t22}" is not a "raster-array" source and cannot be used as an iconset source`)));
          s2.partial = false;
          const r22 = new go(t22, this.scope, o2);
          this.imageManager.addImageProvider(r22, this.scope);
        }
        removeIconset(e22) {
          this.imageManager.removeImageProvider(e22, this.scope);
        }
        _loadIconset(t22) {
          if (!e2.f(t22) && "icon_set" !== this.map._spriteFormat || "raster" === this.map._spriteFormat) return void this._loadSprite(t22);
          const i22 = "auto" === this.map._spriteFormat;
          var o2, s2;
          this._spriteRequest = (s2 = (o3, s3) => {
            if (this._spriteRequest = null, o3) i22 ? this._loadSprite(t22) : this.fire(new e2.z(o3));
            else if (s3) {
              const t3 = /* @__PURE__ */ new Map();
              for (const i3 in s3) t3.set(e2.I.from(i3), s3[i3]);
              this.addImages(t3);
            }
            this.imageManager.setLoaded(true, this.scope), this.dispatcher.broadcast("spriteLoaded", { scope: this.scope, isLoaded: true }), this.fire(new e2.A("data", { dataType: "style" }));
          }, e2.br((o2 = this.map._requestManager).transformRequest(o2.normalizeIconsetURL(t22), e2.R.Iconset), (t3, i3) => {
            if (t3) return void s2(t3);
            const o3 = {}, r22 = e2.c_(new e2.bq(i3));
            for (const t4 of r22.icons) {
              const i4 = { version: 1, pixelRatio: e2.q.devicePixelRatio, content: fo(t4), stretchX: t4.metadata ? mo(t4.metadata.stretch_x_areas) : void 0, stretchY: t4.metadata ? mo(t4.metadata.stretch_y_areas) : void 0, sdf: false, usvg: true, icon: t4 };
              o3[t4.name] = i4;
            }
            s2(null, o3);
          }));
        }
        _validateLayer(t22) {
          const i22 = this.getOwnSource(t22.source);
          if (!i22) return;
          const o2 = t22.sourceLayer;
          o2 && ("geojson" === i22.type || i22.vectorLayerIds && -1 === i22.vectorLayerIds.indexOf(o2)) && this.fire(new e2.z(new Error(`Source layer "${o2}" does not exist on source "${i22.id}" as specified by style layer "${t22.id}"`)));
        }
        loaded() {
          if (!this._loaded) return false;
          if (Object.keys(this._changes.getUpdatedSourceCaches()).length) return false;
          for (const e22 in this._sourceCaches) if (!this._sourceCaches[e22].loaded()) return false;
          if (!this.imageManager.isLoaded()) return false;
          if (this.imageManager.hasPatternsInFlight()) return false;
          if (!this.modelManager.isLoaded()) return false;
          if (this._styleColorTheme.lutLoading) return false;
          for (const { style: e22 } of this.fragments) if (!e22.loaded()) return false;
          return true;
        }
        _serializeImports() {
          if (this.stylesheet.imports) return this.stylesheet.imports.map((e22, t22) => {
            const i22 = this.fragments[t22];
            return i22 && i22.style && (e22.data = i22.style.serialize()), e22;
          });
        }
        _serializeSources() {
          const e22 = {};
          for (const t22 in this._sourceCaches) {
            const i22 = this._sourceCaches[t22].getSource();
            e22[i22.id] || (e22[i22.id] = i22.serialize());
          }
          return e22;
        }
        _serializeLayers(e22) {
          const t22 = [];
          for (const i22 of e22) {
            const e3 = this._layers[i22];
            e3 && "custom" !== e3.type && t22.push(e3.serialize());
          }
          return t22;
        }
        hasLightTransitions() {
          return !(!this.light || !this.light.hasTransition()) || !(!this.ambientLight || !this.ambientLight.hasTransition()) || !(!this.directionalLight || !this.directionalLight.hasTransition());
        }
        hasFogTransition() {
          return !!this.fog && this.fog.hasTransition();
        }
        hasSnowTransition() {
          return !!this.snow && this.snow.hasTransition();
        }
        hasRainTransition() {
          return !!this.rain && this.rain.hasTransition();
        }
        hasTransitions() {
          if (this.hasLightTransitions()) return true;
          if (this.hasFogTransition()) return true;
          if (this.hasSnowTransition()) return true;
          if (this.hasRainTransition()) return true;
          for (const e22 in this._sourceCaches) if (this._sourceCaches[e22].hasTransition()) return true;
          for (const e22 in this._layers) if (this._layers[e22].hasTransition()) return true;
          return false;
        }
        get order() {
          return this.terrain ? this._drapedFirstOrder : this._mergedOrder;
        }
        _getOrder(e22) {
          return e22 ? this.order : this._mergedOrder;
        }
        isLayerDraped(e22) {
          return !!this.terrain && e22.isDraped(this.getLayerSourceCache(e22));
        }
        _checkLoaded() {
          if (!this._loaded) throw new Error("Style is not done loading");
        }
        _checkLayer(t22) {
          const i22 = this.getOwnLayer(t22);
          if (i22) return i22;
          this.fire(new e2.z(new Error(`The layer '${t22}' does not exist in the map's style.`)));
        }
        _checkSource(t22) {
          const i22 = this.getOwnSource(t22);
          if (i22) return i22;
          this.fire(new e2.z(new Error(`The source '${t22}' does not exist in the map's style.`)));
        }
        precompilePrograms(e22, t22) {
          const i22 = this.map.painter;
          if (i22) for (let o2 = e22.minzoom || 0; o2 < (e22.maxzoom || 25.5); o2++) {
            const o3 = e22.getProgramIds();
            if (o3) for (const s2 of o3) {
              const o4 = e22.getDefaultProgramParams(s2, t22.zoom, this._styleColorTheme.lut);
              o4 && (i22.style = this, this.fog && (i22._fogVisible = true, o4.overrideFog = true, i22.getOrCreateProgram(s2, o4)), i22._fogVisible = false, o4.overrideFog = false, i22.getOrCreateProgram(s2, o4), (this.stylesheet.terrain || this.stylesheet.projection && "globe" === this.stylesheet.projection.name) && (o4.overrideRtt = true, i22.getOrCreateProgram(s2, o4)));
            }
          }
        }
        update(t22) {
          if (!this._loaded) return;
          this.ambientLight && this.ambientLight.recalculate(t22), this.directionalLight && this.directionalLight.recalculate(t22);
          const i22 = this.calculateLightsBrightness();
          t22.brightness = i22 || 0, i22 !== this._brightness && (this._brightness = i22, this.dispatcher.broadcast("setBrightness", i22));
          const o2 = this._changes.isDirty();
          let s2 = false;
          if (this._changes.isDirty()) {
            const e22 = this._changes.getLayerUpdatesByScope();
            for (const t3 in e22) {
              const { updatedIds: i3, removedIds: o3 } = e22[t3];
              (i3 || o3) && (this._updateWorkerLayers(t3, i3, o3), s2 = true);
            }
            this.updateSourceCaches(), this._updateTilesForChangedImages(), this.updateLayers(t22), this.light && this.light.updateTransitions(t22), this.ambientLight && this.ambientLight.updateTransitions(t22), this.directionalLight && this.directionalLight.updateTransitions(t22), this.fog && this.fog.updateTransitions(t22), this.snow && this.snow.updateTransitions(t22), this.rain && this.rain.updateTransitions(t22), this._changes.reset();
          }
          const r22 = {};
          for (const e22 in this._mergedSourceCaches) {
            const t3 = this._mergedSourceCaches[e22];
            r22[e22] = t3.used, t3.used = false, t3.tileCoverLift = 0;
          }
          for (const e22 of this._mergedOrder) {
            const i3 = this._mergedLayers[e22];
            if (i3.recalculate(t22, this._availableImages), !i3.isHidden(t22.zoom)) {
              const e3 = this.getLayerSourceCache(i3);
              e3 && (e3.used = true, e3.tileCoverLift = Math.max(e3.tileCoverLift, i3.tileCoverLift()));
            }
            !this._precompileDone && this._shouldPrecompile && ("requestIdleCallback" in window ? requestIdleCallback(() => {
              this.precompilePrograms(i3, t22);
            }) : this.precompilePrograms(i3, t22));
          }
          this._shouldPrecompile && (this._precompileDone = true), this.terrain && s2 && this.mergeLayers();
          const n22 = this.imageManager.getPendingImageProviders();
          for (const e22 of n22) e22.sourceCache.used = true;
          for (const t3 in r22) {
            const i3 = this._mergedSourceCaches[t3];
            r22[t3] !== i3.used && i3.getSource().fire(new e2.A("data", { sourceDataType: "visibility", dataType: "source", sourceId: i3.getSource().id }));
          }
          this.light && this.light.recalculate(t22), this.terrain && this.terrain.recalculate(t22), this.fog && this.fog.recalculate(t22), this.snow && this.snow.recalculate(t22), this.rain && this.rain.recalculate(t22), this.z = t22.zoom, this._markersNeedUpdate && (this._updateMarkersOpacity(), this._markersNeedUpdate = false), this.imageManager.clearUpdatedImages(this.scope), o2 && this.fire(new e2.A("data", { dataType: "style" }));
        }
        updateImageProviders() {
          const e22 = this.imageManager.getPendingImageProviders();
          for (const t22 of e22) {
            const e3 = t22.resolvePendingRequests(), i22 = this.getFragmentStyle(t22.scope);
            i22 && i22.addImages(e3);
          }
        }
        _updateTilesForChangedImages() {
          const e22 = {};
          for (const t22 in this._mergedSourceCaches) {
            const i22 = this._mergedSourceCaches[t22].getSource().scope;
            e22[i22] = e22[i22] || this._changes.getUpdatedImages(i22), 0 !== e22[i22].length && this._mergedSourceCaches[t22].reloadTilesForDependencies(["icons", "patterns"], e22[i22]);
          }
          for (const t22 in e22) this._changes.resetUpdatedImages(t22);
        }
        _updateWorkerLayers(e22, t22, i22) {
          const o2 = this.getFragmentStyle(e22);
          o2 && this.dispatcher.broadcast("updateLayers", { layers: t22 ? o2._serializeLayers(t22) : [], scope: e22, removedIds: i22 || [], options: o2.options });
        }
        setState(t22, i22) {
          if (this._checkLoaded(), vo(this, me(t22))) return false;
          (t22 = e2.d7(t22)).layers = Pt(t22.layers);
          const o2 = function(t3, i3) {
            if (!t3) return [{ command: zt.setStyle, args: [i3] }];
            let o3 = [];
            try {
              if (!e2.bv(t3.version, i3.version)) return [{ command: zt.setStyle, args: [i3] }];
              if (e2.bv(t3.center, i3.center) || o3.push({ command: zt.setCenter, args: [i3.center] }), e2.bv(t3.zoom, i3.zoom) || o3.push({ command: zt.setZoom, args: [i3.zoom] }), e2.bv(t3.bearing, i3.bearing) || o3.push({ command: zt.setBearing, args: [i3.bearing] }), e2.bv(t3.pitch, i3.pitch) || o3.push({ command: zt.setPitch, args: [i3.pitch] }), e2.bv(t3.sprite, i3.sprite) || o3.push({ command: zt.setSprite, args: [i3.sprite] }), e2.bv(t3.glyphs, i3.glyphs) || o3.push({ command: zt.setGlyphs, args: [i3.glyphs] }), e2.bv(t3.imports, i3.imports) || function(t4 = [], i4 = [], o4) {
                i4 = i4 || [];
                const s4 = (t4 = t4 || []).map(Nt), r4 = i4.map(Nt), n3 = t4.reduce(Ut2, {}), a3 = i4.reduce(Ut2, {}), l22 = s4.slice();
                let c22, h22, d22, u22;
                for (c22 = 0, h22 = 0; c22 < s4.length; c22++) d22 = s4[c22], a3.hasOwnProperty(d22) ? h22++ : (o4.push({ command: zt.removeImport, args: [d22] }), l22.splice(l22.indexOf(d22, h22), 1));
                for (c22 = 0, h22 = 0; c22 < r4.length; c22++) d22 = r4[r4.length - 1 - c22], l22[l22.length - 1 - c22] !== d22 && (n3.hasOwnProperty(d22) ? (o4.push({ command: zt.removeImport, args: [d22] }), l22.splice(l22.lastIndexOf(d22, l22.length - h22), 1)) : h22++, u22 = l22[l22.length - c22], o4.push({ command: zt.addImport, args: [a3[d22], u22] }), l22.splice(l22.length - c22, 0, d22));
                for (const t5 of i4) {
                  const i5 = n3[t5.id];
                  i5 && !e2.bv(i5, t5) && o4.push({ command: zt.updateImport, args: [t5.id, t5] });
                }
              }(t3.imports, i3.imports, o3), e2.bv(t3.transition, i3.transition) || o3.push({ command: zt.setTransition, args: [i3.transition] }), e2.bv(t3.light, i3.light) || o3.push({ command: zt.setLight, args: [i3.light] }), e2.bv(t3.fog, i3.fog) || o3.push({ command: zt.setFog, args: [i3.fog] }), e2.bv(t3.snow, i3.snow) || o3.push({ command: zt.setSnow, args: [i3.snow] }), e2.bv(t3.rain, i3.rain) || o3.push({ command: zt.setRain, args: [i3.rain] }), e2.bv(t3.projection, i3.projection) || o3.push({ command: zt.setProjection, args: [i3.projection] }), e2.bv(t3.lights, i3.lights) || o3.push({ command: zt.setLights, args: [i3.lights] }), e2.bv(t3.camera, i3.camera) || o3.push({ command: zt.setCamera, args: [i3.camera] }), e2.bv(t3.iconsets, i3.iconsets) || function(t4, i4, o4) {
                let s4;
                for (s4 in i4 = i4 || {}, t4 = t4 || {}) t4.hasOwnProperty(s4) && (i4.hasOwnProperty(s4) || o4.push({ command: zt.removeIconset, args: [s4] }));
                for (s4 in i4) {
                  if (!i4.hasOwnProperty(s4)) continue;
                  const r4 = i4[s4];
                  t4.hasOwnProperty(s4) ? e2.bv(t4[s4], r4) || (o4.push({ command: zt.removeIconset, args: [s4] }), o4.push({ command: zt.addIconset, args: [s4, r4] })) : o4.push({ command: zt.addIconset, args: [s4, r4] });
                }
              }(t3.iconsets, i3.iconsets, o3), !e2.bv(t3["color-theme"], i3["color-theme"])) return [{ command: zt.setStyle, args: [i3] }];
              const s3 = {}, r3 = [];
              !function(t4, i4, o4, s4) {
                let r4;
                for (r4 in i4 = i4 || {}, t4 = t4 || {}) t4.hasOwnProperty(r4) && (i4.hasOwnProperty(r4) || Ot2(r4, o4, s4));
                for (r4 in i4) {
                  if (!i4.hasOwnProperty(r4)) continue;
                  const n3 = i4[r4];
                  t4.hasOwnProperty(r4) ? e2.bv(t4[r4], n3) || ("geojson" === t4[r4].type && "geojson" === n3.type && Bt(t4, i4, r4) ? o4.push({ command: zt.setGeoJSONSourceData, args: [r4, n3.data] }) : Ft2(r4, i4, o4, s4)) : Mt(r4, i4, o4);
                }
              }(t3.sources, i3.sources, r3, s3);
              const n22 = [];
              t3.layers && t3.layers.forEach((e22) => {
                e22.source && s3[e22.source] ? o3.push({ command: zt.removeLayer, args: [e22.id] }) : n22.push(e22);
              });
              let a22 = t3.terrain;
              a22 && s3[a22.source] && (o3.push({ command: zt.setTerrain, args: [void 0] }), a22 = void 0), o3 = o3.concat(r3), e2.bv(a22, i3.terrain) || o3.push({ command: zt.setTerrain, args: [i3.terrain] }), function(t4, i4, o4) {
                i4 = i4 || [];
                const s4 = (t4 = t4 || []).map(Nt), r4 = i4.map(Nt), n3 = t4.reduce(Ut2, {}), a3 = i4.reduce(Ut2, {}), l22 = s4.slice(), c22 = /* @__PURE__ */ Object.create(null);
                let h22, d22, u22, _22, p22, f22, m22;
                for (h22 = 0, d22 = 0; h22 < s4.length; h22++) u22 = s4[h22], a3.hasOwnProperty(u22) ? d22++ : (o4.push({ command: zt.removeLayer, args: [u22] }), l22.splice(l22.indexOf(u22, d22), 1));
                for (h22 = 0, d22 = 0; h22 < r4.length; h22++) u22 = r4[r4.length - 1 - h22], l22[l22.length - 1 - h22] !== u22 && (n3.hasOwnProperty(u22) ? (o4.push({ command: zt.removeLayer, args: [u22] }), l22.splice(l22.lastIndexOf(u22, l22.length - d22), 1)) : d22++, f22 = l22[l22.length - h22], o4.push({ command: zt.addLayer, args: [a3[u22], f22] }), l22.splice(l22.length - h22, 0, u22), c22[u22] = true);
                for (h22 = 0; h22 < r4.length; h22++) if (u22 = r4[h22], _22 = n3[u22], p22 = a3[u22], !c22[u22] && !e2.bv(_22, p22)) if (e2.bv(_22.source, p22.source) && e2.bv(_22["source-layer"], p22["source-layer"]) && e2.bv(_22.type, p22.type)) {
                  for (m22 in kt(_22.layout, p22.layout, o4, u22, null, zt.setLayoutProperty), kt(_22.paint, p22.paint, o4, u22, null, zt.setPaintProperty), e2.bv(_22.slot, p22.slot) || o4.push({ command: zt.setSlot, args: [u22, p22.slot] }), e2.bv(_22.filter, p22.filter) || o4.push({ command: zt.setFilter, args: [u22, p22.filter] }), e2.bv(_22.minzoom, p22.minzoom) && e2.bv(_22.maxzoom, p22.maxzoom) || o4.push({ command: zt.setLayerZoomRange, args: [u22, p22.minzoom, p22.maxzoom] }), _22) _22.hasOwnProperty(m22) && "layout" !== m22 && "paint" !== m22 && "filter" !== m22 && "metadata" !== m22 && "minzoom" !== m22 && "maxzoom" !== m22 && "slot" !== m22 && (0 === m22.indexOf("paint.") ? kt(_22[m22], p22[m22], o4, u22, m22.slice(6), zt.setPaintProperty) : e2.bv(_22[m22], p22[m22]) || o4.push({ command: zt.setLayerProperty, args: [u22, m22, p22[m22]] }));
                  for (m22 in p22) p22.hasOwnProperty(m22) && !_22.hasOwnProperty(m22) && "layout" !== m22 && "paint" !== m22 && "filter" !== m22 && "metadata" !== m22 && "minzoom" !== m22 && "maxzoom" !== m22 && "slot" !== m22 && (0 === m22.indexOf("paint.") ? kt(_22[m22], p22[m22], o4, u22, m22.slice(6), zt.setPaintProperty) : e2.bv(_22[m22], p22[m22]) || o4.push({ command: zt.setLayerProperty, args: [u22, m22, p22[m22]] }));
                } else o4.push({ command: zt.removeLayer, args: [u22] }), f22 = l22[l22.lastIndexOf(u22) + 1], o4.push({ command: zt.addLayer, args: [p22, f22] });
              }(n22, i3.layers, o3);
            } catch (e22) {
              console.warn("Unable to compute style diff:", e22), o3 = [{ command: zt.setStyle, args: [i3] }];
            }
            return o3;
          }(this.serialize(), t22).filter((e22) => !(e22.command in xo));
          if (0 === o2.length) return false;
          const s2 = o2.filter((e22) => !(e22.command in yo));
          if (s2.length > 0) throw new Error(`Unimplemented: ${s2.map((e22) => e22.command).join(", ")}.`);
          const r22 = [];
          return o2.forEach((e22) => {
            r22.push(this[e22.command](...e22.args));
          }), i22 && Promise.all(r22).then(i22).catch(i22), this.stylesheet = t22, this.mergeAll(), this.dispatcher.broadcast("setLayers", { layers: this._serializeLayers(this._order), scope: this.scope, options: this.options }), true;
        }
        _updateWorkerImages() {
          this._availableImages = this.imageManager.listImages(this.scope), this.dispatcher.broadcast("setImages", { scope: this.scope, images: this._availableImages });
        }
        _updateWorkerModels() {
          this._availableModels = this.modelManager.getModelURIs(this.scope), this.dispatcher.broadcast("setModels", { scope: this.scope, models: this._availableModels });
        }
        addImages(t22) {
          for (const [i22, o2] of t22.entries()) {
            if (this.getImage(i22)) return this.fire(new e2.z(new Error(`An image with the name "${i22.name}" already exists.`)));
            this.imageManager.addImage(i22, this.scope, o2), this._changes.updateImage(i22, this.scope);
          }
          return this._updateWorkerImages(), this.fire(new e2.A("data", { dataType: "style" })), this;
        }
        addImage(t22, i22) {
          return this.getImage(t22) ? this.fire(new e2.z(new Error(`An image with the name "${t22.name}" already exists.`))) : (this.imageManager.addImage(t22, this.scope, i22), this._changes.updateImage(t22, this.scope), this._updateWorkerImages(), this.fire(new e2.A("data", { dataType: "style" })), this);
        }
        updateImage(t22, i22, o2 = false) {
          this.imageManager.updateImage(t22, this.scope, i22), o2 && (this._changes.updateImage(t22, this.scope), this._updateWorkerImages(), this.fire(new e2.A("data", { dataType: "style" })));
        }
        getImage(e22) {
          return this.imageManager.getImage(e22, this.scope);
        }
        removeImage(t22) {
          return this.getImage(t22) ? (this.imageManager.removeImage(t22, this.scope), this._changes.updateImage(t22, this.scope), this._updateWorkerImages(), this.fire(new e2.A("data", { dataType: "style" })), this) : this.fire(new e2.z(new Error("No image with this name exists.")));
        }
        listImages() {
          return this._checkLoaded(), this._availableImages.slice();
        }
        addModelURLs(t22) {
          return this.modelManager.addModelURLs(t22, this.scope), this._updateWorkerModels(), this.fire(new e2.A("data", { dataType: "style" })), this;
        }
        addModel(t22, i22, o2 = {}) {
          return this._checkLoaded(), this._validate(Re, `models.${t22}`, i22, null, o2) || (this.modelManager.addModel(t22, i22, this.scope), this.fire(new e2.A("data", { dataType: "style" }))), this;
        }
        hasModel(e22) {
          return this.modelManager.hasModel(e22, this.scope);
        }
        removeModel(t22) {
          return this.hasModel(t22) ? (this.modelManager.removeModel(t22, this.scope), this.fire(new e2.A("data", { dataType: "style" })), this) : this.fire(new e2.z(new Error("No model with this ID exists.")));
        }
        listModels() {
          return this._checkLoaded(), this.modelManager.listModels(this.scope);
        }
        addSource(t22, i22, o2 = {}) {
          if (this._checkLoaded(), void 0 !== this.getOwnSource(t22)) throw new Error(`There is already a source with ID "${t22}".`);
          if (!i22.type) throw new Error(`The type property must be defined, but only the following properties were given: ${Object.keys(i22).join(", ")}.`);
          if (["vector", "raster", "geojson", "video", "image"].indexOf(i22.type) >= 0 && this._validate(ge, `sources.${t22}`, i22, null, o2)) return;
          this.map && this.map._collectResourceTiming && (i22.collectResourceTiming = true);
          const s2 = nt(t22, i22, this.dispatcher, this);
          s2.scope = this.scope, s2.setEventedParent(this, () => ({ isSourceLoaded: this._isSourceCacheLoaded(s2.id), source: s2.serialize(), sourceId: s2.id }));
          const r22 = (t3) => {
            const i3 = (t3 ? "symbol:" : "other:") + s2.id, o3 = e2.C(i3, this.scope), r3 = this._sourceCaches[i3] = new It2(o3, s2, t3);
            (t3 ? this._symbolSourceCaches : this._otherSourceCaches)[s2.id] = r3, r3.onAdd(this.map);
          };
          r22(false), "vector" !== i22.type && "geojson" !== i22.type || r22(true), s2.onAdd && s2.onAdd(this.map), o2.isInitialLoad || (this.mergeSources(), this._changes.setDirty());
        }
        removeSource(t22) {
          this._checkLoaded();
          const i22 = this.getOwnSource(t22);
          if (!i22) throw new Error("There is no source with this ID");
          for (const i3 in this._layers) if (this._layers[i3].source === t22) return this.fire(new e2.z(new Error(`Source "${t22}" cannot be removed while layer "${i3}" is using it.`)));
          if (this.terrain && this.terrain.scope === this.scope && this.terrain.get().source === t22) return this.fire(new e2.z(new Error(`Source "${t22}" cannot be removed while terrain is using it.`)));
          if (this.stylesheet.iconsets) {
            const i3 = Object.entries(this.stylesheet.iconsets).find(([e22, i4]) => "source" === i4.type && i4.source === t22);
            if (i3) return this.fire(new e2.z(new Error(`Source "${t22}" cannot be removed while iconset "${i3[0]}" is using it.`)));
          }
          const o2 = this.getOwnSourceCaches(t22);
          for (const t3 of o2) {
            const i3 = e2.d8(t3.id);
            delete this._sourceCaches[i3], this._changes.discardSourceCacheUpdate(t3.id), t3.fire(new e2.A("data", { sourceDataType: "metadata", dataType: "source", sourceId: t3.getSource().id })), t3.setEventedParent(null), t3.clearTiles();
          }
          return delete this._otherSourceCaches[t22], delete this._symbolSourceCaches[t22], this.mergeSources(), i22.setEventedParent(null), i22.onRemove && i22.onRemove(this.map), this._changes.setDirty(), this;
        }
        setGeoJSONSourceData(e22, t22) {
          this._checkLoaded(), this.getOwnSource(e22).setData(t22), this._changes.setDirty();
        }
        getOwnSource(e22) {
          const t22 = this.getOwnSourceCache(e22);
          return t22 && t22.getSource();
        }
        getOwnSources() {
          const e22 = [];
          for (const t22 in this._otherSourceCaches) {
            const i22 = this.getOwnSourceCache(t22);
            i22 && e22.push(i22.getSource());
          }
          return e22;
        }
        areTilesLoaded() {
          const e22 = this._mergedSourceCaches;
          for (const t22 in e22) {
            const i22 = e22[t22]._tiles;
            for (const e3 in i22) {
              const t3 = i22[e3];
              if ("loaded" !== t3.state && "errored" !== t3.state) return false;
            }
          }
          return true;
        }
        setLights(t22) {
          if (this._checkLoaded(), !t22) return delete this.ambientLight, void delete this.directionalLight;
          const i22 = this._getTransitionParameters();
          for (const o3 of t22) {
            if (this._validate(ye, "lights", o3)) return;
            switch (o3.type) {
              case "ambient":
                if (this.ambientLight) {
                  const e22 = this.ambientLight;
                  e22.set(o3), e22.updateTransitions(i22);
                } else this.ambientLight = new $e(o3, qe || (qe = new e2.a7({ color: new e2.a8(e2.a5.properties_light_ambient.color), "color-use-theme": new e2.a8({ type: "string", default: "default", "property-type": "data-constant" }), intensity: new e2.a8(e2.a5.properties_light_ambient.intensity) })), this.scope, this.options);
                break;
              case "directional":
                if (this.directionalLight) {
                  const e22 = this.directionalLight;
                  e22.set(o3), e22.updateTransitions(i22);
                } else this.directionalLight = new $e(o3, Ze || (Ze = new e2.a7({ direction: new e2.an(e2.a5.properties_light_directional.direction), color: new e2.a8(e2.a5.properties_light_directional.color), "color-use-theme": new e2.a8({ type: "string", default: "default", "property-type": "data-constant" }), intensity: new e2.a8(e2.a5.properties_light_directional.intensity), "cast-shadows": new e2.a8(e2.a5.properties_light_directional["cast-shadows"]), "shadow-quality": new e2.a8(e2.a5.properties_light_directional["shadow-quality"]), "shadow-intensity": new e2.a8(e2.a5.properties_light_directional["shadow-intensity"]) })), this.scope, this.options);
            }
          }
          const o2 = new e2.aa(this.z || 0, i22);
          this.ambientLight && this.ambientLight.recalculate(o2), this.directionalLight && this.directionalLight.recalculate(o2), this._brightness = this.calculateLightsBrightness(), this.dispatcher.broadcast("setBrightness", this._brightness);
        }
        calculateLightsBrightness() {
          const t22 = this.directionalLight, i22 = this.ambientLight;
          if (!t22 || !i22) return;
          const o2 = (e22) => 0.2126 * (e22[0] <= 0.03928 ? e22[0] / 12.92 : Math.pow((e22[0] + 0.055) / 1.055, 2.4)) + 0.7152 * (e22[1] <= 0.03928 ? e22[1] / 12.92 : Math.pow((e22[1] + 0.055) / 1.055, 2.4)) + 0.0722 * (e22[2] <= 0.03928 ? e22[2] / 12.92 : Math.pow((e22[2] + 0.055) / 1.055, 2.4)), s2 = t22.properties.get("color").toRenderColor(null).toArray01(), r22 = t22.properties.get("intensity"), n22 = t22.properties.get("direction"), a22 = 1 - e2.cR(n22.x, n22.y, n22.z)[2] / 90, l22 = o2(s2) * r22 * a22, c22 = i22.properties.get("color").toRenderColor(null).toArray01(), h22 = i22.properties.get("intensity"), d22 = o2(c22) * h22;
          return Number(((l22 + d22) / 2).toFixed(6));
        }
        getBrightness() {
          return this._brightness;
        }
        getLights() {
          if (!this.enable3dLights()) return null;
          const e22 = [];
          return this.directionalLight && e22.push(this.directionalLight.get()), this.ambientLight && e22.push(this.ambientLight.get()), e22;
        }
        enable3dLights() {
          return !!this.ambientLight && !!this.directionalLight;
        }
        getFragmentStyle(t22) {
          if (null == t22 || "" === t22 && this.isRootStyle()) return this;
          if (e2.d9(t22)) {
            const i22 = e2.da(t22), o2 = this.fragments.find(({ id: e22 }) => e22 === i22);
            if (!o2) return;
            const s2 = e2.d8(t22);
            return o2.style.getFragmentStyle(s2);
          }
          {
            const e22 = this.fragments.find(({ id: e3 }) => e3 === t22);
            return e22 ? e22.style : void 0;
          }
        }
        setFeaturesetSelectors(t22) {
          if (!t22) return;
          const i22 = {}, o2 = (e22, t3 = "") => `${e22}::${t3}`;
          this._featuresetSelectors = {};
          for (const s2 in t22) {
            const r22 = this._featuresetSelectors[s2] = [];
            for (const n22 of t22[s2].selectors) {
              if (n22.featureNamespace) {
                const t4 = this.getOwnLayer(n22.layer);
                if (!t4) {
                  e2.w(`Layer is undefined for selector: ${n22.layer}`);
                  continue;
                }
                const r3 = o2(t4.source, t4.sourceLayer);
                if (r3 in i22 && i22[r3] !== n22.featureNamespace) {
                  e2.w(`"featureNamespace ${n22.featureNamespace} of featureset ${s2}'s selector is not associated to the same source, skip this selector`);
                  continue;
                }
                i22[r3] = n22.featureNamespace;
              }
              let t3;
              if (n22.properties) for (const i3 in n22.properties) {
                const o3 = e2.X(n22.properties[i3]);
                "success" === o3.result && (t3 = t3 || {}, t3[i3] = o3.value);
              }
              r22.push({ layerId: n22.layer, namespace: n22.featureNamespace, properties: t3, uniqueFeatureID: n22._uniqueFeatureID });
            }
          }
        }
        getFeaturesetDescriptors(e22) {
          const t22 = this.getFragmentStyle(e22);
          if (!t22 || !t22.stylesheet.featuresets) return [];
          const i22 = [];
          for (const e3 in t22.stylesheet.featuresets) i22.push({ featuresetId: e3, importId: t22.scope ? t22.scope : void 0 });
          return i22;
        }
        getFeaturesetLayers(t22, i22) {
          const o2 = this.getFragmentStyle(i22), s2 = o2.stylesheet.featuresets;
          if (!s2 || !s2[t22]) return this.fire(new e2.z(new Error(`The featureset '${t22}' does not exist in the map's style and cannot be queried.`))), [];
          const r22 = [];
          for (const e22 of s2[t22].selectors) {
            const t3 = o2.getOwnLayer(e22.layer);
            t3 && r22.push(t3);
          }
          return r22;
        }
        getConfigProperty(t22, i22) {
          const o2 = this.getFragmentStyle(t22);
          if (!o2) return null;
          const s2 = e2.C(i22, o2.scope), r22 = o2.options.get(s2), n22 = r22 ? r22.value || r22.default : null;
          return n22 ? n22.serialize() : null;
        }
        setConfigProperty(t22, i22, o2) {
          const s2 = this.getFragmentStyle(t22);
          if (!s2) return;
          const r22 = s2.stylesheet.indoor ? _o(s2.stylesheet.schema) : s2.stylesheet.schema;
          if (!r22 || !r22[i22]) return;
          const n22 = e2.X(o2);
          if ("success" !== n22.result) return void vo(this, n22.value);
          const a22 = n22.value.expression, l22 = e2.C(i22, s2.scope), c22 = s2.options.get(l22);
          if (!c22) return;
          let h22;
          const { minValue: d22, maxValue: u22, stepValue: _22, type: p22, values: f22 } = r22[i22], m22 = e2.X(r22[i22].default);
          "success" === m22.result && (h22 = m22.value.expression), h22 ? (this.options.set(l22, Object.assign({}, c22, { value: a22, default: h22, minValue: d22, maxValue: u22, stepValue: _22, type: p22, values: f22 })), this.updateConfigDependencies(i22)) : this.fire(new e2.z(new Error(`No schema defined for the config option "${i22}" in the "${t22}" fragment.`)));
        }
        getConfig(t22) {
          const i22 = this.getFragmentStyle(t22);
          if (!i22) return null;
          const o2 = i22.stylesheet.schema;
          if (!o2) return null;
          const s2 = {};
          for (const t3 in o2) {
            const o3 = e2.C(t3, i22.scope), r22 = i22.options.get(o3), n22 = r22 ? r22.value || r22.default : null;
            s2[t3] = n22 ? n22.serialize() : null;
          }
          return s2;
        }
        setConfig(e22, t22) {
          const i22 = this.getFragmentStyle(e22);
          i22 && (i22.updateConfig(t22, i22.stylesheet.schema), this.updateConfigDependencies());
        }
        getSchema(e22) {
          const t22 = this.getFragmentStyle(e22);
          return t22 ? t22.stylesheet.schema : null;
        }
        setSchema(e22, t22) {
          const i22 = this.getFragmentStyle(e22);
          i22 && (i22.stylesheet.schema = t22, i22.updateConfig(i22._config, t22), this.updateConfigDependencies());
        }
        updateConfig(t22, i22) {
          if (this._config = t22, t22 || i22) if (i22) for (const o2 in i22) {
            let s2, r22;
            const n22 = e2.X(i22[o2].default);
            if ("success" === n22.result && (s2 = n22.value.expression), t22 && void 0 !== t22[o2]) {
              const i3 = e2.X(t22[o2]);
              "success" === i3.result && (r22 = i3.value.expression);
            }
            const { minValue: a22, maxValue: l22, stepValue: c22, type: h22, values: d22 } = i22[o2];
            if (s2) {
              const t3 = e2.C(o2, this.scope);
              this.options.set(t3, { default: s2, value: r22, minValue: a22, maxValue: l22, stepValue: c22, type: h22, values: d22 });
            } else this.fire(new e2.z(new Error(`No schema defined for config option "${o2}".`)));
          }
          else this.fire(new e2.z(new Error("Attempting to set config for a style without schema.")));
        }
        updateConfigDependencies(e22) {
          for (const t22 of this._configDependentLayers) {
            const i22 = this.getLayer(t22);
            if (i22) {
              if (e22 && !i22.configDependencies.has(e22)) continue;
              i22.possiblyEvaluateVisibility(), this._updateLayer(i22);
            }
          }
          this.ambientLight && this.ambientLight.updateConfig(this.options), this.directionalLight && this.directionalLight.updateConfig(this.options), this.fog && this.fog.updateConfig(this.options), this.snow && this.snow.updateConfig(this.options), this.rain && this.rain.updateConfig(this.options), this.forEachFragmentStyle((e3) => {
            const t22 = e3._styleColorTheme.colorThemeOverride ? e3._styleColorTheme.colorThemeOverride : e3._styleColorTheme.colorTheme;
            if (t22) {
              const i22 = e3._evaluateColorThemeData(t22);
              (!e3._styleColorTheme.lut && "" !== i22 || e3._styleColorTheme.lut && i22 !== e3._styleColorTheme.lut.data) && e3.setColorTheme(t22);
            }
          }), this._changes.setDirty();
        }
        addLayer(t22, i22, o2 = {}) {
          this._checkLoaded();
          const s2 = t22.id;
          if (this._layers[s2]) return void this.fire(new e2.z(new Error(`Layer with id "${s2}" already exists on this map`)));
          let r22;
          if ("custom" === t22.type) {
            if (vo(this, e2.db(t22))) return;
            r22 = e2.dc(t22, this.scope, this._styleColorTheme.lut, this.options);
          } else {
            if ("object" == typeof t22.source && (this.addSource(s2, t22.source), t22 = e2.d7(t22), t22 = e2.l(t22, { source: s2 })), this._validate(Ee, `layers.${s2}`, t22, { arrayIndex: -1 }, o2)) return;
            r22 = e2.dc(t22, this.scope, this._styleColorTheme.lut, this.options), this._validateLayer(r22), r22.setEventedParent(this, { layer: { id: s2 } });
          }
          0 !== r22.configDependencies.size && this._configDependentLayers.add(r22.fqid);
          let n22 = this._order.length;
          if (i22) {
            const t3 = this._order.indexOf(i22);
            if (-1 === t3) return void this.fire(new e2.z(new Error(`Layer with id "${i22}" does not exist on this map.`)));
            r22.slot === this._layers[i22].slot ? n22 = t3 : e2.w(`Layer with id "${i22}" has a different slot. Layers can only be rearranged within the same slot.`);
          }
          this._order.splice(n22, 0, s2), this._layerOrderChanged = true, this._layers[s2] = r22;
          const a22 = this.getOwnLayerSourceCache(r22), l22 = !!this.directionalLight && this.directionalLight.shadowsEnabled();
          a22 && r22.canCastShadows() && l22 && (a22.castsShadows = true);
          const c22 = this._changes.getRemovedLayer(r22);
          if (c22 && r22.source && a22 && "custom" !== r22.type) {
            this._changes.discardLayerRemoval(r22);
            const t3 = e2.C(r22.source, r22.scope);
            c22.type !== r22.type ? this._changes.updateSourceCache(t3, "clear") : (this._changes.updateSourceCache(t3, "reload"), a22.pause());
          }
          this._updateLayer(r22), r22.onAdd && r22.onAdd(this.map), r22.scope = this.scope, this.mergeLayers();
        }
        moveLayer(t22, i22) {
          this._checkLoaded();
          const o2 = this._checkLayer(t22);
          if (!o2) return;
          if (t22 === i22) return;
          const s2 = this._order.indexOf(t22);
          this._order.splice(s2, 1);
          let r22 = this._order.length;
          if (i22) {
            const t3 = this._order.indexOf(i22);
            if (-1 === t3) return void this.fire(new e2.z(new Error(`Layer with id "${i22}" does not exist on this map.`)));
            o2.slot === this._layers[i22].slot ? r22 = t3 : e2.w(`Layer with id "${i22}" has a different slot. Layers can only be rearranged within the same slot.`);
          }
          this._order.splice(r22, 0, t22), this._changes.setDirty(), this._layerOrderChanged = true, this.mergeLayers();
        }
        removeLayer(e22) {
          this._checkLoaded();
          const t22 = this._checkLayer(e22);
          if (!t22) return;
          t22.setEventedParent(null);
          const i22 = this._order.indexOf(e22);
          this._order.splice(i22, 1), delete this._layers[e22], this._changes.setDirty(), this._layerOrderChanged = true, this._configDependentLayers.delete(t22.fqid), this._changes.removeLayer(t22);
          const o2 = this.getOwnLayerSourceCache(t22);
          if (o2 && o2.castsShadows) {
            let e3 = false;
            for (const i3 in this._layers) if (this._layers[i3].source === t22.source && this._layers[i3].canCastShadows()) {
              e3 = true;
              break;
            }
            o2.castsShadows = e3;
          }
          t22.onRemove && t22.onRemove(this.map), this.mergeLayers();
        }
        getOwnLayer(e22) {
          return this._layers[e22];
        }
        hasLayer(e22) {
          return e22 in this._mergedLayers;
        }
        hasLayerType(e22) {
          for (const t22 in this._layers) if (this._layers[t22].type === e22) return true;
          return false;
        }
        setLayerZoomRange(e22, t22, i22) {
          this._checkLoaded();
          const o2 = this._checkLayer(e22);
          o2 && (o2.minzoom === t22 && o2.maxzoom === i22 || (null != t22 && (o2.minzoom = t22), null != i22 && (o2.maxzoom = i22), this._updateLayer(o2)));
        }
        getSlots() {
          return this._checkLoaded(), this._mergedSlots;
        }
        setSlot(e22, t22) {
          this._checkLoaded();
          const i22 = this._checkLayer(e22);
          i22 && i22.slot !== t22 && (i22.slot = t22, this._updateLayer(i22));
        }
        setFilter(t22, i22, o2 = {}) {
          this._checkLoaded();
          const s2 = this._checkLayer(t22);
          if (s2 && !e2.bv(s2.filter, i22)) return null == i22 ? (s2.filter = void 0, void this._updateLayer(s2)) : void (this._validate(Se, `layers.${s2.id}.filter`, i22, { layerType: s2.type }, o2) || (s2.filter = e2.d7(i22), this._updateLayer(s2)));
        }
        getFilter(t22) {
          const i22 = this._checkLayer(t22);
          if (i22) return e2.d7(i22.filter);
        }
        setLayoutProperty(t22, i22, o2, s2 = {}) {
          this._checkLoaded();
          const r22 = this._checkLayer(t22);
          if (r22 && !e2.bv(r22.getLayoutProperty(i22), o2)) {
            if (null != o2 && (!s2 || false !== s2.validate) && vo(r22, Ce.call(me, { key: `layers.${t22}.layout.${i22}`, layerType: r22.type, objectKey: i22, value: o2, styleSpec: e2.a5, style: { glyphs: true, sprite: true } }))) return;
            r22.setLayoutProperty(i22, o2), 0 !== r22.configDependencies.size && this._configDependentLayers.add(r22.fqid), this._updateLayer(r22);
          }
        }
        getLayoutProperty(e22, t22) {
          const i22 = this._checkLayer(e22);
          if (i22) return i22.getLayoutProperty(t22);
        }
        setPaintProperty(t22, i22, o2, s2 = {}) {
          this._checkLoaded();
          const r22 = this._checkLayer(t22);
          if (!r22) return;
          if (e2.bv(r22.getPaintProperty(i22), o2)) return;
          if (null != o2 && (!s2 || false !== s2.validate) && vo(r22, Ie.call(me, { key: `layers.${t22}.paint.${i22}`, layerType: r22.type, objectKey: i22, value: o2, styleSpec: e2.a5 }))) return;
          const n22 = r22.setPaintProperty(i22, o2);
          0 !== r22.configDependencies.size && this._configDependentLayers.add(r22.fqid), n22 && this._updateLayer(r22), this._changes.updatePaintProperties(r22);
        }
        getPaintProperty(e22, t22) {
          const i22 = this._checkLayer(e22);
          if (i22) return i22.getPaintProperty(t22);
        }
        setFeatureState(t22, i22) {
          if (this._checkLoaded(), "target" in t22) {
            if ("featuresetId" in t22.target) {
              const { featuresetId: e22, importId: o3 } = t22.target, s3 = this.getFragmentStyle(o3), r3 = s3.getFeaturesetLayers(e22);
              for (const { source: e3, sourceLayer: o4 } of r3) s3.setFeatureState({ id: t22.id, source: e3, sourceLayer: o4 }, i22);
            } else if ("layerId" in t22.target) {
              const { layerId: e22 } = t22.target, o3 = this.getLayer(e22);
              this.setFeatureState({ id: t22.id, source: o3.source, sourceLayer: o3.sourceLayer }, i22);
            }
            return;
          }
          const o2 = t22.source, s2 = t22.sourceLayer, r22 = this._checkSource(o2);
          if (!r22) return;
          const n22 = r22.type;
          if ("geojson" === n22 && s2) return void this.fire(new e2.z(new Error("GeoJSON sources cannot have a sourceLayer parameter.")));
          if ("vector" === n22 && !s2) return void this.fire(new e2.z(new Error("The sourceLayer parameter must be provided for vector source types.")));
          void 0 === t22.id && this.fire(new e2.z(new Error("The feature id parameter must be provided.")));
          const a22 = this.getOwnSourceCaches(o2);
          for (const e22 of a22) e22.setFeatureState(s2, t22.id, i22);
        }
        removeFeatureState(t22, i22) {
          if (this._checkLoaded(), "target" in t22) {
            if ("featuresetId" in t22.target) {
              const { featuresetId: e22, importId: o3 } = t22.target, s3 = this.getFragmentStyle(o3), r3 = s3.getFeaturesetLayers(e22);
              for (const { source: e3, sourceLayer: o4 } of r3) s3.removeFeatureState({ id: t22.id, source: e3, sourceLayer: o4 }, i22);
            } else if ("layerId" in t22.target) {
              const { layerId: e22 } = t22.target, o3 = this.getLayer(e22);
              this.removeFeatureState({ id: t22.id, source: o3.source, sourceLayer: o3.sourceLayer }, i22);
            }
            return;
          }
          const o2 = t22.source, s2 = this._checkSource(o2);
          if (!s2) return;
          const r22 = s2.type, n22 = "vector" === r22 ? t22.sourceLayer : void 0;
          if ("vector" === r22 && !n22) return void this.fire(new e2.z(new Error("The sourceLayer parameter must be provided for vector source types.")));
          if (i22 && "string" != typeof t22.id && "number" != typeof t22.id) return void this.fire(new e2.z(new Error("A feature id is required to remove its specific state property.")));
          const a22 = this.getOwnSourceCaches(o2);
          for (const e22 of a22) e22.removeFeatureState(n22, t22.id, i22);
        }
        getFeatureState(t22) {
          if (this._checkLoaded(), "target" in t22) {
            let i3;
            if ("featuresetId" in t22.target) {
              const { featuresetId: o3, importId: s3 } = t22.target, r22 = this.getFragmentStyle(s3), n22 = r22.getFeaturesetLayers(o3);
              for (const { source: o4, sourceLayer: s4 } of n22) {
                const n3 = r22.getFeatureState({ id: t22.id, source: o4, sourceLayer: s4 });
                if (n3 && !i3) i3 = n3;
                else if (!e2.bv(i3, n3)) return void this.fire(new e2.z(new Error("The same feature id exists in multiple sources in the featureset, but their feature states are not consistent through the sources.")));
              }
            } else if ("layerId" in t22.target) {
              const { layerId: e22 } = t22.target, o3 = this.getLayer(e22);
              i3 = this.getFeatureState({ id: t22.id, source: o3.source, sourceLayer: o3.sourceLayer });
            }
            return i3;
          }
          const i22 = t22.source, o2 = t22.sourceLayer, s2 = this._checkSource(i22);
          if (s2) {
            if ("vector" !== s2.type || o2) return void 0 === t22.id && this.fire(new e2.z(new Error("The feature id parameter must be provided."))), this.getOwnSourceCaches(i22)[0].getFeatureState(o2, t22.id);
            this.fire(new e2.z(new Error("The sourceLayer parameter must be provided for vector source types.")));
          }
        }
        setTransition(t22) {
          return this.stylesheet.transition = e2.l({}, this.stylesheet.transition, t22), this.transition = this.stylesheet.transition, this;
        }
        getTransition() {
          return e2.l({}, this.stylesheet.transition);
        }
        serialize() {
          this._checkLoaded();
          const t22 = this.getTerrain(), i22 = t22 && this.terrain && this.terrain.scope === this.scope ? t22 : this.stylesheet.terrain;
          return e2.dd({ version: this.stylesheet.version, name: this.stylesheet.name, metadata: this.stylesheet.metadata, fragment: this.stylesheet.fragment, iconsets: this.stylesheet.iconsets, imports: this._serializeImports(), schema: this.stylesheet.schema, camera: this.stylesheet.camera, light: this.stylesheet.light, lights: this.stylesheet.lights, terrain: i22, fog: this.stylesheet.fog, snow: this.stylesheet.snow, rain: this.stylesheet.rain, center: this.stylesheet.center, "color-theme": this.stylesheet["color-theme"], zoom: this.stylesheet.zoom, bearing: this.stylesheet.bearing, pitch: this.stylesheet.pitch, sprite: this.stylesheet.sprite, glyphs: this.stylesheet.glyphs, transition: this.stylesheet.transition, projection: this.stylesheet.projection, sources: this._serializeSources(), layers: this._serializeLayers(this._order) }, (e22) => void 0 !== e22);
        }
        _updateFilteredLayers(e22) {
          for (const t22 of Object.values(this._mergedLayers)) e22(t22) && this._updateLayer(t22);
        }
        _updateLayer(t22) {
          this._changes.updateLayer(t22);
          const i22 = this.getLayerSourceCache(t22), o2 = e2.C(t22.source, t22.scope), s2 = this._changes.getUpdatedSourceCaches();
          t22.source && !s2[o2] && i22 && "raster" !== i22.getSource().type && (this._changes.updateSourceCache(o2, "reload"), i22.pause()), t22.invalidateCompiledFilter();
        }
        _flattenAndSortRenderedFeatures(e22) {
          const t22 = (e3) => this._mergedLayers[e3].is3D(!!this.terrain), i22 = this.order, o2 = {}, s2 = [];
          for (let r3 = i22.length - 1; r3 >= 0; r3--) {
            const n22 = i22[r3];
            if (t22(n22)) {
              o2[n22] = r3;
              for (const t3 of e22) {
                const e3 = t3[n22];
                if (e3) for (const t4 of e3) s2.push(t4);
              }
            }
          }
          s2.sort((e3, t3) => t3.intersectionZ - e3.intersectionZ);
          const r22 = [];
          for (let n22 = i22.length - 1; n22 >= 0; n22--) {
            const a22 = i22[n22];
            if (t22(a22)) for (let e3 = s2.length - 1; e3 >= 0; e3--) {
              const t3 = s2[e3].feature;
              if (t3.layer && o2[t3.layer.id] < n22) break;
              r22.push(t3), s2.pop();
            }
            else for (const t3 of e22) {
              const e3 = t3[a22];
              if (e3) for (const t4 of e3) r22.push(t4.feature);
            }
          }
          return r22;
        }
        queryRenderedFeatures(t22, i22, o2) {
          let s2;
          i22 && !Array.isArray(i22) && i22.filter && (this._validate(Se, "queryRenderedFeatures.filter", i22.filter, null, i22), s2 = e2.b3(i22.filter));
          const r22 = {}, n22 = (e22) => {
            if (bo.has(e22.type)) return;
            const t3 = this.getOwnLayerSourceCache(e22), i3 = r22[t3.id] = r22[t3.id] || { sourceCache: t3, layers: {}, has3DLayers: false };
            e22.is3D(!!this.terrain) && (i3.has3DLayers = true), i3.layers[e22.fqid] = i3.layers[e22.fqid] || { styleLayer: e22, targets: [] }, i3.layers[e22.fqid].targets.push({ filter: s2 });
          };
          if (i22 && i22.layers) {
            if (!Array.isArray(i22.layers)) return this.fire(new e2.z(new Error("parameters.layers must be an Array."))), [];
            for (const t3 of i22.layers) {
              const i3 = this._layers[t3];
              if (!i3) return this.fire(new e2.z(new Error(`The layer '${t3}' does not exist in the map's style and cannot be queried for features.`))), [];
              n22(i3);
            }
          } else for (const e22 in this._layers) n22(this._layers[e22]);
          const a22 = this._queryRenderedFeatures(t22, r22, o2), l22 = this._flattenAndSortRenderedFeatures(a22), c22 = [];
          for (const t3 of l22) e2.de(t3.layer.id) === this.scope && c22.push(t3);
          return c22;
        }
        queryRenderedFeatureset(t22, i22, o2) {
          let s2;
          i22 && !Array.isArray(i22) && i22.filter && (this._validate(Se, "queryRenderedFeatures.filter", i22.filter, null, i22), s2 = e2.b3(i22.filter));
          const r22 = "mock", n22 = [];
          if (i22 && i22.target) n22.push(Object.assign({}, i22, { targetId: r22, filter: s2 }));
          else {
            const e22 = this.getFeaturesetDescriptors();
            for (const t3 of e22) n22.push({ targetId: r22, filter: s2, target: t3 });
            for (const { style: e3 } of this.fragments) {
              const t3 = e3.getFeaturesetDescriptors();
              for (const e4 of t3) n22.push({ targetId: r22, filter: s2, target: e4 });
            }
          }
          const a22 = this.queryRenderedTargets(t22, n22, o2), l22 = [], c22 = /* @__PURE__ */ new Set();
          for (const t3 of a22) for (const i3 of t3.variants[r22]) lt(i3, t3, c22) || l22.push(new e2.df(t3, i3));
          return l22;
        }
        queryRenderedTargets(t22, i22, o2) {
          const s2 = {}, r22 = (e22, t3, i3, o3) => {
            const r3 = s2[t3.id] = s2[t3.id] || { sourceCache: t3, layers: {}, has3DLayers: false };
            if (r3.layers[e22.fqid] = r3.layers[e22.fqid] || { styleLayer: e22, targets: [] }, e22.is3D(!!this.terrain) && (r3.has3DLayers = true), !o3) return i3.uniqueFeatureID = false, void r3.layers[e22.fqid].targets.push(i3);
            r3.layers[e22.fqid].targets.push(Object.assign({}, i3, { namespace: o3.namespace, properties: o3.properties, uniqueFeatureID: o3.uniqueFeatureID }));
          };
          for (const t3 of i22) if ("featuresetId" in t3.target) {
            const { featuresetId: i3, importId: o3 } = t3.target, s3 = this.getFragmentStyle(o3);
            if (!s3 || !s3._featuresetSelectors) continue;
            const n3 = s3._featuresetSelectors[i3];
            if (!n3) {
              this.fire(new e2.z(new Error(`The featureset '${i3}' does not exist in the map's style and cannot be queried for features.`)));
              continue;
            }
            for (const e22 of n3) {
              const i4 = s3.getOwnLayer(e22.layerId);
              i4 && !bo.has(i4.type) && r22(i4, s3.getOwnLayerSourceCache(i4), t3, e22);
            }
          } else if ("layerId" in t3.target) {
            const { layerId: e22 } = t3.target, i3 = this.getLayer(e22);
            if (!i3 || bo.has(i3.type)) continue;
            r22(i3, this.getLayerSourceCache(i3), t3);
          }
          const n22 = this._queryRenderedFeatures(t22, s2, o2);
          return this._flattenAndSortRenderedFeatures(n22);
        }
        _queryRenderedFeatures(e22, t22, i22) {
          const o2 = [], s2 = !!this.map._showQueryGeometry, r22 = Xe.createFromScreenPoints(e22, i22);
          for (const e3 in t22) {
            const n22 = ct2(r22, t22[e3], this._availableImages, i22, s2);
            Object.keys(n22).length && o2.push(n22);
          }
          if (this.placement) for (const e3 in t22) {
            if (!t22[e3].sourceCache._onlySymbols) continue;
            const i3 = ht(r22.screenGeometry, t22[e3], this._availableImages, this.placement.collisionIndex, this.placement.retainedQueryData);
            Object.keys(i3).length && o2.push(i3);
          }
          return o2;
        }
        querySourceFeatures(e22, t22) {
          const i22 = t22 && t22.filter;
          i22 && this._validate(Se, "querySourceFeatures.filter", i22, null, t22);
          let o2 = [];
          const s2 = this.getOwnSourceCaches(e22);
          for (const e3 of s2) o2 = o2.concat(dt(e3, t22));
          return o2;
        }
        addSourceType(e22, t22, i22) {
          return Eo.getSourceType(e22) ? i22(new Error(`A source type called "${e22}" already exists.`)) : (Eo.setSourceType(e22, t22), t22.workerSourceURL ? void this.dispatcher.broadcast("loadWorkerSource", { name: e22, url: t22.workerSourceURL }, i22) : i22(null, null));
        }
        getFlatLight() {
          return this.light.getLight();
        }
        setFlatLight(t22, i22, o2 = {}) {
          this._checkLoaded();
          const s2 = this.light.getLight();
          let r22 = false;
          for (const i3 in t22) if (!e2.bv(t22[i3], s2[i3])) {
            r22 = true;
            break;
          }
          if (!r22) return;
          const n22 = this._getTransitionParameters();
          this.light.setLight(t22, i22, o2), this.light.updateTransitions(n22);
        }
        getTerrain() {
          return this.terrain && 1 === this.terrain.drapeRenderMode ? this.terrain.get() : null;
        }
        setTerrainForDraping() {
          this.setTerrain({ source: "", exaggeration: 0 }, 0);
        }
        checkCanvasFingerprintNoise() {
          void 0 === this.disableElevatedTerrain && (this.disableElevatedTerrain = e2.q.hasCanvasFingerprintNoise(), this.disableElevatedTerrain && e2.w("Terrain and hillshade are disabled because of Canvas2D limitations when fingerprinting protection is enabled (e.g. in private browsing mode)."));
        }
        setTerrain(t22, i22 = 1) {
          if (this._checkLoaded(), !t22) return this.terrainSetForDrapingOnly() || (delete this.terrain, this.map.transform.projection.requiresDraping && this.setTerrainForDraping()), 0 === i22 && delete this.terrain, null === t22 ? this.stylesheet.terrain = null : delete this.stylesheet.terrain, this._force3DLayerUpdate(), void (this._markersNeedUpdate = true);
          this.checkCanvasFingerprintNoise();
          let o2 = t22;
          const s2 = null == t22.source;
          if (1 === i22) {
            if (this.disableElevatedTerrain) return;
            if ("object" == typeof o2.source) {
              const t4 = "terrain-dem-src";
              this.addSource(t4, o2.source), o2 = e2.d7(o2), o2 = e2.l(o2, { source: t4 });
            }
            const t3 = e2.l({}, o2), i3 = {};
            if (this.terrain && s2) {
              t3.source = this.terrain.get().source;
              const e22 = this.terrain ? this.getFragmentStyle(this.terrain.scope) : null;
              e22 && (i3.style = e22.serialize());
            }
            if (this._validate(xe, "terrain", t3, i3)) return;
          }
          if (!this.terrain || this.terrain.scope !== this.scope && !s2 || this.terrain && i22 !== this.terrain.drapeRenderMode) {
            if (!o2) return;
            this._createTerrain(o2, i22), this.fire(new e2.A("data", { dataType: "style" }));
          } else {
            const i3 = this.terrain, s3 = i3.get();
            for (const t3 of Object.keys(e2.a5.terrain)) !o2.hasOwnProperty(t3) && e2.a5.terrain[t3].default && (o2[t3] = e2.a5.terrain[t3].default);
            for (const o3 in t22) if (!e2.bv(t22[o3], s3[o3])) {
              i3.set(t22, this.options), this.stylesheet.terrain = t22;
              const o4 = this._getTransitionParameters({ duration: 0 });
              i3.updateTransitions(o4), this.fire(new e2.A("data", { dataType: "style" }));
              break;
            }
          }
          this.mergeTerrain(), this.updateDrapeFirstLayers(), this._markersNeedUpdate = true;
        }
        _createFog(e22) {
          const t22 = this.fog = new je(e22, this.map.transform, this.scope, this.options);
          this.stylesheet.fog = t22.get();
          const i22 = this._getTransitionParameters({ duration: 0 });
          t22.updateTransitions(i22);
        }
        _createSnow(e22) {
          const t22 = this.snow = new He(e22, this.map.transform, this.scope, this.options);
          this.stylesheet.snow = t22.get();
          const i22 = this._getTransitionParameters({ duration: 0 });
          t22.updateTransitions(i22);
        }
        _createRain(e22) {
          const t22 = this.rain = new We(e22, this.map.transform, this.scope, this.options);
          this.stylesheet.rain = t22.get();
          const i22 = this._getTransitionParameters({ duration: 0 });
          t22.updateTransitions(i22);
        }
        _updateMarkersOpacity() {
          0 !== this.map._markers.length && this.map._requestDomTask(() => {
            for (const e22 of this.map._markers) e22._evaluateOpacity();
          });
        }
        getFog() {
          return this.fog ? this.fog.get() : null;
        }
        setFog(t22) {
          if (this._checkLoaded(), !t22) return delete this.fog, delete this.stylesheet.fog, void (this._markersNeedUpdate = true);
          if (this.fog) {
            const i22 = this.fog;
            if (!e2.bv(i22.get(), t22)) {
              i22.set(t22, this.options), this.stylesheet.fog = i22.get();
              const e22 = this._getTransitionParameters({ duration: 0 });
              i22.updateTransitions(e22);
            }
          } else this._createFog(t22);
          this._markersNeedUpdate = true;
        }
        getSnow() {
          return this.snow ? this.snow.get() : null;
        }
        setSnow(t22) {
          if (this._checkLoaded(), !t22) return delete this.snow, void delete this.stylesheet.snow;
          if (this.snow) {
            const i22 = this.snow;
            if (!e2.bv(i22.get(), t22)) {
              i22.set(t22, this.options), this.stylesheet.snow = i22.get();
              const e22 = this._getTransitionParameters({ duration: 0 });
              i22.updateTransitions(e22);
            }
          } else this._createSnow(t22);
          this._markersNeedUpdate = true;
        }
        getRain() {
          return this.rain ? this.rain.get() : null;
        }
        setRain(t22) {
          if (this._checkLoaded(), !t22) return delete this.rain, void delete this.stylesheet.rain;
          if (this.rain) {
            const i22 = this.rain;
            if (!e2.bv(i22.get(), t22)) {
              i22.set(t22, this.options), this.stylesheet.rain = i22.get();
              const e22 = this._getTransitionParameters({ duration: 0 });
              i22.updateTransitions(e22);
            }
          } else this._createRain(t22);
          this._markersNeedUpdate = true;
        }
        _reloadColorTheme() {
          const t22 = () => {
            for (const e22 in this._layers) this._layers[e22].lut = this._styleColorTheme.lut;
            for (const e22 in this._sourceCaches) this._sourceCaches[e22].clearTiles();
          }, i22 = this._styleColorTheme.colorThemeOverride ? this._styleColorTheme.colorThemeOverride : this._styleColorTheme.colorTheme;
          if (!i22) return this._styleColorTheme.lut = null, void t22();
          const o2 = this._evaluateColorThemeData(i22);
          this._loadColorTheme(o2).then(() => {
            this.fire(new e2.A("colorthemeset")), t22();
          }).catch((t3) => {
            e2.w(`Couldn't set color theme: ${t3}`);
          });
        }
        setColorTheme(t22) {
          this._checkLoaded(), this._styleColorTheme.colorThemeOverride && e2.w("Note: setColorTheme is called on a style with a color-theme override, the passed color-theme won't be visible."), this._styleColorTheme.colorTheme = t22, this._reloadColorTheme();
        }
        setImportColorTheme(e22, t22) {
          const i22 = this.getFragmentStyle(e22);
          i22 && (i22._styleColorTheme.colorThemeOverride = t22, i22._reloadColorTheme());
        }
        _getTransitionParameters(t22) {
          return { now: e2.q.now(), transition: e2.l(this.transition, t22) };
        }
        updateDrapeFirstLayers() {
          if (!this.terrain) return;
          const e22 = [], t22 = [];
          for (const i22 of this._mergedOrder) this.isLayerDraped(this._mergedLayers[i22]) ? e22.push(i22) : t22.push(i22);
          this._drapedFirstOrder = [], this._drapedFirstOrder.push(...e22), this._drapedFirstOrder.push(...t22);
        }
        _createTerrain(e22, t22) {
          const i22 = this.terrain = new ze(e22, t22, this.scope, this.options);
          1 === t22 && (this.stylesheet.terrain = e22), this.mergeTerrain(), this.updateDrapeFirstLayers(), this._force3DLayerUpdate();
          const o2 = this._getTransitionParameters({ duration: 0 });
          i22.updateTransitions(o2);
        }
        _force3DLayerUpdate() {
          for (const e22 in this._layers) {
            const t22 = this._layers[e22];
            "fill-extrusion" === t22.type && this._updateLayer(t22);
          }
        }
        _forceSymbolLayerUpdate() {
          for (const e22 in this._layers) {
            const t22 = this._layers[e22];
            "symbol" === t22.type && this._updateLayer(t22);
          }
        }
        _validate(t22, i22, o2, s2, r22 = {}) {
          if (r22 && false === r22.validate) return false;
          const n22 = e2.l({}, this.serialize());
          return vo(this, t22.call(me, e2.l({ key: i22, style: n22, value: o2, styleSpec: e2.a5 }, s2)));
        }
        _remove() {
          this._request && (this._request.cancel(), this._request = null), this._spriteRequest && (this._spriteRequest.cancel(), this._spriteRequest = null), e2.dg.off("pluginStateChange", this._rtlTextPluginCallback);
          for (const e22 in this._mergedLayers) this._mergedLayers[e22].setEventedParent(null);
          for (const e22 in this._mergedSourceCaches) this._mergedSourceCaches[e22].clearTiles(), this._mergedSourceCaches[e22].setEventedParent(null);
          this.imageManager.removeScope(this.scope), this.setEventedParent(null), delete this.fog, delete this.snow, delete this.rain, delete this.terrain, delete this.ambientLight, delete this.directionalLight, this.isRootStyle() && (this.imageManager.setEventedParent(null), this.modelManager.setEventedParent(null), this.modelManager.destroy(), this.dispatcher.remove());
        }
        clearSource(e22) {
          const t22 = this.getSourceCaches(e22);
          for (const e3 of t22) e3.clearTiles();
        }
        clearSources() {
          for (const e22 in this._mergedSourceCaches) this._mergedSourceCaches[e22].clearTiles();
        }
        reloadSource(e22) {
          const t22 = this.getSourceCaches(e22);
          for (const e3 of t22) e3.resume(), e3.reload();
        }
        reloadSources() {
          for (const e22 of this.getSources()) e22.reload && e22.reload();
        }
        reloadModels() {
          this.modelManager.reloadModels(""), this.forEachFragmentStyle((e22) => {
            e22.modelManager.reloadModels(e22.scope);
          });
        }
        updateSources(e22) {
          let t22;
          this.directionalLight && (t22 = no(this.directionalLight));
          const i22 = /* @__PURE__ */ new Set();
          for (const e3 in this._mergedLayers) {
            const t3 = this._mergedLayers[e3];
            t3.hasElevation() && !i22.has(t3.source) && i22.add(t3.source);
          }
          for (const o2 in this._mergedSourceCaches) {
            const s2 = this._mergedSourceCaches[o2], r22 = i22.has(s2._source.id);
            s2.update(e22, void 0, void 0, t22, r22);
          }
        }
        _generateCollisionBoxes() {
          for (const e22 in this._sourceCaches) {
            const t22 = this._sourceCaches[e22];
            t22.resume(), t22.reload();
          }
        }
        _updatePlacement(t22, i22, o2, s2, r22, n22, a22 = false) {
          let l22 = false, c22 = false;
          const h22 = {}, d22 = {};
          for (const t3 of this._mergedOrder) {
            const o3 = this._mergedLayers[t3];
            if ("symbol" !== o3.type) continue;
            const s3 = e2.C(o3.source, o3.scope);
            let r3 = h22[s3];
            if (!r3) {
              const e22 = this.getLayerSourceCache(o3);
              if (!e22) continue;
              const t4 = e22.getRenderableIds(true).map((t5) => e22.getTileByID(t5));
              d22[s3] = t4.slice(), r3 = h22[s3] = t4.sort((e3, t5) => t5.tileID.overscaledZ - e3.tileID.overscaledZ || (e3.tileID.isLessThan(t5.tileID) ? -1 : 1));
            }
            const n3 = this.crossTileSymbolIndex.addLayer(o3, r3, i22.center.lng, i22.projection);
            l22 = l22 || n3;
          }
          if (this.crossTileSymbolIndex.pruneUnusedLayers(this._mergedOrder), a22 = a22 || this._layerOrderChanged || 0 === s2, this._layerOrderChanged && this.fire(new e2.A("neworder")), (a22 || !this.pauseablePlacement || this.pauseablePlacement.isDone() && !this.placement.stillRecent(e2.q.now(), i22.zoom)) && (this.pauseablePlacement = new Li(i22, this._mergedOrder, a22, o2, s2, r22, this.placement, this.fog && i22.projection.supportsFog ? this.fog.state : null, this._buildingIndex), this._layerOrderChanged = false), this.pauseablePlacement.isDone() ? this.placement.setStale() : (this.pauseablePlacement.continuePlacement(this._mergedOrder, this._mergedLayers, h22, d22, this.map.painter.scaleFactor), this.pauseablePlacement.isDone() && (this.placement = this.pauseablePlacement.commit(e2.q.now()), c22 = true), l22 && this.pauseablePlacement.placement.setStale()), c22 || l22) {
            this._buildingIndex.onNewFrame(i22.zoom);
            for (let t3 = 0; t3 < this._mergedOrder.length; t3++) {
              const i3 = this._mergedLayers[this._mergedOrder[t3]];
              if ("symbol" !== i3.type) continue;
              const o3 = this.isLayerClipped(i3);
              this.placement.updateLayerOpacities(i3, h22[e2.C(i3.source, i3.scope)], t3, o3 ? n22 : null);
            }
          }
          return { needsRerender: !this.pauseablePlacement.isDone() || this.placement.hasTransitions(e2.q.now()) };
        }
        _releaseSymbolFadeTiles() {
          for (const e22 in this._sourceCaches) this._sourceCaches[e22].releaseSymbolFadeTiles();
        }
        addImport(t22, i22) {
          this._checkLoaded();
          const o2 = this.stylesheet.imports = this.stylesheet.imports || [];
          if (-1 !== o2.findIndex(({ id: e22 }) => e22 === t22.id)) return void this.fire(new e2.z(new Error(`Import with id '${t22.id}' already exists in the map's style.`)));
          if (!i22) return o2.push(t22), this._loadImports([t22], true);
          const s2 = o2.findIndex(({ id: e22 }) => e22 === i22);
          return -1 === s2 && this.fire(new e2.z(new Error(`Import with id "${i22}" does not exist on this map.`))), this.stylesheet.imports = o2.slice(0, s2).concat(t22).concat(o2.slice(s2)), this._loadImports([t22], true, i22);
        }
        updateImport(t22, i22) {
          this._checkLoaded();
          const o2 = this.stylesheet.imports || [], s2 = this.getImportIndex(t22);
          return -1 === s2 ? this : "string" == typeof i22 ? (this.setImportUrl(t22, i22), this) : (i22.url && i22.url !== o2[s2].url && this.setImportUrl(t22, i22.url), e2.bv(i22.config, o2[s2].config) || this.setImportConfig(t22, i22.config, i22.data.schema), e2.bv(i22.data, o2[s2].data) || this.setImportData(t22, i22.data), this);
        }
        moveImport(e22, t22) {
          this._checkLoaded();
          let i22 = this.stylesheet.imports || [];
          const o2 = this.getImportIndex(e22);
          if (-1 === o2) return this;
          const s2 = this.getImportIndex(t22);
          if (-1 === s2) return this;
          const r22 = i22[o2], n22 = this.fragments[o2];
          return i22 = i22.filter(({ id: t3 }) => t3 !== e22), this.fragments = this.fragments.filter(({ id: t3 }) => t3 !== e22), this.stylesheet.imports = i22.slice(0, s2).concat(r22).concat(i22.slice(s2)), this.fragments = this.fragments.slice(0, s2).concat(n22).concat(this.fragments.slice(s2)), this.mergeLayers(), this;
        }
        setImportUrl(e22, t22) {
          this._checkLoaded();
          const i22 = this.stylesheet.imports || [], o2 = this.getImportIndex(e22);
          if (-1 === o2) return this;
          i22[o2].url = t22;
          const s2 = this.fragments[o2];
          return s2.style = this._createFragmentStyle(i22[o2]), s2.style.on("style.import.load", () => this.mergeAll()), s2.style.loadURL(t22), this;
        }
        setImportData(e22, t22) {
          this._checkLoaded();
          const i22 = this.getImportIndex(e22), o2 = this.stylesheet.imports || [];
          return -1 === i22 ? this : t22 ? (this.fragments[i22].style.setState(t22), this._reloadImports(), this) : (delete o2[i22].data, this.setImportUrl(e22, o2[i22].url));
        }
        setImportConfig(e22, t22, i22) {
          this._checkLoaded();
          const o2 = this.getImportIndex(e22), s2 = this.stylesheet.imports || [];
          if (-1 === o2) return this;
          t22 ? s2[o2].config = t22 : delete s2[o2].config;
          const r22 = this.fragments[o2];
          i22 && r22.style.stylesheet && (r22.style.stylesheet.schema = i22);
          const n22 = r22.style.stylesheet && r22.style.stylesheet.schema;
          return r22.config = t22, r22.style.updateConfig(t22, n22), this.updateConfigDependencies(), this;
        }
        removeImport(e22) {
          this._checkLoaded();
          const t22 = this.stylesheet.imports || [], i22 = this.getImportIndex(e22);
          -1 !== i22 && (t22.splice(i22, 1), this.fragments[i22].style._remove(), this.fragments.splice(i22, 1), this._reloadImports());
        }
        getImportIndex(t22) {
          const i22 = (this.stylesheet.imports || []).findIndex((e22) => e22.id === t22);
          return -1 === i22 && this.fire(new e2.z(new Error(`Import '${t22}' does not exist in the map's style and cannot be updated.`))), i22;
        }
        getLayer(e22) {
          return this._mergedLayers[e22];
        }
        getSources() {
          const e22 = [];
          for (const t22 in this._mergedOtherSourceCaches) {
            const i22 = this._mergedOtherSourceCaches[t22];
            i22 && e22.push(i22.getSource());
          }
          return e22;
        }
        getSource(e22, t22) {
          const i22 = this.getSourceCache(e22, t22);
          return i22 && i22.getSource();
        }
        getLayerSource(e22) {
          const t22 = this.getLayerSourceCache(e22);
          return t22 && t22.getSource();
        }
        getSourceCache(t22, i22) {
          const o2 = e2.C(t22, i22);
          return this._mergedOtherSourceCaches[o2];
        }
        getLayerSourceCache(t22) {
          const i22 = e2.C(t22.source, t22.scope);
          return "symbol" === t22.type ? this._mergedSymbolSourceCaches[i22] : this._mergedOtherSourceCaches[i22];
        }
        getSourceCaches(e22) {
          if (null == e22) return Object.values(this._mergedSourceCaches);
          const t22 = [];
          return this._mergedOtherSourceCaches[e22] && t22.push(this._mergedOtherSourceCaches[e22]), this._mergedSymbolSourceCaches[e22] && t22.push(this._mergedSymbolSourceCaches[e22]), t22;
        }
        updateSourceCaches() {
          const e22 = this._changes.getUpdatedSourceCaches();
          for (const t22 in e22) {
            const i22 = e22[t22];
            "reload" === i22 ? this.reloadSource(t22) : "clear" === i22 && this.clearSource(t22);
          }
        }
        updateLayers(e22) {
          const t22 = this._changes.getUpdatedPaintProperties();
          for (const i22 of t22) {
            const t3 = this.getLayer(i22);
            t3 && t3.updateTransitions(e22);
          }
        }
        getGlyphsUrl() {
          return this.stylesheet.glyphs;
        }
        setGlyphsUrl(e22) {
          this.stylesheet.glyphs = e22, this.glyphManager.setURL(e22, this.scope);
        }
        getImages(t22, i22, o2) {
          this.imageManager.getImages(i22.images, i22.scope, o2), this._updateTilesForChangedImages();
          const s2 = (t3) => {
            if (t3) {
              const o3 = i22.images.map((t4) => e2.I.toString(t4));
              t3.setDependencies(i22.tileID.key, i22.type, o3);
            }
          }, r22 = e2.C(i22.source, i22.scope);
          s2(this._mergedOtherSourceCaches[r22]), s2(this._mergedSymbolSourceCaches[r22]);
        }
        rasterizeImages(e22, t22, i22) {
          this.imageManager.rasterizeImages(t22, i22);
        }
        getGlyphs(e22, t22, i22) {
          this.glyphManager.getGlyphs(t22.stacks, t22.scope, i22);
        }
        getResource(t22, i22, o2) {
          return e2.dh(i22, o2);
        }
        getOwnSourceCache(e22) {
          return this._otherSourceCaches[e22];
        }
        getOwnLayerSourceCache(e22) {
          return "symbol" === e22.type ? this._symbolSourceCaches[e22.source] : this._otherSourceCaches[e22.source];
        }
        getOwnSourceCaches(e22) {
          const t22 = [];
          return this._otherSourceCaches[e22] && t22.push(this._otherSourceCaches[e22]), this._symbolSourceCaches[e22] && t22.push(this._symbolSourceCaches[e22]), t22;
        }
        _isSourceCacheLoaded(t22) {
          const i22 = this.getOwnSourceCaches(t22);
          return 0 === i22.length ? (this.fire(new e2.z(new Error(`There is no source with ID '${t22}'`))), false) : i22.every((e22) => e22.loaded());
        }
        has3DLayers() {
          return this._has3DLayers;
        }
        hasSymbolLayers() {
          return this._hasSymbolLayers;
        }
        hasCircleLayers() {
          return this._hasCircleLayers;
        }
        isLayerClipped(e22, t22) {
          if (!this._clipLayerPresent && "fill-extrusion" !== e22.type) return false;
          const i22 = "fill-extrusion" === e22.type && "building" === e22.sourceLayer;
          if (e22.is3D(!!this.terrain)) {
            if (i22 || t22 && "batched-model" === t22.type) return true;
            if ("model" === e22.type) return true;
          } else if ("symbol" === e22.type) return true;
          return false;
        }
        _clearWorkerCaches() {
          this.dispatcher.broadcast("clearCaches");
        }
        destroy() {
          this._clearWorkerCaches(), this.fragments.forEach((e22) => {
            e22.style._remove();
          }), this.terrainSetForDrapingOnly() && (delete this.terrain, delete this.stylesheet.terrain);
        }
      }
      Eo.getSourceType = function(e22) {
        return rt[e22];
      }, Eo.setSourceType = function(e22, t22) {
        rt[e22] = t22;
      }, Eo.registerForPluginStateChange = e2.c$;
      var So = "\n#define EPSILON 0.0000001\n#define PI 3.141592653589793\n#ifdef RENDER_CUTOFF\nfloat cutoff_opacity(vec4 cutoff_params,float depth) {float near=cutoff_params.x;float far=cutoff_params.y;float cutoffStart=cutoff_params.z;float cutoffEnd=cutoff_params.w;float linearDepth=(depth-near)/(far-near);return clamp((linearDepth-cutoffStart)/(cutoffEnd-cutoffStart),0.0,1.0);}\n#endif", Io = "\nout vec4 glFragColor;highp float unpack_depth(highp vec4 rgba_depth)\n{const highp vec4 bit_shift=vec4(1.0/(255.0*255.0*255.0),1.0/(255.0*255.0),1.0/255.0,1.0);return dot(rgba_depth,bit_shift)*2.0-1.0;}highp vec4 pack_depth(highp float ndc_z) {highp float depth=ndc_z*0.5+0.5;const highp vec4 bit_shift=vec4(255.0*255.0*255.0,255.0*255.0,255.0,1.0);const highp vec4 bit_mask =vec4(0.0,1.0/255.0,1.0/255.0,1.0/255.0);highp vec4 res=fract(depth*bit_shift);res-=res.xxyz*bit_mask;return res;}\n#ifdef INDICATOR_CUTOUT\nuniform vec3 u_indicator_cutout_centers;uniform vec4 u_indicator_cutout_params;\n#endif\nvec4 applyCutout(vec4 color,float height) {\n#ifdef INDICATOR_CUTOUT\nfloat verticalFadeRange=u_indicator_cutout_centers.z*0.25;float holeMinOpacity=mix(1.0,u_indicator_cutout_params.x,smoothstep(u_indicator_cutout_centers.z,u_indicator_cutout_centers.z+verticalFadeRange,height));float holeRadius=max(u_indicator_cutout_params.y,0.0);float holeAspectRatio=u_indicator_cutout_params.z;float fadeStart=u_indicator_cutout_params.w;float distA=distance(vec2(gl_FragCoord.x,gl_FragCoord.y*holeAspectRatio),vec2(u_indicator_cutout_centers[0],u_indicator_cutout_centers[1]*holeAspectRatio));return color*min(smoothstep(fadeStart,holeRadius,distA)+holeMinOpacity,1.0);\n#else\nreturn color;\n#endif\n}\n#ifdef DEBUG_WIREFRAME\n#define HANDLE_WIREFRAME_DEBUG \\\nglFragColor=vec4(0.7,0.0,0.0,0.7); \\\ngl_FragDepth=gl_FragCoord.z-0.0001;\n#else\n#define HANDLE_WIREFRAME_DEBUG\n#endif\n#ifdef RENDER_CUTOFF\nuniform highp vec4 u_cutoff_params;in float v_cutoff_opacity;\n#endif\nvec4 textureLodCustom(sampler2D image,highp vec2 pos,highp vec2 lod_coord) {highp vec2 size=vec2(textureSize(image,0));highp vec2 dx=dFdx(lod_coord.xy*size);highp vec2 dy=dFdy(lod_coord.xy*size);highp float delta_max_sqr=max(dot(dx,dx),dot(dy,dy));highp float lod=0.5*log2(delta_max_sqr);return textureLod(image,pos,lod);}vec4 applyLUT(highp sampler3D lut,vec4 col) {vec3 size=vec3(textureSize(lut,0));vec3 uvw=(col.rbg*float(size-1.0)+0.5)/size;return vec4(texture(lut,uvw).rgb,col.a);}vec3 applyLUT(highp sampler3D lut,vec3 col) {return applyLUT(lut,vec4(col,1.0)).rgb;}", Co = "\n#define EXTENT 8192.0\n#define RAD_TO_DEG 180.0/PI\n#define DEG_TO_RAD PI/180.0\n#define GLOBE_RADIUS EXTENT/PI/2.0\nfloat wrap(float n,float min,float max) {float d=max-min;float w=mod(mod(n-min,d)+d,d)+min;return (w==min) ? max : w;}\n#ifdef PROJECTION_GLOBE_VIEW\nvec3 mercator_tile_position(mat4 matrix,vec2 tile_anchor,vec3 tile_id,vec2 mercator_center) {\n#ifndef PROJECTED_POS_ON_VIEWPORT\nfloat tiles=tile_id.z;vec2 mercator=(tile_anchor/EXTENT+tile_id.xy)/tiles;mercator-=mercator_center;mercator.x=wrap(mercator.x,-0.5,0.5);vec4 mercator_tile=vec4(mercator.xy*EXTENT,EXTENT/(2.0*PI),1.0);mercator_tile=matrix*mercator_tile;return mercator_tile.xyz;\n#else\nreturn vec3(0.0);\n#endif\n}vec3 mix_globe_mercator(vec3 globe,vec3 mercator,float t) {return mix(globe,mercator,t);}mat3 globe_mercator_surface_vectors(vec3 pos_normal,vec3 up_dir,float zoom_transition) {vec3 normal=zoom_transition==0.0 ? pos_normal : normalize(mix(pos_normal,up_dir,zoom_transition));vec3 xAxis=normalize(vec3(normal.z,0.0,-normal.x));vec3 yAxis=normalize(cross(normal,xAxis));return mat3(xAxis,yAxis,normal);}\n#endif\nvec2 unpack_float(const float packedValue) {int packedIntValue=int(packedValue);int v0=packedIntValue/256;return vec2(v0,packedIntValue-v0*256);}vec2 unpack_opacity(const float packedOpacity) {int intOpacity=int(packedOpacity)/2;return vec2(float(intOpacity)/127.0,mod(packedOpacity,2.0));}vec4 decode_color(const vec2 encodedColor) {return vec4(\nunpack_float(encodedColor[0])/255.0,unpack_float(encodedColor[1])/255.0\n);}float unpack_mix_vec2(const vec2 packedValue,const float t) {return mix(packedValue[0],packedValue[1],t);}vec4 unpack_mix_color(const vec4 packedColors,const float t) {vec4 minColor=decode_color(vec2(packedColors[0],packedColors[1]));vec4 maxColor=decode_color(vec2(packedColors[2],packedColors[3]));return mix(minColor,maxColor,t);}vec2 get_pattern_pos(const vec2 pixel_coord_upper,const vec2 pixel_coord_lower,const vec2 pattern_size,const vec2 units_to_pixels,const vec2 pos) {vec2 offset=mod(mod(mod(pixel_coord_upper,pattern_size)*256.0,pattern_size)*256.0+pixel_coord_lower,pattern_size);return (units_to_pixels*pos+offset)/pattern_size;}vec2 get_pattern_pos(const vec2 pixel_coord_upper,const vec2 pixel_coord_lower,const vec2 pattern_size,const float tile_units_to_pixels,const vec2 pos) {return get_pattern_pos(pixel_coord_upper,pixel_coord_lower,pattern_size,vec2(tile_units_to_pixels),pos);}float mercatorXfromLng(float lng) {return (180.0+lng)/360.0;}float mercatorYfromLat(float lat) {return (180.0-(RAD_TO_DEG*log(tan(PI/4.0+lat/2.0*DEG_TO_RAD))))/360.0;}vec3 latLngToECEF(vec2 latLng) {latLng=DEG_TO_RAD*latLng;float cosLat=cos(latLng[0]);float sinLat=sin(latLng[0]);float cosLng=cos(latLng[1]);float sinLng=sin(latLng[1]);float sx=cosLat*sinLng*GLOBE_RADIUS;float sy=-sinLat*GLOBE_RADIUS;float sz=cosLat*cosLng*GLOBE_RADIUS;return vec3(sx,sy,sz);}\n#ifdef RENDER_CUTOFF\nuniform vec4 u_cutoff_params;out float v_cutoff_opacity;\n#endif\nconst vec4 AWAY=vec4(-1000.0,-1000.0,-1000.0,1);const float skirtOffset=24575.0;vec3 decomposeToPosAndSkirt(vec2 posWithComposedSkirt)\n{float skirt=float(posWithComposedSkirt.x >=skirtOffset);vec2 pos=posWithComposedSkirt-vec2(skirt*skirtOffset,0.0);return vec3(pos,skirt);}", Ro = "in highp vec3 a_pos_3f;uniform lowp mat4 u_matrix;out highp vec3 v_uv;void main() {const mat3 half_neg_pi_around_x=mat3(1.0,0.0, 0.0,0.0,0.0,-1.0,0.0,1.0, 0.0);v_uv=half_neg_pi_around_x*a_pos_3f;vec4 pos=u_matrix*vec4(a_pos_3f,1.0);gl_Position=pos.xyww;}", Do = "\n#define ELEVATION_SCALE 7.0\n#define ELEVATION_OFFSET 450.0\n#ifdef PROJECTION_GLOBE_VIEW\nuniform vec3 u_tile_tl_up;uniform vec3 u_tile_tr_up;uniform vec3 u_tile_br_up;uniform vec3 u_tile_bl_up;uniform float u_tile_up_scale;vec3 elevationVector(vec2 pos) {vec2 uv=pos/EXTENT;vec3 up=normalize(mix(\nmix(u_tile_tl_up,u_tile_tr_up,uv.xxx),mix(u_tile_bl_up,u_tile_br_up,uv.xxx),uv.yyy));return up*u_tile_up_scale;}\n#else\nvec3 elevationVector(vec2 pos) { return vec3(0,0,1); }\n#endif\n#ifdef TERRAIN\nuniform highp sampler2D u_dem;uniform highp sampler2D u_dem_prev;uniform vec2 u_dem_tl;uniform vec2 u_dem_tl_prev;uniform float u_dem_scale;uniform float u_dem_scale_prev;uniform float u_dem_size;uniform float u_dem_lerp;uniform float u_exaggeration;uniform float u_meter_to_dem;uniform mat4 u_label_plane_matrix_inv;vec4 tileUvToDemSample(vec2 uv,float dem_size,float dem_scale,vec2 dem_tl) {vec2 pos=dem_size*(uv*dem_scale+dem_tl)+1.0;vec2 f=fract(pos);return vec4((pos-f+0.5)/(dem_size+2.0),f);}float currentElevation(vec2 apos) {\n#ifdef TERRAIN_DEM_FLOAT_FORMAT\nvec2 pos=(u_dem_size*(apos/8192.0*u_dem_scale+u_dem_tl)+1.5)/(u_dem_size+2.0);return u_exaggeration*texture(u_dem,pos).r;\n#else\nfloat dd=1.0/(u_dem_size+2.0);vec4 r=tileUvToDemSample(apos/8192.0,u_dem_size,u_dem_scale,u_dem_tl);vec2 pos=r.xy;vec2 f=r.zw;float tl=texture(u_dem,pos).r;float tr=texture(u_dem,pos+vec2(dd,0)).r;float bl=texture(u_dem,pos+vec2(0,dd)).r;float br=texture(u_dem,pos+vec2(dd,dd)).r;return u_exaggeration*mix(mix(tl,tr,f.x),mix(bl,br,f.x),f.y);\n#endif\n}float prevElevation(vec2 apos) {\n#ifdef TERRAIN_DEM_FLOAT_FORMAT\nvec2 pos=(u_dem_size*(apos/8192.0*u_dem_scale_prev+u_dem_tl_prev)+1.5)/(u_dem_size+2.0);return u_exaggeration*texture(u_dem_prev,pos).r;\n#else\nfloat dd=1.0/(u_dem_size+2.0);vec4 r=tileUvToDemSample(apos/8192.0,u_dem_size,u_dem_scale_prev,u_dem_tl_prev);vec2 pos=r.xy;vec2 f=r.zw;float tl=texture(u_dem_prev,pos).r;float tr=texture(u_dem_prev,pos+vec2(dd,0)).r;float bl=texture(u_dem_prev,pos+vec2(0,dd)).r;float br=texture(u_dem_prev,pos+vec2(dd,dd)).r;return u_exaggeration*mix(mix(tl,tr,f.x),mix(bl,br,f.x),f.y);\n#endif\n}\n#ifdef TERRAIN_VERTEX_MORPHING\nfloat elevation(vec2 apos) {\n#ifdef ZERO_EXAGGERATION\nreturn 0.0;\n#endif\nfloat nextElevation=currentElevation(apos);float prevElevation=prevElevation(apos);return mix(prevElevation,nextElevation,u_dem_lerp);}\n#else\nfloat elevation(vec2 apos) {\n#ifdef ZERO_EXAGGERATION\nreturn 0.0;\n#endif\nreturn currentElevation(apos);}\n#endif\nvec4 fourSample(vec2 pos,vec2 off) {float tl=texture(u_dem,pos).r;float tr=texture(u_dem,pos+vec2(off.x,0.0)).r;float bl=texture(u_dem,pos+vec2(0.0,off.y)).r;float br=texture(u_dem,pos+off).r;return vec4(tl,tr,bl,br);}float flatElevation(vec2 pack) {vec2 apos=floor(pack/8.0);vec2 span=10.0*(pack-apos*8.0);vec2 uvTex=(apos-vec2(1.0,1.0))/8190.0;float size=u_dem_size+2.0;float dd=1.0/size;vec2 pos=u_dem_size*(uvTex*u_dem_scale+u_dem_tl)+1.0;vec2 f=fract(pos);pos=(pos-f+0.5)*dd;vec4 h=fourSample(pos,vec2(dd));float z=mix(mix(h.x,h.y,f.x),mix(h.z,h.w,f.x),f.y);vec2 w=floor(0.5*(span*u_meter_to_dem-1.0));vec2 d=dd*w;h=fourSample(pos-d,2.0*d+vec2(dd));vec4 diff=abs(h.xzxy-h.ywzw);vec2 slope=min(vec2(0.25),u_meter_to_dem*0.5*(diff.xz+diff.yw)/(2.0*w+vec2(1.0)));vec2 fix=slope*span;float base=z+max(fix.x,fix.y);return u_exaggeration*base;}float elevationFromUint16(float word) {return u_exaggeration*(word/ELEVATION_SCALE-ELEVATION_OFFSET);}\n#else\nfloat elevation(vec2 pos) { return 0.0; }\n#endif\n#ifdef DEPTH_OCCLUSION\nuniform highp sampler2D u_depth;uniform highp vec2 u_depth_size_inv;uniform highp vec2 u_depth_range_unpack;uniform highp float u_occluder_half_size;uniform highp float u_occlusion_depth_offset;\n#ifdef DEPTH_D24\nfloat unpack_depth(float depth) {return depth*u_depth_range_unpack.x+u_depth_range_unpack.y;}vec4 unpack_depth4(vec4 depth) {return depth*u_depth_range_unpack.x+vec4(u_depth_range_unpack.y);}\n#else\nhighp float unpack_depth_rgba(vec4 rgba_depth)\n{const highp vec4 bit_shift=vec4(1.0/(255.0*255.0*255.0),1.0/(255.0*255.0),1.0/255.0,1.0);return dot(rgba_depth,bit_shift)*2.0-1.0;}\n#endif\nbool isOccluded(vec4 frag) {vec3 coord=frag.xyz/frag.w;\n#ifdef DEPTH_D24\nfloat depth=unpack_depth(texture(u_depth,(coord.xy+1.0)*0.5).r);\n#else\nfloat depth=unpack_depth_rgba(texture(u_depth,(coord.xy+1.0)*0.5));\n#endif\nreturn coord.z+u_occlusion_depth_offset > depth;}highp vec4 getCornerDepths(vec2 coord) {highp vec3 df=vec3(u_occluder_half_size*u_depth_size_inv,0.0);highp vec2 uv=0.5*coord.xy+0.5;\n#ifdef DEPTH_D24\nhighp vec4 depth=vec4(\ntexture(u_depth,uv-df.xz).r,texture(u_depth,uv+df.xz).r,texture(u_depth,uv-df.zy).r,texture(u_depth,uv+df.zy).r\n);depth=unpack_depth4(depth);\n#else\nhighp vec4 depth=vec4(\nunpack_depth_rgba(texture(u_depth,uv-df.xz)),unpack_depth_rgba(texture(u_depth,uv+df.xz)),unpack_depth_rgba(texture(u_depth,uv-df.zy)),unpack_depth_rgba(texture(u_depth,uv+df.zy))\n);\n#endif\nreturn depth;}highp float occlusionFadeMultiSample(vec4 frag) {highp vec3 coord=frag.xyz/frag.w;highp vec2 uv=0.5*coord.xy+0.5;int NX=3;int NY=4;highp vec2 df=u_occluder_half_size*u_depth_size_inv;highp vec2 oneStep=2.0*u_occluder_half_size*u_depth_size_inv/vec2(NX-1,NY-1);highp float res=0.0;for (int y=0; y < NY;++y) {for (int x=0; x < NX;++x) {\n#ifdef DEPTH_D24\nhighp float depth=unpack_depth(texture(u_depth,uv-df+vec2(float(x)*oneStep.x,float(y)*oneStep.y)).r);\n#else\nhighp float depth=unpack_depth_rgba(texture(u_depth,uv-df+vec2(float(x)*oneStep.x,float(y)*oneStep.y)));\n#endif\nres+=1.0-clamp(300.0*(coord.z+u_occlusion_depth_offset-depth),0.0,1.0);}}res=clamp(2.0*res/float(NX*NY)-0.5,0.0,1.0);return res;}highp float occlusionFade(vec4 frag) {highp vec3 coord=frag.xyz/frag.w;highp vec4 depth=getCornerDepths(coord.xy);return dot(vec4(0.25),vec4(1.0)-clamp(300.0*(vec4(coord.z+u_occlusion_depth_offset)-depth),0.0,1.0));}\n#else\nbool isOccluded(vec4 frag) { return false; }highp float occlusionFade(vec4 frag) { return 1.0; }highp float occlusionFadeMultiSample(vec4 frag) { return 1.0; }\n#endif//DEPTH_OCCLUSION", Ao = "#ifdef FOG\nuniform mediump vec4 u_fog_color;uniform mediump vec2 u_fog_range;uniform mediump float u_fog_horizon_blend;uniform mediump mat4 u_fog_matrix;out vec3 v_fog_pos;float fog_range(float depth) {return (depth-u_fog_range[0])/(u_fog_range[1]-u_fog_range[0]);}float fog_horizon_blending(vec3 camera_dir) {float t=max(0.0,camera_dir.z/u_fog_horizon_blend);return u_fog_color.a*exp(-3.0*t*t);}float fog_opacity(float t) {const float decay=6.0;float falloff=1.0-min(1.0,exp(-decay*t));falloff*=falloff*falloff;return u_fog_color.a*min(1.0,1.00747*falloff);}vec3 fog_position(vec3 pos) {return (u_fog_matrix*vec4(pos,1.0)).xyz;}vec3 fog_position(vec2 pos) {return fog_position(vec3(pos,0.0));}float fog(vec3 pos) {float depth=length(pos);float opacity=fog_opacity(fog_range(depth));return opacity*fog_horizon_blending(pos/depth);}\n#endif", Lo = "#ifdef FOG\nuniform mediump vec4 u_fog_color;uniform mediump vec2 u_fog_range;uniform mediump float u_fog_horizon_blend;uniform mediump vec2 u_fog_vertical_limit;uniform mediump float u_fog_temporal_offset;in vec3 v_fog_pos;uniform highp vec3 u_frustum_tl;uniform highp vec3 u_frustum_tr;uniform highp vec3 u_frustum_br;uniform highp vec3 u_frustum_bl;uniform highp vec3 u_globe_pos;uniform highp float u_globe_radius;uniform highp vec2 u_viewport;uniform float u_globe_transition;uniform int u_is_globe;float fog_range(float depth) {return (depth-u_fog_range[0])/(u_fog_range[1]-u_fog_range[0]);}float fog_horizon_blending(vec3 camera_dir) {float t=max(0.0,camera_dir.z/u_fog_horizon_blend);return u_fog_color.a*exp(-3.0*t*t);}float fog_opacity(float t) {const float decay=6.0;float falloff=1.0-min(1.0,exp(-decay*t));falloff*=falloff*falloff;return u_fog_color.a*min(1.0,1.00747*falloff);}float globe_glow_progress() {highp vec2 uv=gl_FragCoord.xy/u_viewport;highp vec3 ray_dir=mix(\nmix(u_frustum_tl,u_frustum_tr,uv.x),mix(u_frustum_bl,u_frustum_br,uv.x),1.0-uv.y);highp vec3 dir=normalize(ray_dir);highp vec3 closest_point=dot(u_globe_pos,dir)*dir;highp float sdf=length(closest_point-u_globe_pos)/u_globe_radius;return sdf+PI*0.5;}float fog_opacity(vec3 pos) {float depth=length(pos);return fog_opacity(fog_range(depth));}vec3 fog_apply(vec3 color,vec3 pos,float opacity_limit) {float depth=length(pos);float opacity;if (u_is_globe==1) {float glow_progress=globe_glow_progress();float t=mix(glow_progress,depth,u_globe_transition);opacity=fog_opacity(fog_range(t));} else {opacity=fog_opacity(fog_range(depth));opacity*=fog_horizon_blending(pos/depth);}return mix(color,u_fog_color.rgb,min(opacity,opacity_limit));}vec3 fog_apply(vec3 color,vec3 pos) {return fog_apply(color,pos,1.0);}vec4 fog_apply_from_vert(vec4 color,float fog_opac) {float alpha=EPSILON+color.a;color.rgb=mix(color.rgb/alpha,u_fog_color.rgb,fog_opac)*alpha;return color;}vec3 fog_apply_sky_gradient(vec3 camera_ray,vec3 sky_color) {float horizon_blend=fog_horizon_blending(normalize(camera_ray));return mix(sky_color,u_fog_color.rgb,horizon_blend);}vec4 fog_apply_premultiplied(vec4 color,vec3 pos) {float alpha=EPSILON+color.a;color.rgb=fog_apply(color.rgb/alpha,pos)*alpha;return color;}vec4 fog_apply_premultiplied(vec4 color,vec3 pos,float heightMeters) {float verticalProgress=(u_fog_vertical_limit.x > 0.0 || u_fog_vertical_limit.y > 0.0) ? smoothstep(u_fog_vertical_limit.x,u_fog_vertical_limit.y,heightMeters) : 0.0;float opacityLimit=1.0-smoothstep(0.9,1.0,fog_opacity(pos));return mix(fog_apply_premultiplied(color,pos),color,min(verticalProgress,opacityLimit));}vec3 fog_dither(vec3 color) {return color;}vec4 fog_dither(vec4 color) {return vec4(fog_dither(color.rgb),color.a);}\n#endif", Po = "#ifdef RASTER_ARRAY\nuniform highp sampler2D u_image0;uniform sampler2D u_image1;const vec4 NODATA=vec4(1);ivec4 _raTexLinearCoord(highp vec2 texCoord,highp vec2 texResolution,out highp vec2 fxy) {texCoord=texCoord*texResolution-0.5;fxy=fract(texCoord);texCoord-=fxy;return ivec4(texCoord.xxyy+vec2(1.5,0.5).xyxy);}vec2 _raTexLinearMix(highp vec2 fxy,highp vec4 colorMix,highp float colorOffset,highp vec4 t00,highp vec4 t10,highp vec4 t01,highp vec4 t11) {vec2 c00=t00==NODATA ? vec2(0) : vec2(colorOffset+dot(t00,colorMix),1);vec2 c10=t10==NODATA ? vec2(0) : vec2(colorOffset+dot(t10,colorMix),1);vec2 c01=t01==NODATA ? vec2(0) : vec2(colorOffset+dot(t01,colorMix),1);vec2 c11=t11==NODATA ? vec2(0) : vec2(colorOffset+dot(t11,colorMix),1);return mix(mix(c01,c11,fxy.x),mix(c00,c10,fxy.x),fxy.y);}vec2 raTexture2D_image0_linear(highp vec2 texCoord,highp vec2 texResolution,highp vec4 colorMix,highp float colorOffset) {vec2 fxy;ivec4 c=_raTexLinearCoord(texCoord,texResolution,fxy);return _raTexLinearMix(fxy,colorMix,colorOffset,texelFetch(u_image0,c.yz,0),texelFetch(u_image0,c.xz,0),texelFetch(u_image0,c.yw,0),texelFetch(u_image0,c.xw,0)\n);}vec2 raTexture2D_image1_linear(highp vec2 texCoord,highp vec2 texResolution,highp vec4 colorMix,highp float colorOffset) {vec2 fxy;ivec4 c=_raTexLinearCoord(texCoord,texResolution,fxy);return _raTexLinearMix(fxy,colorMix,colorOffset,texelFetch(u_image1,c.yz,0),texelFetch(u_image1,c.xz,0),texelFetch(u_image1,c.yw,0),texelFetch(u_image1,c.xw,0)\n);}vec2 raTexture2D_image0_nearest(highp vec2 texCoord,highp vec2 texResolution,highp vec4 colorMix,highp float colorOffset) {vec4 t=texelFetch(u_image0,ivec2(texCoord*texResolution),0);return t==NODATA ? vec2(0) : vec2(colorOffset+dot(t,colorMix),1);}vec2 raTexture2D_image1_nearest(highp vec2 texCoord,highp vec2 texResolution,highp vec4 colorMix,highp float colorOffset) {vec4 t=texelFetch(u_image1,ivec2(texCoord*texResolution),0);return t==NODATA ? vec2(0) : vec2(colorOffset+dot(t,colorMix),1);}\n#endif", zo = "#ifdef RASTER_ARRAY\nuniform sampler2D u_velocity;uniform mediump vec2 u_velocity_res;uniform mediump float u_max_speed;const vec4 NO_DATA=vec4(1);const vec2 INVALID_VELOCITY=vec2(-1);uniform highp vec2 u_uv_offset;uniform highp float u_data_offset;uniform highp vec2 u_data_scale;ivec4 rasterArrayLinearCoord(highp vec2 texCoord,highp vec2 texResolution,out highp vec2 fxy) {texCoord=texCoord*texResolution-0.5;fxy=fract(texCoord);texCoord-=fxy;return ivec4(texCoord.xxyy+vec2(1.5,0.5).xyxy);}highp vec2 lookup_velocity(highp vec2 uv) {uv=u_uv_offset.x+u_uv_offset.y*uv;highp vec2 fxy;ivec4 c=rasterArrayLinearCoord(uv,u_velocity_res,fxy);highp vec4 tl=texelFetch(u_velocity,c.yz,0);highp vec4 tr=texelFetch(u_velocity,c.xz,0);highp vec4 bl=texelFetch(u_velocity,c.yw,0);highp vec4 br=texelFetch(u_velocity,c.xw,0);if (tl==NO_DATA) {return INVALID_VELOCITY;}if (tr==NO_DATA) {return INVALID_VELOCITY;}if (bl==NO_DATA) {return INVALID_VELOCITY;}if (br==NO_DATA) {return INVALID_VELOCITY;}highp vec4 t=mix(mix(bl,br,fxy.x),mix(tl,tr,fxy.x),fxy.y);highp vec2 velocity=u_data_offset+vec2(dot(t.rg,u_data_scale),dot(t.ba,u_data_scale));velocity.y=-velocity.y;velocity/=max(u_max_speed,length(velocity));return velocity;}\n#endif\nuniform highp float u_particle_pos_scale;uniform highp vec2 u_particle_pos_offset;highp vec4 pack_pos_to_rgba(highp vec2 p) {highp vec2 v=(p+u_particle_pos_offset)/u_particle_pos_scale;highp vec4 r=vec4(v.x,fract(v.x*255.0),v.y,fract(v.y*255.0));return vec4(r.x-r.y/255.0,r.y,r.z-r.w/255.0,r.w);}highp vec2 unpack_pos_from_rgba(highp vec4 v) {v=floor(v*255.0+0.5)/255.0;highp vec2 p=vec2(v.x+(v.y/255.0),v.z+(v.w/255.0));return u_particle_pos_scale*p-u_particle_pos_offset;}", Mo = "#ifdef RENDER_SHADOWS\nuniform mediump vec3 u_shadow_direction;uniform highp vec3 u_shadow_normal_offset;vec3 shadow_normal_offset(vec3 normal) {float tileInMeters=u_shadow_normal_offset[0];vec3 n=vec3(-normal.xy,tileInMeters*normal.z);float dotScale=min(1.0-dot(normal,u_shadow_direction),1.0)*0.5+0.5;return n*dotScale;}vec3 shadow_normal_offset_model(vec3 normal) {vec3 transformed_normal=vec3(-normal.xy,normal.z);float NDotL=dot(normalize(transformed_normal),u_shadow_direction);float dotScale=min(1.0-NDotL,1.0)*0.5+0.5;return normal*dotScale;}float shadow_normal_offset_multiplier0() {return u_shadow_normal_offset[1];}float shadow_normal_offset_multiplier1() {return u_shadow_normal_offset[2];}\n#endif//RENDER_SHADOWS", Oo = "#ifdef RENDER_SHADOWS\n#ifdef DEPTH_TEXTURE\nuniform highp sampler2D u_shadowmap_0;uniform highp sampler2D u_shadowmap_1;\n#else\nuniform sampler2D u_shadowmap_0;uniform sampler2D u_shadowmap_1;\n#endif\nuniform float u_shadow_intensity;uniform float u_shadow_map_resolution;uniform float u_shadow_texel_size;uniform highp vec3 u_shadow_normal_offset;uniform vec2 u_fade_range;uniform mediump vec3 u_shadow_direction;uniform highp vec3 u_shadow_bias;highp float shadow_sample_1(highp vec2 uv,highp float compare) {highp float shadow_depth;\n#ifdef DEPTH_TEXTURE\nshadow_depth=texture(u_shadowmap_1,uv).r;\n#else\nshadow_depth=unpack_depth(texture(u_shadowmap_1,uv))*0.5+0.5;\n#endif\nreturn step(shadow_depth,compare);}highp float shadow_sample_0(highp vec2 uv,highp float compare) {highp float shadow_depth;\n#ifdef DEPTH_TEXTURE\nshadow_depth=texture(u_shadowmap_0,uv).r;\n#else\nshadow_depth=unpack_depth(texture(u_shadowmap_0,uv))*0.5+0.5;\n#endif\nreturn step(shadow_depth,compare);}float shadow_occlusion_1(highp vec4 pos,highp float bias) {highp vec2 uv=pos.xy;return shadow_sample_1(uv,pos.z-bias);}float shadow_occlusion_0(highp vec4 pos,highp float bias) {highp float compare0=pos.z-bias;\n#ifdef TEXTURE_GATHER\nhighp vec2 uv=pos.xy;highp vec4 samples=textureGather(u_shadowmap_0,uv,0);lowp vec4 stepSamples=step(samples,vec4(compare0));\n#else\nhighp vec2 uv00=pos.xy-vec2(0.5*u_shadow_texel_size);highp vec2 uv10=uv00+vec2(u_shadow_texel_size,0.0);highp vec2 uv01=uv00+vec2(0.0,u_shadow_texel_size);highp vec2 uv11=uv01+vec2(u_shadow_texel_size,0.0);lowp vec4 stepSamples=vec4(\nshadow_sample_0(uv01,compare0),shadow_sample_0(uv11,compare0),shadow_sample_0(uv10,compare0),shadow_sample_0(uv00,compare0)\n);\n#endif\nvec2 f=fract(pos.xy*u_shadow_map_resolution-vec2(0.5));lowp vec2 lerpx=mix(stepSamples.wx,stepSamples.zy,f.xx);return clamp(mix(lerpx.x,lerpx.y,f.y),0.0,1.0);}float shadow_occlusion(highp vec4 light_view_pos0,highp vec4 light_view_pos1,float view_depth,highp float bias) {\n#ifdef SHADOWS_SINGLE_CASCADE\nlight_view_pos0.xyz/=light_view_pos0.w;vec2 abs_bounds=abs(light_view_pos0.xy);if (abs_bounds.x >=1.0 || abs_bounds.y >=1.0) {return 0.0;}light_view_pos0.xyz=light_view_pos0.xyz*0.5+0.5;return shadow_occlusion_0(light_view_pos0,bias);\n#else\nlight_view_pos0.xyz/=light_view_pos0.w;light_view_pos1.xyz/=light_view_pos1.w;vec4 uv=vec4(light_view_pos0.xy,light_view_pos1.xy);vec4 abs_bounds=abs(uv);if (abs_bounds.x < 1.0 && abs_bounds.y < 1.0) {light_view_pos0.xyz=light_view_pos0.xyz*0.5+0.5;return shadow_occlusion_0(light_view_pos0,bias);}if (abs_bounds.z >=1.0 || abs_bounds.w >=1.0) {return 0.0;}light_view_pos1.xyz=light_view_pos1.xyz*0.5+0.5;float occlusion1=shadow_occlusion_1(light_view_pos1,bias);return clamp(mix(occlusion1,0.0,smoothstep(u_fade_range.x,u_fade_range.y,view_depth)),0.0,1.0);\n#endif\n}highp float calculate_shadow_bias(float NDotL) {\n#ifdef NORMAL_OFFSET\nreturn 0.5*u_shadow_bias.x;\n#else\nreturn 0.5*(u_shadow_bias.x+clamp(u_shadow_bias.y*tan(acos(NDotL)),0.0,u_shadow_bias.z));\n#endif\n}float shadowed_light_factor_normal(vec3 N,highp vec4 light_view_pos0,highp vec4 light_view_pos1,float view_depth) {float NDotL=dot(N,u_shadow_direction);float bias=calculate_shadow_bias(NDotL);float occlusion=shadow_occlusion(light_view_pos0,light_view_pos1,view_depth,bias);return mix(0.0,(1.0-(u_shadow_intensity*occlusion))*NDotL,step(0.0,NDotL));}float shadowed_light_factor_normal_opacity(vec3 N,highp vec4 light_view_pos0,highp vec4 light_view_pos1,float view_depth,float shadow_opacity) {float NDotL=dot(N,u_shadow_direction);float bias=calculate_shadow_bias(NDotL);float occlusion=shadow_occlusion(light_view_pos0,light_view_pos1,view_depth,bias)*shadow_opacity;return mix(0.0,(1.0-(u_shadow_intensity*occlusion))*NDotL,step(0.0,NDotL));}float shadowed_light_factor_normal_unbiased(vec3 N,highp vec4 light_view_pos0,highp vec4 light_view_pos1,float view_depth) {float NDotL=dot(N,u_shadow_direction);float bias=0.0;float occlusion=shadow_occlusion(light_view_pos0,light_view_pos1,view_depth,bias);return mix(0.0,(1.0-(u_shadow_intensity*occlusion))*NDotL,step(0.0,NDotL));}highp vec2 compute_receiver_plane_depth_bias(highp vec3 pos_dx,highp vec3 pos_dy)\n{highp vec2 biasUV=vec2(\npos_dy.y*pos_dx.z-pos_dx.y*pos_dy.z,pos_dx.x*pos_dy.z-pos_dy.x*pos_dx.z);biasUV*=1.0/((pos_dx.x*pos_dy.y)-(pos_dx.y*pos_dy.x));return biasUV;}float shadowed_light_factor_plane_bias(highp vec4 light_view_pos0,highp vec4 light_view_pos1,float view_depth) {highp vec3 light_view_pos0_xyz=light_view_pos0.xyz/light_view_pos0.w*0.5+0.5;highp vec3 light_view_pos0_ddx=dFdx(light_view_pos0_xyz);highp vec3 light_view_pos0_ddy=dFdy(light_view_pos0_xyz);highp vec2 plane_depth_bias=compute_receiver_plane_depth_bias(light_view_pos0_ddx,light_view_pos0_ddy);highp float bias=dot(vec2(u_shadow_texel_size,u_shadow_texel_size),plane_depth_bias)+0.0001;float occlusion=shadow_occlusion(light_view_pos0,light_view_pos1,view_depth,bias);return 1.0-(u_shadow_intensity*occlusion);}float shadowed_light_factor(highp vec4 light_view_pos0,highp vec4 light_view_pos1,float view_depth) {float bias=0.0;float occlusion=shadow_occlusion(light_view_pos0,light_view_pos1,view_depth,bias);return 1.0-(u_shadow_intensity*occlusion);}float shadow_occlusion(float ndotl,highp vec4 light_view_pos0,highp vec4 light_view_pos1,float view_depth) {float bias=calculate_shadow_bias(ndotl);return shadow_occlusion(light_view_pos0,light_view_pos1,view_depth,bias);}\n#endif";
      const Fo = [];
      Vo(So, Fo), Vo(Co, Fo), Vo(Io, Fo);
      const Bo = { "_prelude_fog.vertex.glsl": Ao, "_prelude_terrain.vertex.glsl": Do, "_prelude_shadow.vertex.glsl": Mo, "_prelude_fog.fragment.glsl": Lo, "_prelude_shadow.fragment.glsl": Oo, "_prelude_lighting.glsl": "\n#ifdef LIGHTING_3D_MODE\nuniform mediump vec3 u_lighting_ambient_color;uniform mediump vec3 u_lighting_directional_dir;uniform mediump vec3 u_lighting_directional_color;uniform mediump vec3 u_ground_radiance;float calculate_ambient_directional_factor(vec3 normal) {float NdotL=dot(normal,u_lighting_directional_dir);const float factor_reduction_max=0.3;float dir_luminance=dot(u_lighting_directional_color,vec3(0.2126,0.7152,0.0722));float directional_factor_min=1.0-factor_reduction_max*min(dir_luminance,1.0);float ambient_directional_factor=mix(directional_factor_min,1.0,min((NdotL+1.0),1.0));const float vertical_factor_min=0.92;float vertical_factor=mix(vertical_factor_min,1.0,normal.z*0.5+0.5);return vertical_factor*ambient_directional_factor;}vec3 linearProduct(vec3 srgbIn,vec3 k) {return srgbIn*pow(k,vec3(1./2.2));}vec3 apply_lighting(vec3 color,vec3 normal,float dir_factor) {float ambient_directional_factor=calculate_ambient_directional_factor(normal);vec3 ambient_contrib=ambient_directional_factor*u_lighting_ambient_color;vec3 directional_contrib=u_lighting_directional_color*dir_factor;return linearProduct(color,ambient_contrib+directional_contrib);}vec4 apply_lighting(vec4 color,vec3 normal,float dir_factor) {return vec4(apply_lighting(color.rgb,normal,dir_factor),color.a);}vec3 apply_lighting(vec3 color,vec3 normal) {float dir_factor=max(dot(normal,u_lighting_directional_dir),0.0);return apply_lighting(color.rgb,normal,dir_factor);}vec4 apply_lighting(vec4 color,vec3 normal) {float dir_factor=max(dot(normal,u_lighting_directional_dir),0.0);return vec4(apply_lighting(color.rgb,normal,dir_factor),color.a);}vec3 apply_lighting_ground(vec3 color) {return color*u_ground_radiance;}vec4 apply_lighting_ground(vec4 color) {return vec4(apply_lighting_ground(color.rgb),color.a);}float calculate_NdotL(vec3 normal) {const float ext=0.70710678118;return (clamp(dot(normal,u_lighting_directional_dir),-ext,1.0)+ext)/(1.0+ext);}vec4 apply_lighting_with_emission_ground(vec4 color,float emissive_strength) {return mix(apply_lighting_ground(color),color,emissive_strength);}vec3 compute_flood_lighting(vec3 flood_light_color,float fully_occluded_factor,float occlusion,vec3 ground_shadow_factor) {vec3 fully_occluded_color=flood_light_color*mix(ground_shadow_factor,vec3(1.0),fully_occluded_factor);float occlusion_ramp=smoothstep(0.0,0.2,1.0-occlusion);return mix(fully_occluded_color,flood_light_color,occlusion_ramp);}vec3 compute_emissive_draped(vec3 unlit_color,float fully_occluded_factor,float occlusion,vec3 ground_shadow_factor) {vec3 fully_occluded_color=unlit_color*mix(ground_shadow_factor,vec3(1.0),fully_occluded_factor);return mix(fully_occluded_color,unlit_color,1.0-occlusion);}\n#endif//LIGHTING_3D_MODE", "_prelude_raster_array.glsl": Po, "_prelude_raster_particle.glsl": zo }, ko = {};
      Go("", Do), Go(Lo, Ao), Go(Oo, Mo), Go(Po, ""), Go(zo, "");
      const No = Go(Io, Co), Uo = So;
      var jo = { background: Go('#include "_prelude_fog.fragment.glsl"\n#include "_prelude_lighting.glsl"\nuniform vec4 u_color;uniform float u_opacity;\n#ifdef LIGHTING_3D_MODE\nin vec4 v_color;\n#endif\nvoid main() {vec4 out_color;\n#ifdef LIGHTING_3D_MODE\nout_color=v_color;\n#else\nout_color=u_color;\n#endif\n#ifdef FOG\nout_color=fog_dither(fog_apply_premultiplied(out_color,v_fog_pos));\n#endif\nglFragColor=out_color*u_opacity;\n#ifdef OVERDRAW_INSPECTOR\nglFragColor=vec4(1.0);\n#endif\nHANDLE_WIREFRAME_DEBUG;}', '#include "_prelude_fog.vertex.glsl"\n#include "_prelude_lighting.glsl"\nin vec2 a_pos;uniform mat4 u_matrix;\n#ifdef LIGHTING_3D_MODE\nuniform mediump vec4 u_color;out vec4 v_color;uniform float u_emissive_strength;\n#endif\nvoid main() {gl_Position=u_matrix*vec4(a_pos,0,1);\n#ifdef LIGHTING_3D_MODE\nv_color=apply_lighting_with_emission_ground(u_color,u_emissive_strength);\n#endif\n#ifdef FOG\nv_fog_pos=fog_position(a_pos);\n#endif\n}'), backgroundPattern: Go('#include "_prelude_fog.fragment.glsl"\n#include "_prelude_lighting.glsl"\nuniform vec2 u_pattern_tl;uniform vec2 u_pattern_br;uniform vec2 u_texsize;uniform float u_opacity;uniform float u_emissive_strength;uniform sampler2D u_image;in highp vec2 v_pos;void main() {highp vec2 imagecoord=mod(v_pos,1.0);highp vec2 pos=mix(u_pattern_tl/u_texsize,u_pattern_br/u_texsize,imagecoord);vec4 out_color=textureLodCustom(u_image,pos,v_pos);\n#ifdef LIGHTING_3D_MODE\nout_color=apply_lighting_with_emission_ground(out_color,u_emissive_strength);\n#endif\n#ifdef FOG\nout_color=fog_dither(fog_apply_premultiplied(out_color,v_fog_pos));\n#endif\nglFragColor=out_color*u_opacity;\n#ifdef OVERDRAW_INSPECTOR\nglFragColor=vec4(1.0);\n#endif\nHANDLE_WIREFRAME_DEBUG;}', '#include "_prelude_fog.vertex.glsl"\nuniform mat4 u_matrix;uniform vec2 u_pattern_size;uniform vec2 u_pixel_coord_upper;uniform vec2 u_pixel_coord_lower;uniform vec2 u_pattern_units_to_pixels;in vec2 a_pos;out highp vec2 v_pos;void main() {gl_Position=u_matrix*vec4(a_pos,0,1);v_pos=get_pattern_pos(u_pixel_coord_upper,u_pixel_coord_lower,u_pattern_size,u_pattern_units_to_pixels,a_pos);\n#ifdef FOG\nv_fog_pos=fog_position(a_pos);\n#endif\n}'), building: Go('#include "_prelude_fog.fragment.glsl"\n#include "_prelude_shadow.fragment.glsl"\n#include "_prelude_lighting.glsl"\nin vec4 v_color;in highp vec3 v_normal;in highp float v_height;\n#ifdef RENDER_SHADOWS\nin highp vec4 v_pos_light_view_0;in highp vec4 v_pos_light_view_1;in float v_depth_shadows;\n#endif\nuniform lowp float u_opacity;vec3 linearTosRGB(vec3 color) {return pow(color,vec3(1./2.2));}vec3 apply_lighting_linear(vec3 color,vec3 normal,float dir_factor) {float ambient_directional_factor=calculate_ambient_directional_factor(normal);vec3 ambient_contrib=ambient_directional_factor*u_lighting_ambient_color;vec3 directional_contrib=u_lighting_directional_color*dir_factor;return color*(ambient_contrib+directional_contrib);}void main() {vec4 color=vec4(v_color.rgb,1.0);vec3 normal=normalize(v_normal);vec3 xy_flipped_normal=vec3(-normal.xy,normal.z);float shadowed_lighting_factor=0.0;\n#ifdef RENDER_SHADOWS\nshadowed_lighting_factor=shadowed_light_factor_normal(xy_flipped_normal,v_pos_light_view_0,v_pos_light_view_1,v_depth_shadows);\n#else\nshadowed_lighting_factor=dot(normal,u_lighting_directional_dir);\n#endif\ncolor.rgb=apply_lighting_linear(color.rgb,xy_flipped_normal,shadowed_lighting_factor);color.rgb=mix(color.rgb,v_color.rgb,v_color.a);color*=u_opacity;\n#ifdef FOG\ncolor=fog_dither(fog_apply_premultiplied(color,v_fog_pos,v_height));\n#endif\n#ifdef RENDER_CUTOFF\ncolor*=v_cutoff_opacity;\n#endif\n#ifdef INDICATOR_CUTOUT\ncolor=applyCutout(color,v_height);\n#endif\nglFragColor=vec4(linearTosRGB(color.rgb),color.a);\n#ifdef DEBUG_SHOW_NORMALS\ncolor.rgb=xy_flipped_normal*0.5+vec3(0.5,0.5,0.5);color.a=1.0;glFragColor=color;\n#endif\n#ifdef OVERDRAW_INSPECTOR\nglFragColor=vec4(1.0);\n#endif\nHANDLE_WIREFRAME_DEBUG;}', '#include "_prelude_fog.vertex.glsl"\n#include "_prelude_shadow.vertex.glsl"\nin vec3 a_pos_3f;in vec3 a_normal_3f;out vec4 v_color;out highp vec3 v_normal;out highp float v_height;uniform mat4 u_matrix;uniform mat4 u_normal_matrix;\n#ifdef RENDER_SHADOWS\nuniform mat4 u_light_matrix_0;uniform mat4 u_light_matrix_1;out highp vec4 v_pos_light_view_0;out highp vec4 v_pos_light_view_1;out float v_depth_shadows;\n#endif\nvec3 sRGBToLinear(vec3 srgbIn) {return pow(srgbIn,vec3(2.2));}\n#pragma mapbox: define-attribute-vertex-shader-only highp vec2 part_color_emissive\nvoid main() {\n#pragma mapbox: initialize-attribute-custom highp vec2 part_color_emissive\nvec4 color_emissive=decode_color(part_color_emissive);v_color=vec4(sRGBToLinear(color_emissive.rgb),color_emissive.a);v_normal=vec3(u_normal_matrix*vec4(a_normal_3f,0.0));vec3 pos=a_pos_3f;v_height=pos.z;gl_Position=u_matrix*vec4(pos,1.0);\n#ifdef RENDER_SHADOWS\nvec3 shadow_pos=pos;\n#ifdef NORMAL_OFFSET\nvec3 offset=shadow_normal_offset_model(v_normal);shadow_pos+=offset*shadow_normal_offset_multiplier0();\n#endif\nv_pos_light_view_0=u_light_matrix_0*vec4(shadow_pos,1.0);v_pos_light_view_1=u_light_matrix_1*vec4(shadow_pos,1.0);v_depth_shadows=gl_Position.w;\n#endif\n#ifdef FOG\nv_fog_pos=fog_position(pos);\n#endif\n#ifdef RENDER_CUTOFF\nv_cutoff_opacity=cutoff_opacity(u_cutoff_params,gl_Position.z);\n#endif\n}'), buildingDepth: Go("in highp float v_depth;void main() {\n#ifndef DEPTH_TEXTURE\nglFragColor=pack_depth(v_depth);\n#endif\n}", "in vec3 a_pos_3f;uniform mat4 u_matrix;out highp float v_depth;void main() {gl_Position=u_matrix*vec4(a_pos_3f,1.0);v_depth=gl_Position.z/gl_Position.w;}"), circle: Go('#include "_prelude_fog.fragment.glsl"\n#include "_prelude_lighting.glsl"\nin vec3 v_data;in float v_visibility;\n#pragma mapbox: define highp vec4 color\n#pragma mapbox: define mediump float radius\n#pragma mapbox: define lowp float blur\n#pragma mapbox: define lowp float opacity\n#pragma mapbox: define highp vec4 stroke_color\n#pragma mapbox: define mediump float stroke_width\n#pragma mapbox: define lowp float stroke_opacity\nuniform float u_emissive_strength;void main() {\n#pragma mapbox: initialize highp vec4 color\n#pragma mapbox: initialize mediump float radius\n#pragma mapbox: initialize lowp float blur\n#pragma mapbox: initialize lowp float opacity\n#pragma mapbox: initialize highp vec4 stroke_color\n#pragma mapbox: initialize mediump float stroke_width\n#pragma mapbox: initialize lowp float stroke_opacity\nvec2 extrude=v_data.xy;float blur_positive=blur < 0.0 ? 0.0 : 1.0;lowp float antialiasblur=v_data.z;float extrude_length=length(extrude)+antialiasblur*(1.0-blur_positive);float antialiased_blur=-max(abs(blur),antialiasblur);float antialiase_blur_opacity=smoothstep(0.0,antialiasblur,extrude_length-1.0);float opacity_t=blur_positive==1.0 ? \nsmoothstep(0.0,-antialiased_blur,1.0-extrude_length) : \nsmoothstep(antialiased_blur,0.0,extrude_length-1.0)-antialiase_blur_opacity;float color_t=stroke_width < 0.01 ? 0.0 : smoothstep(\nantialiased_blur,0.0,extrude_length-radius/(radius+stroke_width)\n);vec4 out_color=mix(color*opacity,stroke_color*stroke_opacity,color_t);\n#ifdef LIGHTING_3D_MODE\nout_color=apply_lighting_with_emission_ground(out_color,u_emissive_strength);\n#endif\n#ifdef FOG\nout_color=fog_apply_premultiplied(out_color,v_fog_pos);\n#endif\nglFragColor=out_color*(v_visibility*opacity_t);\n#ifdef OVERDRAW_INSPECTOR\nglFragColor=vec4(1.0);\n#endif\n}', '#include "_prelude_fog.vertex.glsl"\n#include "_prelude_terrain.vertex.glsl"\n#define NUM_VISIBILITY_RINGS 2\n#define INV_SQRT2 0.70710678\n#define ELEVATION_BIAS 0.0001\n#define NUM_SAMPLES_PER_RING 16\nuniform mat4 u_matrix;uniform mat2 u_extrude_scale;uniform lowp float u_device_pixel_ratio;uniform highp float u_camera_to_center_distance;in vec2 a_pos;\n#ifdef PROJECTION_GLOBE_VIEW\nin vec3 a_pos_3;in vec3 a_pos_normal_3;uniform mat4 u_inv_rot_matrix;uniform vec2 u_merc_center;uniform vec3 u_tile_id;uniform float u_zoom_transition;uniform vec3 u_up_dir;\n#endif\n#ifdef ELEVATED_ROADS\nin float a_circle_z_offset;\n#endif\nout vec3 v_data;out float v_visibility;\n#pragma mapbox: define highp vec4 color\n#pragma mapbox: define mediump float radius\n#pragma mapbox: define lowp float blur\n#pragma mapbox: define lowp float opacity\n#pragma mapbox: define highp vec4 stroke_color\n#pragma mapbox: define mediump float stroke_width\n#pragma mapbox: define lowp float stroke_opacity\nvec2 calc_offset(vec2 extrusion,float radius,float stroke_width, float view_scale) {return extrusion*(radius+stroke_width)*u_extrude_scale*view_scale;}float cantilevered_elevation(vec2 pos,float radius,float stroke_width,float view_scale) {vec2 c1=pos+calc_offset(vec2(-1,-1),radius,stroke_width,view_scale);vec2 c2=pos+calc_offset(vec2(1,-1),radius,stroke_width,view_scale);vec2 c3=pos+calc_offset(vec2(1,1),radius,stroke_width,view_scale);vec2 c4=pos+calc_offset(vec2(-1,1),radius,stroke_width,view_scale);float h1=elevation(c1)+ELEVATION_BIAS;float h2=elevation(c2)+ELEVATION_BIAS;float h3=elevation(c3)+ELEVATION_BIAS;float h4=elevation(c4)+ELEVATION_BIAS;return max(h4,max(h3,max(h1,h2)));}float circle_elevation(vec2 pos) {\n#if defined(TERRAIN)\nreturn elevation(pos)+ELEVATION_BIAS;\n#else\nreturn 0.0;\n#endif\n}vec4 project_vertex(vec2 extrusion,vec4 world_center,vec4 projected_center,float radius,float stroke_width, float view_scale,mat3 surface_vectors) {vec2 sample_offset=calc_offset(extrusion,radius,stroke_width,view_scale);\n#ifdef PITCH_WITH_MAP\n#ifdef PROJECTION_GLOBE_VIEW\nreturn u_matrix*( world_center+vec4(sample_offset.x*surface_vectors[0]+sample_offset.y*surface_vectors[1],0) );\n#else\nreturn u_matrix*( world_center+vec4(sample_offset,0,0) );\n#endif\n#else\nreturn projected_center+vec4(sample_offset,0,0);\n#endif\n}float get_sample_step() {\n#ifdef PITCH_WITH_MAP\nreturn 2.0*PI/float(NUM_SAMPLES_PER_RING);\n#else\nreturn PI/float(NUM_SAMPLES_PER_RING);\n#endif\n}void main(void) {\n#pragma mapbox: initialize highp vec4 color\n#pragma mapbox: initialize mediump float radius\n#pragma mapbox: initialize lowp float blur\n#pragma mapbox: initialize lowp float opacity\n#pragma mapbox: initialize highp vec4 stroke_color\n#pragma mapbox: initialize mediump float stroke_width\n#pragma mapbox: initialize lowp float stroke_opacity\nvec2 extrude=vec2(mod(a_pos,2.0)*2.0-1.0);vec2 circle_center=floor(a_pos*0.5);vec4 world_center;mat3 surface_vectors;\n#ifdef PROJECTION_GLOBE_VIEW\nvec3 pos_normal_3=a_pos_normal_3/16384.0;surface_vectors=globe_mercator_surface_vectors(pos_normal_3,u_up_dir,u_zoom_transition);vec3 surface_extrusion=extrude.x*surface_vectors[0]+extrude.y*surface_vectors[1];vec3 globe_elevation=elevationVector(circle_center)*circle_elevation(circle_center);vec3 globe_pos=a_pos_3+surface_extrusion+globe_elevation;vec3 mercator_elevation=u_up_dir*u_tile_up_scale*circle_elevation(circle_center);vec3 merc_pos=mercator_tile_position(u_inv_rot_matrix,circle_center,u_tile_id,u_merc_center)+surface_extrusion+mercator_elevation;vec3 pos=mix_globe_mercator(globe_pos,merc_pos,u_zoom_transition);world_center=vec4(pos,1);\n#else \nsurface_vectors=mat3(1.0);float height=circle_elevation(circle_center);world_center=vec4(circle_center,height,1);\n#endif\n#ifdef ELEVATED_ROADS\nworld_center.z+=a_circle_z_offset+ELEVATION_BIAS;\n#endif\nvec4 projected_center=u_matrix*world_center;float view_scale=0.0;\n#ifdef PITCH_WITH_MAP\n#ifdef SCALE_WITH_MAP\nview_scale=1.0;\n#else\nview_scale=projected_center.w/u_camera_to_center_distance;\n#endif\n#else\n#ifdef SCALE_WITH_MAP\nview_scale=u_camera_to_center_distance;\n#else\nview_scale=projected_center.w;\n#endif\n#endif\ngl_Position=project_vertex(extrude,world_center,projected_center,radius,stroke_width,view_scale,surface_vectors);float visibility=0.0;\n#ifdef TERRAIN\nfloat step=get_sample_step();vec4 occlusion_world_center;vec4 occlusion_projected_center;\n#ifdef PITCH_WITH_MAP\nfloat cantilevered_height=cantilevered_elevation(circle_center,radius,stroke_width,view_scale);occlusion_world_center=vec4(circle_center,cantilevered_height,1);occlusion_projected_center=u_matrix*occlusion_world_center;\n#else\nocclusion_world_center=world_center;occlusion_projected_center=projected_center;\n#endif\nfor(int ring=0; ring < NUM_VISIBILITY_RINGS; ring++) {float scale=(float(ring)+1.0)/float(NUM_VISIBILITY_RINGS);for(int i=0; i < NUM_SAMPLES_PER_RING; i++) {vec2 extrusion=vec2(cos(step*float(i)),-sin(step*float(i)))*scale;vec4 frag_pos=project_vertex(extrusion,occlusion_world_center,occlusion_projected_center,radius,stroke_width,view_scale,surface_vectors);visibility+=float(!isOccluded(frag_pos));}}visibility/=float(NUM_VISIBILITY_RINGS)*float(NUM_SAMPLES_PER_RING);\n#else\nvisibility=1.0;\n#endif\n#ifdef PROJECTION_GLOBE_VIEW\nvisibility=1.0;\n#endif\nv_visibility=visibility;lowp float antialiasblur=1.0/u_device_pixel_ratio/(radius+stroke_width);v_data=vec3(extrude.x,extrude.y,antialiasblur);\n#ifdef FOG\nv_fog_pos=fog_position(world_center.xyz);\n#endif\n}'), clippingMask: Go("void main() {glFragColor=vec4(1.0);}", "in vec2 a_pos;uniform mat4 u_matrix;void main() {gl_Position=u_matrix*vec4(a_pos,0,1);}"), heatmap: Go('#include "_prelude_fog.fragment.glsl"\nuniform highp float u_intensity;in vec2 v_extrude;\n#pragma mapbox: define highp float weight\n#define GAUSS_COEF 0.3989422804014327\nvoid main() {\n#pragma mapbox: initialize highp float weight\nfloat d=-0.5*3.0*3.0*dot(v_extrude,v_extrude);float val=weight*u_intensity*GAUSS_COEF*exp(d);glFragColor=vec4(val,1.0,1.0,1.0);\n#ifdef FOG\nif (u_is_globe==0) {glFragColor.r*=pow(1.0-fog_opacity(v_fog_pos),2.0);}\n#endif\n#ifdef OVERDRAW_INSPECTOR\nglFragColor=vec4(1.0);\n#endif\nHANDLE_WIREFRAME_DEBUG;}', '#include "_prelude_terrain.vertex.glsl"\n#include "_prelude_fog.vertex.glsl"\nuniform mat4 u_matrix;uniform float u_extrude_scale;uniform float u_opacity;uniform float u_intensity;in vec2 a_pos;\n#ifdef PROJECTION_GLOBE_VIEW\nin vec3 a_pos_3;in vec3 a_pos_normal_3;uniform mat4 u_inv_rot_matrix;uniform vec2 u_merc_center;uniform vec3 u_tile_id;uniform float u_zoom_transition;uniform vec3 u_up_dir;\n#endif\nout vec2 v_extrude;\n#pragma mapbox: define highp float weight\n#pragma mapbox: define mediump float radius\nconst highp float ZERO=1.0/255.0/16.0;\n#define GAUSS_COEF 0.3989422804014327\nvoid main(void) {\n#pragma mapbox: initialize highp float weight\n#pragma mapbox: initialize mediump float radius\nvec2 unscaled_extrude=vec2(mod(a_pos,2.0)*2.0-1.0);float S=sqrt(-2.0*log(ZERO/weight/u_intensity/GAUSS_COEF))/3.0;v_extrude=S*unscaled_extrude;vec2 extrude=v_extrude*radius*u_extrude_scale;vec2 tilePos=floor(a_pos*0.5);vec3 pos;\n#ifdef PROJECTION_GLOBE_VIEW\nvec3 pos_normal_3=a_pos_normal_3/16384.0;mat3 surface_vectors=globe_mercator_surface_vectors(pos_normal_3,u_up_dir,u_zoom_transition);vec3 surface_extrusion=extrude.x*surface_vectors[0]+extrude.y*surface_vectors[1];vec3 globe_elevation=elevationVector(tilePos)*elevation(tilePos);vec3 globe_pos=a_pos_3+surface_extrusion+globe_elevation;vec3 mercator_elevation=u_up_dir*u_tile_up_scale*elevation(tilePos);vec3 merc_pos=mercator_tile_position(u_inv_rot_matrix,tilePos,u_tile_id,u_merc_center)+surface_extrusion+mercator_elevation;pos=mix_globe_mercator(globe_pos,merc_pos,u_zoom_transition);\n#else\npos=vec3(tilePos+extrude,elevation(tilePos));\n#endif\ngl_Position=u_matrix*vec4(pos,1);\n#ifdef FOG\nv_fog_pos=fog_position(pos);\n#endif\n}'), heatmapTexture: Go("uniform sampler2D u_image;uniform sampler2D u_color_ramp;uniform float u_opacity;in vec2 v_pos;void main() {float t=texture(u_image,v_pos).r;vec4 color=texture(u_color_ramp,vec2(t,0.5));glFragColor=color*u_opacity;\n#ifdef OVERDRAW_INSPECTOR\nglFragColor=vec4(0.0);\n#endif\nHANDLE_WIREFRAME_DEBUG;}", "in vec2 a_pos;out vec2 v_pos;void main() {gl_Position=vec4(a_pos,0,1);v_pos=a_pos*0.5+0.5;}"), collisionBox: Go("in float v_placed;in float v_notUsed;void main() {vec4 red =vec4(1.0,0.0,0.0,1.0);vec4 blue=vec4(0.0,0.0,1.0,0.5);glFragColor =mix(red,blue,step(0.5,v_placed))*0.5;glFragColor*=mix(1.0,0.1,step(0.5,v_notUsed));}", '#include "_prelude_terrain.vertex.glsl"\nin vec3 a_pos;in vec2 a_anchor_pos;in vec2 a_extrude;in vec2 a_placed;in vec2 a_shift;in vec2 a_elevation_from_sea;in float a_size_scale;in vec2 a_padding;in float a_auto_z_offset;uniform mat4 u_matrix;uniform vec2 u_extrude_scale;uniform float u_camera_to_center_distance;out float v_placed;out float v_notUsed;void main() {float feature_elevation=a_elevation_from_sea.x+a_auto_z_offset;float terrain_elevation=(a_elevation_from_sea.y==1.0 ? 0.0 : elevation(a_anchor_pos));vec4 projectedPoint=u_matrix*vec4(a_pos+elevationVector(a_anchor_pos)*(feature_elevation+terrain_elevation),1);highp float camera_to_anchor_distance=projectedPoint.w;highp float collision_perspective_ratio=clamp(\n0.5+0.5*(u_camera_to_center_distance/camera_to_anchor_distance),0.0,1.5);gl_Position=projectedPoint;gl_Position.xy+=(a_extrude*a_size_scale+a_shift+a_padding)*u_extrude_scale*gl_Position.w*collision_perspective_ratio;v_placed=a_placed.x;v_notUsed=a_placed.y;}'), collisionCircle: Go("in float v_radius;in vec2 v_extrude;in float v_perspective_ratio;in float v_collision;void main() {float alpha=0.5*min(v_perspective_ratio,1.0);float stroke_radius=0.9*max(v_perspective_ratio,1.0);float distance_to_center=length(v_extrude);float distance_to_edge=abs(distance_to_center-v_radius);float opacity_t=smoothstep(-stroke_radius,0.0,-distance_to_edge);vec4 color=mix(vec4(0.0,0.0,1.0,0.5),vec4(1.0,0.0,0.0,1.0),v_collision);glFragColor=color*alpha*opacity_t;}", "in vec2 a_pos_2f;in float a_radius;in vec2 a_flags;uniform mat4 u_matrix;uniform mat4 u_inv_matrix;uniform vec2 u_viewport_size;uniform float u_camera_to_center_distance;out float v_radius;out vec2 v_extrude;out float v_perspective_ratio;out float v_collision;vec3 toTilePosition(vec2 screenPos) {vec4 rayStart=u_inv_matrix*vec4(screenPos,-1.0,1.0);vec4 rayEnd  =u_inv_matrix*vec4(screenPos, 1.0,1.0);rayStart.xyz/=rayStart.w;rayEnd.xyz  /=rayEnd.w;highp float t=(0.0-rayStart.z)/(rayEnd.z-rayStart.z);return mix(rayStart.xyz,rayEnd.xyz,t);}void main() {vec2 quadCenterPos=a_pos_2f;float radius=a_radius;float collision=a_flags.x;float vertexIdx=a_flags.y;vec2 quadVertexOffset=vec2(\nmix(-1.0,1.0,float(vertexIdx >=2.0)),mix(-1.0,1.0,float(vertexIdx >=1.0 && vertexIdx <=2.0)));vec2 quadVertexExtent=quadVertexOffset*radius;vec3 tilePos=toTilePosition(quadCenterPos);vec4 clipPos=u_matrix*vec4(tilePos,1.0);highp float camera_to_anchor_distance=clipPos.w;highp float collision_perspective_ratio=clamp(\n0.5+0.5*(u_camera_to_center_distance/camera_to_anchor_distance),0.0,4.0);float padding_factor=1.2;v_radius=radius;v_extrude=quadVertexExtent*padding_factor;v_perspective_ratio=collision_perspective_ratio;v_collision=collision;gl_Position=vec4(clipPos.xyz/clipPos.w,1.0)+vec4(quadVertexExtent*padding_factor/u_viewport_size*2.0,0.0,0.0);}"), debug: Go("uniform highp vec4 u_color;uniform sampler2D u_overlay;in vec2 v_uv;void main() {vec4 overlay_color=texture(u_overlay,v_uv);glFragColor=mix(u_color,overlay_color,overlay_color.a);}", '#include "_prelude_terrain.vertex.glsl"\nin vec2 a_pos;\n#ifdef PROJECTION_GLOBE_VIEW\nin vec3 a_pos_3;\n#endif\nout vec2 v_uv;uniform mat4 u_matrix;uniform float u_overlay_scale;void main() {float h=elevation(a_pos);v_uv=a_pos/8192.0;\n#ifdef PROJECTION_GLOBE_VIEW\ngl_Position=u_matrix*vec4(a_pos_3+elevationVector(a_pos)*h,1);\n#else\ngl_Position=u_matrix*vec4(a_pos*u_overlay_scale,h,1);\n#endif\n}'), elevatedStructuresDepth: Go("void main() {\n#ifndef DEPTH_TEXTURE\nglFragColor=vec4(0.);\n#endif\n}", "in vec2 a_pos;in float a_height;uniform mat4 u_matrix;uniform float u_depth_bias;void main() {gl_Position=u_matrix*vec4(a_pos,a_height,1);gl_Position.z=gl_Position.z+u_depth_bias;}"), elevatedStructuresDepthReconstruct: Go("#ifdef DEPTH_RECONSTRUCTION\nin float v_height;\n#endif\nvoid main() {\n#ifdef DEPTH_RECONSTRUCTION\nif (v_height >=0.0)\ndiscard;\n#endif\nglFragColor=vec4(1.0,0.0,0.0,1.0);}", "in vec2 a_pos;in float a_height;uniform mat4 u_matrix;uniform vec3 u_camera_pos;uniform highp float u_depth_bias;uniform lowp float u_height_scale;uniform lowp float u_reset_depth;\n#ifdef DEPTH_RECONSTRUCTION\nout float v_height;\n#endif\nvoid main() {vec3 vpos=vec3(a_pos,a_height*u_height_scale);\n#ifdef DEPTH_RECONSTRUCTION\nif (u_camera_pos.z > vpos.z) {vpos-=(u_camera_pos-vpos)*(vpos.z/(u_camera_pos.z-vpos.z));}v_height=a_height;\n#endif\ngl_Position=u_matrix*vec4(vpos,1);gl_Position.z=u_reset_depth==1.0 ? gl_Position.w : gl_Position.z+u_depth_bias;}"), elevatedStructures: Go('#include "_prelude_fog.fragment.glsl"\n#include "_prelude_lighting.glsl"\n#include "_prelude_shadow.fragment.glsl"\nin vec3 v_normal;in float v_height;\n#ifdef RENDER_SHADOWS\nin highp vec4 v_pos_light_view_0;in highp vec4 v_pos_light_view_1;in float v_depth;\n#endif\nvoid main() {vec3 color=vec3(241.0/255.0,236.0/255.0,225.0/255.0);\n#ifdef LIGHTING_3D_MODE\nvec3 normal=normalize(v_normal);\n#ifdef RENDER_SHADOWS\nfloat shadowed_lighting_factor=shadowed_light_factor_normal(normal,v_pos_light_view_0,v_pos_light_view_1,v_depth);color.rgb=apply_lighting(color.rgb,normal,shadowed_lighting_factor);\n#else\ncolor=apply_lighting(color,normal);\n#endif\nif (v_height < 0.0) {float penetration=max(v_height+7.5,0.0);float occlusion=1.0-1.0/PI*acos(1.0-penetration/4.0);color=color*(1.0-pow(occlusion,2.0)*0.3);}\n#endif\n#ifdef FOG\ncolor=fog_apply(color,v_fog_pos);\n#endif\nvec4 out_color=vec4(color,1.0);\n#ifdef INDICATOR_CUTOUT\nout_color=applyCutout(out_color,v_height);\n#endif\nglFragColor=out_color;HANDLE_WIREFRAME_DEBUG;}', '#include "_prelude_fog.vertex.glsl"\n#include "_prelude_shadow.vertex.glsl"\nin vec2 a_pos;in float a_height;in vec3 a_pos_normal_3;uniform mat4 u_matrix;out vec3 v_normal;out float v_height;\n#ifdef RENDER_SHADOWS\nuniform mat4 u_light_matrix_0;uniform mat4 u_light_matrix_1;out highp vec4 v_pos_light_view_0;out highp vec4 v_pos_light_view_1;out float v_depth;\n#endif\nvoid main() {v_normal=a_pos_normal_3/16384.0;v_height=a_height;vec3 pos=vec3(a_pos,a_height);gl_Position=u_matrix*vec4(pos,1);\n#ifdef RENDER_SHADOWS\nvec3 shd_pos0=pos;vec3 shd_pos1=pos;\n#ifdef NORMAL_OFFSET\nvec3 offset=shadow_normal_offset(v_normal);shd_pos0+=offset*shadow_normal_offset_multiplier0();shd_pos1+=offset*shadow_normal_offset_multiplier1();\n#endif\nv_pos_light_view_0=u_light_matrix_0*vec4(shd_pos0,1);v_pos_light_view_1=u_light_matrix_1*vec4(shd_pos1,1);v_depth=gl_Position.w;\n#endif\n#ifdef FOG\nv_fog_pos=fog_position(a_pos);\n#endif\n}'), fill: Go('#include "_prelude_fog.fragment.glsl"\n#include "_prelude_lighting.glsl"\n#include "_prelude_shadow.fragment.glsl"\n#pragma mapbox: define highp vec4 color\n#pragma mapbox: define lowp float opacity\nuniform float u_emissive_strength;\n#ifdef RENDER_SHADOWS\nuniform vec3 u_ground_shadow_factor;in highp vec4 v_pos_light_view_0;in highp vec4 v_pos_light_view_1;in highp float v_depth;\n#endif\n#ifdef INDICATOR_CUTOUT\nin highp float v_z_offset;\n#endif\nvoid main() {\n#pragma mapbox: initialize highp vec4 color\n#pragma mapbox: initialize lowp float opacity\nvec4 out_color=color;\n#ifdef LIGHTING_3D_MODE\nout_color=apply_lighting_with_emission_ground(out_color,u_emissive_strength);\n#ifdef RENDER_SHADOWS\nfloat light=shadowed_light_factor(v_pos_light_view_0,v_pos_light_view_1,v_depth);out_color.rgb*=mix(u_ground_shadow_factor,vec3(1.0),light);\n#endif\n#endif\n#ifdef FOG\nout_color=fog_dither(fog_apply_premultiplied(out_color,v_fog_pos));\n#endif\nout_color*=opacity;\n#ifdef INDICATOR_CUTOUT\nif (v_z_offset >=0.0) {out_color=applyCutout(out_color,v_z_offset);}\n#endif\nglFragColor=out_color;\n#ifdef OVERDRAW_INSPECTOR\nglFragColor=vec4(1.0);\n#endif\nHANDLE_WIREFRAME_DEBUG;}', '#include "_prelude_fog.vertex.glsl"\n#include "_prelude_shadow.vertex.glsl"\nin vec2 a_pos;\n#ifdef ELEVATED_ROADS\nin float a_road_z_offset;\n#endif\n#ifdef RENDER_SHADOWS\nuniform mat4 u_light_matrix_0;uniform mat4 u_light_matrix_1;out highp vec4 v_pos_light_view_0;out highp vec4 v_pos_light_view_1;out highp float v_depth;\n#endif\n#ifdef INDICATOR_CUTOUT\nout highp float v_z_offset;\n#endif\nuniform mat4 u_matrix;\n#pragma mapbox: define highp vec4 color\n#pragma mapbox: define lowp float opacity\n#pragma mapbox: define highp float z_offset\nvoid main() {\n#pragma mapbox: initialize highp vec4 color\n#pragma mapbox: initialize lowp float opacity\n#pragma mapbox: initialize highp float z_offset\n#ifdef ELEVATED_ROADS\nz_offset+=a_road_z_offset;\n#endif\nfloat hidden=float(opacity==0.0);gl_Position=mix(u_matrix*vec4(a_pos,z_offset,1),AWAY,hidden);\n#ifdef RENDER_SHADOWS\nvec3 shd_pos0=vec3(a_pos,z_offset);vec3 shd_pos1=vec3(a_pos,z_offset);\n#ifdef NORMAL_OFFSET\nvec3 offset=shadow_normal_offset(vec3(0.0,0.0,1.0));shd_pos0+=offset*shadow_normal_offset_multiplier0();shd_pos1+=offset*shadow_normal_offset_multiplier1();\n#endif\nv_pos_light_view_0=u_light_matrix_0*vec4(shd_pos0,1);v_pos_light_view_1=u_light_matrix_1*vec4(shd_pos1,1);v_depth=gl_Position.w;\n#endif\n#ifdef FOG\nv_fog_pos=fog_position(a_pos);\n#endif\n#ifdef INDICATOR_CUTOUT\nv_z_offset=z_offset;\n#endif\n}'), fillOutline: Go('#include "_prelude_fog.fragment.glsl"\n#include "_prelude_lighting.glsl"\n#include "_prelude_shadow.fragment.glsl"\nin highp vec2 v_pos;uniform float u_emissive_strength;\n#ifdef RENDER_SHADOWS\nuniform vec3 u_ground_shadow_factor;in highp vec4 v_pos_light_view_0;in highp vec4 v_pos_light_view_1;in highp float v_depth;\n#endif\n#pragma mapbox: define highp vec4 outline_color\n#pragma mapbox: define lowp float opacity\nvoid main() {\n#pragma mapbox: initialize highp vec4 outline_color\n#pragma mapbox: initialize lowp float opacity\nfloat dist=length(v_pos-gl_FragCoord.xy);float alpha=1.0-smoothstep(0.0,1.0,dist);vec4 out_color=outline_color;\n#ifdef LIGHTING_3D_MODE\nout_color=apply_lighting_with_emission_ground(out_color,u_emissive_strength);\n#ifdef RENDER_SHADOWS\nfloat light=shadowed_light_factor(v_pos_light_view_0,v_pos_light_view_1,v_depth);out_color.rgb*=mix(u_ground_shadow_factor,vec3(1.0),light);\n#endif\n#endif\n#ifdef FOG\nout_color=fog_dither(fog_apply_premultiplied(out_color,v_fog_pos));\n#endif\nglFragColor=out_color*(alpha*opacity);\n#ifdef OVERDRAW_INSPECTOR\nglFragColor=vec4(1.0);\n#endif\nHANDLE_WIREFRAME_DEBUG;}', '#include "_prelude_fog.vertex.glsl"\n#include "_prelude_shadow.vertex.glsl"\nin vec2 a_pos;\n#ifdef ELEVATED_ROADS\nin float a_road_z_offset;\n#endif\n#ifdef RENDER_SHADOWS\nuniform mat4 u_light_matrix_0;uniform mat4 u_light_matrix_1;out highp vec4 v_pos_light_view_0;out highp vec4 v_pos_light_view_1;out highp float v_depth;\n#endif\nuniform mat4 u_matrix;uniform vec2 u_world;out highp vec2 v_pos;\n#pragma mapbox: define highp vec4 outline_color\n#pragma mapbox: define lowp float opacity\n#pragma mapbox: define highp float z_offset\nvoid main() {\n#pragma mapbox: initialize highp vec4 outline_color\n#pragma mapbox: initialize lowp float opacity\n#pragma mapbox: initialize highp float z_offset\n#ifdef ELEVATED_ROADS\nz_offset+=a_road_z_offset;\n#endif\nfloat hidden=float(opacity==0.0);gl_Position=mix(u_matrix*vec4(a_pos,z_offset,1),AWAY,hidden);v_pos=(gl_Position.xy/gl_Position.w+1.0)/2.0*u_world;\n#ifdef RENDER_SHADOWS\nvec3 shd_pos0=vec3(a_pos,z_offset);vec3 shd_pos1=vec3(a_pos,z_offset);\n#ifdef NORMAL_OFFSET\nvec3 offset=shadow_normal_offset(vec3(0.0,0.0,1.0));shd_pos0+=offset*shadow_normal_offset_multiplier0();shd_pos1+=offset*shadow_normal_offset_multiplier1();\n#endif\nv_pos_light_view_0=u_light_matrix_0*vec4(shd_pos0,1);v_pos_light_view_1=u_light_matrix_1*vec4(shd_pos1,1);v_depth=gl_Position.w;\n#endif\n#ifdef FOG\nv_fog_pos=fog_position(a_pos);\n#endif\n}'), fillOutlinePattern: Go('#include "_prelude_fog.fragment.glsl"\n#include "_prelude_lighting.glsl"\n#include "_prelude_shadow.fragment.glsl"\nuniform vec2 u_texsize;uniform sampler2D u_image;\n#ifdef FILL_PATTERN_TRANSITION\nuniform float u_pattern_transition;\n#endif\nuniform float u_emissive_strength;\n#ifdef RENDER_SHADOWS\nuniform vec3 u_ground_shadow_factor;in highp vec4 v_pos_light_view_0;in highp vec4 v_pos_light_view_1;in highp float v_depth;\n#endif\nin highp vec2 v_pos;in highp vec2 v_pos_world;\n#pragma mapbox: define lowp float opacity\n#pragma mapbox: define lowp vec4 pattern\n#ifdef FILL_PATTERN_TRANSITION\n#pragma mapbox: define mediump vec4 pattern_b\n#endif\nvoid main() {\n#pragma mapbox: initialize lowp float opacity\n#pragma mapbox: initialize mediump vec4 pattern\n#ifdef FILL_PATTERN_TRANSITION\n#pragma mapbox: initialize mediump vec4 pattern_b\n#endif\nvec2 pattern_tl=pattern.xy;vec2 pattern_br=pattern.zw;highp vec2 imagecoord=mod(v_pos,1.0);highp vec2 pos=mix(pattern_tl/u_texsize,pattern_br/u_texsize,imagecoord);highp vec2 lod_pos=mix(pattern_tl/u_texsize,pattern_br/u_texsize,v_pos);float dist=length(v_pos_world-gl_FragCoord.xy);float alpha=1.0-smoothstep(0.0,1.0,dist);vec4 out_color=textureLodCustom(u_image,pos,lod_pos);\n#ifdef FILL_PATTERN_TRANSITION\nvec2 pattern_b_tl=pattern_b.xy;vec2 pattern_b_br=pattern_b.zw;highp vec2 pos_b=mix(pattern_b_tl/u_texsize,pattern_b_br/u_texsize,imagecoord);vec4 color_b=textureLodCustom(u_image,pos_b,lod_pos);out_color=out_color*(1.0-u_pattern_transition)+color_b*u_pattern_transition;\n#endif\n#ifdef LIGHTING_3D_MODE\nout_color=apply_lighting_with_emission_ground(out_color,u_emissive_strength);\n#ifdef RENDER_SHADOWS\nfloat light=shadowed_light_factor(v_pos_light_view_0,v_pos_light_view_1,v_depth);out_color.rgb*=mix(u_ground_shadow_factor,vec3(1.0),light);\n#endif\n#endif\n#ifdef FOG\nout_color=fog_dither(fog_apply_premultiplied(out_color,v_fog_pos));\n#endif\nglFragColor=out_color*(alpha*opacity);\n#ifdef OVERDRAW_INSPECTOR\nglFragColor=vec4(1.0);\n#endif\nHANDLE_WIREFRAME_DEBUG;}', '#include "_prelude_fog.vertex.glsl"\n#include "_prelude_shadow.vertex.glsl"\nuniform mat4 u_matrix;uniform vec2 u_world;uniform vec2 u_pixel_coord_upper;uniform vec2 u_pixel_coord_lower;uniform float u_tile_units_to_pixels;in vec2 a_pos;\n#ifdef ELEVATED_ROADS\nin float a_road_z_offset;\n#endif\n#ifdef RENDER_SHADOWS\nuniform mat4 u_light_matrix_0;uniform mat4 u_light_matrix_1;out highp vec4 v_pos_light_view_0;out highp vec4 v_pos_light_view_1;out highp float v_depth;\n#endif\nout highp vec2 v_pos;out highp vec2 v_pos_world;\n#pragma mapbox: define lowp float opacity\n#pragma mapbox: define lowp vec4 pattern\n#ifdef FILL_PATTERN_TRANSITION\n#pragma mapbox: define mediump vec4 pattern_b\n#endif\n#pragma mapbox: define lowp float pixel_ratio\n#pragma mapbox: define highp float z_offset\nvoid main() {\n#pragma mapbox: initialize lowp float opacity\n#pragma mapbox: initialize mediump vec4 pattern\n#ifdef FILL_PATTERN_TRANSITION\n#pragma mapbox: initialize mediump vec4 pattern_b\n#endif\n#pragma mapbox: initialize lowp float pixel_ratio\n#pragma mapbox: initialize highp float z_offset\nvec2 pattern_tl=pattern.xy;vec2 pattern_br=pattern.zw;\n#ifdef ELEVATED_ROADS\nz_offset+=a_road_z_offset;\n#endif\nfloat hidden=float(opacity==0.0);gl_Position=mix(u_matrix*vec4(a_pos,z_offset,1),AWAY,hidden);vec2 display_size=(pattern_br-pattern_tl)/pixel_ratio;v_pos=get_pattern_pos(u_pixel_coord_upper,u_pixel_coord_lower,display_size,u_tile_units_to_pixels,a_pos);v_pos_world=(gl_Position.xy/gl_Position.w+1.0)/2.0*u_world;\n#ifdef RENDER_SHADOWS\nvec3 shd_pos0=vec3(a_pos,z_offset);vec3 shd_pos1=vec3(a_pos,z_offset);\n#ifdef NORMAL_OFFSET\nvec3 offset=shadow_normal_offset(vec3(0.0,0.0,1.0));shd_pos0+=offset*shadow_normal_offset_multiplier0();shd_pos1+=offset*shadow_normal_offset_multiplier1();\n#endif\nv_pos_light_view_0=u_light_matrix_0*vec4(shd_pos0,1);v_pos_light_view_1=u_light_matrix_1*vec4(shd_pos1,1);v_depth=gl_Position.w;\n#endif\n#ifdef FOG\nv_fog_pos=fog_position(a_pos);\n#endif\n}'), fillPattern: Go('#include "_prelude_fog.fragment.glsl"\n#include "_prelude_lighting.glsl"\n#include "_prelude_shadow.fragment.glsl"\nuniform vec2 u_texsize;uniform sampler2D u_image;\n#ifdef FILL_PATTERN_TRANSITION\nuniform float u_pattern_transition;\n#endif\nin highp vec2 v_pos;uniform float u_emissive_strength;\n#ifdef RENDER_SHADOWS\nuniform vec3 u_ground_shadow_factor;in highp vec4 v_pos_light_view_0;in highp vec4 v_pos_light_view_1;in highp float v_depth;\n#endif\n#pragma mapbox: define lowp float opacity\n#pragma mapbox: define lowp vec4 pattern\n#ifdef FILL_PATTERN_TRANSITION\n#pragma mapbox: define mediump vec4 pattern_b\n#endif\nvoid main() {\n#pragma mapbox: initialize lowp float opacity\n#pragma mapbox: initialize mediump vec4 pattern\n#ifdef FILL_PATTERN_TRANSITION\n#pragma mapbox: initialize mediump vec4 pattern_b\n#endif\nvec2 pattern_tl=pattern.xy;vec2 pattern_br=pattern.zw;highp vec2 imagecoord=mod(v_pos,1.0);highp vec2 pos=mix(pattern_tl/u_texsize,pattern_br/u_texsize,imagecoord);highp vec2 lod_pos=mix(pattern_tl/u_texsize,pattern_br/u_texsize,v_pos);vec4 out_color=textureLodCustom(u_image,pos,lod_pos);\n#ifdef FILL_PATTERN_TRANSITION\nvec2 pattern_b_tl=pattern_b.xy;vec2 pattern_b_br=pattern_b.zw;highp vec2 pos_b=mix(pattern_b_tl/u_texsize,pattern_b_br/u_texsize,imagecoord);vec4 color_b=textureLodCustom(u_image,pos_b,lod_pos);out_color=out_color*(1.0-u_pattern_transition)+color_b*u_pattern_transition;\n#endif\n#ifdef LIGHTING_3D_MODE\nout_color=apply_lighting_with_emission_ground(out_color,u_emissive_strength);\n#ifdef RENDER_SHADOWS\nfloat light=shadowed_light_factor(v_pos_light_view_0,v_pos_light_view_1,v_depth);out_color.rgb*=mix(u_ground_shadow_factor,vec3(1.0),light);\n#endif\n#endif\n#ifdef FOG\nout_color=fog_dither(fog_apply_premultiplied(out_color,v_fog_pos));\n#endif\nglFragColor=out_color*opacity;\n#ifdef OVERDRAW_INSPECTOR\nglFragColor=vec4(1.0);\n#endif\nHANDLE_WIREFRAME_DEBUG;}', '#include "_prelude_fog.vertex.glsl"\n#include "_prelude_shadow.vertex.glsl"\nuniform mat4 u_matrix;uniform vec2 u_pixel_coord_upper;uniform vec2 u_pixel_coord_lower;uniform float u_tile_units_to_pixels;in vec2 a_pos;\n#ifdef ELEVATED_ROADS\nin float a_road_z_offset;\n#endif\n#ifdef RENDER_SHADOWS\nuniform mat4 u_light_matrix_0;uniform mat4 u_light_matrix_1;out highp vec4 v_pos_light_view_0;out highp vec4 v_pos_light_view_1;out highp float v_depth;\n#endif\nout highp vec2 v_pos;\n#pragma mapbox: define lowp float opacity\n#pragma mapbox: define lowp vec4 pattern\n#ifdef FILL_PATTERN_TRANSITION\n#pragma mapbox: define mediump vec4 pattern_b\n#endif\n#pragma mapbox: define lowp float pixel_ratio\n#pragma mapbox: define highp float z_offset\nvoid main() {\n#pragma mapbox: initialize lowp float opacity\n#pragma mapbox: initialize mediump vec4 pattern\n#pragma mapbox: initialize lowp float pixel_ratio\n#pragma mapbox: initialize highp float z_offset\n#ifdef FILL_PATTERN_TRANSITION\n#pragma mapbox: initialize mediump vec4 pattern_b\n#endif\nvec2 pattern_tl=pattern.xy;vec2 pattern_br=pattern.zw;vec2 display_size=(pattern_br-pattern_tl)/pixel_ratio;\n#ifdef ELEVATED_ROADS\nz_offset+=a_road_z_offset;\n#endif\nfloat hidden=float(opacity==0.0);gl_Position=mix(u_matrix*vec4(a_pos,z_offset,1),AWAY,hidden);v_pos=get_pattern_pos(u_pixel_coord_upper,u_pixel_coord_lower,display_size,u_tile_units_to_pixels,a_pos);\n#ifdef RENDER_SHADOWS\nvec3 shd_pos0=vec3(a_pos,z_offset);vec3 shd_pos1=vec3(a_pos,z_offset);\n#ifdef NORMAL_OFFSET\nvec3 offset=shadow_normal_offset(vec3(0.0,0.0,1.0));shd_pos0+=offset*shadow_normal_offset_multiplier0();shd_pos1+=offset*shadow_normal_offset_multiplier1();\n#endif\nv_pos_light_view_0=u_light_matrix_0*vec4(shd_pos0,1);v_pos_light_view_1=u_light_matrix_1*vec4(shd_pos1,1);v_depth=gl_Position.w;\n#endif\n#ifdef FOG\nv_fog_pos=fog_position(a_pos);\n#endif\n}'), fillExtrusion: Go('#include "_prelude_fog.fragment.glsl"\n#include "_prelude_shadow.fragment.glsl"\n#include "_prelude_lighting.glsl"\nin vec4 v_color;in vec4 v_flat;\n#ifdef RENDER_SHADOWS\nin highp vec4 v_pos_light_view_0;in highp vec4 v_pos_light_view_1;\n#endif\nuniform lowp float u_opacity;\n#ifdef FAUX_AO\nuniform lowp vec2 u_ao;in vec2 v_ao;\n#endif\n#if defined(ZERO_ROOF_RADIUS) && !defined(LIGHTING_3D_MODE)\nin vec4 v_roof_color;\n#endif\n#if defined(ZERO_ROOF_RADIUS) || defined(RENDER_SHADOWS) || defined(LIGHTING_3D_MODE)\nin highp vec3 v_normal;\n#endif\nuniform vec3 u_flood_light_color;uniform highp float u_vertical_scale;uniform float u_flood_light_intensity;uniform vec3 u_ground_shadow_factor;\n#if defined(LIGHTING_3D_MODE) && defined(FLOOD_LIGHT)\nin float v_flood_radius;in float v_has_floodlight;\n#endif\nin float v_height;\n#pragma mapbox: define highp float emissive_strength\nvoid main() {\n#pragma mapbox: initialize highp float emissive_strength\n#if defined(ZERO_ROOF_RADIUS) || defined(RENDER_SHADOWS) || defined(LIGHTING_3D_MODE)\nvec3 normal=normalize(v_normal);\n#endif\nfloat z;vec4 color=v_color;\n#ifdef ZERO_ROOF_RADIUS\nz=float(normal.z > 0.00001);\n#ifdef LIGHTING_3D_MODE\nnormal=mix(normal,vec3(0.0,0.0,1.0),z);\n#else\ncolor=mix(v_color,v_roof_color,z);\n#endif\n#endif\nfloat h=max(0.0,v_height);float ao_shade=1.0;\n#ifdef FAUX_AO\nfloat intensity=u_ao[0];float h_floors=h/(u_ao[1]*u_vertical_scale);float y_shade=1.0-0.9*intensity*min(v_ao.y,1.0);ao_shade=(1.0-0.08*intensity)*(y_shade+(1.0-y_shade)*(1.0-pow(1.0-min(h_floors/16.0,1.0),16.0)))+0.08*intensity*min(h_floors/160.0,1.0);float concave=v_ao.x*v_ao.x;\n#ifdef ZERO_ROOF_RADIUS\nconcave*=(1.0-z);\n#endif\nfloat x_shade=mix(1.0,mix(0.6,0.75,min(h_floors/30.0,1.0)),intensity)+0.1*intensity*min(h,1.0);ao_shade*=mix(1.0,x_shade*x_shade*x_shade,concave);\n#ifdef LIGHTING_3D_MODE\n#ifdef FLOOD_LIGHT\ncolor.rgb*=mix(ao_shade,1.0,v_has_floodlight);\n#else\ncolor.rgb*=ao_shade;\n#endif\n#else\ncolor.rgb*=ao_shade;\n#endif\n#endif\n#ifdef LIGHTING_3D_MODE\nfloat flood_radiance=0.0;\n#ifdef FLOOD_LIGHT\nflood_radiance=(1.0-min(h/v_flood_radius,1.0))*u_flood_light_intensity*v_has_floodlight;\n#endif\n#ifdef RENDER_SHADOWS\n#ifdef FLOOD_LIGHT\nfloat ndotl_unclamped=dot(normal,u_shadow_direction);float ndotl=max(0.0,ndotl_unclamped);float occlusion=ndotl_unclamped < 0.0 ? 1.0 : shadow_occlusion(ndotl,v_pos_light_view_0,v_pos_light_view_1,1.0/gl_FragCoord.w);vec3 litColor=apply_lighting(color.rgb,normal,(1.0-u_shadow_intensity*occlusion)*ndotl);vec3 floodLitColor=compute_flood_lighting(u_flood_light_color*u_opacity,1.0-u_shadow_intensity,occlusion,u_ground_shadow_factor);color.rgb=mix(litColor,floodLitColor,flood_radiance);\n#else\nfloat shadowed_lighting_factor;\n#ifdef RENDER_CUTOFF\nshadowed_lighting_factor=shadowed_light_factor_normal_opacity(normal,v_pos_light_view_0,v_pos_light_view_1,1.0/gl_FragCoord.w,v_cutoff_opacity);if (v_cutoff_opacity==0.0) {discard;}\n#else\nshadowed_lighting_factor=shadowed_light_factor_normal(normal,v_pos_light_view_0,v_pos_light_view_1,1.0/gl_FragCoord.w);\n#endif\ncolor.rgb=apply_lighting(color.rgb,normal,shadowed_lighting_factor);\n#endif\n#else\ncolor.rgb=apply_lighting(color.rgb,normal);\n#ifdef FLOOD_LIGHT\ncolor.rgb=mix(color.rgb,u_flood_light_color*u_opacity,flood_radiance);\n#endif\n#endif\ncolor.rgb=mix(color.rgb,v_flat.rgb,emissive_strength);color*=u_opacity;\n#endif\n#ifdef FOG\ncolor=fog_dither(fog_apply_premultiplied(color,v_fog_pos,h));\n#endif\n#ifdef INDICATOR_CUTOUT\ncolor=applyCutout(color,h);\n#endif\nglFragColor=color;\n#ifdef OVERDRAW_INSPECTOR\nglFragColor=vec4(1.0);\n#endif\nHANDLE_WIREFRAME_DEBUG;}', '#include "_prelude_fog.vertex.glsl"\n#include "_prelude_terrain.vertex.glsl"\n#include "_prelude_shadow.vertex.glsl"\n#include "_prelude_lighting.glsl"\nuniform mat4 u_matrix;uniform vec3 u_lightcolor;uniform lowp vec3 u_lightpos;uniform lowp float u_lightintensity;uniform float u_vertical_gradient;uniform lowp float u_opacity;uniform float u_edge_radius;uniform float u_width_scale;in vec4 a_pos_normal_ed;in vec2 a_centroid_pos;\n#ifdef RENDER_WALL_MODE\nin vec3 a_join_normal_inside;\n#endif\n#ifdef PROJECTION_GLOBE_VIEW\nin vec3 a_pos_3;in vec3 a_pos_normal_3;uniform mat4 u_inv_rot_matrix;uniform vec2 u_merc_center;uniform vec3 u_tile_id;uniform float u_zoom_transition;uniform vec3 u_up_dir;uniform float u_height_lift;\n#endif\n#ifdef TERRAIN\nuniform int u_height_type;uniform int u_base_type;\n#endif\nuniform highp float u_vertical_scale;out vec4 v_color;out vec4 v_flat;\n#ifdef RENDER_SHADOWS\nuniform mat4 u_light_matrix_0;uniform mat4 u_light_matrix_1;out highp vec4 v_pos_light_view_0;out highp vec4 v_pos_light_view_1;\n#endif\n#if defined(ZERO_ROOF_RADIUS) && !defined(LIGHTING_3D_MODE)\nout vec4 v_roof_color;\n#endif\n#if defined(ZERO_ROOF_RADIUS) || defined(RENDER_SHADOWS) || defined(LIGHTING_3D_MODE)\nout highp vec3 v_normal;\n#endif\n#ifdef FAUX_AO\nuniform lowp vec2 u_ao;out vec2 v_ao;\n#endif\n#if defined(LIGHTING_3D_MODE) && defined(FLOOD_LIGHT)\nout float v_flood_radius;out float v_has_floodlight;\n#endif\nout float v_height;vec3 linearTosRGB(vec3 color) {return pow(color,vec3(1./2.2));}vec3 sRGBToLinear(vec3 srgbIn) {return pow(srgbIn,vec3(2.2));}\n#pragma mapbox: define highp float base\n#pragma mapbox: define highp float height\n#pragma mapbox: define highp vec4 color\n#pragma mapbox: define highp float flood_light_wall_radius\n#pragma mapbox: define highp float line_width\n#pragma mapbox: define highp float emissive_strength\nvoid main() {\n#pragma mapbox: initialize highp float base\n#pragma mapbox: initialize highp float height\n#pragma mapbox: initialize highp vec4 color\n#pragma mapbox: initialize highp float flood_light_wall_radius\n#pragma mapbox: initialize highp float line_width\n#pragma mapbox: initialize highp float emissive_strength\nbase*=u_vertical_scale;height*=u_vertical_scale;vec4 pos_nx=floor(a_pos_normal_ed*0.5);vec4 top_up_ny_start=a_pos_normal_ed-2.0*pos_nx;vec3 top_up_ny=top_up_ny_start.xyz;float x_normal=pos_nx.z/8192.0;vec3 normal=top_up_ny.y==1.0 ? vec3(0.0,0.0,1.0) : normalize(vec3(x_normal,(2.0*top_up_ny.z-1.0)*(1.0-abs(x_normal)),0.0));\n#if defined(ZERO_ROOF_RADIUS) || defined(RENDER_SHADOWS) || defined(LIGHTING_3D_MODE)\nv_normal=normal;\n#endif\nbase=max(0.0,base);float attr_height=height;height=max(0.0,top_up_ny.y==0.0 && top_up_ny.x==1.0 ? height-u_edge_radius : height);float t=top_up_ny.x;vec2 centroid_pos=vec2(0.0);\n#if defined(HAS_CENTROID) || defined(TERRAIN)\ncentroid_pos=a_centroid_pos;\n#endif\nfloat ele=0.0;float h=0.0;float c_ele=0.0;vec3 pos;\n#ifdef TERRAIN\nbool is_flat_height=centroid_pos.x !=0.0 && u_height_type==1;bool is_flat_base=centroid_pos.x !=0.0 && u_base_type==1;ele=elevation(pos_nx.xy);c_ele=is_flat_height || is_flat_base ? (centroid_pos.y==0.0 ? elevationFromUint16(centroid_pos.x) : flatElevation(centroid_pos)) : ele;float h_height=is_flat_height ? max(c_ele+height,ele+base+2.0) : ele+height;float h_base=is_flat_base ? max(c_ele+base,ele+base) : ele+(base==0.0 ?-5.0 : base);h=t > 0.0 ? max(h_base,h_height) : h_base;pos=vec3(pos_nx.xy,h);\n#else\nh=t > 0.0 ? height : base;pos=vec3(pos_nx.xy,h);\n#endif\n#ifdef PROJECTION_GLOBE_VIEW\nfloat lift=float((t+base) > 0.0)*u_height_lift;h+=lift;vec3 globe_normal=normalize(mix(a_pos_normal_3/16384.0,u_up_dir,u_zoom_transition));vec3 globe_pos=a_pos_3+globe_normal*(u_tile_up_scale*h);vec3 merc_pos=mercator_tile_position(u_inv_rot_matrix,pos.xy,u_tile_id,u_merc_center)+u_up_dir*u_tile_up_scale*pos.z;pos=mix_globe_mercator(globe_pos,merc_pos,u_zoom_transition);\n#endif\nfloat cutoff=1.0;vec3 scaled_pos=pos;\n#ifdef RENDER_CUTOFF\nvec3 centroid_random=vec3(centroid_pos.xy,centroid_pos.x+centroid_pos.y+1.0);vec3 ground_pos=centroid_pos.x==0.0 ? pos.xyz : (centroid_random/8.0);vec4 ground=u_matrix*vec4(ground_pos.xy,ele,1.0);cutoff=cutoff_opacity(u_cutoff_params,ground.z);if (centroid_pos.y !=0.0 && centroid_pos.x !=0.0) {vec3 g=floor(ground_pos);vec3 mod_=centroid_random-g*8.0;float seed=min(1.0,0.1*(min(3.5,max(mod_.x+mod_.y,0.2*attr_height))*0.35+mod_.z));if (cutoff < 0.8-seed) {cutoff=0.0;}}float cutoff_scale=cutoff;v_cutoff_opacity=cutoff;scaled_pos.z=mix(c_ele,h,cutoff_scale);\n#endif\nfloat hidden=float((centroid_pos.x==0.0 && centroid_pos.y==1.0) || (cutoff==0.0 && centroid_pos.x !=0.0) || (color.a==0.0));\n#ifdef RENDER_WALL_MODE\nvec2 wall_offset=u_width_scale*line_width*(a_join_normal_inside.xy/EXTENT);scaled_pos.xy+=(1.0-a_join_normal_inside.z)*wall_offset*0.5;scaled_pos.xy-=a_join_normal_inside.z*wall_offset*0.5;\n#endif\ngl_Position=mix(u_matrix*vec4(scaled_pos,1),AWAY,hidden);h=h-ele;v_height=h;\n#ifdef RENDER_SHADOWS\nvec3 shd_pos0=pos;vec3 shd_pos1=pos;\n#ifdef NORMAL_OFFSET\nvec3 offset=shadow_normal_offset(normal);shd_pos0+=offset*shadow_normal_offset_multiplier0();shd_pos1+=offset*shadow_normal_offset_multiplier1();\n#endif\nv_pos_light_view_0=u_light_matrix_0*vec4(shd_pos0,1);v_pos_light_view_1=u_light_matrix_1*vec4(shd_pos1,1);\n#endif\nfloat NdotL=0.0;float colorvalue=0.0;\n#ifndef LIGHTING_3D_MODE\ncolorvalue=color.r*0.2126+color.g*0.7152+color.b*0.0722;vec4 ambientlight=vec4(0.03,0.03,0.03,1.0);color+=ambientlight;NdotL=clamp(dot(normal,u_lightpos),0.0,1.0);NdotL=mix((1.0-u_lightintensity),max((1.0-colorvalue+u_lightintensity),1.0),NdotL);if (normal.y !=0.0) {float r=0.84;r=mix(0.7,0.98,1.0-u_lightintensity);NdotL*=(\n(1.0-u_vertical_gradient)+(u_vertical_gradient*clamp((t+base)*pow(height/150.0,0.5),r,1.0)));}\n#endif\n#ifdef FAUX_AO\nfloat concave=pos_nx.w-floor(pos_nx.w*0.5)*2.0;float start=top_up_ny_start.w;float y_ground=1.0-clamp(t+base,0.0,1.0);float top_height=height;\n#ifdef TERRAIN\ntop_height=mix(max(c_ele+height,ele+base+2.0),ele+height,float(centroid_pos.x==0.0))-ele;y_ground+=y_ground*5.0/max(3.0,top_height);\n#endif\nv_ao=vec2(mix(concave,-concave,start),y_ground);NdotL*=(1.0+0.05*(1.0-top_up_ny.y)*u_ao[0]);\n#ifdef PROJECTION_GLOBE_VIEW\ntop_height+=u_height_lift;\n#endif\ngl_Position.z-=(0.0000006*(min(top_height,500.)+2.0*min(base,500.0)+60.0*concave+3.0*start))*gl_Position.w;\n#endif\n#ifdef LIGHTING_3D_MODE\n#ifdef FLOOD_LIGHT\nfloat is_wall=1.0-float(t > 0.0 && top_up_ny.y > 0.0);v_has_floodlight=float(flood_light_wall_radius > 0.0 && is_wall > 0.0);v_flood_radius=flood_light_wall_radius*u_vertical_scale;\n#endif\nv_color=vec4(color.rgb,1.0);float ndotl=calculate_NdotL(normal);v_flat.rgb=sRGBToLinear(color.rgb);v_flat.rgb=v_flat.rgb*(ndotl+(1.0-min(ndotl*57.29,1.0))*emissive_strength);v_flat=vec4(linearTosRGB(v_flat.rgb),1.0);\n#else\nv_color=vec4(0.0,0.0,0.0,1.0);v_color.rgb+=clamp(color.rgb*NdotL*u_lightcolor,mix(vec3(0.0),vec3(0.3),1.0-u_lightcolor),vec3(1.0));v_color*=u_opacity;\n#endif\n#if defined(ZERO_ROOF_RADIUS) && !defined(LIGHTING_3D_MODE)\nfloat roofNdotL=clamp(u_lightpos.z,0.0,1.0);roofNdotL=mix((1.0-u_lightintensity),max((1.0-colorvalue+u_lightintensity),1.0),roofNdotL);v_roof_color=vec4(0.0,0.0,0.0,1.0);v_roof_color.rgb+=clamp(color.rgb*roofNdotL*u_lightcolor,mix(vec3(0.0),vec3(0.3),1.0-u_lightcolor),vec3(1.0));v_roof_color*=u_opacity;\n#endif\n#ifdef FOG\nv_fog_pos=fog_position(pos);\n#endif\n}'), fillExtrusionDepth: Go("in highp float v_depth;void main() {\n#ifndef DEPTH_TEXTURE\nglFragColor=pack_depth(v_depth);\n#endif\n}", '#include "_prelude_terrain.vertex.glsl"\nuniform mat4 u_matrix;uniform float u_edge_radius;uniform float u_width_scale;uniform float u_vertical_scale;\n#ifdef TERRAIN\nuniform int u_height_type;uniform int u_base_type;\n#endif\nin vec4 a_pos_normal_ed;in vec2 a_centroid_pos;\n#ifdef RENDER_WALL_MODE\nin vec3 a_join_normal_inside;\n#endif\n#pragma mapbox: define highp float base\n#pragma mapbox: define highp float height\n#pragma mapbox: define highp float line_width\n#pragma mapbox: define highp vec4 color\nout highp float v_depth;void main() {\n#pragma mapbox: initialize highp float base\n#pragma mapbox: initialize highp float height\n#pragma mapbox: initialize highp float line_width\n#pragma mapbox: initialize highp vec4 color\nbase*=u_vertical_scale;height*=u_vertical_scale;vec3 pos_nx=floor(a_pos_normal_ed.xyz*0.5);mediump vec3 top_up_ny=a_pos_normal_ed.xyz-2.0*pos_nx;base=max(0.0,base);height=max(0.0,top_up_ny.y==0.0 && top_up_ny.x==1.0 ? height-u_edge_radius : height);float t=top_up_ny.x;vec2 centroid_pos=vec2(0.0);\n#if defined(HAS_CENTROID) || defined(TERRAIN)\ncentroid_pos=a_centroid_pos;\n#endif\nvec3 pos;\n#ifdef TERRAIN\nbool is_flat_height=centroid_pos.x !=0.0 && u_height_type==1;bool is_flat_base=centroid_pos.x !=0.0 && u_base_type==1;float ele=elevation(pos_nx.xy);float c_ele=is_flat_height || is_flat_base ? (centroid_pos.y==0.0 ? elevationFromUint16(centroid_pos.x) : flatElevation(centroid_pos)) : ele;float h_height=is_flat_height ? max(c_ele+height,ele+base+2.0) : ele+height;float h_base=is_flat_base ? max(c_ele+base,ele+base) : ele+(base==0.0 ?-5.0 : base);float h=t > 0.0 ? max(h_base,h_height) : h_base;pos=vec3(pos_nx.xy,h);\n#else\npos=vec3(pos_nx.xy,t > 0.0 ? height : base);\n#endif\n#ifdef RENDER_WALL_MODE\nvec2 wall_offset=u_width_scale*line_width*(a_join_normal_inside.xy/EXTENT);pos.xy+=(1.0-a_join_normal_inside.z)*wall_offset*0.5;pos.xy-=a_join_normal_inside.z*wall_offset*0.5;\n#endif\nfloat hidden=float((centroid_pos.x==0.0 && centroid_pos.y==1.0) || (color.a==0.0));gl_Position=mix(u_matrix*vec4(pos,1),AWAY,hidden);v_depth=gl_Position.z/gl_Position.w;}'), fillExtrusionPattern: Go('#include "_prelude_fog.fragment.glsl"\n#include "_prelude_lighting.glsl"\nuniform vec2 u_texsize;uniform sampler2D u_image;\n#ifdef FILL_EXTRUSION_PATTERN_TRANSITION\nuniform float u_pattern_transition;\n#endif\n#ifdef FAUX_AO\nuniform lowp vec2 u_ao;in vec3 v_ao;\n#endif\n#ifdef LIGHTING_3D_MODE\nin vec3 v_normal;\n#endif\nin highp vec2 v_pos;in vec4 v_lighting;uniform lowp float u_opacity;\n#pragma mapbox: define highp float base\n#pragma mapbox: define highp float height\n#pragma mapbox: define mediump vec4 pattern\n#ifdef FILL_EXTRUSION_PATTERN_TRANSITION\n#pragma mapbox: define mediump vec4 pattern_b\n#endif\n#pragma mapbox: define highp float pixel_ratio\nvoid main() {\n#pragma mapbox: initialize highp float base\n#pragma mapbox: initialize highp float height\n#pragma mapbox: initialize mediump vec4 pattern\n#ifdef FILL_EXTRUSION_PATTERN_TRANSITION\n#pragma mapbox: initialize mediump vec4 pattern_b\n#endif\n#pragma mapbox: initialize highp float pixel_ratio\nvec2 pattern_tl=pattern.xy;vec2 pattern_br=pattern.zw;highp vec2 imagecoord=mod(v_pos,1.0);highp vec2 pos=mix(pattern_tl/u_texsize,pattern_br/u_texsize,imagecoord);highp vec2 lod_pos=mix(pattern_tl/u_texsize,pattern_br/u_texsize,v_pos);vec4 out_color=textureLodCustom(u_image,pos,lod_pos);\n#ifdef FILL_EXTRUSION_PATTERN_TRANSITION\nvec2 pattern_b_tl=pattern_b.xy;vec2 pattern_b_br=pattern_b.zw;highp vec2 pos_b=mix(pattern_b_tl/u_texsize,pattern_b_br/u_texsize,imagecoord);vec4 color_b=textureLodCustom(u_image,pos_b,lod_pos);out_color=out_color*(1.0-u_pattern_transition)+color_b*u_pattern_transition;\n#endif\n#ifdef LIGHTING_3D_MODE\nout_color=apply_lighting(out_color,normalize(v_normal))*u_opacity;\n#else\nout_color=out_color*v_lighting;\n#endif\n#ifdef FAUX_AO\nfloat intensity=u_ao[0];float h=max(0.0,v_ao.z);float h_floors=h/u_ao[1];float y_shade=1.0-0.9*intensity*min(v_ao.y,1.0);float shade=(1.0-0.08*intensity)*(y_shade+(1.0-y_shade)*(1.0-pow(1.0-min(h_floors/16.0,1.0),16.0)))+0.08*intensity*min(h_floors/160.0,1.0);float concave=v_ao.x*v_ao.x;float x_shade=mix(1.0,mix(0.6,0.75,min(h_floors/30.0,1.0)),intensity)+0.1*intensity*min(h,1.0);shade*=mix(1.0,x_shade*x_shade*x_shade,concave);out_color.rgb=out_color.rgb*shade;\n#endif\n#ifdef FOG\nout_color=fog_dither(fog_apply_premultiplied(out_color,v_fog_pos));\n#endif\n#ifdef INDICATOR_CUTOUT\nout_color=applyCutout(out_color,height);\n#endif\nglFragColor=out_color;\n#ifdef OVERDRAW_INSPECTOR\nglFragColor=vec4(1.0);\n#endif\nHANDLE_WIREFRAME_DEBUG;}', '#include "_prelude_fog.vertex.glsl"\n#include "_prelude_terrain.vertex.glsl"\n#include "_prelude_lighting.glsl"\nuniform mat4 u_matrix;uniform vec2 u_pixel_coord_upper;uniform vec2 u_pixel_coord_lower;uniform float u_height_factor;uniform float u_tile_units_to_pixels;uniform float u_vertical_gradient;uniform lowp float u_opacity;uniform float u_width_scale;uniform vec3 u_lightcolor;uniform lowp vec3 u_lightpos;uniform lowp float u_lightintensity;in vec4 a_pos_normal_ed;in vec2 a_centroid_pos;\n#ifdef RENDER_WALL_MODE\nin vec3 a_join_normal_inside;\n#endif\n#ifdef PROJECTION_GLOBE_VIEW\nin vec3 a_pos_3;in vec3 a_pos_normal_3;uniform mat4 u_inv_rot_matrix;uniform vec2 u_merc_center;uniform vec3 u_tile_id;uniform float u_zoom_transition;uniform vec3 u_up_dir;uniform float u_height_lift;\n#endif\n#ifdef TERRAIN\nuniform int u_height_type;uniform int u_base_type;\n#endif\nout highp vec2 v_pos;out vec4 v_lighting;\n#ifdef FAUX_AO\nuniform lowp vec2 u_ao;out vec3 v_ao;\n#endif\n#ifdef LIGHTING_3D_MODE\nout vec3 v_normal;\n#endif\n#pragma mapbox: define highp float base\n#pragma mapbox: define highp float height\n#pragma mapbox: define highp vec4 color\n#pragma mapbox: define mediump vec4 pattern\n#ifdef FILL_EXTRUSION_PATTERN_TRANSITION\n#pragma mapbox: define mediump vec4 pattern_b\n#endif\n#pragma mapbox: define highp float pixel_ratio\n#pragma mapbox: define highp float line_width\nvoid main() {\n#pragma mapbox: initialize highp float base\n#pragma mapbox: initialize highp float height\n#pragma mapbox: initialize highp vec4 color\n#pragma mapbox: initialize mediump vec4 pattern\n#ifdef FILL_EXTRUSION_PATTERN_TRANSITION\n#pragma mapbox: initialize mediump vec4 pattern_b\n#endif\n#pragma mapbox: initialize highp float pixel_ratio\n#pragma mapbox: initialize highp float line_width\nvec2 pattern_tl=pattern.xy;vec2 pattern_br=pattern.zw;vec4 pos_nx=floor(a_pos_normal_ed*0.5);mediump vec4 top_up_ny_start=a_pos_normal_ed-2.0*pos_nx;mediump vec3 top_up_ny=top_up_ny_start.xyz;float x_normal=pos_nx.z/8192.0;vec3 normal=top_up_ny.y==1.0 ? vec3(0.0,0.0,1.0) : normalize(vec3(x_normal,(2.0*top_up_ny.z-1.0)*(1.0-abs(x_normal)),0.0));float edgedistance=a_pos_normal_ed.w;vec2 display_size=(pattern_br-pattern_tl)/pixel_ratio;base=max(0.0,base);height=max(0.0,height);float t=top_up_ny.x;float z=t > 0.0 ? height : base;vec2 centroid_pos=vec2(0.0);\n#if defined(HAS_CENTROID) || defined(TERRAIN)\ncentroid_pos=a_centroid_pos;\n#endif\nfloat ele=0.0;float h=z;vec3 p;float c_ele;\n#ifdef TERRAIN\nbool is_flat_height=centroid_pos.x !=0.0 && u_height_type==1;bool is_flat_base=centroid_pos.x !=0.0 && u_base_type==1;ele=elevation(pos_nx.xy);c_ele=is_flat_height || is_flat_base ? (centroid_pos.y==0.0 ? elevationFromUint16(centroid_pos.x) : flatElevation(centroid_pos)) : ele;float h_height=is_flat_height ? max(c_ele+height,ele+base+2.0) : ele+height;float h_base=is_flat_base ? max(c_ele+base,ele+base) : ele+(base==0.0 ?-5.0 : base);h=t > 0.0 ? max(h_base,h_height) : h_base;p=vec3(pos_nx.xy,h);\n#else\np=vec3(pos_nx.xy,z);\n#endif\n#ifdef PROJECTION_GLOBE_VIEW\nfloat lift=float((t+base) > 0.0)*u_height_lift;h+=lift;vec3 globe_normal=normalize(mix(a_pos_normal_3/16384.0,u_up_dir,u_zoom_transition));vec3 globe_pos=a_pos_3+globe_normal*(u_tile_up_scale*(p.z+lift));vec3 merc_pos=mercator_tile_position(u_inv_rot_matrix,p.xy,u_tile_id,u_merc_center)+u_up_dir*u_tile_up_scale*p.z;p=mix_globe_mercator(globe_pos,merc_pos,u_zoom_transition);\n#endif\n#ifdef RENDER_WALL_MODE\nvec2 wall_offset=u_width_scale*line_width*(a_join_normal_inside.xy/EXTENT);p.xy+=(1.0-a_join_normal_inside.z)*wall_offset*0.5;p.xy-=a_join_normal_inside.z*wall_offset*0.5;\n#endif\nfloat hidden=float((centroid_pos.x==0.0 && centroid_pos.y==1.0) || (color.a==0.0));gl_Position=mix(u_matrix*vec4(p,1),AWAY,hidden);vec2 pos=normal.z==1.0\n? pos_nx.xy\n: vec2(edgedistance,z*u_height_factor);v_pos=get_pattern_pos(u_pixel_coord_upper,u_pixel_coord_lower,display_size,u_tile_units_to_pixels,pos);v_lighting=vec4(0.0,0.0,0.0,1.0);float NdotL=0.0;\n#ifdef LIGHTING_3D_MODE\nNdotL=calculate_NdotL(normal);\n#else\nNdotL=clamp(dot(normal,u_lightpos),0.0,1.0);NdotL=mix((1.0-u_lightintensity),max((0.5+u_lightintensity),1.0),NdotL);\n#endif\nif (normal.y !=0.0) {float r=0.84;\n#ifndef LIGHTING_3D_MODE\nr=mix(0.7,0.98,1.0-u_lightintensity);\n#endif\nNdotL*=(\n(1.0-u_vertical_gradient)+(u_vertical_gradient*clamp((t+base)*pow(height/150.0,0.5),r,1.0)));}\n#ifdef FAUX_AO\nfloat concave=pos_nx.w-floor(pos_nx.w*0.5)*2.0;float start=top_up_ny_start.w;float y_ground=1.0-clamp(t+base,0.0,1.0);float top_height=height;\n#ifdef TERRAIN\ntop_height=mix(max(c_ele+height,ele+base+2.0),ele+height,float(centroid_pos.x==0.0))-ele;y_ground+=y_ground*5.0/max(3.0,top_height);\n#endif\nv_ao=vec3(mix(concave,-concave,start),y_ground,h-ele);NdotL*=(1.0+0.05*(1.0-top_up_ny.y)*u_ao[0]);\n#ifdef PROJECTION_GLOBE_VIEW\ntop_height+=u_height_lift;\n#endif\ngl_Position.z-=(0.0000006*(min(top_height,500.)+2.0*min(base,500.0)+60.0*concave+3.0*start))*gl_Position.w;\n#endif\n#ifdef LIGHTING_3D_MODE\nv_normal=normal;\n#else\nv_lighting.rgb+=clamp(NdotL*u_lightcolor,mix(vec3(0.0),vec3(0.3),1.0-u_lightcolor),vec3(1.0));v_lighting*=u_opacity;\n#endif\n#ifdef FOG\nv_fog_pos=fog_position(p);\n#endif\n}'), groundShadow: Go('#include "_prelude_shadow.fragment.glsl"\nprecision highp float;uniform vec3 u_ground_shadow_factor;in vec4 v_pos_light_view_0;in vec4 v_pos_light_view_1;\n#ifdef FOG\nin float v_fog_opacity;\n#endif\nvoid main() {float light=shadowed_light_factor_plane_bias(v_pos_light_view_0,v_pos_light_view_1,1.0/gl_FragCoord.w);vec3 shadow=mix(u_ground_shadow_factor,vec3(1.0),light);\n#ifdef RENDER_CUTOFF\nshadow=mix(vec3(1.0),shadow,cutoff_opacity(u_cutoff_params,1.0/gl_FragCoord.w));\n#endif\n#ifdef FOG\nshadow=mix(shadow,vec3(1.0),v_fog_opacity);\n#endif\n#ifdef INDICATOR_CUTOUT\nshadow=mix(shadow,vec3(1.0),1.0-applyCutout(vec4(1.0),0.0).r);\n#endif\nglFragColor=vec4(shadow,1.0);}', '#include "_prelude_fog.vertex.glsl"\nuniform mat4 u_matrix;uniform mat4 u_light_matrix_0;uniform mat4 u_light_matrix_1;in vec2 a_pos;out vec4 v_pos_light_view_0;out vec4 v_pos_light_view_1;\n#ifdef FOG\nout float v_fog_opacity;\n#endif\nvoid main() {gl_Position=u_matrix*vec4(a_pos,0.0,1.0);v_pos_light_view_0=u_light_matrix_0*vec4(a_pos,0.0,1.0);v_pos_light_view_1=u_light_matrix_1*vec4(a_pos,0.0,1.0);\n#ifdef FOG\nv_fog_pos=fog_position(a_pos);v_fog_opacity=fog(v_fog_pos);\n#endif\n}'), fillExtrusionGroundEffect: Go("uniform highp float u_ao_pass;uniform highp float u_opacity;uniform highp float u_flood_light_intensity;uniform highp vec3 u_flood_light_color;uniform highp float u_attenuation;uniform sampler2D u_fb;uniform float u_fb_size;\n#ifdef SDF_SUBPASS\nin highp vec2 v_pos;in highp vec4 v_line_segment;in highp float v_flood_light_radius_tile;in highp vec2 v_ao;float line_df(highp vec2 a,highp vec2 b,highp vec2 p) {highp vec2 ba=b-a;highp vec2 pa=p-a;highp float r=clamp(dot(pa,ba)/dot(ba,ba),0.0,1.0);return length(pa-r*ba);}\n#ifdef FOG\nin highp float v_fog;\n#endif\n#endif\nvoid main() {\n#ifdef CLEAR_SUBPASS\nvec4 color=vec4(1.0);\n#ifdef CLEAR_FROM_TEXTURE\ncolor=texture(u_fb,gl_FragCoord.xy/vec2(u_fb_size));\n#endif\nglFragColor=color;\n#else\n#ifdef SDF_SUBPASS\nhighp float d=line_df(v_line_segment.xy,v_line_segment.zw,v_pos);highp float effect_radius=mix(v_flood_light_radius_tile,v_ao.y,u_ao_pass);d/=effect_radius;d=min(d,1.0);d=1.0-pow(1.0-d,u_attenuation);highp float effect_intensity=mix(u_flood_light_intensity,v_ao.x,u_ao_pass);highp float fog=1.0;\n#ifdef FOG\nfog=v_fog;\n#endif\n#ifdef RENDER_CUTOFF\nfog*=v_cutoff_opacity;\n#endif\nglFragColor=vec4(vec3(0.0),mix(1.0,d,effect_intensity*u_opacity*fog));\n#else\nvec4 color=mix(vec4(u_flood_light_color,1.0),vec4(vec3(0.0),1.0),u_ao_pass);\n#ifdef OVERDRAW_INSPECTOR\ncolor=vec4(1.0);\n#endif\nglFragColor=color;\n#endif\nHANDLE_WIREFRAME_DEBUG;\n#endif\n}", '#include "_prelude_fog.vertex.glsl"\nin highp vec4 a_pos_end;in highp float a_angular_offset_factor;in highp float a_hidden_by_landmark;\n#ifdef SDF_SUBPASS\nout highp vec2 v_pos;out highp vec4 v_line_segment;out highp float v_flood_light_radius_tile;out highp vec2 v_ao;\n#ifdef FOG\nout highp float v_fog;\n#endif\n#endif\nuniform highp float u_flood_light_intensity;uniform highp mat4 u_matrix;uniform highp float u_ao_pass;uniform highp float u_meter_to_tile;uniform highp float u_edge_radius;uniform highp float u_dynamic_offset;uniform highp vec2 u_ao;\n#pragma mapbox: define highp float flood_light_ground_radius\nconst float TANGENT_CUTOFF=4.0;const float NORM=32767.0;void main() {\n#pragma mapbox: initialize highp float flood_light_ground_radius\nvec2 p=a_pos_end.xy;vec2 q=floor(a_pos_end.zw*0.5);vec2 start_bottom=a_pos_end.zw-q*2.0;float fl_ground_radius=flood_light_ground_radius;fl_ground_radius=abs(flood_light_ground_radius);float direction=flood_light_ground_radius < 0.0 ?-1.0 : 1.0;float flood_radius_tile=fl_ground_radius*u_meter_to_tile;vec2 v=normalize(q-p);float ao_radius=u_ao.y/3.5;float effect_radius=mix(flood_radius_tile,ao_radius,u_ao_pass)+u_edge_radius;float angular_offset_factor=a_angular_offset_factor/NORM*TANGENT_CUTOFF;float angular_offset=direction*angular_offset_factor*effect_radius;float top=1.0-start_bottom.y;float side=(0.5-start_bottom.x)*2.0;vec2 extrusion_parallel=v*side*mix(u_dynamic_offset,angular_offset,top);vec2 perp=vec2(v.y,-v.x);vec2 extrusion_perp=direction*perp*effect_radius*top;vec3 pos=vec3(mix(q,p,start_bottom.x),0.0);pos.xy+=extrusion_parallel+extrusion_perp;\n#ifdef SDF_SUBPASS\nv_pos=pos.xy;v_line_segment=vec4(p,q)+perp.xyxy*u_edge_radius;v_flood_light_radius_tile=flood_radius_tile;v_ao=vec2(u_ao.x,ao_radius);\n#ifdef FOG\nv_fog_pos=fog_position(pos);v_fog=1.0-fog(v_fog_pos);\n#endif\n#endif\nfloat hidden_by_landmark=0.0;\n#ifdef HAS_CENTROID\nhidden_by_landmark=a_hidden_by_landmark;\n#endif\nfloat isFloodlit=float(fl_ground_radius > 0.0 && u_flood_light_intensity > 0.0);float hidden=mix(1.0-isFloodlit,isFloodlit,u_ao_pass);hidden+=hidden_by_landmark;gl_Position=mix(u_matrix*vec4(pos,1.0),AWAY,float(hidden > 0.0));\n#ifdef RENDER_CUTOFF\nv_cutoff_opacity=cutoff_opacity(u_cutoff_params,gl_Position.z);\n#endif\n}'), hillshadePrepare: Go("precision highp float;uniform sampler2D u_image;in vec2 v_pos;uniform vec2 u_dimension;uniform float u_zoom;float getElevation(vec2 coord) {return texture(u_image,coord).r/4.0;}void main() {vec2 epsilon=1.0/u_dimension;float a=getElevation(v_pos+vec2(-epsilon.x,-epsilon.y));float b=getElevation(v_pos+vec2(0,-epsilon.y));float c=getElevation(v_pos+vec2(epsilon.x,-epsilon.y));float d=getElevation(v_pos+vec2(-epsilon.x,0));float e=getElevation(v_pos+vec2(epsilon.x,0));float f=getElevation(v_pos+vec2(-epsilon.x,epsilon.y));float g=getElevation(v_pos+vec2(0,epsilon.y));float h=getElevation(v_pos+vec2(epsilon.x,epsilon.y));float exaggerationFactor=u_zoom < 2.0 ? 0.4 : u_zoom < 4.5 ? 0.35 : 0.3;float exaggeration=u_zoom < 15.0 ? (u_zoom-15.0)*exaggerationFactor : 0.0;vec2 deriv=vec2(\n(c+e+e+h)-(a+d+d+f),(f+g+g+h)-(a+b+b+c)\n)/pow(2.0,exaggeration+(19.2562-u_zoom));glFragColor=clamp(vec4(\nderiv.x/2.0+0.5,deriv.y/2.0+0.5,1.0,1.0),0.0,1.0);}", "uniform mat4 u_matrix;uniform vec2 u_dimension;in vec2 a_pos;in vec2 a_texture_pos;out vec2 v_pos;void main() {gl_Position=u_matrix*vec4(a_pos,0,1);highp vec2 epsilon=1.0/u_dimension;float scale=(u_dimension.x-2.0)/u_dimension.x;v_pos=(a_texture_pos/8192.0)*scale+epsilon;}"), hillshade: Go('#include "_prelude_fog.fragment.glsl"\n#include "_prelude_lighting.glsl"\nuniform sampler2D u_image;in vec2 v_pos;uniform vec2 u_latrange;uniform vec2 u_light;uniform vec4 u_shadow;uniform vec4 u_highlight;uniform vec4 u_accent;uniform float u_emissive_strength;void main() {vec4 pixel=texture(u_image,v_pos);vec2 deriv=((pixel.rg*2.0)-1.0);float scaleFactor=cos(radians((u_latrange[0]-u_latrange[1])*(1.0-v_pos.y)+u_latrange[1]));float slope=atan(1.25*length(deriv)/scaleFactor);float aspect=deriv.x !=0.0 ? atan(deriv.y,-deriv.x) : PI/2.0*(deriv.y > 0.0 ? 1.0 :-1.0);float intensity=u_light.x;float azimuth=u_light.y+PI;float base=1.875-intensity*1.75;float maxValue=0.5*PI;float scaledSlope=intensity !=0.5 ? ((pow(base,slope)-1.0)/(pow(base,maxValue)-1.0))*maxValue : slope;float accent=cos(scaledSlope);vec4 accent_color=(1.0-accent)*u_accent*clamp(intensity*2.0,0.0,1.0);float shade=abs(mod((aspect+azimuth)/PI+0.5,2.0)-1.0);vec4 shade_color=mix(u_shadow,u_highlight,shade)*sin(scaledSlope)*clamp(intensity*2.0,0.0,1.0);glFragColor=accent_color*(1.0-shade_color.a)+shade_color;\n#ifdef LIGHTING_3D_MODE\nglFragColor=apply_lighting_with_emission_ground(glFragColor,u_emissive_strength);\n#endif\n#ifdef FOG\nglFragColor=fog_dither(fog_apply_premultiplied(glFragColor,v_fog_pos));\n#endif\n#ifdef OVERDRAW_INSPECTOR\nglFragColor=vec4(1.0);\n#endif\nHANDLE_WIREFRAME_DEBUG;}', '#include "_prelude_fog.vertex.glsl"\nuniform mat4 u_matrix;in vec2 a_pos;in vec2 a_texture_pos;out vec2 v_pos;void main() {gl_Position=u_matrix*vec4(a_pos,0,1);v_pos=a_texture_pos/8192.0;\n#ifdef FOG\nv_fog_pos=fog_position(a_pos);\n#endif\n}'), line: Go('#include "_prelude_fog.fragment.glsl"\n#include "_prelude_lighting.glsl"\n#include "_prelude_shadow.fragment.glsl"\nuniform lowp float u_device_pixel_ratio;uniform highp float u_width_scale;uniform highp float u_floor_width_scale;uniform float u_alpha_discard_threshold;uniform highp vec2 u_trim_offset;uniform highp vec2 u_trim_fade_range;uniform lowp vec4 u_trim_color;in vec2 v_width2;in vec2 v_normal;in float v_gamma_scale;in highp vec3 v_uv;\n#ifdef ELEVATED_ROADS\nin highp float v_road_z_offset;\n#endif\n#ifdef RENDER_LINE_DASH\nuniform sampler2D u_dash_image;in vec2 v_tex;\n#endif\n#ifdef RENDER_LINE_GRADIENT\nuniform sampler2D u_gradient_image;\n#endif\n#ifdef INDICATOR_CUTOUT\nin highp float v_z_offset;\n#endif\n#ifdef RENDER_SHADOWS\nuniform vec3 u_ground_shadow_factor;in highp vec4 v_pos_light_view_0;in highp vec4 v_pos_light_view_1;in highp float v_depth;\n#endif\nfloat luminance(vec3 c) {return (c.r+c.r+c.b+c.g+c.g+c.g)*0.1667;}uniform float u_emissive_strength;\n#pragma mapbox: define highp vec4 color\n#pragma mapbox: define lowp float floorwidth\n#pragma mapbox: define lowp vec4 dash\n#pragma mapbox: define lowp float blur\n#pragma mapbox: define lowp float opacity\n#pragma mapbox: define lowp float border_width\n#pragma mapbox: define lowp vec4 border_color\nfloat linearstep(float edge0,float edge1,float x) {return  clamp((x-edge0)/(edge1-edge0),0.0,1.0);}void main() {\n#pragma mapbox: initialize highp vec4 color\n#pragma mapbox: initialize lowp float floorwidth\n#pragma mapbox: initialize lowp vec4 dash\n#pragma mapbox: initialize lowp float blur\n#pragma mapbox: initialize lowp float opacity\n#pragma mapbox: initialize lowp float border_width\n#pragma mapbox: initialize lowp vec4 border_color\nfloat dist=length(v_normal)*v_width2.s;float blur2=(u_width_scale*blur+1.0/u_device_pixel_ratio)*v_gamma_scale;float alpha=clamp(min(dist-(v_width2.t-blur2),v_width2.s-dist)/blur2,0.0,1.0);\n#ifdef RENDER_LINE_DASH\nfloat sdfdist=texture(u_dash_image,v_tex).r;float sdfgamma=1.0/(2.0*u_device_pixel_ratio)/dash.z;float scaled_floorwidth=(floorwidth*u_floor_width_scale);alpha*=linearstep(0.5-sdfgamma/scaled_floorwidth,0.5+sdfgamma/scaled_floorwidth,sdfdist);\n#endif\nhighp vec4 out_color;\n#ifdef RENDER_LINE_GRADIENT\nout_color=texture(u_gradient_image,v_uv.xy);\n#else\nout_color=color;\n#endif\nfloat trim_alpha=1.0;\n#ifdef RENDER_LINE_TRIM_OFFSET\nhighp float trim_start=u_trim_offset[0];highp float trim_end=u_trim_offset[1];highp float line_progress=v_uv[2];if (trim_end > trim_start) {highp float start_transition=max(0.0,min(1.0,(line_progress-trim_start)/max(u_trim_fade_range[0],1.0e-9)));highp float end_transition=max(0.0,min(1.0,(trim_end-line_progress)/max(u_trim_fade_range[1],1.0e-9)));highp float transition_factor=min(start_transition,end_transition);out_color=mix(out_color,u_trim_color,transition_factor);trim_alpha=1.0-transition_factor;}\n#endif\nif (u_alpha_discard_threshold !=0.0) {if (alpha < u_alpha_discard_threshold) {discard;}}\n#ifdef RENDER_LINE_BORDER\nfloat edgeBlur=((border_width*u_width_scale)+1.0/u_device_pixel_ratio);float alpha2=clamp(min(dist-(v_width2.t-edgeBlur),v_width2.s-dist)/edgeBlur,0.0,1.0);if (alpha2 < 1.) {float smoothAlpha=smoothstep(0.6,1.0,alpha2);if (border_color.a==0.0) {float Y=(out_color.a > 0.01) ? luminance(out_color.rgb/out_color.a) : 1.;float adjustment=(Y > 0.) ? 0.5/Y : 0.45;if (out_color.a > 0.25 && Y < 0.25) {vec3 borderColor=(Y > 0.) ? out_color.rgb : vec3(1,1,1)*out_color.a;out_color.rgb=out_color.rgb+borderColor*(adjustment*(1.0-smoothAlpha));} else {out_color.rgb*=(0.6 +0.4*smoothAlpha);}} else {out_color=mix(border_color*trim_alpha,out_color,smoothAlpha);}}\n#endif\n#ifdef LIGHTING_3D_MODE\nout_color=apply_lighting_with_emission_ground(out_color,u_emissive_strength);\n#ifdef RENDER_SHADOWS\nfloat light=shadowed_light_factor(v_pos_light_view_0,v_pos_light_view_1,v_depth);\n#ifdef ELEVATED_ROADS\nout_color.rgb*=mix(v_road_z_offset !=0.0 ? u_ground_shadow_factor : vec3(1.0),vec3(1.0),light);\n#else\nout_color.rgb*=mix(u_ground_shadow_factor,vec3(1.0),light);\n#endif\n#endif\n#endif\n#ifdef FOG\nout_color=fog_dither(fog_apply_premultiplied(out_color,v_fog_pos));\n#endif\nout_color*=(alpha*opacity);\n#ifdef INDICATOR_CUTOUT\nout_color=applyCutout(out_color,v_z_offset);\n#endif\nglFragColor=out_color;\n#ifdef OVERDRAW_INSPECTOR\nglFragColor=vec4(1.0);\n#endif\nHANDLE_WIREFRAME_DEBUG;}', '#include "_prelude_fog.vertex.glsl"\n#include "_prelude_shadow.vertex.glsl"\n#include "_prelude_terrain.vertex.glsl"\n#define EXTRUDE_SCALE 0.015873016\nin vec2 a_pos_normal;in vec4 a_data;\n#if defined(ELEVATED) || defined(ELEVATED_ROADS) || defined(VARIABLE_LINE_WIDTH)\nin vec3 a_z_offset_width;\n#endif\n#if defined(RENDER_LINE_GRADIENT) || defined(RENDER_LINE_TRIM_OFFSET)\nin highp vec3 a_packed;\n#endif\n#ifdef RENDER_LINE_DASH\nin float a_linesofar;\n#endif\nuniform mat4 u_matrix;uniform mat2 u_pixels_to_tile_units;uniform vec2 u_units_to_pixels;uniform lowp float u_device_pixel_ratio;uniform float u_width_scale;uniform highp float u_floor_width_scale;\n#ifdef ELEVATED\nuniform lowp float u_zbias_factor;uniform lowp float u_tile_to_meter;float sample_elevation(vec2 apos) {\n#ifdef ELEVATION_REFERENCE_SEA\nreturn 0.0;\n#else\nreturn elevation(apos);\n#endif\n}\n#endif\nout vec2 v_normal;out vec2 v_width2;out float v_gamma_scale;out highp vec3 v_uv;\n#ifdef ELEVATED_ROADS\nout highp float v_road_z_offset;\n#endif\n#ifdef RENDER_LINE_DASH\nuniform vec2 u_texsize;uniform float u_tile_units_to_pixels;out vec2 v_tex;\n#endif\n#ifdef RENDER_LINE_GRADIENT\nuniform float u_image_height;\n#endif\n#ifdef INDICATOR_CUTOUT\nout highp float v_z_offset;\n#endif\n#ifdef RENDER_SHADOWS\nuniform mat4 u_light_matrix_0;uniform mat4 u_light_matrix_1;out highp vec4 v_pos_light_view_0;out highp vec4 v_pos_light_view_1;out highp float v_depth;\n#endif\n#pragma mapbox: define highp vec4 color\n#pragma mapbox: define lowp float floorwidth\n#pragma mapbox: define lowp vec4 dash\n#pragma mapbox: define lowp float blur\n#pragma mapbox: define lowp float opacity\n#pragma mapbox: define mediump float gapwidth\n#pragma mapbox: define lowp float offset\n#pragma mapbox: define mediump float width\n#pragma mapbox: define lowp float border_width\n#pragma mapbox: define lowp vec4 border_color\nvoid main() {\n#pragma mapbox: initialize highp vec4 color\n#pragma mapbox: initialize lowp float floorwidth\n#pragma mapbox: initialize lowp vec4 dash\n#pragma mapbox: initialize lowp float blur\n#pragma mapbox: initialize lowp float opacity\n#pragma mapbox: initialize mediump float gapwidth\n#pragma mapbox: initialize lowp float offset\n#pragma mapbox: initialize mediump float width\n#pragma mapbox: initialize lowp float border_width\n#pragma mapbox: initialize lowp vec4 border_color\nfloat a_z_offset;\n#if defined(ELEVATED) || defined(ELEVATED_ROADS)\na_z_offset=a_z_offset_width.x;\n#endif\nfloat ANTIALIASING=1.0/u_device_pixel_ratio/2.0;vec2 a_extrude=a_data.xy-128.0;float a_direction=mod(a_data.z,4.0)-1.0;vec2 pos=floor(a_pos_normal*0.5);mediump vec2 normal=a_pos_normal-2.0*pos;normal.y=normal.y*2.0-1.0;v_normal=normal;gapwidth=gapwidth/2.0;float halfwidth;\n#ifdef VARIABLE_LINE_WIDTH\nfloat left=a_pos_normal.y-2.0*floor(a_pos_normal.y*0.5);halfwidth=(u_width_scale*(left==1.0 ? a_z_offset_width.y : a_z_offset_width.z))/2.0;\n#else\nhalfwidth=(u_width_scale*width)/2.0;\n#endif\noffset=-1.0*offset*u_width_scale;float inset=gapwidth+(gapwidth > 0.0 ? ANTIALIASING : 0.0);float outset=gapwidth+halfwidth*(gapwidth > 0.0 ? 2.0 : 1.0)+(halfwidth==0.0 ? 0.0 : ANTIALIASING);mediump vec2 dist=outset*a_extrude*EXTRUDE_SCALE;mediump float u=0.5*a_direction;mediump float t=1.0-abs(u);mediump vec2 offset2=offset*a_extrude*EXTRUDE_SCALE*normal.y*mat2(t,-u,u,t);float hidden=float(opacity==0.0);vec2 extrude=dist*u_pixels_to_tile_units;vec4 projected_extrude=u_matrix*vec4(extrude,0.0,0.0);vec2 projected_extrude_xy=projected_extrude.xy;\n#ifdef ELEVATED_ROADS\nv_road_z_offset=a_z_offset;gl_Position=u_matrix*vec4(pos+offset2*u_pixels_to_tile_units,a_z_offset,1.0)+projected_extrude;\n#else\n#ifdef ELEVATED\nvec2 offsetTile=offset2*u_pixels_to_tile_units;vec2 offset_pos=pos+offsetTile;float ele=0.0;\n#ifdef CROSS_SLOPE_VERTICAL\nfloat top=a_pos_normal.y-2.0*floor(a_pos_normal.y*0.5);float line_height=2.0*u_tile_to_meter*outset*top*u_pixels_to_tile_units[1][1]+a_z_offset;ele=sample_elevation(offset_pos)+line_height;projected_extrude=vec4(0);\n#else\n#ifdef CROSS_SLOPE_HORIZONTAL\nfloat ele0=sample_elevation(offset_pos);float ele1=max(sample_elevation(offset_pos+extrude),sample_elevation(offset_pos+extrude/2.0));float ele2=max(sample_elevation(offset_pos-extrude),sample_elevation(offset_pos-extrude/2.0));float ele_max=max(ele0,max(ele1,ele2));ele=ele_max+a_z_offset;\n#else\nfloat ele0=sample_elevation(offset_pos);float ele1=max(sample_elevation(offset_pos+extrude),sample_elevation(offset_pos+extrude/2.0));float ele2=max(sample_elevation(offset_pos-extrude),sample_elevation(offset_pos-extrude/2.0));float ele_max=max(ele0,0.5*(ele1+ele2));ele=ele_max-ele0+ele1+a_z_offset;\n#endif\n#endif\ngl_Position=u_matrix*vec4(offset_pos,ele,1.0)+projected_extrude;float z=clamp(gl_Position.z/gl_Position.w,0.5,1.0);float zbias=max(0.00005,(pow(z,0.8)-z)*u_zbias_factor*u_exaggeration);gl_Position.z-=(gl_Position.w*zbias);gl_Position=mix(gl_Position,AWAY,hidden);\n#else\ngl_Position=mix(u_matrix*vec4(pos+offset2*u_pixels_to_tile_units,0.0,1.0)+projected_extrude,AWAY,hidden);\n#endif\n#endif\n#ifdef ELEVATED_ROADS\n#ifdef RENDER_SHADOWS\nvec3 shd_pos=vec3(pos+(offset2+dist)*u_pixels_to_tile_units,a_z_offset);vec3 shd_pos0=shd_pos;vec3 shd_pos1=shd_pos;\n#ifdef NORMAL_OFFSET\nvec3 shd_pos_offset=shadow_normal_offset(vec3(0.0,0.0,1.0));shd_pos0+=shd_pos_offset*shadow_normal_offset_multiplier0();shd_pos1+=shd_pos_offset*shadow_normal_offset_multiplier1();\n#endif\nv_pos_light_view_0=u_light_matrix_0*vec4(shd_pos0,1);v_pos_light_view_1=u_light_matrix_1*vec4(shd_pos1,1);v_depth=gl_Position.w;\n#endif\n#endif\n#ifndef RENDER_TO_TEXTURE\nfloat epsilon=0.0001;float extrude_length_without_perspective=max(length(dist),epsilon);float extrude_length_with_perspective=max(length(projected_extrude_xy/gl_Position.w*u_units_to_pixels),epsilon);v_gamma_scale=mix(extrude_length_without_perspective/extrude_length_with_perspective,1.0,step(0.01,blur));\n#else\nv_gamma_scale=1.0;\n#endif\n#if defined(RENDER_LINE_GRADIENT) || defined(RENDER_LINE_TRIM_OFFSET)\nhighp float a_uv_x=a_packed[0];float a_split_index=a_packed[1];highp float line_progress=a_packed[2];\n#ifdef RENDER_LINE_GRADIENT\nhighp float texel_height=1.0/u_image_height;highp float half_texel_height=0.5*texel_height;v_uv=vec3(a_uv_x,a_split_index*texel_height-half_texel_height,line_progress);\n#else\nv_uv=vec3(a_uv_x,0.0,line_progress);\n#endif\n#endif\n#ifdef RENDER_LINE_DASH\nfloat scale=dash.z==0.0 ? 0.0 : u_tile_units_to_pixels/dash.z;float height=dash.y;v_tex=vec2(a_linesofar*scale/(floorwidth*u_floor_width_scale),(-normal.y*height+dash.x+0.5)/u_texsize.y);\n#endif\nv_width2=vec2(outset,inset);\n#ifdef FOG\nv_fog_pos=fog_position(pos);\n#endif\n#ifdef INDICATOR_CUTOUT\nv_z_offset=a_z_offset;\n#endif\n}'), linePattern: Go('#include "_prelude_fog.fragment.glsl"\n#include "_prelude_lighting.glsl"\n#include "_prelude_shadow.fragment.glsl"\nuniform highp float u_device_pixel_ratio;uniform highp float u_width_scale;uniform highp float u_alpha_discard_threshold;uniform highp vec2 u_texsize;uniform highp float u_tile_units_to_pixels;uniform highp vec2 u_trim_offset;uniform highp vec2 u_trim_fade_range;uniform lowp vec4 u_trim_color;uniform sampler2D u_image;\n#ifdef LINE_PATTERN_TRANSITION\nuniform float u_pattern_transition;\n#endif\nin vec2 v_normal;in vec2 v_width2;in highp float v_linesofar;in float v_gamma_scale;in float v_width;\n#ifdef RENDER_LINE_TRIM_OFFSET\nin highp vec3 v_uv;\n#endif\n#ifdef ELEVATED_ROADS\nin highp float v_road_z_offset;\n#endif\n#ifdef LINE_JOIN_NONE\nin vec2 v_pattern_data;\n#endif\n#ifdef INDICATOR_CUTOUT\nin highp float v_z_offset;\n#endif\n#ifdef RENDER_SHADOWS\nuniform vec3 u_ground_shadow_factor;in highp vec4 v_pos_light_view_0;in highp vec4 v_pos_light_view_1;in highp float v_depth;\n#endif\nuniform float u_emissive_strength;\n#pragma mapbox: define mediump vec4 pattern\n#ifdef LINE_PATTERN_TRANSITION\n#pragma mapbox: define mediump vec4 pattern_b\n#endif\n#pragma mapbox: define mediump float pixel_ratio\n#pragma mapbox: define mediump float blur\n#pragma mapbox: define mediump float opacity\nvoid main() {\n#pragma mapbox: initialize mediump vec4 pattern\n#ifdef LINE_PATTERN_TRANSITION\n#pragma mapbox: initialize mediump vec4 pattern_b\n#endif\n#pragma mapbox: initialize mediump float pixel_ratio\n#pragma mapbox: initialize mediump float blur\n#pragma mapbox: initialize mediump float opacity\nvec2 pattern_tl=pattern.xy;vec2 pattern_br=pattern.zw;vec2 display_size=(pattern_br-pattern_tl)/pixel_ratio;highp float pattern_size=display_size.x/u_tile_units_to_pixels;float aspect=display_size.y/v_width;float dist=length(v_normal)*v_width2.s;float blur2=(u_width_scale*blur+1.0/u_device_pixel_ratio)*v_gamma_scale;float alpha=clamp(min(dist-(v_width2.t-blur2),v_width2.s-dist)/blur2,0.0,1.0);highp float pattern_x=v_linesofar/pattern_size*aspect;highp float x=mod(pattern_x,1.0);highp float y=0.5*v_normal.y+0.5;vec2 texel_size=1.0/u_texsize;highp vec2 pos=mix(pattern_tl*texel_size-texel_size,pattern_br*texel_size+texel_size,vec2(x,y));highp vec2 lod_pos=mix(pattern_tl*texel_size-texel_size,pattern_br*texel_size+texel_size,vec2(pattern_x,y));vec4 color=textureLodCustom(u_image,pos,lod_pos);\n#ifdef LINE_PATTERN_TRANSITION\nvec2 pattern_b_tl=pattern_b.xy;vec2 pattern_b_br=pattern_b.zw;highp vec2 pos_b=mix(pattern_b_tl*texel_size-texel_size,pattern_b_br*texel_size+texel_size,vec2(x,y));vec4 color_b=textureLodCustom(u_image,pos_b,lod_pos);color=color*(1.0-u_pattern_transition)+color_b*u_pattern_transition;\n#endif\n#ifdef RENDER_LINE_TRIM_OFFSET\nhighp float trim_start=u_trim_offset[0];highp float trim_end=u_trim_offset[1];highp float line_progress=v_uv[2];if (trim_end > trim_start) {highp float start_transition=max(0.0,min(1.0,(line_progress-trim_start)/max(u_trim_fade_range[0],1.0e-9)));highp float end_transition=max(0.0,min(1.0,(trim_end-line_progress)/max(u_trim_fade_range[1],1.0e-9)));highp float transition_factor=min(start_transition,end_transition);color=mix(color,color.a*u_trim_color,transition_factor);}\n#endif\n#ifdef LINE_JOIN_NONE\nhighp float pattern_len=pattern_size/aspect;highp float segment_phase=pattern_len-mod(v_linesofar-v_pattern_data.x+pattern_len,pattern_len);highp float visible_start=segment_phase-step(pattern_len*0.5,segment_phase)*pattern_len;highp float visible_end=floor((v_pattern_data.y-segment_phase)/pattern_len)*pattern_len+segment_phase;visible_end+=step(pattern_len*0.5,v_pattern_data.y-visible_end)*pattern_len;if (v_pattern_data.x < visible_start || v_pattern_data.x >=visible_end) {color=vec4(0.0);}\n#endif\n#ifdef LIGHTING_3D_MODE\ncolor=apply_lighting_with_emission_ground(color,u_emissive_strength);\n#ifdef RENDER_SHADOWS\nfloat light=shadowed_light_factor(v_pos_light_view_0,v_pos_light_view_1,v_depth);\n#ifdef ELEVATED_ROADS\ncolor.rgb*=mix(v_road_z_offset !=0.0 ? u_ground_shadow_factor : vec3(1.0),vec3(1.0),light);\n#else\ncolor.rgb*=mix(u_ground_shadow_factor,vec3(1.0),light);\n#endif\n#endif\n#endif\n#ifdef FOG\ncolor=fog_dither(fog_apply_premultiplied(color,v_fog_pos));\n#endif\ncolor*=(alpha*opacity);if (u_alpha_discard_threshold !=0.0) {if (color.a < u_alpha_discard_threshold) {discard;}}\n#ifdef INDICATOR_CUTOUT\ncolor=applyCutout(color,v_z_offset);\n#endif\nglFragColor=color;\n#ifdef OVERDRAW_INSPECTOR\nglFragColor=vec4(1.0);\n#endif\nHANDLE_WIREFRAME_DEBUG;}', '#include "_prelude_fog.vertex.glsl"\n#include "_prelude_shadow.vertex.glsl"\n#include "_prelude_terrain.vertex.glsl"\n#define scale 0.015873016\nin vec2 a_pos_normal;in vec4 a_data;\n#if defined(ELEVATED) || defined(ELEVATED_ROADS)\nin vec3 a_z_offset_width;\n#endif\n#ifdef RENDER_LINE_TRIM_OFFSET\nin highp vec3 a_packed;\n#endif\nin highp float a_linesofar;\n#ifdef LINE_JOIN_NONE\nin highp vec3 a_pattern_data;out vec2 v_pattern_data;\n#endif\n#ifdef INDICATOR_CUTOUT\nout highp float v_z_offset;\n#endif\nuniform mat4 u_matrix;uniform float u_tile_units_to_pixels;uniform vec2 u_units_to_pixels;uniform mat2 u_pixels_to_tile_units;uniform float u_device_pixel_ratio;uniform float u_width_scale;uniform float u_floor_width_scale;\n#ifdef ELEVATED\nuniform lowp float u_zbias_factor;uniform lowp float u_tile_to_meter;float sample_elevation(vec2 apos) {\n#ifdef ELEVATION_REFERENCE_SEA\nreturn 0.0;\n#else\nreturn elevation(apos);\n#endif\n}\n#endif\nout vec2 v_normal;out vec2 v_width2;out highp float v_linesofar;out float v_gamma_scale;out float v_width;\n#ifdef RENDER_LINE_TRIM_OFFSET\nout highp vec3 v_uv;\n#endif\n#ifdef ELEVATED_ROADS\nout highp float v_road_z_offset;\n#endif\n#ifdef RENDER_SHADOWS\nuniform mat4 u_light_matrix_0;uniform mat4 u_light_matrix_1;out highp vec4 v_pos_light_view_0;out highp vec4 v_pos_light_view_1;out highp float v_depth;\n#endif\n#pragma mapbox: define mediump float blur\n#pragma mapbox: define mediump float opacity\n#pragma mapbox: define mediump float offset\n#pragma mapbox: define mediump float gapwidth\n#pragma mapbox: define mediump float width\n#pragma mapbox: define mediump float floorwidth\n#pragma mapbox: define mediump vec4 pattern\n#ifdef LINE_PATTERN_TRANSITION\n#pragma mapbox: define mediump vec4 pattern_b\n#endif\n#pragma mapbox: define mediump float pixel_ratio\nvoid main() {\n#pragma mapbox: initialize mediump float blur\n#pragma mapbox: initialize mediump float opacity\n#pragma mapbox: initialize mediump float offset\n#pragma mapbox: initialize mediump float gapwidth\n#pragma mapbox: initialize mediump float width\n#pragma mapbox: initialize mediump float floorwidth\n#pragma mapbox: initialize mediump vec4 pattern\n#ifdef LINE_PATTERN_TRANSITION\n#pragma mapbox: initialize mediump vec4 pattern_b\n#endif\n#pragma mapbox: initialize mediump float pixel_ratio\nfloat a_z_offset;\n#if defined(ELEVATED) || defined(ELEVATED_ROADS)\na_z_offset=a_z_offset_width.x;\n#endif\nfloat ANTIALIASING=1.0/u_device_pixel_ratio/2.0;vec2 a_extrude=a_data.xy-128.0;float a_direction=mod(a_data.z,4.0)-1.0;vec2 pos=floor(a_pos_normal*0.5);vec2 normal=a_pos_normal-2.0*pos;normal.y=normal.y*2.0-1.0;v_normal=normal;gapwidth=gapwidth/2.0;float halfwidth=(u_width_scale*width)/2.0;offset=-1.0*offset*u_width_scale;float inset=gapwidth+(gapwidth > 0.0 ? ANTIALIASING : 0.0);float outset=gapwidth+halfwidth*(gapwidth > 0.0 ? 2.0 : 1.0)+(halfwidth==0.0 ? 0.0 : ANTIALIASING);vec2 dist=outset*a_extrude*scale;float u=0.5*a_direction;float t=1.0-abs(u);vec2 offset2=offset*a_extrude*scale*normal.y*mat2(t,-u,u,t);float hidden=float(opacity==0.0);vec2 extrude=dist*u_pixels_to_tile_units;vec4 projected_extrude=u_matrix*vec4(extrude,0.0,0.0);vec2 projected_extrude_xy=projected_extrude.xy;\n#ifdef ELEVATED_ROADS\nv_road_z_offset=a_z_offset;gl_Position=u_matrix*vec4(pos+offset2*u_pixels_to_tile_units,a_z_offset,1.0)+projected_extrude;\n#else\n#ifdef ELEVATED\nvec2 offsetTile=offset2*u_pixels_to_tile_units;vec2 offset_pos=pos+offsetTile;float ele=0.0;\n#ifdef CROSS_SLOPE_VERTICAL\nfloat top=a_pos_normal.y-2.0*floor(a_pos_normal.y*0.5);float line_height=2.0*u_tile_to_meter*outset*top*u_pixels_to_tile_units[1][1]+a_z_offset;ele=sample_elevation(offset_pos)+line_height;projected_extrude=vec4(0);\n#else\n#ifdef CROSS_SLOPE_HORIZONTAL\nfloat ele0=sample_elevation(offset_pos);float ele1=max(sample_elevation(offset_pos+extrude),sample_elevation(offset_pos+extrude/2.0));float ele2=max(sample_elevation(offset_pos-extrude),sample_elevation(offset_pos-extrude/2.0));float ele_max=max(ele0,max(ele1,ele2));ele=ele_max+a_z_offset;\n#else\nfloat ele0=sample_elevation(offset_pos);float ele1=max(sample_elevation(offset_pos+extrude),sample_elevation(offset_pos+extrude/2.0));float ele2=max(sample_elevation(offset_pos-extrude),sample_elevation(offset_pos-extrude/2.0));float ele_max=max(ele0,0.5*(ele1+ele2));ele=ele_max-ele0+ele1+a_z_offset;\n#endif\n#endif\ngl_Position=u_matrix*vec4(offset_pos,ele,1.0)+projected_extrude;float z=clamp(gl_Position.z/gl_Position.w,0.5,1.0);float zbias=max(0.00005,(pow(z,0.8)-z)*u_zbias_factor*u_exaggeration);gl_Position.z-=(gl_Position.w*zbias);gl_Position=mix(gl_Position,AWAY,hidden);\n#else\ngl_Position=mix(u_matrix*vec4(pos+offset2*u_pixels_to_tile_units,0.0,1.0)+projected_extrude,AWAY,hidden);\n#endif\n#endif\n#ifdef ELEVATED_ROADS\n#ifdef RENDER_SHADOWS\nvec3 shd_pos=vec3(pos+(offset2+dist)*u_pixels_to_tile_units,a_z_offset);vec3 shd_pos0=shd_pos;vec3 shd_pos1=shd_pos;\n#ifdef NORMAL_OFFSET\nvec3 shd_pos_offset=shadow_normal_offset(vec3(0.0,0.0,1.0));shd_pos0+=shd_pos_offset*shadow_normal_offset_multiplier0();shd_pos1+=shd_pos_offset*shadow_normal_offset_multiplier1();\n#endif\nv_pos_light_view_0=u_light_matrix_0*vec4(shd_pos0,1);v_pos_light_view_1=u_light_matrix_1*vec4(shd_pos1,1);v_depth=gl_Position.w;\n#endif\n#endif\n#ifndef RENDER_TO_TEXTURE\nfloat extrude_length_without_perspective=length(dist);float extrude_length_with_perspective=length(projected_extrude_xy/gl_Position.w*u_units_to_pixels);v_gamma_scale=mix(extrude_length_without_perspective/extrude_length_with_perspective,1.0,step(0.01,blur));\n#else\nv_gamma_scale=1.0;\n#endif\n#ifdef RENDER_LINE_TRIM_OFFSET\nhighp float a_uv_x=a_packed[0];highp float line_progress=a_packed[2];v_uv=vec3(a_uv_x,0.0,line_progress);\n#endif\nv_linesofar=a_linesofar;v_width2=vec2(outset,inset);v_width=(floorwidth*u_floor_width_scale);\n#ifdef LINE_JOIN_NONE\nv_width=(floorwidth*u_floor_width_scale)+ANTIALIASING;mediump float pixels_to_tile_units=1.0/u_tile_units_to_pixels;mediump float pixel_ratio_inverse=1.0/pixel_ratio;mediump float aspect=v_width/((pattern.w-pattern.y)*pixel_ratio_inverse);highp float subt_multiple=(pattern.z-pattern.x)*pixel_ratio_inverse*pixels_to_tile_units*aspect*32.0;highp float subt=floor(a_pattern_data.z/subt_multiple)*subt_multiple;float offset_sign=(fract(a_pattern_data.x)-0.5)*4.0;float line_progress_offset=offset_sign*v_width*0.5*pixels_to_tile_units;v_linesofar=(a_pattern_data.z-subt)+a_linesofar+line_progress_offset;v_pattern_data=vec2(a_pattern_data.x+line_progress_offset,a_pattern_data.y);\n#endif\n#ifdef FOG\nv_fog_pos=fog_position(pos);\n#endif\n#ifdef INDICATOR_CUTOUT\nv_z_offset=a_z_offset;\n#endif\n}'), raster: Go('#include "_prelude_fog.fragment.glsl"\n#include "_prelude_lighting.glsl"\n#include "_prelude_raster_array.glsl"\nuniform float u_fade_t;uniform float u_opacity;uniform highp float u_raster_elevation;uniform highp float u_zoom_transition;in vec2 v_pos0;in vec2 v_pos1;in float v_depth;\n#ifdef PROJECTION_GLOBE_VIEW\nin float v_split_fade;\n#endif\nuniform float u_brightness_low;uniform float u_brightness_high;uniform float u_saturation_factor;uniform float u_contrast_factor;uniform vec3 u_spin_weights;uniform float u_emissive_strength;\n#ifndef RASTER_ARRAY\nuniform highp sampler2D u_image0;uniform sampler2D u_image1;\n#endif\n#ifdef RASTER_COLOR\nuniform sampler2D u_color_ramp;uniform highp vec4 u_colorization_mix;uniform highp float u_colorization_offset;uniform vec2 u_texture_res;\n#endif\nvoid main() {vec4 color0,color1,color;vec2 value;\n#ifdef RASTER_COLOR\n#ifdef RASTER_ARRAY\n#ifdef RASTER_ARRAY_LINEAR\nvalue=mix(\nraTexture2D_image0_linear(v_pos0,u_texture_res,u_colorization_mix,u_colorization_offset),raTexture2D_image1_linear(v_pos1,u_texture_res,u_colorization_mix,u_colorization_offset),u_fade_t\n);\n#else\nvalue=mix(\nraTexture2D_image0_nearest(v_pos0,u_texture_res,u_colorization_mix,u_colorization_offset),raTexture2D_image1_nearest(v_pos1,u_texture_res,u_colorization_mix,u_colorization_offset),u_fade_t\n);\n#endif\nif (value.y > 0.0) value.x/=value.y;\n#else\ncolor=mix(texture(u_image0,v_pos0),texture(u_image1,v_pos1),u_fade_t);value=vec2(u_colorization_offset+dot(color.rgb,u_colorization_mix.rgb),color.a);\n#endif\ncolor=texture(u_color_ramp,vec2(value.x,0.5));if (color.a > 0.0) color.rgb/=color.a;color.a*=value.y;\n#else\ncolor0=texture(u_image0,v_pos0);color1=texture(u_image1,v_pos1);if (color0.a > 0.0) color0.rgb/=color0.a;if (color1.a > 0.0) color1.rgb/=color1.a;color=mix(color0,color1,u_fade_t);\n#endif\ncolor.a*=u_opacity;\n#ifdef GLOBE_POLES\ncolor.a*=1.0-smoothstep(0.0,0.05,u_zoom_transition);\n#endif\nvec3 rgb=color.rgb;rgb=vec3(\ndot(rgb,u_spin_weights.xyz),dot(rgb,u_spin_weights.zxy),dot(rgb,u_spin_weights.yzx));float average=(color.r+color.g+color.b)/3.0;rgb+=(average-rgb)*u_saturation_factor;rgb=(rgb-0.5)*u_contrast_factor+0.5;vec3 u_high_vec=vec3(u_brightness_low,u_brightness_low,u_brightness_low);vec3 u_low_vec=vec3(u_brightness_high,u_brightness_high,u_brightness_high);vec3 out_color=mix(u_high_vec,u_low_vec,rgb);\n#ifdef LIGHTING_3D_MODE\nout_color=apply_lighting_with_emission_ground(vec4(out_color,1.0),u_emissive_strength).rgb;\n#endif\n#ifdef FOG\nhighp float fog_limit_high_meters=1000000.0;highp float fog_limit_low_meters=600000.0;float fog_limit=1.0-smoothstep(fog_limit_low_meters,fog_limit_high_meters,u_raster_elevation);out_color=fog_dither(fog_apply(out_color,v_fog_pos,fog_limit));\n#endif\nglFragColor=vec4(out_color*color.a,color.a);\n#ifdef PROJECTION_GLOBE_VIEW\nglFragColor*=mix(1.0,1.0-smoothstep(0.0,0.05,u_zoom_transition),smoothstep(0.8,0.9,v_split_fade));\n#endif\n#ifdef RENDER_CUTOFF\nglFragColor=glFragColor*cutoff_opacity(u_cutoff_params,v_depth);\n#endif\n#ifdef OVERDRAW_INSPECTOR\nglFragColor=vec4(1.0);\n#endif\nHANDLE_WIREFRAME_DEBUG;}', '#include "_prelude_fog.vertex.glsl"\nuniform mat4 u_matrix;uniform mat4 u_normalize_matrix;uniform mat4 u_globe_matrix;uniform mat4 u_merc_matrix;uniform mat3 u_grid_matrix;uniform vec2 u_tl_parent;uniform float u_scale_parent;uniform vec2 u_perspective_transform;uniform vec2 u_texture_offset;uniform float u_raster_elevation;uniform float u_zoom_transition;uniform vec2 u_merc_center;\n#define GLOBE_UPSCALE GLOBE_RADIUS/6371008.8\n#ifdef GLOBE_POLES\nin vec3 a_globe_pos;in vec2 a_uv;\n#else\nin vec2 a_pos;in vec2 a_texture_pos;\n#endif\nout vec2 v_pos0;out vec2 v_pos1;out float v_depth;\n#ifdef PROJECTION_GLOBE_VIEW\nout float v_split_fade;\n#endif\nvoid main() {vec2 uv;\n#ifdef GLOBE_POLES\nvec3 globe_pos=a_globe_pos;globe_pos+=normalize(globe_pos)*u_raster_elevation*GLOBE_UPSCALE;gl_Position=u_matrix*u_globe_matrix*vec4(globe_pos   ,1.0);uv=a_uv;\n#ifdef FOG\nv_fog_pos=fog_position((u_normalize_matrix*vec4(a_globe_pos,1.0)).xyz);\n#endif\n#else\nfloat w=1.0+dot(a_texture_pos,u_perspective_transform);uv=a_texture_pos/8192.0;\n#ifdef PROJECTION_GLOBE_VIEW\nvec3 decomposed_pos_and_skirt=decomposeToPosAndSkirt(a_pos);vec3 latLng=u_grid_matrix*vec3(decomposed_pos_and_skirt.xy,1.0);vec3 globe_pos=latLngToECEF(latLng.xy);globe_pos+=normalize(globe_pos)*u_raster_elevation*GLOBE_UPSCALE;vec4 globe_world_pos=u_globe_matrix*vec4(globe_pos,1.0);vec4 merc_world_pos=vec4(0.0);float mercatorY=mercatorYfromLat(latLng[0]);float mercatorX=mercatorXfromLng(latLng[1]);    \nv_split_fade=0.0;if (u_zoom_transition > 0.0) {vec2 merc_pos=vec2(mercatorX,mercatorY);merc_world_pos=vec4(merc_pos,u_raster_elevation,1.0);merc_world_pos.xy-=u_merc_center;merc_world_pos.x=wrap(merc_world_pos.x,-0.5,0.5);merc_world_pos=u_merc_matrix*merc_world_pos;float opposite_merc_center=mod(u_merc_center.x+0.5,1.0);float dist_from_poles=(abs(mercatorY-0.5)*2.0);float range=0.1;v_split_fade=abs(opposite_merc_center-mercatorX);v_split_fade=clamp(1.0-v_split_fade,0.0,1.0);v_split_fade=max(smoothstep(1.0-range,1.0,dist_from_poles),max(smoothstep(1.0-range,1.0,v_split_fade),smoothstep(1.0-range,1.0,1.0-v_split_fade)));}float tiles=u_grid_matrix[0][2];if (tiles > 0.0) {float idx=u_grid_matrix[1][2];float idy=u_grid_matrix[2][2];float uvY=mercatorY*tiles-idy;float uvX=mercatorX*tiles-idx;uv=vec2(uvX,uvY);}vec4 interpolated_pos=vec4(mix(globe_world_pos.xyz,merc_world_pos.xyz,u_zoom_transition)*w,w);gl_Position=u_matrix*interpolated_pos;\n#ifdef FOG\nv_fog_pos=fog_position((u_normalize_matrix*vec4(globe_pos,1.0)).xyz);\n#endif\n#else\ngl_Position=u_matrix*vec4(a_pos*w,u_raster_elevation*w,w);\n#ifdef FOG\nv_fog_pos=fog_position(a_pos);\n#endif\n#endif\n#endif\nv_pos0=uv;v_pos1=(v_pos0*u_scale_parent)+u_tl_parent;v_pos0=u_texture_offset.x+u_texture_offset.y*v_pos0;v_pos1=u_texture_offset.x+u_texture_offset.y*v_pos1;\n#ifdef RENDER_CUTOFF\nv_depth=gl_Position.z;\n#endif\n}'), rasterParticle: Go('#include "_prelude_fog.fragment.glsl"\n#include "_prelude_lighting.glsl"\nuniform float u_fade_t;uniform float u_opacity;uniform highp float u_raster_elevation;in vec2 v_pos0;in vec2 v_pos1;uniform sampler2D u_image0;uniform sampler2D u_image1;void main() {vec4 color0,color1,color;color0=texture(u_image0,v_pos0);color1=texture(u_image1,v_pos1);if (color0.a > 0.0) color0.rgb/=color0.a;if (color1.a > 0.0) color1.rgb/=color1.a;color=mix(color0,color1,u_fade_t);color.a*=u_opacity;vec3 out_color=color.rgb;\n#ifdef LIGHTING_3D_MODE\nout_color=apply_lighting_with_emission_ground(vec4(out_color,1.0),0.0).rgb;\n#endif\n#ifdef FOG\nhighp float fog_limit_high_meters=1000000.0;highp float fog_limit_low_meters=600000.0;float fog_limit=1.0-smoothstep(fog_limit_low_meters,fog_limit_high_meters,u_raster_elevation);out_color=fog_dither(fog_apply(out_color,v_fog_pos,fog_limit));\n#endif\nglFragColor=vec4(out_color*color.a,color.a);\n#ifdef OVERDRAW_INSPECTOR\nglFragColor=vec4(1.0);\n#endif\nHANDLE_WIREFRAME_DEBUG;}', '#include "_prelude_fog.vertex.glsl"\nuniform mat4 u_matrix;uniform mat4 u_normalize_matrix;uniform mat4 u_globe_matrix;uniform mat4 u_merc_matrix;uniform mat3 u_grid_matrix;uniform vec2 u_tl_parent;uniform float u_scale_parent;uniform float u_raster_elevation;uniform float u_zoom_transition;uniform vec2 u_merc_center;\n#define GLOBE_UPSCALE GLOBE_RADIUS/6371008.8\nin vec2 a_pos;in vec2 a_texture_pos;out vec2 v_pos0;out vec2 v_pos1;void main() {float w=1.0;vec2 uv;\n#ifdef PROJECTION_GLOBE_VIEW\nvec3 decomposed_pos_and_skirt=decomposeToPosAndSkirt(a_pos);vec3 latLng=u_grid_matrix*vec3(decomposed_pos_and_skirt.xy,1.0);float mercatorY=mercatorYfromLat(latLng[0]);float mercatorX=mercatorXfromLng(latLng[1]);float tiles=u_grid_matrix[0][2];float idx=u_grid_matrix[1][2];float idy=u_grid_matrix[2][2];float uvX=mercatorX*tiles-idx;float uvY=mercatorY*tiles-idy;uv=vec2(uvX,uvY);vec3 globe_pos=latLngToECEF(latLng.xy);globe_pos+=normalize(globe_pos)*u_raster_elevation*GLOBE_UPSCALE;vec4 globe_world_pos=u_globe_matrix*vec4(globe_pos,1.0);vec4 merc_world_pos=vec4(0.0);if (u_zoom_transition > 0.0) {vec2 merc_pos=vec2(mercatorX,mercatorY);merc_world_pos=vec4(merc_pos,u_raster_elevation,1.0);merc_world_pos.xy-=u_merc_center;merc_world_pos.x=wrap(merc_world_pos.x,-0.5,0.5);merc_world_pos=u_merc_matrix*merc_world_pos;}vec4 interpolated_pos=vec4(mix(globe_world_pos.xyz,merc_world_pos.xyz,u_zoom_transition)*w,w);gl_Position=u_matrix*interpolated_pos;\n#ifdef FOG\nv_fog_pos=fog_position((u_normalize_matrix*vec4(globe_pos,1.0)).xyz);\n#endif\n#else\nuv=a_texture_pos/8192.0;gl_Position=u_matrix*vec4(a_pos*w,u_raster_elevation*w,w);\n#ifdef FOG\nv_fog_pos=fog_position(a_pos);\n#endif\n#endif\nv_pos0=uv;v_pos1=(v_pos0*u_scale_parent)+u_tl_parent;}'), rasterParticleDraw: Go("uniform sampler2D u_color_ramp;in float v_particle_speed;void main() {glFragColor=texture(u_color_ramp,vec2(v_particle_speed,0.5));}", '#include "_prelude_raster_particle.glsl"\nin float a_index;uniform sampler2D u_particle_texture;uniform float u_particle_texture_side_len;uniform vec2 u_tile_offset;out float v_particle_speed;void main() {ivec2 pixel_coord=ivec2(\nmod(a_index,u_particle_texture_side_len),a_index/u_particle_texture_side_len);vec4 pixel=texelFetch(u_particle_texture,pixel_coord,0);vec2 pos=unpack_pos_from_rgba(pixel)+u_tile_offset;vec2 tex_coord=fract(pos);vec2 velocity=lookup_velocity(tex_coord);if (velocity==INVALID_VELOCITY) {gl_Position=AWAY;v_particle_speed=0.0;} else {gl_Position=vec4(2.0*pos-1.0,0,1);v_particle_speed=length(velocity);}gl_PointSize=1.0;}'), rasterParticleTexture: Go("uniform sampler2D u_texture;uniform float u_opacity;in vec2 v_tex_pos;void main() {vec4 color=texture(u_texture,v_tex_pos);glFragColor=vec4(floor(255.0*color*u_opacity)/255.0);}", "in vec2 a_pos;out vec2 v_tex_pos;void main() {vec2 uv=0.5*a_pos+vec2(0.5);v_tex_pos=uv;gl_Position=vec4(a_pos,0.0,1.0);}"), rasterParticleUpdate: Go('#include "_prelude_raster_particle.glsl"\nuniform sampler2D u_particle_texture;uniform mediump float u_particle_texture_side_len;uniform mediump float u_speed_factor;uniform highp float u_reset_rate;uniform highp float u_rand_seed;in highp vec2 v_tex_coord;vec2 linearstep(vec2 edge0,vec2 edge1,vec2 x) {return  clamp((x-edge0)/(edge1-edge0),vec2(0),vec2(1));}const highp vec3 rand_constants=vec3(12.9898,78.233,4375.85453);highp float rand(const highp vec2 co) {highp float t=dot(rand_constants.xy,co);return fract(sin(t)*(rand_constants.z+t));}void main() {ivec2 pixel_coord=ivec2(v_tex_coord*u_particle_texture_side_len);highp vec4 pixel=texelFetch(u_particle_texture,pixel_coord,0);highp vec2 pos=unpack_pos_from_rgba(pixel);highp vec2 velocity=lookup_velocity(clamp(pos,0.0,1.0));highp vec2 dp=velocity==INVALID_VELOCITY ? vec2(0) : velocity*u_speed_factor;pos=pos+dp;highp vec2 seed=(pos+v_tex_coord)*u_rand_seed;highp vec2 random_pos=vec2(rand(seed+1.3),rand(seed+2.1));highp vec2 persist_rate=pow(\nlinearstep(vec2(-u_particle_pos_offset),vec2(0),pos)*linearstep(vec2(1.0+u_particle_pos_offset),vec2(1),pos),vec2(4)\n);highp vec2 per_frame_persist=pow(persist_rate,abs(dp)/u_particle_pos_offset);highp float drop_rate=1.0-per_frame_persist.x*per_frame_persist.y;drop_rate=any(greaterThanEqual(abs(pos-0.5),vec2(0.5+u_particle_pos_offset))) ? 1.0 : drop_rate;highp float drop=step(1.0-drop_rate-u_reset_rate,rand(seed));highp vec2 next_pos=mix(pos,random_pos,drop);glFragColor=pack_pos_to_rgba(next_pos);}', "in vec2 a_pos;out vec2 v_tex_coord;void main() {v_tex_coord=0.5*(a_pos+vec2(1.0));gl_Position=vec4(a_pos,0.0,1.0);}"), symbol: Go('#include "_prelude_lighting.glsl"\n#include "_prelude_shadow.fragment.glsl"\n#define SDF_PX 8.0\n#define SDF 1.0\n#define ICON 0.0\nuniform sampler2D u_texture;uniform sampler2D u_texture_icon;uniform highp float u_gamma_scale;uniform lowp float u_device_pixel_ratio;uniform bool u_is_text;uniform bool u_is_halo;uniform lowp float u_scale_factor;\n#ifdef ICON_TRANSITION\nuniform float u_icon_transition;\n#endif\n#ifdef COLOR_ADJUSTMENT\nuniform mat4 u_color_adj_mat;\n#endif\n#ifdef INDICATOR_CUTOUT\nin highp float v_z_offset;\n#else\n#ifdef Z_OFFSET\n#ifdef RENDER_SHADOWS\nin highp float v_z_offset;\n#endif\n#endif\n#endif\nin vec2 v_tex_a;\n#ifdef ICON_TRANSITION\nin vec2 v_tex_b;\n#endif\nin float v_draw_halo;in vec3 v_gamma_scale_size_fade_opacity;\n#ifdef RENDER_TEXT_AND_SYMBOL\nin float is_sdf;in vec2 v_tex_a_icon;\n#endif\n#ifdef Z_OFFSET\n#ifdef RENDER_SHADOWS\nuniform vec3 u_ground_shadow_factor;in highp vec4 v_pos_light_view_0;in highp vec4 v_pos_light_view_1;in highp float v_depth;\n#endif\n#endif\n#pragma mapbox: define highp vec4 fill_color\n#pragma mapbox: define highp vec4 halo_color\n#pragma mapbox: define lowp float opacity\n#pragma mapbox: define lowp float halo_width\n#pragma mapbox: define lowp float halo_blur\n#pragma mapbox: define lowp float emissive_strength\nvoid main() {\n#pragma mapbox: initialize highp vec4 fill_color\n#pragma mapbox: initialize highp vec4 halo_color\n#pragma mapbox: initialize lowp float opacity\n#pragma mapbox: initialize lowp float halo_width\n#pragma mapbox: initialize lowp float halo_blur\n#pragma mapbox: initialize lowp float emissive_strength\nvec4 out_color;float fade_opacity=v_gamma_scale_size_fade_opacity[2];\n#ifdef RENDER_TEXT_AND_SYMBOL\nif (is_sdf==ICON) {vec2 tex_icon=v_tex_a_icon;lowp float alpha=opacity*fade_opacity;glFragColor=texture(u_texture_icon,tex_icon)*alpha;\n#ifdef OVERDRAW_INSPECTOR\nglFragColor=vec4(1.0);\n#endif\nreturn;}\n#endif\n#ifdef RENDER_SDF\nfloat EDGE_GAMMA=0.105/u_device_pixel_ratio;float gamma_scale=v_gamma_scale_size_fade_opacity.x;float size=v_gamma_scale_size_fade_opacity.y;float fontScale=u_is_text ? size/24.0 : size;out_color=fill_color;highp float gamma=EDGE_GAMMA/(fontScale*u_gamma_scale);lowp float buff=(256.0-64.0)/256.0;bool draw_halo=v_draw_halo > 0.0;if (draw_halo) {out_color=halo_color;gamma=(halo_blur*u_scale_factor*1.19/SDF_PX+EDGE_GAMMA)/(fontScale*u_gamma_scale);buff=(6.0-halo_width*u_scale_factor/fontScale)/SDF_PX;}lowp float dist=texture(u_texture,v_tex_a).r;highp float gamma_scaled=gamma*gamma_scale;highp float alpha=smoothstep(buff-gamma_scaled,buff+gamma_scaled,dist);out_color*=alpha;\n#else\n#ifdef ICON_TRANSITION\nvec4 a=texture(u_texture,v_tex_a)*(1.0-u_icon_transition);vec4 b=texture(u_texture,v_tex_b)*u_icon_transition;out_color=(a+b);\n#else\nout_color=texture(u_texture,v_tex_a);\n#endif\n#ifdef COLOR_ADJUSTMENT\nout_color=u_color_adj_mat*out_color;\n#endif\n#endif\nout_color*=opacity*fade_opacity;\n#ifdef LIGHTING_3D_MODE\nout_color=apply_lighting_with_emission_ground(out_color,emissive_strength);\n#ifdef Z_OFFSET\n#ifdef RENDER_SHADOWS\nfloat light=shadowed_light_factor(v_pos_light_view_0,v_pos_light_view_1,v_depth);out_color.rgb*=mix(abs(v_z_offset) > 0.0 ? u_ground_shadow_factor : vec3(1.0),vec3(1.0),light);\n#endif\n#endif\n#endif\n#ifdef INDICATOR_CUTOUT\nout_color=applyCutout(out_color,v_z_offset);\n#endif\nglFragColor=out_color;\n#ifdef OVERDRAW_INSPECTOR\nglFragColor=vec4(1.0);\n#endif\nHANDLE_WIREFRAME_DEBUG;}', '#include "_prelude_terrain.vertex.glsl"\n#include "_prelude_shadow.vertex.glsl"\nin vec4 a_pos_offset;in vec4 a_tex_size;in vec4 a_pixeloffset;in vec4 a_projected_pos;in float a_fade_opacity;\n#ifdef Z_OFFSET\nin float a_auto_z_offset;\n#endif\n#ifdef PROJECTION_GLOBE_VIEW\nin vec3 a_globe_anchor;in vec3 a_globe_normal;\n#endif\n#ifdef ICON_TRANSITION\nin vec2 a_texb;\n#endif\n#ifdef OCCLUSION_QUERIES\nin float a_occlusion_query_opacity;\n#endif\n#ifdef ELEVATED_ROADS\nin vec3 a_x_axis;in vec3 a_y_axis;uniform float u_normal_scale;\n#endif\n#ifdef INDICATOR_CUTOUT\nout highp float v_z_offset;\n#else\n#ifdef Z_OFFSET\n#ifdef RENDER_SHADOWS\nout highp float v_z_offset;\n#endif\n#endif\n#endif\nuniform bool u_is_size_zoom_constant;uniform bool u_is_size_feature_constant;uniform highp float u_size_t;uniform highp float u_size;uniform mat4 u_matrix;uniform mat4 u_inv_matrix;uniform mat4 u_label_plane_matrix;uniform mat4 u_coord_matrix;uniform bool u_is_text;uniform bool u_elevation_from_sea;uniform bool u_pitch_with_map;uniform bool u_rotate_symbol;uniform highp float u_aspect_ratio;uniform highp float u_camera_to_center_distance;uniform float u_fade_change;uniform vec2 u_texsize;uniform vec3 u_up_vector;uniform vec2 u_texsize_icon;uniform bool u_is_halo;\n#ifdef PROJECTION_GLOBE_VIEW\nuniform vec3 u_tile_id;uniform mat4 u_inv_rot_matrix;uniform vec2 u_merc_center;uniform vec3 u_camera_forward;uniform float u_zoom_transition;uniform vec3 u_ecef_origin;uniform mat4 u_tile_matrix;\n#endif\nout vec2 v_tex_a;\n#ifdef ICON_TRANSITION\nout vec2 v_tex_b;\n#endif\nout float v_draw_halo;out vec3 v_gamma_scale_size_fade_opacity;\n#ifdef RENDER_TEXT_AND_SYMBOL\nout float is_sdf;out vec2 v_tex_a_icon;\n#endif\n#ifdef Z_OFFSET\n#ifdef RENDER_SHADOWS\nuniform mat4 u_light_matrix_0;uniform mat4 u_light_matrix_1;out highp vec4 v_pos_light_view_0;out highp vec4 v_pos_light_view_1;out highp float v_depth;\n#endif\n#endif\n#pragma mapbox: define highp vec4 fill_color\n#pragma mapbox: define highp vec4 halo_color\n#pragma mapbox: define lowp float opacity\n#pragma mapbox: define lowp float halo_width\n#pragma mapbox: define lowp float halo_blur\n#pragma mapbox: define lowp float emissive_strength\n#pragma mapbox: define lowp float occlusion_opacity\n#pragma mapbox: define lowp float z_offset\nvoid main() {\n#pragma mapbox: initialize highp vec4 fill_color\n#pragma mapbox: initialize highp vec4 halo_color\n#pragma mapbox: initialize lowp float opacity\n#pragma mapbox: initialize lowp float halo_width\n#pragma mapbox: initialize lowp float halo_blur\n#pragma mapbox: initialize lowp float emissive_strength\n#pragma mapbox: initialize lowp float occlusion_opacity\n#pragma mapbox: initialize lowp float z_offset\nvec2 a_pos=a_pos_offset.xy;vec2 a_offset=a_pos_offset.zw;vec2 a_tex=a_tex_size.xy;vec2 a_size=a_tex_size.zw;float a_size_min=floor(a_size[0]*0.5);vec2 a_pxoffset=a_pixeloffset.xy;vec2 a_min_font_scale=a_pixeloffset.zw/256.0;highp float segment_angle=-a_projected_pos[3];float size;if (!u_is_size_zoom_constant && !u_is_size_feature_constant) {size=mix(a_size_min,a_size[1],u_size_t)/128.0;} else if (u_is_size_zoom_constant && !u_is_size_feature_constant) {size=a_size_min/128.0;} else {size=u_size;}vec2 tile_anchor=a_pos;float e=u_elevation_from_sea ? z_offset : z_offset+elevation(tile_anchor);\n#ifdef Z_OFFSET\ne+=a_auto_z_offset;\n#endif\nvec3 h=elevationVector(tile_anchor)*e;float globe_occlusion_fade;vec3 world_pos;vec3 mercator_pos;vec3 world_pos_globe;\n#ifdef PROJECTION_GLOBE_VIEW\nmercator_pos=mercator_tile_position(u_inv_rot_matrix,tile_anchor,u_tile_id,u_merc_center);world_pos_globe=a_globe_anchor+h;world_pos=mix_globe_mercator(world_pos_globe,mercator_pos,u_zoom_transition);vec4 ecef_point=u_tile_matrix*vec4(world_pos,1.0);vec3 origin_to_point=ecef_point.xyz-u_ecef_origin;globe_occlusion_fade=dot(origin_to_point,u_camera_forward) >=0.0 ? 0.0 : 1.0;\n#else\nworld_pos=vec3(tile_anchor,0)+h;globe_occlusion_fade=1.0;\n#endif\nvec4 projected_point=u_matrix*vec4(world_pos,1);highp float camera_to_anchor_distance=projected_point.w;highp float distance_ratio=u_pitch_with_map ?\ncamera_to_anchor_distance/u_camera_to_center_distance :\nu_camera_to_center_distance/camera_to_anchor_distance;highp float perspective_ratio=clamp(\n0.5+0.5*distance_ratio,0.0,1.5);size*=perspective_ratio;float font_scale=u_is_text ? size/24.0 : size;highp float symbol_rotation=0.0;if (u_rotate_symbol) {vec4 offsetprojected_point;vec2 a;\n#ifdef PROJECTION_GLOBE_VIEW\nvec3 displacement=vec3(a_globe_normal.z,0,-a_globe_normal.x);offsetprojected_point=u_matrix*vec4(a_globe_anchor+displacement,1);vec4 projected_point_globe=u_matrix*vec4(world_pos_globe,1);a=projected_point_globe.xy/projected_point_globe.w;\n#else\noffsetprojected_point=u_matrix*vec4(tile_anchor+vec2(1,0),0,1);a=projected_point.xy/projected_point.w;\n#endif\nvec2 b=offsetprojected_point.xy/offsetprojected_point.w;symbol_rotation=atan((b.y-a.y)/u_aspect_ratio,b.x-a.x);}vec4 projected_pos;\n#ifdef PROJECTION_GLOBE_VIEW\n#ifdef PROJECTED_POS_ON_VIEWPORT\nprojected_pos=u_label_plane_matrix*vec4(a_projected_pos.xyz+h,1.0);\n#else\nvec3 proj_pos=mix_globe_mercator(a_projected_pos.xyz,mercator_pos,u_zoom_transition)+h;projected_pos=u_label_plane_matrix*vec4(proj_pos,1.0);    \n#endif\n#else\nprojected_pos=u_label_plane_matrix*vec4(a_projected_pos.xy,h.z,1.0);\n#endif\nhighp float angle_sin=sin(segment_angle+symbol_rotation);highp float angle_cos=cos(segment_angle+symbol_rotation);mat2 rotation_matrix=mat2(angle_cos,-1.0*angle_sin,angle_sin,angle_cos);float z=0.0;vec2 offset=rotation_matrix*(a_offset/32.0*max(a_min_font_scale,font_scale)+a_pxoffset/16.0);\n#ifdef TERRAIN\n#ifdef PITCH_WITH_MAP_TERRAIN\nvec4 tile_pos=u_label_plane_matrix_inv*vec4(a_projected_pos.xy+offset,0.0,1.0);z=elevation(tile_pos.xy);\n#endif\n#endif\n#ifdef Z_OFFSET\nz+=u_pitch_with_map ? a_auto_z_offset+z_offset : 0.0;\n#else\nz+=u_pitch_with_map ? z_offset : 0.0;\n#endif\nfloat occlusion_fade=globe_occlusion_fade;vec2 fade_opacity=unpack_opacity(a_fade_opacity);float fade_change=fade_opacity[1] > 0.5 ? u_fade_change :-u_fade_change;float out_fade_opacity=max(0.0,min(occlusion_fade,fade_opacity[0]+fade_change));\n#ifdef DEPTH_OCCLUSION\nfloat depth_occlusion=occlusionFadeMultiSample(projected_point);float depth_occlusion_multplier=mix(occlusion_opacity,1.0,depth_occlusion);out_fade_opacity*=depth_occlusion_multplier;\n#endif\n#ifdef OCCLUSION_QUERIES\nfloat occludedFadeMultiplier=mix(occlusion_opacity,1.0,a_occlusion_query_opacity);out_fade_opacity*=occludedFadeMultiplier;\n#endif\nfloat alpha=opacity*out_fade_opacity;float hidden=float(alpha==0.0 || projected_point.w <=0.0 || occlusion_fade==0.0);vec3 pos;\n#ifdef PROJECTION_GLOBE_VIEW\nvec3 xAxis=u_pitch_with_map ? normalize(cross(a_globe_normal,u_up_vector)) : vec3(1,0,0);vec3 yAxis=u_pitch_with_map ? normalize(cross(a_globe_normal,xAxis)) : vec3(0,1,0);pos=projected_pos.xyz/projected_pos.w+xAxis*offset.x+yAxis*offset.y;\n#else\n#ifdef ELEVATED_ROADS\nvec3 xAxis=vec3(a_x_axis.xy,a_x_axis.z*u_normal_scale);vec3 yAxis=vec3(a_y_axis.xy,a_y_axis.z*u_normal_scale);pos=projected_pos.xyz/projected_pos.w+xAxis*offset.x+yAxis*offset.y;\n#else\npos=vec3(projected_pos.xy/projected_pos.w+offset,z);\n#endif\n#endif\ngl_Position=mix(u_coord_matrix*vec4(pos,1.0),AWAY,hidden);float gamma_scale=gl_Position.w;v_draw_halo=(u_is_halo && float(gl_InstanceID)==0.0) ? 1.0 : 0.0;v_gamma_scale_size_fade_opacity=vec3(gamma_scale,size,out_fade_opacity);v_tex_a=a_tex/u_texsize;\n#ifdef RENDER_TEXT_AND_SYMBOL\nis_sdf=a_size[0]-2.0*a_size_min;v_tex_a_icon=a_tex/u_texsize_icon;\n#endif\n#ifdef ICON_TRANSITION\nv_tex_b=a_texb/u_texsize;\n#endif\n#ifdef Z_OFFSET\n#ifdef RENDER_SHADOWS\nvec4 shd_pos=u_inv_matrix*vec4(pos,1.0);vec3 shd_pos0=shd_pos.xyz;vec3 shd_pos1=shd_pos.xyz;\n#ifdef NORMAL_OFFSET\nvec3 shd_pos_offset=shadow_normal_offset(vec3(0.0,0.0,1.0));shd_pos0+=shd_pos_offset*shadow_normal_offset_multiplier0();shd_pos1+=shd_pos_offset*shadow_normal_offset_multiplier1();\n#endif\nv_pos_light_view_0=u_light_matrix_0*vec4(shd_pos0,1);v_pos_light_view_1=u_light_matrix_1*vec4(shd_pos1,1);v_depth=gl_Position.w;\n#endif\n#endif\n#ifdef INDICATOR_CUTOUT\nv_z_offset=e;\n#else\n#ifdef Z_OFFSET\n#ifdef RENDER_SHADOWS\nv_z_offset=e;\n#endif\n#endif\n#endif\n}'), terrainRaster: Go('#include "_prelude_fog.fragment.glsl"\n#include "_prelude_shadow.fragment.glsl"\n#include "_prelude_lighting.glsl"\nuniform sampler2D u_image0;in vec2 v_pos0;\n#ifdef FOG\nin float v_fog_opacity;\n#endif\n#ifdef RENDER_SHADOWS\nin vec4 v_pos_light_view_0;in vec4 v_pos_light_view_1;\n#endif\nuniform vec3 u_ground_shadow_factor;void main() {vec4 image_color=texture(u_image0,v_pos0);vec4 color;\n#ifdef LIGHTING_3D_MODE\nconst vec3 normal=vec3(0.0,0.0,1.0);\n#ifdef RENDER_SHADOWS\nfloat cutoffOpacity=1.0;\n#ifdef RENDER_CUTOFF\ncutoffOpacity=cutoff_opacity(u_cutoff_params,1.0/gl_FragCoord.w);\n#endif\n#ifdef LIGHTING_3D_ALPHA_EMISSIVENESS\nvec3 unlit_base=image_color.rgb*(1.0-image_color.a);vec3 emissive_base=image_color.rgb*image_color.a;float ndotl=u_shadow_direction.z;float occlusion=ndotl < 0.0 ? 1.0 : shadow_occlusion(v_pos_light_view_0,v_pos_light_view_1,1.0/gl_FragCoord.w,0.0);ndotl=max(0.0,ndotl);vec3 lit=apply_lighting(unlit_base,normal,mix(1.0,(1.0-(u_shadow_intensity*occlusion))*ndotl,cutoffOpacity));vec3 emissive=compute_emissive_draped(emissive_base,1.0-u_shadow_intensity,occlusion,u_ground_shadow_factor);color.rgb=lit+emissive;color.a=1.0;\n#else\nfloat lighting_factor=shadowed_light_factor_normal_unbiased(normal,v_pos_light_view_0,v_pos_light_view_1,1.0/gl_FragCoord.w);color=apply_lighting(image_color,normal,mix(1.0,lighting_factor,cutoffOpacity));\n#endif\n#else\nfloat lighting_factor=u_lighting_directional_dir.z;color=apply_lighting(image_color,normal,lighting_factor);\n#ifdef LIGHTING_3D_ALPHA_EMISSIVENESS\ncolor.rgb=mix(color.rgb,image_color.rgb,image_color.a);color.a=1.0;\n#endif\n#endif\n#else\ncolor=image_color;\n#endif\n#ifdef FOG\n#ifdef ZERO_EXAGGERATION\ncolor=fog_dither(fog_apply_premultiplied(color,v_fog_pos));\n#else\ncolor=fog_dither(fog_apply_from_vert(color,v_fog_opacity));\n#endif\n#endif\nglFragColor=color;\n#ifdef OVERDRAW_INSPECTOR\nglFragColor=vec4(1.0);\n#endif\nHANDLE_WIREFRAME_DEBUG;}', '#include "_prelude_fog.vertex.glsl"\n#include "_prelude_terrain.vertex.glsl"\nuniform mat4 u_matrix;uniform float u_skirt_height;in vec2 a_pos;out vec2 v_pos0;\n#ifdef FOG\nout float v_fog_opacity;\n#endif\n#ifdef RENDER_SHADOWS\nuniform mat4 u_light_matrix_0;uniform mat4 u_light_matrix_1;out vec4 v_pos_light_view_0;out vec4 v_pos_light_view_1;out float v_depth;\n#endif\nvoid main() {vec3 decomposedPosAndSkirt=decomposeToPosAndSkirt(a_pos);float skirt=decomposedPosAndSkirt.z;vec2 decodedPos=decomposedPosAndSkirt.xy;float elevation=elevation(decodedPos)-skirt*u_skirt_height;v_pos0=decodedPos/8192.0;gl_Position=u_matrix*vec4(decodedPos,elevation,1.0);\n#ifdef FOG\n#ifdef ZERO_EXAGGERATION\nv_fog_pos=fog_position(decodedPos);\n#else\nv_fog_opacity=fog(fog_position(vec3(decodedPos,elevation)));\n#endif\n#endif\n#ifdef RENDER_SHADOWS\nvec3 pos=vec3(decodedPos,elevation);v_pos_light_view_0=u_light_matrix_0*vec4(pos,1.);v_pos_light_view_1=u_light_matrix_1*vec4(pos,1.);\n#endif\n}'), terrainDepth: Go("precision highp float;in float v_depth;void main() {glFragColor=pack_depth(v_depth);}", '#include "_prelude_terrain.vertex.glsl"\nuniform mat4 u_matrix;in vec2 a_pos;out float v_depth;void main() {float elevation=elevation(a_pos);gl_Position=u_matrix*vec4(a_pos,elevation,1.0);v_depth=gl_Position.z/gl_Position.w;}'), skybox: Go('#include "_prelude_fog.fragment.glsl"\nin lowp vec3 v_uv;uniform lowp samplerCube u_cubemap;uniform lowp float u_opacity;uniform highp float u_temporal_offset;uniform highp vec3 u_sun_direction;float sun_disk(highp vec3 ray_direction,highp vec3 sun_direction) {highp float cos_angle=dot(normalize(ray_direction),sun_direction);const highp float cos_sun_angular_diameter=0.99996192306;const highp float smoothstep_delta=1e-5;return smoothstep(\ncos_sun_angular_diameter-smoothstep_delta,cos_sun_angular_diameter+smoothstep_delta,cos_angle);}float map(float value,float start,float end,float new_start,float new_end) {return ((value-start)*(new_end-new_start))/(end-start)+new_start;}void main() {vec3 uv=v_uv;const float y_bias=0.015;uv.y+=y_bias;uv.y=pow(abs(uv.y),1.0/5.0);uv.y=map(uv.y,0.0,1.0,-1.0,1.0);vec3 sky_color=texture(u_cubemap,uv).rgb;\n#ifdef FOG\nsky_color=fog_apply_sky_gradient(v_uv.xzy,sky_color);\n#endif\nsky_color+=0.1*sun_disk(v_uv,u_sun_direction);glFragColor=vec4(sky_color*u_opacity,u_opacity);\n#ifdef OVERDRAW_INSPECTOR\nglFragColor=vec4(1.0);\n#endif\n}', Ro), skyboxGradient: Go('#include "_prelude_fog.fragment.glsl"\nin highp vec3 v_uv;uniform lowp sampler2D u_color_ramp;uniform highp vec3 u_center_direction;uniform lowp float u_radius;uniform lowp float u_opacity;uniform highp float u_temporal_offset;void main() {float progress=acos(dot(normalize(v_uv),u_center_direction))/u_radius;vec4 color=texture(u_color_ramp,vec2(progress,0.5));\n#ifdef FOG\ncolor.rgb=fog_apply_sky_gradient(v_uv.xzy,color.rgb/color.a)*color.a;\n#endif\ncolor*=u_opacity;glFragColor=color;\n#ifdef OVERDRAW_INSPECTOR\nglFragColor=vec4(1.0);\n#endif\n}', Ro), skyboxCapture: Go("\nin highp vec3 v_position;uniform highp float u_sun_intensity;uniform highp float u_luminance;uniform lowp vec3 u_sun_direction;uniform highp vec4 u_color_tint_r;uniform highp vec4 u_color_tint_m;precision highp float;\n#define BETA_R                  vec3(5.5e-6,13.0e-6,22.4e-6)\n#define BETA_M                  vec3(21e-6,21e-6,21e-6)\n#define MIE_G                   0.76\n#define DENSITY_HEIGHT_SCALE_R  8000.0\n#define DENSITY_HEIGHT_SCALE_M  1200.0\n#define PLANET_RADIUS           6360e3\n#define ATMOSPHERE_RADIUS       6420e3\n#define SAMPLE_STEPS            10\n#define DENSITY_STEPS           4\nfloat ray_sphere_exit(vec3 orig,vec3 dir,float radius) {float a=dot(dir,dir);float b=2.0*dot(dir,orig);float c=dot(orig,orig)-radius*radius;float d=sqrt(b*b-4.0*a*c);return (-b+d)/(2.0*a);}vec3 extinction(vec2 density) {return exp(-vec3(BETA_R*u_color_tint_r.a*density.x+BETA_M*u_color_tint_m.a*density.y));}vec2 local_density(vec3 point) {float height=max(length(point)-PLANET_RADIUS,0.0);float exp_r=exp(-height/DENSITY_HEIGHT_SCALE_R);float exp_m=exp(-height/DENSITY_HEIGHT_SCALE_M);return vec2(exp_r,exp_m);}float phase_ray(float cos_angle) {return (3.0/(16.0*PI))*(1.0+cos_angle*cos_angle);}float phase_mie(float cos_angle) {return (3.0/(8.0*PI))*((1.0-MIE_G*MIE_G)*(1.0+cos_angle*cos_angle))/((2.0+MIE_G*MIE_G)*pow(1.0+MIE_G*MIE_G-2.0*MIE_G*cos_angle,1.5));}vec2 density_to_atmosphere(vec3 point,vec3 light_dir) {float ray_len=ray_sphere_exit(point,light_dir,ATMOSPHERE_RADIUS);float step_len=ray_len/float(DENSITY_STEPS);vec2 density_point_to_atmosphere=vec2(0.0);for (int i=0; i < DENSITY_STEPS;++i) {vec3 point_on_ray=point+light_dir*((float(i)+0.5)*step_len);density_point_to_atmosphere+=local_density(point_on_ray)*step_len;;}return density_point_to_atmosphere;}vec3 atmosphere(vec3 ray_dir,vec3 sun_direction,float sun_intensity) {vec2 density_orig_to_point=vec2(0.0);vec3 scatter_r=vec3(0.0);vec3 scatter_m=vec3(0.0);vec3 origin=vec3(0.0,PLANET_RADIUS,0.0);float ray_len=ray_sphere_exit(origin,ray_dir,ATMOSPHERE_RADIUS);float step_len=ray_len/float(SAMPLE_STEPS);for (int i=0; i < SAMPLE_STEPS;++i) {vec3 point_on_ray=origin+ray_dir*((float(i)+0.5)*step_len);vec2 density=local_density(point_on_ray)*step_len;density_orig_to_point+=density;vec2 density_point_to_atmosphere=density_to_atmosphere(point_on_ray,sun_direction);vec2 density_orig_to_atmosphere=density_orig_to_point+density_point_to_atmosphere;vec3 extinction=extinction(density_orig_to_atmosphere);scatter_r+=density.x*extinction;scatter_m+=density.y*extinction;}float cos_angle=dot(ray_dir,sun_direction);float phase_r=phase_ray(cos_angle);float phase_m=phase_mie(cos_angle);vec3 beta_r=BETA_R*u_color_tint_r.rgb*u_color_tint_r.a;vec3 beta_m=BETA_M*u_color_tint_m.rgb*u_color_tint_m.a;return (scatter_r*phase_r*beta_r+scatter_m*phase_m*beta_m)*sun_intensity;}const float A=0.15;const float B=0.50;const float C=0.10;const float D=0.20;const float E=0.02;const float F=0.30;vec3 uncharted2_tonemap(vec3 x) {return ((x*(A*x+C*B)+D*E)/(x*(A*x+B)+D*F))-E/F;}void main() {vec3 ray_direction=v_position;ray_direction.y=pow(ray_direction.y,5.0);const float y_bias=0.015;ray_direction.y+=y_bias;vec3 color=atmosphere(normalize(ray_direction),u_sun_direction,u_sun_intensity);float white_scale=1.0748724675633854;color=uncharted2_tonemap((log2(2.0/pow(u_luminance,4.0)))*color)*white_scale;glFragColor=vec4(color,1.0);}", "in highp vec3 a_pos_3f;uniform mat3 u_matrix_3f;out highp vec3 v_position;float map(float value,float start,float end,float new_start,float new_end) {return ((value-start)*(new_end-new_start))/(end-start)+new_start;}void main() {vec4 pos=vec4(u_matrix_3f*a_pos_3f,1.0);v_position=pos.xyz;v_position.y*=-1.0;v_position.y=map(v_position.y,-1.0,1.0,0.0,1.0);gl_Position=vec4(a_pos_3f.xy,0.0,1.0);}"), globeRaster: Go('#include "_prelude_fog.fragment.glsl"\n#include "_prelude_lighting.glsl"\nuniform sampler2D u_image0;uniform float u_far_z_cutoff;in vec2 v_pos0;\n#ifndef FOG\nuniform highp vec3 u_frustum_tl;uniform highp vec3 u_frustum_tr;uniform highp vec3 u_frustum_br;uniform highp vec3 u_frustum_bl;uniform highp vec3 u_globe_pos;uniform highp float u_globe_radius;uniform vec2 u_viewport;\n#endif\nvoid main() {vec4 color;\n#ifdef CUSTOM_ANTIALIASING\nhighp vec2 uv=gl_FragCoord.xy/u_viewport;highp vec3 ray_dir=mix(\nmix(u_frustum_tl,u_frustum_tr,uv.x),mix(u_frustum_bl,u_frustum_br,uv.x),1.0-uv.y);highp vec3 dir=normalize(ray_dir);highp vec3 closest_point=dot(u_globe_pos,dir)*dir;highp float norm_dist_from_center=1.0-length(closest_point-u_globe_pos)/u_globe_radius;const float antialias_pixel=2.0;highp float antialias_factor=antialias_pixel*fwidth(norm_dist_from_center);highp float antialias=smoothstep(0.0,antialias_factor,norm_dist_from_center);vec4 raster=texture(u_image0,v_pos0);\n#ifdef LIGHTING_3D_MODE\n#ifdef LIGHTING_3D_ALPHA_EMISSIVENESS\nraster=apply_lighting_with_emission_ground(raster,raster.a);color=vec4(clamp(raster.rgb,vec3(0),vec3(1))*antialias,antialias);\n#else\nraster=apply_lighting_ground(raster);color=vec4(raster.rgb*antialias,raster.a*antialias);\n#endif\n#else\ncolor=vec4(raster.rgb*antialias,raster.a*antialias);\n#endif\n#else\ncolor=texture(u_image0,v_pos0);\n#ifdef LIGHTING_3D_MODE\n#ifdef LIGHTING_3D_ALPHA_EMISSIVENESS\ncolor=apply_lighting_with_emission_ground(color,color.a);color.a=1.0;\n#else\ncolor=apply_lighting_ground(color);\n#endif\n#endif\n#endif\n#ifdef FOG\ncolor=fog_dither(fog_apply_premultiplied(color,v_fog_pos));\n#endif\ncolor*=1.0-step(u_far_z_cutoff,1.0/gl_FragCoord.w);glFragColor=color;\n#ifdef OVERDRAW_INSPECTOR\nglFragColor=vec4(1.0);\n#endif\nHANDLE_WIREFRAME_DEBUG;}', '#include "_prelude_fog.vertex.glsl"\n#include "_prelude_terrain.vertex.glsl"\nuniform mat4 u_proj_matrix;uniform mat4 u_normalize_matrix;uniform mat4 u_globe_matrix;uniform mat4 u_merc_matrix;uniform float u_zoom_transition;uniform vec2 u_merc_center;uniform mat3 u_grid_matrix;uniform float u_skirt_height;\n#ifdef GLOBE_POLES\nin vec3 a_globe_pos;in vec2 a_uv;\n#else\nin vec2 a_pos;\n#endif\nout vec2 v_pos0;void main() {\n#ifdef GLOBE_POLES\nvec3 globe_pos=a_globe_pos;vec2 uv=a_uv;\n#else\nfloat tiles=u_grid_matrix[0][2];float idx=u_grid_matrix[1][2];float idy=u_grid_matrix[2][2];vec3 decomposed_pos_and_skirt=decomposeToPosAndSkirt(a_pos);vec3 latLng=u_grid_matrix*vec3(decomposed_pos_and_skirt.xy,1.0);float mercatorY=mercatorYfromLat(latLng[0]);float uvY=mercatorY*tiles-idy;float mercatorX=mercatorXfromLng(latLng[1]);float uvX=mercatorX*tiles-idx;vec3 globe_pos=latLngToECEF(latLng.xy);vec2 merc_pos=vec2(mercatorX,mercatorY);vec2 uv=vec2(uvX,uvY);\n#endif\nv_pos0=uv;vec2 tile_pos=uv*EXTENT;vec3 globe_derived_up_vector=normalize(globe_pos)*u_tile_up_scale;\n#ifdef GLOBE_POLES\nvec3 up_vector=globe_derived_up_vector;\n#else\nvec3 up_vector=elevationVector(tile_pos);\n#endif\nfloat height=elevation(tile_pos);globe_pos+=up_vector*height;\n#ifndef GLOBE_POLES\nglobe_pos-=globe_derived_up_vector*u_skirt_height*decomposed_pos_and_skirt.z;\n#endif\n#ifdef GLOBE_POLES\nvec4 interpolated_pos=u_globe_matrix*vec4(globe_pos,1.0);\n#else\nvec4 globe_world_pos=u_globe_matrix*vec4(globe_pos,1.0);vec4 merc_world_pos=vec4(0.0);if (u_zoom_transition > 0.0) {merc_world_pos=vec4(merc_pos,height-u_skirt_height*decomposed_pos_and_skirt.z,1.0);merc_world_pos.xy-=u_merc_center;merc_world_pos.x=wrap(merc_world_pos.x,-0.5,0.5);merc_world_pos=u_merc_matrix*merc_world_pos;}vec4 interpolated_pos=vec4(mix(globe_world_pos.xyz,merc_world_pos.xyz,u_zoom_transition),1.0);\n#endif\ngl_Position=u_proj_matrix*interpolated_pos;\n#ifdef FOG\nv_fog_pos=fog_position((u_normalize_matrix*vec4(globe_pos,1.0)).xyz);\n#endif\n}'), globeAtmosphere: Go('#include "_prelude_fog.fragment.glsl"\nuniform float u_transition;uniform highp float u_fadeout_range;uniform highp float u_temporal_offset;uniform vec4 u_color;uniform vec4 u_high_color;uniform vec4 u_space_color;uniform float u_horizon_angle;in highp vec3 v_ray_dir;in highp vec3 v_horizon_dir;void main() {highp vec3 dir=normalize(v_ray_dir);float globe_pos_dot_dir;\n#ifdef PROJECTION_GLOBE_VIEW\nglobe_pos_dot_dir=dot(u_globe_pos,dir);highp vec3 closest_point_forward=abs(globe_pos_dot_dir)*dir;float norm_dist_from_center=length(closest_point_forward-u_globe_pos)/u_globe_radius;if (norm_dist_from_center < 0.98) {\n#ifdef ALPHA_PASS\nglFragColor=vec4(0,0,0,0);return;\n#else\n#ifdef NATIVE\nglFragColor=vec4(1,1,1,1);\n#else\nglFragColor=vec4(0,0,0,1);\n#endif\nreturn;\n#endif\n}\n#endif\nhighp vec3 horizon_dir=normalize(v_horizon_dir);float horizon_angle_mercator=dir.y < horizon_dir.y ?\n0.0 : max(acos(clamp(dot(dir,horizon_dir),-1.0,1.0)),0.0);float horizon_angle;\n#ifdef PROJECTION_GLOBE_VIEW\nhighp vec3 closest_point=globe_pos_dot_dir*dir;highp float closest_point_to_center=length(closest_point-u_globe_pos);highp float theta=asin(clamp(closest_point_to_center/length(u_globe_pos),-1.0,1.0));horizon_angle=globe_pos_dot_dir < 0.0 ?\nPI-theta-u_horizon_angle : theta-u_horizon_angle;float angle_t=pow(u_transition,10.0);horizon_angle=mix(horizon_angle,horizon_angle_mercator,angle_t);\n#else\nhorizon_angle=horizon_angle_mercator;\n#endif\nhorizon_angle/=PI;float t=exp(-horizon_angle/u_fadeout_range);float alpha_0=u_color.a;float alpha_1=u_high_color.a;float alpha_2=u_space_color.a;vec3 color_stop_0=u_color.rgb;vec3 color_stop_1=u_high_color.rgb;vec3 color_stop_2=u_space_color.rgb;\n#ifdef ALPHA_PASS\nfloat a0=mix(alpha_2,1.0,alpha_1);float a1=mix(a0,1.0,alpha_0);float a2=mix(a0,a1,t);float a =mix(alpha_2,a2,t);glFragColor=vec4(1.0,1.0,1.0,a);\n#else\nvec3 c0=mix(color_stop_2,color_stop_1,alpha_1);vec3 c1=mix(c0,color_stop_0,alpha_0);vec3 c2=mix(c0,c1,t);vec3 c=c2;glFragColor=vec4(c*t,t);\n#endif\n}', "in vec3 a_pos;in vec2 a_uv;uniform vec3 u_frustum_tl;uniform vec3 u_frustum_tr;uniform vec3 u_frustum_br;uniform vec3 u_frustum_bl;uniform float u_horizon;out highp vec3 v_ray_dir;out highp vec3 v_horizon_dir;void main() {v_ray_dir=mix(\nmix(u_frustum_tl,u_frustum_tr,a_uv.x),mix(u_frustum_bl,u_frustum_br,a_uv.x),a_uv.y);v_horizon_dir=mix(\nmix(u_frustum_tl,u_frustum_bl,u_horizon),mix(u_frustum_tr,u_frustum_br,u_horizon),a_uv.x);gl_Position=vec4(a_pos,1.0);}"), model: Go('#include "_prelude_fog.fragment.glsl"\n#include "_prelude_shadow.fragment.glsl"\n#include "_prelude_lighting.glsl"\nuniform float u_opacity;uniform vec3 u_lightcolor;uniform vec3 u_lightpos;uniform float u_lightintensity;uniform vec4 u_baseColorFactor;uniform vec4 u_emissiveFactor;uniform float u_metallicFactor;uniform float u_roughnessFactor;uniform float u_emissive_strength;in highp vec4 v_position_height;in lowp vec4 v_color_mix;\n#ifdef RENDER_SHADOWS\nin highp vec4 v_pos_light_view_0;in highp vec4 v_pos_light_view_1;in float v_depth_shadows;\n#endif\n#ifdef OCCLUSION_TEXTURE_TRANSFORM\nuniform vec4 u_occlusionTextureTransform;\n#endif\n#pragma mapbox: define-attribute highp vec3 normal_3f\n#pragma mapbox: define-attribute highp vec3 color_3f\n#pragma mapbox: define-attribute highp vec4 color_4f\n#pragma mapbox: define-attribute highp vec2 uv_2f\n#pragma mapbox: initialize-attribute highp vec3 normal_3f\n#pragma mapbox: initialize-attribute highp vec3 color_3f\n#pragma mapbox: initialize-attribute highp vec4 color_4f\n#pragma mapbox: initialize-attribute highp vec2 uv_2f\n#ifdef HAS_ATTRIBUTE_a_pbr\nin lowp vec4 v_roughness_metallic_emissive_alpha;in mediump vec4 v_height_based_emission_params;\n#endif\n#ifdef HAS_TEXTURE_u_baseColorTexture\nuniform sampler2D u_baseColorTexture;uniform bool u_baseTextureIsAlpha;uniform bool u_alphaMask;uniform float u_alphaCutoff;\n#endif\n#ifdef HAS_TEXTURE_u_metallicRoughnessTexture\nuniform sampler2D u_metallicRoughnessTexture;\n#endif\n#ifdef HAS_TEXTURE_u_occlusionTexture\nuniform sampler2D u_occlusionTexture;uniform float u_aoIntensity;\n#endif\n#ifdef HAS_TEXTURE_u_normalTexture\nuniform sampler2D u_normalTexture;\n#endif\n#ifdef HAS_TEXTURE_u_emissionTexture\nuniform sampler2D u_emissionTexture;\n#endif\n#ifdef APPLY_LUT_ON_GPU\nuniform highp sampler3D u_lutTexture;\n#endif\n#ifdef TERRAIN_FRAGMENT_OCCLUSION\nin highp float v_depth;uniform highp sampler2D u_depthTexture;uniform highp vec2 u_inv_depth_size;uniform highp vec2 u_depth_range_unpack;\n#ifdef DEPTH_D24\nhighp float unpack_depth(highp float depth) {return  depth*u_depth_range_unpack.x+u_depth_range_unpack.y;}\n#else\nhighp float unpack_depth_rgba(highp vec4 rgba_depth)\n{const highp vec4 bit_shift=vec4(1.0/(255.0*255.0*255.0),1.0/(255.0*255.0),1.0/255.0,1.0);return dot(rgba_depth,bit_shift)*2.0-1.0;}\n#endif\nbool isOccluded() {highp vec2 coord=gl_FragCoord.xy*u_inv_depth_size;\n#ifdef DEPTH_D24\nhighp float depth=unpack_depth(texture(u_depthTexture,coord).r);\n#else\nhighp float depth=unpack_depth_rgba(texture(u_depthTexture,coord));\n#endif\nreturn v_depth > depth+0.0005;}\n#endif\n#define saturate(_x) clamp(_x,0.,1.)\nvec3 linearTosRGB(vec3 color) {return pow(color,vec3(1./2.2));}vec3 sRGBToLinear(vec3 srgbIn) {return pow(srgbIn,vec3(2.2));}float calculate_NdotL(vec3 normal,vec3 lightDir) {const float ext=0.70710678118;return (clamp(dot(normal,lightDir),-ext,1.0)+ext)/(1.0+ext);}vec3 getDiffuseShadedColor(vec3 albedo,vec3 normal,vec3 lightDir,vec3 lightColor)\n{\n#ifdef LIGHTING_3D_MODE\nvec3 transformed_normal=vec3(-normal.xy,normal.z);float lighting_factor;\n#ifdef RENDER_SHADOWS\nlighting_factor=shadowed_light_factor_normal(transformed_normal,v_pos_light_view_0,v_pos_light_view_1,v_depth_shadows);\n#else\nlighting_factor=saturate(dot(transformed_normal,u_lighting_directional_dir));\n#endif\nreturn apply_lighting(albedo,transformed_normal,lighting_factor);\n#else\nvec3 n=normal;float colorvalue=((albedo.x*0.2126)+(albedo.y*0.7152))+(albedo.z*0.0722);vec3 c=vec3(0.03,0.03,0.03);float directional=clamp(dot(n,vec3(lightDir)),0.0,1.0);directional=mix(1.0-u_lightintensity,max((1.0-colorvalue)+u_lightintensity,1.0),directional);vec3 c3=c+clamp((albedo*directional)*lightColor,mix(vec3(0.0),vec3(0.3),vec3(1.0)-lightColor),vec3(1.0));return c3;\n#endif\n}vec4 getBaseColor() {vec4 albedo=u_baseColorFactor;\n#ifdef HAS_ATTRIBUTE_a_color_3f\nalbedo*=vec4(color_3f,1.0);\n#endif\n#ifdef HAS_ATTRIBUTE_a_pbr\n#else\n#ifdef HAS_ATTRIBUTE_a_color_4f\nalbedo*=color_4f;\n#endif\n#endif\n#if defined (HAS_TEXTURE_u_baseColorTexture) && defined (HAS_ATTRIBUTE_a_uv_2f)\nvec4 texColor=texture(u_baseColorTexture,uv_2f);if(u_alphaMask) {if (texColor.w < u_alphaCutoff) {discard;}}\n#ifdef UNPREMULT_TEXTURE_IN_SHADER\nif(texColor.w > 0.0) {texColor.rgb/=texColor.w;}texColor.w=1.0;\n#endif\nif(u_baseTextureIsAlpha) {if (texColor.r < 0.5) {discard;}} else {texColor.rgb=sRGBToLinear(texColor.rgb);albedo*=texColor;}\n#endif\nvec4 color=vec4(mix(albedo.rgb,v_color_mix.rgb,v_color_mix.a),albedo.a);\n#ifdef APPLY_LUT_ON_GPU\ncolor=applyLUT(u_lutTexture,color);\n#endif\nreturn color;}highp mat3 cotangentFrame(highp vec3 N,highp vec3 p,highp vec2 uv ) {\n#ifdef HAS_TEXTURE_u_normalTexture\nhighp vec3 dp1=vec3(dFdx(p.x),dFdx(p.y),dFdx(p.z));highp vec3 dp2=vec3(dFdy(p.x),dFdy(p.y),dFdy(p.z));highp vec2 duv1=vec2(dFdx(uv.x),dFdx(uv.y));highp vec2 duv2=vec2(dFdy(uv.x),dFdy(uv.y));highp vec3 dp2perp=cross( dp2,N );highp vec3 dp1perp=cross( N,dp1 );highp vec3 T=dp2perp*duv1.x+dp1perp*duv2.x;highp vec3 B=dp2perp*duv1.y+dp1perp*duv2.y;highp float lengthT=dot(T,T);highp float lengthB=dot(B,B);highp float maxLength=max(lengthT,lengthB);highp float invmax=inversesqrt( maxLength );highp mat3 res=mat3( T*invmax,B*invmax,N );return res;\n#else\nreturn mat3(1.0);\n#endif\n}highp vec3 getNormal(){highp vec3 n;\n#ifdef HAS_ATTRIBUTE_a_normal_3f\nn=normalize(normal_3f);\n#else\nhighp vec3 fdx=vec3(dFdx(v_position_height.x),dFdx(v_position_height.y),dFdx(v_position_height.z));highp vec3 fdy=vec3(dFdy(v_position_height.x),dFdy(v_position_height.y),dFdy(v_position_height.z));n=normalize(cross(fdx,fdy))*-1.0;\n#endif\n#if defined(HAS_TEXTURE_u_normalTexture) && defined(HAS_ATTRIBUTE_a_uv_2f)\nvec3 nMap=texture( u_normalTexture,uv_2f).xyz;nMap=normalize(2.0*nMap-vec3(1.0));highp vec3 v=normalize(-v_position_height.xyz);highp mat3 TBN=cotangentFrame(n,v,uv_2f);n=normalize(TBN*nMap);\n#endif\nreturn n;}struct Material {float perceptualRoughness;float alphaRoughness;float metallic;vec3 f90;vec4 baseColor;vec3 diffuseColor;vec3 specularColor;highp vec3 normal;};Material getPBRMaterial() {Material mat;mat.baseColor=getBaseColor();mat.perceptualRoughness=u_roughnessFactor;mat.metallic=u_metallicFactor;\n#ifdef HAS_ATTRIBUTE_a_pbr\nmat.perceptualRoughness=v_roughness_metallic_emissive_alpha.x;mat.metallic=v_roughness_metallic_emissive_alpha.y;mat.baseColor.w*=v_roughness_metallic_emissive_alpha.w;\n#endif\n#if defined(HAS_TEXTURE_u_metallicRoughnessTexture) && defined(HAS_ATTRIBUTE_a_uv_2f) \nvec4 mrSample=texture(u_metallicRoughnessTexture,uv_2f);mat.perceptualRoughness*=mrSample.g;mat.metallic*=mrSample.b;\n#endif\nconst float c_minRoughness=0.04;mat.perceptualRoughness=clamp(mat.perceptualRoughness,c_minRoughness,1.0);mat.metallic=saturate(mat.metallic);mat.alphaRoughness=mat.perceptualRoughness*mat.perceptualRoughness;const vec3 f0=vec3(0.04);mat.diffuseColor=mat.baseColor.rgb*(vec3(1.0)-f0);mat.diffuseColor*=1.0-mat.metallic;mat.specularColor=mix(f0,mat.baseColor.rgb,mat.metallic);highp float reflectance=max(max(mat.specularColor.r,mat.specularColor.g),mat.specularColor.b);highp float reflectance90=saturate(reflectance*25.0);mat.f90=vec3(reflectance90);mat.normal=getNormal();return mat;}float V_GGX(float NdotL,float NdotV,float roughness)\n{float a2=roughness*roughness;float GGXV=NdotL*sqrt(NdotV*NdotV*(1.0-a2)+a2);float GGXL=NdotV*sqrt(NdotL*NdotL*(1.0-a2)+a2);return 0.5/(GGXV+GGXL);}float V_GGXFast(float NdotL,float NdotV,float roughness) {float a=roughness;float GGXV=NdotL*(NdotV*(1.0-a)+a);float GGXL=NdotV*(NdotL*(1.0-a)+a);return 0.5/(GGXV+GGXL);}vec3 F_Schlick(vec3 specularColor,vec3 f90,float VdotH)\n{return specularColor+(f90-specularColor)*pow(clamp(1.0-VdotH,0.0,1.0),5.0);}vec3 F_SchlickFast(vec3 specularColor,float VdotH)\n{float x=1.0-VdotH;float x4=x*x*x*x;return specularColor+(1.0-specularColor)*x4*x;}float D_GGX(highp float NdotH,float alphaRoughness)\n{highp float a4=alphaRoughness*alphaRoughness;highp float f=(NdotH*a4-NdotH)*NdotH+1.0;return a4/(PI*f*f);}vec3 diffuseBurley(Material mat,float LdotH,float NdotL,float NdotV)\n{float f90=2.0*LdotH*LdotH*mat.alphaRoughness-0.5;return (mat.diffuseColor/PI)*(1.0+f90*pow((1.0-NdotL),5.0))*(1.0+f90*pow((1.0-NdotV),5.0));}vec3 diffuseLambertian(Material mat)\n{\n#ifdef LIGHTING_3D_MODE\nreturn mat.diffuseColor;\n#else\nreturn mat.diffuseColor/PI;\n#endif\n}vec3 EnvBRDFApprox(vec3 specularColor,float roughness,highp float NdotV)\n{vec4 c0=vec4(-1,-0.0275,-0.572,0.022);vec4 c1=vec4(1,0.0425,1.04,-0.04);highp vec4 r=roughness*c0+c1;highp float a004=min(r.x*r.x,exp2(-9.28*NdotV))*r.x+r.y;vec2 AB=vec2(-1.04,1.04)*a004+r.zw;return specularColor*AB.x+AB.y;}vec3 computeIndirectLightContribution(Material mat,float NdotV,vec3 normal)\n{vec3 env_light=vec3(0.65,0.65,0.65);\n#ifdef LIGHTING_3D_MODE\nfloat ambient_factor=calculate_ambient_directional_factor(normal);env_light=u_lighting_ambient_color*ambient_factor;\n#endif\nvec3 envBRDF=EnvBRDFApprox(mat.specularColor,mat.perceptualRoughness,NdotV);vec3 indirectSpecular= envBRDF*env_light;vec3 indirectDiffuse=mat.diffuseColor*env_light;return indirectSpecular+indirectDiffuse;}vec3 computeLightContribution(Material mat,vec3 lightPosition,vec3 lightColor)\n{highp vec3 n=mat.normal;highp vec3 v=normalize(-v_position_height.xyz);highp vec3 l=normalize(lightPosition);highp vec3 h=normalize(v+l);float NdotV=clamp(abs(dot(n,v)),0.001,1.0);float NdotL=saturate(dot(n,l));highp float NdotH=saturate(dot(n,h));float VdotH=saturate(dot(v,h));vec3 f=F_SchlickFast(mat.specularColor,VdotH);float g=V_GGXFast(NdotL,NdotV,mat.alphaRoughness);float d=D_GGX(NdotH,mat.alphaRoughness);vec3 diffuseTerm=(1.0-f)*diffuseLambertian(mat);vec3 specularTerm=f*g*d;vec3 transformed_normal=vec3(-n.xy,n.z);float lighting_factor;\n#ifdef RENDER_SHADOWS\nlighting_factor=shadowed_light_factor_normal(transformed_normal,v_pos_light_view_0,v_pos_light_view_1,v_depth_shadows);\n#else\nlighting_factor=NdotL;\n#endif\nvec3 directLightColor=(specularTerm+diffuseTerm)*lighting_factor*lightColor;vec3 indirectLightColor=computeIndirectLightContribution(mat,NdotV,transformed_normal);vec3 color=(saturate(directLightColor)+indirectLightColor);float intensityFactor=1.0;\n#if !defined(LIGHTING_3D_MODE)\nconst vec3 luminosityFactor=vec3(0.2126,0.7152,0.0722);float luminance=dot(diffuseTerm,luminosityFactor);intensityFactor=mix((1.0-u_lightintensity),max((1.0-luminance+u_lightintensity),1.0),NdotL);\n#endif\ncolor*=intensityFactor;return color;}void main() {\n#ifdef TERRAIN_FRAGMENT_OCCLUSION\nif (isOccluded()) {discard;}\n#endif\nvec3 lightDir=u_lightpos;vec3 lightColor=u_lightcolor;\n#ifdef LIGHTING_3D_MODE\nlightDir=u_lighting_directional_dir;lightDir.xy=-lightDir.xy;lightColor=u_lighting_directional_color;\n#endif\nvec4 finalColor;\n#ifdef DIFFUSE_SHADED\nvec3 N=getNormal();vec3 baseColor=getBaseColor().rgb;vec3 diffuse=getDiffuseShadedColor(baseColor,N,lightDir,lightColor);\n#ifdef HAS_TEXTURE_u_occlusionTexture\nfloat ao=(texture(u_occlusionTexture,uv_2f).r-1.0)*u_aoIntensity+1.0;diffuse*=ao;\n#endif\nfinalColor=vec4(mix(diffuse,baseColor,u_emissive_strength),1.0)*u_opacity;\n#else\nMaterial mat=getPBRMaterial();vec3 color=computeLightContribution(mat,lightDir,lightColor);float ao=1.0;\n#if defined (HAS_TEXTURE_u_occlusionTexture) && defined(HAS_ATTRIBUTE_a_uv_2f)\n#ifdef OCCLUSION_TEXTURE_TRANSFORM\nvec2 uv=uv_2f.xy*u_occlusionTextureTransform.zw+u_occlusionTextureTransform.xy;\n#else\nvec2 uv=uv_2f;\n#endif\nao=(texture(u_occlusionTexture,uv).x-1.0)*u_aoIntensity+1.0;color*=ao;\n#endif\nvec4 emissive=u_emissiveFactor;\n#if defined(HAS_TEXTURE_u_emissionTexture) && defined(HAS_ATTRIBUTE_a_uv_2f)\nemissive.rgb*=sRGBToLinear(texture(u_emissionTexture,uv_2f).rgb);\n#endif\n#ifdef APPLY_LUT_ON_GPU\nfloat emissiveFactorLength=max(length(u_emissiveFactor.rgb),0.001);emissive.rgb=sRGBToLinear(applyLUT(u_lutTexture,linearTosRGB(emissive.rgb/emissiveFactorLength).rbg))*emissiveFactorLength;\n#endif\ncolor+=emissive.rgb;float opacity=mat.baseColor.w*u_opacity;\n#ifdef HAS_ATTRIBUTE_a_pbr\nfloat resEmission=v_roughness_metallic_emissive_alpha.z;resEmission*=v_height_based_emission_params.z+v_height_based_emission_params.w*pow(clamp(v_height_based_emission_params.x,0.0,1.0),v_height_based_emission_params.y);vec3 color_mix=v_color_mix.rgb;\n#ifdef APPLY_LUT_ON_GPU\ncolor_mix=applyLUT(u_lutTexture,color_mix);\n#endif\ncolor=mix(color,color_mix,min(1.0,resEmission));\n#ifdef HAS_ATTRIBUTE_a_color_4f\nfloat distance=length(vec2(1.3*max(0.0,abs(color_4f.x)-color_4f.z),color_4f.y));distance+= mix(0.5,0.0,clamp(resEmission-1.0,0.0,1.0));opacity*=v_roughness_metallic_emissive_alpha.w*saturate(1.0-distance*distance);\n#endif\n#endif\nvec3 unlitColor=mat.baseColor.rgb*ao+emissive.rgb;color=mix(color,unlitColor,u_emissive_strength);color=linearTosRGB(color);color*=opacity;finalColor=vec4(color,opacity);\n#endif\n#ifdef FOG\nfinalColor=fog_dither(fog_apply_premultiplied(finalColor,v_fog_pos,v_position_height.w));\n#endif\n#ifdef RENDER_CUTOFF\nfinalColor*=v_cutoff_opacity;\n#endif\n#ifdef INDICATOR_CUTOUT\nfinalColor=applyCutout(finalColor,v_position_height.w);\n#endif\nglFragColor=finalColor;\n#ifdef OVERDRAW_INSPECTOR\nglFragColor=vec4(1.0);\n#endif\nHANDLE_WIREFRAME_DEBUG;}', '#include "_prelude_fog.vertex.glsl"\n#include "_prelude_shadow.vertex.glsl"\nin vec3 a_pos_3f;\n#pragma mapbox: define-attribute highp vec3 normal_3f\n#pragma mapbox: define-attribute highp vec2 uv_2f\n#pragma mapbox: define-attribute highp vec3 color_3f\n#pragma mapbox: define-attribute highp vec4 color_4f\n#pragma mapbox: define-attribute-vertex-shader-only highp vec4 pbr\n#pragma mapbox: define-attribute-vertex-shader-only highp vec3 heightBasedEmissiveStrength\nuniform mat4 u_matrix;uniform mat4 u_node_matrix;uniform mat4 u_lighting_matrix;uniform vec3 u_camera_pos;uniform vec4 u_color_mix;\n#ifdef INSTANCED_ARRAYS\nin vec4 a_normal_matrix0;in vec4 a_normal_matrix1;in vec4 a_normal_matrix2;in vec4 a_normal_matrix3;\n#else\nuniform highp mat4 u_normal_matrix;\n#endif\n#ifdef RENDER_SHADOWS\nuniform mat4 u_light_matrix_0;uniform mat4 u_light_matrix_1;out highp vec4 v_pos_light_view_0;out highp vec4 v_pos_light_view_1;out float v_depth_shadows;\n#endif\nout vec4 v_position_height;out lowp vec4 v_color_mix;\n#ifdef TERRAIN_FRAGMENT_OCCLUSION\nout highp float v_depth;\n#endif\n#ifdef HAS_ATTRIBUTE_a_pbr\nout lowp vec4 v_roughness_metallic_emissive_alpha;out mediump vec4 v_height_based_emission_params;\n#endif\nvec3 sRGBToLinear(vec3 srgbIn) {return pow(srgbIn,vec3(2.2));}void main() {\n#pragma mapbox: initialize-attribute highp vec3 normal_3f\n#pragma mapbox: initialize-attribute highp vec2 uv_2f\n#pragma mapbox: initialize-attribute highp vec3 color_3f\n#pragma mapbox: initialize-attribute highp vec4 color_4f\n#pragma mapbox: initialize-attribute-custom highp vec4 pbr\n#pragma mapbox: initialize-attribute-custom highp vec3 heightBasedEmissiveStrength\nhighp mat4 normal_matrix;\n#ifdef INSTANCED_ARRAYS\nnormal_matrix=mat4(a_normal_matrix0,a_normal_matrix1,a_normal_matrix2,a_normal_matrix3);\n#else\nnormal_matrix=u_normal_matrix;\n#endif\nvec3 local_pos;mat3 rs;\n#ifdef MODEL_POSITION_ON_GPU\nvec3 pos_color=normal_matrix[0].xyz;vec4 translate=normal_matrix[1];vec3 pos_a=floor(pos_color);vec3 rgb=1.05*(pos_color-pos_a);float hidden=float(pos_a.x > EXTENT);float color_mix=pos_a.z/100.0;v_color_mix=vec4(sRGBToLinear(rgb),color_mix);float meter_to_tile=normal_matrix[0].w;vec4 pos=vec4(pos_a.xy,translate.z,1.0);rs[0].x=normal_matrix[1].w;rs[0].yz=normal_matrix[2].xy;rs[1].xy=normal_matrix[2].zw;rs[1].z=normal_matrix[3].x;rs[2].xyz=normal_matrix[3].yzw;vec4 pos_node=u_lighting_matrix*vec4(a_pos_3f,1.0);vec3 rotated_pos_node=rs*pos_node.xyz;vec3 pos_model_tile=(rotated_pos_node+vec3(translate.xy,0.0))*vec3(meter_to_tile,meter_to_tile,1.0);pos.xyz+=pos_model_tile;local_pos=pos.xyz;gl_Position=mix(u_matrix*pos,AWAY,hidden);pos.z*=meter_to_tile;v_position_height.xyz=pos.xyz-u_camera_pos;\n#else\nlocal_pos=a_pos_3f;gl_Position=u_matrix*vec4(a_pos_3f,1);v_position_height.xyz=vec3(u_lighting_matrix*vec4(a_pos_3f,1));v_color_mix=vec4(sRGBToLinear(u_color_mix.rgb),u_color_mix.a);\n#endif\nv_position_height.w=a_pos_3f.z;\n#ifdef HAS_ATTRIBUTE_a_pbr\nvec4 albedo_c=decode_color(pbr.xy);vec2 e_r_m=unpack_float(pbr.z);vec2 r_m= unpack_float(e_r_m.y*16.0);r_m.r=r_m.r*16.0;v_color_mix=vec4(albedo_c.rgb,1.0);v_roughness_metallic_emissive_alpha=vec4(vec3(r_m,e_r_m.x)/255.0,albedo_c.a);v_roughness_metallic_emissive_alpha.z*=2.0;float heightBasedRelativeIntepolation=a_pos_3f.z*heightBasedEmissiveStrength.x+heightBasedEmissiveStrength.y;v_height_based_emission_params.x=heightBasedRelativeIntepolation;v_height_based_emission_params.y=heightBasedEmissiveStrength.z;vec2 emissionMultiplierValues=unpack_float(pbr.w)/256.0;v_height_based_emission_params.z=emissionMultiplierValues.x;v_height_based_emission_params.w=emissionMultiplierValues.y-emissionMultiplierValues.x;\n#endif\n#ifdef FOG\nv_fog_pos=fog_position(local_pos);\n#endif\n#ifdef RENDER_CUTOFF\nv_cutoff_opacity=cutoff_opacity(u_cutoff_params,gl_Position.z);\n#endif\n#ifdef TERRAIN_FRAGMENT_OCCLUSION\nv_depth=gl_Position.z/gl_Position.w;\n#endif\n#ifdef HAS_ATTRIBUTE_a_normal_3f\n#ifdef MODEL_POSITION_ON_GPU\nfloat x_squared_scale=dot(rs[0],rs[0]);float y_squared_scale=dot(rs[1],rs[1]);float z_squared_scale=dot(rs[2],rs[2]);vec3 squared_scale=vec3(x_squared_scale,y_squared_scale,z_squared_scale);normal_3f=rs*((u_lighting_matrix*vec4(normal_3f,0.0)).xyz/squared_scale);normal_3f=normalize(normal_3f);\n#else\nnormal_3f=vec3(normal_matrix*vec4(normal_3f,0));\n#endif\n#endif\n#ifdef HAS_ATTRIBUTE_a_pbr\n#ifdef HAS_ATTRIBUTE_a_color_4f\nv_roughness_metallic_emissive_alpha.w=clamp(color_4f.a*v_roughness_metallic_emissive_alpha.w*(v_roughness_metallic_emissive_alpha.z-1.0),0.0,1.0);\n#endif\n#endif\n#ifdef RENDER_SHADOWS\nvec4 shadow_pos=u_node_matrix*vec4(local_pos,1.0);\n#ifdef NORMAL_OFFSET\n#ifdef HAS_ATTRIBUTE_a_normal_3f\n#ifdef MODEL_POSITION_ON_GPU\nvec3 offset=shadow_normal_offset(vec3(-normal_3f.xy,normal_3f.z));shadow_pos.xyz+=offset*shadow_normal_offset_multiplier0();\n#else\nvec3 offset=shadow_normal_offset_model(normal_3f);shadow_pos.xyz+=offset*shadow_normal_offset_multiplier0();\n#endif\n#endif\n#endif\nv_pos_light_view_0=u_light_matrix_0*shadow_pos;v_pos_light_view_1=u_light_matrix_1*shadow_pos;v_depth_shadows=gl_Position.w;\n#endif\n}'), modelDepth: Go("in highp float v_depth;void main() {\n#ifndef DEPTH_TEXTURE\nglFragColor=pack_depth(v_depth);\n#endif\n}", "in vec3 a_pos_3f;uniform mat4 u_matrix;out highp float v_depth;\n#ifdef MODEL_POSITION_ON_GPU\n#ifdef INSTANCED_ARRAYS\nin vec4 a_normal_matrix0;in vec4 a_normal_matrix1;in vec4 a_normal_matrix2;in vec4 a_normal_matrix3;\n#else\nuniform highp mat4 u_instance;\n#endif\nuniform highp mat4 u_node_matrix;\n#endif\nvoid main() {\n#ifdef MODEL_POSITION_ON_GPU\nhighp mat4 instance;\n#ifdef INSTANCED_ARRAYS\ninstance=mat4(a_normal_matrix0,a_normal_matrix1,a_normal_matrix2,a_normal_matrix3);\n#else\ninstance=u_instance;\n#endif\nvec3 pos_color=instance[0].xyz;vec4 translate=instance[1];vec3 pos_a=floor(pos_color);float hidden=float(pos_a.x > EXTENT);float meter_to_tile=instance[0].w;vec4 pos=vec4(pos_a.xy,translate.z,1.0);mat3 rs;rs[0].x=instance[1].w;rs[0].yz=instance[2].xy;rs[1].xy=instance[2].zw;rs[1].z=instance[3].x;rs[2].xyz=instance[3].yzw;vec4 pos_node=u_node_matrix*vec4(a_pos_3f,1.0);vec3 rotated_pos_node=rs*pos_node.xyz;vec3 pos_model_tile=(rotated_pos_node+vec3(translate.xy,0.0))*vec3(meter_to_tile,meter_to_tile,1.0);pos.xyz+=pos_model_tile;gl_Position=mix(u_matrix*pos,AWAY,hidden);\n#else\ngl_Position=u_matrix*vec4(a_pos_3f,1);\n#endif\nv_depth=gl_Position.z/gl_Position.w;}"), stars: Go("in highp vec2 v_uv;in mediump float v_intensity;float shapeCircle(in vec2 uv)\n{float beginFade=0.6;float lengthFromCenter=length(v_uv);return 1.0-clamp((lengthFromCenter-beginFade)/(1.0-beginFade),0.0,1.0);}void main() {float alpha=shapeCircle(v_uv);vec3 color=vec3(1.0,1.0,1.0);alpha*=v_intensity;glFragColor=vec4(color*alpha,alpha);HANDLE_WIREFRAME_DEBUG;}", "\nin vec3 a_pos_3f;in vec2 a_uv;in float a_size_scale;in float a_fade_opacity;uniform mat4 u_matrix;uniform vec3 u_up;uniform vec3 u_right;uniform float u_intensity_multiplier;out highp vec2 v_uv;out mediump float v_intensity;void main() {v_uv=a_uv;v_intensity=a_fade_opacity*u_intensity_multiplier;vec3 pos=a_pos_3f;pos+=a_uv.x*u_right*a_size_scale;pos+=a_uv.y*u_up*a_size_scale;gl_Position=u_matrix*vec4(pos,1.0);}"), snowParticle: Go("in highp vec2 uv;in highp float alphaMultiplier;uniform vec4 u_particleColor;uniform vec2 u_simpleShapeParameters;void main() {float t=clamp((length(uv)-u_simpleShapeParameters.x)/(1.0-u_simpleShapeParameters.x),0.0,1.0);float alpha=1.0-pow(t,pow(10.0,u_simpleShapeParameters.y));alpha*=alphaMultiplier;alpha*=u_particleColor.a;vec3 color=u_particleColor.rgb*alpha;glFragColor=vec4(color,alpha) ;HANDLE_WIREFRAME_DEBUG;}", "\nin highp vec3 a_pos_3f;in highp vec2 a_uv;in highp vec4 a_snowParticleData;in highp vec4 a_snowParticleDataHorizontalOscillation;uniform mat4 u_modelview;uniform mat4 u_projection;uniform vec3 u_cam_pos;uniform vec2 u_screenSize;uniform float u_time;uniform float u_boxSize;uniform float u_velocityConeAperture; \nuniform float u_velocity;uniform vec3 u_direction;uniform float u_horizontalOscillationRadius; \nuniform float u_horizontalOscillationRate; \nuniform float u_billboardSize;uniform vec2 u_thinningCenterPos;uniform vec3 u_thinningShape;uniform float u_thinningAffectedRatio;uniform float u_thinningParticleOffset;out highp vec2 uv;out highp float alphaMultiplier;void main() {vec3 pos=a_pos_3f;float halfBoxSize=0.5*u_boxSize;pos.xyz*=halfBoxSize;pos+=u_cam_pos;float velocityConeApertureRad=radians(u_velocityConeAperture*0.5);float coneAnglePichRad=velocityConeApertureRad*a_snowParticleData.z;float coneAngleHeadingRad=a_snowParticleData.w*radians(360.0);vec3 localZ=normalize(u_direction);vec3 localX=normalize(cross(localZ,vec3(1,0,0)));vec3 localY=normalize(cross(localZ,localX));vec3 direction;direction.x=cos(coneAngleHeadingRad)*sin(coneAnglePichRad);direction.y=sin(coneAngleHeadingRad)*sin(coneAnglePichRad);direction.z=cos(coneAnglePichRad);direction=normalize(direction);vec3 simPosLocal=vec3(0,0,0);float velocityScale=(1.0+3.0*a_snowParticleData.y)*u_velocity;simPosLocal+=direction*velocityScale*u_time;float horizontalOscillationRadius=u_horizontalOscillationRadius*a_snowParticleDataHorizontalOscillation.x;float horizontalOscillationAngle=u_horizontalOscillationRate*u_time*(-1.0+2.0*a_snowParticleDataHorizontalOscillation.y);simPosLocal.xy+=horizontalOscillationRadius*vec2(cos(horizontalOscillationAngle),sin(horizontalOscillationAngle));vec3 simPos=localX*simPosLocal.x+\nlocalY*simPosLocal.y+localZ*simPosLocal.z;pos+=simPos;pos=fract((pos+vec3(halfBoxSize))/vec3(u_boxSize))*u_boxSize-vec3(halfBoxSize);float clipZ=-u_cam_pos.z+pos.z;vec4 posView=u_modelview*vec4(pos,1.0);float size=u_billboardSize;alphaMultiplier=1.0;vec4 posScreen=u_projection*posView;posScreen/=posScreen.w;posScreen.xy=vec2(0.5)+posScreen.xy*0.5;posScreen.xy*=u_screenSize;vec2 thinningCenterPos=u_thinningCenterPos.xy;thinningCenterPos.y=u_screenSize.y-thinningCenterPos.y;float screenDist=length((thinningCenterPos-posScreen.xy)/(0.5*u_screenSize));screenDist+=a_snowParticleData.x*u_thinningParticleOffset;float scaleFactorMode=0.0;float thinningShapeDist=u_thinningShape.x+u_thinningShape.y;if (screenDist < thinningShapeDist) {float thinningFadeRatio=clamp((screenDist-u_thinningShape.x)/u_thinningShape.y,0.0,1.0);thinningFadeRatio=pow(thinningFadeRatio,u_thinningShape.z);if (a_snowParticleData.x < u_thinningAffectedRatio) {scaleFactorMode=1.0-thinningFadeRatio;alphaMultiplier=thinningFadeRatio;}}vec4 posScreen1=u_projection*vec4(posView.x-size,posView.yzw);posScreen1/=posScreen1.w;vec4 posScreen2=u_projection*vec4(posView.x+size,posView.yzw);posScreen2/=posScreen2.w;posScreen1.xy=vec2(0.5)+posScreen1.xy*0.5;posScreen1.xy*=u_screenSize;posScreen2.xy=vec2(0.5)+posScreen2.xy*0.5;posScreen2.xy*=u_screenSize;float screenLength=length(posScreen1.xy-posScreen2.xy);float screenEpsilon=3.0;float scaleFactor=1.0;if (screenLength < screenEpsilon) {scaleFactor=screenEpsilon/max(screenLength,0.01);scaleFactor=mix(scaleFactor,1.0,scaleFactorMode);}float screenEpsilon2=15.0;if (screenLength > screenEpsilon2) {scaleFactor=screenEpsilon2/max(screenLength,0.01);}size*=scaleFactor;vec2 right=size*vec2(1,0);vec2 up=size*vec2(0,1);posView.xy+=right*a_uv.x;posView.xy+=up*a_uv.y;uv=a_uv;gl_Position=u_projection*posView;}"), rainParticle: Go("in highp vec2 uv;in highp float particleRandomValue;uniform sampler2D u_texScreen;uniform float u_distortionStrength;uniform vec4 u_color;uniform vec2 u_thinningCenterPos;uniform vec3 u_thinningShape;uniform float u_thinningAffectedRatio;uniform float u_thinningParticleOffset;uniform float u_shapeDirectionalPower;uniform float u_mode;void main() {vec2 st=uv*0.5+vec2(0.5);vec2 uvm=uv;uvm.y=-1.0+2.0*pow(st.y,u_shapeDirectionalPower);float shape=clamp(1.0-length(uvm),0.0,1.0);float alpha=abs(shape)*u_color.a;vec2 screenSize=vec2(textureSize(u_texScreen,0));vec2 thinningCenterPos=u_thinningCenterPos.xy;thinningCenterPos.y=screenSize.y-thinningCenterPos.y;float screenDist=length((thinningCenterPos-gl_FragCoord.xy)/(0.5*screenSize));screenDist+=(0.5+0.5*particleRandomValue)*u_thinningParticleOffset;float thinningShapeDist=u_thinningShape.x+u_thinningShape.y;float thinningAlpha=1.0;if (screenDist < thinningShapeDist) {float thinningFadeRatio=clamp((screenDist-u_thinningShape.x)/u_thinningShape.y,0.0,1.0);thinningFadeRatio=pow(thinningFadeRatio,u_thinningShape.z);thinningAlpha*=thinningFadeRatio;}vec2 offsetXY=normalize(uvm)*abs(shape);vec2 stScreen=(gl_FragCoord.xy+offsetXY*u_distortionStrength*thinningAlpha)/screenSize;vec3 colorScreen=texture(u_texScreen,stScreen).rgb;alpha*=thinningAlpha;glFragColor=mix(vec4(colorScreen,1.0),vec4(u_color.rgb*alpha,alpha),u_mode);HANDLE_WIREFRAME_DEBUG;}", "\nin highp vec3 a_pos_3f;in highp vec2 a_uv;in highp vec4 a_rainParticleData;uniform mat4 u_modelview;uniform mat4 u_projection;uniform vec3 u_cam_pos;uniform float u_time;uniform float u_boxSize;uniform float u_velocityConeAperture; \nuniform float u_velocity; \nuniform vec2 u_rainDropletSize;uniform vec3 u_rainDirection;out highp vec2 uv;out highp float particleRandomValue;void main() {vec3 pos=a_pos_3f;float halfBoxSize=0.5*u_boxSize;pos*=halfBoxSize; \npos+=u_cam_pos;float velocityConeApertureRad=radians(u_velocityConeAperture*0.5);float coneAnglePichRad=velocityConeApertureRad*a_rainParticleData.z;float coneAngleHeadingRad=a_rainParticleData.w*radians(360.0);vec3 localZ=normalize(u_rainDirection);vec3 localX=normalize(cross(localZ,vec3(1,0,0)));vec3 localY=normalize(cross(localZ,localX));vec3 directionLocal;directionLocal.x=cos(coneAngleHeadingRad)*sin(coneAnglePichRad);directionLocal.y=sin(coneAngleHeadingRad)*sin(coneAnglePichRad);directionLocal.z=cos(coneAnglePichRad);directionLocal=normalize(directionLocal);vec3 directionWorld=localX*directionLocal.x+localY*directionLocal.y+localZ*directionLocal.z;float velocityScale=(1.0+3.0*a_rainParticleData.y)*u_velocity;vec3 simPosLocal=vec3(0,0,0);simPosLocal+=directionLocal*velocityScale*u_time;vec3 simPos=localX*simPosLocal.x+\nlocalY*simPosLocal.y+localZ*simPosLocal.z;pos+=simPos;pos=fract((pos+vec3(halfBoxSize))/vec3(u_boxSize))*u_boxSize-vec3(halfBoxSize);vec4 posView=u_modelview*vec4(pos,1.0);vec3 directionView=normalize((u_modelview*vec4(directionWorld,0.0)).xyz);vec3 side=cross(directionView,normalize(posView.xyz));posView.xyz+=side*a_uv.x*u_rainDropletSize.x;posView.xyz+=directionView*a_uv.y*u_rainDropletSize.y;uv=a_uv;particleRandomValue=a_rainParticleData.x;gl_Position=u_projection*posView;}"), vignette: Go("uniform vec3 u_vignetteShape;uniform vec4 u_vignetteColor;in vec2 st;void main() {float screenDist=length(st);float alpha=clamp((screenDist-u_vignetteShape.x)/u_vignetteShape.y,0.0,1.0);alpha=pow(alpha,u_vignetteShape.z)*u_vignetteColor.a;vec3 color=u_vignetteColor.rgb;glFragColor=vec4(color*alpha,alpha) ;}", "in vec2 a_pos_2f;out vec2 st;void main() {st=a_pos_2f;gl_Position=vec4(a_pos_2f,0,1);}"), occlusion: Go("uniform vec4 u_color;void main() {glFragColor=u_color;}", '#include "_prelude_terrain.vertex.glsl"\nin highp vec2 a_offset_xy;uniform highp vec3 u_anchorPos;uniform mat4 u_matrix;uniform vec2 u_screenSizePx;uniform vec2 u_occluderSizePx;void main() {vec3 world_pos=u_anchorPos;\n#ifdef TERRAIN\nfloat e=elevation(world_pos.xy);world_pos.z+=e;\n#endif\nvec4 projected_point=u_matrix*vec4(world_pos,1.0);projected_point.xy+=projected_point.w*a_offset_xy*0.5*u_occluderSizePx/u_screenSizePx;gl_Position=projected_point;}') };
      function Vo(e22, t22) {
        const i22 = e22.replace(/\s*\/\/[^\n]*\n/g, "\n").split("\n");
        for (let e3 of i22) if (e3 = e3.trim(), "#" === e3[0] && e3.includes("if") && !e3.includes("endif")) {
          e3 = e3.replace("#", "").replace(/ifdef|ifndef|elif|if/g, "").replace(/!|defined|\(|\)|\|\||&&/g, "").replace(/\s+/g, " ").trim();
          const i3 = e3.split(" ");
          for (const e4 of i3) t22.includes(e4) || t22.push(e4);
        }
      }
      function Go(e22, t22) {
        const i22 = /#include\s+"([^"]+)"/g, o2 = /#pragma mapbox: ([\w\-]+) ([\w]+) ([\w]+) ([\w]+)/g;
        let s2 = t22.match(/(attribute(\S*)|(^\s*|;)in) (highp |mediump |lowp )?([\w]+) ([\w]+)/gm);
        s2 && (s2 = s2.map((e3) => {
          const t3 = e3.split(" ");
          return t3[t3.length - 1];
        }), s2 = [...new Set(s2)]);
        const r22 = {}, n22 = [], a22 = [];
        if (e22 = e22.replace(i22, (e3, t3) => (a22.push(t3), "")), (t22 = t22.replace(i22, (e3, t3) => (n22.push(t3), ""))).includes("flat out")) return void console.error('The usage of "flat" qualifier is disallowed, see: https://bugs.webkit.org/show_bug.cgi?id=268071');
        let l22 = [...Fo];
        Vo(e22, l22), Vo(t22, l22);
        for (const e3 of [...n22, ...a22]) Bo[e3] || console.error(`Undefined include: ${e3}`), ko[e3] || (ko[e3] = [], Vo(Bo[e3], ko[e3])), l22 = [...l22, ...ko[e3]];
        return { fragmentSource: e22 = e22.replace(o2, (e3, t3, i3, o3, s3) => (r22[s3] = true, "define" === t3 ? `
#ifndef HAS_UNIFORM_u_${s3}
in ${i3} ${o3} ${s3};
#else
uniform ${i3} ${o3} u_${s3};
#endif
` : "initialize" === t3 ? `
#ifdef HAS_UNIFORM_u_${s3}
    ${i3} ${o3} ${s3} = u_${s3};
#endif
` : "define-attribute" === t3 ? `
#ifdef HAS_ATTRIBUTE_a_${s3}
    in ${i3} ${o3} ${s3};
#endif
` : "initialize-attribute" === t3 ? "" : void 0)), vertexSource: t22 = t22.replace(o2, (e3, t3, i3, o3, s3) => {
          const n3 = "float" === o3 ? "vec2" : o3, a3 = s3.match(/color/) ? "color" : n3;
          return "define-attribute-vertex-shader-only" === t3 ? `
#ifdef HAS_ATTRIBUTE_a_${s3}
in ${i3} ${o3} a_${s3};
#endif
` : r22[s3] ? "define" === t3 ? `
#ifndef HAS_UNIFORM_u_${s3}
uniform lowp float u_${s3}_t;
in ${i3} ${n3} a_${s3};
out ${i3} ${o3} ${s3};
#else
uniform ${i3} ${o3} u_${s3};
#endif
` : "initialize" === t3 ? "vec4" === a3 ? `
#ifndef HAS_UNIFORM_u_${s3}
    ${s3} = a_${s3};
#else
    ${i3} ${o3} ${s3} = u_${s3};
#endif
` : `
#ifndef HAS_UNIFORM_u_${s3}
    ${s3} = unpack_mix_${a3}(a_${s3}, u_${s3}_t);
#else
    ${i3} ${o3} ${s3} = u_${s3};
#endif
` : "define-attribute" === t3 ? `
#ifdef HAS_ATTRIBUTE_a_${s3}
    in ${i3} ${o3} a_${s3};
    out ${i3} ${o3} ${s3};
#endif
` : "initialize-attribute" === t3 ? `
#ifdef HAS_ATTRIBUTE_a_${s3}
    ${s3} = a_${s3};
#endif
` : void 0 : "define" === t3 ? `
#ifndef HAS_UNIFORM_u_${s3}
uniform lowp float u_${s3}_t;
in ${i3} ${n3} a_${s3};
#else
uniform ${i3} ${o3} u_${s3};
#endif
` : "define-instanced" === t3 ? "mat4" === a3 ? `
#ifdef INSTANCED_ARRAYS
in vec4 a_${s3}0;
in vec4 a_${s3}1;
in vec4 a_${s3}2;
in vec4 a_${s3}3;
#else
uniform ${i3} ${o3} u_${s3};
#endif
` : `
#ifdef INSTANCED_ARRAYS
in ${i3} ${n3} a_${s3};
#else
uniform ${i3} ${o3} u_${s3};
#endif
` : "initialize-attribute-custom" === t3 ? `
#ifdef HAS_ATTRIBUTE_a_${s3}
    ${i3} ${o3} ${s3} = a_${s3};
#endif
` : "vec4" === a3 ? `
#ifndef HAS_UNIFORM_u_${s3}
    ${i3} ${o3} ${s3} = a_${s3};
#else
    ${i3} ${o3} ${s3} = u_${s3};
#endif
` : `
#ifndef HAS_UNIFORM_u_${s3}
    ${i3} ${o3} ${s3} = unpack_mix_${a3}(a_${s3}, u_${s3}_t);
#else
    ${i3} ${o3} ${s3} = u_${s3};
#endif
`;
        }), staticAttributes: s2, usedDefines: l22, vertexIncludes: n22, fragmentIncludes: a22 };
      }
      class qo {
        constructor() {
          this.boundProgram = null, this.boundLayoutVertexBuffer = null, this.boundPaintVertexBuffers = [], this.boundIndexBuffer = null, this.boundVertexOffset = null, this.boundDynamicVertexBuffers = [], this.vao = null;
        }
        bind(e22, t22, i22, o2, s2, r22, n22, a22) {
          this.context = e22;
          let l22 = this.boundPaintVertexBuffers.length !== o2.length;
          for (let e3 = 0; !l22 && e3 < o2.length; e3++) this.boundPaintVertexBuffers[e3] !== o2[e3] && (l22 = true);
          let c22 = this.boundDynamicVertexBuffers.length !== n22.length;
          for (let e3 = 0; !c22 && e3 < n22.length; e3++) this.boundDynamicVertexBuffers[e3] !== n22[e3] && (c22 = true);
          if (!this.vao || this.boundProgram !== t22 || this.boundLayoutVertexBuffer !== i22 || l22 || c22 || this.boundIndexBuffer !== s2 || this.boundVertexOffset !== r22) this.freshBind(t22, i22, o2, s2, r22, n22, a22);
          else {
            e22.bindVertexArrayOES.set(this.vao);
            for (const i3 of n22) i3 && (i3.bind(), a22 && i3.instanceCount && i3.setVertexAttribDivisor(e22.gl, t22, a22));
            s2 && s2.dynamicDraw && s2.bind();
          }
        }
        freshBind(e22, t22, i22, o2, s2, r22, n22) {
          const a22 = e22.numAttributes, l22 = this.context, c22 = l22.gl;
          this.vao && this.destroy(), this.vao = l22.gl.createVertexArray(), l22.bindVertexArrayOES.set(this.vao), this.boundProgram = e22, this.boundLayoutVertexBuffer = t22, this.boundPaintVertexBuffers = i22, this.boundIndexBuffer = o2, this.boundVertexOffset = s2, this.boundDynamicVertexBuffers = r22, t22.enableAttributes(c22, e22), t22.bind(), t22.setVertexAttribPointers(c22, e22, s2);
          for (const t3 of i22) t3.enableAttributes(c22, e22), t3.bind(), t3.setVertexAttribPointers(c22, e22, s2);
          for (const t3 of r22) t3 && (t3.enableAttributes(c22, e22), t3.bind(), t3.setVertexAttribPointers(c22, e22, s2), n22 && t3.instanceCount && t3.setVertexAttribDivisor(c22, e22, n22));
          o2 && o2.bind(), l22.currentNumAttributes = a22;
        }
        destroy() {
          this.vao && (this.context.gl.deleteVertexArray(this.vao), this.vao = null);
        }
      }
      function Zo(t22, i22) {
        const o2 = Math.pow(2, i22.canonical.z), s2 = i22.canonical.y;
        return [new e2.ac(0, s2 / o2).toLngLat().lat, new e2.ac(0, (s2 + 1) / o2).toLngLat().lat];
      }
      function Ho(t22, i22, o2, s2, r22, n22, a22) {
        const l22 = t22.context, c22 = l22.gl, h22 = o2.hillshadeFBO;
        if (!h22) return;
        t22.prepareDrawTile();
        const d22 = t22.isTileAffectedByFog(i22), u22 = t22.getOrCreateProgram("hillshade", { overrideFog: d22 });
        l22.activeTexture.set(c22.TEXTURE0), c22.bindTexture(c22.TEXTURE_2D, h22.colorAttachment.get());
        const _22 = ((t3, i3, o3, s3) => {
          const r3 = o3.paint.get("hillshade-shadow-color"), n3 = "none" === o3.paint.get("hillshade-shadow-color-use-theme").constantOr("default"), a3 = o3.paint.get("hillshade-highlight-color"), l3 = "none" === o3.paint.get("hillshade-highlight-color-use-theme").constantOr("default"), c3 = o3.paint.get("hillshade-accent-color"), h3 = "none" === o3.paint.get("hillshade-accent-color-use-theme").constantOr("default"), d3 = o3.paint.get("hillshade-emissive-strength");
          let u3 = e2.al(o3.paint.get("hillshade-illumination-direction"));
          if ("viewport" === o3.paint.get("hillshade-illumination-anchor")) u3 -= t3.transform.angle;
          else if (t3.style && t3.style.enable3dLights() && t3.style.directionalLight) {
            const i4 = t3.style.directionalLight.properties.get("direction"), o4 = e2.cR(i4.x, i4.y, i4.z);
            u3 = e2.al(o4[1]);
          }
          const _3 = !t3.options.moving;
          return { u_matrix: s3 || t3.transform.calculateProjMatrix(i3.tileID.toUnwrapped(), _3), u_image: 0, u_latrange: Zo(0, i3.tileID), u_light: [o3.paint.get("hillshade-exaggeration"), u3], u_shadow: r3.toRenderColor(n3 ? null : o3.lut), u_highlight: a3.toRenderColor(l3 ? null : o3.lut), u_emissive_strength: d3, u_accent: c3.toRenderColor(h3 ? null : o3.lut) };
        })(t22, o2, s2, t22.terrain ? i22.projMatrix : null);
        t22.uploadCommonUniforms(l22, u22, i22.toUnwrapped());
        const { tileBoundsBuffer: p22, tileBoundsIndexBuffer: f22, tileBoundsSegments: m22 } = t22.getTileBoundsBuffers(o2);
        u22.draw(t22, c22.TRIANGLES, r22, n22, a22, qi.disabled, _22, s2.id, p22, f22, m22);
      }
      function Wo(t22, i22, o2) {
        if (!i22.needsDEMTextureUpload) return;
        const s2 = t22.context, r22 = s2.gl;
        s2.pixelStoreUnpackPremultiplyAlpha.set(false), i22.demTexture = i22.demTexture || t22.getTileTexture(o2.stride);
        const n22 = o2.getPixels();
        i22.demTexture ? i22.demTexture.update(n22, { premultiply: false }) : i22.demTexture = new e2.T(s2, n22, r22.R32F, { premultiply: false }), i22.needsDEMTextureUpload = false;
      }
      function $o(t22, i22, o2) {
        const s2 = t22.context, r22 = s2.gl;
        if (!i22.dem) return;
        const n22 = i22.dem;
        if (s2.activeTexture.set(r22.TEXTURE1), Wo(t22, i22, n22), !i22.demTexture) return;
        i22.demTexture.bind(r22.NEAREST, r22.CLAMP_TO_EDGE);
        const a22 = n22.dim;
        s2.activeTexture.set(r22.TEXTURE0);
        let l22 = i22.hillshadeFBO;
        if (!l22) {
          const t3 = new e2.T(s2, { width: a22, height: a22, data: null }, r22.RGBA8);
          t3.bind(r22.LINEAR, r22.CLAMP_TO_EDGE), l22 = i22.hillshadeFBO = s2.createFramebuffer(a22, a22, true, "renderbuffer"), l22.colorAttachment.set(t3.texture);
        }
        s2.bindFramebuffer.set(l22.framebuffer), s2.viewport.set([0, 0, a22, a22]);
        const { tileBoundsBuffer: c22, tileBoundsIndexBuffer: h22, tileBoundsSegments: d22 } = t22.getMercatorTileBoundsBuffers(), u22 = [];
        t22.linearFloatFilteringSupported() && u22.push("TERRAIN_DEM_FLOAT_FORMAT"), t22.getOrCreateProgram("hillshadePrepare", { defines: u22 }).draw(t22, r22.TRIANGLES, Ni.disabled, ji.disabled, ki.unblended, qi.disabled, ((t3, i3) => {
          const o3 = i3.stride, s3 = e2.bz();
          return e2.c5(s3, 0, e2.aj, -e2.aj, 0, 0, 1), e2.bo(s3, s3, [0, -e2.aj, 0]), { u_matrix: s3, u_image: 1, u_dimension: [o3, o3], u_zoom: t3.overscaledZ };
        })(i22.tileID, n22), o2.id, c22, h22, d22), i22.needsHillshadePrepare = false;
      }
      class Xo {
        constructor(e22) {
          this.gl = e22.gl, this.default = this.getDefault(), this.current = this.default, this.dirty = false;
        }
        get() {
          return this.current;
        }
        set(e22) {
        }
        getDefault() {
          return this.default;
        }
        setDefault() {
          this.set(this.default);
        }
      }
      class Yo extends Xo {
        getDefault() {
          return e2.am.transparent;
        }
        set(e22) {
          const t22 = this.current;
          (e22.r !== t22.r || e22.g !== t22.g || e22.b !== t22.b || e22.a !== t22.a || this.dirty) && (this.gl.clearColor(e22.r, e22.g, e22.b, e22.a), this.current = e22, this.dirty = false);
        }
      }
      class Ko extends Xo {
        getDefault() {
          return 1;
        }
        set(e22) {
          (e22 !== this.current || this.dirty) && (this.gl.clearDepth(e22), this.current = e22, this.dirty = false);
        }
      }
      class Jo extends Xo {
        getDefault() {
          return 0;
        }
        set(e22) {
          (e22 !== this.current || this.dirty) && (this.gl.clearStencil(e22), this.current = e22, this.dirty = false);
        }
      }
      class Qo extends Xo {
        getDefault() {
          return [true, true, true, true];
        }
        set(e22) {
          const t22 = this.current;
          (e22[0] !== t22[0] || e22[1] !== t22[1] || e22[2] !== t22[2] || e22[3] !== t22[3] || this.dirty) && (this.gl.colorMask(e22[0], e22[1], e22[2], e22[3]), this.current = e22, this.dirty = false);
        }
      }
      class es2 extends Xo {
        getDefault() {
          return true;
        }
        set(e22) {
          (e22 !== this.current || this.dirty) && (this.gl.depthMask(e22), this.current = e22, this.dirty = false);
        }
      }
      class ts extends Xo {
        getDefault() {
          return 255;
        }
        set(e22) {
          (e22 !== this.current || this.dirty) && (this.gl.stencilMask(e22), this.current = e22, this.dirty = false);
        }
      }
      class is extends Xo {
        getDefault() {
          return { func: this.gl.ALWAYS, ref: 0, mask: 255 };
        }
        set(e22) {
          const t22 = this.current;
          (e22.func !== t22.func || e22.ref !== t22.ref || e22.mask !== t22.mask || this.dirty) && (this.gl.stencilFunc(e22.func, e22.ref, e22.mask), this.current = e22, this.dirty = false);
        }
      }
      class os extends Xo {
        getDefault() {
          const e22 = this.gl;
          return [e22.KEEP, e22.KEEP, e22.KEEP];
        }
        set(e22) {
          const t22 = this.current;
          (e22[0] !== t22[0] || e22[1] !== t22[1] || e22[2] !== t22[2] || this.dirty) && (this.gl.stencilOp(e22[0], e22[1], e22[2]), this.current = e22, this.dirty = false);
        }
      }
      class ss extends Xo {
        getDefault() {
          return false;
        }
        set(e22) {
          if (e22 === this.current && !this.dirty) return;
          const t22 = this.gl;
          e22 ? t22.enable(t22.STENCIL_TEST) : t22.disable(t22.STENCIL_TEST), this.current = e22, this.dirty = false;
        }
      }
      class rs extends Xo {
        getDefault() {
          return [0, 1];
        }
        set(e22) {
          const t22 = this.current;
          (e22[0] !== t22[0] || e22[1] !== t22[1] || this.dirty) && (this.gl.depthRange(e22[0], e22[1]), this.current = e22, this.dirty = false);
        }
      }
      class ns extends Xo {
        getDefault() {
          return false;
        }
        set(e22) {
          if (e22 === this.current && !this.dirty) return;
          const t22 = this.gl;
          e22 ? t22.enable(t22.DEPTH_TEST) : t22.disable(t22.DEPTH_TEST), this.current = e22, this.dirty = false;
        }
      }
      class as extends Xo {
        getDefault() {
          return this.gl.LESS;
        }
        set(e22) {
          (e22 !== this.current || this.dirty) && (this.gl.depthFunc(e22), this.current = e22, this.dirty = false);
        }
      }
      class ls extends Xo {
        getDefault() {
          return false;
        }
        set(e22) {
          if (e22 === this.current && !this.dirty) return;
          const t22 = this.gl;
          e22 ? t22.enable(t22.BLEND) : t22.disable(t22.BLEND), this.current = e22, this.dirty = false;
        }
      }
      class cs extends Xo {
        getDefault() {
          const e22 = this.gl;
          return [e22.ONE, e22.ZERO, e22.ONE, e22.ZERO];
        }
        set(e22) {
          const t22 = this.current;
          (e22[0] !== t22[0] || e22[1] !== t22[1] || e22[2] !== t22[2] || e22[3] !== t22[3] || this.dirty) && (this.gl.blendFuncSeparate(e22[0], e22[1], e22[2], e22[3]), this.current = e22, this.dirty = false);
        }
      }
      class hs extends Xo {
        getDefault() {
          return e2.am.transparent;
        }
        set(e22) {
          const t22 = this.current;
          (e22.r !== t22.r || e22.g !== t22.g || e22.b !== t22.b || e22.a !== t22.a || this.dirty) && (this.gl.blendColor(e22.r, e22.g, e22.b, e22.a), this.current = e22, this.dirty = false);
        }
      }
      class ds extends Xo {
        getDefault() {
          return this.gl.FUNC_ADD;
        }
        set(e22) {
          (e22 !== this.current || this.dirty) && (this.gl.blendEquationSeparate(e22, e22), this.current = e22, this.dirty = false);
        }
      }
      class us extends Xo {
        getDefault() {
          return false;
        }
        set(e22) {
          if (e22 === this.current && !this.dirty) return;
          const t22 = this.gl;
          e22 ? t22.enable(t22.CULL_FACE) : t22.disable(t22.CULL_FACE), this.current = e22, this.dirty = false;
        }
      }
      class _s extends Xo {
        getDefault() {
          return this.gl.BACK;
        }
        set(e22) {
          (e22 !== this.current || this.dirty) && (this.gl.cullFace(e22), this.current = e22, this.dirty = false);
        }
      }
      class ps extends Xo {
        getDefault() {
          return this.gl.CCW;
        }
        set(e22) {
          (e22 !== this.current || this.dirty) && (this.gl.frontFace(e22), this.current = e22, this.dirty = false);
        }
      }
      let fs = class extends Xo {
        getDefault() {
          return null;
        }
        set(e22) {
          (e22 !== this.current || this.dirty) && (this.gl.useProgram(e22), this.current = e22, this.dirty = false);
        }
      };
      class ms extends Xo {
        getDefault() {
          return this.gl.TEXTURE0;
        }
        set(e22) {
          (e22 !== this.current || this.dirty) && (this.gl.activeTexture(e22), this.current = e22, this.dirty = false);
        }
      }
      class gs extends Xo {
        getDefault() {
          const e22 = this.gl;
          return [0, 0, e22.drawingBufferWidth, e22.drawingBufferHeight];
        }
        set(e22) {
          const t22 = this.current;
          (e22[0] !== t22[0] || e22[1] !== t22[1] || e22[2] !== t22[2] || e22[3] !== t22[3] || this.dirty) && (this.gl.viewport(e22[0], e22[1], e22[2], e22[3]), this.current = e22, this.dirty = false);
        }
      }
      class vs extends Xo {
        getDefault() {
          return null;
        }
        set(e22) {
          if (e22 === this.current && !this.dirty) return;
          const t22 = this.gl;
          t22.bindFramebuffer(t22.FRAMEBUFFER, e22), this.current = e22, this.dirty = false;
        }
      }
      class ys extends Xo {
        getDefault() {
          return null;
        }
        set(e22) {
          if (e22 === this.current && !this.dirty) return;
          const t22 = this.gl;
          t22.bindRenderbuffer(t22.RENDERBUFFER, e22), this.current = e22, this.dirty = false;
        }
      }
      class xs extends Xo {
        getDefault() {
          return null;
        }
        set(e22) {
          if (e22 === this.current && !this.dirty) return;
          const t22 = this.gl;
          t22.bindTexture(t22.TEXTURE_2D, e22), this.current = e22, this.dirty = false;
        }
      }
      class bs extends Xo {
        getDefault() {
          return null;
        }
        set(e22) {
          if (e22 === this.current && !this.dirty) return;
          const t22 = this.gl;
          t22.bindBuffer(t22.ARRAY_BUFFER, e22), this.current = e22, this.dirty = false;
        }
      }
      class ws extends Xo {
        getDefault() {
          return null;
        }
        set(e22) {
          const t22 = this.gl;
          t22.bindBuffer(t22.ELEMENT_ARRAY_BUFFER, e22), this.current = e22, this.dirty = false;
        }
      }
      class Ts extends Xo {
        getDefault() {
          return null;
        }
        set(e22) {
          this.gl && (e22 !== this.current || this.dirty) && (this.gl.bindVertexArray(e22), this.current = e22, this.dirty = false);
        }
      }
      class Es extends Xo {
        getDefault() {
          return 4;
        }
        set(e22) {
          if (e22 === this.current && !this.dirty) return;
          const t22 = this.gl;
          t22.pixelStorei(t22.UNPACK_ALIGNMENT, e22), this.current = e22, this.dirty = false;
        }
      }
      class Ss extends Xo {
        getDefault() {
          return false;
        }
        set(e22) {
          if (e22 === this.current && !this.dirty) return;
          const t22 = this.gl;
          t22.pixelStorei(t22.UNPACK_PREMULTIPLY_ALPHA_WEBGL, e22), this.current = e22, this.dirty = false;
        }
      }
      class Is extends Xo {
        getDefault() {
          return false;
        }
        set(e22) {
          if (e22 === this.current && !this.dirty) return;
          const t22 = this.gl;
          t22.pixelStorei(t22.UNPACK_FLIP_Y_WEBGL, e22), this.current = e22, this.dirty = false;
        }
      }
      class Cs extends Xo {
        constructor(e22, t22) {
          super(e22), this.context = e22, this.parent = t22;
        }
        getDefault() {
          return null;
        }
      }
      class Rs extends Cs {
        setDirty() {
          this.dirty = true;
        }
        set(e22) {
          if (e22 === this.current && !this.dirty) return;
          this.context.bindFramebuffer.set(this.parent);
          const t22 = this.gl;
          t22.framebufferTexture2D(t22.FRAMEBUFFER, t22.COLOR_ATTACHMENT0, t22.TEXTURE_2D, e22, 0), this.current = e22, this.dirty = false;
        }
      }
      class Ds extends Cs {
        attachment() {
          return this.gl.DEPTH_ATTACHMENT;
        }
        set(e22) {
          if (e22 === this.current && !this.dirty) return;
          this.context.bindFramebuffer.set(this.parent);
          const t22 = this.gl;
          t22.framebufferRenderbuffer(t22.FRAMEBUFFER, this.attachment(), t22.RENDERBUFFER, e22), this.current = e22, this.dirty = false;
        }
      }
      class As extends Cs {
        attachment() {
          return this.gl.DEPTH_ATTACHMENT;
        }
        set(e22) {
          if (e22 === this.current && !this.dirty) return;
          this.context.bindFramebuffer.set(this.parent);
          const t22 = this.gl;
          t22.framebufferTexture2D(t22.FRAMEBUFFER, this.attachment(), t22.TEXTURE_2D, e22, 0), this.current = e22, this.dirty = false;
        }
      }
      class Ls extends Ds {
        attachment() {
          return this.gl.DEPTH_STENCIL_ATTACHMENT;
        }
      }
      const Ps = (e22, t22, i22) => ({ u_matrix: e22, u_image0: 0, u_skirt_height: t22, u_ground_shadow_factor: i22 }), zs = (e22, t22, i22, o2, s2, r22, n22, a22, l22, c22, h22, d22, u22, _22, p22, f22) => ({ u_proj_matrix: Float32Array.from(e22), u_globe_matrix: t22, u_normalize_matrix: Float32Array.from(o2), u_merc_matrix: i22, u_zoom_transition: s2, u_merc_center: r22, u_image0: 0, u_frustum_tl: n22, u_frustum_tr: a22, u_frustum_br: l22, u_frustum_bl: c22, u_globe_pos: h22, u_globe_radius: d22, u_viewport: u22, u_grid_matrix: f22 ? Float32Array.from(f22) : new Float32Array(9), u_skirt_height: _22, u_far_z_cutoff: p22 });
      function Ms(e22, t22) {
        return null != e22 && null != t22 && !(!e22.hasData() || !t22.hasData()) && null != e22.demTexture && null != t22.demTexture && e22.tileID.key !== t22.tileID.key;
      }
      const Os = new class {
        constructor() {
          this.operations = {};
        }
        newMorphing(e22, t22, i22, o2, s2) {
          if (e22 in this.operations) {
            const t3 = this.operations[e22];
            t3.to.tileID.key !== i22.tileID.key && (t3.queued = i22);
          } else this.operations[e22] = { startTime: o2, phase: 0, duration: s2, from: t22, to: i22, queued: null };
        }
        getMorphValuesForProxy(e22) {
          if (!(e22 in this.operations)) return null;
          const t22 = this.operations[e22];
          return { from: t22.from, to: t22.to, phase: t22.phase };
        }
        update(e22) {
          for (const t22 in this.operations) {
            const i22 = this.operations[t22];
            for (i22.phase = (e22 - i22.startTime) / i22.duration; i22.phase >= 1 || !this._validOp(i22); ) if (!this._nextOp(i22, e22)) {
              delete this.operations[t22];
              break;
            }
          }
        }
        _nextOp(e22, t22) {
          return !!e22.queued && (e22.from = e22.to, e22.to = e22.queued, e22.queued = null, e22.phase = 0, e22.startTime = t22, true);
        }
        _validOp(e22) {
          return e22.from.hasData() && e22.to.hasData();
        }
      }(), Fs = { 0: null, 1: "TERRAIN_VERTEX_MORPHING" };
      function Bs(e22, t22, i22) {
        if (0 === t22) return 0;
        const o2 = t22 < 1 && 514 === i22 ? 0.25 / t22 : 1;
        return 6 * Math.pow(1.5, 22 - e22) * Math.max(t22, 1) * o2;
      }
      function ks(e22, t22) {
        const i22 = 1 << e22.z;
        return !t22 && (0 === e22.x || e22.x === i22 - 1) || 0 === e22.y || e22.y === i22 - 1;
      }
      const Ns = (e22) => ({ u_matrix: e22 });
      function Us(t22, i22, o2, s2, r22) {
        if (r22 > 0) {
          const n22 = e2.q.now(), a22 = (n22 - t22.timeAdded) / r22, l22 = i22 ? (n22 - i22.timeAdded) / r22 : -1, c22 = o2.getSource(), h22 = s2.coveringZoomLevel({ tileSize: c22.tileSize, roundZoom: c22.roundZoom }), d22 = !i22 || Math.abs(i22.tileID.overscaledZ - h22) > Math.abs(t22.tileID.overscaledZ - h22), u22 = d22 && t22.refreshedUponExpiration ? 1 : e2.aD(d22 ? a22 : 1 - l22, 0, 1);
          return t22.refreshedUponExpiration && a22 >= 1 && (t22.refreshedUponExpiration = false), i22 ? { opacity: 1, mix: 1 - u22 } : { opacity: u22, mix: 0 };
        }
        return { opacity: 1, mix: 0 };
      }
      class js extends It2 {
        constructor(t22) {
          const i22 = { type: "raster-dem", maxzoom: t22.transform.maxZoom }, o2 = new e2.D(e2.d0(), null), s2 = nt("mock-dem", i22, o2, t22.style);
          super("mock-dem", s2, false), s2.setEventedParent(this), this._sourceLoaded = true;
        }
        _loadTile(e22, t22) {
          e22.state = "loaded", t22(null);
        }
      }
      class Vs extends It2 {
        constructor(t22) {
          const i22 = nt("proxy", { type: "geojson", maxzoom: t22.transform.maxZoom }, new e2.D(e2.d0(), null), t22.style);
          super("proxy", i22, false), i22.setEventedParent(this), this.map = this.getSource().map = t22, this.used = this._sourceLoaded = true, this.renderCache = [], this.renderCachePool = [], this.proxyCachedFBO = {};
        }
        update(e22, t22, i22) {
          if (e22.freezeTileCoverage) return;
          this.transform = e22;
          const o2 = e22.coveringTiles({ tileSize: this._source.tileSize, minzoom: this._source.minzoom, maxzoom: this._source.maxzoom, roundZoom: this._source.roundZoom, reparseOverscaled: this._source.reparseOverscaled }).reduce((t3, i3) => {
            if (t3[i3.key] = "", !this._tiles[i3.key]) {
              const t4 = new wt(i3, this._source.tileSize * i3.overscaleFactor(), e22.tileZoom);
              t4.state = "loaded", this._tiles[i3.key] = t4;
            }
            return t3;
          }, {});
          for (const e3 in this._tiles) e3 in o2 || (this.freeFBO(e3), this._tiles[e3].unloadVectorData(), delete this._tiles[e3]);
        }
        freeFBO(e22) {
          const t22 = this.proxyCachedFBO[e22];
          if (void 0 !== t22) {
            const i22 = Object.values(t22);
            this.renderCachePool.push(...i22), delete this.proxyCachedFBO[e22];
          }
        }
        deallocRenderCache() {
          this.renderCache.forEach((e22) => e22.fb.destroy()), this.renderCache = [], this.renderCachePool = [], this.proxyCachedFBO = {};
        }
      }
      class Gs extends e2.aM {
        constructor(e22, t22, i22) {
          super(e22.overscaledZ, e22.wrap, e22.canonical.z, e22.canonical.x, e22.canonical.y), this.proxyTileKey = t22, this.projMatrix = i22;
        }
      }
      class qs extends e2.dt {
        constructor(t22, i22) {
          super(), this._debugParams = { sortTilesHiZFirst: true, disableRenderCache: false }, t22.tp.registerParameter(this._debugParams, ["Terrain"], "sortTilesHiZFirst", {}, () => {
            this._style.map.triggerRepaint();
          }), t22.tp.registerParameter(this._debugParams, ["Terrain"], "disableRenderCache", {}, () => {
            this._style.map.triggerRepaint();
          }), t22.tp.registerButton(["Terrain"], "Invalidate Render Cache", () => {
            this.invalidateRenderCache = true, this._style.map.triggerRepaint();
          }), this.painter = t22, this.terrainTileForTile = {}, this.prevTerrainTileForTile = {};
          const [o2, s2, r22] = function(t3) {
            const i3 = new e2.ba(), o3 = new e2.a_(), s3 = 131;
            i3.reserve(17161), o3.reserve(33800);
            const r3 = e2.aj / 128, n3 = e2.aj + r3 / 2, a3 = n3 + r3;
            for (let t4 = -r3; t4 < a3; t4 += r3) for (let o4 = -r3; o4 < a3; o4 += r3) {
              const s4 = o4 < 0 || o4 > n3 || t4 < 0 || t4 > n3 ? 24575 : 0, r4 = e2.aD(Math.round(o4), 0, e2.aj), a4 = e2.aD(Math.round(t4), 0, e2.aj);
              i3.emplaceBack(r4 + s4, a4);
            }
            const l22 = (e22, t4) => {
              const i4 = t4 * s3 + e22;
              o3.emplaceBack(i4 + 1, i4, i4 + s3), o3.emplaceBack(i4 + s3, i4 + s3 + 1, i4 + 1);
            };
            for (let e22 = 1; e22 < 129; e22++) for (let t4 = 1; t4 < 129; t4++) l22(t4, e22);
            return [0, 129].forEach((e22) => {
              for (let t4 = 0; t4 < 130; t4++) l22(t4, e22), l22(e22, t4);
            }), [i3, o3, 32768];
          }(), n22 = t22.context;
          this.gridBuffer = n22.createVertexBuffer(o2, e2.bc.members), this.gridIndexBuffer = n22.createIndexBuffer(s2), this.gridSegments = e2.bd.simpleSegment(0, 0, o2.length, s2.length), this.gridNoSkirtSegments = e2.bd.simpleSegment(0, 0, o2.length, r22), this.proxyCoords = [], this.proxiedCoords = {}, this._visibleDemTiles = [], this._drapedRenderBatches = [], this._sourceTilesOverlap = {}, this.proxySourceCache = new Vs(i22.map), this.orthoMatrix = e2.bz(), e2.c5(this.orthoMatrix, "globe" === this.painter.transform.projection.name ? 0.015 : 0, e2.aj, 0, e2.aj, 0, 1);
          const a22 = n22.gl;
          this._overlapStencilMode = new ji({ func: a22.GEQUAL, mask: 255 }, 0, 255, a22.KEEP, a22.KEEP, a22.REPLACE), this._previousZoom = t22.transform.zoom, this.pool = [], this._findCoveringTileCache = {}, this._tilesDirty = {}, this.style = i22, this._useVertexMorphing = true, this._exaggeration = 1, this._mockSourceCache = new js(i22.map), this._pendingGroundEffectLayers = [];
        }
        set style(e22) {
          e22.on("data", this._onStyleDataEvent.bind(this)), this._style = e22, this._style.map.on("moveend", () => {
            this._clearLineLayersFromRenderCache();
          });
        }
        update(t22, i22, o2) {
          if (t22 && t22.terrain) {
            this._style !== t22 && (this.style = t22, this._evaluationZoom = void 0);
            const s2 = t22.terrain.properties, r22 = 0 === t22.terrain.drapeRenderMode, n22 = t22.terrain.isZoomDependent();
            this._previousUpdateTimestamp = this.enabled ? this._updateTimestamp : void 0, this._updateTimestamp = e2.q.now();
            const a22 = t22.terrain && t22.terrain.scope, l22 = s2.get("source"), c22 = r22 ? this._mockSourceCache : t22.getSourceCache(l22, a22);
            if (!c22) return void e2.w(`Couldn't find terrain source "${l22}".`);
            if (this.sourceCache = c22, this._attenuationRange = t22.terrain.getAttenuationRange(), this._exaggeration = n22 ? this.calculateExaggeration(i22) : s2.get("exaggeration"), !i22.projection.requiresDraping && n22 && 0 === this._exaggeration) return void this._disable();
            this.enabled = true;
            const h22 = () => {
              this.sourceCache.used && e2.w(`Raster DEM source '${this.sourceCache.id}' is used both for terrain and as layer source.
This leads to lower resolution of hillshade. For full hillshade resolution but higher memory consumption, define another raster DEM source.`);
              const t3 = this.getScaledDemTileSize();
              this.sourceCache.update(i22, t3, true), this.resetTileLookupCache(this.sourceCache.id);
            };
            this.sourceCache.usedForTerrain || (this.resetTileLookupCache(this.sourceCache.id), this.sourceCache.usedForTerrain = true, h22(), this._initializing = true), h22(), i22.updateElevation(true, o2), this.resetTileLookupCache(this.proxySourceCache.id), this.proxySourceCache.update(i22), this._emptyDEMTextureDirty = true, this._previousZoom = i22.zoom;
          } else this._disable();
        }
        calculateExaggeration(t22) {
          if (this._attenuationRange && t22.zoom >= Math.ceil(this._attenuationRange[1])) return this._style.terrain.getExaggeration(t22.zoom);
          const i22 = this._previousCameraAltitude, o2 = t22.getFreeCameraOptions().position.z / t22.pixelsPerMeter * t22.worldSize;
          this._previousCameraAltitude = o2;
          const s2 = null != i22 ? o2 - i22 : Number.MAX_VALUE;
          if (Math.abs(s2) < 2) return this._exaggeration;
          const r22 = t22.zoom, n22 = this._style.terrain;
          if (!this._previousUpdateTimestamp) return n22.getExaggeration(r22);
          let a22 = r22 - this._previousZoom;
          const l22 = this._previousUpdateTimestamp;
          let c22 = r22;
          null != this._evaluationZoom && (c22 = this._evaluationZoom, Math.abs(r22 - c22) > 0.5 && (a22 = 0.5 * (r22 - c22 + a22)), a22 * s2 < 0 && (c22 += a22)), this._evaluationZoom = c22;
          const h22 = n22.getExaggeration(c22), d22 = h22 === n22.getExaggeration(Math.max(0, c22 - 0.1));
          if (d22 && Math.abs(h22 - this._exaggeration) < 0.01) return h22;
          let u22 = Math.min(0.1, 375e-5 * (this._updateTimestamp - l22));
          return (d22 || h22 < 0.1 || Math.abs(a22) < 1e-4) && (u22 = Math.min(0.2, 4 * u22)), e2.ai(this._exaggeration, h22, u22);
        }
        resetTileLookupCache(e22) {
          this._findCoveringTileCache[e22] = {};
        }
        attenuationRange() {
          return this._attenuationRange;
        }
        getDemUpscale() {
          return this.proxySourceCache.getSource().tileSize / 128;
        }
        getScaledDemTileSize() {
          return this.sourceCache.getSource().tileSize / 128 * this.proxySourceCache.getSource().tileSize;
        }
        _onStyleDataEvent(e22) {
          e22.coord && "source" === e22.dataType ? this._clearRenderCacheForTile(e22.sourceCacheId, e22.coord) : "style" === e22.dataType && (this.invalidateRenderCache = true, this._evaluationZoom = void 0, this._previousUpdateTimestamp = void 0, this._previousCameraAltitude = void 0);
        }
        _disable() {
          if (this.enabled && (this.enabled = false, this._emptyDEMTextureDirty = true, this._sharedDepthStencil = void 0, this._evaluationZoom = void 0, this._previousUpdateTimestamp = void 0, this.proxySourceCache.deallocRenderCache(), this._style)) for (const e22 in this._style._mergedSourceCaches) this._style._mergedSourceCaches[e22].usedForTerrain = false;
        }
        destroy() {
          this._disable(), this._emptyDEMTexture && this._emptyDEMTexture.destroy(), this.pool.forEach((e22) => e22.fb.destroy()), this.pool = [], this.framebufferCopyTexture && this.framebufferCopyTexture.destroy();
        }
        _source() {
          return this.enabled ? this.sourceCache : null;
        }
        isUsingMockSource() {
          return this.sourceCache === this._mockSourceCache;
        }
        exaggeration() {
          return this.enabled ? this._exaggeration : 0;
        }
        get visibleDemTiles() {
          return this._visibleDemTiles;
        }
        get drapeBufferSize() {
          const e22 = 2 * this.proxySourceCache.getSource().tileSize;
          return [e22, e22];
        }
        set useVertexMorphing(e22) {
          this._useVertexMorphing = e22;
        }
        updateTileBinding(t22) {
          if (!this.enabled) return;
          this.prevTerrainTileForTile = this.terrainTileForTile;
          const i22 = this.proxySourceCache, o2 = this.painter.transform;
          this._initializing && (this._initializing = 0 === o2._centerAltitude && -1 === this.getAtPointOrZero(e2.ac.fromLngLat(o2.center), -1), this._emptyDEMTextureDirty = !this._initializing);
          const s2 = this.proxyCoords = i22.getIds().map((e22) => {
            const t3 = i22.getTileByID(e22).tileID;
            return t3.projMatrix = o2.calculateProjMatrix(t3.toUnwrapped()), t3;
          });
          !function(t3, i3) {
            const o3 = i3.transform.pointCoordinate(i3.transform.getCameraPoint()), s3 = new e2.P(o3.x, o3.y);
            t3.sort((t4, i4) => {
              if (i4.overscaledZ - t4.overscaledZ) return i4.overscaledZ - t4.overscaledZ;
              const o4 = new e2.P(t4.canonical.x + (1 << t4.canonical.z) * t4.wrap, t4.canonical.y), r3 = new e2.P(i4.canonical.x + (1 << i4.canonical.z) * i4.wrap, i4.canonical.y), n3 = s3.mult(1 << t4.canonical.z);
              return n3.x -= 0.5, n3.y -= 0.5, n3.distSqr(o4) - n3.distSqr(r3);
            });
          }(s2, this.painter);
          const r22 = this.proxyToSource || {};
          this.proxyToSource = {}, s2.forEach((e22) => {
            this.proxyToSource[e22.key] = {};
          }), this.terrainTileForTile = {};
          const n22 = this._style._mergedSourceCaches;
          for (const e22 in n22) {
            const i3 = n22[e22];
            if (!i3.used) continue;
            if (i3 !== this.sourceCache && this.resetTileLookupCache(i3.id), this._setupProxiedCoordsForOrtho(i3, t22[e22], r22), i3.usedForTerrain) continue;
            const o3 = t22[e22];
            i3.getSource().reparseOverscaled && this._assignTerrainTiles(o3);
          }
          this.proxiedCoords[i22.id] = s2.map((e22) => new Gs(e22, e22.key, this.orthoMatrix)), this._assignTerrainTiles(s2), this._prepareDEMTextures(), this._setupDrapedRenderBatches(), this._initFBOPool(), this._setupRenderCache(r22), this.renderingToTexture = false;
          const a22 = {};
          this._visibleDemTiles = [];
          for (const e22 of this.proxyCoords) {
            const t3 = this.terrainTileForTile[e22.key];
            if (!t3) continue;
            const i3 = t3.tileID.key;
            i3 in a22 || (this._visibleDemTiles.push(t3), a22[i3] = i3);
          }
        }
        _assignTerrainTiles(e22) {
          this._initializing || e22.forEach((e3) => {
            if (this.terrainTileForTile[e3.key]) return;
            const t22 = this._findTileCoveringTileID(e3, this.sourceCache);
            t22 && (this.terrainTileForTile[e3.key] = t22);
          });
        }
        _prepareDEMTextures() {
          const e22 = this.painter.context, t22 = e22.gl;
          for (const i22 in this.terrainTileForTile) {
            const o2 = this.terrainTileForTile[i22], s2 = o2.dem;
            !s2 || o2.demTexture && !o2.needsDEMTextureUpload || (e22.activeTexture.set(t22.TEXTURE1), Wo(this.painter, o2, s2));
          }
        }
        _prepareDemTileUniforms(e22, t22, i22, o2) {
          if (!t22 || null == t22.demTexture) return false;
          const s2 = e22.tileID.canonical, r22 = Math.pow(2, t22.tileID.canonical.z - s2.z), n22 = o2 || "";
          return i22[`u_dem_tl${n22}`] = [s2.x * r22 % 1, s2.y * r22 % 1], i22[`u_dem_scale${n22}`] = r22, true;
        }
        get emptyDEMTexture() {
          return !this._emptyDEMTextureDirty && this._emptyDEMTexture ? this._emptyDEMTexture : this._updateEmptyDEMTexture();
        }
        _getLoadedAreaMinimum() {
          if (!this.enabled) return 0;
          let e22 = 0;
          const t22 = this._visibleDemTiles.reduce((t3, i22) => {
            if (!i22.dem) return t3;
            const o2 = i22.dem.tree.minimums[0];
            return o2 > 0 && e22++, t3 + o2;
          }, 0);
          return e22 ? t22 / e22 : 0;
        }
        _updateEmptyDEMTexture() {
          const t22 = this.painter.context, i22 = t22.gl;
          t22.activeTexture.set(i22.TEXTURE2);
          const o2 = this._getLoadedAreaMinimum(), s2 = new e2.du({ width: 1, height: 1 }, new Float32Array([o2]));
          this._emptyDEMTextureDirty = false;
          let r22 = this._emptyDEMTexture;
          return r22 ? r22.update(s2, { premultiply: false }) : r22 = this._emptyDEMTexture = new e2.T(t22, s2, i22.R32F, { premultiply: false }), r22;
        }
        setupElevationDraw(t22, i22, o2) {
          const s2 = this.painter.context, r22 = s2.gl, n22 = { u_dem: 2, u_dem_prev: 4, u_dem_tl: [0, 0], u_dem_tl_prev: [0, 0], u_dem_scale: 0, u_dem_scale_prev: 0, u_dem_size: 0, u_dem_lerp: 1, u_depth: 3, u_depth_size_inv: [0, 0], u_depth_range_unpack: [0, 1], u_occluder_half_size: 16, u_occlusion_depth_offset: -1e-4, u_exaggeration: 0 };
          n22.u_exaggeration = this.exaggeration();
          let a22 = null, l22 = null, c22 = 1;
          if (o2 && o2.morphing && this._useVertexMorphing) {
            const e22 = o2.morphing.srcDemTile, i3 = o2.morphing.dstDemTile;
            c22 = o2.morphing.phase, e22 && i3 && (this._prepareDemTileUniforms(t22, e22, n22, "_prev") && (l22 = e22), this._prepareDemTileUniforms(t22, i3, n22) && (a22 = i3));
          }
          const h22 = (e22) => e22 && e22.demTexture && this.painter.linearFloatFilteringSupported() ? r22.LINEAR : r22.NEAREST;
          let d22 = null;
          var u22;
          if (this.enabled ? l22 && a22 ? (d22 = a22.demTexture, s2.activeTexture.set(r22.TEXTURE4), l22.demTexture.bind(h22(l22), r22.CLAMP_TO_EDGE), n22.u_dem_lerp = c22) : (a22 = this.terrainTileForTile[t22.tileID.key], d22 = this._prepareDemTileUniforms(t22, a22, n22) ? a22.demTexture : this.emptyDEMTexture) : d22 = this.emptyDEMTexture, s2.activeTexture.set(r22.TEXTURE2), d22 && (n22.u_dem_size = 1 === (u22 = d22).size[0] ? 1 : u22.size[0] - 2, d22.bind(h22(a22), r22.CLAMP_TO_EDGE)), this.painter.setupDepthForOcclusion(o2 && o2.useDepthForOcclusion, i22, n22), o2 && o2.useMeterToDem && a22) {
            const t3 = (1 << a22.tileID.canonical.z) * e2.c6(1, this.painter.transform.center.lat) * this.sourceCache.getSource().tileSize;
            n22.u_meter_to_dem = t3;
          }
          if (o2 && o2.labelPlaneMatrixInv && (n22.u_label_plane_matrix_inv = o2.labelPlaneMatrixInv), i22.setTerrainUniformValues(s2, n22), "globe" === this.painter.transform.projection.name) {
            const e22 = this.globeUniformValues(this.painter.transform, t22.tileID.canonical, o2 && o2.useDenormalizedUpVectorScale);
            i22.setGlobeUniformValues(s2, e22);
          }
        }
        globeUniformValues(t22, i22, o2) {
          const s2 = t22.projection;
          return { u_tile_tl_up: s2.upVector(i22, 0, 0), u_tile_tr_up: s2.upVector(i22, e2.aj, 0), u_tile_br_up: s2.upVector(i22, e2.aj, e2.aj), u_tile_bl_up: s2.upVector(i22, 0, e2.aj), u_tile_up_scale: o2 ? e2.dv(1) : s2.upVectorScale(i22, t22.center.lat, t22.worldSize).metersToTile };
        }
        renderToBackBuffer(t22) {
          const i22 = this.painter, o2 = this.painter.context;
          0 !== t22.length && (o2.bindFramebuffer.set(null), o2.viewport.set([0, 0, i22.width, i22.height]), i22.gpuTimingDeferredRenderStart(), this.renderingToTexture = false, function(t3, i3, o3, s2, r22) {
            if ("globe" === t3.transform.projection.name) !function(t4, i4, o4, s3, r3) {
              const n22 = t4.context, a22 = n22.gl;
              let l22, c22;
              const h22 = t4.transform, d22 = e2.dl(t4, n22, h22), u22 = (e22, i5) => {
                if (c22 === i5) return;
                const o5 = [Fs[i5], "PROJECTION_GLOBE_VIEW"];
                d22 && o5.push("CUSTOM_ANTIALIASING");
                const s4 = t4.isTileAffectedByFog(e22);
                l22 = t4.getOrCreateProgram("globeRaster", { defines: o5, overrideFog: s4 }), c22 = i5;
              }, _22 = t4.colorModeForRenderPass(), p22 = new Ni(a22.LEQUAL, Ni.ReadWrite, t4.depthRangeFor3D);
              Os.update(r3);
              const f22 = e2.dm(h22), m22 = [e2.ay(h22.center.lng), e2.aH(h22.center.lat)], g22 = t4.globeSharedBuffers, v22 = [h22.width * e2.q.devicePixelRatio, h22.height * e2.q.devicePixelRatio], y22 = Float32Array.from(h22.globeMatrix), x22 = { useDenormalizedUpVectorScale: true };
              {
                const h3 = t4.transform, d3 = Bs(h3.zoom, i4.exaggeration(), i4.sourceCache._source.tileSize);
                c22 = -1;
                const b22 = a22.TRIANGLES;
                for (const c3 of s3) {
                  const s4 = o4.getTile(c3), w22 = ji.disabled, T2 = i4.prevTerrainTileForTile[c3.key], E22 = i4.terrainTileForTile[c3.key];
                  Ms(T2, E22) && Os.newMorphing(c3.key, T2, E22, r3, 250), n22.activeTexture.set(a22.TEXTURE0), s4.texture && s4.texture.bind(a22.LINEAR, a22.CLAMP_TO_EDGE);
                  const S2 = Os.getMorphValuesForProxy(c3.key), I2 = S2 ? 1 : 0;
                  S2 && e2.L(x22, { morphing: { srcDemTile: S2.from, dstDemTile: S2.to, phase: e2.dk(S2.phase) } });
                  const C22 = e2.dn(c3.canonical), R22 = e2.dp(C22.getCenter().lat), D22 = e2.dq(c3.canonical, C22, R22, h3.worldSize / h3._pixelsPerMercatorPixel), A22 = e2.bh(e2.dr(c3.canonical)), L22 = zs(h3.expandedFarZProjMatrix, y22, f22, A22, e2.ah(h3.zoom), m22, h3.frustumCorners.TL, h3.frustumCorners.TR, h3.frustumCorners.BR, h3.frustumCorners.BL, h3.globeCenterInViewSpace, h3.globeRadius, v22, d3, h3._farZ, D22);
                  if (u22(c3, I2), l22 && (i4.setupElevationDraw(s4, l22, x22), t4.uploadCommonUniforms(n22, l22, c3.toUnwrapped()), g22)) {
                    const [e22, i5, o5] = g22.getGridBuffers(R22, 0 !== d3);
                    l22.draw(t4, b22, p22, w22, _22, qi.backCCW, L22, "globe_raster", e22, i5, o5);
                  }
                }
              }
              if (g22 && (t4.renderDefaultNorthPole || t4.renderDefaultSouthPole)) {
                const r4 = ["GLOBE_POLES", "PROJECTION_GLOBE_VIEW"];
                d22 && r4.push("CUSTOM_ANTIALIASING"), l22 = t4.getOrCreateProgram("globeRaster", { defines: r4 });
                for (const r5 of s3) {
                  const { x: s4, y: c3, z: d3 } = r5.canonical, u3 = 0 === c3, f3 = c3 === (1 << d3) - 1, [y3, b22, w22, T2] = g22.getPoleBuffers(d3, false);
                  if (T2 && (u3 || f3)) {
                    const c4 = o4.getTile(r5);
                    n22.activeTexture.set(a22.TEXTURE0), c4.texture && c4.texture.bind(a22.LINEAR, a22.CLAMP_TO_EDGE);
                    let g3 = e2.ds(d3, s4, h22);
                    const E22 = e2.bh(e2.dr(r5.canonical)), S2 = (e22, i5) => e22.draw(t4, a22.TRIANGLES, p22, ji.disabled, _22, qi.disabled, zs(h22.expandedFarZProjMatrix, g3, g3, E22, 0, m22, h22.frustumCorners.TL, h22.frustumCorners.TR, h22.frustumCorners.BR, h22.frustumCorners.BL, h22.globeCenterInViewSpace, h22.globeRadius, v22, 0, h22._farZ), "globe_pole_raster", i5, w22, T2);
                    i4.setupElevationDraw(c4, l22, x22), t4.uploadCommonUniforms(n22, l22, r5.toUnwrapped()), u3 && t4.renderDefaultNorthPole && S2(l22, y3), f3 && t4.renderDefaultSouthPole && (g3 = e2.cE(e2.bz(), g3, [1, -1, 1]), S2(l22, b22));
                  }
                }
              }
            }(t3, i3, o3, s2, r22);
            else {
              const n22 = t3.context, a22 = n22.gl;
              let l22, c22;
              const h22 = t3.shadowRenderer, d22 = eo(t3, t3.longestCutoffRange), u22 = (e22) => {
                if (c22 === e22) return;
                const i4 = [];
                i4.push(Fs[e22]), d22.shouldRenderCutoff && i4.push("RENDER_CUTOFF"), h22 && (i4.push("RENDER_SHADOWS", "DEPTH_TEXTURE"), h22.useNormalOffset && i4.push("NORMAL_OFFSET")), l22 = t3.getOrCreateProgram("terrainRaster", { defines: i4 }), c22 = e22;
              }, _22 = t3.colorModeForRenderPass(), p22 = new Ni(a22.LEQUAL, Ni.ReadWrite, t3.depthRangeFor3D);
              Os.update(r22);
              const f22 = t3.transform, m22 = Bs(f22.zoom, i3.exaggeration(), i3.sourceCache._source.tileSize);
              let g22 = [0, 0, 0];
              if (h22) {
                const e22 = t3.style.directionalLight, i4 = t3.style.ambientLight;
                e22 && i4 && (g22 = ao(t3.style, e22, i4));
              }
              {
                c22 = -1;
                const v22 = a22.TRIANGLES, [y22, x22] = [i3.gridIndexBuffer, i3.gridSegments];
                for (const c3 of s2) {
                  const s3 = o3.getTile(c3), b22 = ji.disabled, w22 = i3.prevTerrainTileForTile[c3.key], T2 = i3.terrainTileForTile[c3.key];
                  Ms(w22, T2) && Os.newMorphing(c3.key, w22, T2, r22, 250), n22.activeTexture.set(a22.TEXTURE0), s3.texture && s3.texture.bind(a22.LINEAR, a22.CLAMP_TO_EDGE);
                  const E22 = Os.getMorphValuesForProxy(c3.key), S2 = E22 ? 1 : 0;
                  let I2;
                  E22 && (I2 = { morphing: { srcDemTile: E22.from, dstDemTile: E22.to, phase: e2.dk(E22.phase) } });
                  const C22 = Ps(c3.projMatrix, ks(c3.canonical, f22.renderWorldCopies) ? m22 / 10 : m22, g22);
                  if (u22(S2), !l22) continue;
                  i3.setupElevationDraw(s3, l22, I2);
                  const R22 = c3.toUnwrapped();
                  h22 && h22.setupShadows(R22, l22), t3.uploadCommonUniforms(n22, l22, R22, null, d22), l22.draw(t3, v22, p22, b22, _22, qi.backCCW, C22, "terrain_raster", i3.gridBuffer, y22, x22);
                }
              }
            }
          }(i22, this, this.proxySourceCache, t22, this._updateTimestamp), this.renderingToTexture = true, i22.gpuTimingDeferredRenderEnd(), t22.splice(0, t22.length));
        }
        renderBatch(t22) {
          if (0 === this._drapedRenderBatches.length) return t22 + 1;
          this.renderingToTexture = true;
          const i22 = this.painter, o2 = this.painter.context, s2 = this.proxySourceCache, r22 = this.proxiedCoords[s2.id], n22 = this._drapedRenderBatches.shift(), a22 = i22.style.order, l22 = [];
          let c22 = 0;
          for (const h22 of r22) {
            const r3 = s2.getTileByID(h22.proxyTileKey), d22 = s2.proxyCachedFBO[h22.key] ? s2.proxyCachedFBO[h22.key][t22] : void 0, u22 = void 0 !== d22 ? s2.renderCache[d22] : this.pool[c22++], _22 = void 0 !== d22;
            if (r3.texture = u22.tex, _22 && !u22.dirty) {
              l22.push(r3.tileID);
              continue;
            }
            let p22;
            o2.bindFramebuffer.set(u22.fb.framebuffer), this.renderedToTile = false, u22.dirty && (o2.clear({ color: e2.am.transparent, stencil: 0 }), u22.dirty = false);
            for (let e22 = n22.start; e22 <= n22.end; ++e22) {
              const t3 = i22.style._mergedLayers[a22[e22]];
              if (t3.isHidden(i22.transform.zoom)) continue;
              const s3 = i22.style.getLayerSourceCache(t3), r4 = s3 ? this.proxyToSource[h22.key][s3.id] : [h22];
              if (!r4) continue;
              const n3 = r4;
              o2.viewport.set([0, 0, u22.fb.width, u22.fb.height]), p22 !== (s3 ? s3.id : null) && (this._setupStencil(u22, r4, t3, s3), p22 = s3 ? s3.id : null), i22.renderLayer(i22, s3, t3, n3);
            }
            if (0 === this._drapedRenderBatches.length) for (const e22 of this._pendingGroundEffectLayers) {
              const t3 = i22.style._mergedLayers[a22[e22]];
              if (t3.isHidden(i22.transform.zoom)) continue;
              const s3 = i22.style.getLayerSourceCache(t3), r4 = s3 ? this.proxyToSource[h22.key][s3.id] : [h22];
              if (!r4) continue;
              const n3 = r4;
              o2.viewport.set([0, 0, u22.fb.width, u22.fb.height]), p22 !== (s3 ? s3.id : null) && (this._setupStencil(u22, r4, t3, s3), p22 = s3 ? s3.id : null), i22.renderLayer(i22, s3, t3, n3);
            }
            this.renderedToTile ? (u22.dirty = true, l22.push(r3.tileID)) : _22 || --c22, 5 === c22 && (c22 = 0, this.renderToBackBuffer(l22));
          }
          return this.renderToBackBuffer(l22), this.renderingToTexture = false, o2.bindFramebuffer.set(null), o2.viewport.set([0, 0, i22.width, i22.height]), n22.end + 1;
        }
        postRender() {
        }
        isLayerOrderingCorrect(e22) {
          const t22 = e22.order.length;
          let i22 = -1, o2 = t22;
          for (let s2 = 0; s2 < t22; ++s2) this._style.isLayerDraped(e22._mergedLayers[e22.order[s2]]) ? i22 = Math.max(i22, s2) : o2 = Math.min(o2, s2);
          return o2 > i22;
        }
        getMinElevationBelowMSL() {
          let e22 = 0;
          return this._visibleDemTiles.filter((e3) => e3.dem).forEach((t22) => {
            e22 = Math.min(e22, t22.dem.tree.minimums[0]);
          }), 0 === e22 ? e22 : (e22 - 30) * this._exaggeration;
        }
        raycast(e22, t22, i22) {
          if (!this._visibleDemTiles) return null;
          const o2 = this._visibleDemTiles.filter((e3) => e3.dem).map((o3) => {
            const s2 = o3.tileID, r22 = 1 << s2.overscaledZ, { x: n22, y: a22 } = s2.canonical, l22 = n22 / r22, c22 = (n22 + 1) / r22, h22 = a22 / r22, d22 = (a22 + 1) / r22;
            return { minx: l22, miny: h22, maxx: c22, maxy: d22, t: o3.dem.tree.raycastRoot(l22, h22, c22, d22, e22, t22, i22), tile: o3 };
          });
          o2.sort((e3, t3) => (null !== e3.t ? e3.t : Number.MAX_VALUE) - (null !== t3.t ? t3.t : Number.MAX_VALUE));
          for (const s2 of o2) {
            if (null == s2.t) return null;
            const o3 = s2.tile.dem.tree.raycast(s2.minx, s2.miny, s2.maxx, s2.maxy, e22, t22, i22);
            if (null != o3) return o3;
          }
          return null;
        }
        _createFBO() {
          const t22 = this.painter.context, i22 = t22.gl, o2 = this.drapeBufferSize;
          t22.activeTexture.set(i22.TEXTURE0);
          const s2 = new e2.T(t22, { width: o2[0], height: o2[1], data: null }, i22.RGBA8);
          s2.bind(i22.LINEAR, i22.CLAMP_TO_EDGE);
          const r22 = t22.createFramebuffer(o2[0], o2[1], true, null);
          return r22.colorAttachment.set(s2.texture), r22.depthAttachment = new Ls(t22, r22.framebuffer), void 0 === this._sharedDepthStencil ? (this._sharedDepthStencil = t22.createRenderbuffer(t22.gl.DEPTH_STENCIL, o2[0], o2[1]), this._stencilRef = 0, r22.depthAttachment.set(this._sharedDepthStencil), t22.clear({ stencil: 0 })) : r22.depthAttachment.set(this._sharedDepthStencil), t22.extTextureFilterAnisotropic && i22.texParameterf(i22.TEXTURE_2D, t22.extTextureFilterAnisotropic.TEXTURE_MAX_ANISOTROPY_EXT, t22.extTextureFilterAnisotropicMax), { fb: r22, tex: s2, dirty: false };
        }
        _initFBOPool() {
          for (; this.pool.length < Math.min(5, this.proxyCoords.length); ) this.pool.push(this._createFBO());
        }
        _shouldDisableRenderCache() {
          if (this._debugParams.disableRenderCache) return true;
          if (this._style.hasLightTransitions()) return true;
          for (const e22 in this._style._mergedSourceCaches) if (this._style._mergedSourceCaches[e22].hasTransition()) return true;
          return this._style.order.some((e22) => {
            const t22 = this._style._mergedLayers[e22], i22 = t22.isHidden(this.painter.transform.zoom);
            return "hillshade" === t22.type || "custom" === t22.type ? !i22 && t22.shouldRedrape() : !i22 && t22.hasTransition();
          });
        }
        _clearLineLayersFromRenderCache() {
          let t22 = false;
          for (const e22 of this._style.getSources()) if (e22 instanceof it) {
            t22 = true;
            break;
          }
          if (!t22) return;
          const i22 = {};
          for (let t3 = 0; t3 < this._style.order.length; ++t3) {
            const o2 = this._style._mergedLayers[this._style.order[t3]], s2 = this._style.getLayerSourceCache(o2);
            if (s2 && !i22[s2.id] && !o2.isHidden(this.painter.transform.zoom) && "line" === o2.type && o2.widthExpression() instanceof e2.ab) {
              i22[s2.id] = true;
              for (const e22 of this.proxyCoords) {
                const t4 = this.proxyToSource[e22.key][s2.id];
                if (t4) for (const e3 of t4) this._clearRenderCacheForTile(s2.id, e3);
              }
            }
          }
        }
        _clearRasterLayersFromRenderCache() {
          let e22 = false;
          for (const t3 in this._style._mergedSourceCaches) if (this._style._mergedSourceCaches[t3]._source instanceof ot) {
            e22 = true;
            break;
          }
          if (!e22) return;
          const t22 = {};
          for (let e3 = 0; e3 < this._style.order.length; ++e3) {
            const i22 = this._style._mergedLayers[this._style.order[e3]], o2 = this._style.getLayerSourceCache(i22);
            if (!o2 || t22[o2.id]) continue;
            if (i22.isHidden(this.painter.transform.zoom) || "raster" !== i22.type) continue;
            const s2 = i22.paint.get("raster-fade-duration");
            for (const e4 of this.proxyCoords) {
              const t3 = this.proxyToSource[e4.key][o2.id];
              if (t3) for (const e5 of t3) {
                const t4 = Us(o2.getTile(e5), o2.findLoadedParent(e5, 0), o2, this.painter.transform, s2);
                (1 !== t4.opacity || 0 !== t4.mix) && this._clearRenderCacheForTile(o2.id, e5);
              }
            }
          }
        }
        _setupDrapedRenderBatches() {
          this._style.updateDrapeFirstLayers();
          const t22 = this._style.order, i22 = t22.length;
          if (0 === i22) return;
          const o2 = [];
          this._pendingGroundEffectLayers = [];
          let s2, r22 = 0, n22 = this._style._mergedLayers[t22[r22]];
          for (; !this._style.isLayerDraped(n22) && n22.isHidden(this.painter.transform.zoom) && ++r22 < i22; ) n22 = this._style._mergedLayers[t22[r22]];
          for (; r22 < i22; ++r22) {
            const e22 = this._style._mergedLayers[t22[r22]];
            e22.isHidden(this.painter.transform.zoom) || (this._style.isLayerDraped(e22) ? void 0 === s2 && (s2 = r22) : ("fill-extrusion" === e22.type && this._pendingGroundEffectLayers.push(r22), void 0 !== s2 && (o2.push({ start: s2, end: r22 - 1 }), s2 = void 0)));
          }
          if (void 0 !== s2 && o2.push({ start: s2, end: r22 - 1 }), 0 !== o2.length) {
            const t3 = o2[o2.length - 1];
            this._pendingGroundEffectLayers.every((e22) => e22 > t3.end) || e2.w("fill-extrusion with flood lighting and/or ground ambient occlusion should be moved to be on top of all draped layers.");
          }
          this._drapedRenderBatches = o2;
        }
        _setupRenderCache(e22) {
          const t22 = this.proxySourceCache;
          if (this._shouldDisableRenderCache() || this.invalidateRenderCache) {
            if (this.invalidateRenderCache = false, t22.renderCache.length > t22.renderCachePool.length) {
              const e3 = Object.values(t22.proxyCachedFBO);
              t22.proxyCachedFBO = {};
              for (let i3 = 0; i3 < e3.length; ++i3) {
                const o3 = Object.values(e3[i3]);
                t22.renderCachePool.push(...o3);
              }
            }
            return;
          }
          this._clearRasterLayersFromRenderCache();
          const i22 = this.proxyCoords, o2 = this._tilesDirty;
          for (let s3 = i22.length - 1; s3 >= 0; s3--) {
            const r22 = i22[s3];
            if (t22.getTileByID(r22.key), void 0 !== t22.proxyCachedFBO[r22.key]) {
              const i3 = e22[r22.key], s4 = this.proxyToSource[r22.key];
              let n22 = 0;
              for (const e3 in s4) {
                const t3 = s4[e3], r3 = i3[e3];
                if (!r3 || r3.length !== t3.length || t3.some((t4, i4) => t4 !== r3[i4] || o2[e3] && o2[e3].hasOwnProperty(t4.key))) {
                  n22 = -1;
                  break;
                }
                ++n22;
              }
              for (const e3 in t22.proxyCachedFBO[r22.key]) t22.renderCache[t22.proxyCachedFBO[r22.key][e3]].dirty = n22 < 0 || n22 !== Object.values(i3).length;
            }
          }
          const s2 = [...this._drapedRenderBatches];
          s2.sort((e3, t3) => t3.end - t3.start - (e3.end - e3.start));
          for (const e3 of s2) for (const o3 of i22) {
            if (t22.proxyCachedFBO[o3.key]) continue;
            let i3 = t22.renderCachePool.pop();
            void 0 === i3 && t22.renderCache.length < 50 && (i3 = t22.renderCache.length, t22.renderCache.push(this._createFBO())), void 0 !== i3 && (t22.proxyCachedFBO[o3.key] = {}, t22.proxyCachedFBO[o3.key][e3.start] = i3, t22.renderCache[i3].dirty = true);
          }
          this._tilesDirty = {};
        }
        _setupStencil(e22, t22, i22, o2) {
          if (!o2 || !this._sourceTilesOverlap[o2.id]) return void (this._overlapStencilType && (this._overlapStencilType = false));
          const s2 = this.painter.context, r22 = s2.gl;
          if (t22.length <= 1) return void (this._overlapStencilType = false);
          let n22;
          if (i22.isTileClipped()) n22 = t22.length, this._overlapStencilMode.test = { func: r22.EQUAL, mask: 255 }, this._overlapStencilType = "Clip";
          else {
            if (!(t22[0].overscaledZ > t22[t22.length - 1].overscaledZ)) return void (this._overlapStencilType = false);
            n22 = 1, this._overlapStencilMode.test = { func: r22.GREATER, mask: 255 }, this._overlapStencilType = "Mask";
          }
          this._stencilRef + n22 > 255 && (s2.clear({ stencil: 0 }), this._stencilRef = 0), this._stencilRef += n22, this._overlapStencilMode.ref = this._stencilRef, i22.isTileClipped() && this._renderTileClippingMasks(t22, this._overlapStencilMode.ref);
        }
        clipOrMaskOverlapStencilType() {
          return "Clip" === this._overlapStencilType || "Mask" === this._overlapStencilType;
        }
        stencilModeForRTTOverlap(e22) {
          return this.renderingToTexture && this._overlapStencilType ? ("Clip" === this._overlapStencilType && (this._overlapStencilMode.ref = this.painter._tileClippingMaskIDs[e22.key]), this._overlapStencilMode) : ji.disabled;
        }
        _renderTileClippingMasks(e22, t22) {
          const i22 = this.painter, o2 = this.painter.context, s2 = o2.gl;
          i22._tileClippingMaskIDs = {}, o2.setColorMode(ki.disabled), o2.setDepthMode(Ni.disabled);
          const r22 = i22.getOrCreateProgram("clippingMask");
          for (const o3 of e22) {
            const e3 = i22._tileClippingMaskIDs[o3.key] = --t22;
            r22.draw(i22, s2.TRIANGLES, Ni.disabled, new ji({ func: s2.ALWAYS, mask: 0 }, e3, 255, s2.KEEP, s2.KEEP, s2.REPLACE), ki.disabled, qi.disabled, Ns(o3.projMatrix), "$clipping", i22.tileExtentBuffer, i22.quadTriangleIndexBuffer, i22.tileExtentSegments);
          }
        }
        pointCoordinate(t22) {
          const i22 = this.painter.transform;
          if (t22.x < 0 || t22.x > i22.width || t22.y < 0 || t22.y > i22.height) return null;
          const o2 = [t22.x, t22.y, 1, 1];
          e2.aA(o2, o2, i22.pixelMatrixInverse), e2.cw(o2, o2, 1 / o2[3]), o2[0] /= i22.worldSize, o2[1] /= i22.worldSize;
          const s2 = i22._camera.position, r22 = e2.c6(1, i22.center.lat), n22 = [s2[0], s2[1], s2[2] / r22, 0], a22 = e2.cY([], o2.slice(0, 3), n22);
          e2.au(a22, a22);
          const l22 = this.raycast(n22, a22, this._exaggeration);
          return null !== l22 && l22 ? (e2.bF(n22, n22, a22, l22), n22[3] = n22[2], n22[2] *= r22, n22) : null;
        }
        _setupProxiedCoordsForOrtho(t22, i22, o2) {
          if (t22.getSource() instanceof e2.aP) return this._setupProxiedCoordsForImageSource(t22, i22, o2);
          this._findCoveringTileCache[t22.id] = this._findCoveringTileCache[t22.id] || {};
          const s2 = this.proxiedCoords[t22.id] = [], r22 = this.proxyCoords;
          for (let e22 = 0; e22 < r22.length; e22++) {
            const i3 = r22[e22], n3 = this._findTileCoveringTileID(i3, t22);
            if (n3) {
              const e3 = this._createProxiedId(i3, n3, o2[i3.key] && o2[i3.key][t22.id]);
              s2.push(e3), this.proxyToSource[i3.key][t22.id] = [e3];
            }
          }
          let n22 = false;
          const a22 = /* @__PURE__ */ new Set();
          for (let e22 = 0; e22 < i22.length; e22++) {
            const r3 = t22.getTile(i22[e22]);
            if (!r3 || !r3.hasData()) continue;
            const l22 = this._findTileCoveringTileID(r3.tileID, this.proxySourceCache);
            if (l22 && l22.tileID.canonical.z !== r3.tileID.canonical.z) {
              const e3 = this.proxyToSource[l22.tileID.key][t22.id], i3 = this._createProxiedId(l22.tileID, r3, o2[l22.tileID.key] && o2[l22.tileID.key][t22.id]);
              e3 ? e3.splice(e3.length - 1, 0, i3) : this.proxyToSource[l22.tileID.key][t22.id] = [i3];
              const c22 = this.proxyToSource[l22.tileID.key][t22.id];
              a22.has(c22) || a22.add(c22), s2.push(i3), n22 = true;
            }
          }
          if (this._sourceTilesOverlap[t22.id] = n22, n22 && this._debugParams.sortTilesHiZFirst) for (const e22 of a22) e22.sort((e3, t3) => t3.overscaledZ - e3.overscaledZ);
        }
        _setupProxiedCoordsForImageSource(t22, i22, o2) {
          if (!t22.getSource().loaded()) return;
          const s2 = this.proxiedCoords[t22.id] = [], r22 = this.proxyCoords, n22 = t22.getSource(), a22 = n22.tileID;
          if (!a22) return;
          const l22 = new e2.P(a22.x, a22.y)._div(1 << a22.z), c22 = n22.coordinates.map(e2.ac.fromLngLat).reduce((e22, t3) => (e22.min.x = Math.min(e22.min.x, t3.x - l22.x), e22.min.y = Math.min(e22.min.y, t3.y - l22.y), e22.max.x = Math.max(e22.max.x, t3.x - l22.x), e22.max.y = Math.max(e22.max.y, t3.y - l22.y), e22), { min: new e2.P(Number.MAX_VALUE, Number.MAX_VALUE), max: new e2.P(-Number.MAX_VALUE, -Number.MAX_VALUE) }), h22 = (t3, i3) => {
            const o3 = t3.wrap + t3.canonical.x / (1 << t3.canonical.z), s3 = t3.canonical.y / (1 << t3.canonical.z), r3 = e2.aj / (1 << t3.canonical.z), n3 = i3.wrap + i3.canonical.x / (1 << i3.canonical.z), a3 = i3.canonical.y / (1 << i3.canonical.z);
            return o3 + r3 < n3 + c22.min.x || o3 > n3 + c22.max.x || s3 + r3 < a3 + c22.min.y || s3 > a3 + c22.max.y;
          };
          for (let e22 = 0; e22 < r22.length; e22++) {
            const n3 = r22[e22];
            for (let e3 = 0; e3 < i22.length; e3++) {
              const r3 = t22.getTile(i22[e3]);
              if (!r3 || !r3.hasData()) continue;
              if (h22(n3, r3.tileID)) continue;
              const a3 = this._createProxiedId(n3, r3, o2[n3.key] && o2[n3.key][t22.id]), l3 = this.proxyToSource[n3.key][t22.id];
              l3 ? l3.push(a3) : this.proxyToSource[n3.key][t22.id] = [a3], s2.push(a3);
            }
          }
        }
        _createProxiedId(t22, i22, o2) {
          let s2 = this.orthoMatrix;
          if (o2) {
            const e22 = o2.find((e3) => e3.key === i22.tileID.key);
            if (e22) return e22;
          }
          if (i22.tileID.key !== t22.key) {
            const o3 = t22.canonical.z - i22.tileID.canonical.z;
            let r22, n22, a22;
            s2 = e2.bz();
            const l22 = i22.tileID.wrap - t22.wrap << t22.overscaledZ;
            o3 > 0 ? (r22 = e2.aj >> o3, n22 = r22 * ((i22.tileID.canonical.x << o3) - t22.canonical.x + l22), a22 = r22 * ((i22.tileID.canonical.y << o3) - t22.canonical.y)) : (r22 = e2.aj << -o3, n22 = e2.aj * (i22.tileID.canonical.x - (t22.canonical.x + l22 << -o3)), a22 = e2.aj * (i22.tileID.canonical.y - (t22.canonical.y << -o3))), e2.c5(s2, 0, r22, 0, r22, 0, 1), e2.bo(s2, s2, [n22, a22, 0]);
          }
          return new Gs(i22.tileID, t22.key, s2);
        }
        _findTileCoveringTileID(t22, i22) {
          let o2 = i22.getTile(t22);
          if (o2 && o2.hasData()) return o2;
          const s2 = this._findCoveringTileCache[i22.id], r22 = s2[t22.key];
          if (o2 = r22 ? i22.getTileByID(r22) : null, o2 && o2.hasData() || null === r22) return o2;
          let n22 = o2 ? o2.tileID : t22, a22 = n22.overscaledZ;
          const l22 = i22.getSource().minzoom, c22 = [];
          if (!r22) {
            const s3 = i22.getSource().maxzoom;
            if (t22.canonical.z >= s3) {
              const o3 = t22.canonical.z - s3;
              i22.getSource().reparseOverscaled ? (a22 = Math.max(t22.canonical.z + 2, i22.transform.tileZoom), n22 = new e2.aM(a22, t22.wrap, s3, t22.canonical.x >> o3, t22.canonical.y >> o3)) : 0 !== o3 && (a22 = s3, n22 = new e2.aM(a22, t22.wrap, s3, t22.canonical.x >> o3, t22.canonical.y >> o3));
            }
            n22.key !== t22.key && (c22.push(n22.key), o2 = i22.getTile(n22));
          }
          const h22 = (e22) => {
            c22.forEach((t3) => {
              s2[t3] = e22;
            }), c22.length = 0;
          };
          for (a22 -= 1; a22 >= l22 && (!o2 || !o2.hasData()); a22--) {
            o2 && h22(o2.tileID.key);
            const e22 = n22.calculateScaledKey(a22);
            if (o2 = i22.getTileByID(e22), o2 && o2.hasData()) break;
            const t3 = s2[e22];
            if (null === t3) break;
            void 0 === t3 ? c22.push(e22) : o2 = i22.getTileByID(t3);
          }
          return h22(o2 ? o2.tileID.key : null), o2 && o2.hasData() ? o2 : null;
        }
        findDEMTileFor(e22) {
          return this.enabled ? this._findTileCoveringTileID(e22, this.sourceCache) : null;
        }
        prepareDrawTile() {
          this.renderedToTile = true;
        }
        _clearRenderCacheForTile(e22, t22) {
          let i22 = this._tilesDirty[e22];
          i22 || (i22 = this._tilesDirty[e22] = {}), i22[t22.key] = true;
        }
      }
      function Zs(t22, i22, o2) {
        const s2 = function(t3, i3, o3) {
          const s3 = e2.bE(i3, t3), r3 = e2.bE(o3, [0.2126, 0.7152, 0.0722]), n3 = (e22, t4, i4) => (1 - i4) * e22 + i4 * t4, a3 = n3(1 - 0.3 * Math.min(r3, 1), 1, Math.min(s3 + 1, 1));
          return n3(0.92, 1, Math.asin(e2.aD(i3[2], -1, 1)) / Math.PI + 0.5) * a3;
        }(t22, [0, 0, 1], i22), r22 = [0, 0, 0];
        e2.b$(r22, o2.slice(0, 3), s2);
        const n22 = [0, 0, 0];
        e2.b$(n22, i22.slice(0, 3), t22[2]);
        const a22 = [0, 0, 0];
        return e2.cU(a22, r22, n22), e2.cX(a22);
      }
      const Hs = ["fill", "fillOutline", "fillPattern", "line", "linePattern", "background", "backgroundPattern", "hillshade", "raster"], Ws = ["stars", "rainParticle", "snowParticle", "fillExtrusion", "fillExtrusionGroundEffect", "elevatedStructures", "model", "symbol"];
      class $s {
        static cacheKey(e22, t22, i22, o2) {
          let s2 = `${t22}${o2 ? o2.cacheKey : ""}`;
          for (const t3 of i22) e22.usedDefines.includes(t3) && (s2 += `/${t3}`);
          return s2;
        }
        constructor(t22, i22, o2, s2, r22, n22) {
          const a22 = t22.gl;
          this.program = a22.createProgram(), this.configuration = s2, this.name = i22, this.fixedDefines = [...n22];
          const l22 = s2 ? s2.getBinderAttributes() : [], c22 = (o2.staticAttributes || []).concat(l22);
          let h22 = s2 ? s2.defines() : [];
          h22 = h22.concat(n22.map((e22) => `#define ${e22}`));
          const d22 = "#version 300 es\n";
          let u22 = d22 + h22.concat("precision mediump float;", Uo, No.fragmentSource).join("\n");
          for (const e22 of o2.fragmentIncludes) u22 += `
${Bo[e22]}`;
          u22 += `
${o2.fragmentSource}`;
          let _22 = d22 + h22.concat("precision highp float;", Uo, No.vertexSource).join("\n");
          for (const e22 of o2.vertexIncludes) _22 += `
${Bo[e22]}`;
          this.forceManualRenderingForInstanceIDShaders = t22.forceManualRenderingForInstanceIDShaders && -1 !== o2.vertexSource.indexOf("gl_InstanceID"), this.forceManualRenderingForInstanceIDShaders && (_22 += "\nuniform int u_instanceID;\n"), _22 += `
${o2.vertexSource}`, this.forceManualRenderingForInstanceIDShaders && (_22 = _22.replaceAll("gl_InstanceID", "u_instanceID"));
          const p22 = a22.createShader(a22.FRAGMENT_SHADER);
          if (a22.isContextLost()) return void (this.failedToCreate = true);
          a22.shaderSource(p22, u22), a22.compileShader(p22), a22.attachShader(this.program, p22);
          const f22 = a22.createShader(a22.VERTEX_SHADER);
          if (a22.isContextLost()) this.failedToCreate = true;
          else {
            a22.shaderSource(f22, _22), a22.compileShader(f22), a22.attachShader(this.program, f22), this.attributes = {}, this.numAttributes = c22.length;
            for (let e22 = 0; e22 < this.numAttributes; e22++) if (c22[e22]) {
              const t3 = c22[e22].startsWith("a_") ? c22[e22] : `a_${c22[e22]}`;
              a22.bindAttribLocation(this.program, e22, t3), this.attributes[t3] = e22;
            }
            a22.linkProgram(this.program), a22.deleteShader(f22), a22.deleteShader(p22), this.fixedUniforms = r22(t22), this.binderUniforms = s2 ? s2.getUniforms(t22) : [], this.forceManualRenderingForInstanceIDShaders && (this.instancingUniforms = ((t3) => ({ u_instanceID: new e2.cc(t3) }))(t22)), (n22.includes("TERRAIN") || -1 !== i22.indexOf("symbol") || -1 !== i22.indexOf("circle")) && (this.terrainUniforms = ((t3) => ({ u_dem: new e2.cc(t3), u_dem_prev: new e2.cc(t3), u_dem_tl: new e2.c9(t3), u_dem_scale: new e2.cb(t3), u_dem_tl_prev: new e2.c9(t3), u_dem_scale_prev: new e2.cb(t3), u_dem_size: new e2.cb(t3), u_dem_lerp: new e2.cb(t3), u_exaggeration: new e2.cb(t3), u_depth: new e2.cc(t3), u_depth_size_inv: new e2.c9(t3), u_depth_range_unpack: new e2.c9(t3), u_occluder_half_size: new e2.cb(t3), u_occlusion_depth_offset: new e2.cb(t3), u_meter_to_dem: new e2.cb(t3), u_label_plane_matrix_inv: new e2.c8(t3) }))(t22)), n22.includes("GLOBE") && (this.globeUniforms = ((t3) => ({ u_tile_tl_up: new e2.ca(t3), u_tile_tr_up: new e2.ca(t3), u_tile_br_up: new e2.ca(t3), u_tile_bl_up: new e2.ca(t3), u_tile_up_scale: new e2.cb(t3) }))(t22)), n22.includes("FOG") && (this.fogUniforms = ((t3) => ({ u_fog_matrix: new e2.c8(t3), u_fog_range: new e2.c9(t3), u_fog_color: new e2.cQ(t3), u_fog_horizon_blend: new e2.cb(t3), u_fog_vertical_limit: new e2.c9(t3), u_fog_temporal_offset: new e2.cb(t3), u_frustum_tl: new e2.ca(t3), u_frustum_tr: new e2.ca(t3), u_frustum_br: new e2.ca(t3), u_frustum_bl: new e2.ca(t3), u_globe_pos: new e2.ca(t3), u_globe_radius: new e2.cb(t3), u_globe_transition: new e2.cb(t3), u_is_globe: new e2.cc(t3), u_viewport: new e2.c9(t3) }))(t22)), n22.includes("RENDER_CUTOFF") && (this.cutoffUniforms = ((t3) => ({ u_cutoff_params: new e2.cQ(t3) }))(t22)), n22.includes("LIGHTING_3D_MODE") && (this.lightsUniforms = ((t3) => ({ u_lighting_ambient_color: new e2.ca(t3), u_lighting_directional_dir: new e2.ca(t3), u_lighting_directional_color: new e2.ca(t3), u_ground_radiance: new e2.ca(t3) }))(t22)), n22.includes("RENDER_SHADOWS") && (this.shadowUniforms = ((t3) => ({ u_light_matrix_0: new e2.c8(t3), u_light_matrix_1: new e2.c8(t3), u_fade_range: new e2.c9(t3), u_shadow_normal_offset: new e2.ca(t3), u_shadow_intensity: new e2.cb(t3), u_shadow_texel_size: new e2.cb(t3), u_shadow_map_resolution: new e2.cb(t3), u_shadow_direction: new e2.ca(t3), u_shadow_bias: new e2.ca(t3), u_shadowmap_0: new e2.cc(t3), u_shadowmap_1: new e2.cc(t3) }))(t22));
          }
        }
        setTerrainUniformValues(e22, t22) {
          if (!this.terrainUniforms) return;
          const i22 = this.terrainUniforms;
          if (!this.failedToCreate) {
            e22.program.set(this.program);
            for (const e3 in t22) i22[e3] && i22[e3].set(this.program, e3, t22[e3]);
          }
        }
        setGlobeUniformValues(e22, t22) {
          if (!this.globeUniforms) return;
          const i22 = this.globeUniforms;
          if (!this.failedToCreate) {
            e22.program.set(this.program);
            for (const e3 in t22) i22[e3] && i22[e3].set(this.program, e3, t22[e3]);
          }
        }
        setFogUniformValues(e22, t22) {
          if (!this.fogUniforms) return;
          const i22 = this.fogUniforms;
          if (!this.failedToCreate) {
            e22.program.set(this.program);
            for (const e3 in t22) i22[e3].set(this.program, e3, t22[e3]);
          }
        }
        setCutoffUniformValues(e22, t22) {
          if (!this.cutoffUniforms) return;
          const i22 = this.cutoffUniforms;
          if (!this.failedToCreate) {
            e22.program.set(this.program);
            for (const e3 in t22) i22[e3].set(this.program, e3, t22[e3]);
          }
        }
        setLightsUniformValues(e22, t22) {
          if (!this.lightsUniforms) return;
          const i22 = this.lightsUniforms;
          if (!this.failedToCreate) {
            e22.program.set(this.program);
            for (const e3 in t22) i22[e3].set(this.program, e3, t22[e3]);
          }
        }
        setShadowUniformValues(e22, t22) {
          if (this.failedToCreate || !this.shadowUniforms) return;
          const i22 = this.shadowUniforms;
          e22.program.set(this.program);
          for (const e3 in t22) i22[e3].set(this.program, e3, t22[e3]);
        }
        _drawDebugWireframe(t22, i22, o2, s2, r22, n22, a22, l22, c22, h22) {
          const d22 = t22.options.wireframe;
          if (false === d22.terrain && false === d22.layers2D && false === d22.layers3D) return;
          const u22 = t22.context;
          if (!(() => !(!d22.terrain || "terrainRaster" !== this.name && "globeRaster" !== this.name) || !(!d22.layers2D || t22._terrain && t22._terrain.renderingToTexture || !Hs.includes(this.name)) || !(!d22.layers3D || !Ws.includes(this.name)))()) return;
          const _22 = u22.gl, p22 = t22.wireframeDebugCache.getLinesFromTrianglesBuffer(t22.frameCounter, r22, u22);
          if (!p22) return;
          const f22 = [...this.fixedDefines];
          f22.push("DEBUG_WIREFRAME");
          const m22 = t22.getOrCreateProgram(this.name, { config: this.configuration, defines: f22 });
          u22.program.set(m22.program);
          const g22 = (e22, t3, i3) => {
            if (t3[e22] && i3[e22]) for (const o3 in t3[e22]) i3[e22][o3] && i3[e22][o3].set(i3.program, o3, t3[e22][o3].current);
          };
          c22 && c22.setUniforms(m22.program, u22, m22.binderUniforms, a22, { zoom: l22 }), g22("fixedUniforms", this, m22), g22("terrainUniforms", this, m22), g22("globeUniforms", this, m22), g22("fogUniforms", this, m22), g22("lightsUniforms", this, m22), g22("shadowUniforms", this, m22), p22.bind(), u22.setColorMode(new ki([_22.ONE, _22.ONE_MINUS_SRC_ALPHA, _22.ZERO, _22.ONE], e2.am.transparent, [true, true, true, false])), u22.setDepthMode(new Ni(i22.func === _22.LESS ? _22.LEQUAL : i22.func, Ni.ReadOnly, i22.range)), u22.setStencilMode(ji.disabled);
          const v22 = 3 * n22.primitiveLength * 2, y22 = 3 * n22.primitiveOffset * 2 * 2;
          if (this.forceManualRenderingForInstanceIDShaders) {
            const e22 = h22 || 1;
            for (let t3 = 0; t3 < e22; ++t3) m22.instancingUniforms.u_instanceID.set(this.program, "u_instanceID", t3), _22.drawElements(_22.LINES, v22, _22.UNSIGNED_SHORT, y22);
          } else h22 && h22 > 1 ? _22.drawElementsInstanced(_22.LINES, v22, _22.UNSIGNED_SHORT, y22, h22) : _22.drawElements(_22.LINES, v22, _22.UNSIGNED_SHORT, y22);
          r22.bind(), u22.program.set(this.program), u22.setDepthMode(i22), u22.setStencilMode(o2), u22.setColorMode(s2);
        }
        checkUniforms(e22, t22, i22) {
          if (this.fixedDefines.includes(t22)) {
            for (const o2 of Object.keys(i22)) if (!i22[o2].initialized) throw new Error(`Program '${this.name}', from draw '${e22}': uniform ${o2} not set but required by ${t22} being defined`);
          }
        }
        draw(e22, t22, i22, o2, s2, r22, n22, a22, l22, c22, h22, d22, u22, _22, p22, f22) {
          const m22 = e22.context, g22 = m22.gl;
          if (this.failedToCreate) return;
          m22.program.set(this.program), m22.setDepthMode(i22), m22.setStencilMode(o2), m22.setColorMode(s2), m22.setCullFace(r22);
          for (const e3 of Object.keys(this.fixedUniforms)) this.fixedUniforms[e3].set(this.program, e3, n22[e3]);
          _22 && _22.setUniforms(this.program, m22, this.binderUniforms, d22, { zoom: u22 });
          const v22 = { [g22.POINTS]: 1, [g22.LINES]: 2, [g22.TRIANGLES]: 3, [g22.LINE_STRIP]: 1 }[t22];
          this.checkUniforms(a22, "RENDER_SHADOWS", this.shadowUniforms);
          const y22 = f22 && f22 > 0 ? 1 : void 0;
          for (const r3 of h22.get()) {
            const n3 = r3.vaos || (r3.vaos = {});
            if ((n3[a22] || (n3[a22] = new qo())).bind(m22, this, l22, _22 ? _22.getPaintVertexBuffers() : [], c22, r3.vertexOffset, p22 || [], y22), this.forceManualRenderingForInstanceIDShaders) {
              const e3 = f22 || 1;
              for (let i3 = 0; i3 < e3; ++i3) this.instancingUniforms.u_instanceID.set(this.program, "u_instanceID", i3), c22 ? g22.drawElements(t22, r3.primitiveLength * v22, g22.UNSIGNED_SHORT, r3.primitiveOffset * v22 * 2) : g22.drawArrays(t22, r3.vertexOffset, r3.vertexLength);
            } else f22 && f22 > 1 ? g22.drawElementsInstanced(t22, r3.primitiveLength * v22, g22.UNSIGNED_SHORT, r3.primitiveOffset * v22 * 2, f22) : c22 ? g22.drawElements(t22, r3.primitiveLength * v22, g22.UNSIGNED_SHORT, r3.primitiveOffset * v22 * 2) : g22.drawArrays(t22, r3.vertexOffset, r3.vertexLength);
            t22 === g22.TRIANGLES && c22 && this._drawDebugWireframe(e22, i22, o2, s2, c22, r3, d22, u22, _22, f22);
          }
        }
      }
      function Xs(t22, i22, o2 = 0) {
        const s2 = Math.pow(2, i22.tileID.overscaledZ), r22 = i22.tileSize * Math.pow(2, t22.transform.tileZoom) / s2, n22 = r22 * (i22.tileID.canonical.x + i22.tileID.wrap * s2), a22 = r22 * i22.tileID.canonical.y;
        return { u_image: 0, u_texsize: i22.imageAtlasTexture ? i22.imageAtlasTexture.size : [0, 0], u_tile_units_to_pixels: 1 / e2.aw(i22, 1, t22.transform.tileZoom), u_pixel_coord_upper: [n22 >> 16, a22 >> 16], u_pixel_coord_lower: [65535 & n22, 65535 & a22], u_pattern_transition: o2 };
      }
      const Ys = { terrain: 0, flat: 1 }, Ks = e2.bz(), Js = (t22, i22, o2, s2, r22, n22, a22, l22, c22, h22, d22, u22, _22, p22, f22, m22, g22, v22) => {
        const y22 = i22.style.light, x22 = y22.properties.get("position"), b22 = [x22.x, x22.y, x22.z], w22 = e2.dx();
        "viewport" === y22.properties.get("anchor") && (e2.dy(w22, -i22.transform.angle), e2.dz(b22, b22, w22));
        const T2 = y22.properties.get("color"), E22 = i22.transform, S2 = { u_matrix: t22, u_lightpos: b22, u_lightintensity: y22.properties.get("intensity"), u_lightcolor: [T2.r, T2.g, T2.b], u_vertical_gradient: +o2, u_opacity: s2, u_tile_id: [0, 0, 0], u_zoom_transition: 0, u_inv_rot_matrix: Ks, u_merc_center: [0, 0], u_up_dir: [0, 0, 0], u_height_lift: 0, u_height_type: Ys[h22], u_base_type: Ys[d22], u_ao: r22, u_edge_radius: n22, u_width_scale: a22, u_flood_light_color: f22, u_vertical_scale: m22, u_flood_light_intensity: g22, u_ground_shadow_factor: v22 };
        return "globe" === E22.projection.name && (S2.u_tile_id = [l22.canonical.x, l22.canonical.y, 1 << l22.canonical.z], S2.u_zoom_transition = u22, S2.u_inv_rot_matrix = p22, S2.u_merc_center = _22, S2.u_up_dir = E22.projection.upVector(new e2.cp(0, 0, 0), _22[0] * e2.aj, _22[1] * e2.aj), S2.u_height_lift = c22), S2;
      }, Qs = (e22, t22, i22, o2, s2, r22) => ({ u_matrix: e22, u_edge_radius: t22, u_width_scale: i22, u_vertical_scale: o2, u_height_type: Ys[s2], u_base_type: Ys[r22] }), er = (t22, i22, o2, s2, r22, n22, a22, l22, c22, h22, d22, u22, _22, p22, f22, m22, g22, v22) => {
        const y22 = Js(t22, i22, o2, s2, r22, n22, a22, l22, h22, d22, u22, _22, p22, f22, m22, g22, 1, [0, 0, 0]), x22 = { u_height_factor: -Math.pow(2, l22.overscaledZ) / c22.tileSize / 8 };
        return e2.l(y22, Xs(i22, c22, v22), x22);
      }, tr = (e22, t22, i22) => ({ u_matrix: e22, u_emissive_strength: t22, u_ground_shadow_factor: i22 }), ir = (t22, i22, o2, s2, r22, n22 = 0) => e2.l(tr(t22, i22, r22), Xs(o2, s2, n22)), or = (e22, t22, i22, o2) => ({ u_matrix: e22, u_world: i22, u_emissive_strength: t22, u_ground_shadow_factor: o2 }), sr = (t22, i22, o2, s2, r22, n22, a22 = 0) => e2.l(ir(t22, i22, o2, s2, n22, a22), { u_world: r22 }), rr = (e22, t22) => ({ u_matrix: e22, u_ground_shadow_factor: t22 }), nr = (e22, t22, i22, o2, s2) => ({ u_matrix: e22, u_camera_pos: [t22[0], t22[1], t22[2]], u_depth_bias: i22, u_height_scale: o2, u_reset_depth: s2 }), ar = (t22, i22, o2, s2) => {
        const r22 = e2.aj / o2.tileSize;
        return { u_matrix: t22, u_camera_to_center_distance: i22.getCameraToCenterDistance(s2), u_extrude_scale: [i22.pixelsToGLUnits[0] / r22, i22.pixelsToGLUnits[1] / r22] };
      }, lr = (e22, t22, i22 = 1) => ({ u_matrix: e22, u_color: t22.toRenderColor(null), u_overlay: 0, u_overlay_scale: i22 }), cr = e2.bz(), hr = (t22, i22, o2, s2, r22, n22, a22) => {
        const l22 = t22.transform, c22 = "globe" === l22.projection.name, h22 = c22 ? e2.dA(l22.zoom, i22.canonical) * l22._pixelsPerMercatorPixel : e2.aw(o2, 1, n22), d22 = { u_matrix: i22.projMatrix, u_extrude_scale: h22, u_intensity: a22, u_inv_rot_matrix: cr, u_merc_center: [0, 0], u_tile_id: [0, 0, 0], u_zoom_transition: 0, u_up_dir: [0, 0, 0] };
        if (c22) {
          d22.u_inv_rot_matrix = s2, d22.u_merc_center = r22, d22.u_tile_id = [i22.canonical.x, i22.canonical.y, 1 << i22.canonical.z], d22.u_zoom_transition = e2.ah(l22.zoom);
          const t3 = r22[0] * e2.aj, o3 = r22[1] * e2.aj;
          d22.u_up_dir = l22.projection.upVector(new e2.cp(0, 0, 0), t3, o3);
        }
        return d22;
      };
      function dr(e22, [t22, i22, o2, s2], [r22, n22]) {
        if (r22 === n22) return [0, 0, 0, 0];
        const a22 = 255 * (e22 - 1) / (e22 * (n22 - r22));
        return [t22 * a22, i22 * a22, o2 * a22, s2 * a22];
      }
      function ur(e22, t22, [i22, o2]) {
        return i22 === o2 ? 0 : 0.5 / e22 + (t22 - i22) * (e22 - 1) / (e22 * (o2 - i22));
      }
      const _r = (t22, i22, o2, s2, r22, n22, a22, l22, c22, h22, d22, u22, _22, p22, f22, m22, g22, v22, y22, x22, b22) => ({ u_matrix: t22, u_normalize_matrix: i22, u_globe_matrix: o2, u_merc_matrix: s2, u_grid_matrix: r22, u_tl_parent: n22, u_scale_parent: h22, u_fade_t: d22.mix, u_opacity: d22.opacity * u22.paint.get("raster-opacity"), u_image0: 0, u_image1: 1, u_brightness_low: u22.paint.get("raster-brightness-min"), u_brightness_high: u22.paint.get("raster-brightness-max"), u_saturation_factor: e2.dB(u22.paint.get("raster-saturation")), u_contrast_factor: e2.dC(u22.paint.get("raster-contrast")), u_spin_weights: pr(u22.paint.get("raster-hue-rotate")), u_perspective_transform: _22, u_raster_elevation: p22, u_zoom_transition: a22, u_merc_center: l22, u_cutoff_params: c22, u_colorization_mix: dr(e2.dD, m22, v22), u_colorization_offset: ur(e2.dD, g22, v22), u_color_ramp: f22, u_texture_offset: [x22 / (y22 + 2 * x22), y22 / (y22 + 2 * x22)], u_texture_res: [y22 + 2 * x22, y22 + 2 * x22], u_emissive_strength: b22 });
      function pr(e22) {
        e22 *= Math.PI / 180;
        const t22 = Math.sin(e22), i22 = Math.cos(e22);
        return [(2 * i22 + 1) / 3, (-Math.sqrt(3) * t22 - i22 + 1) / 3, (Math.sqrt(3) * t22 - i22 + 1) / 3];
      }
      const fr = 0.05, mr = (e22, t22, i22, o2, s2, r22, n22, a22, l22, c22, h22, d22) => ({ u_matrix: e22, u_normalize_matrix: t22, u_globe_matrix: i22, u_merc_matrix: o2, u_grid_matrix: s2, u_tl_parent: r22, u_scale_parent: c22, u_fade_t: h22.mix, u_opacity: h22.opacity, u_image0: 0, u_image1: 1, u_raster_elevation: d22, u_zoom_transition: n22, u_merc_center: a22, u_cutoff_params: l22 }), gr = (e22, t22, i22, o2, s2, r22, n22, a22, l22, c22) => ({ u_particle_texture: e22, u_particle_texture_side_len: t22, u_tile_offset: i22, u_velocity: o2, u_color_ramp: r22, u_velocity_res: s2, u_max_speed: n22, u_uv_offset: a22, u_data_scale: [255 * l22[0], 255 * l22[1]], u_data_offset: c22, u_particle_pos_scale: 1.1, u_particle_pos_offset: [fr, fr] }), vr = (e22, t22, i22, o2, s2, r22, n22, a22, l22, c22) => ({ u_particle_texture: e22, u_particle_texture_side_len: t22, u_velocity: i22, u_velocity_res: o2, u_max_speed: s2, u_speed_factor: r22, u_reset_rate: n22, u_rand_seed: Math.random(), u_uv_offset: a22, u_data_scale: [255 * l22[0], 255 * l22[1]], u_data_offset: c22, u_particle_pos_scale: 1.1, u_particle_pos_offset: [fr, fr] }), yr = e2.bz(), xr = (t22, i22, o2, s2, r22, n22, a22, l22, c22, h22, d22, u22, _22, p22, f22, m22, g22, v22, y22, x22, b22, w22, T2) => {
        const E22 = r22.transform, S2 = { u_is_size_zoom_constant: +("constant" === t22 || "source" === t22), u_is_size_feature_constant: +("constant" === t22 || "camera" === t22), u_size_t: i22 ? i22.uSizeT : 0, u_size: i22 ? i22.uSize : 0, u_camera_to_center_distance: E22.getCameraToCenterDistance(y22), u_rotate_symbol: +o2, u_aspect_ratio: E22.width / E22.height, u_fade_change: r22.options.fadeDuration ? r22.symbolFadeChange : 1, u_matrix: n22, u_label_plane_matrix: a22, u_coord_matrix: l22, u_is_text: +h22, u_elevation_from_sea: c22 ? 1 : 0, u_pitch_with_map: +s2, u_texsize: d22, u_texsize_icon: u22, u_texture: 0, u_texture_icon: 1, u_tile_id: [0, 0, 0], u_zoom_transition: 0, u_inv_rot_matrix: yr, u_merc_center: [0, 0], u_camera_forward: [0, 0, 0], u_ecef_origin: [0, 0, 0], u_tile_matrix: yr, u_up_vector: [0, -1, 0], u_color_adj_mat: b22, u_icon_transition: w22 || 0, u_gamma_scale: s2 ? r22.transform.getCameraToCenterDistance(y22) * Math.cos(r22.terrain ? 0 : r22.transform._pitch) : 1, u_device_pixel_ratio: e2.q.devicePixelRatio, u_is_halo: +_22, u_scale_factor: T2 || 1, u_ground_shadow_factor: x22, u_inv_matrix: e2.bi(e2.bz(), a22) };
        return "globe" === y22.name && (S2.u_tile_id = [p22.canonical.x, p22.canonical.y, 1 << p22.canonical.z], S2.u_zoom_transition = f22, S2.u_inv_rot_matrix = g22, S2.u_merc_center = m22, S2.u_camera_forward = E22._camera.forward(), S2.u_ecef_origin = e2.dE(E22.globeMatrix, p22.toUnwrapped()), S2.u_tile_matrix = Float32Array.from(E22.globeMatrix), S2.u_up_vector = v22), S2;
      }, br = (e22, t22, i22, o2) => ({ u_matrix: e22, u_emissive_strength: t22, u_opacity: i22, u_color: o2 }), wr = (t22, i22, o2, s2, r22, n22, a22, l22, c22) => e2.l(function(t3, i3, o3, s3, r3, n3) {
        const { width: a3, height: l3 } = s3.imageManager.getPixelSize(i3), c3 = Math.pow(2, n3.tileID.overscaledZ), h22 = n3.tileSize * Math.pow(2, s3.transform.tileZoom) / c3, d22 = h22 * (n3.tileID.canonical.x + n3.tileID.wrap * c3), u22 = h22 * n3.tileID.canonical.y;
        return { u_image: 0, u_pattern_tl: o3.tl, u_pattern_br: o3.br, u_texsize: [a3, l3], u_pattern_size: o3.displaySize, u_pattern_units_to_pixels: r3 ? [s3.transform.width, -1 * s3.transform.height] : [1 / e2.aw(n3, 1, s3.transform.tileZoom), 1 / e2.aw(n3, 1, s3.transform.tileZoom)], u_pixel_coord_upper: [d22 >> 16, u22 >> 16], u_pixel_coord_lower: [65535 & d22, 65535 & u22] };
      }(0, n22, a22, s2, l22, c22), { u_matrix: t22, u_emissive_strength: i22, u_opacity: o2 }), Tr = new Float32Array(e2.bx([])), Er = (t22, i22, o2, s2, r22, n22, a22, l22, c22, h22, d22, u22, _22, p22 = [0, 0, 0], f22) => {
        const m22 = r22.style.light, g22 = m22.properties.get("position"), v22 = [-g22.x, -g22.y, g22.z], y22 = e2.dx();
        "viewport" === m22.properties.get("anchor") && (e2.dy(y22, -r22.transform.angle), e2.dz(v22, v22, y22));
        const x22 = "MASK" === d22.alphaMode, b22 = m22.properties.get("color").toRenderColor(null), w22 = _22.paint.get("model-ambient-occlusion-intensity"), T2 = _22.paint.get("model-color").constantOr(e2.am.white).toRenderColor(null), E22 = _22.paint.get("model-color-mix-intensity").constantOr(0);
        return { u_matrix: t22, u_lighting_matrix: i22, u_normal_matrix: o2, u_node_matrix: s2 || Tr, u_lightpos: v22, u_lightintensity: m22.properties.get("intensity"), u_lightcolor: [b22.r, b22.g, b22.b], u_camera_pos: p22, u_opacity: n22, u_baseTextureIsAlpha: 0, u_alphaMask: +x22, u_alphaCutoff: d22.alphaCutoff, u_baseColorFactor: [a22.r, a22.g, a22.b, a22.a], u_emissiveFactor: [l22[0], l22[1], l22[2], 1], u_metallicFactor: c22, u_roughnessFactor: h22, u_baseColorTexture: Yi.BaseColor, u_metallicRoughnessTexture: Yi.MetallicRoughness, u_normalTexture: Yi.Normal, u_occlusionTexture: Yi.Occlusion, u_emissionTexture: Yi.Emission, u_lutTexture: Yi.LUT, u_color_mix: [T2.r, T2.g, T2.b, E22], u_aoIntensity: w22, u_emissive_strength: u22, u_occlusionTextureTransform: f22 || [0, 0, 0, 0] };
      }, Sr = (e22, t22 = Tr, i22 = Tr) => ({ u_matrix: e22, u_instance: t22, u_node_matrix: i22 }), Ir = { fillExtrusion: (t22) => ({ u_matrix: new e2.c8(t22), u_lightpos: new e2.ca(t22), u_lightintensity: new e2.cb(t22), u_lightcolor: new e2.ca(t22), u_vertical_gradient: new e2.cb(t22), u_opacity: new e2.cb(t22), u_edge_radius: new e2.cb(t22), u_width_scale: new e2.cb(t22), u_ao: new e2.c9(t22), u_height_type: new e2.cc(t22), u_base_type: new e2.cc(t22), u_tile_id: new e2.ca(t22), u_zoom_transition: new e2.cb(t22), u_inv_rot_matrix: new e2.c8(t22), u_merc_center: new e2.c9(t22), u_up_dir: new e2.ca(t22), u_height_lift: new e2.cb(t22), u_flood_light_color: new e2.ca(t22), u_vertical_scale: new e2.cb(t22), u_flood_light_intensity: new e2.cb(t22), u_ground_shadow_factor: new e2.ca(t22) }), fillExtrusionDepth: (t22) => ({ u_matrix: new e2.c8(t22), u_edge_radius: new e2.cb(t22), u_width_scale: new e2.cb(t22), u_vertical_scale: new e2.cb(t22), u_height_type: new e2.cc(t22), u_base_type: new e2.cc(t22) }), fillExtrusionPattern: (t22) => ({ u_matrix: new e2.c8(t22), u_lightpos: new e2.ca(t22), u_lightintensity: new e2.cb(t22), u_lightcolor: new e2.ca(t22), u_vertical_gradient: new e2.cb(t22), u_height_factor: new e2.cb(t22), u_edge_radius: new e2.cb(t22), u_width_scale: new e2.cb(t22), u_ao: new e2.c9(t22), u_height_type: new e2.cc(t22), u_base_type: new e2.cc(t22), u_tile_id: new e2.ca(t22), u_zoom_transition: new e2.cb(t22), u_inv_rot_matrix: new e2.c8(t22), u_merc_center: new e2.c9(t22), u_up_dir: new e2.ca(t22), u_height_lift: new e2.cb(t22), u_image: new e2.cc(t22), u_texsize: new e2.c9(t22), u_pixel_coord_upper: new e2.c9(t22), u_pixel_coord_lower: new e2.c9(t22), u_tile_units_to_pixels: new e2.cb(t22), u_opacity: new e2.cb(t22), u_pattern_transition: new e2.cb(t22) }), fillExtrusionGroundEffect: (t22) => ({ u_matrix: new e2.c8(t22), u_opacity: new e2.cb(t22), u_ao_pass: new e2.cb(t22), u_meter_to_tile: new e2.cb(t22), u_ao: new e2.c9(t22), u_flood_light_intensity: new e2.cb(t22), u_flood_light_color: new e2.ca(t22), u_attenuation: new e2.cb(t22), u_edge_radius: new e2.cb(t22), u_fb: new e2.cc(t22), u_fb_size: new e2.cb(t22), u_dynamic_offset: new e2.cb(t22) }), fill: (t22) => ({ u_matrix: new e2.c8(t22), u_emissive_strength: new e2.cb(t22), u_ground_shadow_factor: new e2.ca(t22) }), fillPattern: (t22) => ({ u_matrix: new e2.c8(t22), u_emissive_strength: new e2.cb(t22), u_image: new e2.cc(t22), u_texsize: new e2.c9(t22), u_pixel_coord_upper: new e2.c9(t22), u_pixel_coord_lower: new e2.c9(t22), u_tile_units_to_pixels: new e2.cb(t22), u_ground_shadow_factor: new e2.ca(t22), u_pattern_transition: new e2.cb(t22) }), fillOutline: (t22) => ({ u_matrix: new e2.c8(t22), u_emissive_strength: new e2.cb(t22), u_world: new e2.c9(t22), u_ground_shadow_factor: new e2.ca(t22) }), fillOutlinePattern: (t22) => ({ u_matrix: new e2.c8(t22), u_emissive_strength: new e2.cb(t22), u_world: new e2.c9(t22), u_image: new e2.cc(t22), u_texsize: new e2.c9(t22), u_pixel_coord_upper: new e2.c9(t22), u_pixel_coord_lower: new e2.c9(t22), u_tile_units_to_pixels: new e2.cb(t22), u_ground_shadow_factor: new e2.ca(t22), u_pattern_transition: new e2.cb(t22) }), building: (t22) => ({ u_matrix: new e2.c8(t22), u_normal_matrix: new e2.c8(t22), u_opacity: new e2.cb(t22) }), buildingDepth: (t22) => ({ u_matrix: new e2.c8(t22) }), elevatedStructuresDepth: (t22) => ({ u_matrix: new e2.c8(t22), u_depth_bias: new e2.cb(t22) }), elevatedStructures: (t22) => ({ u_matrix: new e2.c8(t22), u_ground_shadow_factor: new e2.ca(t22) }), elevatedStructuresDepthReconstruct: (t22) => ({ u_matrix: new e2.c8(t22), u_camera_pos: new e2.ca(t22), u_depth_bias: new e2.cb(t22), u_height_scale: new e2.cb(t22), u_reset_depth: new e2.cb(t22) }), circle: e2.dF, collisionBox: (t22) => ({ u_matrix: new e2.c8(t22), u_camera_to_center_distance: new e2.cb(t22), u_extrude_scale: new e2.c9(t22) }), collisionCircle: (t22) => ({ u_matrix: new e2.c8(t22), u_inv_matrix: new e2.c8(t22), u_camera_to_center_distance: new e2.cb(t22), u_viewport_size: new e2.c9(t22) }), debug: (t22) => ({ u_color: new e2.di(t22), u_matrix: new e2.c8(t22), u_overlay: new e2.cc(t22), u_overlay_scale: new e2.cb(t22) }), clippingMask: (t22) => ({ u_matrix: new e2.c8(t22) }), heatmap: (t22) => ({ u_extrude_scale: new e2.cb(t22), u_intensity: new e2.cb(t22), u_matrix: new e2.c8(t22), u_inv_rot_matrix: new e2.c8(t22), u_merc_center: new e2.c9(t22), u_tile_id: new e2.ca(t22), u_zoom_transition: new e2.cb(t22), u_up_dir: new e2.ca(t22) }), heatmapTexture: (t22) => ({ u_image: new e2.cc(t22), u_color_ramp: new e2.cc(t22), u_opacity: new e2.cb(t22) }), hillshade: (t22) => ({ u_matrix: new e2.c8(t22), u_image: new e2.cc(t22), u_latrange: new e2.c9(t22), u_light: new e2.c9(t22), u_shadow: new e2.di(t22), u_highlight: new e2.di(t22), u_emissive_strength: new e2.cb(t22), u_accent: new e2.di(t22) }), hillshadePrepare: (t22) => ({ u_matrix: new e2.c8(t22), u_image: new e2.cc(t22), u_dimension: new e2.c9(t22), u_zoom: new e2.cb(t22) }), line: e2.dG, linePattern: e2.dH, raster: (t22) => ({ u_matrix: new e2.c8(t22), u_normalize_matrix: new e2.c8(t22), u_globe_matrix: new e2.c8(t22), u_merc_matrix: new e2.c8(t22), u_grid_matrix: new e2.dj(t22), u_tl_parent: new e2.c9(t22), u_scale_parent: new e2.cb(t22), u_fade_t: new e2.cb(t22), u_opacity: new e2.cb(t22), u_image0: new e2.cc(t22), u_image1: new e2.cc(t22), u_brightness_low: new e2.cb(t22), u_brightness_high: new e2.cb(t22), u_saturation_factor: new e2.cb(t22), u_contrast_factor: new e2.cb(t22), u_spin_weights: new e2.ca(t22), u_perspective_transform: new e2.c9(t22), u_raster_elevation: new e2.cb(t22), u_zoom_transition: new e2.cb(t22), u_merc_center: new e2.c9(t22), u_cutoff_params: new e2.cQ(t22), u_colorization_mix: new e2.cQ(t22), u_colorization_offset: new e2.cb(t22), u_color_ramp: new e2.cc(t22), u_texture_offset: new e2.c9(t22), u_texture_res: new e2.c9(t22), u_emissive_strength: new e2.cb(t22) }), rasterParticle: (t22) => ({ u_matrix: new e2.c8(t22), u_normalize_matrix: new e2.c8(t22), u_globe_matrix: new e2.c8(t22), u_merc_matrix: new e2.c8(t22), u_grid_matrix: new e2.dj(t22), u_tl_parent: new e2.c9(t22), u_scale_parent: new e2.cb(t22), u_fade_t: new e2.cb(t22), u_opacity: new e2.cb(t22), u_image0: new e2.cc(t22), u_image1: new e2.cc(t22), u_raster_elevation: new e2.cb(t22), u_zoom_transition: new e2.cb(t22), u_merc_center: new e2.c9(t22), u_cutoff_params: new e2.cQ(t22) }), rasterParticleTexture: (t22) => ({ u_texture: new e2.cc(t22), u_opacity: new e2.cb(t22) }), rasterParticleDraw: (t22) => ({ u_particle_texture: new e2.cc(t22), u_particle_texture_side_len: new e2.cb(t22), u_tile_offset: new e2.c9(t22), u_velocity: new e2.cc(t22), u_color_ramp: new e2.cc(t22), u_velocity_res: new e2.c9(t22), u_max_speed: new e2.cb(t22), u_uv_offset: new e2.c9(t22), u_data_scale: new e2.c9(t22), u_data_offset: new e2.cb(t22), u_particle_pos_scale: new e2.cb(t22), u_particle_pos_offset: new e2.c9(t22) }), rasterParticleUpdate: (t22) => ({ u_particle_texture: new e2.cc(t22), u_particle_texture_side_len: new e2.cb(t22), u_velocity: new e2.cc(t22), u_velocity_res: new e2.c9(t22), u_max_speed: new e2.cb(t22), u_speed_factor: new e2.cb(t22), u_reset_rate: new e2.cb(t22), u_rand_seed: new e2.cb(t22), u_uv_offset: new e2.c9(t22), u_data_scale: new e2.c9(t22), u_data_offset: new e2.cb(t22), u_particle_pos_scale: new e2.cb(t22), u_particle_pos_offset: new e2.c9(t22) }), symbol: (t22) => ({ u_is_size_zoom_constant: new e2.cc(t22), u_is_size_feature_constant: new e2.cc(t22), u_size_t: new e2.cb(t22), u_size: new e2.cb(t22), u_camera_to_center_distance: new e2.cb(t22), u_rotate_symbol: new e2.cc(t22), u_aspect_ratio: new e2.cb(t22), u_fade_change: new e2.cb(t22), u_matrix: new e2.c8(t22), u_label_plane_matrix: new e2.c8(t22), u_coord_matrix: new e2.c8(t22), u_is_text: new e2.cc(t22), u_elevation_from_sea: new e2.cc(t22), u_pitch_with_map: new e2.cc(t22), u_texsize: new e2.c9(t22), u_texsize_icon: new e2.c9(t22), u_texture: new e2.cc(t22), u_texture_icon: new e2.cc(t22), u_gamma_scale: new e2.cb(t22), u_device_pixel_ratio: new e2.cb(t22), u_tile_id: new e2.ca(t22), u_zoom_transition: new e2.cb(t22), u_inv_rot_matrix: new e2.c8(t22), u_merc_center: new e2.c9(t22), u_camera_forward: new e2.ca(t22), u_tile_matrix: new e2.c8(t22), u_up_vector: new e2.ca(t22), u_ecef_origin: new e2.ca(t22), u_is_halo: new e2.cc(t22), u_icon_transition: new e2.cb(t22), u_color_adj_mat: new e2.c8(t22), u_scale_factor: new e2.cb(t22), u_ground_shadow_factor: new e2.ca(t22), u_inv_matrix: new e2.c8(t22) }), background: (t22) => ({ u_matrix: new e2.c8(t22), u_emissive_strength: new e2.cb(t22), u_opacity: new e2.cb(t22), u_color: new e2.di(t22) }), backgroundPattern: (t22) => ({ u_matrix: new e2.c8(t22), u_emissive_strength: new e2.cb(t22), u_opacity: new e2.cb(t22), u_image: new e2.cc(t22), u_pattern_tl: new e2.c9(t22), u_pattern_br: new e2.c9(t22), u_texsize: new e2.c9(t22), u_pattern_size: new e2.c9(t22), u_pixel_coord_upper: new e2.c9(t22), u_pixel_coord_lower: new e2.c9(t22), u_pattern_units_to_pixels: new e2.c9(t22) }), terrainRaster: (t22) => ({ u_matrix: new e2.c8(t22), u_image0: new e2.cc(t22), u_skirt_height: new e2.cb(t22), u_ground_shadow_factor: new e2.ca(t22) }), skybox: (t22) => ({ u_matrix: new e2.c8(t22), u_sun_direction: new e2.ca(t22), u_cubemap: new e2.cc(t22), u_opacity: new e2.cb(t22), u_temporal_offset: new e2.cb(t22) }), skyboxGradient: (t22) => ({ u_matrix: new e2.c8(t22), u_color_ramp: new e2.cc(t22), u_center_direction: new e2.ca(t22), u_radius: new e2.cb(t22), u_opacity: new e2.cb(t22), u_temporal_offset: new e2.cb(t22) }), skyboxCapture: (t22) => ({ u_matrix_3f: new e2.dj(t22), u_sun_direction: new e2.ca(t22), u_sun_intensity: new e2.cb(t22), u_color_tint_r: new e2.cQ(t22), u_color_tint_m: new e2.cQ(t22), u_luminance: new e2.cb(t22) }), globeRaster: (t22) => ({ u_proj_matrix: new e2.c8(t22), u_globe_matrix: new e2.c8(t22), u_normalize_matrix: new e2.c8(t22), u_merc_matrix: new e2.c8(t22), u_zoom_transition: new e2.cb(t22), u_merc_center: new e2.c9(t22), u_image0: new e2.cc(t22), u_grid_matrix: new e2.dj(t22), u_skirt_height: new e2.cb(t22), u_far_z_cutoff: new e2.cb(t22), u_frustum_tl: new e2.ca(t22), u_frustum_tr: new e2.ca(t22), u_frustum_br: new e2.ca(t22), u_frustum_bl: new e2.ca(t22), u_globe_pos: new e2.ca(t22), u_globe_radius: new e2.cb(t22), u_viewport: new e2.c9(t22) }), globeAtmosphere: (t22) => ({ u_frustum_tl: new e2.ca(t22), u_frustum_tr: new e2.ca(t22), u_frustum_br: new e2.ca(t22), u_frustum_bl: new e2.ca(t22), u_horizon: new e2.cb(t22), u_transition: new e2.cb(t22), u_fadeout_range: new e2.cb(t22), u_color: new e2.cQ(t22), u_high_color: new e2.cQ(t22), u_space_color: new e2.cQ(t22), u_temporal_offset: new e2.cb(t22), u_horizon_angle: new e2.cb(t22) }), model: (t22) => ({ u_matrix: new e2.c8(t22), u_lighting_matrix: new e2.c8(t22), u_normal_matrix: new e2.c8(t22), u_node_matrix: new e2.c8(t22), u_lightpos: new e2.ca(t22), u_lightintensity: new e2.cb(t22), u_lightcolor: new e2.ca(t22), u_camera_pos: new e2.ca(t22), u_opacity: new e2.cb(t22), u_baseColorFactor: new e2.cQ(t22), u_emissiveFactor: new e2.cQ(t22), u_metallicFactor: new e2.cb(t22), u_roughnessFactor: new e2.cb(t22), u_baseTextureIsAlpha: new e2.cc(t22), u_alphaMask: new e2.cc(t22), u_alphaCutoff: new e2.cb(t22), u_baseColorTexture: new e2.cc(t22), u_metallicRoughnessTexture: new e2.cc(t22), u_normalTexture: new e2.cc(t22), u_occlusionTexture: new e2.cc(t22), u_emissionTexture: new e2.cc(t22), u_lutTexture: new e2.cc(t22), u_color_mix: new e2.cQ(t22), u_aoIntensity: new e2.cb(t22), u_emissive_strength: new e2.cb(t22), u_occlusionTextureTransform: new e2.cQ(t22) }), modelDepth: (t22) => ({ u_matrix: new e2.c8(t22), u_instance: new e2.c8(t22), u_node_matrix: new e2.c8(t22) }), groundShadow: (t22) => ({ u_matrix: new e2.c8(t22), u_ground_shadow_factor: new e2.ca(t22) }), stars: (t22) => ({ u_matrix: new e2.c8(t22), u_up: new e2.ca(t22), u_right: new e2.ca(t22), u_intensity_multiplier: new e2.cb(t22) }), snowParticle: (t22) => ({ u_modelview: new e2.c8(t22), u_projection: new e2.c8(t22), u_time: new e2.cb(t22), u_cam_pos: new e2.ca(t22), u_velocityConeAperture: new e2.cb(t22), u_velocity: new e2.cb(t22), u_horizontalOscillationRadius: new e2.cb(t22), u_horizontalOscillationRate: new e2.cb(t22), u_boxSize: new e2.cb(t22), u_billboardSize: new e2.cb(t22), u_simpleShapeParameters: new e2.c9(t22), u_screenSize: new e2.c9(t22), u_thinningCenterPos: new e2.c9(t22), u_thinningShape: new e2.ca(t22), u_thinningAffectedRatio: new e2.cb(t22), u_thinningParticleOffset: new e2.cb(t22), u_particleColor: new e2.cQ(t22), u_direction: new e2.ca(t22) }), rainParticle: (t22) => ({ u_modelview: new e2.c8(t22), u_projection: new e2.c8(t22), u_time: new e2.cb(t22), u_cam_pos: new e2.ca(t22), u_texScreen: new e2.cc(t22), u_velocityConeAperture: new e2.cb(t22), u_velocity: new e2.cb(t22), u_boxSize: new e2.cb(t22), u_rainDropletSize: new e2.c9(t22), u_distortionStrength: new e2.cb(t22), u_rainDirection: new e2.ca(t22), u_color: new e2.cQ(t22), u_screenSize: new e2.c9(t22), u_thinningCenterPos: new e2.c9(t22), u_thinningShape: new e2.ca(t22), u_thinningAffectedRatio: new e2.cb(t22), u_thinningParticleOffset: new e2.cb(t22), u_shapeDirectionalPower: new e2.cb(t22), u_shapeNormalPower: new e2.cb(t22), u_mode: new e2.cb(t22) }), vignette: (t22) => ({ u_vignetteShape: new e2.ca(t22), u_vignetteColor: new e2.cQ(t22) }), occlusion: (t22) => ({ u_matrix: new e2.c8(t22), u_anchorPos: new e2.ca(t22), u_screenSizePx: new e2.c9(t22), u_occluderSizePx: new e2.c9(t22), u_color: new e2.cQ(t22) }) };
      class Cr {
        constructor(e22, t22, i22, o2) {
          this.id = Cr.uniqueIdxCounter, Cr.uniqueIdxCounter++, this.context = e22;
          const s2 = e22.gl;
          this.buffer = s2.createBuffer(), this.dynamicDraw = Boolean(i22), this.context.unbindVAO(), e22.bindElementBuffer.set(this.buffer), s2.bufferData(s2.ELEMENT_ARRAY_BUFFER, t22.arrayBuffer, this.dynamicDraw ? s2.DYNAMIC_DRAW : s2.STATIC_DRAW), this.dynamicDraw || o2 || t22.destroy();
        }
        bind() {
          this.context.bindElementBuffer.set(this.buffer);
        }
        updateData(e22) {
          this.id = Cr.uniqueIdxCounter, Cr.uniqueIdxCounter++;
          const t22 = this.context.gl;
          this.context.unbindVAO(), this.bind(), t22.bufferSubData(t22.ELEMENT_ARRAY_BUFFER, 0, e22.arrayBuffer);
        }
        destroy() {
          this.buffer && (this.context.gl.deleteBuffer(this.buffer), delete this.buffer);
        }
      }
      Cr.uniqueIdxCounter = 0;
      const Rr = { Int8: "BYTE", Uint8: "UNSIGNED_BYTE", Int16: "SHORT", Uint16: "UNSIGNED_SHORT", Int32: "INT", Uint32: "UNSIGNED_INT", Float32: "FLOAT" };
      class Dr {
        constructor(e22, t22, i22, o2, s2, r22) {
          this.length = t22.length, this.attributes = i22, this.itemSize = t22.bytesPerElement, this.dynamicDraw = o2, this.instanceCount = r22, this.context = e22;
          const n22 = e22.gl;
          this.buffer = n22.createBuffer(), e22.bindVertexBuffer.set(this.buffer), n22.bufferData(n22.ARRAY_BUFFER, t22.arrayBuffer, this.dynamicDraw ? n22.DYNAMIC_DRAW : n22.STATIC_DRAW), this.dynamicDraw || s2 || t22.destroy();
        }
        bind() {
          this.context.bindVertexBuffer.set(this.buffer);
        }
        updateData(e22) {
          const t22 = this.context.gl;
          this.bind(), t22.bufferSubData(t22.ARRAY_BUFFER, 0, e22.arrayBuffer);
        }
        enableAttributes(e22, t22) {
          for (let i22 = 0; i22 < this.attributes.length; i22++) {
            const o2 = t22.attributes[this.attributes[i22].name];
            void 0 !== o2 && e22.enableVertexAttribArray(o2);
          }
        }
        setVertexAttribPointers(e22, t22, i22) {
          for (let o2 = 0; o2 < this.attributes.length; o2++) {
            const s2 = this.attributes[o2], r22 = t22.attributes[s2.name];
            void 0 !== r22 && e22.vertexAttribPointer(r22, s2.components, e22[Rr[s2.type]], false, this.itemSize, s2.offset + this.itemSize * (i22 || 0));
          }
        }
        setVertexAttribDivisor(e22, t22, i22) {
          for (let o2 = 0; o2 < this.attributes.length; o2++) {
            const s2 = t22.attributes[this.attributes[o2].name];
            void 0 !== s2 && this.instanceCount && this.instanceCount > 0 && e22.vertexAttribDivisor(s2, i22);
          }
        }
        destroy() {
          this.buffer && (this.context.gl.deleteBuffer(this.buffer), delete this.buffer);
        }
      }
      class Ar {
        constructor(e22, t22, i22, o2, s2) {
          this.context = e22, this.width = t22, this.height = i22;
          const r22 = this.framebuffer = e22.gl.createFramebuffer();
          o2 && (this.colorAttachment = new Rs(e22, r22)), s2 && (this.depthAttachmentType = s2, this.depthAttachment = "renderbuffer" === s2 ? new Ds(e22, r22) : new As(e22, r22));
        }
        destroy() {
          const e22 = this.context.gl;
          if (this.colorAttachment) {
            const t22 = this.colorAttachment.get();
            t22 && e22.deleteTexture(t22);
          }
          if (this.depthAttachment && this.depthAttachmentType) if ("renderbuffer" === this.depthAttachmentType) {
            const t22 = this.depthAttachment.get();
            t22 && e22.deleteRenderbuffer(t22);
          } else {
            const t22 = this.depthAttachment.get();
            t22 && e22.deleteTexture(t22);
          }
          e22.deleteFramebuffer(this.framebuffer);
        }
      }
      class Lr {
        constructor(e22, t22) {
          this.gl = e22, this.clearColor = new Yo(this), this.clearDepth = new Ko(this), this.clearStencil = new Jo(this), this.colorMask = new Qo(this), this.depthMask = new es2(this), this.stencilMask = new ts(this), this.stencilFunc = new is(this), this.stencilOp = new os(this), this.stencilTest = new ss(this), this.depthRange = new rs(this), this.depthTest = new ns(this), this.depthFunc = new as(this), this.blend = new ls(this), this.blendFunc = new cs(this), this.blendColor = new hs(this), this.blendEquation = new ds(this), this.cullFace = new us(this), this.cullFaceSide = new _s(this), this.frontFace = new ps(this), this.program = new fs(this), this.activeTexture = new ms(this), this.viewport = new gs(this), this.bindFramebuffer = new vs(this), this.bindRenderbuffer = new ys(this), this.bindTexture = new xs(this), this.bindVertexBuffer = new bs(this), this.bindElementBuffer = new ws(this), this.bindVertexArrayOES = new Ts(this), this.pixelStoreUnpack = new Es(this), this.pixelStoreUnpackPremultiplyAlpha = new Ss(this), this.pixelStoreUnpackFlipY = new Is(this), this.options = t22 ? Object.assign({}, t22) : {}, this.options.extTextureFilterAnisotropicForceOff || (this.extTextureFilterAnisotropic = e22.getExtension("EXT_texture_filter_anisotropic") || e22.getExtension("MOZ_EXT_texture_filter_anisotropic") || e22.getExtension("WEBKIT_EXT_texture_filter_anisotropic"), this.extTextureFilterAnisotropic && (this.extTextureFilterAnisotropicMax = e22.getParameter(this.extTextureFilterAnisotropic.MAX_TEXTURE_MAX_ANISOTROPY_EXT))), this.extDebugRendererInfo = e22.getExtension("WEBGL_debug_renderer_info"), this.extDebugRendererInfo && (this.renderer = e22.getParameter(this.extDebugRendererInfo.UNMASKED_RENDERER_WEBGL), this.vendor = e22.getParameter(this.extDebugRendererInfo.UNMASKED_VENDOR_WEBGL)), this.forceManualRenderingForInstanceIDShaders = t22 && !!t22.forceManualRenderingForInstanceIDShaders || this.renderer && -1 !== this.renderer.indexOf("PowerVR"), this.options.extTextureFloatLinearForceOff || (this.extTextureFloatLinear = e22.getExtension("OES_texture_float_linear")), this.extRenderToTextureHalfFloat = e22.getExtension("EXT_color_buffer_half_float"), this.extTimerQuery = e22.getExtension("EXT_disjoint_timer_query_webgl2"), this.maxTextureSize = e22.getParameter(e22.MAX_TEXTURE_SIZE), this.maxPointSize = e22.getParameter(e22.ALIASED_POINT_SIZE_RANGE)[1];
        }
        setDefault() {
          this.unbindVAO(), this.clearColor.setDefault(), this.clearDepth.setDefault(), this.clearStencil.setDefault(), this.colorMask.setDefault(), this.depthMask.setDefault(), this.stencilMask.setDefault(), this.stencilFunc.setDefault(), this.stencilOp.setDefault(), this.stencilTest.setDefault(), this.depthRange.setDefault(), this.depthTest.setDefault(), this.depthFunc.setDefault(), this.blend.setDefault(), this.blendFunc.setDefault(), this.blendColor.setDefault(), this.blendEquation.setDefault(), this.cullFace.setDefault(), this.cullFaceSide.setDefault(), this.frontFace.setDefault(), this.program.setDefault(), this.activeTexture.setDefault(), this.bindFramebuffer.setDefault(), this.pixelStoreUnpack.setDefault(), this.pixelStoreUnpackPremultiplyAlpha.setDefault(), this.pixelStoreUnpackFlipY.setDefault();
        }
        setDirty() {
          this.clearColor.dirty = true, this.clearDepth.dirty = true, this.clearStencil.dirty = true, this.colorMask.dirty = true, this.depthMask.dirty = true, this.stencilMask.dirty = true, this.stencilFunc.dirty = true, this.stencilOp.dirty = true, this.stencilTest.dirty = true, this.depthRange.dirty = true, this.depthTest.dirty = true, this.depthFunc.dirty = true, this.blend.dirty = true, this.blendFunc.dirty = true, this.blendColor.dirty = true, this.blendEquation.dirty = true, this.cullFace.dirty = true, this.cullFaceSide.dirty = true, this.frontFace.dirty = true, this.program.dirty = true, this.activeTexture.dirty = true, this.viewport.dirty = true, this.bindFramebuffer.dirty = true, this.bindRenderbuffer.dirty = true, this.bindTexture.dirty = true, this.bindVertexBuffer.dirty = true, this.bindElementBuffer.dirty = true, this.bindVertexArrayOES.dirty = true, this.pixelStoreUnpack.dirty = true, this.pixelStoreUnpackPremultiplyAlpha.dirty = true, this.pixelStoreUnpackFlipY.dirty = true;
        }
        createIndexBuffer(e22, t22, i22) {
          return new Cr(this, e22, t22, i22);
        }
        createVertexBuffer(e22, t22, i22, o2, s2) {
          return new Dr(this, e22, t22, i22, o2, s2);
        }
        createRenderbuffer(e22, t22, i22) {
          const o2 = this.gl, s2 = o2.createRenderbuffer();
          return this.bindRenderbuffer.set(s2), o2.renderbufferStorage(o2.RENDERBUFFER, e22, t22, i22), this.bindRenderbuffer.set(null), s2;
        }
        createFramebuffer(e22, t22, i22, o2) {
          return new Ar(this, e22, t22, i22, o2);
        }
        clear({ color: e22, depth: t22, stencil: i22, colorMask: o2 }) {
          const s2 = this.gl;
          let r22 = 0;
          e22 && (r22 |= s2.COLOR_BUFFER_BIT, this.clearColor.set(e22), this.colorMask.set(o2 || [true, true, true, true])), void 0 !== t22 && (r22 |= s2.DEPTH_BUFFER_BIT, this.depthRange.set([0, 1]), this.clearDepth.set(t22), this.depthMask.set(true)), void 0 !== i22 && (r22 |= s2.STENCIL_BUFFER_BIT, this.clearStencil.set(i22), this.stencilMask.set(255)), s2.clear(r22);
        }
        setCullFace(e22) {
          false === e22.enable ? this.cullFace.set(false) : (this.cullFace.set(true), this.cullFaceSide.set(e22.mode), this.frontFace.set(e22.frontFace));
        }
        setDepthMode(e22) {
          e22.func !== this.gl.ALWAYS || e22.mask ? (this.depthTest.set(true), this.depthFunc.set(e22.func), this.depthMask.set(e22.mask), this.depthRange.set(e22.range)) : this.depthTest.set(false);
        }
        setStencilMode(e22) {
          e22.test.func !== this.gl.ALWAYS || e22.mask ? (this.stencilTest.set(true), this.stencilMask.set(e22.mask), this.stencilOp.set([e22.fail, e22.depthFail, e22.pass]), this.stencilFunc.set({ func: e22.test.func, ref: e22.ref, mask: e22.test.mask })) : this.stencilTest.set(false);
        }
        setColorMode(t22) {
          e2.bv(t22.blendFunction, ki.Replace) ? this.blend.set(false) : (this.blend.set(true), this.blendFunc.set(t22.blendFunction), this.blendColor.set(t22.blendColor), t22.blendEquation ? this.blendEquation.set(t22.blendEquation) : this.blendEquation.setDefault()), this.colorMask.set(t22.mask);
        }
        unbindVAO() {
          this.bindVertexArrayOES.set(null);
        }
      }
      let Pr;
      function zr(t22, i22, o2, s2, r22, n22, a22) {
        const l22 = t22.context, c22 = l22.gl, h22 = t22.transform, d22 = t22.getOrCreateProgram("collisionBox"), u22 = [];
        let _22 = 0, p22 = 0;
        for (let l3 = 0; l3 < s2.length; l3++) {
          const f3 = s2[l3], m3 = i22.getTile(f3), g3 = m3.getBucket(o2);
          if (!g3) continue;
          const v3 = ci(f3, g3, h22);
          let y3 = v3;
          0 === r22[0] && 0 === r22[1] || (y3 = t22.translatePosMatrix(v3, m3, r22, n22));
          const x3 = a22 ? g3.textCollisionBox : g3.iconCollisionBox, b22 = g3.collisionCircleArray;
          if (b22.length > 0) {
            const t3 = e2.bz(), i3 = y3;
            e2.cB(t3, g3.placementInvProjMatrix, h22.glCoordMatrix), e2.cB(t3, t3, g3.placementViewportMatrix), u22.push({ circleArray: b22, circleOffset: p22, transform: i3, invTransform: t3, projection: g3.getProjection() }), _22 += b22.length / 4, p22 = _22;
          }
          x3 && (t22.terrain && t22.terrain.setupElevationDraw(m3, d22), d22.draw(t22, c22.LINES, Ni.disabled, ji.disabled, t22.colorModeForRenderPass(), qi.disabled, ar(y3, h22, m3, g3.getProjection()), o2.id, x3.layoutVertexBuffer, x3.indexBuffer, x3.segments, null, h22.zoom, null, [x3.collisionVertexBuffer, x3.collisionVertexBufferExt]));
        }
        if (!a22 || !u22.length) return;
        const f22 = t22.getOrCreateProgram("collisionCircle"), m22 = new e2.dI();
        m22.resize(4 * _22), m22._trim();
        let g22 = 0;
        for (const e22 of u22) for (let t3 = 0; t3 < e22.circleArray.length / 4; t3++) {
          const i3 = 4 * t3, o3 = e22.circleArray[i3 + 0], s3 = e22.circleArray[i3 + 1], r3 = e22.circleArray[i3 + 2], n3 = e22.circleArray[i3 + 3];
          m22.emplace(g22++, o3, s3, r3, n3, 0), m22.emplace(g22++, o3, s3, r3, n3, 1), m22.emplace(g22++, o3, s3, r3, n3, 2), m22.emplace(g22++, o3, s3, r3, n3, 3);
        }
        (!Pr || Pr.length < 2 * _22) && (Pr = function(t3) {
          const i3 = 2 * t3, o3 = new e2.a_();
          o3.resize(i3), o3._trim();
          for (let e22 = 0; e22 < i3; e22++) {
            const t4 = 6 * e22;
            o3.uint16[t4 + 0] = 4 * e22 + 0, o3.uint16[t4 + 1] = 4 * e22 + 1, o3.uint16[t4 + 2] = 4 * e22 + 2, o3.uint16[t4 + 3] = 4 * e22 + 2, o3.uint16[t4 + 4] = 4 * e22 + 3, o3.uint16[t4 + 5] = 4 * e22 + 0;
          }
          return o3;
        }(_22));
        const v22 = l22.createIndexBuffer(Pr, true), y22 = l22.createVertexBuffer(m22, e2.dJ.members, true);
        for (const i3 of u22) {
          const s3 = { u_matrix: i3.transform, u_inv_matrix: i3.invTransform, u_camera_to_center_distance: (x22 = h22).getCameraToCenterDistance(i3.projection), u_viewport_size: [x22.width, x22.height] };
          f22.draw(t22, c22.TRIANGLES, Ni.disabled, ji.disabled, t22.colorModeForRenderPass(), qi.disabled, s3, o2.id, y22, v22, e2.bd.simpleSegment(0, 2 * i3.circleOffset, i3.circleArray.length, i3.circleArray.length / 2), null, h22.zoom);
        }
        var x22;
        y22.destroy(), v22.destroy();
      }
      const Mr = e2.bz();
      function Or(t22) {
        const i22 = t22._camera.getWorldToCamera(t22.worldSize, 1), o2 = e2.az([], i22, t22.globeMatrix);
        e2.bi(o2, o2);
        const s2 = [0, 0, 0], r22 = [0, 1, 0, 0];
        return e2.aA(r22, r22, o2), s2[0] = r22[0], s2[1] = r22[1], s2[2] = r22[2], e2.au(s2, s2), s2;
      }
      function Fr({ width: t22, height: i22, anchor: o2, textOffset: s2, textScale: r22 }, n22) {
        const { horizontalAlign: a22, verticalAlign: l22 } = e2.bV(o2), c22 = -(a22 - 0.5) * t22, h22 = -(l22 - 0.5) * i22, d22 = e2.bU(o2, s2);
        return new e2.P((c22 / r22 + d22[0]) * n22, (h22 / r22 + d22[1]) * n22);
      }
      function Br(t22, i22, o2, s2, r22, n22, a22, l22, c22, h22) {
        const d22 = t22.text.placedSymbolArray, u22 = t22.text.dynamicLayoutVertexArray, _22 = t22.icon.dynamicLayoutVertexArray, p22 = {}, f22 = t22.getProjection(), m22 = hi(a22, f22, r22), g22 = r22.elevation, v22 = f22.upVectorScale(a22.canonical, r22.center.lat, r22.worldSize).metersToTile;
        u22.clear();
        for (let _3 = 0; _3 < d22.length; _3++) {
          const y22 = d22.get(_3), { tileAnchorX: x22, tileAnchorY: b22, numGlyphs: w22 } = y22, T2 = y22.hidden || !y22.crossTileID || t22.allowVerticalPlacement && !y22.placedOrientation ? null : s2[y22.crossTileID];
          if (T2) {
            let s3 = 0, d3 = 0, _4 = 0;
            if (g22) {
              const e22 = g22 ? g22.getAtTileOffset(a22, x22, b22) : 0, [t3, i3, o3] = f22.upVector(a22.canonical, x22, b22);
              s3 = e22 * t3 * v22, d3 = e22 * i3 * v22, _4 = e22 * o3 * v22;
            }
            let [E22, S2, I2, C22] = $t2(y22.projectedAnchorX + s3, y22.projectedAnchorY + d3, y22.projectedAnchorZ + _4, o2 ? m22 : n22);
            const R22 = Xt2(r22.getCameraToCenterDistance(f22), C22);
            let D22 = e2.bJ(t22.textSizeData, c22, y22) * R22 / e2.bO;
            o2 && (D22 *= t22.tilePixelRatio / l22);
            const A22 = Fr(T2, D22);
            o2 ? ({ x: E22, y: S2, z: I2 } = f22.projectTilePoint(x22 + A22.x, b22 + A22.y, a22.canonical), [E22, S2, I2] = $t2(E22 + s3, S2 + d3, I2 + _4, n22)) : (i22 && A22._rotate(-r22.angle), E22 += A22.x, S2 += A22.y, I2 = 0);
            const L22 = t22.allowVerticalPlacement && y22.placedOrientation === e2.bI.vertical ? Math.PI / 2 : 0;
            for (let t3 = 0; t3 < w22; t3++) e2.bL(u22, E22, S2, I2, L22);
            h22 && y22.associatedIconIndex >= 0 && (p22[y22.associatedIconIndex] = { x: E22, y: S2, z: I2, angle: L22 });
          } else si(w22, u22);
        }
        if (h22) {
          _22.clear();
          const i3 = t22.icon.placedSymbolArray;
          for (let t3 = 0; t3 < i3.length; t3++) {
            const o3 = i3.get(t3), { numGlyphs: s3 } = o3, r3 = p22[t3];
            if (o3.hidden || !r3) si(s3, _22);
            else {
              const { x: t4, y: i4, z: o4, angle: n3 } = r3;
              for (let r4 = 0; r4 < s3; r4++) e2.bL(_22, t4, i4, o4, n3);
            }
          }
          t22.icon.dynamicLayoutVertexBuffer.updateData(_22);
        }
        t22.text.dynamicLayoutVertexBuffer.updateData(u22);
      }
      function kr(t22, i22, o2, s2, r22, n22, a22 = {}) {
        const l22 = o2.paint.get("icon-translate"), c22 = o2.paint.get("text-translate"), h22 = o2.paint.get("icon-translate-anchor"), d22 = o2.paint.get("text-translate-anchor"), u22 = o2.layout.get("icon-rotation-alignment"), _22 = o2.layout.get("text-rotation-alignment"), p22 = o2.layout.get("icon-pitch-alignment"), f22 = o2.layout.get("text-pitch-alignment"), m22 = o2.layout.get("icon-keep-upright"), g22 = o2.layout.get("text-keep-upright"), v22 = o2.paint.get("icon-color-saturation"), y22 = o2.paint.get("icon-color-contrast"), x22 = o2.paint.get("icon-color-brightness-min"), b22 = o2.paint.get("icon-color-brightness-max"), w22 = "sea" === o2.layout.get("symbol-elevation-reference"), T2 = t22.context, E22 = T2.gl, S2 = t22.transform, I2 = "map" === u22, C22 = "map" === _22, R22 = "map" === p22, D22 = "map" === f22, A22 = void 0 !== o2.layout.get("symbol-sort-key").constantOr(1);
        let L22 = false;
        const P22 = t22.depthModeForSublayer(0, Ni.ReadOnly), z22 = new Ni(t22.context.gl.LEQUAL, Ni.ReadOnly, t22.depthRangeFor3D), M22 = [e2.ay(S2.center.lng), e2.aH(S2.center.lat)], O2 = o2.layout.get("text-variable-anchor"), F2 = "globe" === S2.projection.name, B22 = [], k22 = [0, -1, 0];
        for (const r3 of s2) {
          const s3 = i22.getTile(r3), n3 = s3.getBucket(o2);
          if (!n3) continue;
          if ("mercator" === n3.projection.name && F2) continue;
          if (n3.fullyClipped) continue;
          const u3 = "globe" === n3.projection.name, _3 = u3 ? e2.ah(S2.zoom) : 0, p3 = hi(r3, n3.getProjection(), S2), f3 = S2.calculatePixelsToTileUnitsMatrix(s3), T3 = O2 && n3.hasTextData(), N22 = n3.hasIconTextFit() && T3 && n3.hasIconData(), U22 = "road" === n3.elevationType ? z22 : P22, j22 = n3.getProjection().createInversionMatrix(S2, r3.canonical), V2 = t22.shadowRenderer, G2 = "road" === n3.elevationType && !!V2 && V2.enabled;
          let q22 = [0, 0, 0];
          if (G2) {
            const e22 = t22.style.directionalLight, i3 = t22.style.ambientLight;
            e22 && i3 && (q22 = ao(t22.style, e22, i3));
          }
          const Z2 = (e22) => {
            S2.depthOcclusionForSymbolsAndCircles && (o2.hasInitialOcclusionOpacityProperties || t22.terrain) && (e22.push("DEPTH_D24"), e22.push("DEPTH_OCCLUSION"));
          }, H2 = () => {
            const i3 = I2 && "point" !== o2.layout.get("symbol-placement"), a3 = [];
            Z2(a3);
            const c3 = i3 || N22, d3 = o2.paint.get("icon-image-cross-fade");
            t22.terrainRenderModeElevated() && R22 && a3.push("PITCH_WITH_MAP_TERRAIN"), u3 && (a3.push("PROJECTION_GLOBE_VIEW"), c3 && a3.push("PROJECTED_POS_ON_VIEWPORT")), d3 > 0 && a3.push("ICON_TRANSITION"), n3.icon.zOffsetVertexBuffer && a3.push("Z_OFFSET"), 0 === v22 && 0 === y22 && 0 === x22 && 1 === b22 || a3.push("COLOR_ADJUSTMENT"), n3.sdfIcons && a3.push("RENDER_SDF"), G2 && a3.push("RENDER_SHADOWS", "DEPTH_TEXTURE", "NORMAL_OFFSET");
            const g3 = n3.icon.programConfigurations.get(o2.id), T4 = t22.getOrCreateProgram("symbol", { config: g3, defines: a3 }), C3 = s3.imageAtlasTexture ? s3.imageAtlasTexture.size : [0, 0], D3 = n3.iconSizeData, A3 = e2.bH(D3, S2.zoom), L3 = R22 || 0 !== S2.pitch, P3 = Zt2(p3, s3.tileID.canonical, R22, I2, S2, n3.getProjection(), f3), z3 = Wt2(p3, s3.tileID.canonical, R22, I2, S2, n3.getProjection(), f3), O3 = t22.translatePosMatrix(z3, s3, l22, h22, true), B3 = t22.translatePosMatrix(p3, s3, l22, h22), V3 = c3 ? Mr : P3, H3 = I2 && !R22 && !i3;
            let W3 = k22;
            !F2 && !S2.mercatorFromTransition || I2 || (W3 = Or(S2));
            const $3 = u3 ? W3 : k22, X3 = o2.getColorAdjustmentMatrix(v22, y22, x22, b22), Y3 = xr(D3.kind, A3, H3, R22, t22, B3, V3, O3, w22, false, C3, [0, 0], true, r3, _3, M22, j22, $3, n3.getProjection(), q22, X3, d3), K3 = s3.imageAtlasTexture ? s3.imageAtlasTexture : null, J3 = 1 !== o2.layout.get("icon-size").constantOr(0) || n3.iconsNeedLinear, Q3 = n3.sdfIcons || t22.options.rotating || t22.options.zooming || J3 || L3 ? E22.LINEAR : E22.NEAREST, ee22 = n3.sdfIcons && 0 !== o2.paint.get("icon-halo-width").constantOr(1), te22 = t22.terrain && R22 && i3 ? e2.bi(e2.bz(), P3) : Mr;
            if (i3 && n3.icon) {
              const e22 = S2.elevation, i4 = e22 ? e22.getAtTileOffsetFunc(r3, S2.center.lat, S2.worldSize, n3.getProjection()) : null, o3 = Ht2(p3, s3.tileID.canonical, R22, I2, S2, n3.getProjection(), f3);
              Kt2(n3, p3, t22, false, o3, z3, R22, m22, i4, r3);
            }
            return { program: T4, buffers: n3.icon, uniformValues: Y3, atlasTexture: K3, atlasTextureIcon: null, atlasInterpolation: Q3, atlasInterpolationIcon: null, isSDF: n3.sdfIcons, hasHalo: ee22, depthMode: U22, tile: s3, renderWithShadows: G2, labelPlaneMatrixInv: te22 };
          }, W2 = () => {
            const i3 = C22 && "point" !== o2.layout.get("symbol-placement"), a3 = [], l3 = i3 || O2 || N22;
            t22.terrainRenderModeElevated() && D22 && a3.push("PITCH_WITH_MAP_TERRAIN"), u3 && (a3.push("PROJECTION_GLOBE_VIEW"), l3 && a3.push("PROJECTED_POS_ON_VIEWPORT")), n3.text.zOffsetVertexBuffer && a3.push("Z_OFFSET"), n3.iconsInText && a3.push("RENDER_TEXT_AND_SYMBOL"), a3.push("RENDER_SDF"), G2 && a3.push("RENDER_SHADOWS", "DEPTH_TEXTURE", "NORMAL_OFFSET"), Z2(a3);
            const h3 = n3.text.programConfigurations.get(o2.id), m3 = t22.getOrCreateProgram("symbol", { config: h3, defines: a3 });
            let v3, y3 = [0, 0], x3 = null;
            const b3 = n3.textSizeData;
            n3.iconsInText && (y3 = s3.imageAtlasTexture ? s3.imageAtlasTexture.size : [0, 0], x3 = s3.imageAtlasTexture ? s3.imageAtlasTexture : null, v3 = D22 || 0 !== S2.pitch || t22.options.rotating || t22.options.zooming || "composite" === b3.kind || "camera" === b3.kind ? E22.LINEAR : E22.NEAREST);
            const T4 = s3.glyphAtlasTexture ? s3.glyphAtlasTexture.size : [0, 0], I3 = o2.layout.get("text-size-scale-range"), R3 = e2.aD(t22.scaleFactor, I3[0], I3[1]), A3 = e2.bH(b3, S2.zoom, R3), L3 = Zt2(p3, s3.tileID.canonical, D22, C22, S2, n3.getProjection(), f3), P3 = Wt2(p3, s3.tileID.canonical, D22, C22, S2, n3.getProjection(), f3), z3 = t22.translatePosMatrix(P3, s3, c22, d22, true), B3 = t22.translatePosMatrix(p3, s3, c22, d22), V3 = l3 ? Mr : L3, H3 = C22 && !D22 && !i3;
            let W3 = k22;
            !F2 && !S2.mercatorFromTransition || C22 || (W3 = Or(S2));
            const $3 = xr(b3.kind, A3, H3, D22, t22, B3, V3, z3, w22, true, T4, y3, true, r3, _3, M22, j22, u3 ? W3 : k22, n3.getProjection(), q22, null, null, R3), X3 = s3.glyphAtlasTexture ? s3.glyphAtlasTexture : null, Y3 = E22.LINEAR, K3 = 0 !== o2.paint.get("text-halo-width").constantOr(1), J3 = t22.terrain && D22 && i3 ? e2.bi(e2.bz(), L3) : Mr;
            if (i3 && n3.text) {
              const e22 = S2.elevation, i4 = e22 ? e22.getAtTileOffsetFunc(r3, S2.center.lat, S2.worldSize, n3.getProjection()) : null, o3 = Ht2(p3, s3.tileID.canonical, D22, C22, S2, n3.getProjection(), f3);
              Kt2(n3, p3, t22, true, o3, P3, D22, g22, i4, r3);
            }
            return { program: m3, buffers: n3.text, uniformValues: $3, atlasTexture: X3, atlasTextureIcon: x3, atlasInterpolation: Y3, atlasInterpolationIcon: v3, isSDF: true, hasHalo: K3, depthMode: U22, tile: s3, renderWithShadows: G2, labelPlaneMatrixInv: J3 };
          }, $2 = n3.icon.segments.get().length, X22 = n3.text.segments.get().length, Y2 = $2 && !a22.onlyText ? H2() : null, K22 = X22 && !a22.onlyIcons ? W2() : null, J2 = o2.paint.get("icon-opacity").constantOr(1), Q2 = o2.paint.get("text-opacity").constantOr(1);
          if (A22 && n3.canOverlap) {
            L22 = true;
            const t3 = J2 && !a22.onlyText ? n3.icon.segments.get() : [], i3 = Q2 && !a22.onlyIcons ? n3.text.segments.get() : [];
            for (const i4 of t3) B22.push({ segments: new e2.bd([i4]), sortKey: i4.sortKey, state: Y2 });
            for (const t4 of i3) B22.push({ segments: new e2.bd([t4]), sortKey: t4.sortKey, state: K22 });
          } else a22.onlyText || B22.push({ segments: J2 ? n3.icon.segments : new e2.bd([]), sortKey: 0, state: Y2 }), a22.onlyIcons || B22.push({ segments: Q2 ? n3.text.segments : new e2.bd([]), sortKey: 0, state: K22 });
        }
        L22 && B22.sort((e22, t3) => e22.sortKey - t3.sortKey);
        for (const e22 of B22) {
          const i3 = e22.state;
          if (i3) if (t22.terrain ? t22.terrain.setupElevationDraw(i3.tile, i3.program, { useDepthForOcclusion: S2.depthOcclusionForSymbolsAndCircles, labelPlaneMatrixInv: i3.labelPlaneMatrixInv }) : t22.setupDepthForOcclusion(S2.depthOcclusionForSymbolsAndCircles, i3.program), T2.activeTexture.set(E22.TEXTURE0), i3.atlasTexture && i3.atlasTexture.bind(i3.atlasInterpolation, E22.CLAMP_TO_EDGE, true), i3.atlasTextureIcon && (T2.activeTexture.set(E22.TEXTURE1), i3.atlasTextureIcon && i3.atlasTextureIcon.bind(i3.atlasInterpolationIcon, E22.CLAMP_TO_EDGE, true)), i3.renderWithShadows && t22.shadowRenderer.setupShadows(i3.tile.tileID.toUnwrapped(), i3.program, "vector-tile", i3.tile.tileID.overscaledZ), t22.uploadCommonLightUniforms(t22.context, i3.program), i3.hasHalo) {
            const s3 = i3.uniformValues;
            s3.u_is_halo = 1, Nr(i3.buffers, e22.segments, o2, t22, i3.program, i3.depthMode, r22, n22, s3, 2), s3.u_is_halo = 0;
          } else {
            if (i3.isSDF) {
              const s3 = i3.uniformValues;
              i3.hasHalo && (s3.u_is_halo = 1, Nr(i3.buffers, e22.segments, o2, t22, i3.program, i3.depthMode, r22, n22, s3, 1)), s3.u_is_halo = 0;
            }
            Nr(i3.buffers, e22.segments, o2, t22, i3.program, i3.depthMode, r22, n22, i3.uniformValues, 1);
          }
        }
      }
      function Nr(e22, t22, i22, o2, s2, r22, n22, a22, l22, c22) {
        const h22 = [e22.dynamicLayoutVertexBuffer, e22.opacityVertexBuffer, e22.iconTransitioningVertexBuffer, e22.globeExtVertexBuffer, e22.zOffsetVertexBuffer];
        s2.draw(o2, o2.context.gl.TRIANGLES, r22, n22, a22, qi.disabled, l22, i22.id, e22.layoutVertexBuffer, e22.indexBuffer, t22, i22.paint, o2.transform.zoom, e22.programConfigurations.get(i22.id), h22, c22);
      }
      function Ur(t22, i22) {
        const o2 = 1 << t22.canonical.z, s2 = (i22.x * o2 - t22.canonical.x - t22.wrap * o2) * e2.aj, r22 = (i22.y * o2 - t22.canonical.y) * e2.aj, n22 = e2.dS(i22.z, i22.y);
        return e2.cS(s2, r22, n22);
      }
      function jr(t22, i22, o2, s2, r22) {
        if (!o2.layout || "none" === o2.layout.get("fill-elevation-reference")) return;
        const n22 = t22.context.gl, a22 = new Ni(t22.context.gl.LEQUAL, Ni.ReadWrite, t22.depthRangeFor3D), l22 = new Ni(t22.context.gl.GREATER, Ni.ReadWrite, t22.depthRangeFor3D), c22 = function(t3) {
          const i3 = e2.cJ(t3.pitch);
          let o3 = 0.01;
          return t3.isOrthographic && (o3 = e2.ai(1e-4, o3, e2.cO(i3 >= Ji ? 1 : i3 / Ji))), 2 * o3;
        }(t22.transform), h22 = t22.transform.getFreeCameraOptions().position, d22 = "elevatedStructuresDepthReconstruct", u22 = t22.getOrCreateProgram(d22, { defines: ["DEPTH_RECONSTRUCTION"] }), _22 = t22.getOrCreateProgram(d22);
        for (const e22 of s2) {
          const s3 = i22.getTile(e22), d3 = s3.getBucket(o2);
          if (!d3) continue;
          const p22 = d3.elevatedStructures;
          if (!p22) continue;
          const f22 = d3.elevationBufferData.heightRange, m22 = Ur(e22.toUnwrapped(), h22), g22 = t22.translatePosMatrix(e22.projMatrix, s3, o2.paint.get("fill-translate"), o2.paint.get("fill-translate-anchor"));
          let v22, y22, x22, b22;
          if ("initialize" === r22) {
            if (!f22 || f22.min >= 1 || 0 === p22.depthSegments.segments[0].primitiveLength) continue;
            v22 = nr(g22, m22, c22, 1, 0), y22 = a22, x22 = p22.depthSegments, b22 = u22;
          } else if ("reset" === r22) {
            if (!f22 || f22.min >= 0 || 0 === p22.maskSegments.segments[0].primitiveLength) continue;
            v22 = nr(g22, m22, 0, 0, 1), y22 = l22, x22 = p22.maskSegments, b22 = u22;
          } else if ("geometry" === r22) {
            if (0 === p22.depthSegments.segments[0].primitiveLength) continue;
            v22 = nr(g22, m22, c22, 1, 0), y22 = a22, x22 = p22.depthSegments, b22 = _22;
          }
          b22.draw(t22, n22.TRIANGLES, y22, ji.disabled, ki.disabled, qi.disabled, v22, o2.id, p22.vertexBuffer, p22.indexBuffer, x22, o2.paint, t22.transform.zoom);
        }
      }
      function Vr(t22, i22, o2) {
        const { painter: s2, sourceCache: r22, layer: n22, coords: a22, colorMode: l22, elevationType: c22, terrainEnabled: h22, pass: d22 } = t22, u22 = s2.context.gl, _22 = n22.paint.get("fill-pattern"), p22 = n22.paint.get("fill-pattern-cross-fade"), f22 = _22.constantOr(null);
        let m22 = c22;
        "road" !== c22 || i22 && !h22 || (m22 = "none");
        const g22 = "road" === m22, v22 = t22.painter.shadowRenderer, y22 = g22 && !!v22 && v22.enabled, x22 = new Ni(s2.context.gl.LEQUAL, Ni.ReadOnly, s2.depthRangeFor3D);
        let b22 = [0, 0, 0];
        if (y22) {
          const e22 = s2.style.directionalLight, t3 = s2.style.ambientLight;
          e22 && t3 && (b22 = ao(s2.style, e22, t3));
        }
        const w22 = _22 && _22.constantOr(1), T2 = (t3, d3) => {
          let _3, m3, T3, E22, S2;
          d3 ? (_3 = w22 && !n22.getPaintProperty("fill-outline-color") ? "fillOutlinePattern" : "fillOutline", T3 = u22.LINES) : (_3 = w22 ? "fillPattern" : "fill", T3 = u22.TRIANGLES);
          for (const I2 of a22) {
            const a3 = r22.getTile(I2);
            if (w22 && !a3.patternsLoaded()) continue;
            const C22 = a3.getBucket(n22);
            if (!C22) continue;
            const R22 = i22 ? C22.elevationBufferData : C22.bufferData;
            if (R22.isEmpty()) continue;
            s2.prepareDrawTile();
            const D22 = R22.programConfigurations.get(n22.id), A22 = s2.isTileAffectedByFog(I2), L22 = [], P22 = [];
            g22 && (L22.push("ELEVATED_ROADS"), P22.push(R22.elevatedLayoutVertexBuffer)), y22 && L22.push("RENDER_SHADOWS", "DEPTH_TEXTURE", "NORMAL_OFFSET"), w22 && (s2.context.activeTexture.set(u22.TEXTURE0), a3.imageAtlasTexture && a3.imageAtlasTexture.bind(u22.LINEAR, u22.CLAMP_TO_EDGE), D22.updatePaintBuffers());
            let z22 = false;
            if (f22 && a3.imageAtlas) {
              const t4 = a3.imageAtlas, i3 = e2.dN.from(f22), o3 = i3.getPrimary().scaleSelf(e2.q.devicePixelRatio).toString(), s3 = i3.getSecondary(), r3 = t4.patternPositions.get(o3), n3 = s3 ? t4.patternPositions.get(s3.scaleSelf(e2.q.devicePixelRatio).toString()) : null;
              z22 = !!r3 && !!n3, r3 && D22.setConstantPatternPositions(r3, n3);
            }
            p22 > 0 && (z22 || D22.getPatternTransitionVertexBuffer("fill-pattern")) && L22.push("FILL_PATTERN_TRANSITION");
            const M22 = s2.getOrCreateProgram(_3, { config: D22, overrideFog: A22, defines: L22 }), O2 = s2.translatePosMatrix(I2.projMatrix, a3, n22.paint.get("fill-translate"), n22.paint.get("fill-translate-anchor"));
            y22 && v22.setupShadows(a3.tileID.toUnwrapped(), M22, "vector-tile", a3.tileID.overscaledZ);
            const F2 = n22.paint.get("fill-emissive-strength");
            if (d3) {
              E22 = R22.lineIndexBuffer, S2 = R22.lineSegments;
              const e22 = s2.terrain && s2.terrain.renderingToTexture ? s2.terrain.drapeBufferSize : [u22.drawingBufferWidth, u22.drawingBufferHeight];
              m3 = "fillOutlinePattern" === _3 && w22 ? sr(O2, F2, s2, a3, e22, b22, p22) : or(O2, F2, e22, b22);
            } else E22 = R22.indexBuffer, S2 = R22.triangleSegments, m3 = w22 ? ir(O2, F2, s2, a3, b22, p22) : tr(O2, F2, b22);
            s2.uploadCommonUniforms(s2.context, M22, I2.toUnwrapped());
            let B22 = t3;
            ("road" === c22 && !h22 || "offset" === c22) && (B22 = x22), M22.draw(s2, T3, B22, o2 || s2.stencilModeForClipping(I2), l22, qi.disabled, m3, n22.id, R22.layoutVertexBuffer, E22, S2, n22.paint, s2.transform.zoom, D22, P22);
          }
        };
        s2.renderPass === d22 && T2(s2.depthModeForSublayer(1, "opaque" === s2.renderPass ? Ni.ReadWrite : Ni.ReadOnly), false), "none" === m22 && "translucent" === s2.renderPass && n22.paint.get("fill-antialias") && T2(s2.depthModeForSublayer(n22.getPaintProperty("fill-outline-color") ? 2 : 0, Ni.ReadOnly), true);
      }
      function Gr(t22, i22, o2, s2, r22, n22, a22, l22) {
        o2.resetLayerRenderingStats(t22);
        const c22 = t22.context, h22 = c22.gl, d22 = t22.transform, u22 = o2.paint.get("fill-extrusion-pattern"), _22 = o2.paint.get("fill-extrusion-pattern-cross-fade"), p22 = u22.constantOr(null), f22 = u22.constantOr(1), m22 = o2.paint.get("fill-extrusion-opacity"), g22 = t22.style.enable3dLights(), v22 = o2.paint.get(g22 && !f22 ? "fill-extrusion-ambient-occlusion-wall-radius" : "fill-extrusion-ambient-occlusion-radius"), y22 = [o2.paint.get("fill-extrusion-ambient-occlusion-intensity"), v22], x22 = o2.layout.get("fill-extrusion-edge-radius"), b22 = x22 > 0 && !o2.paint.get("fill-extrusion-rounded-roof"), w22 = b22 ? 0 : x22, T2 = "globe" === d22.projection.name ? e2.dT() : 0, E22 = "globe" === d22.projection.name, S2 = E22 ? e2.ah(d22.zoom) : 0, I2 = [e2.ay(d22.center.lng), e2.aH(d22.center.lat)], C22 = "none" === o2.paint.get("fill-extrusion-flood-light-color-use-theme").constantOr("default"), R22 = o2.paint.get("fill-extrusion-flood-light-color").toRenderColor(C22 ? null : o2.lut).toArray01().slice(0, 3), D22 = o2.paint.get("fill-extrusion-flood-light-intensity"), A22 = o2.paint.get("fill-extrusion-vertical-scale"), L22 = 0 !== o2.paint.get("fill-extrusion-line-width").constantOr(1), P22 = o2.paint.get("fill-extrusion-height-alignment"), z22 = o2.paint.get("fill-extrusion-base-alignment"), M22 = eo(t22, o2.paint.get("fill-extrusion-cutoff-fade-range")), O2 = [];
        let F2;
        E22 && O2.push("PROJECTION_GLOBE_VIEW"), y22[0] > 0 && O2.push("FAUX_AO"), b22 && O2.push("ZERO_ROOF_RADIUS"), l22 && O2.push("HAS_CENTROID"), D22 > 0 && O2.push("FLOOD_LIGHT"), M22.shouldRenderCutoff && O2.push("RENDER_CUTOFF"), L22 && O2.push("RENDER_WALL_MODE");
        const B22 = "shadow" === t22.renderPass, k22 = t22.shadowRenderer, N22 = B22 && !!k22, U22 = B22 ? qi.disabled : qi.backCCW;
        t22.shadowRenderer && (t22.shadowRenderer.useNormalOffset = true);
        let j22 = [0, 0, 0];
        if (k22) {
          const e22 = t22.style.directionalLight, i3 = t22.style.ambientLight;
          e22 && i3 && (j22 = ao(t22.style, e22, i3)), B22 || (O2.push("RENDER_SHADOWS", "DEPTH_TEXTURE"), k22.useNormalOffset && O2.push("NORMAL_OFFSET")), F2 = O2.concat(["SHADOWS_SINGLE_CASCADE"]);
        }
        const V2 = N22 ? "fillExtrusionDepth" : f22 ? "fillExtrusionPattern" : "fillExtrusion", G2 = o2.getLayerRenderingStats();
        for (const u3 of s2) {
          const s3 = i22.getTile(u3), g3 = s3.getBucket(o2);
          if (!g3 || g3.projection.name !== d22.projection.name) continue;
          let v3 = false;
          k22 && (v3 = 0 === k22.getMaxCascadeForTile(u3.toUnwrapped()));
          const x3 = t22.isTileAffectedByFog(u3), b3 = g3.programConfigurations.get(o2.id);
          let C3 = false;
          if (p22 && s3.imageAtlas) {
            const t3 = s3.imageAtlas, i3 = e2.dN.from(p22), o3 = i3.getPrimary().scaleSelf(e2.q.devicePixelRatio).toString(), r3 = i3.getSecondary(), n3 = t3.patternPositions.get(o3), a3 = r3 ? t3.patternPositions.get(r3.scaleSelf(e2.q.devicePixelRatio).toString()) : null;
            C3 = !!n3 && !!a3, n3 && b3.setConstantPatternPositions(n3, a3);
          }
          _22 > 0 && (C3 || b3.getPatternTransitionVertexBuffer("fill-extrusion-pattern")) && O2.push("FILL_EXTRUSION_PATTERN_TRANSITION");
          const N3 = t22.getOrCreateProgram(V2, { config: b3, defines: v3 ? F2 : O2, overrideFog: x3 });
          if (t22.terrain && t22.terrain.setupElevationDraw(s3, N3, { useMeterToDem: true }), !g3.centroidVertexBuffer) {
            const e22 = N3.attributes.a_centroid_pos;
            void 0 !== e22 && h22.vertexAttrib2f(e22, 0, 0);
          }
          !B22 && k22 && k22.setupShadows(s3.tileID.toUnwrapped(), N3, "vector-tile", s3.tileID.overscaledZ), f22 && (t22.context.activeTexture.set(h22.TEXTURE0), s3.imageAtlasTexture && s3.imageAtlasTexture.bind(h22.LINEAR, h22.CLAMP_TO_EDGE), b3.updatePaintBuffers());
          const q22 = o2.paint.get("fill-extrusion-vertical-gradient"), Z2 = 1 / g3.tileToMeter;
          let H2;
          if (B22 && k22) {
            if (Xr(s3.tileID, g3, t22)) continue;
            const e22 = k22.calculateShadowPassMatrixFromTile(s3.tileID.toUnwrapped());
            H2 = Qs(e22, w22, Z2, A22, P22, z22);
          } else {
            const e22 = t22.translatePosMatrix(u3.expandedProjMatrix, s3, o2.paint.get("fill-extrusion-translate"), o2.paint.get("fill-extrusion-translate-anchor")), i3 = d22.projection.createInversionMatrix(d22, u3.canonical);
            H2 = f22 ? er(e22, t22, q22, m22, y22, w22, Z2, u3, s3, T2, P22, z22, S2, I2, i3, R22, A22, _22) : Js(e22, t22, q22, m22, y22, w22, Z2, u3, T2, P22, z22, S2, I2, i3, R22, A22, D22, j22);
          }
          t22.uploadCommonUniforms(c22, N3, u3.toUnwrapped(), null, M22);
          let W2 = g3.segments;
          if ("mercator" === d22.projection.name && !B22 && (W2 = g3.getVisibleSegments(s3.tileID, t22.terrain, t22.transform.getFrustum(0)), !W2.get().length)) continue;
          if (G2) if (B22) for (const e22 of W2.get()) G2.numRenderedVerticesInShadowPass += e22.primitiveLength;
          else for (const e22 of W2.get()) G2.numRenderedVerticesInTransparentPass += e22.primitiveLength;
          const $2 = [];
          (t22.terrain || l22) && $2.push(g3.centroidVertexBuffer), E22 && $2.push(g3.layoutVertexExtBuffer), L22 && $2.push(g3.wallVertexBuffer), N3.draw(t22, c22.gl.TRIANGLES, r22, n22, a22, U22, H2, o2.id, g3.layoutVertexBuffer, g3.indexBuffer, W2, o2.paint, t22.transform.zoom, b3, $2);
        }
        t22.shadowRenderer && (t22.shadowRenderer.useNormalOffset = false);
      }
      function qr(t22, i22, o2, s2, r22, n22, a22, l22, c22, h22, d22, u22, _22, p22, f22, m22, g22, v22, y22) {
        const x22 = t22.context, b22 = x22.gl, w22 = t22.transform, T2 = t22.transform.zoom, E22 = [], S2 = eo(t22, o2.paint.get("fill-extrusion-cutoff-fade-range"));
        "clear" === h22 ? (E22.push("CLEAR_SUBPASS"), y22 && (E22.push("CLEAR_FROM_TEXTURE"), x22.activeTexture.set(b22.TEXTURE0), y22.bind(b22.LINEAR, b22.CLAMP_TO_EDGE))) : "sdf" === h22 && E22.push("SDF_SUBPASS"), g22 && E22.push("HAS_CENTROID"), S2.shouldRenderCutoff && E22.push("RENDER_CUTOFF");
        const I2 = o2.layout.get("fill-extrusion-edge-radius"), C22 = (e22, i3, s3, h3, v3) => {
          const b3 = i3.programConfigurations.get(o2.id), w3 = t22.isTileAffectedByFog(e22), C3 = t22.getOrCreateProgram("fillExtrusionGroundEffect", { config: b3, defines: E22, overrideFog: w3 }), R22 = /* @__PURE__ */ ((e3, t3, i4, o3, s4, r3, n3, a3, l3, c3, h4) => ({ u_matrix: t3, u_opacity: i4, u_ao_pass: o3 ? 1 : 0, u_meter_to_tile: s4, u_ao: r3, u_flood_light_intensity: n3, u_flood_light_color: a3, u_attenuation: l3, u_edge_radius: c3, u_fb: 0, u_fb_size: h4, u_dynamic_offset: 1 }))(0, h3, d22, c22, v3, [u22, _22 * v3], p22, f22, m22, T2 >= 17 ? 0 : I2 * v3, y22 ? y22.size[0] : 0), D22 = [];
          g22 && D22.push(i3.hiddenByLandmarkVertexBuffer), t22.uploadCommonUniforms(x22, C3, e22.toUnwrapped(), null, S2), C3.draw(t22, x22.gl.TRIANGLES, r22, n22, a22, l22, R22, o2.id, i3.vertexBuffer, i3.indexBuffer, s3, o2.paint, T2, b3, D22);
        };
        for (const r3 of s2) {
          const s3 = i22.getTile(r3), n3 = s3.getBucket(o2);
          if (!n3 || n3.projection.name !== w22.projection.name || !n3.groundEffect || n3.groundEffect && !n3.groundEffect.hasData()) continue;
          const a3 = n3.groundEffect, l3 = 1 / n3.tileToMeter;
          {
            const e22 = t22.translatePosMatrix(r3.projMatrix, s3, o2.paint.get("fill-extrusion-translate"), o2.paint.get("fill-extrusion-translate-anchor")), i3 = a3.getDefaultSegment();
            C22(r3, a3, i3, e22, l3);
          }
          if (v22) for (let n4 = 0; n4 < 4; n4++) {
            const a4 = e2.dU[n4](r3), c3 = i22.getTile(a4);
            if (!c3) continue;
            const h3 = c3.getBucket(o2);
            if (!h3 || h3.projection.name !== w22.projection.name || !h3.groundEffect || h3.groundEffect && !h3.groundEffect.hasData()) continue;
            const d3 = h3.groundEffect;
            let u3, _3;
            0 === n4 ? (u3 = [-e2.aj, 0, 0], _3 = 1) : 1 === n4 ? (u3 = [e2.aj, 0, 0], _3 = 0) : 2 === n4 ? (u3 = [0, -e2.aj, 0], _3 = 3) : (u3 = [0, e2.aj, 0], _3 = 2);
            const p3 = d3.regionSegments[_3];
            if (!p3) continue;
            const f3 = new Float32Array(16);
            e2.bo(f3, r3.projMatrix, u3), C22(r3, d3, p3, t22.translatePosMatrix(f3, s3, o2.paint.get("fill-extrusion-translate"), o2.paint.get("fill-extrusion-translate-anchor")), l3);
          }
        }
      }
      function Zr(t22, i22, o2, s2, r22, n22, a22) {
        0 === s2.centroidVertexArray.length && s2.createCentroidsBuffer();
        const l22 = n22 ? n22.findDEMTileFor(o2) : null;
        if (!(l22 && l22.dem || a22)) return;
        n22 && l22 && l22.dem && s2.selfDEMTileTimestamp !== l22.dem._timestamp && (s2.borderDoneWithNeighborZ = [-1, -1, -1, -1], s2.selfDEMTileTimestamp = l22.dem._timestamp);
        const c22 = (t3) => new e2.P(Math.ceil((t3 + e2.dX) * e2.dY), 0), h22 = (e22) => {
          const t3 = i22.getSource().minzoom, o3 = (e3) => {
            const t4 = i22.getTileByID(e3);
            if (t4 && t4.hasData()) return t4.getBucket(r22);
          }, s3 = [0, -1, 1];
          for (const i3 of s3) {
            if (e22.overscaledZ + i3 < t3) continue;
            const s4 = o3(e22.calculateScaledKey(e22.overscaledZ + i3));
            if (s4) return s4;
          }
        }, d22 = [0, 0, 0], u22 = (t3, i3) => (d22[0] = Math.min(t3.min.y, i3.min.y), d22[1] = Math.max(t3.max.y, i3.max.y), d22[2] = e2.aj - i3.min.x > t3.max.x ? i3.min.x - e2.aj : t3.max.x, d22), _22 = (t3, i3) => (d22[0] = Math.min(t3.min.x, i3.min.x), d22[1] = Math.max(t3.max.x, i3.max.x), d22[2] = e2.aj - i3.min.y > t3.max.y ? i3.min.y - e2.aj : t3.max.y, d22), p22 = [(e22, t3) => u22(e22, t3), (e22, t3) => u22(t3, e22), (e22, t3) => _22(e22, t3), (e22, t3) => _22(t3, e22)], f22 = (t3, i3, s3, r3, a3, c3, h3) => {
          if (!n22) return 0;
          const d3 = [[c3 ? s3 : t3, c3 ? t3 : s3, 0], [c3 ? s3 : i3, c3 ? i3 : s3, 0]], u3 = h3 < 0 ? e2.aj + h3 : h3, _3 = [c3 ? u3 : (t3 + i3) / 2, c3 ? (t3 + i3) / 2 : u3, 0];
          return 0 === s3 && h3 < 0 || 0 !== s3 && h3 > 0 ? n22.getForTilePoints(a3, [_3], true, r3) : d3.push(_3), n22.getForTilePoints(o2, d3, true, l22), Math.max(d3[0][2], d3[1][2], _3[2]) / n22.exaggeration();
        };
        for (let t3 = 0; t3 < 4; t3++) {
          const i3 = s2.borderFeatureIndices[t3];
          if (0 === i3.length) continue;
          const r3 = e2.dU[t3](o2), l3 = h22(r3);
          if (!(l3 && l3 instanceof e2.dV)) continue;
          const d3 = n22 ? n22.findDEMTileFor(r3) : null;
          if (!(d3 && d3.dem || a22)) continue;
          if (n22 && d3 && d3.dem && s2.borderDEMTileTimestamp[t3] !== d3.dem._timestamp && (s2.borderDoneWithNeighborZ[t3] = -1, s2.borderDEMTileTimestamp[t3] = d3.dem._timestamp), s2.borderDoneWithNeighborZ[t3] === l3.canonical.z) continue;
          0 === l3.centroidVertexArray.length && l3.createCentroidsBuffer();
          const u3 = (t3 < 2 ? 1 : 5) - t3, _3 = l3.borderDoneWithNeighborZ[u3] !== s2.canonical.z, v22 = l3.borderFeatureIndices[u3];
          let y22 = 0;
          if (s2.canonical.z !== l3.canonical.z) {
            for (const e22 of i3) s2.showCentroid(s2.featuresOnBorder[e22]);
            if (_3) for (const e22 of v22) l3.showCentroid(l3.featuresOnBorder[e22]);
            s2.borderDoneWithNeighborZ[t3] = l3.canonical.z, l3.borderDoneWithNeighborZ[u3] = s2.canonical.z;
          }
          for (const o3 of i3) {
            const i4 = s2.featuresOnBorder[o3], n3 = s2.centroidData[i4.centroidDataIndex], h3 = i4.borders[t3];
            let _4;
            for (; y22 < v22.length; ) {
              _4 = l3.featuresOnBorder[v22[y22]];
              const e22 = _4.borders[u3];
              if (e22[1] > h3[0] + 3 || e22[0] > h3[0] - 3) break;
              l3.showCentroid(_4), y22++;
            }
            if (_4 && y22 < v22.length) {
              const o4 = y22;
              let x22 = 0;
              for (; !(_4.borders[u3][0] > h3[1] - 3) && (x22++, ++y22 !== v22.length); ) _4 = l3.featuresOnBorder[v22[y22]];
              _4 = l3.featuresOnBorder[v22[o4]];
              let b22 = false;
              if (x22 >= 1) {
                const e22 = _4.borders[u3];
                Math.abs(h3[0] - e22[0]) < 3 && Math.abs(h3[1] - e22[1]) < 3 && (x22 = 1, b22 = true, y22 = o4 + 1);
              } else if (0 === x22) {
                s2.showCentroid(i4);
                continue;
              }
              const w22 = l3.centroidData[_4.centroidDataIndex];
              a22 && b22 && (((m22 = n3).flags | (g22 = w22).flags) & e2.dW ? (m22.flags |= e2.dW, g22.flags |= e2.dW) : (m22.flags &= ~e2.dW, g22.flags &= ~e2.dW));
              const T2 = i4.intersectsCount() > 1 || _4.intersectsCount() > 1;
              if (x22 > 1) y22 = o4, n3.centroidXY = w22.centroidXY = new e2.P(0, 0);
              else if (d3 && d3.dem && !T2) {
                const i5 = p22[t3](n3, w22), o5 = t3 % 2 ? e2.aj - 1 : 0, s3 = f22(i5[0], Math.min(e2.aj - 1, i5[1]), o5, d3, r3, t3 < 2, i5[2]);
                n3.centroidXY = w22.centroidXY = c22(s3);
              } else T2 ? n3.centroidXY = w22.centroidXY = new e2.P(0, 0) : (n3.centroidXY = s2.encodeBorderCentroid(i4), w22.centroidXY = l3.encodeBorderCentroid(_4));
              s2.writeCentroidToBuffer(n3), l3.writeCentroidToBuffer(w22);
            } else s2.showCentroid(i4);
          }
          s2.borderDoneWithNeighborZ[t3] = l3.canonical.z, l3.borderDoneWithNeighborZ[u3] = s2.canonical.z;
        }
        var m22, g22;
        (s2.needsCentroidUpdate || !s2.centroidVertexBuffer && 0 !== s2.centroidVertexArray.length) && s2.uploadCentroid(t22);
      }
      const Hr = [1, 0, 0], Wr = [0, 1, 0], $r = [0, 0, 1];
      function Xr(t22, i22, o2) {
        const s2 = o2.transform, r22 = o2.shadowRenderer;
        if (!r22) return true;
        const n22 = t22.toUnwrapped(), a22 = s2.tileSize * r22._cascades[o2.currentShadowCascade].scale;
        let l22 = i22.maxHeight;
        if (s2.elevation) {
          const e22 = s2.elevation.getMinMaxForTile(t22);
          e22 && (l22 += e22.max);
        }
        const c22 = [...r22.shadowDirection];
        c22[2] = -c22[2];
        const h22 = r22.computeSimplifiedTileShadowVolume(n22, l22, a22, c22);
        if (!h22) return false;
        const d22 = [Hr, Wr, $r, c22, [c22[0], 0, c22[2]], [0, c22[1], c22[2]]], u22 = "globe" === s2.projection.name, _22 = s2.scaleZoom(a22), p22 = e2.cn.fromInvProjectionMatrix(s2.invProjMatrix, s2.worldSize, _22, !u22), f22 = r22.getCurrentCascadeFrustum();
        return 0 === p22.intersectsPrecise(h22.vertices, h22.planes, d22) || 0 === f22.intersectsPrecise(h22.vertices, h22.planes, d22);
      }
      function Yr(t22) {
        return [t22[0] * e2.dZ, t22[1] * e2.dZ, t22[2] * e2.dZ, 0];
      }
      function Kr(t22, i22, o2, s2, r22, n22, a22, l22, c22) {
        const h22 = s2.getSource(), d22 = o2.globeSharedBuffers;
        if (!d22) return;
        let u22, _22, p22;
        if (i22 && (u22 = s2.getTile(i22)), h22 instanceof e2.aP ? (_22 = h22.texture, p22 = e2.ds(0, 0, o2.transform)) : u22 && i22 && (_22 = u22.texture, p22 = e2.ds(i22.canonical.z, i22.canonical.x, o2.transform)), !_22 || !p22) return;
        t22 || (p22 = e2.cE(e2.bz(), p22, [1, -1, 1]));
        const f22 = o2.context, m22 = f22.gl, g22 = "nearest" === r22.paint.get("raster-resampling") ? m22.NEAREST : m22.LINEAR, v22 = o2.colorModeForDrapableLayerRenderPass(n22), y22 = a22.defines;
        y22.push("GLOBE_POLES");
        const x22 = new Ni(m22.LEQUAL, Ni.ReadWrite, o2.depthRangeFor3D), b22 = Float32Array.from(o2.transform.expandedFarZProjMatrix), w22 = Float32Array.from(e2.bh(e2.dr(new e2.cp(0, 0, 0))));
        o2.terrain && o2.terrain.prepareDrawTile(), f22.activeTexture.set(m22.TEXTURE0), _22.bind(g22, m22.CLAMP_TO_EDGE), f22.activeTexture.set(m22.TEXTURE1), _22.bind(g22, m22.CLAMP_TO_EDGE), "useMipmap" in _22 && f22.extTextureFilterAnisotropic && o2.transform.pitch > 20 && m22.texParameterf(m22.TEXTURE_2D, f22.extTextureFilterAnisotropic.TEXTURE_MAX_ANISOTROPY_EXT, f22.extTextureFilterAnisotropicMax);
        const [T2, E22, S2, I2] = i22 ? d22.getPoleBuffers(i22.canonical.z, false) : d22.getPoleBuffers(0, true), C22 = r22.paint.get("raster-elevation");
        let R22;
        t22 ? (R22 = T2, o2.renderDefaultNorthPole = 0 !== C22) : (R22 = E22, o2.renderDefaultSouthPole = 0 !== C22);
        const D22 = Yr(a22.mix), A22 = ((e22, t3, i3, o3, s3, r3, n3, a3, l3, c3, h3, d3, u3) => _r(e22, t3, i3, new Float32Array(16), new Float32Array(9), [0, 0], o3, [0, 0], [0, 0, 0, 0], 1, { opacity: 1, mix: 0 }, r3, [0, 0], a3, 2, c3, h3, d3, 1, 0, u3))(b22, w22, p22, e2.ah(o2.transform.zoom), 0, r22, 0, C22, 0, D22, a22.offset, a22.range, n22), L22 = o2.getOrCreateProgram("raster", { defines: y22 });
        o2.uploadCommonUniforms(f22, L22, null), L22.draw(o2, m22.TRIANGLES, x22, c22, v22, l22, A22, r22.id, R22, S2, I2);
      }
      function Jr(e22) {
        const t22 = e22._nearZ, i22 = e22.projection.farthestPixelDistance(e22), o2 = i22 - t22, s2 = 0.2 * e22.height, r22 = t22 + s2;
        return [t22, i22, (r22 - s2 - t22) / o2, (r22 - t22) / o2];
      }
      function Qr(e22, t22, i22, o2) {
        if (e22) return t22 instanceof st && e22 instanceof Tt ? t22.getTextureDescriptor(e22, i22, true) : { texture: e22.texture, mix: Yr(o2.mix), offset: o2.offset, buffer: 0, tileSize: 1 };
      }
      var en2 = e2.d_([{ name: "a_index", type: "Int16", components: 1 }]);
      class tn {
        constructor(t22, i22, o2, s2) {
          const r22 = { width: o2[0], height: o2[1], data: null }, n22 = t22.gl;
          this.targetColorTexture = new e2.T(t22, r22, n22.RGBA8, { useMipmap: false }), this.backgroundColorTexture = new e2.T(t22, r22, n22.RGBA8, { useMipmap: false }), this.context = t22, this.updateParticleTexture(i22, s2), this.lastInvalidatedAt = 0;
        }
        updateParticleTexture(t22, i22) {
          if (this.particleTextureDimension === i22.width) return;
          (this.particleTexture0 || this.particleTexture1 || this.particleIndexBuffer || this.particleSegment) && (this.particleTexture0.destroy(), this.particleTexture1.destroy(), this.particleIndexBuffer.destroy(), this.particleSegment.destroy());
          const o2 = this.context.gl, s2 = i22.width * i22.height;
          this.particleTexture0 = new e2.T(this.context, i22, o2.RGBA8, { premultiply: false, useMipmap: false }), this.particleTexture1 = new e2.T(this.context, i22, o2.RGBA8, { premultiply: false, useMipmap: false });
          const r22 = new e2.d$();
          r22.reserve(s2);
          for (let e22 = 0; e22 < s2; e22++) r22.emplaceBack(e22);
          this.particleIndexBuffer = this.context.createVertexBuffer(r22, en2.members, true), this.particleSegment = e2.bd.simpleSegment(0, 0, this.particleIndexBuffer.length, 0), this.particleTextureDimension = i22.width;
        }
        update(t22) {
          return !(this.lastInvalidatedAt < t22 && (this.lastInvalidatedAt = e2.q.now(), 1));
        }
        destroy() {
          this.targetColorTexture.destroy(), this.backgroundColorTexture.destroy(), this.particleIndexBuffer.destroy(), this.particleTexture0.destroy(), this.particleTexture1.destroy(), this.particleSegment.destroy();
        }
      }
      function on(t22, i22, o2) {
        if (!t22) return null;
        const s2 = i22.getTextureDescriptor(t22, o2, true);
        if (!s2) return null;
        let { texture: r22, mix: n22, offset: a22, tileSize: l22, buffer: c22, format: h22 } = s2;
        if (!r22 || !h22) return null;
        let d22 = false;
        return "uint32" === h22 && (d22 = true, n22[3] = 0, n22 = dr(e2.e0, n22, [0, o2.paint.get("raster-particle-max-speed")]), a22 = ur(e2.e0, a22, [0, o2.paint.get("raster-particle-max-speed")])), { texture: r22, textureOffset: [c22 / (l22 + 2 * c22), l22 / (l22 + 2 * c22)], tileSize: l22, scalarData: d22, scale: n22, offset: a22, defines: ["RASTER_ARRAY", { uint8: "DATA_FORMAT_UINT8", uint16: "DATA_FORMAT_UINT16", uint32: "DATA_FORMAT_UINT32" }[h22]] };
      }
      function sn(e22) {
        const t22 = e22._nearZ, i22 = e22.projection.farthestPixelDistance(e22), o2 = i22 - t22, s2 = 0.2 * e22.height, r22 = t22 + s2;
        return [t22, i22, (r22 - s2 - t22) / o2, (r22 - t22) / o2];
      }
      const rn = new e2.am(1, 0, 0, 1), nn = new e2.am(0, 1, 0, 1), an = new e2.am(0, 0, 1, 1), ln = new e2.am(1, 0, 1, 1), cn2 = new e2.am(0, 1, 1, 1);
      function hn(t22, i22, o2, s2, r22, n22, a22) {
        const l22 = t22.context, c22 = t22.transform, h22 = l22.gl, d22 = "globe" === c22.projection.name, u22 = d22 ? ["PROJECTION_GLOBE_VIEW"] : [];
        let _22 = e2.bw(o2.projMatrix);
        if (d22 && e2.ah(c22.zoom) > 0) {
          const t3 = e2.bg(o2.canonical, c22), i3 = e2.e1(t3);
          _22 = e2.az(new Float32Array(16), c22.globeMatrix, i3), e2.az(_22, c22.projMatrix, _22);
        }
        const p22 = e2.bz();
        p22[12] += 2 * r22 / (e2.q.devicePixelRatio * c22.width), p22[13] += 2 * n22 / (e2.q.devicePixelRatio * c22.height), e2.az(_22, p22, _22);
        const f22 = t22.getOrCreateProgram("debug", { defines: u22 }), m22 = i22.getTileByID(o2.key);
        t22.terrain && t22.terrain.setupElevationDraw(m22, f22);
        const g22 = Ni.disabled, v22 = ji.disabled, y22 = t22.colorModeForRenderPass(), x22 = "$debug";
        l22.activeTexture.set(h22.TEXTURE0), t22.emptyTexture.bind(h22.LINEAR, h22.CLAMP_TO_EDGE), d22 ? m22._makeGlobeTileDebugBuffers(t22.context, c22) : m22._makeDebugTileBoundsBuffers(t22.context, c22.projection);
        const b22 = m22._tileDebugBuffer || t22.debugBuffer, w22 = m22._tileDebugIndexBuffer || t22.debugIndexBuffer, T2 = m22._tileDebugSegments || t22.debugSegments;
        if (f22.draw(t22, h22.LINE_STRIP, g22, v22, y22, qi.disabled, lr(_22, s2), x22, b22, w22, T2, null, null, null, [m22._globeTileDebugBorderBuffer]), a22) {
          const e22 = m22.latestRawTileData, i3 = Math.floor((e22 && e22.byteLength || 0) / 1024);
          let s3 = o2.canonical.toString();
          o2.overscaledZ !== o2.canonical.z && (s3 += ` => ${o2.overscaledZ}`), s3 += ` ${m22.state}`, s3 += ` ${i3}kb`, function(e3, t3) {
            e3.initDebugOverlayCanvas();
            const i4 = e3.debugOverlayCanvas, o3 = e3.context.gl, s4 = e3.debugOverlayCanvas.getContext("2d");
            s4.clearRect(0, 0, i4.width, i4.height), s4.shadowColor = "white", s4.shadowBlur = 2, s4.lineWidth = 1.5, s4.strokeStyle = "white", s4.textBaseline = "top", s4.font = "bold 36px Open Sans, sans-serif", s4.fillText(t3, 5, 5), s4.strokeText(t3, 5, 5), e3.debugOverlayTexture.update(i4), e3.debugOverlayTexture.bind(o3.LINEAR, o3.CLAMP_TO_EDGE);
          }(t22, s3);
        }
        const E22 = i22.getTile(o2).tileSize, S2 = 512 / Math.min(E22, 512) * (o2.overscaledZ / c22.zoom) * 0.5, I2 = m22._tileDebugTextBuffer || t22.debugBuffer, C22 = m22._tileDebugTextIndexBuffer || t22.quadTriangleIndexBuffer, R22 = m22._tileDebugTextSegments || t22.debugSegments;
        f22.draw(t22, h22.TRIANGLES, g22, v22, ki.alphaBlended, qi.disabled, lr(_22, e2.am.transparent, S2), x22, I2, C22, R22, null, null, null, [m22._globeTileDebugTextBuffer]);
      }
      function dn(e22, t22, i22, o2) {
        _n(e22, 0, t22 + i22 / 2, e22.transform.width, i22, o2);
      }
      function un(e22, t22, i22, o2) {
        _n(e22, t22 - i22 / 2, 0, i22, e22.transform.height, o2);
      }
      function _n(t22, i22, o2, s2, r22, n22) {
        const a22 = t22.context, l22 = a22.gl;
        l22.enable(l22.SCISSOR_TEST), l22.scissor(i22 * e2.q.devicePixelRatio, o2 * e2.q.devicePixelRatio, s2 * e2.q.devicePixelRatio, r22 * e2.q.devicePixelRatio), a22.clear({ color: n22 }), l22.disable(l22.SCISSOR_TEST);
      }
      const pn = e2.d_([{ name: "a_pos_3f", components: 3, type: "Float32" }]), { members: fn } = pn;
      function mn(e22, t22, i22, o2) {
        e22.emplaceBack(t22, i22, o2);
      }
      class gn {
        constructor(t22) {
          this.vertexArray = new e2.e2(), this.indices = new e2.a_(), mn(this.vertexArray, -1, -1, 1), mn(this.vertexArray, 1, -1, 1), mn(this.vertexArray, -1, 1, 1), mn(this.vertexArray, 1, 1, 1), mn(this.vertexArray, -1, -1, -1), mn(this.vertexArray, 1, -1, -1), mn(this.vertexArray, -1, 1, -1), mn(this.vertexArray, 1, 1, -1), this.indices.emplaceBack(5, 1, 3), this.indices.emplaceBack(3, 7, 5), this.indices.emplaceBack(6, 2, 0), this.indices.emplaceBack(0, 4, 6), this.indices.emplaceBack(2, 6, 7), this.indices.emplaceBack(7, 3, 2), this.indices.emplaceBack(5, 4, 0), this.indices.emplaceBack(0, 1, 5), this.indices.emplaceBack(0, 2, 3), this.indices.emplaceBack(3, 1, 0), this.indices.emplaceBack(7, 6, 4), this.indices.emplaceBack(4, 5, 7), this.vertexBuffer = t22.createVertexBuffer(this.vertexArray, fn), this.indexBuffer = t22.createIndexBuffer(this.indices), this.segment = e2.bd.simpleSegment(0, 0, 36, 12);
        }
      }
      function vn(t22, i22, o2, s2, r22, n22) {
        const a22 = t22.context.gl, l22 = i22.paint.get("sky-atmosphere-color"), c22 = i22.paint.get("sky-atmosphere-halo-color"), h22 = i22.paint.get("sky-atmosphere-sun-intensity"), d22 = ((e22, t3, i3, o3, s3) => ({ u_matrix_3f: e22, u_sun_direction: t3, u_sun_intensity: i3, u_color_tint_r: [o3.r, o3.g, o3.b, o3.a], u_color_tint_m: [s3.r, s3.g, s3.b, s3.a], u_luminance: 5e-5 }))(e2.e4(e2.dx(), s2), r22, h22, l22, c22);
        a22.framebufferTexture2D(a22.FRAMEBUFFER, a22.COLOR_ATTACHMENT0, a22.TEXTURE_CUBE_MAP_POSITIVE_X + n22, i22.skyboxTexture, 0), o2.draw(t22, a22.TRIANGLES, Ni.disabled, ji.disabled, ki.unblended, qi.frontCW, d22, "skyboxCapture", i22.skyboxGeometry.vertexBuffer, i22.skyboxGeometry.indexBuffer, i22.skyboxGeometry.segment);
      }
      const yn = e2.d_([{ type: "Float32", name: "a_pos", components: 3 }, { type: "Float32", name: "a_uv", components: 2 }]);
      class xn {
        constructor(t22) {
          const i22 = new e2.e5();
          i22.emplaceBack(-1, 1, 1, 0, 0), i22.emplaceBack(1, 1, 1, 1, 0), i22.emplaceBack(1, -1, 1, 1, 1), i22.emplaceBack(-1, -1, 1, 0, 1);
          const o2 = new e2.a_();
          o2.emplaceBack(0, 1, 2), o2.emplaceBack(2, 3, 0), this.vertexBuffer = t22.createVertexBuffer(i22, yn.members), this.indexBuffer = t22.createIndexBuffer(o2), this.segments = e2.bd.simpleSegment(0, 0, 4, 2);
        }
        destroy() {
          this.vertexBuffer.destroy(), this.indexBuffer.destroy(), this.segments.destroy();
        }
      }
      const bn = e2.d_([{ type: "Float32", name: "a_pos_3f", components: 3 }, { type: "Float32", name: "a_uv", components: 2 }, { type: "Float32", name: "a_size_scale", components: 1 }, { type: "Float32", name: "a_fade_opacity", components: 1 }]);
      class wn {
        constructor() {
          this.starsCount = 16e3, this.sizeMultiplier = 0.15, this.sizeRange = 100, this.intensityRange = 200;
        }
      }
      class Tn {
        constructor(t22) {
          this.colorModeAlphaBlendedWriteRGB = new ki([1, Bi, 1, Bi], e2.am.transparent, [true, true, true, false]), this.colorModeWriteAlpha = new ki([1, 0, 1, 0], e2.am.transparent, [false, false, false, true]), this.params = new wn(), this.updateNeeded = true, t22.tp.registerParameter(this.params, ["Stars"], "starsCount", { min: 100, max: 16e3, step: 1 }, () => {
            this.updateNeeded = true;
          }), t22.tp.registerParameter(this.params, ["Stars"], "sizeMultiplier", { min: 0.01, max: 2, step: 0.01 }), t22.tp.registerParameter(this.params, ["Stars"], "sizeRange", { min: 0, max: 200, step: 1 }, () => {
            this.updateNeeded = true;
          }), t22.tp.registerParameter(this.params, ["Stars"], "intensityRange", { min: 0, max: 200, step: 1 }, () => {
            this.updateNeeded = true;
          });
        }
        update(t22) {
          const i22 = t22.context;
          if (!this.atmosphereBuffer || this.updateNeeded) {
            this.updateNeeded = false, this.atmosphereBuffer = new xn(i22);
            const t3 = this.params.sizeRange, o2 = this.params.intensityRange, s2 = function(t4) {
              const i3 = e2.ea(30), o3 = [];
              for (let s3 = 0; s3 < t4; ++s3) {
                const t5 = 2 * Math.PI * i3(), s4 = Math.acos(1 - 2 * i3()) - 0.5 * Math.PI;
                o3.push(e2.cS(Math.cos(s4) * Math.cos(t5), Math.cos(s4) * Math.sin(t5), Math.sin(s4)));
              }
              return o3;
            }(this.params.starsCount), r22 = e2.ea(300), n22 = new e2.e6(), a22 = new e2.a_();
            let l22 = 0;
            for (let i3 = 0; i3 < s2.length; ++i3) {
              const c22 = e2.b$([], s2[i3], 200), h22 = Math.max(0, 1 + 0.01 * t3 * (1 * r22() - 0.5)), d22 = Math.max(0, 1 + 0.01 * o2 * (1 * r22() - 0.5));
              n22.emplaceBack(c22[0], c22[1], c22[2], -1, -1, h22, d22), n22.emplaceBack(c22[0], c22[1], c22[2], 1, -1, h22, d22), n22.emplaceBack(c22[0], c22[1], c22[2], 1, 1, h22, d22), n22.emplaceBack(c22[0], c22[1], c22[2], -1, 1, h22, d22), a22.emplaceBack(l22 + 0, l22 + 1, l22 + 2), a22.emplaceBack(l22 + 0, l22 + 2, l22 + 3), l22 += 4;
            }
            this.starsVx = i22.createVertexBuffer(n22, bn.members), this.starsIdx = i22.createIndexBuffer(a22), this.starsSegments = e2.bd.simpleSegment(0, 0, n22.length, a22.length);
          }
        }
        destroy() {
          this.atmosphereBuffer && this.atmosphereBuffer.destroy(), this.starsVx && this.starsVx.destroy(), this.starsIdx && this.starsIdx.destroy();
        }
        drawAtmosphereGlow(t22, i22) {
          const o2 = t22.context, s2 = o2.gl, r22 = t22.transform, n22 = new Ni(s2.LEQUAL, Ni.ReadOnly, [0, 1]), a22 = e2.ah(r22.zoom), l22 = t22.style.getLut(i22.scope), c22 = "none" === i22.properties.get("color-use-theme"), h22 = i22.properties.get("color").toRenderColor(c22 ? null : l22).toArray01(), d22 = "none" === i22.properties.get("high-color-use-theme"), u22 = i22.properties.get("high-color").toRenderColor(d22 ? null : l22).toArray01(), _22 = "none" === i22.properties.get("space-color-use-theme"), p22 = i22.properties.get("space-color").toRenderColor(_22 ? null : l22).toArray01PremultipliedAlpha(), f22 = 5e-4, m22 = e2.e7(i22.properties.get("horizon-blend"), 0, 1, f22, 0.25), g22 = e2.dl(t22, o2, r22) && m22 === f22 ? r22.worldSize / (2 * Math.PI * 1.025) - 1 : r22.globeRadius, v22 = t22.frameCounter / 1e3 % 1, y22 = e2.ae(r22.globeCenterInViewSpace), x22 = Math.sqrt(Math.pow(y22, 2) - Math.pow(g22, 2)), b22 = Math.acos(x22 / y22), w22 = (e22) => {
            const i3 = "globe" === r22.projection.name ? ["PROJECTION_GLOBE_VIEW", "FOG"] : ["FOG"];
            e22 && i3.push("ALPHA_PASS");
            const l3 = t22.getOrCreateProgram("globeAtmosphere", { defines: i3 }), c3 = /* @__PURE__ */ ((e3, t3, i4, o3, s3, r3, n3, a3, l4, c4, h3, d4) => ({ u_frustum_tl: e3, u_frustum_tr: t3, u_frustum_br: i4, u_frustum_bl: o3, u_horizon: s3, u_transition: r3, u_fadeout_range: n3, u_color: a3, u_high_color: l4, u_space_color: c4, u_temporal_offset: h3, u_horizon_angle: d4 }))(r22.frustumCorners.TL, r22.frustumCorners.TR, r22.frustumCorners.BR, r22.frustumCorners.BL, r22.frustumCorners.horizon, a22, m22, h22, u22, p22, v22, b22);
            t22.uploadCommonUniforms(o2, l3);
            const d3 = this.atmosphereBuffer;
            d3 && l3.draw(t22, s2.TRIANGLES, n22, ji.disabled, e22 ? this.colorModeWriteAlpha : this.colorModeAlphaBlendedWriteRGB, qi.backCW, c3, e22 ? "atmosphere_glow_alpha" : "atmosphere_glow", d3.vertexBuffer, d3.indexBuffer, d3.segments);
          };
          w22(false), w22(true);
        }
        drawStars(t22, i22) {
          const o2 = e2.aD(i22.properties.get("star-intensity"), 0, 1);
          if (0 === o2) return;
          const s2 = t22.context, r22 = s2.gl, n22 = t22.transform, a22 = t22.getOrCreateProgram("stars"), l22 = e2.bY([]);
          e2.b_(l22, l22, -n22._pitch), e2.bZ(l22, l22, -n22.angle), e2.b_(l22, l22, e2.al(n22._center.lat)), e2.e8(l22, l22, -e2.al(n22._center.lng));
          const c22 = e2.c3(new Float32Array(16), l22), h22 = e2.az([], n22.starsProjMatrix, c22), d22 = e2.e4([], c22), u22 = e2.e9([], d22), _22 = [0, 1, 0];
          e2.dz(_22, _22, u22), e2.b$(_22, _22, this.params.sizeMultiplier);
          const p22 = [1, 0, 0];
          e2.dz(p22, p22, u22), e2.b$(p22, p22, this.params.sizeMultiplier);
          const f22 = (m22 = _22, g22 = p22, v22 = o2, { u_matrix: Float32Array.from(h22), u_up: m22, u_right: g22, u_intensity_multiplier: v22 });
          var m22, g22, v22;
          t22.uploadCommonUniforms(s2, a22), this.starsVx && this.starsIdx && a22.draw(t22, r22.TRIANGLES, Ni.disabled, ji.disabled, this.colorModeAlphaBlendedWriteRGB, qi.disabled, f22, "atmosphere_stars", this.starsVx, this.starsIdx, this.starsSegments);
        }
      }
      function En(t22, i22) {
        const o2 = [...t22], s2 = i22.cameraWorldSizeForFog / i22.worldSize, r22 = e2.bx([]);
        return e2.cE(r22, r22, [s2, s2, 1]), e2.az(o2, r22, o2), e2.az(o2, i22.worldToFogMatrix, o2), o2;
      }
      function Sn(t22, i22, o2, s2, r22) {
        const n22 = o2.material, a22 = s2.context, { baseColorTexture: l22, metallicRoughnessTexture: c22 } = n22.pbrMetallicRoughness, { normalTexture: h22, occlusionTexture: d22, emissionTexture: u22 } = n22;
        function _22(e22, i3, o3) {
          if (e22 && (t22.push(i3), a22.activeTexture.set(a22.gl.TEXTURE0 + o3), e22.gfxTexture)) {
            const { minFilter: t3, magFilter: i4, wrapS: o4, wrapT: s3 } = e22.sampler;
            e22.gfxTexture.bindExtraParam(t3, i4, o4, s3);
          }
        }
        _22(l22, "HAS_TEXTURE_u_baseColorTexture", Yi.BaseColor), _22(c22, "HAS_TEXTURE_u_metallicRoughnessTexture", Yi.MetallicRoughness), _22(h22, "HAS_TEXTURE_u_normalTexture", Yi.Normal), _22(d22, "HAS_TEXTURE_u_occlusionTexture", Yi.Occlusion), _22(u22, "HAS_TEXTURE_u_emissionTexture", Yi.Emission), r22 && (r22.texture || (r22.texture = new e2.ed(s2.context, r22.image, [r22.image.height, r22.image.height, r22.image.height], a22.gl.RGBA8)), a22.activeTexture.set(a22.gl.TEXTURE0 + Yi.LUT), r22.texture && r22.texture.bind(a22.gl.LINEAR, a22.gl.CLAMP_TO_EDGE), t22.push("APPLY_LUT_ON_GPU")), o2.texcoordBuffer && (t22.push("HAS_ATTRIBUTE_a_uv_2f"), i22.push(o2.texcoordBuffer)), o2.colorBuffer && (t22.push(12 === o2.colorBuffer.itemSize ? "HAS_ATTRIBUTE_a_color_3f" : "HAS_ATTRIBUTE_a_color_4f"), i22.push(o2.colorBuffer)), o2.normalBuffer && (t22.push("HAS_ATTRIBUTE_a_normal_3f"), i22.push(o2.normalBuffer)), o2.pbrBuffer && (t22.push("HAS_ATTRIBUTE_a_pbr"), t22.push("HAS_ATTRIBUTE_a_heightBasedEmissiveStrength"), i22.push(o2.pbrBuffer)), "OPAQUE" !== n22.alphaMode && "MASK" !== n22.alphaMode || t22.push("UNPREMULT_TEXTURE_IN_SHADER"), n22.defined || t22.push("DIFFUSE_SHADED");
        const p22 = s2.shadowRenderer;
        p22 && (t22.push("RENDER_SHADOWS", "DEPTH_TEXTURE"), p22.useNormalOffset && t22.push("NORMAL_OFFSET"));
      }
      function In(t22, i22, o2, s2, r22, n22) {
        const a22 = o2.paint.get("model-opacity").constantOr(1), l22 = i22.context, c22 = new Ni(i22.context.gl.LEQUAL, Ni.ReadWrite, i22.depthRangeFor3D), h22 = i22.transform, d22 = t22.mesh, u22 = d22.material, _22 = u22.pbrMetallicRoughness, p22 = i22.style.fog;
        let f22;
        f22 = "pixels" === i22.transform.projection.zAxisUnit ? [...t22.nodeModelMatrix] : e2.az([], s2.zScaleMatrix, t22.nodeModelMatrix), e2.az(f22, s2.negCameraPosMatrix, f22);
        const m22 = e2.bi([], f22);
        e2.ee(m22, m22);
        const g22 = "none" === o2.paint.get("model-color-use-theme").constantOr("default"), v22 = o2.paint.get("model-emissive-strength").constantOr(0), y22 = Er(new Float32Array(t22.worldViewProjection), new Float32Array(f22), new Float32Array(m22), null, i22, a22, _22.baseColorFactor.toRenderColor(null), u22.emissiveFactor, _22.metallicFactor, _22.roughnessFactor, u22, v22, o2), x22 = { defines: [] }, b22 = [], w22 = i22.shadowRenderer;
        w22 && (w22.useNormalOffset = false), Sn(x22.defines, b22, d22, i22, g22 ? null : o2.lut);
        let T2 = null;
        if (p22) {
          const e22 = En(t22.nodeModelMatrix, i22.transform);
          if (T2 = new Float32Array(e22), "globe" !== h22.projection.name) {
            const t3 = d22.aabb.min, i3 = d22.aabb.max, [o3, s3] = p22.getOpacityForBounds(e22, t3[0], t3[1], i3[0], i3[1]);
            x22.overrideFog = o3 >= Fe || s3 >= Fe;
          }
        }
        const E22 = eo(i22, o2.paint.get("model-cutoff-fade-range"));
        E22.shouldRenderCutoff && x22.defines.push("RENDER_CUTOFF");
        const S2 = i22.getOrCreateProgram("model", x22);
        i22.uploadCommonUniforms(l22, S2, null, T2, E22), "shadow" !== i22.renderPass && w22 && w22.setupShadowsFromMatrix(t22.nodeModelMatrix, S2), S2.draw(i22, l22.gl.TRIANGLES, c22, r22, n22, d22.material.doubleSided ? qi.disabled : qi.backCCW, y22, o2.id, d22.vertexBuffer, d22.indexBuffer, d22.segments, o2.paint, i22.transform.zoom, void 0, b22);
      }
      function Cn(t22, i22, o2, s2, r22, n22, a22) {
        let l22;
        l22 = "globe" === t22.projection.name ? e2.ef(o2, t22) : [...o2], e2.az(l22, l22, i22.matrix);
        const c22 = e2.az([], s2, l22);
        if (i22.meshes) for (const o3 of i22.meshes) {
          if ("BLEND" !== o3.material.alphaMode) {
            a22.push({ mesh: o3, depth: 0, modelIndex: r22, worldViewProjection: c22, nodeModelMatrix: l22 });
            continue;
          }
          const i3 = e2.ad([], o3.centroid, c22);
          !t22.isOrthographic && i3[2] <= 0 || n22.push({ mesh: o3, depth: i3[2], modelIndex: r22, worldViewProjection: c22, nodeModelMatrix: l22 });
        }
        if (i22.children) for (const e22 of i22.children) Cn(t22, e22, o2, s2, r22, n22, a22);
      }
      function Rn(e22, t22, i22, o2) {
        const s2 = i22.shadowRenderer;
        if (!s2) return;
        const r22 = s2.getShadowPassDepthMode(), n22 = s2.getShadowPassColorMode(), a22 = s2.calculateShadowPassMatrixFromMatrix(t22), l22 = Sr(a22);
        i22.getOrCreateProgram("modelDepth", { defines: i22._shadowMapDebug ? [] : ["DEPTH_TEXTURE"] }).draw(i22, i22.context.gl.TRIANGLES, r22, ji.disabled, n22, qi.backCCW, l22, o2.id, e22.vertexBuffer, e22.indexBuffer, e22.segments, o2.paint, i22.transform.zoom, void 0, void 0);
      }
      function Dn(t22, i22, o2) {
        const s2 = i22.updateZoomBasedPaintProperties(), r22 = function(t3, i3, o3) {
          let s3, r3, n22, a22 = t3.terrain ? t3.terrain.exaggeration() : 0;
          if (t3.terrain && a22 > 0) {
            const i4 = t3.terrain, r4 = i4.findDEMTileFor(o3);
            r4 && r4.dem ? s3 = e2.el.create(i4, o3, r4) : a22 = 0;
          }
          if (0 === a22 && (i3.terrainElevationMin = 0, i3.terrainElevationMax = 0), a22 === i3.validForExaggeration && (0 === a22 || s3 && s3._demTile && s3._demTile.tileID === i3.validForDEMTile.id && s3._dem._timestamp === i3.validForDEMTile.timestamp)) return false;
          for (const e22 in i3.instancesPerModel) {
            const t4 = i3.instancesPerModel[e22];
            for (let e3 = 0; e3 < t4.instancedDataArray.length; ++e3) {
              const o4 = (s3 ? a22 * s3.getElevationAt(0 | t4.instancedDataArray.float32[16 * e3], 0 | t4.instancedDataArray.float32[16 * e3 + 1], true, true) : 0) + t4.instancesEvaluatedElevation[e3];
              t4.instancedDataArray.float32[16 * e3 + 6] = o4, r3 = r3 ? Math.min(i3.terrainElevationMin, o4) : o4, n22 = n22 ? Math.max(i3.terrainElevationMax, o4) : o4;
            }
          }
          return i3.terrainElevationMin = r3 || 0, i3.terrainElevationMax = n22 || 0, i3.validForExaggeration = a22, i3.validForDEMTile = s3 && s3._demTile ? { id: s3._demTile.tileID, timestamp: s3._dem._timestamp } : { id: void 0, timestamp: 0 }, true;
        }(t22, i22, o2);
        (s2 || r22) && (i22.uploaded = false, i22.upload(t22.context));
      }
      const An = { shadowUniformsInitialized: false, useSingleShadowCascade: false, tileMatrix: new Float64Array(16), shadowTileMatrix: new Float32Array(16), aabb: new e2.cV([0, 0, 0], [e2.aj, e2.aj, 0]) };
      function Ln(t22, i22) {
        const o2 = 1 << t22.canonical.z, s2 = i22.getFreeCameraOptions().position, r22 = i22.elevation, n22 = t22.canonical.x / o2, a22 = (t22.canonical.x + 1) / o2, l22 = t22.canonical.y / o2, c22 = (t22.canonical.y + 1) / o2;
        let h22 = i22._centerAltitude;
        if (r22) {
          const e22 = r22.getMinMaxForTile(t22);
          e22 && e22.max > h22 && (h22 = e22.max);
        }
        const d22 = e2.aD(s2.x, n22, a22) - s2.x, u22 = e2.aD(s2.y, l22, c22) - s2.y, _22 = e2.c6(h22, i22.center.lat) - s2.z;
        return i22._zoomFromMercatorZ(Math.sqrt(d22 * d22 + u22 * u22 + _22 * _22));
      }
      function Pn(e22, t22, i22, o2, s2, r22, n22) {
        const a22 = e22.context, l22 = "shadow" === e22.renderPass, c22 = e22.shadowRenderer, h22 = l22 && c22 ? c22.getShadowPassDepthMode() : new Ni(a22.gl.LEQUAL, Ni.ReadWrite, e22.depthRangeFor3D), d22 = e22.isTileAffectedByFog(r22);
        if (i22.meshes) for (const u22 of i22.meshes) {
          const _22 = ["MODEL_POSITION_ON_GPU"], p22 = [];
          let f22, m22, g22;
          o2.instancedDataArray.length > 20 && _22.push("INSTANCED_ARRAYS");
          const v22 = eo(e22, t22.paint.get("model-cutoff-fade-range"));
          if (v22.shouldRenderCutoff && _22.push("RENDER_CUTOFF"), l22 && c22) f22 = e22.getOrCreateProgram("modelDepth", { defines: _22 }), m22 = Sr(n22.shadowTileMatrix, n22.shadowTileMatrix, Float32Array.from(i22.matrix)), g22 = c22.getShadowPassColorMode();
          else {
            Sn(_22, p22, u22, e22, "none" === t22.paint.get("model-color-use-theme").constantOr("default") ? null : t22.lut), f22 = e22.getOrCreateProgram("model", { defines: _22, overrideFog: d22 });
            const o3 = u22.material, l3 = o3.pbrMetallicRoughness, h3 = t22.paint.get("model-opacity").constantOr(1), y3 = t22.paint.get("model-emissive-strength").constantOr(0);
            m22 = Er(r22.expandedProjMatrix, Float32Array.from(i22.matrix), new Float32Array(16), null, e22, h3, l3.baseColorFactor.toRenderColor(null), o3.emissiveFactor, l3.metallicFactor, l3.roughnessFactor, o3, y3, t22, s2), c22 && (n22.shadowUniformsInitialized ? f22.setShadowUniformValues(a22, c22.getShadowUniformValues()) : (c22.setupShadows(r22.toUnwrapped(), f22, "model-tile", r22.overscaledZ), n22.shadowUniformsInitialized = true)), g22 = v22.shouldRenderCutoff || h3 < 1 || "OPAQUE" !== o3.alphaMode ? ki.alphaBlended : ki.unblended;
          }
          e22.uploadCommonUniforms(a22, f22, r22.toUnwrapped(), null, v22);
          const y22 = u22.material.doubleSided ? qi.disabled : qi.backCCW;
          if (o2.instancedDataArray.length > 20) p22.push(o2.instancedDataBuffer), f22.draw(e22, a22.gl.TRIANGLES, h22, ji.disabled, g22, y22, m22, t22.id, u22.vertexBuffer, u22.indexBuffer, u22.segments, t22.paint, e22.transform.zoom, void 0, p22, o2.instancedDataArray.length);
          else {
            const i3 = l22 ? "u_instance" : "u_normal_matrix";
            for (let s3 = 0; s3 < o2.instancedDataArray.length; ++s3) m22[i3] = new Float32Array(o2.instancedDataArray.arrayBuffer, 64 * s3, 16), f22.draw(e22, a22.gl.TRIANGLES, h22, ji.disabled, g22, y22, m22, t22.id, u22.vertexBuffer, u22.indexBuffer, u22.segments, t22.paint, e22.transform.zoom, void 0, p22);
          }
        }
        if (i22.children) for (const a3 of i22.children) Pn(e22, t22, a3, o2, s2, r22, n22);
      }
      const zn = [1, -1, 1];
      function Mn(t22, i22, o2, s2) {
        if (!o2.modelManager) return true;
        const r22 = o2.modelManager;
        if (!o2.shadowRenderer) return true;
        const n22 = o2.shadowRenderer, a22 = i22.aabb;
        let l22 = true, c22 = t22.maxHeight;
        if (0 === c22) {
          let e22 = 0;
          for (const i3 in t22.instancesPerModel) {
            const t3 = r22.getModel(i3, s2);
            t3 ? e22 = Math.max(e22, Math.max(Math.max(t3.aabb.max[0], t3.aabb.max[1]), t3.aabb.max[2])) : l22 = false;
          }
          c22 = t22.maxScale * e22 * 1.41 + t22.maxVerticalOffset, l22 && (t22.maxHeight = c22);
        }
        a22.max[2] = c22, a22.min[2] += t22.terrainElevationMin, a22.max[2] += t22.terrainElevationMax, e2.ad(a22.min, a22.min, i22.tileMatrix), e2.ad(a22.max, a22.max, i22.tileMatrix);
        const h22 = a22.intersects(n22.getCurrentCascadeFrustum());
        return 0 === o2.currentShadowCascade && (t22.isInsideFirstShadowMapFrustum = 2 === h22), 0 === h22;
      }
      function On(t22, i22) {
        const o2 = t22.uniformValues.u_cutoff_params[0], s2 = t22.uniformValues.u_cutoff_params[1], r22 = t22.uniformValues.u_cutoff_params[2], n22 = t22.uniformValues.u_cutoff_params[3];
        return s2 === o2 || n22 === r22 ? 1 : e2.aD(((i22 - o2) / (s2 - o2) - r22) / (n22 - r22), 0, 1);
      }
      function Fn(t22, i22, o2, s2) {
        if (i22.pitch < 20) return 1;
        const r22 = i22.getWorldToCameraMatrix();
        e2.az(r22, r22, t22);
        const n22 = e2.ei(o2.min[0], o2.min[1], o2.min[2], 1);
        let a22 = e2.aA(e2.ej(), n22, r22), l22 = a22, c22 = a22;
        n22[1] = o2.max[1], a22 = e2.aA(e2.ej(), n22, r22), l22 = a22[1] < l22[1] ? a22 : l22, c22 = a22[1] > c22[1] ? a22 : c22, n22[0] = o2.max[0], a22 = e2.aA(e2.ej(), n22, r22), l22 = a22[1] < l22[1] ? a22 : l22, c22 = a22[1] > c22[1] ? a22 : c22, n22[1] = o2.min[1], a22 = e2.aA(e2.ej(), n22, r22), l22 = a22[1] < l22[1] ? a22 : l22, c22 = a22[1] > c22[1] ? a22 : c22;
        const h22 = e2.aD(s2[0], 0, 1), d22 = 100 * i22.pixelsPerMeter * e2.aD(s2[1], 0, 1), u22 = e2.aD(s2[2], 0, 1), _22 = e2.ek(e2.ej(), l22, c22, h22), p22 = Math.tan(0.5 * i22.fovX), f22 = -_22[2] * p22;
        if (0 === d22) return _22[1] < -Math.abs(f22) ? u22 : 1;
        const m22 = (-Math.abs(f22) - _22[1]) / d22, g22 = (e22, t3, i3) => (1 - i3) * e22 + i3 * t3, v22 = e2.aD(g22(1, u22, m22), u22, 1);
        return g22(1, v22, e2.aD((i22.pitch - 20) / 20, 0, 1));
      }
      class Bn {
      }
      class kn {
        constructor() {
          this._storage = /* @__PURE__ */ new Map();
        }
        getLinesFromTrianglesBuffer(t22, i22, o2) {
          {
            const e22 = this._storage.get(i22.id);
            if (e22) return e22.lastUsedFrameIdx = t22, e22.buf;
          }
          const s2 = o2.gl, r22 = s2.getBufferParameter(s2.ELEMENT_ARRAY_BUFFER, s2.BUFFER_SIZE), n22 = new ArrayBuffer(r22), a22 = new Int16Array(n22);
          s2.getBufferSubData(s2.ELEMENT_ARRAY_BUFFER, 0, new Int16Array(n22));
          const l22 = new e2.en();
          for (let e22 = 0; e22 < r22 / 2; e22 += 3) {
            const t3 = a22[e22], i3 = a22[e22 + 1], o3 = a22[e22 + 2];
            l22.emplaceBack(t3, i3), l22.emplaceBack(i3, o3), l22.emplaceBack(o3, t3);
          }
          const c22 = o2.bindVertexArrayOES.current, h22 = new Bn();
          return h22.buf = new Cr(o2, l22), h22.lastUsedFrameIdx = t22, this._storage.set(i22.id, h22), o2.bindVertexArrayOES.set(c22), h22.buf;
        }
        update(e22) {
          for (const [t22, i22] of this._storage) e22 - i22.lastUsedFrameIdx > 30 && (i22.buf.destroy(), this._storage.delete(t22));
        }
        destroy() {
          for (const [e22, t22] of this._storage) t22.buf.destroy(), this._storage.delete(e22);
        }
      }
      class Nn {
        constructor(e22) {
          this.occluderSize = 30, this.depthOffset = -1e-4, e22.registerParameter(this, ["Occlusion"], "occluderSize", { min: 1, max: 100, step: 1 }), e22.registerParameter(this, ["Occlusion"], "depthOffset", { min: -0.05, max: 0, step: 1e-5 });
        }
      }
      const Un = e2.d_([{ type: "Float32", name: "a_pos_3f", components: 3 }, { type: "Float32", name: "a_uv", components: 2 }, { type: "Float32", name: "a_rainParticleData", components: 4 }]);
      class jn {
        registerParameter() {
        }
        registerButton() {
        }
        registerBinding() {
        }
        refreshUI() {
        }
      }
      class Vn {
        constructor(e22, t22) {
          this.revealStart = 11, this.revealRange = 2, e22.registerParameter(this, [...t22, "Reveal"], "revealStart", { min: 0, max: 17, step: 0.05 }), e22.registerParameter(this, [...t22, "Reveal"], "revealRange", { min: 0.1, max: 5.1, step: 0.05 });
        }
      }
      const Gn = e2.d_([{ type: "Float32", name: "a_pos_2f", components: 2 }]);
      class qn {
        destroy() {
          this.vignetteVx && this.vignetteVx.destroy(), this.vignetteIdx && this.vignetteIdx.destroy();
        }
        draw(t22, i22) {
          const o2 = t22.getOrCreateProgram("vignette");
          if (!this.vignetteVx || !this.vignetteIdx) {
            const i3 = new e2.eo(), o3 = new e2.a_();
            i3.emplaceBack(-1, -1), i3.emplaceBack(1, -1), i3.emplaceBack(1, 1), i3.emplaceBack(-1, 1), o3.emplaceBack(0, 1, 2), o3.emplaceBack(0, 2, 3), this.vignetteVx = t22.context.createVertexBuffer(i3, Gn.members), this.vignetteIdx = t22.context.createIndexBuffer(o3);
          }
          const s2 = e2.bd.simpleSegment(0, 0, 4, 6);
          if (this.vignetteVx && this.vignetteIdx) {
            t22.uploadCommonUniforms(t22.context, o2);
            const e22 = { u_vignetteShape: (r22 = { vignetteShape: [i22.start, i22.range, Math.pow(10, i22.fadePower)], vignetteColor: [i22.color.r, i22.color.g, i22.color.b, i22.color.a * i22.strength] }).vignetteShape, u_vignetteColor: r22.vignetteColor };
            o2.draw(t22, t22.context.gl.TRIANGLES, Ni.disabled, ji.disabled, ki.alphaBlended, qi.disabled, e22, "vignette", this.vignetteVx, this.vignetteIdx, s2);
          }
          var r22;
        }
      }
      class Zn {
        constructor() {
          this._accumulatedOffsetX = 0, this._accumulatedOffsetY = 0, this._accumulatedElevation = 0;
        }
        update(t22, i22) {
          const o2 = t22.getFreeCameraOptions().position, s2 = o2.toAltitude(), r22 = o2.toLngLat(), n22 = e2.al(r22.lng), a22 = e2.al(r22.lat), l22 = t22.pixelsPerMeter / i22, c22 = n22 * e2.eq, h22 = e2.eq * Math.log(Math.tan(Math.PI / 4 + a22 / 2));
          if (void 0 === this._offsetXPrev) this._offsetXPrev = 0, this._offsetYPrev = 0, this._elevationPrev = 0, this._accumulatedOffsetX = 0, this._accumulatedOffsetY = 0, this._accumulatedElevation = 0;
          else {
            const e22 = -this._offsetYPrev + h22, t3 = -this._elevationPrev + s2;
            this._accumulatedOffsetX += (-this._offsetXPrev + c22) * l22, this._accumulatedOffsetY += e22 * l22, this._accumulatedElevation += t3 * l22, this._offsetXPrev = c22, this._offsetYPrev = h22, this._elevationPrev = s2;
          }
        }
        getPosition() {
          return [this._accumulatedOffsetX, this._accumulatedOffsetY, this._accumulatedElevation];
        }
      }
      function Hn(e22, t22) {
        return [-(e22[0] - Math.floor(e22[0] / t22) * t22), -(e22[1] - Math.floor(e22[1] / t22) * t22), -(e22[2] - Math.floor(e22[2] / t22) * t22)];
      }
      function Wn(t22) {
        const i22 = e2.ea(1323123451230), o2 = [];
        for (let s2 = 0; s2 < t22; ++s2) {
          const t3 = 2 * i22() - 1, s3 = 2 * i22() - 1, r22 = 2 * i22() - 1;
          o2.push(e2.cS(t3, s3, r22));
        }
        return o2;
      }
      function $n(t22, i22, o2, s2, r22) {
        const n22 = e2.aD((r22 - o2) / (s2 - o2), 0, 1);
        return (1 - n22) * t22 + n22 * i22;
      }
      class Xn {
        constructor(e22) {
          this._movement = new Zn(), this._accumulatedTimeFromStart = 0, this._prevTime = Date.now() / 1e3, this._vignette = new qn(), this._ppmScaleFactor = e22;
        }
        destroy() {
          this.particlesVx && this.particlesVx.destroy(), this.particlesIdx && this.particlesIdx.destroy(), this._vignette && this._vignette.destroy();
        }
        updateOnRender(t22, i22) {
          const o2 = t22.transform;
          this._movement.update(o2, this._ppmScaleFactor);
          const s2 = o2.starsProjMatrix, r22 = e2.bY([]);
          e2.b_(r22, r22, e2.al(90) - o2._pitch), e2.bZ(r22, r22, -o2.angle);
          const n22 = e2.c3(new Float32Array(16), r22), a22 = e2.ep(1, 0, 0, 0, 0, 0, 1, 0, 0, -1, 0, 0, 0, 0, 0, 1), l22 = e2.ee([], a22), c22 = e2.az([], l22, n22), h22 = Date.now() / 1e3;
          return this._accumulatedTimeFromStart += (h22 - this._prevTime) * i22, this._prevTime = h22, { projectionMatrix: s2, modelviewMatrix: c22 };
        }
      }
      class Yn extends Xn {
        constructor(e22) {
          super(4.25), this._params = { overrideStyleParameters: false, intensity: 0.5, timeFactor: 1, velocityConeAperture: 0, velocity: 300, boxSize: 2500, dropletSizeX: 1, dropletSizeYScale: 10, distortionStrength: 70, screenThinning: { intensity: 0.57, start: 0.46, range: 1.17, fadePower: 0.17, affectedRatio: 1, particleOffset: -0.2 }, color: { r: 0.66, g: 0.68, b: 0.74, a: 0.7 }, direction: { x: -50, y: -35 }, shapeDirPower: 2, shapeNormalPower: 1 }, this._revealParams = new Vn(e22.tp, ["Precipitation", "Rain"]), this._vignetteParams = { strength: 1, start: 0.7, range: 1, fadePower: 0.4, color: { r: 0.27, g: 0.27, b: 0.27, a: 1 } }, this.particlesCount = 16e3;
        }
        update(t22) {
          const i22 = t22.context;
          if (!this.particlesVx) {
            const t3 = Wn(this.particlesCount), o2 = new e2.er(), s2 = new e2.a_();
            let r22 = 0;
            const n22 = e2.ea(1323123451230);
            for (let e22 = 0; e22 < t3.length; ++e22) {
              const i3 = t3[e22], a22 = [2 * n22() - 1, n22(), n22(), n22()];
              o2.emplaceBack(i3[0], i3[1], i3[2], -1, -1, ...a22), o2.emplaceBack(i3[0], i3[1], i3[2], 1, -1, ...a22), o2.emplaceBack(i3[0], i3[1], i3[2], 1, 1, ...a22), o2.emplaceBack(i3[0], i3[1], i3[2], -1, 1, ...a22), s2.emplaceBack(r22 + 0, r22 + 1, r22 + 2), s2.emplaceBack(r22 + 0, r22 + 2, r22 + 3), r22 += 4;
            }
            this.particlesVx = i22.createVertexBuffer(o2, Un.members), this.particlesIdx = i22.createIndexBuffer(s2);
          }
        }
        draw(t22) {
          if (!this._params.overrideStyleParameters && !t22.style.rain) return;
          const i22 = this._params.overrideStyleParameters ? this._revealParams : { revealStart: 0, revealRange: 0.01 }, o2 = t22.transform.zoom;
          if (i22.revealStart > o2) return;
          const s2 = $n(0, 1, i22.revealStart, i22.revealStart + i22.revealRange, o2);
          if (!this.particlesVx || !this.particlesIdx) return;
          const r22 = structuredClone(this._params);
          let n22 = [-r22.direction.x, r22.direction.y, -100];
          e2.au(n22, n22);
          const a22 = structuredClone(this._vignetteParams);
          a22.strength *= s2, r22.overrideStyleParameters || (r22.intensity = t22.style.rain.state.density, r22.timeFactor = t22.style.rain.state.intensity, r22.color = structuredClone(t22.style.rain.state.color), n22 = structuredClone(t22.style.rain.state.direction), r22.screenThinning.intensity = t22.style.rain.state.centerThinning, r22.dropletSizeX = t22.style.rain.state.dropletSize[0], r22.dropletSizeYScale = t22.style.rain.state.dropletSize[1] / t22.style.rain.state.dropletSize[0], r22.distortionStrength = 100 * t22.style.rain.state.distortionStrength, a22.strength = 1, a22.color = structuredClone(t22.style.rain.state.vignetteColor));
          const l22 = this.updateOnRender(t22, r22.timeFactor), c22 = t22.context, h22 = c22.gl, d22 = t22.transform;
          this.screenTexture && this.screenTexture.size[0] === t22.width && this.screenTexture.size[1] === t22.height || (this.screenTexture = new e2.T(c22, { width: t22.width, height: t22.height, data: null }, h22.RGBA8)), r22.distortionStrength > 0 && (c22.activeTexture.set(h22.TEXTURE0), this.screenTexture.bind(h22.LINEAR, h22.CLAMP_TO_EDGE), h22.copyTexSubImage2D(h22.TEXTURE_2D, 0, 0, 0, 0, 0, t22.width, t22.height));
          const u22 = t22.getOrCreateProgram("rainParticle");
          t22.uploadCommonUniforms(c22, u22), c22.activeTexture.set(h22.TEXTURE0), this.screenTexture.bind(h22.LINEAR, h22.CLAMP_TO_EDGE);
          const _22 = [r22.color.r, r22.color.g, r22.color.b, r22.color.a], p22 = (i3, o3) => {
            const s3 = Hn(this._movement.getPosition(), i3), a3 = r22.dropletSizeX, c3 = r22.dropletSizeX * r22.dropletSizeYScale, p3 = t22.width / 2, f22 = t22.height / 2, m22 = $n(0, r22.screenThinning.start, 0, 1, r22.screenThinning.intensity), g22 = $n(1e-3, r22.screenThinning.range, 0, 1, r22.screenThinning.intensity), v22 = $n(0, r22.screenThinning.particleOffset, 0, 1, r22.screenThinning.intensity), y22 = (x22 = { modelview: l22.modelviewMatrix, projection: l22.projectionMatrix, time: this._accumulatedTimeFromStart, camPos: s3, velocityConeAperture: r22.velocityConeAperture, velocity: r22.velocity, boxSize: i3, rainDropletSize: [a3, c3], distortionStrength: r22.distortionStrength, rainDirection: n22, color: _22, screenSize: [d22.width, d22.height], thinningCenterPos: [p3, f22], thinningShape: [m22, g22, Math.pow(10, r22.screenThinning.fadePower)], thinningAffectedRatio: r22.screenThinning.affectedRatio, thinningParticleOffset: v22, shapeDirectionalPower: r22.shapeDirPower, shapeNormalPower: r22.shapeNormalPower, mode: o3 ? 0 : 1 }, { u_modelview: Float32Array.from(x22.modelview), u_projection: Float32Array.from(x22.projection), u_time: x22.time, u_cam_pos: x22.camPos, u_texScreen: 0, u_velocityConeAperture: x22.velocityConeAperture, u_velocity: x22.velocity, u_boxSize: x22.boxSize, u_rainDropletSize: x22.rainDropletSize, u_distortionStrength: x22.distortionStrength, u_rainDirection: x22.rainDirection, u_color: x22.color, u_screenSize: x22.screenSize, u_thinningCenterPos: x22.thinningCenterPos, u_thinningShape: x22.thinningShape, u_thinningAffectedRatio: x22.thinningAffectedRatio, u_thinningParticleOffset: x22.thinningParticleOffset, u_shapeDirectionalPower: x22.shapeDirectionalPower, u_shapeNormalPower: x22.shapeNormalPower, u_mode: x22.mode });
            var x22;
            const b22 = Math.round(r22.intensity * this.particlesCount), w22 = e2.bd.simpleSegment(0, 0, 4 * b22, 2 * b22);
            u22.draw(t22, h22.TRIANGLES, Ni.disabled, ji.disabled, ki.alphaBlended, qi.disabled, y22, "rain_particles", this.particlesVx, this.particlesIdx, w22);
          };
          r22.distortionStrength > 0 && p22(r22.boxSize, true), p22(r22.boxSize, false), this._vignette.draw(t22, a22);
        }
      }
      const Kn = e2.d_([{ type: "Float32", name: "a_pos_3f", components: 3 }, { type: "Float32", name: "a_uv", components: 2 }, { type: "Float32", name: "a_snowParticleData", components: 4 }, { type: "Float32", name: "a_snowParticleDataHorizontalOscillation", components: 2 }]);
      class Jn extends Xn {
        constructor(e22) {
          super(2.25), this._params = { overrideStyleParameters: false, intensity: 0.85, timeFactor: 0.75, velocityConeAperture: 70, velocity: 40, horizontalOscillationRadius: 4, horizontalOscillationRate: 1.5, boxSize: 2e3, billboardSize: 2, shapeFadeStart: 0.27, shapeFadePower: 0.21, screenThinning: { intensity: 0.4, start: 0.15, range: 1.4, fadePower: 0.24, affectedRatio: 1, particleOffset: -0.2 }, color: { r: 1, g: 1, b: 1, a: 1 }, direction: { x: -50, y: -35 } }, this._revealParams = new Vn(e22.tp, ["Precipitation", "Snow"]), this._vignetteParams = { strength: 0.3, start: 0.78, range: 0.46, fadePower: 0.2, color: { r: 1, g: 1, b: 1, a: 1 } }, this.particlesCount = 16e3;
        }
        update(t22) {
          const i22 = t22.context;
          if (!this.particlesVx) {
            const t3 = Wn(this.particlesCount), o2 = new e2.es(), s2 = new e2.a_();
            let r22 = 0;
            const n22 = e2.ea(1323123451230);
            for (let e22 = 0; e22 < t3.length; ++e22) {
              const i3 = t3[e22], a22 = n22(), l22 = n22(), c22 = n22(), h22 = [e22 / t3.length, a22, l22, c22], d22 = [n22(), n22()];
              o2.emplaceBack(i3[0], i3[1], i3[2], -1, -1, ...h22, ...d22), o2.emplaceBack(i3[0], i3[1], i3[2], 1, -1, ...h22, ...d22), o2.emplaceBack(i3[0], i3[1], i3[2], 1, 1, ...h22, ...d22), o2.emplaceBack(i3[0], i3[1], i3[2], -1, 1, ...h22, ...d22), s2.emplaceBack(r22 + 0, r22 + 1, r22 + 2), s2.emplaceBack(r22 + 0, r22 + 2, r22 + 3), r22 += 4;
            }
            this.particlesVx = i22.createVertexBuffer(o2, Kn.members), this.particlesIdx = i22.createIndexBuffer(s2);
          }
        }
        draw(t22) {
          if (!this._params.overrideStyleParameters && !t22.style.snow) return;
          const i22 = structuredClone(this._params);
          let o2 = [-i22.direction.x, i22.direction.y, -100];
          e2.au(o2, o2);
          const s2 = structuredClone(this._vignetteParams), r22 = i22.overrideStyleParameters ? this._revealParams : { revealStart: 0, revealRange: 0.01 }, n22 = t22.transform.zoom;
          if (r22.revealStart > n22) return;
          const a22 = $n(0, 1, r22.revealStart, r22.revealStart + r22.revealRange, n22);
          s2.strength *= a22, i22.overrideStyleParameters || (i22.intensity = t22.style.snow.state.density, i22.timeFactor = t22.style.snow.state.intensity, i22.color = structuredClone(t22.style.snow.state.color), o2 = structuredClone(t22.style.snow.state.direction), i22.screenThinning.intensity = t22.style.snow.state.centerThinning, i22.billboardSize = 2.79 * t22.style.snow.state.flakeSize, s2.strength = 1, s2.color = structuredClone(t22.style.snow.state.vignetteColor));
          const l22 = this.updateOnRender(t22, i22.timeFactor);
          if (!this.particlesVx || !this.particlesIdx) return;
          const c22 = t22.context, h22 = c22.gl, d22 = t22.transform, u22 = t22.getOrCreateProgram("snowParticle");
          t22.uploadCommonUniforms(c22, u22), ((i3, s3, r3) => {
            const n3 = Hn(this._movement.getPosition(), i3), a3 = d22.width / 2, c3 = d22.height / 2, _22 = $n(0, r3.screenThinning.start, 0, 1, r3.screenThinning.intensity), p22 = $n(1e-3, r3.screenThinning.range, 0, 1, r3.screenThinning.intensity), f22 = $n(0, r3.screenThinning.particleOffset, 0, 1, r3.screenThinning.intensity), m22 = (g22 = { modelview: l22.modelviewMatrix, projection: l22.projectionMatrix, time: this._accumulatedTimeFromStart, camPos: n3, velocityConeAperture: r3.velocityConeAperture, velocity: r3.velocity, horizontalOscillationRadius: r3.horizontalOscillationRadius, horizontalOscillationRate: r3.horizontalOscillationRate, boxSize: i3, billboardSize: 1 * r3.billboardSize, simpleShapeParameters: [r3.shapeFadeStart, r3.shapeFadePower], screenSize: [d22.width, d22.height], thinningCenterPos: [a3, c3], thinningShape: [_22, p22, Math.pow(10, r3.screenThinning.fadePower)], thinningAffectedRatio: r3.screenThinning.affectedRatio, thinningParticleOffset: f22, color: [r3.color.r, r3.color.g, r3.color.b, r3.color.a], direction: o2 }, { u_modelview: Float32Array.from(g22.modelview), u_projection: Float32Array.from(g22.projection), u_time: g22.time, u_cam_pos: g22.camPos, u_velocityConeAperture: g22.velocityConeAperture, u_velocity: g22.velocity, u_horizontalOscillationRadius: g22.horizontalOscillationRadius, u_horizontalOscillationRate: g22.horizontalOscillationRate, u_boxSize: g22.boxSize, u_billboardSize: g22.billboardSize, u_simpleShapeParameters: g22.simpleShapeParameters, u_screenSize: g22.screenSize, u_thinningCenterPos: g22.thinningCenterPos, u_thinningShape: g22.thinningShape, u_thinningAffectedRatio: g22.thinningAffectedRatio, u_thinningParticleOffset: g22.thinningParticleOffset, u_particleColor: g22.color, u_direction: g22.direction });
            var g22;
            const v22 = Math.round(r3.intensity * this.particlesCount), y22 = e2.bd.simpleSegment(0, 0, 4 * v22, 2 * v22);
            this.particlesVx && this.particlesIdx && u22.draw(t22, h22.TRIANGLES, Ni.disabled, ji.disabled, ki.alphaBlended, qi.disabled, m22, "snow_particles", this.particlesVx, this.particlesIdx, y22);
          })(i22.boxSize, 0, i22), this._vignette.draw(t22, s2);
        }
      }
      const Qn = { symbol: function(t22, i22, o2, s2, r22) {
        if ("translucent" !== t22.renderPass) return;
        const n22 = ji.disabled, a22 = t22.colorModeForRenderPass(), l22 = o2.layout.get("text-variable-anchor"), c22 = o2.layout.get("text-size-scale-range"), h22 = e2.aD(t22.scaleFactor, c22[0], c22[1]);
        l22 && function(t3, i3, o3, s3, r3, n3, a3, l3) {
          const c3 = i3.transform, h3 = "map" === r3, d3 = "map" === n3;
          for (const i4 of t3) {
            const t4 = s3.getTile(i4), r4 = t4.getBucket(o3);
            if (!r4 || !r4.text || !r4.text.segments.get().length) continue;
            const n4 = e2.bH(r4.textSizeData, c3.zoom, l3), u3 = hi(i4, r4.getProjection(), c3), _22 = c3.calculatePixelsToTileUnitsMatrix(t4), p22 = Zt2(u3, t4.tileID.canonical, d3, h3, c3, r4.getProjection(), _22), f22 = r4.hasIconTextFit() && r4.hasIconData();
            n4 && Br(r4, h3, d3, a3, c3, p22, i4, Math.pow(2, c3.zoom - t4.tileID.overscaledZ), n4, f22);
          }
        }(s2, t22, o2, i22, o2.layout.get("text-rotation-alignment"), o2.layout.get("text-pitch-alignment"), r22, h22);
        const d22 = 0 !== o2.paint.get("icon-opacity").constantOr(1), u22 = 0 !== o2.paint.get("text-opacity").constantOr(1);
        void 0 !== o2.layout.get("symbol-sort-key").constantOr(1) && (d22 || u22) ? kr(t22, i22, o2, s2, n22, a22) : (d22 && kr(t22, i22, o2, s2, n22, a22, { onlyIcons: true }), u22 && kr(t22, i22, o2, s2, n22, a22, { onlyText: true })), i22.map.showCollisionBoxes && (zr(t22, i22, o2, s2, o2.paint.get("text-translate"), o2.paint.get("text-translate-anchor"), true), zr(t22, i22, o2, s2, o2.paint.get("icon-translate"), o2.paint.get("icon-translate-anchor"), false));
      }, circle: function(t22, i22, o2, s2) {
        if ("translucent" !== t22.renderPass) return;
        const r22 = o2.paint.get("circle-opacity"), n22 = o2.paint.get("circle-stroke-width"), a22 = o2.paint.get("circle-stroke-opacity"), l22 = void 0 !== o2.layout.get("circle-sort-key").constantOr(1), c22 = o2.paint.get("circle-emissive-strength");
        if (0 === r22.constantOr(1) && (0 === n22.constantOr(1) || 0 === a22.constantOr(1))) return;
        const h22 = t22.context, d22 = h22.gl, u22 = t22.transform, _22 = t22.depthModeForSublayer(0, Ni.ReadOnly), p22 = ji.disabled, f22 = t22.colorModeForDrapableLayerRenderPass(c22), m22 = "globe" === u22.projection.name, g22 = [e2.ay(u22.center.lng), e2.aH(u22.center.lat)], v22 = [];
        for (let r3 = 0; r3 < s2.length; r3++) {
          const n3 = s2[r3], a3 = i22.getTile(n3), c3 = a3.getBucket(o2);
          if (!c3 || c3.projection.name !== u22.projection.name) continue;
          const h3 = c3.programConfigurations.get(o2.id), d3 = e2.dK(o2), _3 = t22.isTileAffectedByFog(n3);
          m22 && d3.push("PROJECTION_GLOBE_VIEW"), d3.push("DEPTH_D24"), t22.terrain && u22.depthOcclusionForSymbolsAndCircles && d3.push("DEPTH_OCCLUSION");
          const p3 = t22.getOrCreateProgram("circle", { config: h3, defines: d3, overrideFog: _3 }), f3 = c3.layoutVertexBuffer, y3 = c3.globeExtVertexBuffer, x22 = c3.indexBuffer, b22 = u22.projection.createInversionMatrix(u22, n3.canonical), w22 = { programConfiguration: h3, program: p3, layoutVertexBuffer: f3, globeExtVertexBuffer: y3, indexBuffer: x22, uniformValues: e2.dL(t22, n3, a3, b22, g22, o2), tile: a3 };
          if (l22) {
            const t3 = c3.segments.get();
            for (const i3 of t3) v22.push({ segments: new e2.bd([i3]), sortKey: i3.sortKey, state: w22 });
          } else v22.push({ segments: c3.segments, sortKey: 0, state: w22 });
        }
        l22 && v22.sort((e22, t3) => e22.sortKey - t3.sortKey);
        const y22 = { useDepthForOcclusion: u22.depthOcclusionForSymbolsAndCircles };
        for (const e22 of v22) {
          const { programConfiguration: i3, program: s3, layoutVertexBuffer: r3, globeExtVertexBuffer: n3, indexBuffer: a3, uniformValues: l3, tile: c3 } = e22.state, m3 = e22.segments;
          t22.terrain && t22.terrain.setupElevationDraw(c3, s3, y22), t22.uploadCommonUniforms(h22, s3, c3.tileID.toUnwrapped()), s3.draw(t22, d22.TRIANGLES, _22, p22, f22, qi.disabled, l3, o2.id, r3, a3, m3, o2.paint, u22.zoom, i3, [n3]);
        }
      }, heatmap: function(t22, i22, o2, s2) {
        if (0 !== o2.paint.get("heatmap-opacity")) if ("offscreen" === t22.renderPass) {
          const r22 = t22.context, n22 = r22.gl, a22 = ji.disabled, l22 = new ki([n22.ONE, n22.ONE, n22.ONE, n22.ONE], e2.am.transparent, [true, true, true, true]);
          !function(e22, t3, i3, o3) {
            const s3 = e22.gl, r3 = t3.width * o3, n3 = t3.height * o3;
            e22.activeTexture.set(s3.TEXTURE1), e22.viewport.set([0, 0, r3, n3]);
            let a3 = i3.heatmapFbo;
            if (!a3 || a3 && (a3.width !== r3 || a3.height !== n3)) {
              a3 && a3.destroy();
              const t4 = s3.createTexture();
              s3.bindTexture(s3.TEXTURE_2D, t4), s3.texParameteri(s3.TEXTURE_2D, s3.TEXTURE_WRAP_S, s3.CLAMP_TO_EDGE), s3.texParameteri(s3.TEXTURE_2D, s3.TEXTURE_WRAP_T, s3.CLAMP_TO_EDGE), s3.texParameteri(s3.TEXTURE_2D, s3.TEXTURE_MIN_FILTER, s3.LINEAR), s3.texParameteri(s3.TEXTURE_2D, s3.TEXTURE_MAG_FILTER, s3.LINEAR), a3 = i3.heatmapFbo = e22.createFramebuffer(r3, n3, true, null), function(e3, t5, i4, o4, s4, r4) {
                const n4 = e3.gl;
                n4.texImage2D(n4.TEXTURE_2D, 0, e3.extRenderToTextureHalfFloat ? n4.RGBA16F : n4.RGBA, s4, r4, 0, n4.RGBA, e3.extRenderToTextureHalfFloat ? n4.HALF_FLOAT : n4.UNSIGNED_BYTE, null), o4.colorAttachment.set(i4);
              }(e22, 0, t4, a3, r3, n3);
            } else s3.bindTexture(s3.TEXTURE_2D, a3.colorAttachment.get()), e22.bindFramebuffer.set(a3.framebuffer);
          }(r22, t22, o2, "globe" === t22.transform.projection.name ? 0.5 : 0.25), r22.clear({ color: e2.am.transparent });
          const c22 = t22.transform, h22 = "globe" === c22.projection.name, d22 = h22 ? ["PROJECTION_GLOBE_VIEW"] : [], u22 = h22 ? qi.frontCCW : qi.disabled, _22 = [e2.ay(c22.center.lng), e2.aH(c22.center.lat)];
          for (let e22 = 0; e22 < s2.length; e22++) {
            const p22 = s2[e22];
            if (i22.hasRenderableParent(p22)) continue;
            const f22 = i22.getTile(p22), m22 = f22.getBucket(o2);
            if (!m22 || m22.projection.name !== c22.projection.name) continue;
            const g22 = t22.isTileAffectedByFog(p22), v22 = m22.programConfigurations.get(o2.id), y22 = t22.getOrCreateProgram("heatmap", { config: v22, defines: d22, overrideFog: g22 }), { zoom: x22 } = t22.transform;
            t22.terrain && t22.terrain.setupElevationDraw(f22, y22), t22.uploadCommonUniforms(r22, y22, p22.toUnwrapped());
            const b22 = c22.projection.createInversionMatrix(c22, p22.canonical);
            y22.draw(t22, n22.TRIANGLES, Ni.disabled, a22, l22, u22, hr(t22, p22, f22, b22, _22, x22, o2.paint.get("heatmap-intensity")), o2.id, m22.layoutVertexBuffer, m22.indexBuffer, m22.segments, o2.paint, t22.transform.zoom, v22, h22 ? [m22.globeExtVertexBuffer] : null);
          }
          r22.viewport.set([0, 0, t22.width, t22.height]);
        } else "translucent" === t22.renderPass && (t22.context.setColorMode(t22.colorModeForRenderPass()), function(t3, i3) {
          const o3 = t3.context, s3 = o3.gl, r22 = i3.heatmapFbo;
          if (!r22) return;
          o3.activeTexture.set(s3.TEXTURE0), s3.bindTexture(s3.TEXTURE_2D, r22.colorAttachment.get()), o3.activeTexture.set(s3.TEXTURE1);
          let n22 = i3.colorRampTexture;
          n22 || (n22 = i3.colorRampTexture = new e2.T(o3, i3.colorRamp, s3.RGBA8)), n22.bind(s3.LINEAR, s3.CLAMP_TO_EDGE), t3.getOrCreateProgram("heatmapTexture").draw(t3, s3.TRIANGLES, Ni.disabled, ji.disabled, t3.colorModeForRenderPass(), qi.disabled, ((e22, t4, i4, o4) => ({ u_image: 0, u_color_ramp: 1, u_opacity: t4.paint.get("heatmap-opacity") }))(0, i3), i3.id, t3.viewportBuffer, t3.quadTriangleIndexBuffer, t3.viewportSegments, i3.paint, t3.transform.zoom);
        }(t22, o2));
      }, line: function(t22, i22, o2, s2) {
        if ("translucent" !== t22.renderPass) return;
        const r22 = o2.paint.get("line-opacity"), n22 = o2.paint.get("line-width");
        if (0 === r22.constantOr(1) || 0 === n22.constantOr(1)) return;
        const a22 = o2.paint.get("line-emissive-strength"), l22 = o2.paint.get("line-occlusion-opacity"), c22 = o2.layout.get("line-elevation-reference"), h22 = "meters" === o2.layout.get("line-width-unit"), d22 = "sea" === c22, u22 = !(!t22.terrain || !t22.terrain.enabled), _22 = t22.context, p22 = _22.gl;
        if (o2.hasElevatedBuckets && "globe" === t22.transform.projection.name) return;
        const f22 = o2.layout.get("line-cross-slope"), m22 = void 0 !== f22, g22 = f22 < 1, v22 = t22.colorModeForDrapableLayerRenderPass(a22), y22 = t22.terrain && t22.terrain.renderingToTexture, x22 = y22 ? 1 : e2.q.devicePixelRatio, b22 = o2.paint.get("line-dasharray"), w22 = b22.constantOr(1), T2 = o2.layout.get("line-cap"), E22 = b22.constantOr(null), S2 = T2.constantOr(null), I2 = o2.paint.get("line-pattern"), C22 = I2.constantOr(1), R22 = o2.paint.get("line-pattern-cross-fade"), D22 = I2.constantOr(null), A22 = o2.paint.get("line-opacity").constantOr(1);
        let L22 = !C22 && 1 !== A22 || t22.depthOcclusion && l22 > 0 && l22 < 1;
        const P22 = o2.paint.get("line-gradient"), z22 = C22 ? "linePattern" : "line", M22 = e2.dM(o2);
        let O2;
        if (y22 && t22.terrain && t22.terrain.clipOrMaskOverlapStencilType() && (L22 = false), 0 !== l22 && t22.depthOcclusion) {
          const t3 = o2.paint._values["line-opacity"];
          t3 && t3.value && "constant" === t3.value.kind ? O2 = t3.value : e2.w(`Occlusion opacity for layer ${o2.id} is supported only when line-opacity isn't data-driven.`);
        }
        "constant" !== n22.value.kind && false === n22.value.isLineProgressConstant && M22.push("VARIABLE_LINE_WIDTH");
        const F2 = (s3, r3, n3, a3, c3, u3) => {
          for (const f3 of s3) {
            const s4 = i22.getTile(f3);
            if (C22 && !s4.patternsLoaded()) continue;
            const m3 = s4.getBucket(o2);
            if (!m3) continue;
            if ("none" !== m3.elevationType && !c3 || "none" === m3.elevationType && c3) continue;
            t22.prepareDrawTile();
            const g3 = [...r3], b3 = t22.shadowRenderer, T3 = "road" === m3.elevationType && !!b3 && b3.enabled;
            let I3 = [0, 0, 0];
            if (T3) {
              const e22 = t22.style.directionalLight, i3 = t22.style.ambientLight;
              e22 && i3 && (I3 = ao(t22.style, e22, i3)), g3.push("RENDER_SHADOWS", "DEPTH_TEXTURE", "NORMAL_OFFSET");
            }
            const M3 = m3.programConfigurations.get(o2.id);
            let F3 = false;
            if (D22 && s4.imageAtlas) {
              const t3 = e2.dN.from(D22), i3 = t3.getPrimary().scaleSelf(x22).toString(), o3 = s4.imageAtlas.patternPositions.get(i3), r4 = t3.getSecondary(), n4 = r4 ? s4.imageAtlas.patternPositions.get(r4.scaleSelf(x22).toString()) : null;
              F3 = !!o3 && !!n4, o3 && M3.setConstantPatternPositions(o3, n4);
            }
            R22 > 0 && (F3 || M3.getPatternTransitionVertexBuffer("line-pattern")) && g3.push("LINE_PATTERN_TRANSITION");
            const B3 = t22.isTileAffectedByFog(f3), k3 = t22.getOrCreateProgram(z22, { config: M3, defines: g3, overrideFog: B3, overrideRtt: !c3 && void 0 });
            if (!C22 && E22 && S2 && s4.lineAtlas) {
              const e22 = s4.lineAtlas.getDash(E22, S2);
              e22 && M3.setConstantPatternPositions(e22);
            }
            T3 && b3.setupShadows(s4.tileID.toUnwrapped(), k3, "vector-tile", s4.tileID.overscaledZ);
            let [N22, U22] = o2.paint.get("line-trim-offset");
            if ("round" === S2 || "square" === S2) {
              const e22 = 1;
              N22 !== U22 && (0 === N22 && (N22 -= e22), 1 === U22 && (U22 += e22));
            }
            const j22 = y22 ? f3.projMatrix : null, V2 = h22 ? 1 / m3.tileToMeter / e2.aw(s4, 1, t22.transform.zoom) : 1, G2 = h22 ? 1 / m3.tileToMeter / e2.aw(s4, 1, Math.floor(t22.transform.zoom)) : 1, q22 = C22 ? e2.dO(t22, s4, o2, j22, x22, V2, G2, [N22, U22], I3, R22) : e2.dP(t22, s4, o2, j22, m3.lineClipsArray.length, x22, V2, G2, [N22, U22], I3);
            if (P22) {
              const s5 = m3.gradients[o2.id];
              let r4 = s5.texture;
              if (o2.gradientVersion !== s5.version) {
                let n4 = 256;
                if (o2.stepInterpolant) {
                  const o3 = i22.getSource().maxzoom, s6 = f3.canonical.z === o3 ? Math.ceil(1 << t22.transform.maxZoom - f3.canonical.z) : 1;
                  n4 = e2.aD(e2.dQ(m3.maxLineLength / e2.aj * 1024 * s6), 256, _22.maxTextureSize);
                }
                s5.gradient = e2.dR({ expression: o2.gradientExpression(), evaluationKey: "lineProgress", resolution: n4, image: s5.gradient || void 0, clips: m3.lineClipsArray }), s5.texture ? s5.texture.update(s5.gradient) : s5.texture = new e2.T(_22, s5.gradient, p22.RGBA8), s5.version = o2.gradientVersion, r4 = s5.texture;
              }
              _22.activeTexture.set(p22.TEXTURE1), r4.bind(o2.stepInterpolant ? p22.NEAREST : p22.LINEAR, p22.CLAMP_TO_EDGE);
            }
            w22 && (_22.activeTexture.set(p22.TEXTURE0), s4.lineAtlasTexture && s4.lineAtlasTexture.bind(p22.LINEAR, p22.REPEAT), M3.updatePaintBuffers()), C22 && (_22.activeTexture.set(p22.TEXTURE0), s4.imageAtlasTexture && s4.imageAtlasTexture.bind(p22.LINEAR, p22.CLAMP_TO_EDGE), M3.updatePaintBuffers()), c3 && !d22 && t22.terrain.setupElevationDraw(s4, k3), t22.uploadCommonUniforms(_22, k3, f3.toUnwrapped());
            const Z2 = (e22) => {
              null != O2 && (O2.value = A22 * l22), k3.draw(t22, p22.TRIANGLES, n3, e22, v22, qi.disabled, q22, o2.id, m3.layoutVertexBuffer, m3.indexBuffer, m3.segments, o2.paint, t22.transform.zoom, M3, [m3.layoutVertexBuffer2, m3.patternVertexBuffer, m3.zOffsetVertexBuffer]), null != O2 && (O2.value = A22);
            };
            if (L22 && !c3) {
              const e22 = t22.stencilModeForClipping(f3).ref;
              0 === e22 && y22 && _22.clear({ stencil: 0 });
              const i3 = { func: p22.EQUAL, mask: 255 };
              q22.u_alpha_discard_threshold = 0.8, Z2(new ji(i3, e22, 255, p22.KEEP, p22.KEEP, p22.INVERT)), q22.u_alpha_discard_threshold = 0, Z2(new ji(i3, e22, 255, p22.KEEP, p22.KEEP, p22.KEEP));
            } else q22.u_alpha_discard_threshold = L22 && c3 && u3 ? 0.8 : 0, Z2(c3 ? a3 : t22.stencilModeForClipping(f3));
          }
        };
        let B22 = t22.depthModeForSublayer(0, Ni.ReadOnly);
        const k22 = new Ni(t22.depthOcclusion ? p22.GREATER : p22.LEQUAL, Ni.ReadOnly, t22.depthRangeFor3D);
        if (o2.hasNonElevatedBuckets) {
          const i3 = !y22 && t22.terrain;
          0 !== l22 && i3 ? e2.w(`Occlusion opacity for layer ${o2.id} is supported on terrain only if the layer has line-z-offset enabled.`) : i3 ? e2.w(`Cannot render non-elevated lines in immediate mode when terrain is enabled. Layer: ${o2.id}.`) : F2(s2, M22, B22, ji.disabled, false, true);
        }
        if (o2.hasElevatedBuckets) {
          "hd-road-markup" === c22 ? u22 || (B22 = k22, M22.push("ELEVATED_ROADS")) : (M22.push("ELEVATED"), B22 = k22, m22 && M22.push(g22 ? "CROSS_SLOPE_HORIZONTAL" : "CROSS_SLOPE_VERTICAL"), d22 && M22.push("ELEVATION_REFERENCE_SEA"));
          const e22 = L22 ? t22.stencilModeFor3D() : ji.disabled;
          t22.forceTerrainMode = true, F2(s2, M22, B22, e22, true, true), L22 && F2(s2, M22, B22, e22, true, false), t22.forceTerrainMode = false;
        }
        L22 && (t22.resetStencilClippingMasks(), y22 && _22.clear({ stencil: 0 })), 0 === l22 || t22.depthOcclusion || y22 || t22.layersWithOcclusionOpacity.push(t22.currentLayer);
      }, fill: function(t22, i22, o2, s2) {
        const r22 = o2.paint.get("fill-color"), n22 = o2.paint.get("fill-opacity");
        if (0 === n22.constantOr(1)) return;
        const a22 = o2.paint.get("fill-emissive-strength"), l22 = t22.colorModeForDrapableLayerRenderPass(a22), c22 = o2.paint.get("fill-pattern"), h22 = t22.opaquePassEnabledForLayer() && !c22.constantOr(1) && 1 === r22.constantOr(e2.am.transparent).a && 1 === n22.constantOr(0) ? "opaque" : "translucent";
        let d22 = "none";
        "none" !== o2.layout.get("fill-elevation-reference") ? d22 = "road" : 0 !== o2.paint.get("fill-z-offset").constantOr(1) && (d22 = "offset");
        const u22 = !(!t22.terrain || !t22.terrain.enabled), _22 = { painter: t22, sourceCache: i22, layer: o2, coords: s2, colorMode: l22, elevationType: d22, terrainEnabled: u22, pass: h22 };
        if ("shadow" !== t22.renderPass) if ("offset" !== d22) {
          if (Vr(_22, false), "road" === d22) {
            const e22 = !u22 && "translucent" === t22.renderPass;
            e22 && jr(t22, i22, o2, s2, "geometry"), Vr(_22, true, ji.disabled), e22 && function(e3) {
              const { painter: t3, sourceCache: i3, layer: o3, coords: s3, colorMode: r3 } = e3, n3 = t3.context.gl, a3 = e3.painter.shadowRenderer, l3 = !!a3 && a3.enabled, c3 = new Ni(t3.context.gl.LEQUAL, Ni.ReadOnly, t3.depthRangeFor3D);
              let h3 = [0, 0, 0];
              if (l3) {
                const e4 = t3.style.directionalLight, i4 = t3.style.ambientLight;
                e4 && i4 && (h3 = ao(t3.style, e4, i4));
              }
              for (const e4 of s3) {
                const s4 = i3.getTile(e4), d3 = s4.getBucket(o3);
                if (!d3) continue;
                const u3 = d3.elevatedStructures;
                if (!u3 || !u3.renderableSegments || 0 === u3.renderableSegments.segments[0].primitiveLength) continue;
                t3.prepareDrawTile();
                const _3 = d3.bufferData.programConfigurations.get(o3.id), p22 = t3.isTileAffectedByFog(e4), f22 = [];
                l3 && f22.push("RENDER_SHADOWS", "DEPTH_TEXTURE", "NORMAL_OFFSET");
                const m22 = t3.getOrCreateProgram("elevatedStructures", { config: _3, overrideFog: p22, defines: f22 }), g22 = t3.translatePosMatrix(e4.projMatrix, s4, o3.paint.get("fill-translate"), o3.paint.get("fill-translate-anchor"));
                l3 && a3.setupShadows(s4.tileID.toUnwrapped(), m22, "vector-tile", s4.tileID.overscaledZ);
                const v22 = rr(g22, h3);
                t3.uploadCommonUniforms(t3.context, m22, e4.toUnwrapped()), m22.draw(t3, n3.TRIANGLES, c3, ji.disabled, r3, qi.backCCW, v22, o3.id, u3.vertexBuffer, u3.indexBuffer, u3.renderableSegments, o3.paint, t3.transform.zoom, _3, [u3.vertexBufferNormal]);
              }
            }(_22);
          }
        } else Vr(_22, false, t22.stencilModeFor3D());
        else t22.shadowRenderer && "road" === d22 && !u22 && function(e22) {
          const { painter: t3, sourceCache: i3, layer: o3, coords: s3 } = e22, r3 = t3.context.gl, n3 = e22.painter.shadowRenderer;
          for (const e3 of s3) {
            const s4 = i3.getTile(e3), a3 = s4.getBucket(o3);
            if (!a3) continue;
            const l3 = a3.elevatedStructures;
            if (!l3) continue;
            if (!l3.shadowCasterSegments || 0 === l3.shadowCasterSegments.segments[0].primitiveLength) continue;
            t3.prepareDrawTile();
            const c3 = a3.bufferData.programConfigurations.get(o3.id), h3 = t3.isTileAffectedByFog(e3), d3 = t3.getOrCreateProgram("elevatedStructuresDepth", { config: c3, overrideFog: h3 }), u3 = n3.calculateShadowPassMatrixFromTile(s4.tileID.toUnwrapped());
            t3.uploadCommonUniforms(t3.context, d3, e3.toUnwrapped());
            const _3 = { u_matrix: u3, u_depth_bias: 1e-3 };
            d3.draw(t3, r3.TRIANGLES, n3.getShadowPassDepthMode(), ji.disabled, n3.getShadowPassColorMode(), qi.disabled, _3, o3.id, l3.vertexBuffer, l3.indexBuffer, l3.shadowCasterSegments, o3.paint, t3.transform.zoom, c3);
          }
        }(_22);
      }, "fill-extrusion": function(t22, i22, o2, s2) {
        const r22 = o2.paint.get("fill-extrusion-opacity"), n22 = t22.context, a22 = n22.gl, l22 = t22.terrain, c22 = l22 && l22.renderingToTexture;
        if (0 === r22) return;
        const h22 = t22.conflationActive && t22.style.isLayerClipped(o2, i22.getSource()), d22 = t22.style.order.indexOf(o2.fqid);
        if (h22 && function(e22, t3, i3, o3, s3) {
          for (const r3 of o3) {
            const o4 = t3.getTile(r3).getBucket(i3);
            o4 && (o4.updateReplacement(r3, e22.replacementSource, s3), o4.uploadCentroid(e22.context));
          }
        }(t22, i22, o2, s2, d22), l22 || h22) for (const e22 of s2) {
          const s3 = i22.getTile(e22).getBucket(o2);
          s3 && Zr(t22.context, i22, e22, s3, o2, l22, h22);
        }
        if ("shadow" === t22.renderPass && t22.shadowRenderer) {
          const n3 = t22.shadowRenderer;
          if (l22 && r22 < 0.65 && o2._transitionablePaint._values["fill-extrusion-opacity"].value.expression instanceof e2.ab) return;
          const a3 = n3.getShadowPassDepthMode(), c3 = n3.getShadowPassColorMode();
          Gr(t22, i22, o2, s2, a3, ji.disabled, c3, h22);
        } else if ("translucent" === t22.renderPass) {
          const d3 = !o2.paint.get("fill-extrusion-pattern").constantOr(1), u22 = o2.paint.get("fill-extrusion-color").constantOr(e2.am.white);
          if (!c22 && 0 !== u22.a) {
            const e22 = new Ni(t22.context.gl.LEQUAL, Ni.ReadWrite, t22.depthRangeFor3D);
            1 === r22 && d3 ? Gr(t22, i22, o2, s2, e22, ji.disabled, ki.unblended, h22) : (Gr(t22, i22, o2, s2, e22, ji.disabled, ki.disabled, h22), Gr(t22, i22, o2, s2, e22, t22.stencilModeFor3D(), t22.colorModeForRenderPass(), h22), t22.resetStencilClippingMasks());
          }
          if (t22.style.enable3dLights() && d3 && (!l22 && "globe" !== t22.transform.projection.name || c22)) {
            const r3 = o2.paint.get("fill-extrusion-opacity"), d4 = o2.paint.get("fill-extrusion-ambient-occlusion-intensity"), u3 = o2.paint.get("fill-extrusion-ambient-occlusion-ground-radius"), _22 = o2.paint.get("fill-extrusion-flood-light-intensity"), p22 = "none" === o2.paint.get("fill-extrusion-flood-light-color-use-theme").constantOr("default"), f22 = o2.paint.get("fill-extrusion-flood-light-color").toRenderColor(p22 ? null : o2.lut).toArray01().slice(0, 3), m22 = d4 > 0 && u3 > 0, g22 = _22 > 0, v22 = (e22, t3, i3) => (1 - i3) * e22 + i3 * t3, y22 = (n3) => {
              const l3 = t22.depthModeForSublayer(1, Ni.ReadOnly, a22.LEQUAL, true), c3 = o2.paint.get(n3 ? "fill-extrusion-ambient-occlusion-ground-attenuation" : "fill-extrusion-flood-light-ground-attenuation"), p3 = v22(0.1, 3, c3), m3 = t22._showOverdrawInspector;
              if (!m3) {
                const c4 = new ji({ func: a22.ALWAYS, mask: 255 }, 255, 255, a22.KEEP, a22.KEEP, a22.REPLACE), m4 = new ki([a22.ONE, a22.ONE, a22.ONE, a22.ONE], e2.am.transparent, [false, false, false, true], a22.MIN);
                qr(t22, i22, o2, s2, l3, c4, m4, qi.disabled, n3, "sdf", r3, d4, u3, _22, f22, p3, h22, false);
              }
              {
                const c4 = m3 ? ji.disabled : new ji({ func: a22.EQUAL, mask: 255 }, 255, 255, a22.KEEP, a22.DECR, a22.DECR), g3 = m3 ? t22.colorModeForRenderPass() : new ki([a22.ONE_MINUS_DST_ALPHA, a22.DST_ALPHA, a22.ONE, a22.ONE], e2.am.transparent, [true, true, true, true]);
                qr(t22, i22, o2, s2, l3, c4, g3, qi.disabled, n3, "color", r3, d4, u3, _22, f22, p3, h22, false);
              }
            };
            if (c22) {
              const c3 = (n3, l3, c4) => {
                const p3 = t22.depthModeForSublayer(1, Ni.ReadOnly, a22.LEQUAL, false), m3 = o2.paint.get(n3 ? "fill-extrusion-ambient-occlusion-ground-attenuation" : "fill-extrusion-flood-light-ground-attenuation"), g3 = v22(0.1, 3, m3);
                {
                  const c5 = new ki([a22.ONE, a22.ONE, a22.ONE, a22.ONE], e2.am.transparent, [false, false, false, true]);
                  qr(t22, i22, o2, s2, p3, ji.disabled, c5, qi.disabled, n3, "clear", r3, d4, u3, _22, f22, g3, h22, l3);
                }
                {
                  const c5 = new ji({ func: a22.ALWAYS, mask: 255 }, 255, 255, a22.KEEP, a22.KEEP, a22.REPLACE), m4 = new ki([a22.ONE, a22.ONE, a22.ONE, a22.ONE], e2.am.transparent, [false, false, false, true], a22.MIN);
                  qr(t22, i22, o2, s2, p3, c5, m4, qi.disabled, n3, "sdf", r3, d4, u3, _22, f22, g3, h22, l3);
                }
                {
                  const c5 = n3 ? a22.ZERO : a22.ONE_MINUS_DST_ALPHA, m4 = new ji({ func: a22.EQUAL, mask: 255 }, 255, 255, a22.KEEP, a22.DECR, a22.DECR), v3 = new ki([c5, a22.DST_ALPHA, a22.ONE_MINUS_DST_ALPHA, a22.ZERO], e2.am.transparent, [true, true, true, true]);
                  qr(t22, i22, o2, s2, p3, m4, v3, qi.disabled, n3, "color", r3, d4, u3, _22, f22, g3, h22, l3);
                }
                {
                  const m4 = new ki([a22.ONE, a22.ONE, a22.ONE, n3 ? a22.ZERO : a22.ONE], e2.am.transparent, [false, false, false, true], n3 ? a22.FUNC_ADD : a22.MAX);
                  qr(t22, i22, o2, s2, p3, ji.disabled, m4, qi.disabled, n3, "clear", r3, d4, u3, _22, f22, g3, h22, l3, c4);
                }
              };
              if (m22 || g22) {
                let i3;
                if (t22.prepareDrawTile(), l22) {
                  const t3 = l22.drapeBufferSize[0], o3 = l22.drapeBufferSize[1];
                  i3 = l22.framebufferCopyTexture, i3 && (!i3 || i3.size[0] === t3 && i3.size[1] === o3) || (i3 && i3.destroy(), i3 = l22.framebufferCopyTexture = new e2.T(n22, new e2.r({ width: t3, height: o3 }), a22.RGBA8)), i3.bind(a22.LINEAR, a22.CLAMP_TO_EDGE), a22.copyTexSubImage2D(a22.TEXTURE_2D, 0, 0, 0, 0, 0, t3, o3);
                }
                m22 && c3(true, false, i3), g22 && c3(false, true, i3);
              }
            } else m22 && y22(true), g22 && y22(false), (m22 || g22) && t22.resetStencilClippingMasks();
          }
        }
      }, hillshade: function(e22, t22, i22, o2) {
        if ("offscreen" !== e22.renderPass && "translucent" !== e22.renderPass) return;
        if (e22.style.disableElevatedTerrain) return;
        const s2 = e22.context, r22 = e22.terrain && e22.terrain.renderingToTexture, [n22, a22] = "translucent" !== e22.renderPass || r22 ? [{}, o2] : e22.stencilConfigForOverlap(o2);
        for (const o3 of a22) {
          const s3 = t22.getTile(o3);
          if (s3.needsHillshadePrepare && "offscreen" === e22.renderPass) $o(e22, s3, i22);
          else if ("translucent" === e22.renderPass) {
            const t3 = e22.depthModeForSublayer(0, Ni.ReadOnly), a3 = i22.paint.get("hillshade-emissive-strength"), l22 = e22.colorModeForDrapableLayerRenderPass(a3), c22 = r22 && e22.terrain ? e22.terrain.stencilModeForRTTOverlap(o3) : n22[o3.overscaledZ];
            Ho(e22, o3, s3, i22, t3, c22, l22);
          }
        }
        s2.viewport.set([0, 0, e22.width, e22.height]), e22.resetStencilClippingMasks();
      }, raster: function(t22, i22, o2, s2, r22, n22) {
        if ("translucent" !== t22.renderPass) return;
        if (0 === o2.paint.get("raster-opacity")) return;
        const a22 = "globe" === t22.transform.projection.name, l22 = 0 !== o2.paint.get("raster-elevation"), c22 = l22 && a22;
        if (t22.renderElevatedRasterBackface && !c22) return;
        const h22 = t22.context, d22 = h22.gl, u22 = i22.getSource(), _22 = function(t3, i3, o3, s3) {
          const r3 = i3.paint.get("raster-color"), n3 = "raster-array" === t3.type, a3 = [], l3 = i3.paint.get("raster-resampling"), c3 = i3.paint.get("raster-color-mix");
          let h3 = i3.paint.get("raster-color-range");
          const d3 = [c3[0], c3[1], c3[2], 0], u3 = c3[3];
          let _3 = "nearest" === l3 ? s3.NEAREST : s3.LINEAR;
          if (n3 && (a3.push("RASTER_ARRAY"), r3 || a3.push("RASTER_COLOR"), "linear" === l3 && a3.push("RASTER_ARRAY_LINEAR"), _3 = s3.NEAREST, !h3 && t3.rasterLayers)) {
            const e22 = t3.rasterLayers.find(({ id: e3 }) => e3 === i3.sourceLayer);
            e22 && e22.fields && e22.fields.range && (h3 = e22.fields.range);
          }
          if (h3 = h3 || [0, 1], r3) {
            a3.push("RASTER_COLOR"), o3.activeTexture.set(s3.TEXTURE2), i3.updateColorRamp(h3);
            let t4 = i3.colorRampTexture;
            t4 || (t4 = i3.colorRampTexture = new e2.T(o3, i3.colorRamp, s3.RGBA8)), t4.bind(s3.LINEAR, s3.CLAMP_TO_EDGE);
          }
          return { mix: d3, range: h3, offset: u3, defines: a3, resampling: _3 };
        }(u22, o2, h22, d22);
        if (u22 instanceof e2.aP && !s2.length && !a22) return;
        const p22 = o2.paint.get("raster-emissive-strength"), f22 = t22.colorModeForDrapableLayerRenderPass(p22), m22 = t22.terrain && t22.terrain.renderingToTexture, g22 = !t22.options.moving, v22 = "nearest" === o2.paint.get("raster-resampling") ? d22.NEAREST : d22.LINEAR;
        if (u22 instanceof e2.aP && !s2.length && (u22.onNorthPole || u22.onSouthPole)) {
          const e22 = l22 ? t22.stencilModeFor3D() : ji.disabled;
          return void Kr(!!u22.onNorthPole, null, t22, i22, o2, p22, _22, qi.disabled, e22);
        }
        if (!s2.length) return;
        const [y22, x22] = u22 instanceof e2.aP || m22 ? [{}, s2] : t22.stencilConfigForOverlap(s2), b22 = x22[x22.length - 1].overscaledZ;
        c22 && _22.defines.push("PROJECTION_GLOBE_VIEW"), l22 && _22.defines.push("RENDER_CUTOFF");
        const w22 = (s3, r3, x3) => {
          for (const w3 of s3) {
            const s4 = w3.toUnwrapped(), T2 = i22.getTile(w3);
            if (m22 && (!T2 || !T2.hasData())) continue;
            h22.activeTexture.set(d22.TEXTURE0);
            const E22 = Qr(T2, u22, o2, _22);
            if (!E22 || !E22.texture) continue;
            const { texture: S2, mix: I2, offset: C22, tileSize: R22, buffer: D22 } = E22;
            let A22, L22;
            m22 ? (A22 = Ni.disabled, L22 = w3.projMatrix) : l22 ? (A22 = new Ni(d22.LEQUAL, Ni.ReadWrite, t22.depthRangeFor3D), L22 = a22 ? Float32Array.from(t22.transform.expandedFarZProjMatrix) : t22.transform.calculateProjMatrix(s4, g22)) : (A22 = t22.depthModeForSublayer(w3.overscaledZ - b22, 1 === o2.paint.get("raster-opacity") ? Ni.ReadWrite : Ni.ReadOnly, d22.LESS), L22 = t22.transform.calculateProjMatrix(s4, g22));
            const P22 = t22.terrain && m22 ? t22.terrain.stencilModeForRTTOverlap(w3) : y22[w3.overscaledZ], z22 = n22 ? 0 : o2.paint.get("raster-fade-duration");
            T2.registerFadeDuration(z22);
            const M22 = i22.findLoadedParent(w3, 0), O2 = Us(T2, M22, i22, t22.transform, z22);
            let F2, B22;
            t22.terrain && t22.terrain.prepareDrawTile(), h22.activeTexture.set(d22.TEXTURE0), S2.bind(v22, d22.CLAMP_TO_EDGE), h22.activeTexture.set(d22.TEXTURE1), M22 ? (M22.texture && M22.texture.bind(v22, d22.CLAMP_TO_EDGE), F2 = Math.pow(2, M22.tileID.overscaledZ - T2.tileID.overscaledZ), B22 = [T2.tileID.canonical.x * F2 % 1, T2.tileID.canonical.y * F2 % 1]) : S2.bind(v22, d22.CLAMP_TO_EDGE), "useMipmap" in S2 && h22.extTextureFilterAnisotropic && t22.transform.pitch > 20 && d22.texParameterf(d22.TEXTURE_2D, h22.extTextureFilterAnisotropic.TEXTURE_MAX_ANISOTROPY_EXT, h22.extTextureFilterAnisotropicMax);
            const k22 = t22.transform;
            let N22;
            const U22 = l22 ? Jr(k22) : [0, 0, 0, 0];
            let j22, V2, G2, q22, Z2, H2 = 0;
            if (c22 && u22 instanceof e2.aP && u22.coordinates.length > 3) j22 = Float32Array.from(e2.bh(e2.dr(new e2.cp(0, 0, 0)))), V2 = Float32Array.from(k22.globeMatrix), G2 = Float32Array.from(e2.dm(k22)), q22 = [e2.ay(k22.center.lng), e2.aH(k22.center.lat)], N22 = u22.elevatedGlobePerspectiveTransform, Z2 = u22.elevatedGlobeGridMatrix || new Float32Array(9);
            else if (c22) {
              const t3 = e2.dn(w3.canonical);
              H2 = e2.dp(t3.getCenter().lat), j22 = Float32Array.from(e2.bh(e2.dr(w3.canonical))), V2 = Float32Array.from(k22.globeMatrix), G2 = Float32Array.from(e2.dm(k22)), q22 = [e2.ay(k22.center.lng), e2.aH(k22.center.lat)], N22 = [0, 0], Z2 = Float32Array.from(e2.dq(w3.canonical, t3, H2, k22.worldSize / k22._pixelsPerMercatorPixel));
            } else N22 = u22 instanceof e2.aP ? u22.perspectiveTransform : [0, 0], j22 = new Float32Array(16), V2 = new Float32Array(9), G2 = new Float32Array(16), q22 = [0, 0], Z2 = new Float32Array(9);
            const W2 = _r(L22, j22, V2, G2, Z2, B22 || [0, 0], e2.ah(t22.transform.zoom), q22, U22, F2 || 1, O2, o2, N22, l22 ? o2.paint.get("raster-elevation") : 0, 2, I2, C22, _22.range, R22, D22, p22), $2 = t22.isTileAffectedByFog(w3), X22 = t22.getOrCreateProgram("raster", { defines: _22.defines, overrideFog: $2 });
            if (t22.uploadCommonUniforms(h22, X22, s4), u22 instanceof e2.aP) {
              const i3 = u22.elevatedGlobeVertexBuffer, s5 = u22.elevatedGlobeIndexBuffer;
              if (m22 || !a22) u22.boundsBuffer && u22.boundsSegments && X22.draw(t22, d22.TRIANGLES, A22, ji.disabled, f22, qi.disabled, W2, o2.id, u22.boundsBuffer, t22.quadTriangleIndexBuffer, u22.boundsSegments);
              else if (i3 && s5) {
                const n3 = k22.zoom <= e2.cL ? u22.elevatedGlobeSegments : u22.getSegmentsForLongitude(k22.center.lng);
                n3 && X22.draw(t22, d22.TRIANGLES, A22, ji.disabled, f22, r3, W2, o2.id, i3, s5, n3);
              }
            } else if (c22) {
              A22 = new Ni(d22.LEQUAL, Ni.ReadOnly, t22.depthRangeFor3D);
              const e22 = t22.globeSharedBuffers;
              if (e22) {
                const [i3, s5, n3] = e22.getGridBuffers(H2, false);
                X22.draw(t22, d22.TRIANGLES, A22, x3 || P22, t22.colorModeForRenderPass(), r3, W2, o2.id, i3, s5, n3);
              }
            } else {
              const { tileBoundsBuffer: e22, tileBoundsIndexBuffer: i3, tileBoundsSegments: s5 } = t22.getTileBoundsBuffers(T2);
              X22.draw(t22, d22.TRIANGLES, A22, P22, f22, qi.disabled, W2, o2.id, e22, i3, s5);
            }
          }
          if (!(u22 instanceof e2.aP) && c22) for (const e22 of s3) {
            const s4 = e22.canonical.y === (1 << e22.canonical.z) - 1;
            0 === e22.canonical.y && Kr(true, e22, t22, i22, o2, p22, _22, r3, x3 || ji.disabled), s4 && Kr(false, e22, t22, i22, o2, p22, _22, r3 === qi.frontCW ? qi.backCW : qi.frontCW, x3 || ji.disabled);
          }
        };
        c22 ? w22(x22, t22.renderElevatedRasterBackface ? qi.backCW : qi.frontCW, t22.stencilModeFor3D()) : w22(x22, qi.disabled, void 0), t22.resetStencilClippingMasks();
      }, "raster-particle": function(t22, i22, o2, s2, r22, n22) {
        "offscreen" === t22.renderPass && function(t3, i3, o3, s3) {
          if (!s3.length) return;
          const r3 = t3.context, n3 = r3.gl, a22 = i3.getSource();
          if (!(a22 instanceof st)) return;
          const l22 = Math.ceil(Math.sqrt(o3.paint.get("raster-particle-count")));
          let c22 = o3.particlePositionRGBAImage;
          if (!c22 || c22.width !== l22) {
            const t4 = function(e22) {
              const t5 = e22 * e22, i4 = new Uint8Array(4 * t5), o4 = function(e3) {
                return e3 |= 0, e3 = Math.imul(2747636419 ^ e3, 2654435769), e3 = Math.imul(e3 ^ e3 >>> 16, 2654435769), ((e3 = Math.imul(e3 ^ e3 >>> 16, 2654435769)) >>> 0) / 4294967296;
              }, s4 = 1 / 1.1;
              for (let e3 = 0; e3 < t5; e3++) {
                const t6 = s4 * (o4(2 * e3 + 0) + fr), r4 = s4 * (o4(2 * e3 + 1) + fr), n4 = 255 * t6 % 1, a3 = 255 * r4 % 1, l3 = n4, c3 = r4 - a3 / 255, h3 = a3;
                i4[4 * e3 + 0] = 255 * (t6 - n4 / 255), i4[4 * e3 + 1] = 255 * l3, i4[4 * e3 + 2] = 255 * c3, i4[4 * e3 + 3] = 255 * h3;
              }
              return i4;
            }(l22);
            c22 = o3.particlePositionRGBAImage = new e2.r({ width: l22, height: l22 }, t4);
          }
          let h22 = o3.particleFramebuffer;
          h22 ? h22.width !== l22 && (h22.destroy(), h22 = o3.particleFramebuffer = r3.createFramebuffer(l22, l22, true, null)) : h22 = o3.particleFramebuffer = r3.createFramebuffer(l22, l22, true, null);
          const d22 = [];
          for (const e22 of s3) {
            const t4 = i3.getTile(e22);
            if (!(t4 instanceof Tt)) continue;
            const s4 = on(t4, a22, o3);
            if (!s4) continue;
            const n4 = [t4.tileSize, t4.tileSize];
            let h3 = o3.tileFramebuffer;
            h3 || (h3 = o3.tileFramebuffer = r3.createFramebuffer(n4[0], n4[1], true, null));
            let u3 = t4.rasterParticleState;
            u3 || (u3 = t4.rasterParticleState = new tn(r3, e22, n4, c22));
            const _3 = u3.update(o3.lastInvalidatedAt);
            u3.particleTextureDimension !== l22 && u3.updateParticleTexture(e22, c22);
            const p22 = u3.targetColorTexture;
            u3.targetColorTexture = u3.backgroundColorTexture, u3.backgroundColorTexture = p22;
            const f22 = u3.particleTexture0;
            u3.particleTexture0 = u3.particleTexture1, u3.particleTexture1 = f22, d22.push([e22, s4, u3, _3]);
          }
          if (0 === d22.length) return;
          const u22 = e2.q.now(), _22 = o3.previousDrawTimestamp ? 1e-3 * (u22 - o3.previousDrawTimestamp) : 0.0167;
          if (o3.previousDrawTimestamp = u22, o3.hasColorMap()) {
            r3.activeTexture.set(n3.TEXTURE0 + 2);
            let t4 = o3.colorRampTexture;
            t4 || (t4 = o3.colorRampTexture = new e2.T(r3, o3.colorRamp, n3.RGBA8)), t4.bind(n3.LINEAR, n3.CLAMP_TO_EDGE);
          }
          r3.bindFramebuffer.set(o3.tileFramebuffer.framebuffer), function(t4, i4, o4) {
            const s4 = t4.context, r4 = s4.gl, n4 = i4.tileFramebuffer;
            s4.activeTexture.set(r4.TEXTURE0);
            const a3 = { u_texture: 0, u_opacity: 1.05 * (c3 = i4.paint.get("raster-particle-fade-opacity-factor")) / (c3 + 0.05) }, l3 = t4.getOrCreateProgram("rasterParticleTexture", { defines: [], overrideFog: false });
            var c3;
            for (const c4 of o4) {
              const [, , o5, h3] = c4;
              n4.colorAttachment.set(o5.targetColorTexture.texture), s4.viewport.set([0, 0, n4.width, n4.height]), s4.clear({ color: e2.am.transparent }), h3 && (o5.backgroundColorTexture.bind(r4.NEAREST, r4.CLAMP_TO_EDGE), l3.draw(t4, r4.TRIANGLES, Ni.disabled, ji.disabled, ki.alphaBlended, qi.disabled, a3, i4.id, t4.viewportBuffer, t4.quadTriangleIndexBuffer, t4.viewportSegments));
            }
          }(t3, o3, d22), function(t4, i4, o4, s4) {
            const r4 = t4.context, n4 = r4.gl, a3 = o4.tileFramebuffer, l3 = "globe" === t4.transform.projection.name, c3 = o4.paint.get("raster-particle-max-speed");
            for (const h3 of s4) {
              const [s5, d3, u3] = h3;
              r4.activeTexture.set(n4.TEXTURE0 + 0), d3.texture.bind(n4.LINEAR, n4.CLAMP_TO_EDGE), a3.colorAttachment.set(u3.targetColorTexture.texture);
              const _3 = t4.getOrCreateProgram("rasterParticleDraw", { defines: d3.defines, overrideFog: false });
              r4.activeTexture.set(n4.TEXTURE0 + 1);
              const p22 = d3.scalarData ? [] : [0, 1, 2, 3].map((t5) => e2.dU[t5](s5));
              p22.push(s5);
              const f22 = s5.canonical.x, m22 = s5.canonical.y;
              for (const e22 of p22) {
                const r5 = i4.getTile(l3 ? e22.wrapped() : e22);
                if (!r5) continue;
                const a4 = r5.rasterParticleState;
                if (!a4) continue;
                const h4 = e22.canonical.x + (1 << e22.canonical.z) * (e22.wrap - s5.wrap), u4 = e22.canonical.y;
                a4.particleTexture0.bind(n4.NEAREST, n4.CLAMP_TO_EDGE);
                const p3 = gr(1, a4.particleTexture0.size[0], [h4 - f22, u4 - m22], 0, d3.texture.size, 2, c3, d3.textureOffset, d3.scale, d3.offset);
                _3.draw(t4, n4.POINTS, Ni.disabled, ji.disabled, ki.alphaBlended, qi.disabled, p3, o4.id, a4.particleIndexBuffer, void 0, a4.particleSegment);
              }
            }
          }(t3, i3, o3, d22), r3.bindFramebuffer.set(o3.particleFramebuffer.framebuffer), function(t4, i4, o4, s4) {
            const r4 = t4.context, n4 = r4.gl, a3 = i4.paint.get("raster-particle-max-speed"), l3 = s4 * i4.paint.get("raster-particle-speed-factor") * 0.15, c3 = function(e22) {
              return Math.pow(e22, 6);
            }(0.01 + 1 * i4.paint.get("raster-particle-reset-rate-factor")), h3 = i4.particleFramebuffer;
            r4.viewport.set([0, 0, h3.width, h3.height]);
            for (const s5 of o4) {
              const [, o5, d3] = s5;
              r4.activeTexture.set(n4.TEXTURE0 + 0), o5.texture.bind(n4.LINEAR, n4.CLAMP_TO_EDGE), r4.activeTexture.set(n4.TEXTURE0 + 1);
              const u3 = d3.particleTexture0;
              u3.bind(n4.NEAREST, n4.CLAMP_TO_EDGE);
              const _3 = vr(1, u3.size[0], 0, o5.texture.size, a3, l3, c3, o5.textureOffset, o5.scale, o5.offset);
              h3.colorAttachment.set(d3.particleTexture1.texture), r4.clear({ color: e2.am.transparent }), t4.getOrCreateProgram("rasterParticleUpdate", { defines: o5.defines }).draw(t4, n4.TRIANGLES, Ni.disabled, ji.disabled, ki.unblended, qi.disabled, _3, i4.id, t4.viewportBuffer, t4.quadTriangleIndexBuffer, t4.viewportSegments);
            }
          }(t3, o3, d22, _22);
        }(t22, i22, o2, s2), "translucent" === t22.renderPass && (function(t3, i3, o3, s3, r3) {
          const n3 = t3.context, a22 = n3.gl, l22 = i3.getSource().tileSize, c22 = 5 * (1 - e2.af(e2.cx, e2.cx + 1, t3.transform.zoom)) * l22 + o3.paint.get("raster-particle-elevation"), h22 = !t3.options.moving, d22 = "globe" === t3.transform.projection.name;
          if (!s3.length) return;
          const [u22, _22] = t3.stencilConfigForOverlap(s3), p22 = [];
          d22 && p22.push("PROJECTION_GLOBE_VIEW");
          const f22 = t3.stencilModeFor3D();
          for (const s4 of _22) {
            const r4 = s4.toUnwrapped(), l3 = i3.getTile(s4);
            if (!l3.rasterParticleState) continue;
            const _3 = l3.rasterParticleState, m22 = 100;
            l3.registerFadeDuration(m22);
            const g22 = i3.findLoadedParent(s4, 0), v22 = Us(l3, g22, i3, t3.transform, m22);
            let y22, x22;
            t3.terrain && t3.terrain.prepareDrawTile(), n3.activeTexture.set(a22.TEXTURE0), _3.targetColorTexture.bind(a22.LINEAR, a22.CLAMP_TO_EDGE), n3.activeTexture.set(a22.TEXTURE1), g22 && g22.rasterParticleState ? (g22.rasterParticleState.targetColorTexture.bind(a22.LINEAR, a22.CLAMP_TO_EDGE), y22 = Math.pow(2, g22.tileID.overscaledZ - l3.tileID.overscaledZ), x22 = [l3.tileID.canonical.x * y22 % 1, l3.tileID.canonical.y * y22 % 1]) : _3.targetColorTexture.bind(a22.LINEAR, a22.CLAMP_TO_EDGE);
            const b22 = d22 ? Float32Array.from(t3.transform.expandedFarZProjMatrix) : t3.transform.calculateProjMatrix(r4, h22), w22 = t3.transform, T2 = sn(w22), E22 = e2.dn(s4.canonical), S2 = e2.dp(E22.getCenter().lat);
            let I2, C22, R22, D22, A22;
            d22 ? (I2 = Float32Array.from(e2.bh(e2.dr(s4.canonical))), C22 = Float32Array.from(w22.globeMatrix), R22 = Float32Array.from(e2.dm(w22)), D22 = [e2.ay(w22.center.lng), e2.aH(w22.center.lat)], A22 = Float32Array.from(e2.dq(s4.canonical, E22, S2, w22.worldSize / w22._pixelsPerMercatorPixel))) : (I2 = new Float32Array(16), C22 = new Float32Array(9), R22 = new Float32Array(16), D22 = [0, 0], A22 = new Float32Array(9));
            const L22 = mr(b22, I2, C22, R22, A22, x22 || [0, 0], e2.ah(t3.transform.zoom), D22, T2, y22 || 1, v22, c22), P22 = t3.isTileAffectedByFog(s4), z22 = t3.getOrCreateProgram("rasterParticle", { defines: p22, overrideFog: P22 });
            if (t3.uploadCommonUniforms(n3, z22, r4), d22) {
              const e22 = new Ni(a22.LEQUAL, Ni.ReadOnly, t3.depthRangeFor3D), i4 = 0, s5 = t3.globeSharedBuffers;
              if (s5) {
                const [r5, n4, l4] = s5.getGridBuffers(S2, 0 !== i4);
                z22.draw(t3, a22.TRIANGLES, e22, f22, ki.alphaBlended, t3.renderElevatedRasterBackface ? qi.frontCCW : qi.backCCW, L22, o3.id, r5, n4, l4);
              }
            } else {
              const e22 = t3.depthModeForSublayer(0, Ni.ReadOnly), i4 = u22[s4.overscaledZ], { tileBoundsBuffer: r5, tileBoundsIndexBuffer: n4, tileBoundsSegments: c3 } = t3.getTileBoundsBuffers(l3);
              z22.draw(t3, a22.TRIANGLES, e22, i4, ki.alphaBlended, qi.disabled, L22, o3.id, r5, n4, c3);
            }
          }
          t3.resetStencilClippingMasks();
        }(t22, i22, o2, s2), t22.style.map.triggerRepaint());
      }, background: function(t22, i22, o2, s2) {
        const r22 = o2.paint.get("background-color"), n22 = "none" === o2.paint.get("background-color-use-theme").constantOr("default"), a22 = o2.paint.get("background-opacity"), l22 = o2.paint.get("background-emissive-strength"), c22 = "viewport" === o2.paint.get("background-pitch-alignment");
        if (0 === a22) return;
        const h22 = t22.context, d22 = h22.gl, u22 = t22.transform, _22 = u22.tileSize, p22 = o2.paint.get("background-pattern");
        let f22;
        if (void 0 !== p22) {
          if (null === p22) return;
          if (f22 = t22.imageManager.getPattern(e2.I.from(p22.toString()), o2.scope, t22.style.getLut(o2.scope)), !f22) return;
        }
        const m22 = !p22 && 1 === r22.a && 1 === a22 && t22.opaquePassEnabledForLayer() ? "opaque" : "translucent";
        if (t22.renderPass !== m22) return;
        const g22 = ji.disabled, v22 = t22.depthModeForSublayer(0, "opaque" === m22 ? Ni.ReadWrite : Ni.ReadOnly), y22 = t22.colorModeForDrapableLayerRenderPass(l22), x22 = p22 ? "backgroundPattern" : "background";
        let b22, w22 = s2;
        if (w22 || (b22 = t22.getBackgroundTiles(), w22 = Object.values(b22).map((e22) => e22.tileID)), p22 && (h22.activeTexture.set(d22.TEXTURE0), t22.imageManager.bind(t22.context, o2.scope)), c22) {
          const i3 = t22.getOrCreateProgram(x22, { overrideFog: false, overrideRtt: true }), s3 = new Float32Array(e2.bx([])), h3 = new e2.aM(0, 0, 0, 0, 0), u3 = p22 ? wr(s3, l22, a22, t22, 0, o2.scope, f22, c22, { tileID: h3, tileSize: _22 }) : br(s3, l22, a22, r22.toRenderColor(n22 ? null : o2.lut));
          i3.draw(t22, d22.TRIANGLES, v22, g22, y22, qi.disabled, u3, o2.id, t22.viewportBuffer, t22.quadTriangleIndexBuffer, t22.viewportSegments);
        } else for (const e22 of w22) {
          const m3 = t22.isTileAffectedByFog(e22), w3 = t22.getOrCreateProgram(x22, { overrideFog: m3 }), T2 = e22.toUnwrapped(), E22 = s2 ? e22.projMatrix : t22.transform.calculateProjMatrix(T2);
          t22.prepareDrawTile();
          const S2 = i22 ? i22.getTile(e22) : b22 ? b22[e22.key] : new wt(e22, _22, u22.zoom, t22), I2 = p22 ? wr(E22, l22, a22, t22, 0, o2.scope, f22, c22, { tileID: e22, tileSize: _22 }) : br(E22, l22, a22, r22.toRenderColor(n22 ? null : o2.lut));
          t22.uploadCommonUniforms(h22, w3, T2);
          const { tileBoundsBuffer: C22, tileBoundsIndexBuffer: R22, tileBoundsSegments: D22 } = t22.getTileBoundsBuffers(S2);
          w3.draw(t22, d22.TRIANGLES, v22, g22, y22, qi.disabled, I2, o2.id, C22, R22, D22);
        }
      }, sky: function(t22, i22, o2) {
        const s2 = t22._atmosphere ? e2.ah(t22.transform.zoom) : 1, r22 = o2.paint.get("sky-opacity") * s2;
        if (0 === r22) return;
        const n22 = t22.context, a22 = o2.paint.get("sky-type"), l22 = new Ni(n22.gl.LEQUAL, Ni.ReadOnly, [0, 1]), c22 = t22.frameCounter / 1e3 % 1;
        "atmosphere" === a22 ? "offscreen" === t22.renderPass ? o2.needsSkyboxCapture(t22) && (function(t3, i3, o3, s3) {
          const r3 = t3.context, n3 = r3.gl;
          let a3 = i3.skyboxFbo;
          if (!a3) {
            a3 = i3.skyboxFbo = r3.createFramebuffer(32, 32, true, null), i3.skyboxGeometry = new gn(r3), i3.skyboxTexture = r3.gl.createTexture(), n3.bindTexture(n3.TEXTURE_CUBE_MAP, i3.skyboxTexture), n3.texParameteri(n3.TEXTURE_CUBE_MAP, n3.TEXTURE_WRAP_S, n3.CLAMP_TO_EDGE), n3.texParameteri(n3.TEXTURE_CUBE_MAP, n3.TEXTURE_WRAP_T, n3.CLAMP_TO_EDGE), n3.texParameteri(n3.TEXTURE_CUBE_MAP, n3.TEXTURE_MIN_FILTER, n3.LINEAR), n3.texParameteri(n3.TEXTURE_CUBE_MAP, n3.TEXTURE_MAG_FILTER, n3.LINEAR);
            for (let e22 = 0; e22 < 6; ++e22) n3.texImage2D(n3.TEXTURE_CUBE_MAP_POSITIVE_X + e22, 0, n3.RGBA, 32, 32, 0, n3.RGBA, n3.UNSIGNED_BYTE, null);
          }
          r3.bindFramebuffer.set(a3.framebuffer), r3.viewport.set([0, 0, 32, 32]);
          const l3 = i3.getCenter(t3, true), c3 = t3.getOrCreateProgram("skyboxCapture"), h22 = new Float64Array(16);
          e2.bx(h22), e2.e3(h22, h22, 0.5 * -Math.PI), vn(t3, i3, c3, h22, l3, 0), e2.bx(h22), e2.e3(h22, h22, 0.5 * Math.PI), vn(t3, i3, c3, h22, l3, 1), e2.bx(h22), e2.cG(h22, h22, 0.5 * -Math.PI), vn(t3, i3, c3, h22, l3, 2), e2.bx(h22), e2.cG(h22, h22, 0.5 * Math.PI), vn(t3, i3, c3, h22, l3, 3), e2.bx(h22), vn(t3, i3, c3, h22, l3, 4), e2.bx(h22), e2.e3(h22, h22, Math.PI), vn(t3, i3, c3, h22, l3, 5), r3.viewport.set([0, 0, t3.width, t3.height]);
        }(t22, o2), o2.markSkyboxValid(t22)) : "sky" === t22.renderPass && function(e22, t3, i3, o3, s3) {
          const r3 = e22.context, n3 = r3.gl, a3 = e22.transform, l3 = e22.getOrCreateProgram("skybox");
          r3.activeTexture.set(n3.TEXTURE0), n3.bindTexture(n3.TEXTURE_CUBE_MAP, t3.skyboxTexture);
          const c3 = /* @__PURE__ */ ((e3, t4, i4, o4, s4) => ({ u_matrix: e3, u_sun_direction: t4, u_cubemap: 0, u_opacity: o4, u_temporal_offset: s4 }))(a3.skyboxMatrix, t3.getCenter(e22, false), 0, o3, s3);
          e22.uploadCommonUniforms(r3, l3), l3.draw(e22, n3.TRIANGLES, i3, ji.disabled, e22.colorModeForRenderPass(), qi.backCW, c3, "skybox", t3.skyboxGeometry.vertexBuffer, t3.skyboxGeometry.indexBuffer, t3.skyboxGeometry.segment);
        }(t22, o2, l22, r22, c22) : "gradient" === a22 && "sky" === t22.renderPass && function(t3, i3, o3, s3, r3) {
          const n3 = t3.context, a3 = n3.gl, l3 = t3.transform, c3 = t3.getOrCreateProgram("skyboxGradient");
          i3.skyboxGeometry || (i3.skyboxGeometry = new gn(n3)), n3.activeTexture.set(a3.TEXTURE0);
          let h22 = i3.colorRampTexture;
          h22 || (h22 = i3.colorRampTexture = new e2.T(n3, i3.colorRamp, a3.RGBA8)), h22.bind(a3.LINEAR, a3.CLAMP_TO_EDGE);
          const d22 = ((t4, i4, o4, s4, r4) => ({ u_matrix: t4, u_color_ramp: 0, u_center_direction: i4, u_radius: e2.al(o4), u_opacity: s4, u_temporal_offset: r4 }))(l3.skyboxMatrix, i3.getCenter(t3, false), i3.paint.get("sky-gradient-radius"), s3, r3);
          t3.uploadCommonUniforms(n3, c3), c3.draw(t3, a3.TRIANGLES, o3, ji.disabled, t3.colorModeForRenderPass(), qi.backCW, d22, "skyboxGradient", i3.skyboxGeometry.vertexBuffer, i3.skyboxGeometry.indexBuffer, i3.skyboxGeometry.segment);
        }(t22, o2, l22, r22, c22);
      }, debug: function(t22, i22, o2, s2, r22, n22) {
        for (let a22 = 0; a22 < o2.length; a22++) if (r22) {
          const r3 = 1, l22 = 0.8, c22 = new e2.am(s2.r * l22, s2.g * l22, s2.b * l22, 1);
          hn(t22, i22, o2[a22], s2, -r3, -r3, n22), hn(t22, i22, o2[a22], s2, -r3, r3, n22), hn(t22, i22, o2[a22], s2, r3, r3, n22), hn(t22, i22, o2[a22], s2, r3, -r3, n22), hn(t22, i22, o2[a22], c22, 0, 0, n22);
        } else hn(t22, i22, o2[a22], s2, 0, 0, n22);
      }, custom: function(t22, i22, o2, s2) {
        const r22 = t22.context, n22 = o2.implementation;
        if (!t22.transform.projection.unsupportedLayers || !t22.transform.projection.unsupportedLayers.includes("custom") || t22.terrain && (t22.terrain.renderingToTexture || "offscreen" === t22.renderPass) && o2.isDraped(i22)) {
          if ("offscreen" === t22.renderPass) {
            const i3 = n22.prerender;
            if (i3) {
              if (t22.setCustomLayerDefaults(), r22.setColorMode(t22.colorModeForRenderPass()), "globe" === t22.transform.projection.name) {
                const o3 = t22.transform.pointMerc;
                i3.call(n22, r22.gl, t22.transform.customLayerMatrix(), t22.transform.getProjection(), t22.transform.globeToMercatorMatrix(), e2.ah(t22.transform.zoom), [o3.x, o3.y], t22.transform.pixelsPerMeterRatio);
              } else i3.call(n22, r22.gl, t22.transform.customLayerMatrix());
              r22.setDirty(), t22.setBaseState();
            }
          } else if ("translucent" === t22.renderPass) {
            if (t22.terrain && t22.terrain.renderingToTexture) {
              const e22 = n22.renderToTile;
              if (e22) {
                const i4 = s2[0].canonical, o3 = { x: i4.x + s2[0].wrap * (n22.wrapTileId ? 0 : 1 << i4.z), y: i4.y, z: i4.z };
                r22.setDepthMode(Ni.disabled), r22.setStencilMode(ji.disabled), r22.setColorMode(t22.colorModeForRenderPass()), t22.setCustomLayerDefaults(), e22.call(n22, r22.gl, o3), r22.setDirty(), t22.setBaseState();
              }
              return;
            }
            t22.setCustomLayerDefaults(), r22.setColorMode(t22.colorModeForRenderPass()), r22.setStencilMode(ji.disabled);
            const i3 = "3d" === n22.renderingMode ? new Ni(t22.context.gl.LEQUAL, Ni.ReadWrite, t22.depthRangeFor3D) : t22.depthModeForSublayer(0, Ni.ReadOnly);
            if (r22.setDepthMode(i3), "globe" === t22.transform.projection.name) {
              const i4 = t22.transform.pointMerc;
              n22.render(r22.gl, t22.transform.customLayerMatrix(), t22.transform.getProjection(), t22.transform.globeToMercatorMatrix(), e2.ah(t22.transform.zoom), [i4.x, i4.y], t22.transform.pixelsPerMeterRatio);
            } else n22.render(r22.gl, t22.transform.customLayerMatrix());
            r22.setDirty(), t22.setBaseState(), r22.bindFramebuffer.set(null);
          }
        } else e2.w("Custom layers are not yet supported with this projection. Use mercator or globe to enable usage of custom layers.");
      }, model: function(t22, i22, o2, s2) {
        if ("opaque" === t22.renderPass) return;
        const r22 = o2.paint.get("model-opacity").constantOr(1);
        if (0 === r22) return;
        const n22 = o2.paint.get("model-cast-shadows");
        if ("shadow" === t22.renderPass) {
          if (!n22) return;
          if (t22.terrain && r22 < 0.65 && o2._transitionablePaint._values["model-opacity"].value.expression instanceof e2.ab) return;
        }
        const a22 = t22.shadowRenderer, l22 = o2.paint.get("model-receive-shadows");
        a22 && (a22.useNormalOffset = true, l22 || (a22.enabled = false));
        const c22 = () => {
          a22 && (a22.useNormalOffset = true, l22 || (a22.enabled = true));
        }, h22 = i22.getSource();
        if ("light-beam" === t22.renderPass && "batched-model" !== h22.type) return;
        if ("vector" === h22.type || "geojson" === h22.type) return function(t3, i3, o3, s3, r3) {
          const n3 = t3.transform;
          if ("mercator" !== n3.projection.name) return void e2.w(`Drawing 3D models for ${n3.projection.name} projection is not yet implemented`);
          const a3 = n3.getFreeCameraOptions().position;
          if (!t3.modelManager) return;
          const l3 = t3.modelManager;
          o3.modelManager = l3;
          const c3 = t3.shadowRenderer;
          if (!o3._unevaluatedLayout._values.hasOwnProperty("model-id")) return;
          const h3 = o3._unevaluatedLayout._values["model-id"], d3 = Object.assign({}, o3.layout.get("model-id").parameters), u3 = t3.style.order.indexOf(o3.fqid);
          for (const _3 of s3) {
            const s4 = i3.getTile(_3).getBucket(o3);
            if (!s4 || s4.projection.name !== n3.projection.name) continue;
            const p3 = s4.getModelUris();
            p3 && !s4.modelsRequested && (l3.addModelsFromBucket(p3, r3), s4.modelsRequested = true);
            const f3 = Ln(_3, n3);
            d3.zoom = f3;
            const m3 = h3.possiblyEvaluate(d3);
            if (Dn(t3, s4, _3), An.shadowUniformsInitialized = false, An.useSingleShadowCascade = !!c3 && 0 === c3.getMaxCascadeForTile(_3.toUnwrapped()), "shadow" === t3.renderPass && c3) {
              if (1 === t3.currentShadowCascade && s4.isInsideFirstShadowMapFrustum) continue;
              const i4 = n3.calculatePosMatrix(_3.toUnwrapped(), n3.worldSize);
              if (An.tileMatrix.set(i4), An.shadowTileMatrix = Float32Array.from(c3.calculateShadowPassMatrixFromMatrix(i4)), An.aabb.min.fill(0), An.aabb.max[0] = An.aabb.max[1] = e2.aj, An.aabb.max[2] = 0, Mn(s4, An, t3, o3.scope)) continue;
            }
            const g3 = 1 << _3.canonical.z, v22 = [((a3.x - _3.wrap) * g3 - _3.canonical.x) * e2.aj, (a3.y * g3 - _3.canonical.y) * e2.aj, a3.z * g3 * e2.aj];
            t3.conflationActive && Object.keys(s4.instancesPerModel).length > 0 && t3.style.isLayerClipped(o3, i3.getSource()) && s4.updateReplacement(_3, t3.replacementSource, u3, r3) && (s4.uploaded = false, s4.upload(t3.context));
            for (let e22 in s4.instancesPerModel) {
              const i4 = s4.instancesPerModel[e22];
              i4.features.length > 0 && (e22 = m3.evaluate(i4.features[0].feature, {}));
              const n4 = l3.getModel(e22, r3);
              if (n4 || l3.hasURLBeenRequested(e22) || s4.modelUris.includes(e22) || (s4.modelUris.push(e22), s4.modelsRequested = false), n4 && n4.uploaded) for (const e3 of n4.nodes) Pn(t3, o3, e3, i4, v22, _3, An);
            }
          }
        }(t22, i22, o2, s2, "vector" === h22.type ? o2.scope : ""), void c22();
        if (!h22.loaded()) return;
        if ("batched-model" === h22.type) return function(t3, i3, o3, s3) {
          o3.resetLayerRenderingStats(t3);
          const r3 = t3.context, n3 = t3.transform, a3 = t3.style.fog, l3 = t3.shadowRenderer;
          if ("mercator" !== n3.projection.name) return void e2.w(`Drawing 3D landmark models for ${n3.projection.name} projection is not yet implemented`);
          const c3 = t3.transform.getFreeCameraOptions().position, h3 = e2.b$([], [c3.x, c3.y, c3.z], t3.transform.worldSize), d3 = e2.eb([], h3), u3 = e2.bx([]), _3 = e2.ec(n3.center.lat, n3.zoom), p3 = e2.bn([], [1, 1, 1 / _3]);
          e2.bo(u3, u3, d3);
          const f3 = o3.paint.get("model-opacity").constantOr(1), m3 = new Ni(r3.gl.LEQUAL, Ni.ReadWrite, t3.depthRangeFor3D), g3 = new Ni(r3.gl.LEQUAL, Ni.ReadOnly, t3.depthRangeFor3D), v22 = new e2.cV([1 / 0, 1 / 0, 1 / 0], [-1 / 0, -1 / 0, -1 / 0]), y22 = "shadow" === t3.renderPass, x22 = y22 && l3 ? l3.getCurrentCascadeFrustum() : n3.getFrustum(n3.scaleZoom(n3.worldSize)), b22 = o3.paint.get("model-front-cutoff"), w22 = b22[2] < 1, T2 = eo(t3, o3.paint.get("model-cutoff-fade-range")), E22 = o3.getLayerRenderingStats();
          (function(e22, t4, i4, o4) {
            const s4 = e22.terrain ? e22.terrain.exaggeration() : 0, r4 = e22.transform.zoom;
            for (const n4 of o4) {
              const o5 = t4.getTile(n4).getBucket(i4);
              o5 && (o5.setFilter(i4.filter), e22.conflationActive && o5.updateReplacement(n4, e22.replacementSource), o5.evaluateScale(e22, i4), e22.terrain && s4 > 0 && o5.elevationUpdate(e22.terrain, s4, n4, i4.source), o5.needsReEvaluation(e22, r4, i4) && o5.evaluate(i4));
            }
          })(t3, i3, o3, s3), function() {
            let c4, d4, S2;
            w22 ? (c4 = s3.length - 1, d4 = -1, S2 = -1) : (c4 = 0, d4 = s3.length, S2 = 1);
            const I2 = new Float64Array(16), C22 = e2.eg(), R22 = new e2.P(0, 0);
            for (let D22 = c4; D22 !== d4; D22 += S2) {
              const c5 = s3[D22], d5 = i3.getTile(c5).getBucket(o3);
              if (!d5 || !d5.uploaded) continue;
              let S3 = false;
              l3 && (S3 = 0 === l3.getMaxCascadeForTile(c5.toUnwrapped()));
              const A22 = n3.calculatePosMatrix(c5.toUnwrapped(), n3.worldSize), L22 = d5.modelTraits;
              !y22 && w22 && (e2.bi(I2, A22), e2.ad(C22, h3, I2), R22.x = C22[0], R22.y = C22[1]);
              const P22 = [];
              d5.setFilter(o3.filter);
              for (const i4 of d5.getNodesInfo()) {
                if (i4.hiddenByReplacement) continue;
                if (!i4.node.meshes) continue;
                const o4 = i4.node;
                let s4 = 0;
                t3.terrain && o4.elevation && (s4 = o4.elevation * t3.terrain.exaggeration());
                const r4 = (() => {
                  const t4 = i4.aabb;
                  return v22.min = [...t4.min], v22.max = [...t4.max], v22.min[2] += s4, v22.max[2] += s4, e2.ad(v22.min, v22.min, A22), e2.ad(v22.max, v22.max, A22), v22;
                })(), a4 = i4.evaluatedScale;
                if (a4[0] <= 1 && a4[1] <= 1 && a4[2] <= 1 && 0 === r4.intersects(x22)) continue;
                if (!y22 && w22) {
                  const t4 = 1 / 6;
                  i4.cameraCollisionOpacity = h3[0] > r4.min[0] && h3[0] < r4.max[0] && h3[1] > r4.min[1] && h3[1] < r4.max[1] && h3[2] * _3 < r4.max[2] && o4.footprint && e2.bS(R22, o4.footprint) ? Math.max(i4.cameraCollisionOpacity - t4, 0) : Math.min(1, i4.cameraCollisionOpacity + t4);
                }
                const l4 = [...A22], c6 = o4.anchor ? o4.anchor[0] : 0, d6 = o4.anchor ? o4.anchor[1] : 0;
                e2.bo(l4, l4, [c6 * (a4[0] - 1), d6 * (a4[1] - 1), s4]), e2.ci(a4, e2.eh) || e2.cE(l4, l4, a4);
                const u4 = e2.az([], l4, o4.matrix), p4 = e2.az([], n3.expandedFarZProjMatrix, u4), m4 = e2.az([], n3.expandedFarZProjMatrix, l4), g4 = e2.aA([], [c6, d6, s4, 1], p4)[2];
                o4.hidden = false;
                let E3 = f3;
                y22 || (w22 && (E3 *= i4.cameraCollisionOpacity, E3 *= Fn(l4, n3, i4.aabb, b22)), E3 *= On(T2, g4)), 0 !== E3 ? P22.push({ nodeInfo: i4, depth: g4, opacity: E3, wvpForNode: p4, wvpForTile: m4, nodeModelMatrix: u4, tileModelMatrix: l4 }) : o4.hidden = true;
              }
              y22 || P22.sort((e22, t4) => !w22 || 1 === e22.opacity && 1 === t4.opacity ? e22.depth < t4.depth ? -1 : 1 : 1 === e22.opacity ? -1 : 1 === t4.opacity ? 1 : e22.depth > t4.depth ? -1 : 1);
              for (const i4 of P22) {
                const s4 = i4.nodeInfo, c6 = s4.node;
                let h4 = e2.az([], p3, i4.tileModelMatrix);
                e2.az(h4, u3, h4);
                const d6 = e2.bi([], h4);
                e2.ee(d6, d6), e2.cE(d6, d6, zn), h4 = e2.az(h4, h4, c6.matrix);
                const _4 = "light-beam" === t3.renderPass, f4 = "none" === o3.paint.get("model-color-use-theme").constantOr("default"), v3 = L22 & e2.em.HasMapboxMeshFeatures, x3 = v3 ? 0 : s4.evaluatedRMEA[0][2];
                for (let e22 = 0; e22 < c6.meshes.length; ++e22) {
                  const u4 = c6.meshes[e22], p4 = e22 === c6.lightMeshIndex;
                  let b3 = i4.wvpForNode;
                  if (p4) {
                    if (!_4 && !t3.terrain && t3.shadowRenderer) {
                      t3.currentLayer < t3.firstLightBeamLayer && (t3.firstLightBeamLayer = t3.currentLayer);
                      continue;
                    }
                    b3 = i4.wvpForTile;
                  } else if (_4) continue;
                  const w3 = { defines: [] }, T3 = [];
                  if (!y22 && l3 && (l3.useNormalOffset = !!u4.normalBuffer), Sn(w3.defines, T3, u4, t3, f4 ? null : o3.lut), v3 || w3.defines.push("DIFFUSE_SHADED"), S3 && w3.defines.push("SHADOWS_SINGLE_CASCADE"), E22 && (y22 ? E22.numRenderedVerticesInShadowPass += u4.vertexArray.length : E22.numRenderedVerticesInTransparentPass += u4.vertexArray.length), y22) {
                    Rn(u4, i4.nodeModelMatrix, t3, o3);
                    continue;
                  }
                  let I3 = null;
                  if (a3) {
                    const e3 = En(i4.nodeModelMatrix, t3.transform);
                    if (I3 = new Float32Array(e3), "globe" !== n3.projection.name) {
                      const t4 = u4.aabb.min, i5 = u4.aabb.max, [o4, s5] = a3.getOpacityForBounds(e3, t4[0], t4[1], i5[0], i5[1]);
                      w3.overrideFog = o4 >= Fe || s5 >= Fe;
                    }
                  }
                  const C3 = u4.material;
                  let R3;
                  C3.occlusionTexture && C3.occlusionTexture.offsetScale && (R3 = C3.occlusionTexture.offsetScale, w3.defines.push("OCCLUSION_TEXTURE_TRANSFORM"));
                  const D3 = t3.getOrCreateProgram("model", w3);
                  !y22 && l3 && l3.setupShadowsFromMatrix(i4.tileModelMatrix, D3, l3.useNormalOffset), t3.uploadCommonUniforms(r3, D3, null, I3);
                  const A3 = C3.pbrMetallicRoughness;
                  A3.metallicFactor = 0.9, A3.roughnessFactor = 0.5;
                  const L3 = Er(new Float32Array(b3), new Float32Array(h4), new Float32Array(d6), new Float32Array(c6.matrix), t3, i4.opacity, A3.baseColorFactor.toRenderColor(null), C3.emissiveFactor, A3.metallicFactor, A3.roughnessFactor, C3, x3, o3, [0, 0, 0], R3);
                  !p4 && (s4.hasTranslucentParts || i4.opacity < 1) && D3.draw(t3, r3.gl.TRIANGLES, m3, ji.disabled, ki.disabled, qi.backCCW, L3, o3.id, u4.vertexBuffer, u4.indexBuffer, u4.segments, o3.paint, t3.transform.zoom, void 0, T3), D3.draw(t3, r3.gl.TRIANGLES, p4 ? g3 : m3, ji.disabled, p4 || i4.opacity < 1 || s4.hasTranslucentParts ? ki.alphaBlended : ki.unblended, qi.backCCW, L3, o3.id, u4.vertexBuffer, u4.indexBuffer, u4.segments, o3.paint, t3.transform.zoom, void 0, T3);
                }
              }
            }
          }();
        }(t22, i22, o2, s2), void c22();
        if ("model" !== h22.type) return;
        const d22 = h22.getModels(), u22 = [], _22 = t22.transform.getFreeCameraOptions().position, p22 = e2.b$([], [_22.x, _22.y, _22.z], t22.transform.worldSize);
        e2.eb(p22, p22);
        const f22 = [], m22 = [];
        let g22 = 0;
        for (const i3 of d22) {
          const s3 = o2.paint.get("model-rotation").constantOr(null), r3 = o2.paint.get("model-scale").constantOr(null), n3 = o2.paint.get("model-translation").constantOr(null);
          i3.computeModelMatrix(t22, s3, r3, n3, true, true, false);
          const a3 = e2.bx([]), l3 = e2.ec(i3.position.lat, t22.transform.zoom), c3 = e2.bn([], [1, 1, 1 / l3]);
          e2.bo(a3, a3, p22), u22.push({ zScaleMatrix: c3, negCameraPosMatrix: a3 });
          for (const e22 of i3.nodes) Cn(t22.transform, e22, i3.matrix, t22.transform.expandedFarZProjMatrix, g22, f22, m22);
          g22++;
        }
        if (f22.sort((e22, t3) => t3.depth - e22.depth), "shadow" !== t22.renderPass) {
          if (1 === r22) for (const e22 of m22) In(e22, t22, o2, u22[e22.modelIndex], ji.disabled, t22.colorModeForRenderPass());
          else {
            for (const e22 of m22) In(e22, t22, o2, u22[e22.modelIndex], ji.disabled, ki.disabled);
            for (const e22 of m22) In(e22, t22, o2, u22[e22.modelIndex], t22.stencilModeFor3D(), t22.colorModeForRenderPass());
            t22.resetStencilClippingMasks();
          }
          for (const e22 of f22) In(e22, t22, o2, u22[e22.modelIndex], ji.disabled, t22.colorModeForRenderPass());
          c22();
        } else {
          for (const e22 of m22) Rn(e22.mesh, e22.nodeModelMatrix, t22, o2);
          for (const e22 of f22) Rn(e22.mesh, e22.nodeModelMatrix, t22, o2);
          c22();
        }
      } }, ea = { line: function(e22, t22, i22) {
        if (e22.hasElevatedBuckets = false, e22.hasNonElevatedBuckets = false, void 0 !== e22._unevaluatedLayout.getValue("line-elevation-reference") || void 0 !== e22._unevaluatedLayout.getValue("line-z-offset")) {
          if (t22) {
            const i3 = t22.getVisibleCoordinates();
            for (const o2 of i3) {
              const i4 = t22.getTile(o2).getBucket(e22);
              if (i4 && ("none" !== i4.elevationType ? e22.hasElevatedBuckets = true : e22.hasNonElevatedBuckets = true, e22.hasElevatedBuckets && e22.hasNonElevatedBuckets)) break;
            }
          }
        } else e22.hasNonElevatedBuckets = true;
      }, model: function(e22, t22, i22) {
        const o2 = t22.getSource();
        if (!o2.loaded()) return;
        if ("vector" === o2.type || "geojson" === o2.type) return void (i22.modelManager && i22.modelManager.upload(i22, "vector" === o2.type ? e22.scope : ""));
        if ("batched-model" === o2.type) return;
        if ("model" !== o2.type) return;
        const s2 = o2.getModels();
        for (const e3 of s2) e3.upload(i22.context);
      }, raster: function(e22, t22, i22) {
        const o2 = t22.getSource();
        if (!(o2 instanceof st && o2.loaded())) return;
        const s2 = e22.sourceLayer || o2.rasterLayerIds && o2.rasterLayerIds[0];
        if (!s2) return;
        const r22 = e22.paint.get("raster-array-band") || o2.getInitialBand(s2);
        if (null == r22) return;
        const n22 = t22.getIds().map((e3) => t22.getTileByID(e3));
        for (const e3 of n22) e3.updateNeeded(s2, r22) && o2.prepareTile(e3, s2, r22);
      }, "raster-particle": function(e22, t22, i22) {
        const o2 = t22.getSource();
        if (!(o2 instanceof st && o2.loaded())) return;
        const s2 = e22.sourceLayer || o2.rasterLayerIds && o2.rasterLayerIds[0];
        if (!s2) return;
        const r22 = e22.paint.get("raster-particle-array-band") || o2.getInitialBand(s2);
        if (null == r22) return;
        const n22 = t22.getIds().map((e3) => t22.getTileByID(e3));
        for (const e3 of n22) e3.updateNeeded(s2, r22) && o2.prepareTile(e3, s2, r22);
      } }, ta = { fill: jr };
      class ia {
        constructor(t22, i22, o2, s2, r22) {
          this.context = new Lr(t22, i22), this.transform = o2, this._tileTextures = {}, this.frameCopies = [], this.loadTimeStamps = [], this.tp = r22, this._timeStamp = e2.q.now(), this._averageFPS = 0, this._fpsHistory = [], this._dt = 0, this._debugParams = { forceEnablePrecipitation: false, showTerrainProxyTiles: false, fpsWindow: 30, continousRedraw: false, enabledLayers: {} };
          const n22 = ["fill", "line", "symbol", "circle", "heatmap", "fill-extrusion", "raster", "raster-particle", "hillshade", "model", "background", "sky"];
          for (const e22 of n22) this._debugParams.enabledLayers[e22] = true;
          r22.registerParameter(this._debugParams, ["Terrain"], "showTerrainProxyTiles", {}, () => {
            this.style.map.triggerRepaint();
          }), r22.registerParameter(this._debugParams, ["Precipitation"], "forceEnablePrecipitation"), r22.registerParameter(this._debugParams, ["FPS"], "fpsWindow", { min: 1, max: 100, step: 1 }), r22.registerBinding(this._debugParams, ["FPS"], "continousRedraw", { readonly: true, label: "continuous redraw" }), r22.registerBinding(this, ["FPS"], "_averageFPS", { readonly: true, label: "value" }), r22.registerBinding(this, ["FPS"], "_averageFPS", { readonly: true, label: "graph", view: "graph", min: 0, max: 200 });
          for (const e22 of n22) r22.registerParameter(this._debugParams.enabledLayers, ["Debug", "Layers"], e22);
          this.occlusionParams = new Nn(r22), this.setup(), this.numSublayers = It2.maxUnderzooming + It2.maxOverzooming + 1, this.depthEpsilon = 1 / Math.pow(2, 16), this.deferredRenderGpuTimeQueries = [], this.gpuTimers = {}, this.frameCounter = 0, this._backgroundTiles = {}, this.conflationActive = false, this.replacementSource = new e2.et(), this.longestCutoffRange = 0, this.minCutoffZoom = 0, this._fogVisible = false, this._cachedTileFogOpacities = {}, this._shadowRenderer = new so(this), this._wireframeDebugCache = new kn(), this.renderDefaultNorthPole = true, this.renderDefaultSouthPole = true, this.layersWithOcclusionOpacity = [];
          const a22 = new e2.r({ width: 1, height: 1 }, Uint8Array.of(0, 0, 0, 0));
          this.emptyDepthTexture = new e2.T(this.context, a22, t22.RGBA8), this._clippingActiveLastFrame = false, this.scaleFactor = s2;
        }
        updateTerrain(e22, t22) {
          const i22 = !!e22 && !!e22.terrain && this.transform.projection.supportsTerrain;
          if (!(i22 || this._terrain && this._terrain.enabled)) return;
          this._terrain || (this._terrain = new qs(this, e22));
          const o2 = this._terrain;
          this.transform.elevation = i22 ? o2 : null, o2.update(e22, this.transform, t22), this.transform.elevation && !o2.enabled && (this.transform.elevation = null);
        }
        _updateFog(e22) {
          const t22 = e22.fog;
          if (!t22 || "globe" === this.transform.projection.name || t22.getOpacity(this.transform.pitch) < 1 || t22.properties.get("horizon-blend") < 0.03) return void (this.transform.fogCullDistSq = null);
          const [i22, o2] = t22.getFovAdjustedRange(this.transform._fov);
          if (i22 > o2) return void (this.transform.fogCullDistSq = null);
          const s2 = i22 + 0.78 * (o2 - i22);
          this.transform.fogCullDistSq = s2 * s2;
        }
        get terrain() {
          return this.transform._terrainEnabled() && this._terrain && this._terrain.enabled || this._forceTerrainMode ? this._terrain : null;
        }
        get forceTerrainMode() {
          return this._forceTerrainMode;
        }
        set forceTerrainMode(e22) {
          e22 && !this._terrain && (this._terrain = new qs(this, this.style)), this._forceTerrainMode = e22;
        }
        get shadowRenderer() {
          return this._shadowRenderer && this._shadowRenderer.enabled ? this._shadowRenderer : null;
        }
        get wireframeDebugCache() {
          return this._wireframeDebugCache;
        }
        resize(t22, i22) {
          if (this.width = t22 * e2.q.devicePixelRatio, this.height = i22 * e2.q.devicePixelRatio, this.context.viewport.set([0, 0, this.width, this.height]), this.style) for (const e22 of this.style.order) this.style._mergedLayers[e22].resize();
        }
        setup() {
          const t22 = this.context, i22 = new e2.ba();
          i22.emplaceBack(0, 0), i22.emplaceBack(e2.aj, 0), i22.emplaceBack(0, e2.aj), i22.emplaceBack(e2.aj, e2.aj), this.tileExtentBuffer = t22.createVertexBuffer(i22, e2.bc.members), this.tileExtentSegments = e2.bd.simpleSegment(0, 0, 4, 2);
          const o2 = new e2.ba();
          o2.emplaceBack(0, 0), o2.emplaceBack(e2.aj, 0), o2.emplaceBack(0, e2.aj), o2.emplaceBack(e2.aj, e2.aj), this.debugBuffer = t22.createVertexBuffer(o2, e2.bc.members), this.debugSegments = e2.bd.simpleSegment(0, 0, 4, 5);
          const s2 = new e2.ba();
          s2.emplaceBack(-1, -1), s2.emplaceBack(1, -1), s2.emplaceBack(-1, 1), s2.emplaceBack(1, 1), this.viewportBuffer = t22.createVertexBuffer(s2, e2.bc.members), this.viewportSegments = e2.bd.simpleSegment(0, 0, 4, 2);
          const r22 = new e2.aZ();
          r22.emplaceBack(0, 0, 0, 0), r22.emplaceBack(e2.aj, 0, e2.aj, 0), r22.emplaceBack(0, e2.aj, 0, e2.aj), r22.emplaceBack(e2.aj, e2.aj, e2.aj, e2.aj), this.mercatorBoundsBuffer = t22.createVertexBuffer(r22, e2.bf.members), this.mercatorBoundsSegments = e2.bd.simpleSegment(0, 0, 4, 2);
          const n22 = new e2.a_();
          n22.emplaceBack(0, 1, 2), n22.emplaceBack(2, 1, 3), this.quadTriangleIndexBuffer = t22.createIndexBuffer(n22);
          const a22 = new e2.bb();
          for (const e22 of [0, 1, 3, 2, 0]) a22.emplaceBack(e22);
          this.debugIndexBuffer = t22.createIndexBuffer(a22), this.emptyTexture = new e2.T(t22, new e2.r({ width: 1, height: 1 }, Uint8Array.of(0, 0, 0, 0)), t22.gl.RGBA8), this.identityMat = e2.bz();
          const l22 = this.context.gl;
          this.stencilClearMode = new ji({ func: l22.ALWAYS, mask: 0 }, 0, 255, l22.ZERO, l22.ZERO, l22.ZERO), this.loadTimeStamps.push(performance.now());
        }
        getMercatorTileBoundsBuffers() {
          return { tileBoundsBuffer: this.mercatorBoundsBuffer, tileBoundsIndexBuffer: this.quadTriangleIndexBuffer, tileBoundsSegments: this.mercatorBoundsSegments };
        }
        getTileBoundsBuffers(e22) {
          return e22._makeTileBoundsBuffers(this.context, this.transform.projection), e22._tileBoundsBuffer ? { tileBoundsBuffer: e22._tileBoundsBuffer, tileBoundsIndexBuffer: e22._tileBoundsIndexBuffer, tileBoundsSegments: e22._tileBoundsSegments } : this.getMercatorTileBoundsBuffers();
        }
        clearStencil() {
          const e22 = this.context.gl;
          this.nextStencilID = 1, this.currentStencilSource = void 0, this._tileClippingMaskIDs = {}, this.getOrCreateProgram("clippingMask").draw(this, e22.TRIANGLES, Ni.disabled, this.stencilClearMode, ki.disabled, qi.disabled, Ns(this.identityMat), "$clipping", this.viewportBuffer, this.quadTriangleIndexBuffer, this.viewportSegments);
        }
        resetStencilClippingMasks() {
          this.terrain || (this.currentStencilSource = void 0, this._tileClippingMaskIDs = {});
        }
        _renderTileClippingMasks(e22, t22, i22) {
          if (!t22 || this.currentStencilSource === t22.id || !e22.isTileClipped() || !i22 || 0 === i22.length) return;
          if (this._tileClippingMaskIDs && !this.terrain) {
            let e3 = false;
            for (const t3 of i22) if (void 0 === this._tileClippingMaskIDs[t3.key]) {
              e3 = true;
              break;
            }
            if (!e3) return;
          }
          this.currentStencilSource = t22.id;
          const o2 = this.context, s2 = o2.gl;
          this.nextStencilID + i22.length > 256 && this.clearStencil(), o2.setColorMode(ki.disabled), o2.setDepthMode(Ni.disabled);
          const r22 = this.getOrCreateProgram("clippingMask");
          this._tileClippingMaskIDs = {};
          for (const e3 of i22) {
            const i3 = t22.getTile(e3), o3 = this._tileClippingMaskIDs[e3.key] = this.nextStencilID++, { tileBoundsBuffer: n22, tileBoundsIndexBuffer: a22, tileBoundsSegments: l22 } = this.getTileBoundsBuffers(i3);
            r22.draw(this, s2.TRIANGLES, Ni.disabled, new ji({ func: s2.ALWAYS, mask: 0 }, o3, 255, s2.KEEP, s2.KEEP, s2.REPLACE), ki.disabled, qi.disabled, Ns(e3.projMatrix), "$clipping", n22, a22, l22);
          }
        }
        stencilModeFor3D() {
          this.currentStencilSource = void 0, this.nextStencilID + 1 > 256 && this.clearStencil();
          const e22 = this.nextStencilID++, t22 = this.context.gl;
          return new ji({ func: t22.NOTEQUAL, mask: 255 }, e22, 255, t22.KEEP, t22.KEEP, t22.REPLACE);
        }
        stencilModeForClipping(e22) {
          if (this.terrain) return this.terrain.stencilModeForRTTOverlap(e22);
          const t22 = this.context.gl;
          return new ji({ func: t22.EQUAL, mask: 255 }, this._tileClippingMaskIDs[e22.key], 0, t22.KEEP, t22.KEEP, t22.REPLACE);
        }
        stencilConfigForOverlap(e22) {
          const t22 = this.context.gl, i22 = e22.sort((e3, t3) => t3.overscaledZ - e3.overscaledZ), o2 = i22[i22.length - 1].overscaledZ, s2 = i22[0].overscaledZ - o2 + 1;
          if (s2 > 1) {
            this.currentStencilSource = void 0, this.nextStencilID + s2 > 256 && this.clearStencil();
            const e3 = {};
            for (let i3 = 0; i3 < s2; i3++) e3[i3 + o2] = new ji({ func: t22.GEQUAL, mask: 255 }, i3 + this.nextStencilID, 255, t22.KEEP, t22.KEEP, t22.REPLACE);
            return this.nextStencilID += s2, [e3, i22];
          }
          return [{ [o2]: ji.disabled }, i22];
        }
        colorModeForRenderPass() {
          const t22 = this.context.gl;
          if (this._showOverdrawInspector) {
            const i22 = 1 / 8;
            return new ki([t22.CONSTANT_COLOR, t22.ONE, t22.CONSTANT_COLOR, t22.ONE], new e2.am(i22, i22, i22, 0), [true, true, true, true]);
          }
          return "opaque" === this.renderPass ? ki.unblended : ki.alphaBlended;
        }
        colorModeForDrapableLayerRenderPass(t22) {
          const i22 = this.context.gl;
          return (() => this.style && this.style.enable3dLights() && this.terrain && this.terrain.renderingToTexture)() && "translucent" === this.renderPass ? new ki([i22.ONE, i22.ONE_MINUS_SRC_ALPHA, i22.CONSTANT_ALPHA, i22.ONE_MINUS_SRC_ALPHA], new e2.am(0, 0, 0, void 0 === t22 ? 0 : t22), [true, true, true, true]) : this.colorModeForRenderPass();
        }
        depthModeForSublayer(e22, t22, i22, o2 = false) {
          if (this.depthOcclusion) return new Ni(this.context.gl.GREATER, Ni.ReadOnly, this.depthRangeFor3D);
          if (!this.opaquePassEnabledForLayer() && !o2) return Ni.disabled;
          const s2 = 1 - ((1 + this.currentLayer) * this.numSublayers + e22) * this.depthEpsilon;
          return new Ni(i22 || this.context.gl.LEQUAL, t22, [s2, s2]);
        }
        opaquePassEnabledForLayer() {
          return this.currentLayer < this.opaquePassCutoff;
        }
        blitDepth() {
          const t22 = this.context.gl, i22 = Math.ceil(this.width), o2 = Math.ceil(this.height), s2 = this.context.bindFramebuffer.get(), r22 = t22.getParameter(t22.TEXTURE_BINDING_2D);
          this.depthFBO && this.depthFBO.width === i22 && this.depthFBO.height === o2 || (this.depthFBO && (this.depthFBO.destroy(), this.depthFBO = void 0, this.depthTexture = void 0), 0 !== i22 && 0 !== o2 && (this.depthFBO = new Ar(this.context, i22, o2, false, "texture"), this.depthTexture = new e2.T(this.context, { width: i22, height: o2, data: null }, t22.DEPTH24_STENCIL8), this.depthFBO.depthAttachment.set(this.depthTexture.texture))), this.context.bindFramebuffer.set(s2), t22.bindTexture(t22.TEXTURE_2D, r22), this.depthFBO && (t22.bindFramebuffer(t22.READ_FRAMEBUFFER, null), t22.bindFramebuffer(t22.DRAW_FRAMEBUFFER, this.depthFBO.framebuffer), t22.blitFramebuffer(0, 0, i22, o2, 0, 0, i22, o2, t22.DEPTH_BUFFER_BIT, t22.NEAREST), t22.bindFramebuffer(t22.FRAMEBUFFER, this.context.bindFramebuffer.current));
        }
        updateAverageFPS() {
          this._fpsHistory.push(0 === this._dt ? 0 : 1e3 / this._dt), this._fpsHistory.length > this._debugParams.fpsWindow && this._fpsHistory.splice(0, this._fpsHistory.length - this._debugParams.fpsWindow), this._averageFPS = Math.round(this._fpsHistory.reduce((e22, t22) => e22 + t22 / this._fpsHistory.length, 0));
        }
        render(t22, i22) {
          const o2 = e2.q.now();
          this._dt = o2 - this._timeStamp, this._timeStamp = o2, this._wireframeDebugCache.update(this.frameCounter), this._debugParams.continousRedraw = t22.map.repaint, this.style = t22, this.options = i22;
          const s2 = this.style._mergedLayers, r22 = !(!this.terrain || !this.terrain.enabled), n22 = () => this.style._getOrder(r22).filter((e22) => {
            const t3 = s2[e22];
            return !(t3.type in this._debugParams.enabledLayers) || this._debugParams.enabledLayers[t3.type];
          });
          let a22 = n22(), l22 = false, c22 = false;
          for (const e22 of a22) {
            const t3 = s2[e22];
            "circle" === t3.type && (l22 = true), "symbol" === t3.type && (t3.hasInitialOcclusionOpacityProperties ? c22 = true : l22 = true);
          }
          let h22 = a22.map((e22) => s2[e22]);
          const d22 = this.style._mergedSourceCaches;
          this.imageManager = t22.imageManager, this.modelManager = t22.modelManager, this.symbolFadeChange = t22.placement.symbolFadeChange(e2.q.now()), this.imageManager.beginFrame();
          let u22 = 0, _22 = false;
          for (const e22 in d22) {
            const t3 = d22[e22];
            t3.used && (t3.prepare(this.context), t3.getSource().usedInConflation && ++u22);
          }
          let p22 = false;
          for (const e22 of h22) e22.isHidden(this.transform.zoom) || ("clip" === e22.type && (p22 = true), this.prepareLayer(e22));
          const f22 = {}, m22 = {}, g22 = {}, v22 = {}, y22 = {};
          for (const e22 in d22) {
            const t3 = d22[e22];
            f22[e22] = t3.getVisibleCoordinates(), m22[e22] = f22[e22].slice().reverse(), g22[e22] = t3.getVisibleCoordinates(true).reverse(), v22[e22] = t3.getShadowCasterCoordinates(), y22[e22] = t3.sortCoordinatesByDistance(f22[e22]);
          }
          const x22 = (e22) => {
            const t3 = this.style.getLayerSourceCache(e22);
            return t3 && t3.used ? t3.getSource() : null;
          };
          if (u22 || p22 || this._clippingActiveLastFrame) {
            const t3 = [], i3 = [];
            let o3 = 0;
            for (const e22 of h22) this.isSourceForClippingOrConflation(e22, x22(e22)) && (t3.push(e22), i3.push(o3)), o3++;
            if (t3 && (p22 || t3.length > 1) || this._clippingActiveLastFrame) {
              p22 = false;
              const o4 = [];
              for (let s3 = 0; s3 < t3.length; s3++) {
                const r3 = t3[s3], n3 = i3[s3], a3 = this.style.getLayerSourceCache(r3);
                if (!a3 || !a3.used || !a3.getSource().usedInConflation && "clip" !== r3.type) continue;
                let l3 = e2.ev, c3 = e2.bQ.None;
                const h3 = [];
                let d3 = true;
                if ("clip" === r3.type) {
                  l3 = n3;
                  for (const t4 of r3.layout.get("clip-layer-types")) c3 |= "model" === t4 ? e2.bQ.Model : "symbol" === t4 ? e2.bQ.Symbol : e2.bQ.FillExtrusion;
                  for (const e22 of r3.layout.get("clip-layer-scope")) h3.push(e22);
                  r3.isHidden(this.transform.zoom) ? d3 = false : p22 = true;
                }
                d3 && o4.push({ layer: r3.fqid, cache: a3, order: l3, clipMask: c3, clipScope: h3 });
              }
              this.replacementSource.setSources(o4), _22 = true;
            }
          }
          this._clippingActiveLastFrame = p22, _22 || this.replacementSource.clear(), this.conflationActive = _22, this.minCutoffZoom = 0, this.longestCutoffRange = 0, this.opaquePassCutoff = 1 / 0, this._lastOcclusionLayer = -1, this.layersWithOcclusionOpacity = [];
          for (let e22 = 0; e22 < h22.length; e22++) {
            const t3 = h22[e22], i3 = t3.cutoffRange();
            if (this.longestCutoffRange = Math.max(i3, this.longestCutoffRange), i3 > 0) {
              const e3 = x22(t3);
              e3 && (this.minCutoffZoom = Math.max(e3.minzoom, this.minCutoffZoom)), t3.minzoom && (this.minCutoffZoom = Math.max(t3.minzoom, this.minCutoffZoom));
            }
            t3.is3D(r22) && (this.opaquePassCutoff === 1 / 0 && (this.opaquePassCutoff = e22), this._lastOcclusionLayer = e22);
          }
          const b22 = this.style && this.style.fog;
          b22 ? (this._fogVisible = 0 !== b22.getOpacity(this.transform.pitch), this._fogVisible && "globe" !== this.transform.projection.name && (this._fogVisible = b22.isVisibleOnFrustum(this.transform.cameraFrustum))) : this._fogVisible = false, this._cachedTileFogOpacities = {}, this.terrain && (this.terrain.updateTileBinding(g22), this.opaquePassCutoff = 0, a22 = n22(), h22 = a22.map((e22) => s2[e22]));
          const w22 = this._shadowRenderer;
          if (w22) {
            w22.updateShadowParameters(this.transform, this.style.directionalLight);
            for (const e22 in d22) for (const t3 of f22[e22]) {
              let e3 = { min: 0, max: 0 };
              this.terrain && (e3 = this.terrain.getMinMaxForTile(t3) || e3), w22.addShadowReceiver(t3.toUnwrapped(), e3.min, e3.max);
            }
          }
          "globe" !== this.transform.projection.name || this.globeSharedBuffers || (this.globeSharedBuffers = new e2.eu(this.context)), this.style.fog && this.transform.projection.supportsFog ? (this._atmosphere || (this._atmosphere = new Tn(this)), this._atmosphere.update(this)) : this._atmosphere && (this._atmosphere.destroy(), this._atmosphere = void 0);
          const T2 = this._debugParams.forceEnablePrecipitation || !(!this.style || !this.style.snow), E22 = this._debugParams.forceEnablePrecipitation || !(!this.style || !this.style.rain);
          if (T2 && !this._snow && (this._snow = new Jn(this)), !T2 && this._snow && (this._snow.destroy(), delete this._snow), E22 && !this._rain && (this._rain = new Yn(this)), !E22 && this._rain && (this._rain.destroy(), delete this._rain), this._snow && this._snow.update(this), this._rain && this._rain.update(this), !U2.has(this.context.gl)) return;
          this.renderPass = "offscreen";
          for (const e22 of h22) {
            const i3 = t22.getLayerSourceCache(e22);
            if (!e22.hasOffscreenPass() || e22.isHidden(this.transform.zoom)) continue;
            const o3 = i3 ? m22[i3.id] : void 0;
            ("custom" === e22.type || "raster" === e22.type || "raster-particle" === e22.type || e22.isSky() || o3 && o3.length) && this.renderLayer(this, i3, e22, o3);
          }
          this.depthRangeFor3D = [0, 1 - (h22.length + 2) * this.numSublayers * this.depthEpsilon], this._shadowRenderer && (this.renderPass = "shadow", this._shadowRenderer.drawShadowPass(this.style, v22)), this.context.bindFramebuffer.set(null), this.context.viewport.set([0, 0, this.width, this.height]);
          const S2 = "globe" === this.transform.projection.name || this.transform.isHorizonVisible(), I2 = (() => {
            if (i22.showOverdrawInspector) return e2.am.black;
            const t3 = this.style.fog;
            if (t3 && this.transform.projection.supportsFog) {
              const i3 = this.style.getLut(t3.scope);
              if (!S2) {
                const o3 = "none" === t3.properties.get("color-use-theme"), s3 = t3.properties.get("color").toRenderColor(o3 ? null : i3).toArray01();
                return new e2.am(...s3);
              }
              if (S2) {
                const o3 = "none" === t3.properties.get("space-color-use-theme"), s3 = t3.properties.get("space-color").toRenderColor(o3 ? null : i3).toArray01();
                return new e2.am(...s3);
              }
            }
            return e2.am.transparent;
          })();
          if (this.context.clear({ color: I2, depth: 1 }), this.clearStencil(), this._showOverdrawInspector = i22.showOverdrawInspector, this.renderPass = "opaque", this.style.fog && this.transform.projection.supportsFog && this._atmosphere && !this._showOverdrawInspector && S2 && this._atmosphere.drawStars(this, this.style.fog), !this.terrain) for (this.currentLayer = a22.length - 1; this.currentLayer >= 0; this.currentLayer--) {
            const e22 = h22[this.currentLayer], i3 = t22.getLayerSourceCache(e22);
            if (e22.isSky()) continue;
            const o3 = i3 ? (e22.is3D(r22) ? y22 : m22)[i3.id] : void 0;
            this._renderTileClippingMasks(e22, i3, o3), this.renderLayer(this, i3, e22, o3);
          }
          if (this.style.fog && this.transform.projection.supportsFog && this._atmosphere && !this._showOverdrawInspector && S2 && this._atmosphere.drawAtmosphereGlow(this, this.style.fog), this.renderPass = "sky", (!this._atmosphere || e2.ah(this.transform.zoom) > 0) && ("globe" === this.transform.projection.name || this.transform.isHorizonVisible())) for (this.currentLayer = 0; this.currentLayer < a22.length; this.currentLayer++) {
            const e22 = h22[this.currentLayer], i3 = t22.getLayerSourceCache(e22);
            e22.isSky() && this.renderLayer(this, i3, e22, i3 ? m22[i3.id] : void 0);
          }
          function C22(e22, t3) {
            let i3;
            return t3 && (i3 = ("symbol" === e22.type ? g22 : e22.is3D(r22) ? y22 : m22)[t3.id]), i3;
          }
          if (this.renderPass = "translucent", "globe" === this.transform.projection.name) {
            for (this.renderElevatedRasterBackface = true, this.currentLayer = 0; this.currentLayer < a22.length; ) {
              const e22 = h22[this.currentLayer];
              if ("raster" === e22.type || "raster-particle" === e22.type) {
                const i3 = t22.getLayerSourceCache(e22);
                this.renderLayer(this, i3, e22, C22(e22, i3));
              }
              ++this.currentLayer;
            }
            this.renderElevatedRasterBackface = false;
          }
          this.currentLayer = 0, this.firstLightBeamLayer = Number.MAX_SAFE_INTEGER;
          let R22 = 0;
          w22 && (R22 = w22.getShadowCastingLayerCount());
          let D22 = false, A22 = -1;
          for (let e22 = 0; e22 < a22.length; ++e22) {
            const t3 = h22[e22];
            t3.isHidden(this.transform.zoom) || t3.is3D(r22) && (A22 = e22);
          }
          c22 && -1 === A22 && (l22 = true);
          let L22 = false;
          for (; this.currentLayer < a22.length; ) {
            const e22 = h22[this.currentLayer], i3 = t22.getLayerSourceCache(e22);
            if (e22.isSky()) ++this.currentLayer;
            else if (this.terrain && this.style.isLayerDraped(e22)) {
              if (e22.isHidden(this.transform.zoom)) {
                ++this.currentLayer;
                continue;
              }
              this.currentLayer = this.terrain.renderBatch(this.currentLayer), this._lastOcclusionLayer = Math.max(this.currentLayer, this._lastOcclusionLayer);
            } else {
              if (!L22 && e22.is3D(r22) && !r22) {
                const e3 = this.currentLayer, t3 = (e4) => {
                  for (this.currentLayer = 0; this.currentLayer < h22.length; this.currentLayer++) {
                    const t4 = h22[this.currentLayer];
                    if (ta[t4.type]) {
                      const i4 = this.style.getLayerSourceCache(t4);
                      ta[t4.type](this, i4, t4, C22(t4, i4), e4);
                    }
                  }
                };
                t3("initialize"), t3("reset"), this.currentLayer = e3, L22 = true;
              }
              if (l22 && !D22 && this.terrain && !this.transform.isOrthographic && (D22 = true, this.blitDepth()), c22 && -1 !== A22 && this.currentLayer === A22 + 1 && !this.transform.isOrthographic && this.blitDepth(), this.terrain || this._renderTileClippingMasks(e22, i3, i3 ? f22[i3.id] : void 0), this.renderLayer(this, i3, e22, C22(e22, i3)), !this.terrain && w22 && R22 > 0 && e22.hasShadowPass() && 0 == --R22 && (w22.drawGroundShadows(), this.firstLightBeamLayer <= this.currentLayer)) {
                const e3 = this.currentLayer;
                for (this.renderPass = "light-beam", this.currentLayer = this.firstLightBeamLayer; this.currentLayer <= e3; this.currentLayer++) {
                  const e4 = h22[this.currentLayer];
                  if (!e4.hasLightBeamPass()) continue;
                  const i4 = t22.getLayerSourceCache(e4);
                  this.renderLayer(this, i4, e4, i4 ? m22[i4.id] : void 0);
                }
                this.currentLayer = e3, this.renderPass = "translucent";
              }
              if (this.currentLayer >= this._lastOcclusionLayer && this.layersWithOcclusionOpacity.length > 0) {
                const e3 = this.currentLayer;
                this.depthOcclusion = true;
                for (const e4 of this.layersWithOcclusionOpacity) {
                  this.currentLayer = e4;
                  const i4 = h22[this.currentLayer], o3 = t22.getLayerSourceCache(i4), s3 = o3 ? m22[o3.id] : void 0;
                  this.terrain || this._renderTileClippingMasks(i4, o3, o3 ? f22[o3.id] : void 0), this.renderLayer(this, o3, i4, s3);
                }
                this.depthOcclusion = false, this.currentLayer = e3, this.renderPass = "translucent", this.layersWithOcclusionOpacity = [];
              }
              ++this.currentLayer;
            }
          }
          if (this.terrain && this.terrain.postRender(), this._snow && this._snow.draw(this), this._rain && this._rain.draw(this), this.options.showTileBoundaries || this.options.showQueryGeometry || this.options.showTileAABBs) {
            let i3 = null;
            h22.forEach((e22) => {
              const o3 = t22.getLayerSourceCache(e22);
              o3 && !e22.isHidden(this.transform.zoom) && o3.getVisibleCoordinates().length && (!i3 || i3.getSource().maxzoom < o3.getSource().maxzoom) && (i3 = o3);
            }), i3 && this.options.showTileBoundaries && Qn.debug(this, i3, i3.getVisibleCoordinates(), e2.am.red, false, this.options.showParseStatus);
          }
          this.terrain && this._debugParams.showTerrainProxyTiles && Qn.debug(this, this.terrain.proxySourceCache, this.terrain.proxyCoords, new e2.am(1, 0.8, 0.1, 1), true, this.options.showParseStatus), this.options.showPadding && function(e22) {
            const t3 = e22.transform.padding;
            dn(e22, e22.transform.height - (t3.top || 0), 3, rn), dn(e22, t3.bottom || 0, 3, nn), un(e22, t3.left || 0, 3, an), un(e22, e22.transform.width - (t3.right || 0), 3, ln);
            const i3 = e22.transform.centerPoint;
            !function(e3, t4, i4, o3) {
              _n(e3, t4 - 1, i4 - 10, 2, 20, o3), _n(e3, t4 - 10, i4 - 1, 20, 2, o3);
            }(e22, i3.x, e22.transform.height - i3.y, cn2);
          }(this), this.context.setDefault(), this.frameCounter = (this.frameCounter + 1) % Number.MAX_SAFE_INTEGER, this.tileLoaded && this.options.speedIndexTiming && (this.loadTimeStamps.push(performance.now()), this.saveCanvasCopy()), _22 || (this.conflationActive = false);
        }
        prepareLayer(e22) {
          this.gpuTimingStart(e22);
          const { unsupportedLayers: t22 } = this.transform.projection, i22 = !t22 || !t22.includes(e22.type);
          if (ea[e22.type] && (i22 || this.terrain && "custom" === e22.type)) {
            const t3 = this.style.getLayerSourceCache(e22);
            ea[e22.type](e22, t3, this);
          }
          this.gpuTimingEnd();
        }
        renderLayer(e22, t22, i22, o2) {
          i22.isHidden(this.transform.zoom) || ("background" === i22.type || "sky" === i22.type || "custom" === i22.type || "model" === i22.type || "raster" === i22.type || "raster-particle" === i22.type || o2 && o2.length) && (this.id = i22.id, this.gpuTimingStart(i22), e22.transform.projection.unsupportedLayers && e22.transform.projection.unsupportedLayers.includes(i22.type) && (!e22.terrain || "custom" !== i22.type) || "clip" === i22.type || Qn[i22.type](e22, t22, i22, o2, this.style.placement.variableOffsets, this.options.isInitialLoad), this.gpuTimingEnd());
        }
        gpuTimingStart(e22) {
          if (!this.options.gpuTiming) return;
          const t22 = this.context.extTimerQuery, i22 = this.context.gl;
          let o2 = this.gpuTimers[e22.id];
          o2 || (o2 = this.gpuTimers[e22.id] = { calls: 0, cpuTime: 0, query: i22.createQuery() }), o2.calls++, i22.beginQuery(t22.TIME_ELAPSED_EXT, o2.query);
        }
        gpuTimingDeferredRenderStart() {
          if (this.options.gpuTimingDeferredRender) {
            const e22 = this.context.extTimerQuery, t22 = this.context.gl, i22 = t22.createQuery();
            this.deferredRenderGpuTimeQueries.push(i22), t22.beginQuery(e22.TIME_ELAPSED_EXT, i22);
          }
        }
        gpuTimingDeferredRenderEnd() {
          this.options.gpuTimingDeferredRender && this.context.gl.endQuery(this.context.extTimerQuery.TIME_ELAPSED_EXT);
        }
        gpuTimingEnd() {
          this.options.gpuTiming && this.context.gl.endQuery(this.context.extTimerQuery.TIME_ELAPSED_EXT);
        }
        collectGpuTimers() {
          const e22 = this.gpuTimers;
          return this.gpuTimers = {}, e22;
        }
        collectDeferredRenderGpuQueries() {
          const e22 = this.deferredRenderGpuTimeQueries;
          return this.deferredRenderGpuTimeQueries = [], e22;
        }
        queryGpuTimers(e22) {
          const t22 = {};
          for (const i22 in e22) {
            const o2 = e22[i22], s2 = this.context.extTimerQuery, r22 = s2.getQueryParameter(o2.query, this.context.gl.QUERY_RESULT) / 1e6;
            s2.deleteQueryEXT(o2.query), t22[i22] = r22;
          }
          return t22;
        }
        queryGpuTimeDeferredRender(e22) {
          if (!this.options.gpuTimingDeferredRender) return 0;
          const t22 = this.context.gl;
          let i22 = 0;
          for (const o2 of e22) i22 += t22.getQueryParameter(o2, t22.QUERY_RESULT) / 1e6, t22.deleteQuery(o2);
          return i22;
        }
        translatePosMatrix(t22, i22, o2, s2, r22) {
          if (!o2[0] && !o2[1]) return t22;
          const n22 = r22 ? "map" === s2 ? this.transform.angle : 0 : "viewport" === s2 ? -this.transform.angle : 0;
          if (n22) {
            const e22 = Math.sin(n22), t3 = Math.cos(n22);
            o2 = [o2[0] * t3 - o2[1] * e22, o2[0] * e22 + o2[1] * t3];
          }
          const a22 = [r22 ? o2[0] : e2.aw(i22, o2[0], this.transform.zoom), r22 ? o2[1] : e2.aw(i22, o2[1], this.transform.zoom), 0], l22 = new Float32Array(16);
          return e2.bo(l22, t22, a22), l22;
        }
        saveTileTexture(e22) {
          const t22 = e22.size[0], i22 = this._tileTextures[t22];
          i22 ? i22.push(e22) : this._tileTextures[t22] = [e22];
        }
        getTileTexture(e22) {
          const t22 = this._tileTextures[e22];
          return t22 && t22.length > 0 ? t22.pop() : null;
        }
        terrainRenderModeElevated() {
          return this.style && !!this.style.getTerrain() && !!this.terrain && !this.terrain.renderingToTexture || this.forceTerrainMode;
        }
        linearFloatFilteringSupported() {
          return null != this.context.extTextureFloatLinear;
        }
        currentGlobalDefines(e22, t22, i22) {
          const o2 = void 0 === i22 ? this.terrain && this.terrain.renderingToTexture : i22, s2 = [];
          return this.style && this.style.enable3dLights() && ("globeRaster" === e22 || "terrainRaster" === e22 ? (s2.push("LIGHTING_3D_MODE"), s2.push("LIGHTING_3D_ALPHA_EMISSIVENESS")) : o2 || s2.push("LIGHTING_3D_MODE")), "shadow" === this.renderPass && (this._shadowMapDebug || s2.push("DEPTH_TEXTURE")), this.terrainRenderModeElevated() && (s2.push("TERRAIN"), this.linearFloatFilteringSupported() && s2.push("TERRAIN_DEM_FLOAT_FORMAT")), "globe" === this.transform.projection.name && s2.push("GLOBE"), !this._fogVisible || o2 || void 0 !== t22 && !t22 || s2.push("FOG", "FOG_DITHERING"), o2 && s2.push("RENDER_TO_TEXTURE"), this._showOverdrawInspector && s2.push("OVERDRAW_INSPECTOR"), s2;
        }
        getOrCreateProgram(e22, t22) {
          this.cache = this.cache || {};
          const i22 = t22 && t22.defines || [], o2 = t22 && t22.config, s2 = this.currentGlobalDefines(e22, t22 && t22.overrideFog, t22 && t22.overrideRtt).concat(i22), r22 = $s.cacheKey(jo[e22], e22, s2, o2);
          return this.cache[r22] || (this.cache[r22] = new $s(this.context, e22, jo[e22], o2, Ir[e22], s2)), this.cache[r22];
        }
        setCustomLayerDefaults() {
          this.context.unbindVAO(), this.context.cullFace.setDefault(), this.context.frontFace.setDefault(), this.context.cullFaceSide.setDefault(), this.context.activeTexture.setDefault(), this.context.pixelStoreUnpack.setDefault(), this.context.pixelStoreUnpackPremultiplyAlpha.setDefault(), this.context.pixelStoreUnpackFlipY.setDefault();
        }
        setBaseState() {
          const e22 = this.context.gl;
          this.context.cullFace.set(false), this.context.viewport.set([0, 0, this.width, this.height]), this.context.blendEquation.set(e22.FUNC_ADD);
        }
        initDebugOverlayCanvas() {
          null == this.debugOverlayCanvas && (this.debugOverlayCanvas = document.createElement("canvas"), this.debugOverlayCanvas.width = 512, this.debugOverlayCanvas.height = 512, this.debugOverlayTexture = new e2.T(this.context, this.debugOverlayCanvas, this.context.gl.RGBA8));
        }
        destroy() {
          this._terrain && this._terrain.destroy(), this._atmosphere && (this._atmosphere.destroy(), this._atmosphere = void 0), this.globeSharedBuffers && this.globeSharedBuffers.destroy(), this.emptyTexture.destroy(), this.debugOverlayTexture && this.debugOverlayTexture.destroy(), this._wireframeDebugCache.destroy(), this.depthFBO && (this.depthFBO.destroy(), this.depthFBO = void 0, this.depthTexture = void 0), this.emptyDepthTexture && this.emptyDepthTexture.destroy();
        }
        prepareDrawTile() {
          this.terrain && this.terrain.prepareDrawTile();
        }
        uploadCommonLightUniforms(t22, i22) {
          if (this.style.enable3dLights()) {
            const o2 = this.style.directionalLight, s2 = this.style.ambientLight;
            if (o2 && s2) {
              const r22 = ((t3, i3, o3) => {
                const s3 = t3.properties.get("direction"), r3 = "none" === t3.properties.get("color-use-theme"), n22 = t3.properties.get("color").toRenderColor(r3 ? null : o3.getLut(t3.scope)).toArray01(), a22 = t3.properties.get("intensity"), l22 = "none" === i3.properties.get("color-use-theme"), c22 = i3.properties.get("color").toRenderColor(l22 ? null : o3.getLut(i3.scope)).toArray01(), h22 = i3.properties.get("intensity"), d22 = [s3.x, s3.y, s3.z], u22 = e2.dw(c22, h22), _22 = e2.dw(n22, a22);
                return { u_lighting_ambient_color: u22, u_lighting_directional_dir: d22, u_lighting_directional_color: _22, u_ground_radiance: Zs(d22, _22, u22) };
              })(o2, s2, this.style);
              i22.setLightsUniformValues(t22, r22);
            }
          }
        }
        uploadCommonUniforms(t22, i22, o2, s2, r22) {
          if (this.uploadCommonLightUniforms(t22, i22), this.terrain && this.terrain.renderingToTexture) return;
          const n22 = this.style.fog;
          if (n22) {
            const r3 = n22.getOpacity(this.transform.pitch), a22 = ((t3, i3, o3, s3, r4, n3, a3, l22, c22, h22, d22, u22) => {
              const _22 = t3.transform, p22 = "none" === i3.properties.get("color-use-theme"), f22 = i3.properties.get("color").toRenderColor(p22 ? null : t3.style.getLut(i3.scope)).toArray01();
              f22[3] = s3;
              const m22 = t3.frameCounter / 1e3 % 1, [g22, v22] = i3.properties.get("vertical-range");
              return { u_fog_matrix: o3 ? _22.calculateFogTileMatrix(o3) : u22 || t3.identityMat, u_fog_range: i3.getFovAdjustedRange(_22._fov), u_fog_color: f22, u_fog_horizon_blend: i3.properties.get("horizon-blend"), u_fog_vertical_limit: [Math.min(g22, v22), v22], u_fog_temporal_offset: m22, u_frustum_tl: r4, u_frustum_tr: n3, u_frustum_br: a3, u_frustum_bl: l22, u_globe_pos: c22, u_globe_radius: h22, u_viewport: d22, u_globe_transition: e2.ah(_22.zoom), u_is_globe: +("globe" === _22.projection.name) };
            })(this, n22, o2, r3, this.transform.frustumCorners.TL, this.transform.frustumCorners.TR, this.transform.frustumCorners.BR, this.transform.frustumCorners.BL, this.transform.globeCenterInViewSpace, this.transform.globeRadius, [this.transform.width * e2.q.devicePixelRatio, this.transform.height * e2.q.devicePixelRatio], s2);
            i22.setFogUniformValues(t22, a22);
          }
          r22 && i22.setCutoffUniformValues(t22, r22.uniformValues);
        }
        setTileLoadedFlag(e22) {
          this.tileLoaded = e22;
        }
        saveCanvasCopy() {
          const e22 = this.canvasCopy();
          e22 && (this.frameCopies.push(e22), this.tileLoaded = false);
        }
        canvasCopy() {
          const e22 = this.context.gl, t22 = e22.createTexture();
          return e22.bindTexture(e22.TEXTURE_2D, t22), e22.copyTexImage2D(e22.TEXTURE_2D, 0, e22.RGBA, 0, 0, e22.drawingBufferWidth, e22.drawingBufferHeight, 0), t22;
        }
        getCanvasCopiesAndTimestamps() {
          return { canvasCopies: this.frameCopies, timeStamps: this.loadTimeStamps };
        }
        averageElevationNeedsEasing() {
          if (!this.transform._elevation) return false;
          const e22 = this.style && this.style.fog;
          return !!e22 && 0 !== e22.getOpacity(this.transform.pitch);
        }
        getBackgroundTiles() {
          const e22 = this._backgroundTiles, t22 = this._backgroundTiles = {}, i22 = this.transform.coveringTiles({ tileSize: 512 });
          for (const o2 of i22) t22[o2.key] = e22[o2.key] || new wt(o2, 512, this.transform.tileZoom, this);
          return t22;
        }
        clearBackgroundTiles() {
          this._backgroundTiles = {};
        }
        isSourceForClippingOrConflation(e22, t22) {
          return !(!e22.is3D(!(!this.terrain || !this.terrain.enabled)) || "clip" !== e22.type && (e22.minzoom && e22.minzoom > this.transform.zoom || (this.style._clipLayerPresent || "building" !== e22.sourceLayer) && (!t22 || "batched-model" !== t22.type)));
        }
        isTileAffectedByFog(e22) {
          if (!this.style || !this.style.fog) return false;
          if ("globe" === this.transform.projection.name) return true;
          let t22 = this._cachedTileFogOpacities[e22.key];
          return t22 || (this._cachedTileFogOpacities[e22.key] = t22 = this.style.fog.getOpacityForTile(e22)), t22[0] >= Fe || t22[1] >= Fe;
        }
        setupDepthForOcclusion(e22, t22, i22) {
          const o2 = this.context, s2 = o2.gl, r22 = !!i22;
          var n22;
          i22 || (i22 = { u_dem: 2, u_dem_prev: 4, u_dem_tl: [0, 0], u_dem_tl_prev: [0, 0], u_dem_scale: 0, u_dem_scale_prev: 0, u_dem_size: 0, u_dem_lerp: 1, u_depth: 3, u_depth_size_inv: [0, 0], u_depth_range_unpack: [0, 1], u_occluder_half_size: 16, u_occlusion_depth_offset: -1e-4, u_exaggeration: 0 }), o2.activeTexture.set(s2.TEXTURE3), e22 && this.depthFBO && this.depthTexture ? (this.depthTexture.bind(s2.NEAREST, s2.CLAMP_TO_EDGE), i22.u_depth_size_inv = [1 / this.depthFBO.width, 1 / this.depthFBO.height], i22.u_depth_range_unpack = [2 / ((n22 = this.depthRangeFor3D)[1] - n22[0]), -1 - 2 * n22[0] / (n22[1] - n22[0])], i22.u_occluder_half_size = 0.5 * this.occlusionParams.occluderSize, i22.u_occlusion_depth_offset = this.occlusionParams.depthOffset) : this.emptyDepthTexture.bind(s2.NEAREST, s2.CLAMP_TO_EDGE), o2.activeTexture.set(s2.TEXTURE0), r22 || t22.setTerrainUniformValues(o2, i22);
        }
      }
      function oa(e22, t22) {
        let i22 = false, o2 = null;
        const s2 = () => {
          o2 = null, i22 && (e22(), o2 = setTimeout(s2, t22), i22 = false);
        };
        return () => (i22 = true, o2 || s2(), o2);
      }
      class sa {
        constructor(t22) {
          this._hashName = t22 && encodeURIComponent(t22), e2.aV(["_getCurrentHash", "_onHashChange", "_updateHash"], this), this._updateHash = oa(this._updateHashUnthrottled.bind(this), 300);
        }
        addTo(e22) {
          return this._map = e22, window.addEventListener("hashchange", this._onHashChange, false), e22.on("moveend", this._updateHash), this;
        }
        remove() {
          return this._map ? (this._map.off("moveend", this._updateHash), window.removeEventListener("hashchange", this._onHashChange, false), clearTimeout(this._updateHash()), this._map = void 0, this) : this;
        }
        getHashString() {
          const e22 = this._map;
          if (!e22) return "";
          const t22 = ra(e22);
          if (this._hashName) {
            const e3 = this._hashName;
            let i22 = false;
            const o2 = location.hash.slice(1).split("&").map((o3) => {
              const s2 = o3.split("=")[0];
              return s2 === e3 ? (i22 = true, `${s2}=${t22}`) : o3;
            }).filter((e4) => e4);
            return i22 || o2.push(`${e3}=${t22}`), `#${o2.join("&")}`;
          }
          return `#${t22}`;
        }
        _getCurrentHash() {
          const e22 = location.hash.replace("#", "");
          if (this._hashName) {
            let t22;
            return e22.split("&").map((e3) => e3.split("=")).forEach((e3) => {
              e3[0] === this._hashName && (t22 = e3);
            }), (t22 && t22[1] || "").split("/");
          }
          return e22.split("/");
        }
        _onHashChange() {
          const e22 = this._map;
          if (!e22) return false;
          const t22 = this._getCurrentHash();
          if (t22.length >= 3 && !t22.some((e3) => isNaN(Number(e3)))) {
            const i22 = e22.dragRotate.isEnabled() && e22.touchZoomRotate.isEnabled() ? +(t22[3] || 0) : e22.getBearing();
            return e22.jumpTo({ center: [+t22[2], +t22[1]], zoom: +t22[0], bearing: i22, pitch: +(t22[4] || 0) }), true;
          }
          return false;
        }
        _updateHashUnthrottled() {
          history.replaceState(history.state, "", location.href.replace(/(#.+)?$/, this.getHashString()));
        }
      }
      function ra(e22, t22) {
        const i22 = e22.getCenter(), o2 = Math.round(100 * e22.getZoom()) / 100, s2 = Math.ceil((o2 * Math.LN2 + Math.log(512 / 360 / 0.5)) / Math.LN10), r22 = Math.pow(10, s2), n22 = Math.round(i22.lng * r22) / r22, a22 = Math.round(i22.lat * r22) / r22, l22 = e22.getBearing(), c22 = e22.getPitch();
        let h22 = t22 ? `/${n22}/${a22}/${o2}` : `${o2}/${a22}/${n22}`;
        return (l22 || c22) && (h22 += "/" + Math.round(10 * l22) / 10), c22 && (h22 += `/${Math.round(c22)}`), h22;
      }
      const na = { linearity: 0.3, easing: e2.ew(0, 0, 0.3, 1) }, aa = e2.l({ deceleration: 2500, maxSpeed: 1400 }, na), la = e2.l({ deceleration: 20, maxSpeed: 1400 }, na), ca = e2.l({ deceleration: 1e3, maxSpeed: 360 }, na), ha = e2.l({ deceleration: 1e3, maxSpeed: 90 }, na);
      class da {
        constructor(e22) {
          this._map = e22, this.clear();
        }
        clear() {
          this._inertiaBuffer = [];
        }
        record(t22) {
          this._drainInertiaBuffer(), this._inertiaBuffer.push({ time: e2.q.now(), settings: t22 });
        }
        _drainInertiaBuffer() {
          const t22 = this._inertiaBuffer, i22 = e2.q.now();
          for (; t22.length > 0 && i22 - t22[0].time > 160; ) t22.shift();
        }
        _onMoveEnd(t22) {
          if (this._map._prefersReducedMotion()) return;
          if (this._drainInertiaBuffer(), this._inertiaBuffer.length < 2) return;
          const i22 = { zoom: 0, bearing: 0, pitch: 0, pan: new e2.P(0, 0), pinchAround: void 0, around: void 0 };
          for (const { settings: e22 } of this._inertiaBuffer) i22.zoom += e22.zoomDelta || 0, i22.bearing += e22.bearingDelta || 0, i22.pitch += e22.pitchDelta || 0, e22.panDelta && i22.pan._add(e22.panDelta), e22.around && (i22.around = e22.around), e22.pinchAround && (i22.pinchAround = e22.pinchAround);
          const o2 = this._inertiaBuffer[this._inertiaBuffer.length - 1].time - this._inertiaBuffer[0].time, s2 = {};
          if (i22.pan.mag()) {
            const r22 = _a2(i22.pan.mag(), o2, e2.l({}, aa, t22 || {}));
            s2.offset = i22.pan.mult(r22.amount / i22.pan.mag()), s2.center = this._map.transform.center, ua(s2, r22);
          }
          if (i22.zoom) {
            const e22 = _a2(i22.zoom, o2, la);
            s2.zoom = this._map.transform.zoom + e22.amount, ua(s2, e22);
          }
          if (i22.bearing) {
            const t3 = _a2(i22.bearing, o2, ca);
            s2.bearing = this._map.transform.bearing + e2.aD(t3.amount, -179, 179), ua(s2, t3);
          }
          if (i22.pitch) {
            const e22 = _a2(i22.pitch, o2, ha);
            s2.pitch = this._map.transform.pitch + e22.amount, ua(s2, e22);
          }
          if (s2.zoom || s2.bearing) {
            const e22 = void 0 === i22.pinchAround ? i22.around : i22.pinchAround;
            s2.around = e22 ? this._map.unproject(e22) : this._map.getCenter();
          }
          return this.clear(), s2.noMoveStart = true, s2;
        }
      }
      function ua(e22, t22) {
        (!e22.duration || e22.duration < t22.duration) && (e22.duration = t22.duration, e22.easing = t22.easing);
      }
      function _a2(t22, i22, o2) {
        const { maxSpeed: s2, linearity: r22, deceleration: n22 } = o2, a22 = e2.aD(t22 * r22 / (i22 / 1e3), -s2, s2), l22 = Math.abs(a22) / (n22 * r22);
        return { easing: o2.easing, duration: 1e3 * l22, amount: a22 * (l22 / 2) };
      }
      class pa extends e2.A {
        preventDefault() {
          this._defaultPrevented = true;
        }
        get defaultPrevented() {
          return this._defaultPrevented;
        }
        constructor(t22, i22, o2, s2 = {}) {
          const r22 = g2(i22.getCanvasContainer(), o2), n22 = i22.unproject(r22);
          super(t22, e2.l({ point: r22, lngLat: n22, originalEvent: o2 }, s2)), this._defaultPrevented = false, this.target = i22;
        }
      }
      class fa extends e2.A {
        preventDefault() {
          this._defaultPrevented = true;
        }
        get defaultPrevented() {
          return this._defaultPrevented;
        }
        constructor(t22, i22, o2) {
          const s2 = "touchend" === t22 ? o2.changedTouches : o2.touches, r22 = v2(i22.getCanvasContainer(), s2), n22 = r22.map((e22) => i22.unproject(e22)), a22 = r22.reduce((e22, t3, i3, o3) => e22.add(t3.div(o3.length)), new e2.P(0, 0));
          super(t22, { points: r22, point: a22, lngLats: n22, lngLat: i22.unproject(a22), originalEvent: o2 }), this._defaultPrevented = false;
        }
      }
      class ma extends e2.A {
        preventDefault() {
          this._defaultPrevented = true;
        }
        get defaultPrevented() {
          return this._defaultPrevented;
        }
        constructor(e22, t22) {
          super("wheel", { originalEvent: t22 }), this._defaultPrevented = false;
        }
      }
      class ga {
        constructor(e22, t22) {
          this._map = e22, this._clickTolerance = t22.clickTolerance;
        }
        reset() {
          this._mousedownPos = void 0;
        }
        wheel(e22) {
          return this._firePreventable(new ma(this._map, e22));
        }
        mousedown(e22, t22) {
          return this._mousedownPos = t22, this._firePreventable(new pa(e22.type, this._map, e22));
        }
        mouseup(e22) {
          this._map.fire(new pa(e22.type, this._map, e22));
        }
        preclick(t22) {
          const i22 = e2.l({}, t22);
          i22.type = "preclick", this._map.fire(new pa(i22.type, this._map, i22));
        }
        click(e22, t22) {
          this._mousedownPos && this._mousedownPos.dist(t22) >= this._clickTolerance || (this.preclick(e22), this._map.fire(new pa(e22.type, this._map, e22)));
        }
        dblclick(e22) {
          return this._firePreventable(new pa(e22.type, this._map, e22));
        }
        mouseover(e22) {
          this._map.fire(new pa(e22.type, this._map, e22));
        }
        mouseout(e22) {
          this._map.fire(new pa(e22.type, this._map, e22));
        }
        touchstart(e22) {
          return this._firePreventable(new fa(e22.type, this._map, e22));
        }
        touchmove(e22) {
          this._map.fire(new fa(e22.type, this._map, e22));
        }
        touchend(e22) {
          this._map.fire(new fa(e22.type, this._map, e22));
        }
        touchcancel(e22) {
          this._map.fire(new fa(e22.type, this._map, e22));
        }
        _firePreventable(e22) {
          if (this._map.fire(e22), e22.defaultPrevented) return {};
        }
        isEnabled() {
          return true;
        }
        isActive() {
          return false;
        }
        enable() {
        }
        disable() {
        }
      }
      class va {
        constructor(e22) {
          this._map = e22;
        }
        reset() {
          this._delayContextMenu = false, this._contextMenuEvent = void 0;
        }
        mousemove(e22) {
          this._map.fire(new pa(e22.type, this._map, e22));
        }
        mousedown() {
          this._delayContextMenu = true;
        }
        mouseup() {
          this._delayContextMenu = false, this._contextMenuEvent && (this._map.fire(new pa("contextmenu", this._map, this._contextMenuEvent)), delete this._contextMenuEvent);
        }
        contextmenu(e22) {
          this._delayContextMenu ? this._contextMenuEvent = e22 : this._map.fire(new pa(e22.type, this._map, e22)), this._map.listens("contextmenu") && e22.preventDefault();
        }
        isEnabled() {
          return true;
        }
        isActive() {
          return false;
        }
        enable() {
        }
        disable() {
        }
      }
      class ya {
        constructor(e22, t22) {
          this._map = e22, this._el = e22.getCanvasContainer(), this._container = e22.getContainer(), this._clickTolerance = t22.clickTolerance || 1;
        }
        isEnabled() {
          return !!this._enabled;
        }
        isActive() {
          return !!this._active;
        }
        enable() {
          this.isEnabled() || (this._enabled = true);
        }
        disable() {
          this.isEnabled() && (this._enabled = false);
        }
        mousedown(e22, t22) {
          this.isEnabled() && e22.shiftKey && 0 === e22.button && (_2(), this._startPos = this._lastPos = t22, this._active = true);
        }
        mousemoveWindow(e22, t22) {
          if (!this._active) return;
          const i22 = t22, o2 = this._startPos, s2 = this._lastPos;
          if (!o2 || !s2 || s2.equals(i22) || !this._box && i22.dist(o2) < this._clickTolerance) return;
          this._lastPos = i22, this._box || (this._box = l2("div", "mapboxgl-boxzoom", this._container), this._container.classList.add("mapboxgl-crosshair"), this._fireEvent("boxzoomstart", e22));
          const r22 = Math.min(o2.x, i22.x), n22 = Math.max(o2.x, i22.x), a22 = Math.min(o2.y, i22.y), c22 = Math.max(o2.y, i22.y);
          this._map._requestDomTask(() => {
            this._box && (this._box.style.transform = `translate(${r22}px,${a22}px)`, this._box.style.width = n22 - r22 + "px", this._box.style.height = c22 - a22 + "px");
          });
        }
        mouseupWindow(t22, i22) {
          if (!this._active) return;
          const o2 = this._startPos, s2 = i22;
          if (o2 && 0 === t22.button) {
            if (this.reset(), m2(), o2.x !== s2.x || o2.y !== s2.y) return this._map.fire(new e2.A("boxzoomend", { originalEvent: t22 })), { cameraAnimation: (e22) => e22.fitScreenCoordinates(o2, s2, this._map.getBearing(), { linear: false }) };
            this._fireEvent("boxzoomcancel", t22);
          }
        }
        keydown(e22) {
          this._active && 27 === e22.keyCode && (this.reset(), this._fireEvent("boxzoomcancel", e22));
        }
        blur() {
          this.reset();
        }
        reset() {
          this._active = false, this._container.classList.remove("mapboxgl-crosshair"), this._box && (this._box.remove(), this._box = null), p2(), delete this._startPos, delete this._lastPos;
        }
        _fireEvent(t22, i22) {
          return this._map.fire(new e2.A(t22, { originalEvent: i22 }));
        }
      }
      function xa(e22, t22) {
        const i22 = {};
        for (let o2 = 0; o2 < e22.length; o2++) i22[e22[o2].identifier] = t22[o2];
        return i22;
      }
      class ba {
        constructor(e22) {
          this.reset(), this.numTouches = e22.numTouches;
        }
        reset() {
          this.centroid = void 0, this.startTime = 0, this.touches = {}, this.aborted = false;
        }
        touchstart(t22, i22, o2) {
          (this.centroid || o2.length > this.numTouches) && (this.aborted = true), this.aborted || (0 === this.startTime && (this.startTime = t22.timeStamp), o2.length === this.numTouches && (this.centroid = function(t3) {
            const i3 = new e2.P(0, 0);
            for (const e22 of t3) i3._add(e22);
            return i3.div(t3.length);
          }(i22), this.touches = xa(o2, i22)));
        }
        touchmove(e22, t22, i22) {
          if (this.aborted || !this.centroid) return;
          const o2 = xa(i22, t22);
          for (const e3 in this.touches) {
            const t3 = o2[e3];
            (!t3 || t3.dist(this.touches[e3]) > 30) && (this.aborted = true);
          }
        }
        touchend(e22, t22, i22) {
          if ((!this.centroid || e22.timeStamp - this.startTime > 500) && (this.aborted = true), 0 === i22.length) {
            const e3 = !this.aborted && this.centroid;
            if (this.reset(), e3) return e3;
          }
        }
      }
      class wa {
        constructor(e22) {
          this.singleTap = new ba(e22), this.numTaps = e22.numTaps, this.reset();
        }
        reset() {
          this.lastTime = 1 / 0, this.lastTap = void 0, this.count = 0, this.singleTap.reset();
        }
        touchstart(e22, t22, i22) {
          this.singleTap.touchstart(e22, t22, i22);
        }
        touchmove(e22, t22, i22) {
          this.singleTap.touchmove(e22, t22, i22);
        }
        touchend(e22, t22, i22) {
          const o2 = this.singleTap.touchend(e22, t22, i22);
          if (o2) {
            const t3 = e22.timeStamp - this.lastTime < 500, i3 = !this.lastTap || this.lastTap.dist(o2) < 30;
            if (t3 && i3 || this.reset(), this.count++, this.lastTime = e22.timeStamp, this.lastTap = o2, this.count === this.numTaps) return this.reset(), o2;
          }
        }
      }
      class Ta {
        constructor() {
          this._zoomIn = new wa({ numTouches: 1, numTaps: 2 }), this._zoomOut = new wa({ numTouches: 2, numTaps: 1 }), this.reset();
        }
        reset() {
          this._active = false, this._zoomIn.reset(), this._zoomOut.reset();
        }
        touchstart(e22, t22, i22) {
          this._zoomIn.touchstart(e22, t22, i22), this._zoomOut.touchstart(e22, t22, i22);
        }
        touchmove(e22, t22, i22) {
          this._zoomIn.touchmove(e22, t22, i22), this._zoomOut.touchmove(e22, t22, i22);
        }
        touchend(e22, t22, i22) {
          const o2 = this._zoomIn.touchend(e22, t22, i22), s2 = this._zoomOut.touchend(e22, t22, i22);
          return o2 ? (this._active = true, e22.preventDefault(), setTimeout(() => this.reset(), 0), { cameraAnimation: (t3) => t3.easeTo({ duration: 300, zoom: t3.getZoom() + 1, around: t3.unproject(o2) }, { originalEvent: e22 }) }) : s2 ? (this._active = true, e22.preventDefault(), setTimeout(() => this.reset(), 0), { cameraAnimation: (t3) => t3.easeTo({ duration: 300, zoom: t3.getZoom() - 1, around: t3.unproject(s2) }, { originalEvent: e22 }) }) : void 0;
        }
        touchcancel() {
          this.reset();
        }
        enable() {
          this._enabled = true;
        }
        disable() {
          this._enabled = false, this.reset();
        }
        isEnabled() {
          return this._enabled;
        }
        isActive() {
          return this._active;
        }
      }
      const Ea = { 0: 1, 2: 2 }, Sa = { Control: "ctrlKey", Alt: "altKey", Shift: "shiftKey", Meta: "metaKey" };
      class Ia {
        constructor(e22) {
          this.reset(), this._clickTolerance = e22.clickTolerance || 1;
        }
        blur() {
          this.reset();
        }
        reset() {
          this._active = false, this._moved = false, this._lastPoint = void 0, this._eventButton = void 0;
        }
        _correctButton(e22, t22) {
          return false;
        }
        _move(e22, t22) {
          return {};
        }
        mousedown(e22, t22) {
          if (this._lastPoint) return;
          const i22 = y2(e22);
          this._correctButton(e22, i22) && (this._lastPoint = t22, this._eventButton = i22);
        }
        mousemoveWindow(e22, t22) {
          const i22 = this._lastPoint;
          if (i22) {
            if (e22.preventDefault(), null != this._eventButton && function(e3, t3) {
              const i3 = Ea[t3];
              return void 0 === e3.buttons || (e3.buttons & i3) !== i3;
            }(e22, this._eventButton)) this.reset();
            else if (this._moved || !(t22.dist(i22) < this._clickTolerance)) return this._moved = true, this._lastPoint = t22, this._move(i22, t22);
          }
        }
        mouseupWindow(e22) {
          this._lastPoint && y2(e22) === this._eventButton && (this._moved && m2(), this.reset());
        }
        enable() {
          this._enabled = true;
        }
        disable() {
          this._enabled = false, this.reset();
        }
        isEnabled() {
          return this._enabled;
        }
        isActive() {
          return this._active;
        }
      }
      class Ca extends Ia {
        mousedown(e22, t22) {
          super.mousedown(e22, t22), this._lastPoint && (this._active = true);
        }
        _correctButton(e22, t22) {
          return 0 === t22 && !e22.ctrlKey;
        }
        _move(e22, t22) {
          return { around: t22, panDelta: t22.sub(e22) };
        }
      }
      class Ra extends Ia {
        constructor(e22) {
          super(e22), this._pitchRotateKey = e22.pitchRotateKey ? Sa[e22.pitchRotateKey] : void 0;
        }
        _correctButton(e22, t22) {
          return this._pitchRotateKey ? 0 === t22 && e22[this._pitchRotateKey] : 0 === t22 && e22.ctrlKey || 2 === t22;
        }
        _move(e22, t22) {
          const i22 = 0.8 * (t22.x - e22.x);
          if (i22) return this._active = true, { bearingDelta: i22 };
        }
        contextmenu(e22) {
          this._pitchRotateKey || e22.preventDefault();
        }
      }
      class Da extends Ia {
        constructor(e22) {
          super(e22), this._pitchRotateKey = e22.pitchRotateKey ? Sa[e22.pitchRotateKey] : void 0;
        }
        _correctButton(e22, t22) {
          return this._pitchRotateKey ? 0 === t22 && e22[this._pitchRotateKey] : 0 === t22 && e22.ctrlKey || 2 === t22;
        }
        _move(e22, t22) {
          const i22 = -0.5 * (t22.y - e22.y);
          if (i22) return this._active = true, { pitchDelta: i22 };
        }
        contextmenu(e22) {
          this._pitchRotateKey || e22.preventDefault();
        }
      }
      class Aa {
        constructor(t22, i22) {
          this._map = t22, this._el = t22.getCanvasContainer(), this._minTouches = 1, this._clickTolerance = i22.clickTolerance || 1, this.reset(), e2.aV(["_addTouchPanBlocker", "_showTouchPanBlockerAlert"], this);
        }
        reset() {
          this._active = false, this._touches = {}, this._sum = new e2.P(0, 0);
        }
        touchstart(e22, t22, i22) {
          return this._calculateTransform(e22, t22, i22);
        }
        touchmove(t22, i22, o2) {
          if (this._active && !(o2.length < this._minTouches)) {
            if (this._map._cooperativeGestures && !this._map.isMoving()) {
              if (1 === o2.length && !e2.ex()) return void this._showTouchPanBlockerAlert();
              "hidden" !== this._alertContainer.style.visibility && (this._alertContainer.style.visibility = "hidden", clearTimeout(this._alertTimer));
            }
            return t22.cancelable && t22.preventDefault(), this._calculateTransform(t22, i22, o2);
          }
        }
        touchend(e22, t22, i22) {
          this._calculateTransform(e22, t22, i22), this._active && i22.length < this._minTouches && this.reset();
        }
        touchcancel() {
          this.reset();
        }
        _calculateTransform(t22, i22, o2) {
          o2.length > 0 && (this._active = true);
          const s2 = xa(o2, i22), r22 = new e2.P(0, 0), n22 = new e2.P(0, 0);
          let a22 = 0;
          for (const e22 in s2) {
            const t3 = s2[e22], i3 = this._touches[e22];
            i3 && (r22._add(t3), n22._add(t3.sub(i3)), a22++, s2[e22] = t3);
          }
          if (this._touches = s2, a22 < this._minTouches || !n22.mag()) return;
          const l22 = n22.div(a22);
          return this._sum._add(l22), this._sum.mag() < this._clickTolerance ? void 0 : { around: r22.div(a22), panDelta: l22 };
        }
        enable() {
          this._enabled = true, this._map._cooperativeGestures && (this._addTouchPanBlocker(), this._el.classList.add("mapboxgl-touch-pan-blocker-override", "mapboxgl-scrollable-page"));
        }
        disable() {
          this._enabled = false, this._map._cooperativeGestures && (clearTimeout(this._alertTimer), this._alertContainer.remove(), this._el.classList.remove("mapboxgl-touch-pan-blocker-override", "mapboxgl-scrollable-page")), this.reset();
        }
        isEnabled() {
          return !!this._enabled;
        }
        isActive() {
          return !!this._active;
        }
        _addTouchPanBlocker() {
          this._map && !this._alertContainer && (this._alertContainer = l2("div", "mapboxgl-touch-pan-blocker", this._map._container), this._alertContainer.textContent = this._map._getUIString("TouchPanBlocker.Message"), this._alertContainer.style.fontSize = `${Math.max(10, Math.min(24, Math.floor(0.05 * this._el.clientWidth)))}px`);
        }
        _showTouchPanBlockerAlert() {
          this._alertContainer.style.visibility = "visible", this._alertContainer.classList.add("mapboxgl-touch-pan-blocker-show"), this._alertContainer.setAttribute("role", "alert"), clearTimeout(this._alertTimer), this._alertTimer = window.setTimeout(() => {
            this._alertContainer.classList.remove("mapboxgl-touch-pan-blocker-show"), this._alertContainer.removeAttribute("role");
          }, 500);
        }
      }
      class La {
        constructor() {
          this.reset();
        }
        reset() {
          this._active = false, this._firstTwoTouches = void 0;
        }
        _start(e22) {
        }
        _move(e22, t22, i22) {
          return {};
        }
        touchstart(e22, t22, i22) {
          this._firstTwoTouches || i22.length < 2 || (this._firstTwoTouches = [i22[0].identifier, i22[1].identifier], this._start([t22[0], t22[1]]));
        }
        touchmove(e22, t22, i22) {
          const o2 = this._firstTwoTouches;
          if (!o2) return;
          e22.preventDefault();
          const [s2, r22] = o2, n22 = Pa(i22, t22, s2), a22 = Pa(i22, t22, r22);
          if (!n22 || !a22) return;
          const l22 = this._aroundCenter ? null : n22.add(a22).div(2);
          return this._move([n22, a22], l22, e22);
        }
        touchend(e22, t22, i22) {
          if (!this._firstTwoTouches) return;
          const [o2, s2] = this._firstTwoTouches, r22 = Pa(i22, t22, o2), n22 = Pa(i22, t22, s2);
          r22 && n22 || (this._active && m2(), this.reset());
        }
        touchcancel() {
          this.reset();
        }
        enable(e22) {
          this._enabled = true, this._aroundCenter = !!e22 && "center" === e22.around;
        }
        disable() {
          this._enabled = false, this.reset();
        }
        isEnabled() {
          return this._enabled;
        }
        isActive() {
          return this._active;
        }
      }
      function Pa(e22, t22, i22) {
        for (let o2 = 0; o2 < e22.length; o2++) if (e22[o2].identifier === i22) return t22[o2];
      }
      function za(e22, t22) {
        return Math.log(e22 / t22) / Math.LN2;
      }
      class Ma extends La {
        reset() {
          super.reset(), this._distance = 0, this._startDistance = 0;
        }
        _start(e22) {
          this._startDistance = this._distance = e22[0].dist(e22[1]);
        }
        _move(e22, t22) {
          const i22 = this._distance;
          if (this._distance = e22[0].dist(e22[1]), this._active || !(Math.abs(za(this._distance, this._startDistance)) < 0.1)) return this._active = true, { zoomDelta: za(this._distance, i22), pinchAround: t22 };
        }
      }
      function Oa(e22, t22) {
        return 180 * e22.angleWith(t22) / Math.PI;
      }
      class Fa extends La {
        reset() {
          super.reset(), this._minDiameter = 0, this._startVector = void 0, this._vector = void 0;
        }
        _start(e22) {
          this._startVector = this._vector = e22[0].sub(e22[1]), this._minDiameter = e22[0].dist(e22[1]);
        }
        _move(e22, t22) {
          const i22 = this._vector;
          if (this._vector = e22[0].sub(e22[1]), i22 && (this._active || !this._isBelowThreshold(this._vector))) return this._active = true, { bearingDelta: Oa(this._vector, i22), pinchAround: t22 };
        }
        _isBelowThreshold(e22) {
          this._minDiameter = Math.min(this._minDiameter, e22.mag());
          const t22 = 25 / (Math.PI * this._minDiameter) * 360, i22 = this._startVector;
          if (!i22) return false;
          const o2 = Oa(e22, i22);
          return Math.abs(o2) < t22;
        }
      }
      function Ba(e22) {
        return Math.abs(e22.y) > Math.abs(e22.x);
      }
      class ka extends La {
        constructor(e22) {
          super(), this._map = e22;
        }
        reset() {
          super.reset(), this._valid = void 0, this._firstMove = void 0, this._lastPoints = void 0;
        }
        _start(e22) {
          this._lastPoints = e22, Ba(e22[0].sub(e22[1])) && (this._valid = false);
        }
        _move(t22, i22, o2) {
          const s2 = this._lastPoints;
          if (!s2) return;
          const r22 = t22[0].sub(s2[0]), n22 = t22[1].sub(s2[1]);
          return this._map._cooperativeGestures && !e2.ex() && o2.touches.length < 3 || (this._valid = this.gestureBeginsVertically(r22, n22, o2.timeStamp), !this._valid) ? void 0 : (this._lastPoints = t22, this._active = true, { pitchDelta: (r22.y + n22.y) / 2 * -0.5 });
        }
        gestureBeginsVertically(e22, t22, i22) {
          if (void 0 !== this._valid) return this._valid;
          const o2 = e22.mag() >= 2, s2 = t22.mag() >= 2;
          if (!o2 && !s2) return;
          if (!o2 || !s2) return null == this._firstMove && (this._firstMove = i22), i22 - this._firstMove < 100 && void 0;
          const r22 = e22.y > 0 == t22.y > 0;
          return Ba(e22) && Ba(t22) && r22;
        }
      }
      const Na = { panStep: 100, bearingStep: 15, pitchStep: 10 };
      class Ua {
        constructor() {
          const e22 = Na;
          this._panStep = e22.panStep, this._bearingStep = e22.bearingStep, this._pitchStep = e22.pitchStep, this._rotationDisabled = false;
        }
        blur() {
          this.reset();
        }
        reset() {
          this._active = false;
        }
        keydown(e22) {
          if (e22.altKey || e22.ctrlKey || e22.metaKey) return;
          let t22 = 0, i22 = 0, o2 = 0, s2 = 0, r22 = 0;
          switch (e22.keyCode) {
            case 61:
            case 107:
            case 171:
            case 187:
              t22 = 1;
              break;
            case 189:
            case 109:
            case 173:
              t22 = -1;
              break;
            case 37:
              e22.shiftKey ? i22 = -1 : (e22.preventDefault(), s2 = -1);
              break;
            case 39:
              e22.shiftKey ? i22 = 1 : (e22.preventDefault(), s2 = 1);
              break;
            case 38:
              e22.shiftKey ? o2 = 1 : (e22.preventDefault(), r22 = -1);
              break;
            case 40:
              e22.shiftKey ? o2 = -1 : (e22.preventDefault(), r22 = 1);
              break;
            default:
              return;
          }
          return this._rotationDisabled && (i22 = 0, o2 = 0), { cameraAnimation: (n22) => {
            const a22 = n22.getZoom();
            n22.easeTo({ duration: 300, easeId: "keyboardHandler", easing: ja, zoom: t22 ? Math.round(a22) + t22 * (e22.shiftKey ? 2 : 1) : a22, bearing: n22.getBearing() + i22 * this._bearingStep, pitch: n22.getPitch() + o2 * this._pitchStep, offset: [-s2 * this._panStep, -r22 * this._panStep], center: n22.getCenter() }, { originalEvent: e22 });
          } };
        }
        enable() {
          this._enabled = true;
        }
        disable() {
          this._enabled = false, this.reset();
        }
        isEnabled() {
          return this._enabled;
        }
        isActive() {
          return this._active;
        }
        disableRotation() {
          this._rotationDisabled = true;
        }
        enableRotation() {
          this._rotationDisabled = false;
        }
      }
      function ja(e22) {
        return e22 * (2 - e22);
      }
      const Va = 4.000244140625, Ga = 1 / 450;
      class qa {
        constructor(t22, i22) {
          this._map = t22, this._el = t22.getCanvasContainer(), this._handler = i22, this._delta = 0, this._lastDelta = 0, this._defaultZoomRate = 0.01, this._wheelZoomRate = Ga, e2.aV(["_onTimeout", "_addScrollZoomBlocker", "_showBlockerAlert"], this);
        }
        setZoomRate(e22) {
          this._defaultZoomRate = e22;
        }
        setWheelZoomRate(e22) {
          this._wheelZoomRate = e22;
        }
        isEnabled() {
          return !!this._enabled;
        }
        isActive() {
          return this._active || void 0 !== this._finishTimeout;
        }
        isZooming() {
          return !!this._zooming;
        }
        enable(e22) {
          this.isEnabled() || (this._enabled = true, this._aroundCenter = !!e22 && "center" === e22.around, this._map._cooperativeGestures && this._addScrollZoomBlocker());
        }
        disable() {
          this.isEnabled() && (this._enabled = false, this._map._cooperativeGestures && (clearTimeout(this._alertTimer), this._alertContainer.remove()));
        }
        wheel(t22) {
          if (!this.isEnabled()) return;
          if (this._map._cooperativeGestures) {
            if (!(t22.ctrlKey || t22.metaKey || this.isZooming() || e2.ex())) return void this._showBlockerAlert();
            "hidden" !== this._alertContainer.style.visibility && (this._alertContainer.style.visibility = "hidden", clearTimeout(this._alertTimer));
          }
          let i22 = t22.deltaMode === WheelEvent.DOM_DELTA_LINE ? 40 * t22.deltaY : t22.deltaY;
          const o2 = e2.q.now(), s2 = o2 - (this._lastWheelEventTime || 0);
          this._lastWheelEventTime = o2, 0 !== i22 && i22 % Va == 0 ? this._type = "wheel" : 0 !== i22 && Math.abs(i22) < 4 ? this._type = "trackpad" : s2 > 400 ? (this._type = null, this._lastValue = i22, this._timeout = window.setTimeout(this._onTimeout, 40, t22)) : this._type || (this._type = Math.abs(s2 * i22) < 200 ? "trackpad" : "wheel", this._timeout && (clearTimeout(this._timeout), this._timeout = null, i22 += this._lastValue)), t22.shiftKey && i22 && (i22 /= 4), this._type && (this._lastWheelEvent = t22, this._delta -= i22, this._active || this._start(t22)), t22.preventDefault();
        }
        _onTimeout(e22) {
          this._type = "wheel", this._delta -= this._lastValue, this._active || this._start(e22);
        }
        _start(e22) {
          if (!this._delta) return;
          this._frameId && (this._frameId = null), this._active = true, this.isZooming() || (this._zooming = true), this._finishTimeout && (clearTimeout(this._finishTimeout), delete this._finishTimeout);
          const t22 = g2(this._el, e22);
          this._aroundPoint = this._aroundCenter ? this._map.transform.centerPoint : t22, this._aroundCoord = this._map.transform.pointCoordinate3D(this._aroundPoint), this._targetZoom = void 0, this._frameId || (this._frameId = true, this._handler._triggerRenderFrame());
        }
        renderFrame() {
          if (!this._frameId) return;
          if (this._frameId = null, !this.isActive()) return;
          const t22 = this._map.transform;
          "wheel" === this._type && t22.projection.wrap && (t22._center.lng >= 180 || t22._center.lng <= -180) && (this._prevEase = null, this._easing = null, this._lastWheelEvent = null, this._lastWheelEventTime = 0);
          const i22 = () => t22._terrainEnabled() && this._aroundCoord ? t22.computeZoomRelativeTo(this._aroundCoord) : t22.zoom;
          if (0 !== this._delta) {
            const e22 = "wheel" === this._type && Math.abs(this._delta) > Va ? this._wheelZoomRate : this._defaultZoomRate;
            let o3 = 2 / (1 + Math.exp(-Math.abs(this._delta * e22)));
            this._delta < 0 && 0 !== o3 && (o3 = 1 / o3);
            const s3 = i22(), r3 = Math.pow(2, s3), n3 = "number" == typeof this._targetZoom ? t22.zoomScale(this._targetZoom) : r3;
            this._targetZoom = Math.min(t22.maxZoom, Math.max(t22.minZoom, t22.scaleZoom(n3 * o3))), "wheel" === this._type && (this._startZoom = s3, this._easing = this._smoothOutEasing(200)), this._lastDelta = this._delta, this._delta = 0;
          }
          const o2 = "number" == typeof this._targetZoom ? this._targetZoom : i22(), s2 = this._startZoom, r22 = this._easing;
          let n22, a22 = false;
          if ("wheel" === this._type && s2 && r22) {
            const t3 = Math.min((e2.q.now() - this._lastWheelEventTime) / 200, 1), i3 = r22(t3);
            n22 = e2.ai(s2, o2, i3), t3 < 1 ? this._frameId || (this._frameId = true) : a22 = true;
          } else n22 = o2, a22 = true;
          this._active = true, a22 && (this._active = false, this._finishTimeout = window.setTimeout(() => {
            this._zooming = false, this._handler._triggerRenderFrame(), delete this._targetZoom, delete this._finishTimeout;
          }, 200));
          let l22 = n22 - i22();
          return l22 * this._lastDelta < 0 && (l22 = 0), { noInertia: true, needsRenderFrame: !a22, zoomDelta: l22, around: this._aroundPoint, aroundCoord: this._aroundCoord, originalEvent: this._lastWheelEvent };
        }
        _smoothOutEasing(t22) {
          let i22 = e2.ey;
          if (this._prevEase) {
            const t3 = this._prevEase, o2 = (e2.q.now() - t3.start) / t3.duration, s2 = t3.easing(o2 + 0.01) - t3.easing(o2), r22 = 0.27 / Math.sqrt(s2 * s2 + 1e-4) * 0.01, n22 = Math.sqrt(0.0729 - r22 * r22);
            i22 = e2.ew(r22, n22, 0.25, 1);
          }
          return this._prevEase = { start: e2.q.now(), duration: t22, easing: i22 }, i22;
        }
        blur() {
          this.reset();
        }
        reset() {
          this._active = false;
        }
        _addScrollZoomBlocker() {
          this._map && !this._alertContainer && (this._alertContainer = l2("div", "mapboxgl-scroll-zoom-blocker", this._map._container), this._alertContainer.textContent = /(Mac|iPad)/i.test(navigator.userAgent) ? this._map._getUIString("ScrollZoomBlocker.CmdMessage") : this._map._getUIString("ScrollZoomBlocker.CtrlMessage"), this._alertContainer.style.fontSize = `${Math.max(10, Math.min(24, Math.floor(0.05 * this._el.clientWidth)))}px`);
        }
        _showBlockerAlert() {
          this._alertContainer.style.visibility = "visible", this._alertContainer.classList.add("mapboxgl-scroll-zoom-blocker-show"), this._alertContainer.setAttribute("role", "alert"), clearTimeout(this._alertTimer), this._alertTimer = window.setTimeout(() => {
            this._alertContainer.classList.remove("mapboxgl-scroll-zoom-blocker-show"), this._alertContainer.removeAttribute("role");
          }, 200);
        }
      }
      class Za {
        constructor(e22, t22) {
          this._clickZoom = e22, this._tapZoom = t22;
        }
        enable() {
          this._clickZoom.enable(), this._tapZoom.enable();
        }
        disable() {
          this._clickZoom.disable(), this._tapZoom.disable();
        }
        isEnabled() {
          return this._clickZoom.isEnabled() && this._tapZoom.isEnabled();
        }
        isActive() {
          return this._clickZoom.isActive() || this._tapZoom.isActive();
        }
      }
      class Ha {
        constructor() {
          this.reset();
        }
        reset() {
          this._active = false;
        }
        blur() {
          this.reset();
        }
        dblclick(e22, t22) {
          return e22.preventDefault(), { cameraAnimation: (i22) => {
            i22.easeTo({ duration: 300, zoom: i22.getZoom() + (e22.shiftKey ? -1 : 1), around: i22.unproject(t22) }, { originalEvent: e22 });
          } };
        }
        enable() {
          this._enabled = true;
        }
        disable() {
          this._enabled = false, this.reset();
        }
        isEnabled() {
          return this._enabled;
        }
        isActive() {
          return this._active;
        }
      }
      class Wa {
        constructor() {
          this._tap = new wa({ numTouches: 1, numTaps: 1 }), this.reset();
        }
        reset() {
          this._active = false, this._swipePoint = void 0, this._swipeTouch = 0, this._tapTime = 0, this._tap.reset();
        }
        touchstart(e22, t22, i22) {
          this._swipePoint || (this._tapTime && e22.timeStamp - this._tapTime > 500 && this.reset(), this._tapTime ? i22.length > 0 && (this._swipePoint = t22[0], this._swipeTouch = i22[0].identifier) : this._tap.touchstart(e22, t22, i22));
        }
        touchmove(e22, t22, i22) {
          if (this._tapTime) {
            if (this._swipePoint) {
              if (i22[0].identifier !== this._swipeTouch) return;
              const o2 = t22[0], s2 = o2.y - this._swipePoint.y;
              return this._swipePoint = o2, e22.preventDefault(), this._active = true, { zoomDelta: s2 / 128 };
            }
          } else this._tap.touchmove(e22, t22, i22);
        }
        touchend(e22, t22, i22) {
          this._tapTime ? this._swipePoint && 0 === i22.length && this.reset() : this._tap.touchend(e22, t22, i22) && (this._tapTime = e22.timeStamp);
        }
        touchcancel() {
          this.reset();
        }
        enable() {
          this._enabled = true;
        }
        disable() {
          this._enabled = false, this.reset();
        }
        isEnabled() {
          return this._enabled;
        }
        isActive() {
          return this._active;
        }
      }
      class $a {
        constructor(e22, t22, i22) {
          this._el = e22, this._mousePan = t22, this._touchPan = i22;
        }
        enable(e22) {
          this._inertiaOptions = e22 || {}, this._mousePan.enable(), this._touchPan.enable(), this._el.classList.add("mapboxgl-touch-drag-pan");
        }
        disable() {
          this._mousePan.disable(), this._touchPan.disable(), this._el.classList.remove("mapboxgl-touch-drag-pan");
        }
        isEnabled() {
          return this._mousePan.isEnabled() && this._touchPan.isEnabled();
        }
        isActive() {
          return this._mousePan.isActive() || this._touchPan.isActive();
        }
      }
      class Xa {
        constructor(e22, t22, i22) {
          this._pitchWithRotate = e22.pitchWithRotate, this._mouseRotate = t22, this._mousePitch = i22;
        }
        enable() {
          this._mouseRotate.enable(), this._pitchWithRotate && this._mousePitch.enable();
        }
        disable() {
          this._mouseRotate.disable(), this._mousePitch.disable();
        }
        isEnabled() {
          return this._mouseRotate.isEnabled() && (!this._pitchWithRotate || this._mousePitch.isEnabled());
        }
        isActive() {
          return this._mouseRotate.isActive() || this._mousePitch.isActive();
        }
      }
      class Ya {
        constructor(e22, t22, i22, o2) {
          this._el = e22, this._touchZoom = t22, this._touchRotate = i22, this._tapDragZoom = o2, this._rotationDisabled = false, this._enabled = true;
        }
        enable(e22) {
          this._touchZoom.enable(e22), this._rotationDisabled || this._touchRotate.enable(e22), this._tapDragZoom.enable(), this._el.classList.add("mapboxgl-touch-zoom-rotate");
        }
        disable() {
          this._touchZoom.disable(), this._touchRotate.disable(), this._tapDragZoom.disable(), this._el.classList.remove("mapboxgl-touch-zoom-rotate");
        }
        isEnabled() {
          return this._touchZoom.isEnabled() && (this._rotationDisabled || this._touchRotate.isEnabled()) && this._tapDragZoom.isEnabled();
        }
        isActive() {
          return this._touchZoom.isActive() || this._touchRotate.isActive() || this._tapDragZoom.isActive();
        }
        disableRotation() {
          this._rotationDisabled = true, this._touchRotate.disable();
        }
        enableRotation() {
          this._rotationDisabled = false, this._touchZoom.isEnabled() && this._touchRotate.enable();
        }
      }
      const Ka = (e22) => e22.zoom || e22.drag || e22.pitch || e22.rotate;
      class Ja extends e2.A {
      }
      class Qa {
        constructor() {
          this.constants = [1, 1, 0.01], this.radius = 0;
        }
        setup(t22, i22) {
          const o2 = e2.at([], i22, t22);
          this.radius = e2.ae(o2[2] < 0 ? e2.eA([], o2, this.constants) : [o2[0], o2[1], 0]);
        }
        projectRay(t22) {
          e2.eA(t22, t22, this.constants), e2.au(t22, t22), e2.eB(t22, t22, this.constants);
          const i22 = e2.b$([], t22, this.radius);
          if (i22[2] > 0) {
            const t3 = e2.b$([], [0, 0, 1], e2.bE(i22, [0, 0, 1])), o2 = e2.b$([], e2.au([], [i22[0], i22[1], 0]), this.radius), s2 = e2.cU([], i22, e2.b$([], e2.at([], e2.cU([], o2, t3), i22), 2));
            i22[0] = s2[0], i22[1] = s2[1];
          }
          return i22;
        }
      }
      function el(e22) {
        return e22.panDelta && e22.panDelta.mag() || e22.zoomDelta || e22.bearingDelta || e22.pitchDelta;
      }
      class tl {
        constructor(t22, i22) {
          this._map = t22, this._el = this._map.getCanvasContainer(), this._handlers = [], this._handlersById = {}, this._changes = [], this._inertia = new da(t22), this._bearingSnap = i22.bearingSnap, this._previousActiveHandlers = {}, this._trackingEllipsoid = new Qa(), this._dragOrigin = null, this._eventsInProgress = {}, this._addDefaultHandlers(i22), e2.aV(["handleEvent", "handleWindowEvent"], this);
          const o2 = this._el;
          this._listeners = [[o2, "touchstart", { passive: true }], [o2, "touchmove", { passive: false }], [o2, "touchend", void 0], [o2, "touchcancel", void 0], [o2, "mousedown", void 0], [o2, "mousemove", void 0], [o2, "mouseup", void 0], [document, "mousemove", { capture: true }], [document, "mouseup", void 0], [o2, "mouseover", void 0], [o2, "mouseout", void 0], [o2, "dblclick", void 0], [o2, "click", void 0], [o2, "keydown", { capture: false }], [o2, "keyup", void 0], [o2, "wheel", { passive: false }], [o2, "contextmenu", void 0], [window, "blur", void 0]];
          for (const [e22, t3, i3] of this._listeners) {
            const o3 = e22 === document ? this.handleWindowEvent : this.handleEvent;
            e22.addEventListener(t3, o3, i3);
          }
        }
        destroy() {
          for (const [e22, t22, i22] of this._listeners) {
            const o2 = e22 === document ? this.handleWindowEvent : this.handleEvent;
            e22.removeEventListener(t22, o2, i22);
          }
        }
        _addDefaultHandlers(e22) {
          const t22 = this._map, i22 = t22.getCanvasContainer();
          this._add("mapEvent", new ga(t22, e22));
          const o2 = t22.boxZoom = new ya(t22, e22);
          this._add("boxZoom", o2);
          const s2 = new Ta(), r22 = new Ha();
          t22.doubleClickZoom = new Za(r22, s2), this._add("tapZoom", s2), this._add("clickZoom", r22);
          const n22 = new Wa();
          this._add("tapDragZoom", n22);
          const a22 = t22.touchPitch = new ka(t22);
          this._add("touchPitch", a22);
          const l22 = new Ra(e22), c22 = new Da(e22);
          t22.dragRotate = new Xa(e22, l22, c22), this._add("mouseRotate", l22, ["mousePitch"]), this._add("mousePitch", c22, ["mouseRotate"]);
          const h22 = new Ca(e22), d22 = new Aa(t22, e22);
          t22.dragPan = new $a(i22, h22, d22), this._add("mousePan", h22), this._add("touchPan", d22, ["touchZoom", "touchRotate"]);
          const u22 = new Fa(), _22 = new Ma();
          t22.touchZoomRotate = new Ya(i22, _22, u22, n22), this._add("touchRotate", u22, ["touchPan", "touchZoom"]), this._add("touchZoom", _22, ["touchPan", "touchRotate"]), this._add("blockableMapEvent", new va(t22));
          const p22 = t22.scrollZoom = new qa(t22, this);
          this._add("scrollZoom", p22, ["mousePan"]);
          const f22 = t22.keyboard = new Ua();
          this._add("keyboard", f22);
          for (const i3 of ["boxZoom", "doubleClickZoom", "tapDragZoom", "touchPitch", "dragRotate", "dragPan", "touchZoomRotate", "scrollZoom", "keyboard"]) e22.interactive && e22[i3] && t22[i3].enable(e22[i3]);
        }
        _add(e22, t22, i22) {
          this._handlers.push({ handlerName: e22, handler: t22, allowed: i22 }), this._handlersById[e22] = t22;
        }
        stop(e22) {
          if (!this._updatingCamera) {
            for (const { handler: e3 } of this._handlers) e3.reset();
            this._inertia.clear(), this._fireEvents({}, {}, e22), this._changes = [], this._originalZoom = void 0;
          }
        }
        isActive() {
          for (const { handler: e22 } of this._handlers) if (e22.isActive()) return true;
          return false;
        }
        isZooming() {
          return !!this._eventsInProgress.zoom || this._map.scrollZoom.isZooming();
        }
        isRotating() {
          return !!this._eventsInProgress.rotate;
        }
        isMoving() {
          return !!Ka(this._eventsInProgress) || this.isZooming();
        }
        _isDragging() {
          return !!this._eventsInProgress.drag;
        }
        _blockedByActive(e22, t22, i22) {
          for (const o2 in e22) if (o2 !== i22 && (!t22 || t22.indexOf(o2) < 0)) return true;
          return false;
        }
        handleWindowEvent(e22) {
          this.handleEvent(e22, `${e22.type}Window`);
        }
        _getMapTouches(e22) {
          const t22 = [];
          for (const i22 of e22) this._el.contains(i22.target) && t22.push(i22);
          return t22;
        }
        handleEvent(e22, t22) {
          this._updatingCamera = true;
          const i22 = "renderFrame" === e22.type, o2 = i22 ? void 0 : e22, s2 = { needsRenderFrame: false }, r22 = {}, n22 = {}, a22 = e22.touches ? this._getMapTouches(e22.touches) : void 0, l22 = a22 ? v2(this._el, a22) : i22 ? void 0 : g2(this._el, e22);
          for (const { handlerName: i3, handler: c3, allowed: h3 } of this._handlers) {
            if (!c3.isEnabled()) continue;
            let d22;
            this._blockedByActive(n22, h3, i3) ? c3.reset() : c3[t22 || e22.type] && (d22 = c3[t22 || e22.type](e22, l22, a22), this.mergeHandlerResult(s2, r22, d22, i3, o2), d22 && d22.needsRenderFrame && this._triggerRenderFrame()), (d22 || c3.isActive()) && (n22[i3] = c3);
          }
          const c22 = {};
          for (const e3 in this._previousActiveHandlers) n22[e3] || (c22[e3] = o2);
          this._previousActiveHandlers = n22, (Object.keys(c22).length || el(s2)) && (this._changes.push([s2, r22, c22]), this._triggerRenderFrame()), (Object.keys(n22).length || el(s2)) && this._map._stop(true), this._updatingCamera = false;
          const { cameraAnimation: h22 } = s2;
          h22 && (this._inertia.clear(), this._fireEvents({}, {}, true), this._changes = [], h22(this._map));
        }
        mergeHandlerResult(t22, i22, o2, s2, r22) {
          if (!o2) return;
          e2.l(t22, o2);
          const n22 = { handlerName: s2, originalEvent: o2.originalEvent || r22 };
          void 0 !== o2.zoomDelta && (i22.zoom = n22), void 0 !== o2.panDelta && (i22.drag = n22), void 0 !== o2.pitchDelta && (i22.pitch = n22), void 0 !== o2.bearingDelta && (i22.rotate = n22);
        }
        _applyChanges() {
          const t22 = {}, i22 = {}, o2 = {};
          for (const [s2, r22, n22] of this._changes) s2.panDelta && (t22.panDelta = (t22.panDelta || new e2.P(0, 0))._add(s2.panDelta)), s2.zoomDelta && (t22.zoomDelta = (t22.zoomDelta || 0) + s2.zoomDelta), s2.bearingDelta && (t22.bearingDelta = (t22.bearingDelta || 0) + s2.bearingDelta), s2.pitchDelta && (t22.pitchDelta = (t22.pitchDelta || 0) + s2.pitchDelta), void 0 !== s2.around && (t22.around = s2.around), void 0 !== s2.aroundCoord && (t22.aroundCoord = s2.aroundCoord), void 0 !== s2.pinchAround && (t22.pinchAround = s2.pinchAround), s2.noInertia && (t22.noInertia = s2.noInertia), e2.l(i22, r22), e2.l(o2, n22);
          this._updateMapTransform(t22, i22, o2), this._changes = [];
        }
        _updateMapTransform(t22, i22, o2) {
          const s2 = this._map, r22 = s2.transform, n22 = (e22) => [e22.x, e22.y, e22.z];
          if (((e22) => {
            const t3 = this._eventsInProgress.drag;
            return t3 && !this._handlersById[t3.handlerName].isActive();
          })() && !el(t22)) {
            const e22 = r22.zoom;
            r22.cameraElevationReference = "sea", null != this._originalZoom && r22._orthographicProjectionAtLowPitch && "globe" !== r22.projection.name && 0 === r22.pitch ? (r22.cameraElevationReference = "ground", r22.zoom = this._originalZoom) : (r22.recenterOnTerrain(), r22.cameraElevationReference = "ground"), e22 !== r22.zoom && this._map._update(true);
          }
          if (r22._isCameraConstrained && s2._stop(true), !el(t22)) return void this._fireEvents(i22, o2, true);
          let { panDelta: a22, zoomDelta: l22, bearingDelta: c22, pitchDelta: h22, around: d22, aroundCoord: u22, pinchAround: _22 } = t22;
          r22._isCameraConstrained && (l22 > 0 && (l22 = 0), r22._isCameraConstrained = false), void 0 !== _22 && (d22 = _22), (l22 || ((e22) => i22[e22] && !this._eventsInProgress[e22])("drag")) && d22 && (this._dragOrigin = n22(r22.pointCoordinate3D(d22)), this._originalZoom = r22.zoom, this._trackingEllipsoid.setup(r22._camera.position, this._dragOrigin)), r22.cameraElevationReference = "sea", s2._stop(true), d22 = d22 || s2.transform.centerPoint, c22 && (r22.bearing += c22), h22 && (r22.pitch += h22), r22._updateCameraState();
          const p22 = [0, 0, 0];
          if (a22) if ("mercator" === r22.projection.name) {
            const e22 = this._trackingEllipsoid.projectRay(r22.screenPointToMercatorRay(d22).dir), t3 = this._trackingEllipsoid.projectRay(r22.screenPointToMercatorRay(d22.sub(a22)).dir);
            p22[0] = t3[0] - e22[0], p22[1] = t3[1] - e22[1];
          } else {
            const t3 = r22.pointCoordinate(d22);
            if ("globe" === r22.projection.name) {
              a22 = a22.rotate(-r22.angle);
              const i3 = r22._pixelsPerMercatorPixel / r22.worldSize;
              p22[0] = -a22.x * e2.ez(e2.aY(t3.y)) * i3, p22[1] = -a22.y * e2.ez(r22.center.lat) * i3;
            } else {
              const e22 = r22.pointCoordinate(d22.sub(a22));
              t3 && e22 && (p22[0] = e22.x - t3.x, p22[1] = e22.y - t3.y);
            }
          }
          const f22 = r22.zoom, m22 = [0, 0, 0];
          if (l22) {
            const t3 = n22(u22 || r22.pointCoordinate3D(d22)), i3 = { dir: e2.au([], e2.at([], t3, r22._camera.position)) };
            if (i3.dir[2] < 0) {
              const o3 = r22.zoomDeltaToMovement(t3, l22);
              e2.b$(m22, i3.dir, o3);
            }
          }
          const g22 = e2.cU(p22, p22, m22);
          r22._translateCameraConstrained(g22), l22 && Math.abs(r22.zoom - f22) > 1e-4 && r22.recenterOnTerrain(), r22.cameraElevationReference = "ground", this._map._update(), t22.noInertia || this._inertia.record(t22), this._fireEvents(i22, o2, true);
        }
        _fireEvents(t22, i22, o2) {
          const s2 = Ka(this._eventsInProgress), r22 = Ka(t22), n22 = {};
          for (const e22 in t22) {
            const { originalEvent: i3 } = t22[e22];
            this._eventsInProgress[e22] || (n22[`${e22}start`] = i3), this._eventsInProgress[e22] = t22[e22];
          }
          !s2 && r22 && this._fireEvent("movestart", r22.originalEvent);
          for (const e22 in n22) this._fireEvent(e22, n22[e22]);
          r22 && this._fireEvent("move", r22.originalEvent);
          for (const e22 in t22) {
            const { originalEvent: i3 } = t22[e22];
            this._fireEvent(e22, i3);
          }
          const a22 = {};
          let l22;
          for (const e22 in this._eventsInProgress) {
            const { handlerName: t3, originalEvent: o3 } = this._eventsInProgress[e22];
            this._handlersById[t3].isActive() || (delete this._eventsInProgress[e22], l22 = i22[t3] || o3, a22[`${e22}end`] = l22);
          }
          for (const e22 in a22) this._fireEvent(e22, a22[e22]);
          const c22 = Ka(this._eventsInProgress);
          if (o2 && (s2 || r22) && !c22) {
            this._updatingCamera = true;
            const t3 = this._inertia._onMoveEnd(this._map.dragPan._inertiaOptions), i3 = (e22) => 0 !== e22 && -this._bearingSnap < e22 && e22 < this._bearingSnap;
            t3 ? (i3(t3.bearing || this._map.getBearing()) && (t3.bearing = 0), this._map.easeTo(t3, { originalEvent: l22 })) : (this._map.fire(new e2.A("moveend", { originalEvent: l22 })), i3(this._map.getBearing()) && this._map.resetNorth()), this._updatingCamera = false;
          }
        }
        _fireEvent(t22, i22) {
          this._map.fire(new e2.A(t22, i22 ? { originalEvent: i22 } : {}));
        }
        _requestFrame() {
          return this._map.triggerRepaint(), this._map._renderTaskQueue.add((e22) => {
            this._frameId = void 0, this.handleEvent(new Ja("renderFrame", { timeStamp: e22 })), this._applyChanges();
          });
        }
        _triggerRenderFrame() {
          void 0 === this._frameId && (this._frameId = this._requestFrame());
        }
      }
      const il = "map.setFreeCameraOptions(...) and map.getFreeCameraOptions() are not yet supported for non-mercator projections.";
      class ol extends e2.E {
        constructor(t22, i22) {
          super(), this._moving = false, this._zooming = false, this.transform = t22, this._bearingSnap = i22.bearingSnap, this._respectPrefersReducedMotion = false !== i22.respectPrefersReducedMotion, e2.aV(["_renderFrameCallback"], this);
        }
        getCenter() {
          return new e2.cd(this.transform.center.lng, this.transform.center.lat);
        }
        setCenter(e22, t22) {
          return this.jumpTo({ center: e22 }, t22);
        }
        panBy(t22, i22, o2) {
          return t22 = e2.P.convert(t22).mult(-1), this.panTo(this.transform.center, e2.l({ offset: t22 }, i22), o2);
        }
        panTo(t22, i22, o2) {
          return this.easeTo(e2.l({ center: t22 }, i22), o2);
        }
        getZoom() {
          return this.transform.zoom;
        }
        setZoom(e22, t22) {
          return this.jumpTo({ zoom: e22 }, t22), this;
        }
        zoomTo(t22, i22, o2) {
          return this.easeTo(e2.l({ zoom: t22 }, i22), o2);
        }
        zoomIn(e22, t22) {
          return this.zoomTo(this.getZoom() + 1, e22, t22), this;
        }
        zoomOut(e22, t22) {
          return this.zoomTo(this.getZoom() - 1, e22, t22), this;
        }
        getBearing() {
          return this.transform.bearing;
        }
        setBearing(e22, t22) {
          return this.jumpTo({ bearing: e22 }, t22), this;
        }
        getPadding() {
          return this.transform.padding;
        }
        setPadding(e22, t22) {
          return this.jumpTo({ padding: e22 }, t22), this;
        }
        rotateTo(t22, i22, o2) {
          return this.easeTo(e2.l({ bearing: t22 }, i22), o2);
        }
        resetNorth(t22, i22) {
          return this.rotateTo(0, e2.l({ duration: 1e3 }, t22), i22), this;
        }
        resetNorthPitch(t22, i22) {
          return this.easeTo(e2.l({ bearing: 0, pitch: 0, duration: 1e3 }, t22), i22), this;
        }
        snapToNorth(e22, t22) {
          return Math.abs(this.getBearing()) < this._bearingSnap ? this.resetNorth(e22, t22) : this;
        }
        getPitch() {
          return this.transform.pitch;
        }
        setPitch(e22, t22) {
          return this.jumpTo({ pitch: e22 }, t22), this;
        }
        cameraForBounds(t22, i22) {
          t22 = e2.aG.convert(t22);
          const o2 = i22 && i22.bearing || 0, s2 = i22 && i22.pitch || 0, r22 = t22.getNorthWest(), n22 = t22.getSouthEast();
          return this._cameraForBounds(this.transform, r22, n22, o2, s2, i22);
        }
        _extendPadding(t22) {
          const i22 = { top: 0, right: 0, bottom: 0, left: 0 };
          return null == t22 ? e2.l({}, i22, this.transform.padding) : "number" == typeof t22 ? { top: t22, bottom: t22, right: t22, left: t22 } : e2.l({}, i22, t22);
        }
        _extendCameraOptions(t22) {
          return (t22 = e2.l({ offset: [0, 0], maxZoom: this.transform.maxZoom }, t22)).padding = this._extendPadding(t22.padding), t22;
        }
        _minimumAABBFrustumDistance(e22, t22) {
          const i22 = t22.max[0] - t22.min[0], o2 = t22.max[1] - t22.min[1];
          return i22 / o2 > e22.aspect ? i22 / (2 * Math.tan(0.5 * e22.fovX) * e22.aspect) : o2 / (2 * Math.tan(0.5 * e22.fovY) * e22.aspect);
        }
        _cameraForBoundsOnGlobe(t22, i22, o2, s2, r22, n22) {
          const a22 = t22.clone(), l22 = this._extendCameraOptions(n22);
          a22.bearing = s2, a22.pitch = r22;
          const c22 = e2.cd.convert(i22), h22 = e2.cd.convert(o2), d22 = 0.5 * (c22.lat + h22.lat), u22 = 0.5 * (c22.lng + h22.lng), _22 = e2.eC(d22, u22), p22 = e2.au([], _22), f22 = e2.au([], e2.bG([], p22, [0, 1, 0])), m22 = e2.bG([], f22, p22), g22 = [f22[0], f22[1], f22[2], 0, m22[0], m22[1], m22[2], 0, p22[0], p22[1], p22[2], 0, 0, 0, 0, 1], v22 = [_22, e2.eC(c22.lat, c22.lng), e2.eC(h22.lat, c22.lng), e2.eC(h22.lat, h22.lng), e2.eC(c22.lat, h22.lng), e2.eC(d22, c22.lng), e2.eC(d22, h22.lng), e2.eC(c22.lat, u22), e2.eC(h22.lat, u22)];
          let y22 = e2.cV.fromPoints(v22.map((t3) => [e2.bE(f22, t3), e2.bE(m22, t3), e2.bE(p22, t3)]));
          const x22 = e2.ad([], y22.center, g22);
          0 === e2.eD(x22) && e2.eE(x22, 0, 0, 1), e2.au(x22, x22), e2.b$(x22, x22, e2.aE), a22.center = e2.eF(x22);
          const b22 = a22.getWorldToCameraMatrix(), w22 = e2.bi(new Float64Array(16), b22);
          y22 = e2.cV.applyTransform(y22, e2.az([], b22, g22));
          const T2 = this._extendAABB(y22, a22, l22, s2);
          if (!T2) return void e2.w("Map cannot fit within canvas with the given bounds, padding, and/or offset.");
          y22 = T2, e2.ad(x22, x22, b22);
          const E22 = 0.5 * (y22.max[2] - y22.min[2]), S2 = this._minimumAABBFrustumDistance(a22, y22), I2 = e2.b$([], [0, 0, 1], E22), C22 = e2.cU(I2, x22, I2), R22 = S2 + (0 === a22.pitch ? 0 : e2.bD(x22, C22)), D22 = a22.globeCenterInViewSpace, A22 = e2.at([], x22, [D22[0], D22[1], D22[2]]);
          e2.au(A22, A22), e2.b$(A22, A22, R22);
          const L22 = e2.cU([], x22, A22);
          e2.ad(L22, L22, w22);
          const P22 = e2.eq / e2.aE, z22 = e2.ae(L22), M22 = e2.c6(Math.max(z22 * P22 - e2.eq, Number.EPSILON), 0), O2 = Math.min(a22.zoomFromMercatorZAdjusted(M22), l22.maxZoom);
          return O2 > 0.5 * (e2.cL + e2.cx) ? (a22.setProjection({ name: "mercator" }), a22.zoom = O2, this._cameraForBounds(a22, i22, o2, s2, r22, n22)) : { center: a22.center, zoom: O2, bearing: s2, pitch: r22 };
        }
        _extendAABB(t22, i22, o2, s2) {
          const r22 = 0.5 * ((o2.padding.left || 0) + (o2.padding.right || 0)), n22 = 0.5 * ((o2.padding.top || 0) + (o2.padding.bottom || 0)), a22 = n22, l22 = r22, c22 = r22, h22 = n22, d22 = i22.width - (l22 + c22), u22 = i22.height - (a22 + h22), _22 = e2.at([], t22.max, t22.min), p22 = Math.min(d22 / _22[0], u22 / _22[1]), f22 = Math.min(i22.scaleZoom(i22.scale * p22), o2.maxZoom);
          if (isNaN(f22)) return null;
          const m22 = i22.scale / i22.zoomScale(f22), g22 = new e2.cV([t22.min[0] - l22 * m22, t22.min[1] - h22 * m22, t22.min[2]], [t22.max[0] + c22 * m22, t22.max[1] + a22 * m22, t22.max[2]]), v22 = ("number" == typeof o2.offset.x && "number" == typeof o2.offset.y ? new e2.P(o2.offset.x, o2.offset.y) : e2.P.convert(o2.offset)).rotate(-e2.al(s2));
          return g22.center[0] -= v22.x * m22, g22.center[1] += v22.y * m22, g22;
        }
        queryTerrainElevation(t22, i22) {
          const o2 = this.transform.elevation;
          return o2 ? (i22 = e2.l({}, { exaggerated: true }, i22), o2.getAtPoint(e2.ac.fromLngLat(t22), null, i22.exaggerated)) : null;
        }
        _cameraForBounds(t22, i22, o2, s2, r22, n22) {
          if ("globe" === t22.projection.name) return this._cameraForBoundsOnGlobe(t22, i22, o2, s2, r22, n22);
          const a22 = t22.clone(), l22 = this._extendCameraOptions(n22);
          a22.bearing = s2, a22.pitch = r22;
          const c22 = e2.cd.convert(i22), h22 = e2.cd.convert(o2), d22 = new e2.cd(c22.lng, h22.lat), u22 = new e2.cd(h22.lng, c22.lat), _22 = a22.project(c22), p22 = a22.project(h22), f22 = this.queryTerrainElevation(c22), m22 = this.queryTerrainElevation(h22), g22 = this.queryTerrainElevation(d22), v22 = this.queryTerrainElevation(u22), y22 = [[_22.x, _22.y, Math.min(f22 || 0, m22 || 0, g22 || 0, v22 || 0)], [p22.x, p22.y, Math.max(f22 || 0, m22 || 0, g22 || 0, v22 || 0)]];
          let x22 = e2.cV.fromPoints(y22);
          const b22 = a22.getWorldToCameraMatrix(), w22 = e2.bi(new Float64Array(16), b22);
          x22 = e2.cV.applyTransform(x22, b22);
          const T2 = this._extendAABB(x22, a22, l22, s2);
          if (!T2) return void e2.w("Map cannot fit within canvas with the given bounds, padding, and/or offset.");
          x22 = T2;
          const E22 = 0.5 * e2.at([], x22.max, x22.min)[2], S2 = this._minimumAABBFrustumDistance(a22, x22), I2 = [0, 0, 1, 0];
          e2.aA(I2, I2, b22), e2.eG(I2, I2);
          const C22 = e2.b$([], I2, S2 + E22), R22 = e2.cU([], x22.center, C22);
          e2.ad(x22.center, x22.center, w22), e2.ad(R22, R22, w22);
          const D22 = a22.unproject(new e2.P(x22.center[0], x22.center[1])), A22 = e2.eH(a22.projection, D22), L22 = Math.pow(2, A22), P22 = Math.min(a22._zoomFromMercatorZ(R22[2] * a22.pixelsPerMeter * L22 / a22.worldSize), l22.maxZoom);
          return a22.mercatorFromTransition && P22 < 0.5 * (e2.cL + e2.cx) ? (a22.setProjection({ name: "globe" }), a22.zoom = P22, this._cameraForBounds(a22, i22, o2, s2, r22, n22)) : { center: D22, zoom: P22, bearing: s2, pitch: r22 };
        }
        fitBounds(e22, t22, i22) {
          const o2 = this.cameraForBounds(e22, t22);
          return this._fitInternal(o2, t22, i22);
        }
        fitScreenCoordinates(t22, i22, o2, s2, r22) {
          const n22 = e2.P.convert(t22), a22 = e2.P.convert(i22), l22 = new e2.P(Math.min(n22.x, a22.x), Math.min(n22.y, a22.y)), c22 = new e2.P(Math.max(n22.x, a22.x), Math.max(n22.y, a22.y));
          if ("mercator" === this.transform.projection.name && this.transform.anyCornerOffEdge(n22, a22)) return this;
          const h22 = this.transform.pointLocation3D(l22), d22 = this.transform.pointLocation3D(c22), u22 = this.transform.pointLocation3D(new e2.P(l22.x, c22.y)), _22 = this.transform.pointLocation3D(new e2.P(c22.x, l22.y)), p22 = [Math.min(h22.lng, d22.lng, u22.lng, _22.lng), Math.min(h22.lat, d22.lat, u22.lat, _22.lat)], f22 = [Math.max(h22.lng, d22.lng, u22.lng, _22.lng), Math.max(h22.lat, d22.lat, u22.lat, _22.lat)], m22 = s2 && s2.pitch ? s2.pitch : this.getPitch(), g22 = this._cameraForBounds(this.transform, p22, f22, o2, m22, s2);
          return this._fitInternal(g22, s2, r22);
        }
        _fitInternal(t22, i22, o2) {
          return t22 ? (i22 = e2.l(t22, i22)).linear ? this.easeTo(i22, o2) : this.flyTo(i22, o2) : this;
        }
        jumpTo(t22, i22) {
          this.stop();
          const o2 = t22.preloadOnly ? this.transform.clone() : this.transform;
          let s2 = false, r22 = false, n22 = false;
          "zoom" in t22 && o2.zoom !== +t22.zoom && (s2 = true, o2.zoom = +t22.zoom), void 0 !== t22.center && (o2.center = e2.cd.convert(t22.center)), "bearing" in t22 && o2.bearing !== +t22.bearing && (r22 = true, o2.bearing = +t22.bearing), "pitch" in t22 && o2.pitch !== +t22.pitch && (n22 = true, o2.pitch = +t22.pitch);
          const a22 = "number" == typeof t22.padding ? this._extendPadding(t22.padding) : t22.padding;
          if (null != t22.padding && !o2.isPaddingEqual(a22)) if (false === t22.retainPadding) {
            const e22 = o2.clone();
            e22.padding = a22, o2.setLocationAtPoint(o2.center, e22.centerPoint);
          } else o2.padding = a22;
          return t22.preloadOnly ? (this._preloadTiles(o2), this) : (this.fire(new e2.A("movestart", i22)).fire(new e2.A("move", i22)), s2 && this.fire(new e2.A("zoomstart", i22)).fire(new e2.A("zoom", i22)).fire(new e2.A("zoomend", i22)), r22 && this.fire(new e2.A("rotatestart", i22)).fire(new e2.A("rotate", i22)).fire(new e2.A("rotateend", i22)), n22 && this.fire(new e2.A("pitchstart", i22)).fire(new e2.A("pitch", i22)).fire(new e2.A("pitchend", i22)), this.fire(new e2.A("moveend", i22)));
        }
        getFreeCameraOptions() {
          return this.transform.projection.supportsFreeCamera || e2.w(il), this.transform.getFreeCameraOptions();
        }
        setFreeCameraOptions(t22, i22) {
          const o2 = this.transform;
          if (!o2.projection.supportsFreeCamera) return e2.w(il), this;
          this.stop();
          const s2 = o2.zoom, r22 = o2.pitch, n22 = o2.bearing;
          o2.setFreeCameraOptions(t22);
          const a22 = s2 !== o2.zoom, l22 = r22 !== o2.pitch, c22 = n22 !== o2.bearing;
          return this.fire(new e2.A("movestart", i22)).fire(new e2.A("move", i22)), a22 && this.fire(new e2.A("zoomstart", i22)).fire(new e2.A("zoom", i22)).fire(new e2.A("zoomend", i22)), c22 && this.fire(new e2.A("rotatestart", i22)).fire(new e2.A("rotate", i22)).fire(new e2.A("rotateend", i22)), l22 && this.fire(new e2.A("pitchstart", i22)).fire(new e2.A("pitch", i22)).fire(new e2.A("pitchend", i22)), this.fire(new e2.A("moveend", i22)), this;
        }
        easeTo(t22, i22) {
          this._stop(false, t22.easeId), (false === (t22 = e2.l({ offset: [0, 0], duration: 500, easing: e2.ey }, t22)).animate || this._prefersReducedMotion(t22)) && (t22.duration = 0);
          const o2 = this.transform, s2 = this.getZoom(), r22 = this.getBearing(), n22 = this.getPitch(), a22 = this.getPadding(), l22 = "zoom" in t22 ? +t22.zoom : s2, c22 = "bearing" in t22 ? this._normalizeBearing(t22.bearing, r22) : r22, h22 = "pitch" in t22 ? +t22.pitch : n22, d22 = this._extendPadding(t22.padding), u22 = e2.P.convert(t22.offset);
          let _22, p22, f22;
          if ("globe" === o2.projection.name) {
            const i3 = e2.ac.fromLngLat(o2.center), s3 = u22.rotate(-o2.angle);
            i3.x += s3.x / o2.worldSize, i3.y += s3.y / o2.worldSize;
            const r3 = i3.toLngLat(), n3 = e2.cd.convert(t22.center || r3);
            this._normalizeCenter(n3), _22 = o2.centerPoint.add(s3), p22 = new e2.P(i3.x, i3.y).mult(o2.worldSize), f22 = new e2.P(e2.ay(n3.lng), e2.aH(n3.lat)).mult(o2.worldSize).sub(p22);
          } else {
            _22 = o2.centerPoint.add(u22);
            const i3 = o2.pointLocation(_22), s3 = e2.cd.convert(t22.center || i3);
            this._normalizeCenter(s3), p22 = o2.project(i3), f22 = o2.project(s3).sub(p22);
          }
          const m22 = o2.zoomScale(l22 - s2);
          let g22, v22;
          t22.around && (g22 = e2.cd.convert(t22.around), v22 = o2.locationPoint(g22));
          const y22 = this._zooming || l22 !== s2, x22 = this._rotating || r22 !== c22, b22 = this._pitching || h22 !== n22, w22 = !o2.isPaddingEqual(d22), T2 = false === t22.retainPadding ? o2.clone() : o2, E22 = (o3) => (E3) => {
            if (y22 && (o3.zoom = e2.ai(s2, l22, E3)), x22 && (o3.bearing = e2.ai(r22, c22, E3)), b22 && (o3.pitch = e2.ai(n22, h22, E3)), w22 && (T2.interpolatePadding(a22, d22, E3), _22 = T2.centerPoint.add(u22)), g22) o3.setLocationAtPoint(g22, v22);
            else {
              const e22 = o3.zoomScale(o3.zoom - s2), t3 = l22 > s2 ? Math.min(2, m22) : Math.max(0.5, m22), i3 = Math.pow(t3, 1 - E3), r3 = o3.unproject(p22.add(f22.mult(E3 * i3)).mult(e22));
              o3.setLocationAtPoint(o3.renderWorldCopies ? r3.wrap() : r3, _22);
            }
            return t22.preloadOnly || this._fireMoveEvents(i22), o3;
          };
          if (t22.preloadOnly) {
            const e22 = this._emulate(E22, t22.duration, o2);
            return this._preloadTiles(e22), this;
          }
          const S2 = { moving: this._moving, zooming: this._zooming, rotating: this._rotating, pitching: this._pitching };
          return this._zooming = y22, this._rotating = x22, this._pitching = b22, this._padding = w22, this._easeId = t22.easeId, this._prepareEase(i22, t22.noMoveStart, S2), this._ease(E22(o2), (e22) => {
            "sea" === o2.cameraElevationReference && o2.recenterOnTerrain(), this._afterEase(i22, e22);
          }, t22), this;
        }
        _prepareEase(t22, i22, o2 = {}) {
          this._moving = true, this.transform.cameraElevationReference = "sea", this.transform._orthographicProjectionAtLowPitch && 0 === this.transform.pitch && "globe" !== this.transform.projection.name && (this.transform.cameraElevationReference = "ground"), i22 || o2.moving || this.fire(new e2.A("movestart", t22)), this._zooming && !o2.zooming && this.fire(new e2.A("zoomstart", t22)), this._rotating && !o2.rotating && this.fire(new e2.A("rotatestart", t22)), this._pitching && !o2.pitching && this.fire(new e2.A("pitchstart", t22));
        }
        _fireMoveEvents(t22) {
          this.fire(new e2.A("move", t22)), this._zooming && this.fire(new e2.A("zoom", t22)), this._rotating && this.fire(new e2.A("rotate", t22)), this._pitching && this.fire(new e2.A("pitch", t22));
        }
        _afterEase(t22, i22) {
          if (this._easeId && i22 && this._easeId === i22) return;
          this._easeId = void 0, this.transform.cameraElevationReference = "ground";
          const o2 = this._zooming, s2 = this._rotating, r22 = this._pitching;
          this._moving = false, this._zooming = false, this._rotating = false, this._pitching = false, this._padding = false, o2 && this.fire(new e2.A("zoomend", t22)), s2 && this.fire(new e2.A("rotateend", t22)), r22 && this.fire(new e2.A("pitchend", t22)), this.fire(new e2.A("moveend", t22));
        }
        flyTo(t22, i22) {
          if (this._prefersReducedMotion(t22)) {
            const o3 = e2.aF(t22, ["center", "zoom", "bearing", "pitch", "around", "padding", "retainPadding"]);
            return this.jumpTo(o3, i22);
          }
          this.stop(), t22 = e2.l({ offset: [0, 0], speed: 1.2, curve: 1.42, easing: e2.ey }, t22);
          const o2 = this.transform, s2 = this.getZoom(), r22 = this.getBearing(), n22 = this.getPitch(), a22 = this.getPadding(), l22 = "zoom" in t22 ? e2.aD(+t22.zoom, o2.minZoom, o2.maxZoom) : s2, c22 = "bearing" in t22 ? this._normalizeBearing(t22.bearing, r22) : r22, h22 = "pitch" in t22 ? +t22.pitch : n22, d22 = this._extendPadding(t22.padding), u22 = o2.zoomScale(l22 - s2), _22 = e2.P.convert(t22.offset);
          let p22 = o2.centerPoint.add(_22);
          const f22 = o2.pointLocation(p22), m22 = e2.cd.convert(t22.center || f22);
          this._normalizeCenter(m22);
          const g22 = o2.project(f22), v22 = o2.project(m22).sub(g22);
          let y22 = t22.curve;
          const x22 = Math.max(o2.width, o2.height), b22 = x22 / u22, w22 = v22.mag();
          if ("minZoom" in t22) {
            const i3 = e2.aD(Math.min(t22.minZoom, s2, l22), o2.minZoom, o2.maxZoom), r3 = x22 / o2.zoomScale(i3 - s2);
            y22 = Math.sqrt(r3 / w22 * 2);
          }
          const T2 = y22 * y22;
          function E22(e22) {
            const t3 = (b22 * b22 - x22 * x22 + (e22 ? -1 : 1) * T2 * T2 * w22 * w22) / (2 * (e22 ? b22 : x22) * T2 * w22);
            return Math.log(Math.sqrt(t3 * t3 + 1) - t3);
          }
          function S2(e22) {
            return (Math.exp(e22) - Math.exp(-e22)) / 2;
          }
          function I2(e22) {
            return (Math.exp(e22) + Math.exp(-e22)) / 2;
          }
          const C22 = E22(0);
          let R22 = function(e22) {
            return I2(C22) / I2(C22 + y22 * e22);
          }, D22 = function(e22) {
            return x22 * ((I2(C22) * (S2(t3 = C22 + y22 * e22) / I2(t3)) - S2(C22)) / T2) / w22;
            var t3;
          }, A22 = (E22(1) - C22) / y22;
          if (Math.abs(w22) < 1e-6 || !isFinite(A22)) {
            if (Math.abs(x22 - b22) < 1e-6) return this.easeTo(t22, i22);
            const e22 = b22 < x22 ? -1 : 1;
            A22 = Math.abs(Math.log(b22 / x22)) / y22, D22 = function() {
              return 0;
            }, R22 = function(t3) {
              return Math.exp(e22 * y22 * t3);
            };
          }
          t22.duration = "duration" in t22 ? +t22.duration : 1e3 * A22 / ("screenSpeed" in t22 ? +t22.screenSpeed / y22 : +t22.speed), t22.maxDuration && t22.duration > t22.maxDuration && (t22.duration = 0);
          const L22 = r22 !== c22, P22 = h22 !== n22, z22 = !o2.isPaddingEqual(d22), M22 = false === t22.retainPadding ? o2.clone() : o2, O2 = (o3) => (u3) => {
            const f3 = u3 * A22, y3 = 1 / R22(f3);
            o3.zoom = 1 === u3 ? l22 : s2 + o3.scaleZoom(y3), L22 && (o3.bearing = e2.ai(r22, c22, u3)), P22 && (o3.pitch = e2.ai(n22, h22, u3)), z22 && (M22.interpolatePadding(a22, d22, u3), p22 = M22.centerPoint.add(_22));
            const x3 = 1 === u3 ? m22 : o3.unproject(g22.add(v22.mult(D22(f3))).mult(y3));
            return o3.setLocationAtPoint(o3.renderWorldCopies ? x3.wrap() : x3, p22), o3._updateCameraOnTerrain(), t22.preloadOnly || this._fireMoveEvents(i22), o3;
          };
          if (t22.preloadOnly) {
            const e22 = this._emulate(O2, t22.duration, o2);
            return this._preloadTiles(e22), this;
          }
          return this._zooming = true, this._rotating = L22, this._pitching = P22, this._padding = z22, this._prepareEase(i22, false), this._ease(O2(o2), () => this._afterEase(i22), t22), this;
        }
        isEasing() {
          return !!this._easeFrameId;
        }
        stop() {
          return this._stop();
        }
        _requestRenderFrame(e22) {
        }
        _cancelRenderFrame(e22) {
        }
        _stop(e22, t22) {
          if (this._easeFrameId && (this._cancelRenderFrame(this._easeFrameId), this._easeFrameId = void 0, this._onEaseFrame = void 0), this._onEaseEnd) {
            const e3 = this._onEaseEnd;
            this._onEaseEnd = void 0, e3.call(this, t22);
          }
          if (!e22) {
            const e3 = this.handlers;
            e3 && e3.stop(false);
          }
          return this;
        }
        _ease(t22, i22, o2) {
          false === o2.animate || 0 === o2.duration ? (t22(1), i22()) : (this._easeStart = e2.q.now(), this._easeOptions = o2, this._onEaseFrame = t22, this._onEaseEnd = i22, this._easeFrameId = this._requestRenderFrame(this._renderFrameCallback));
        }
        _renderFrameCallback() {
          const t22 = Math.min((e2.q.now() - this._easeStart) / this._easeOptions.duration, 1), i22 = this._onEaseFrame;
          i22 && i22(this._easeOptions.easing(t22)), t22 < 1 ? this._easeFrameId = this._requestRenderFrame(this._renderFrameCallback) : this.stop();
        }
        _normalizeBearing(t22, i22) {
          t22 = e2.bX(t22, -180, 180);
          const o2 = Math.abs(t22 - i22);
          return Math.abs(t22 - 360 - i22) < o2 && (t22 -= 360), Math.abs(t22 + 360 - i22) < o2 && (t22 += 360), t22;
        }
        _normalizeCenter(e22) {
          const t22 = this.transform;
          if (t22.maxBounds) return;
          if ("globe" !== t22.projection.name && !t22.renderWorldCopies) return;
          const i22 = e22.lng - t22.center.lng;
          e22.lng += i22 > 180 ? -360 : i22 < -180 ? 360 : 0;
        }
        _prefersReducedMotion(t22) {
          return this._respectPrefersReducedMotion && e2.q.prefersReducedMotion && !(t22 && t22.essential);
        }
        _emulate(e22, t22, i22) {
          const o2 = Math.ceil(15 * t22 / 1e3), s2 = [], r22 = e22(i22.clone());
          for (let e3 = 0; e3 <= o2; e3++) {
            const t3 = r22(e3 / o2);
            s2.push(t3.clone());
          }
          return s2;
        }
        _preloadTiles(e22, t22) {
        }
      }
      class sl {
        constructor(t22 = {}) {
          this.options = t22, e2.aV(["_toggleAttribution", "_updateEditLink", "_updateData", "_updateCompact"], this);
        }
        getDefaultPosition() {
          return "bottom-right";
        }
        onAdd(e22) {
          const t22 = this.options && this.options.compact, i22 = e22._getUIString("AttributionControl.ToggleAttribution");
          this._map = e22, this._container = l2("div", "mapboxgl-ctrl mapboxgl-ctrl-attrib"), this._compactButton = l2("button", "mapboxgl-ctrl-attrib-button", this._container), this._compactButton.type = "button", this._compactButton.addEventListener("click", this._toggleAttribution), this._compactButton.setAttribute("aria-label", i22);
          const o2 = l2("span", "mapboxgl-ctrl-icon", this._compactButton);
          return o2.setAttribute("aria-hidden", "true"), o2.setAttribute("title", i22), this._innerContainer = l2("div", "mapboxgl-ctrl-attrib-inner", this._container), t22 && this._container.classList.add("mapboxgl-compact"), this._updateAttributions(), this._updateEditLink(), this._map.on("styledata", this._updateData), this._map.on("sourcedata", this._updateData), this._map.on("moveend", this._updateEditLink), void 0 === t22 && (this._map.on("resize", this._updateCompact), this._updateCompact()), this._container;
        }
        onRemove() {
          this._container.remove(), this._map.off("styledata", this._updateData), this._map.off("sourcedata", this._updateData), this._map.off("moveend", this._updateEditLink), this._map.off("resize", this._updateCompact), this._map = void 0, this._attribHTML = void 0;
        }
        _toggleAttribution() {
          this._container.classList.contains("mapboxgl-compact-show") ? (this._container.classList.remove("mapboxgl-compact-show"), this._compactButton.setAttribute("aria-expanded", "false")) : (this._container.classList.add("mapboxgl-compact-show"), this._compactButton.setAttribute("aria-expanded", "true"));
        }
        _updateEditLink() {
          let t22 = this._editLink;
          t22 || (t22 = this._editLink = this._container.querySelector(".mapbox-improve-map"));
          const i22 = [{ key: "owner", value: this.styleOwner }, { key: "id", value: this.styleId }, { key: "access_token", value: this._map._requestManager._customAccessToken || e2.e.ACCESS_TOKEN }];
          if (t22) {
            const o2 = i22.reduce((e22, t3, o3) => (t3.value && (e22 += `${t3.key}=${t3.value}${o3 < i22.length - 1 ? "&" : ""}`), e22), "?");
            t22.href = `${e2.e.FEEDBACK_URL}/${o2}#${ra(this._map, true)}`, t22.rel = "noopener nofollow";
          }
        }
        _updateData(e22) {
          !e22 || "metadata" !== e22.sourceDataType && "visibility" !== e22.sourceDataType && "style" !== e22.dataType || (this._updateAttributions(), this._updateEditLink());
        }
        _updateAttributions() {
          if (!this._map.style) return;
          let e22 = [];
          if (this._map.style.stylesheet) {
            const e3 = this._map.style.stylesheet;
            this.styleOwner = e3.owner, this.styleId = e3.id;
          }
          const t22 = this._map.style._mergedSourceCaches;
          for (const i3 in t22) {
            const o2 = t22[i3];
            if (o2.used) {
              const t3 = o2.getSource();
              t3.attribution && e22.indexOf(t3.attribution) < 0 && e22.push(t3.attribution);
            }
          }
          e22.sort((e3, t3) => e3.length - t3.length), e22 = e22.filter((t3, i3) => {
            for (let o2 = i3 + 1; o2 < e22.length; o2++) if (e22[o2].indexOf(t3) >= 0) return false;
            return true;
          }), this.options.customAttribution && (Array.isArray(this.options.customAttribution) ? e22 = [...this.options.customAttribution, ...e22] : e22.unshift(this.options.customAttribution));
          const i22 = e22.join(" | ");
          i22 !== this._attribHTML && (this._attribHTML = i22, e22.length ? (this._innerContainer.innerHTML = i22, this._container.classList.remove("mapboxgl-attrib-empty")) : this._container.classList.add("mapboxgl-attrib-empty"), this._editLink = null);
        }
        _updateCompact() {
          this._map.getCanvasContainer().offsetWidth <= 640 ? this._container.classList.add("mapboxgl-compact") : this._container.classList.remove("mapboxgl-compact", "mapboxgl-compact-show");
        }
      }
      class rl {
        constructor() {
          e2.aV(["_updateLogo", "_updateCompact"], this);
        }
        onAdd(e22) {
          this._map = e22, this._container = l2("div", "mapboxgl-ctrl");
          const t22 = l2("a", "mapboxgl-ctrl-logo");
          return t22.target = "_blank", t22.rel = "noopener nofollow", t22.href = "https://www.mapbox.com/", t22.setAttribute("aria-label", this._map._getUIString("LogoControl.Title")), t22.setAttribute("rel", "noopener nofollow"), this._container.appendChild(t22), this._container.style.display = "none", this._map.on("sourcedata", this._updateLogo), this._updateLogo(), this._map.on("resize", this._updateCompact), this._updateCompact(), this._container;
        }
        onRemove() {
          this._container.remove(), this._map.off("sourcedata", this._updateLogo), this._map.off("resize", this._updateCompact);
        }
        getDefaultPosition() {
          return "bottom-left";
        }
        _updateLogo(e22) {
          e22 && "metadata" !== e22.sourceDataType || (this._container.style.display = this._logoRequired() ? "block" : "none");
        }
        _logoRequired() {
          if (!this._map.style) return true;
          const e22 = this._map.style._sourceCaches;
          if (0 === Object.entries(e22).length) return true;
          for (const t22 in e22) {
            const i22 = e22[t22].getSource();
            if (i22.hasOwnProperty("mapbox_logo") && !i22.mapbox_logo) return false;
          }
          return true;
        }
        _updateCompact() {
          const e22 = this._container.children;
          if (e22.length) {
            const t22 = e22[0];
            this._map.getCanvasContainer().offsetWidth < 250 ? t22.classList.add("mapboxgl-compact") : t22.classList.remove("mapboxgl-compact");
          }
        }
      }
      class nl {
        constructor() {
          this._queue = [], this._id = 0, this._cleared = false, this._currentlyRunning = false;
        }
        add(e22) {
          const t22 = ++this._id;
          return this._queue.push({ callback: e22, id: t22, cancelled: false }), t22;
        }
        remove(e22) {
          const t22 = this._currentlyRunning, i22 = t22 ? this._queue.concat(t22) : this._queue;
          for (const t3 of i22) if (t3.id === e22) return void (t3.cancelled = true);
        }
        run(e22 = 0) {
          const t22 = this._currentlyRunning = this._queue;
          this._queue = [];
          for (const i22 of t22) if (!i22.cancelled && (i22.callback(e22), this._cleared)) break;
          this._cleared = false, this._currentlyRunning = false;
        }
        clear() {
          this._currentlyRunning && (this._cleared = true), this._queue = [];
        }
      }
      class al {
        constructor(e22) {
          this.jumpTo(e22);
        }
        getValue(t22) {
          if (t22 <= this._startTime) return this._start;
          if (t22 >= this._endTime) return this._end;
          const i22 = e2.dk((t22 - this._startTime) / (this._endTime - this._startTime));
          return this._start * (1 - i22) + this._end * i22;
        }
        isEasing(e22) {
          return e22 >= this._startTime && e22 <= this._endTime;
        }
        jumpTo(e22) {
          this._startTime = -1 / 0, this._endTime = -1 / 0, this._start = e22, this._end = e22;
        }
        easeTo(e22, t22, i22) {
          this._start = this.getValue(t22), this._end = e22, this._startTime = t22, this._endTime = t22 + i22;
        }
      }
      const ll = { "AttributionControl.ToggleAttribution": "Toggle attribution", "FullscreenControl.Enter": "Enter fullscreen", "FullscreenControl.Exit": "Exit fullscreen", "GeolocateControl.FindMyLocation": "Find my location", "GeolocateControl.LocationNotAvailable": "Location not available", "LogoControl.Title": "Mapbox homepage", "Map.Title": "Map", "NavigationControl.ResetBearing": "Reset bearing to north", "NavigationControl.ZoomIn": "Zoom in", "NavigationControl.ZoomOut": "Zoom out", "ScrollZoomBlocker.CtrlMessage": "Use ctrl + scroll to zoom the map", "ScrollZoomBlocker.CmdMessage": "Use ⌘ + scroll to zoom the map", "TouchPanBlocker.Message": "Use two fingers to move the map" };
      class cl extends e2.A {
        constructor(e22, t22, i22, o2) {
          const { point: s2, lngLat: r22, originalEvent: n22, target: a22 } = e22;
          super(e22.type, { point: s2, lngLat: r22, originalEvent: n22, target: a22 }), this.preventDefault = () => {
            e22.preventDefault();
          }, this.id = t22, this.interaction = i22, this.feature = o2;
        }
      }
      class hl {
        constructor(e22) {
          this.map = e22, this.interactionsByType = /* @__PURE__ */ new Map(), this.delegatedInteractions = /* @__PURE__ */ new Map(), this.typeById = /* @__PURE__ */ new Map(), this.filters = /* @__PURE__ */ new Map(), this.handleType = this.handleType.bind(this), this.handleMove = this.handleMove.bind(this), this.handleOut = this.handleOut.bind(this), this.hoveredFeatures = /* @__PURE__ */ new Map(), this.prevHoveredFeatures = /* @__PURE__ */ new Map();
        }
        add(t22, i22) {
          if (this.typeById.has(t22)) throw new Error(`Interaction id "${t22}" already exists.`);
          const o2 = i22.filter;
          let s2 = i22.type;
          o2 && this.filters.set(t22, e2.b3(o2)), "mouseover" === s2 && (s2 = "mouseenter"), "mouseout" === s2 && (s2 = "mouseleave");
          const r22 = this.interactionsByType.get(s2) || /* @__PURE__ */ new Map();
          "mouseenter" === s2 || "mouseleave" === s2 ? (0 === this.delegatedInteractions.size && (this.map.on("mousemove", this.handleMove), this.map.on("mouseout", this.handleOut)), this.delegatedInteractions.set(t22, i22)) : 0 === r22.size && this.map.on(s2, this.handleType), 0 === r22.size && this.interactionsByType.set(s2, r22), r22.set(t22, i22), this.typeById.set(t22, s2);
        }
        get(e22) {
          const t22 = this.typeById.get(e22);
          if (!t22) return;
          const i22 = this.interactionsByType.get(t22);
          return i22 ? i22.get(e22) : void 0;
        }
        remove(e22) {
          const t22 = this.typeById.get(e22);
          if (!t22) return;
          this.typeById.delete(e22), this.filters.delete(e22);
          const i22 = this.interactionsByType.get(t22);
          i22 && (i22.delete(e22), "mouseenter" === t22 || "mouseleave" === t22 ? (this.delegatedInteractions.delete(e22), 0 === this.delegatedInteractions.size && (this.map.off("mousemove", this.handleMove), this.map.off("mouseout", this.handleOut))) : 0 === i22.size && this.map.off(t22, this.handleType));
        }
        queryTargets(e22, t22) {
          const i22 = [];
          for (const [e3, o2] of t22) o2.target && i22.push({ targetId: e3, target: o2.target, filter: this.filters.get(e3) });
          return this.map.style.queryRenderedTargets(e22, i22, this.map.transform);
        }
        handleMove(e22) {
          this.prevHoveredFeatures = this.hoveredFeatures, this.hoveredFeatures = /* @__PURE__ */ new Map();
          const t22 = this.queryTargets(e22.point, Array.from(this.delegatedInteractions).reverse());
          t22.length && (e22.type = "mouseenter", this.handleType(e22, t22));
          const i22 = /* @__PURE__ */ new Map();
          for (const [e3, { feature: t3 }] of this.prevHoveredFeatures) this.hoveredFeatures.has(e3) || i22.set(t3.id, t3);
          i22.size && (e22.type = "mouseleave", this.handleType(e22, Array.from(i22.values())));
        }
        handleOut(e22) {
          const t22 = Array.from(this.hoveredFeatures.values()).map(({ feature: e3 }) => e3);
          t22.length && (e22.type = "mouseleave", this.handleType(e22, t22)), this.hoveredFeatures.clear();
        }
        handleType(t22, i22) {
          const o2 = Array.from(this.interactionsByType.get(t22.type)).reverse(), s2 = !!i22;
          i22 = i22 || this.queryTargets(t22.point, o2);
          const r22 = "mouseenter" === t22.type;
          let n22 = false;
          const a22 = /* @__PURE__ */ new Set();
          for (const l22 of i22) {
            for (const [i3, c22] of o2) {
              if (!c22.target) continue;
              const o3 = l22.variants ? l22.variants[i3] : null;
              if (o3) {
                for (const h22 of o3) {
                  if (lt(h22, l22, a22, i3)) continue;
                  const o4 = new e2.df(l22, h22), d22 = at(h22, l22, i3);
                  s2 && (o4.state = this.map.getFeatureState(o4));
                  const u22 = r22 ? this.prevHoveredFeatures.get(d22) : null, _22 = new cl(t22, i3, c22, o4), p22 = u22 ? u22.stop : c22.handler(_22);
                  if (r22 && this.hoveredFeatures.set(d22, { feature: l22, stop: p22 }), false !== p22) {
                    n22 = true;
                    break;
                  }
                }
                if (n22) break;
              }
            }
            if (n22) break;
          }
          if (!n22) for (const [e22, i3] of o2) {
            const { handler: o3, target: s3 } = i3;
            if (!s3 && false !== o3(new cl(t22, e22, i3, null))) break;
          }
        }
      }
      function dl(t22, i22) {
        if (Array.isArray(t22) && Array.isArray(i22)) {
          const e22 = new Set(t22), o2 = new Set(i22);
          return e22.size === o2.size && t22.every((e3) => o2.has(e3));
        }
        return e2.bv(t22, i22);
      }
      const ul = { center: [0, 0], zoom: 0, bearing: 0, pitch: 0, minZoom: -2, maxZoom: 22, minPitch: 0, maxPitch: 85, interactive: true, scrollZoom: true, boxZoom: true, dragRotate: true, dragPan: true, keyboard: true, doubleClickZoom: true, touchZoomRotate: true, touchPitch: true, cooperativeGestures: false, performanceMetricsCollection: true, bearingSnap: 7, clickTolerance: 3, pitchWithRotate: true, hash: false, attributionControl: true, antialias: false, failIfMajorPerformanceCaveat: false, preserveDrawingBuffer: false, trackResize: true, renderWorldCopies: true, refreshExpiredTiles: true, minTileCacheSize: null, maxTileCacheSize: null, localIdeographFontFamily: "sans-serif", localFontFamily: null, transformRequest: null, accessToken: null, fadeDuration: 300, respectPrefersReducedMotion: true, crossSourceCollisions: true, collectResourceTiming: false, testMode: false, precompilePrograms: true, scaleFactor: 1, spriteFormat: "auto" }, _l = { showCompass: true, showZoom: true, visualizePitch: false };
      class pl {
        constructor(t22, i22, o2 = false) {
          this._clickTolerance = 10, this.element = i22, this.mouseRotate = new Ra({ clickTolerance: t22.dragRotate._mouseRotate._clickTolerance }), this.map = t22, o2 && (this.mousePitch = new Da({ clickTolerance: t22.dragRotate._mousePitch._clickTolerance })), e2.aV(["mousedown", "mousemove", "mouseup", "touchstart", "touchmove", "touchend", "reset"], this), i22.addEventListener("mousedown", this.mousedown), i22.addEventListener("touchstart", this.touchstart, { passive: false }), i22.addEventListener("touchmove", this.touchmove), i22.addEventListener("touchend", this.touchend), i22.addEventListener("touchcancel", this.reset);
        }
        down(e22, t22) {
          this.mouseRotate.mousedown(e22, t22), this.mousePitch && this.mousePitch.mousedown(e22, t22), _2();
        }
        move(e22, t22) {
          const i22 = this.map, o2 = this.mouseRotate.mousemoveWindow(e22, t22), s2 = o2 && o2.bearingDelta;
          if (s2 && i22.setBearing(i22.getBearing() + s2), this.mousePitch) {
            const o3 = this.mousePitch.mousemoveWindow(e22, t22), s3 = o3 && o3.pitchDelta;
            s3 && i22.setPitch(i22.getPitch() + s3);
          }
        }
        off() {
          const e22 = this.element;
          e22.removeEventListener("mousedown", this.mousedown), e22.removeEventListener("touchstart", this.touchstart), e22.removeEventListener("touchmove", this.touchmove), e22.removeEventListener("touchend", this.touchend), e22.removeEventListener("touchcancel", this.reset), this.offTemp();
        }
        offTemp() {
          p2(), window.removeEventListener("mousemove", this.mousemove), window.removeEventListener("mouseup", this.mouseup);
        }
        mousedown(t22) {
          this.down(e2.l({}, t22, { ctrlKey: true, preventDefault: () => t22.preventDefault() }), g2(this.element, t22)), window.addEventListener("mousemove", this.mousemove), window.addEventListener("mouseup", this.mouseup);
        }
        mousemove(e22) {
          this.move(e22, g2(this.element, e22));
        }
        mouseup(e22) {
          this.mouseRotate.mouseupWindow(e22), this.mousePitch && this.mousePitch.mouseupWindow(e22), this.offTemp();
        }
        touchstart(e22) {
          1 !== e22.targetTouches.length ? this.reset() : (this._startPos = this._lastPos = v2(this.element, e22.targetTouches)[0], this.down({ type: "mousedown", button: 0, ctrlKey: true, preventDefault: () => e22.preventDefault() }, this._startPos));
        }
        touchmove(e22) {
          1 !== e22.targetTouches.length ? this.reset() : (this._lastPos = v2(this.element, e22.targetTouches)[0], this.move({ preventDefault: () => e22.preventDefault() }, this._lastPos));
        }
        touchend(e22) {
          0 === e22.targetTouches.length && this._startPos && this._lastPos && this._startPos.dist(this._lastPos) < this._clickTolerance && this.element.click(), this.reset();
        }
        reset() {
          this.mouseRotate.reset(), this.mousePitch && this.mousePitch.reset(), delete this._startPos, delete this._lastPos, this.offTemp();
        }
      }
      function fl(t22, i22, o2) {
        if (t22 = new e2.cd(t22.lng, t22.lat), i22) {
          const s2 = new e2.cd(t22.lng - 360, t22.lat), r22 = new e2.cd(t22.lng + 360, t22.lat), n22 = 360 * Math.ceil(Math.abs(t22.lng - o2.center.lng) / 360), a22 = o2.locationPoint3D(t22).distSqr(i22), l22 = i22.x < 0 || i22.y < 0 || i22.x > o2.width || i22.y > o2.height;
          o2.locationPoint3D(s2).distSqr(i22) < a22 && (l22 || Math.abs(s2.lng - o2.center.lng) < n22) ? t22 = s2 : o2.locationPoint3D(r22).distSqr(i22) < a22 && (l22 || Math.abs(r22.lng - o2.center.lng) < n22) && (t22 = r22);
        }
        for (; Math.abs(t22.lng - o2.center.lng) > 180; ) {
          const e22 = o2.locationPoint3D(t22);
          if (e22.x >= 0 && e22.y >= 0 && e22.x <= o2.width && e22.y <= o2.height) break;
          t22.lng > o2.center.lng ? t22.lng -= 360 : t22.lng += 360;
        }
        return t22;
      }
      const ml = { center: "translate(-50%,-50%)", top: "translate(-50%,0)", "top-left": "translate(0,0)", "top-right": "translate(-100%,0)", bottom: "translate(-50%,-100%)", "bottom-left": "translate(0,-100%)", "bottom-right": "translate(-100%,-100%)", left: "translate(0,-50%)", right: "translate(-100%,-50%)" }, gl = { rotation: 0, rotationAlignment: "auto", pitchAlignment: "auto", occludedOpacity: 0.2, altitude: 0 };
      class vl extends e2.E {
        constructor(t22, i22) {
          super(), (t22 instanceof HTMLElement || i22) && (t22 = e2.l({ element: t22 }, i22)), e2.aV(["_update", "_onMove", "_onUp", "_addDragHandler", "_onMapClick", "_onKeyPress", "_clearFadeTimer"], this);
          const { anchor: o2 = "center", color: s2 = "#3FB1CE", scale: r22 = 1, draggable: n22 = false, clickTolerance: a22 = 0, rotation: l22 = gl.rotation, rotationAlignment: c22 = gl.rotationAlignment, pitchAlignment: h22 = gl.pitchAlignment, occludedOpacity: d22 = gl.occludedOpacity, altitude: u22 = gl.altitude } = t22 || {};
          this._anchor = o2, this._color = s2, this._scale = r22, this._draggable = n22, this._clickTolerance = a22, this._rotation = l22, this._rotationAlignment = c22, this._pitchAlignment = h22, this._occludedOpacity = d22, this._altitude = u22, this._state = "inactive", this._isDragging = false, this._updateMoving = () => this._update(true), t22 && t22.element ? (this._element = t22.element, this._offset = e2.P.convert(t22 && t22.offset || [0, 0])) : (this._defaultMarker = true, this._element = this._createDefaultMarker(), this._offset = e2.P.convert(t22 && t22.offset || [0, -14])), this._element.hasAttribute("aria-label") || this._element.setAttribute("aria-label", "Map marker"), this._element.hasAttribute("role") || this._element.setAttribute("role", "img"), this._element.classList.add("mapboxgl-marker"), this._element.addEventListener("dragstart", (e22) => {
            e22.preventDefault();
          }), this._element.addEventListener("mousedown", (e22) => {
            e22.preventDefault();
          });
          const _22 = this._element.classList;
          for (const e22 in ml) _22.remove(`mapboxgl-marker-anchor-${e22}`);
          _22.add(`mapboxgl-marker-anchor-${this._anchor}`);
          const p22 = t22 && t22.className ? t22.className.trim().split(/\s+/) : [];
          _22.add(...p22), this._popup = null;
        }
        _createDefaultMarker() {
          const e22 = l2("div"), t22 = c2("svg", { display: "block", height: 41 * this._scale + "px", width: 27 * this._scale + "px", viewBox: "0 0 27 41" }, e22);
          if (0 === this._altitude) {
            const e3 = c2("radialGradient", { id: "shadowGradient" }, c2("defs", {}, t22));
            c2("stop", { offset: "10%", "stop-opacity": 0.4 }, e3), c2("stop", { offset: "100%", "stop-opacity": 0.05 }, e3), c2("ellipse", { cx: 13.5, cy: 34.8, rx: 10.5, ry: 5.25, fill: "url(#shadowGradient)" }, t22);
          }
          return c2("path", { fill: this._color, d: "M27,13.5C27,19.07 20.25,27 14.75,34.5C14.02,35.5 12.98,35.5 12.25,34.5C6.75,27 0,19.22 0,13.5C0,6.04 6.04,0 13.5,0C20.96,0 27,6.04 27,13.5Z" }, t22), c2("path", { opacity: 0.25, d: "M13.5,0C6.04,0 0,6.04 0,13.5C0,19.22 6.75,27 12.25,34.5C13,35.52 14.02,35.5 14.75,34.5C20.25,27 27,19.07 27,13.5C27,6.04 20.96,0 13.5,0ZM13.5,1C20.42,1 26,6.58 26,13.5C26,15.9 24.5,19.18 22.22,22.74C19.95,26.3 16.71,30.14 13.94,33.91C13.74,34.18 13.61,34.32 13.5,34.44C13.39,34.32 13.26,34.18 13.06,33.91C10.28,30.13 7.41,26.31 5.02,22.77C2.62,19.23 1,15.95 1,13.5C1,6.58 6.58,1 13.5,1Z" }, t22), c2("circle", { fill: "white", cx: 13.5, cy: 13.5, r: 5.5 }, t22), e22;
        }
        addTo(e22) {
          return e22 === this._map || (this.remove(), this._map = e22, e22.getCanvasContainer().appendChild(this._element), e22.on("move", this._updateMoving), e22.on("moveend", this._update), e22.on("remove", this._clearFadeTimer), e22._addMarker(this), this.setDraggable(this._draggable), this._update(), e22.on("click", this._onMapClick)), this;
        }
        remove() {
          const e22 = this._map;
          return e22 && (e22.off("click", this._onMapClick), e22.off("move", this._updateMoving), e22.off("moveend", this._update), e22.off("mousedown", this._addDragHandler), e22.off("touchstart", this._addDragHandler), e22.off("mouseup", this._onUp), e22.off("touchend", this._onUp), e22.off("mousemove", this._onMove), e22.off("touchmove", this._onMove), e22.off("remove", this._clearFadeTimer), e22._removeMarker(this), this._map = void 0), this._clearFadeTimer(), this._element.remove(), this._popup && this._popup.remove(), this;
        }
        getLngLat() {
          return this._lngLat;
        }
        setLngLat(t22) {
          return this._lngLat = e2.cd.convert(t22), this._pos = null, this._popup && this._popup.setLngLat(this._lngLat), this._update(true), this;
        }
        setAltitude(e22) {
          return e22 === this._altitude || (this._defaultMarker && (0 === this._altitude && 0 !== e22 || 0 !== this._altitude && 0 === e22) && (this._element = this._createDefaultMarker()), this._altitude = e22 || gl.altitude, this._update()), this;
        }
        getAltitude() {
          return this._altitude;
        }
        getElement() {
          return this._element;
        }
        setPopup(e22) {
          if (this._popup && (this._popup.remove(), this._popup = null, this._element.removeAttribute("role"), this._element.removeEventListener("keypress", this._onKeyPress), this._originalTabIndex || this._element.removeAttribute("tabindex")), e22) {
            if (!("offset" in e22.options)) {
              const t22 = 38.1, i22 = 13.5, o2 = Math.sqrt(Math.pow(i22, 2) / 2);
              e22.options.offset = this._defaultMarker ? { top: [0, 0], "top-left": [0, 0], "top-right": [0, 0], bottom: [0, -t22], "bottom-left": [o2, -1 * (t22 - i22 + o2)], "bottom-right": [-o2, -1 * (t22 - i22 + o2)], left: [i22, -1 * (t22 - i22)], right: [-i22, -1 * (t22 - i22)] } : this._offset;
            }
            this._popup = e22, e22._marker = this, e22._altitude = this._altitude, this._lngLat && this._popup.setLngLat(this._lngLat), this._element.setAttribute("role", "button"), this._originalTabIndex = this._element.getAttribute("tabindex"), this._originalTabIndex || this._element.setAttribute("tabindex", "0"), this._element.addEventListener("keypress", this._onKeyPress), this._element.setAttribute("aria-expanded", "false");
          }
          return this;
        }
        _onKeyPress(e22) {
          const t22 = e22.code, i22 = e22.charCode || e22.keyCode;
          "Space" !== t22 && "Enter" !== t22 && 32 !== i22 && 13 !== i22 || this.togglePopup();
        }
        _onMapClick(e22) {
          const t22 = e22.originalEvent.target, i22 = this._element;
          this._popup && (t22 === i22 || i22.contains(t22)) && this.togglePopup();
        }
        getPopup() {
          return this._popup;
        }
        togglePopup() {
          const e22 = this._popup;
          return e22 ? (e22.isOpen() ? (e22.remove(), this._element.setAttribute("aria-expanded", "false")) : this._map && (e22.addTo(this._map), this._element.setAttribute("aria-expanded", "true")), this) : this;
        }
        _behindTerrain() {
          const e22 = this._map, t22 = this._pos;
          if (!e22 || !t22) return false;
          const i22 = e22.unproject(t22, this._altitude), o2 = e22.getFreeCameraOptions();
          if (!o2.position) return false;
          const s2 = o2.position.toLngLat();
          return s2.distanceTo(i22) < 0.9 * s2.distanceTo(this._lngLat);
        }
        _evaluateOpacity() {
          const t22 = this._map;
          if (!t22) return;
          const i22 = this._pos;
          if (!i22 || i22.x < 0 || i22.x > t22.transform.width || i22.y < 0 || i22.y > t22.transform.height) return void this._clearFadeTimer();
          const o2 = t22.unproject(i22, this._altitude);
          let s2;
          t22._showingGlobe() && e2.eK(t22.transform, this._lngLat) ? s2 = 0 : (s2 = 1 - t22._queryFogOpacity(o2), t22.transform._terrainEnabled() && t22.getTerrain() && this._behindTerrain() && (s2 *= this._occludedOpacity)), this._element.style.opacity = `${s2}`, this._element.style.pointerEvents = s2 > 0 ? "auto" : "none", this._popup && this._popup._setOpacity(s2), this._fadeTimer = null;
        }
        _clearFadeTimer() {
          this._fadeTimer && (clearTimeout(this._fadeTimer), this._fadeTimer = null);
        }
        _updateDOM() {
          const e22 = this._pos;
          if (!e22 || !this._map) return;
          const t22 = this._offset.mult(this._scale);
          this._element.style.transform = `
            translate(${e22.x}px,${e22.y}px)
            ${ml[this._anchor]}
            ${this._calculateXYTransform()} ${this._calculateZTransform()}
            translate(${t22.x}px,${t22.y}px)
        `;
        }
        _calculateXYTransform() {
          const t22 = this._pos, i22 = this._map, o2 = this.getPitchAlignment();
          if (!i22 || !t22 || "map" !== o2) return "";
          if (!i22._showingGlobe()) {
            const e22 = i22.getPitch();
            return e22 ? `rotateX(${e22}deg)` : "";
          }
          const s2 = e2.cJ(e2.eL(i22.transform, this._lngLat)), r22 = t22.sub(e2.eM(i22.transform)), n22 = Math.abs(r22.x) + Math.abs(r22.y);
          if (0 === n22) return "";
          const a22 = s2 / n22;
          return `rotateX(${-r22.y * a22}deg) rotateY(${r22.x * a22}deg)`;
        }
        _calculateZTransform() {
          const t22 = this._pos, i22 = this._map;
          if (!i22 || !t22) return "";
          let o2 = 0;
          const s2 = this.getRotationAlignment();
          if ("map" === s2) if (i22._showingGlobe()) {
            const t3 = i22.project(new e2.cd(this._lngLat.lng, this._lngLat.lat + 1e-3), this._altitude), s3 = i22.project(new e2.cd(this._lngLat.lng, this._lngLat.lat - 1e-3), this._altitude).sub(t3);
            o2 = e2.cJ(Math.atan2(s3.y, s3.x)) - 90;
          } else o2 = -i22.getBearing();
          else if ("horizon" === s2) {
            const s3 = e2.af(4, 6, i22.getZoom()), r22 = e2.eM(i22.transform);
            r22.y += s3 * i22.transform.height;
            const n22 = t22.sub(r22), a22 = e2.cJ(Math.atan2(n22.y, n22.x));
            o2 = (a22 > 90 ? a22 - 270 : a22 + 90) * (1 - s3);
          }
          return o2 += this._rotation, o2 ? `rotateZ(${o2}deg)` : "";
        }
        _update(e22) {
          cancelAnimationFrame(this._updateFrameId);
          const t22 = this._map;
          t22 && (t22.transform.renderWorldCopies && (this._lngLat = fl(this._lngLat, this._pos, t22.transform)), this._pos = t22.project(this._lngLat, this._altitude), true === e22 ? this._updateFrameId = requestAnimationFrame(() => {
            this._element && this._pos && this._anchor && (this._pos = this._pos.round(), this._updateDOM());
          }) : this._pos = this._pos.round(), t22._requestDomTask(() => {
            this._map && (this._element && this._pos && this._anchor && this._updateDOM(), (t22._showingGlobe() || t22.getTerrain() || t22.getFog()) && !this._fadeTimer && (this._fadeTimer = window.setTimeout(this._evaluateOpacity.bind(this), 60)));
          }));
        }
        getOffset() {
          return this._offset;
        }
        setOffset(t22) {
          return this._offset = e2.P.convert(t22), this._update(), this;
        }
        addClassName(e22) {
          return this._element.classList.add(e22), this;
        }
        removeClassName(e22) {
          return this._element.classList.remove(e22), this;
        }
        toggleClassName(e22) {
          return this._element.classList.toggle(e22);
        }
        _onMove(t22) {
          const i22 = this._map;
          if (!i22) return;
          const o2 = this._pointerdownPos, s2 = this._positionDelta;
          if (o2 && s2) {
            if (!this._isDragging) {
              const e22 = this._clickTolerance || i22._clickTolerance;
              if (t22.point.dist(o2) < e22) return;
              this._isDragging = true;
            }
            this._pos = t22.point.sub(s2), this._lngLat = i22.unproject(this._pos, this._altitude), this.setLngLat(this._lngLat), this._element.style.pointerEvents = "none", "pending" === this._state && (this._state = "active", this.fire(new e2.A("dragstart"))), this.fire(new e2.A("drag"));
          }
        }
        _onUp() {
          this._element.style.pointerEvents = "auto", this._positionDelta = null, this._pointerdownPos = null, this._isDragging = false;
          const t22 = this._map;
          t22 && (t22.off("mousemove", this._onMove), t22.off("touchmove", this._onMove)), "active" === this._state && this.fire(new e2.A("dragend")), this._state = "inactive";
        }
        _addDragHandler(e22) {
          const t22 = this._map, i22 = this._pos;
          t22 && i22 && this._element.contains(e22.originalEvent.target) && (e22.preventDefault(), this._positionDelta = e22.point.sub(i22), this._pointerdownPos = e22.point, this._state = "pending", t22.on("mousemove", this._onMove), t22.on("touchmove", this._onMove), t22.once("mouseup", this._onUp), t22.once("touchend", this._onUp));
        }
        setDraggable(e22) {
          this._draggable = !!e22;
          const t22 = this._map;
          return t22 && (e22 ? (t22.on("mousedown", this._addDragHandler), t22.on("touchstart", this._addDragHandler)) : (t22.off("mousedown", this._addDragHandler), t22.off("touchstart", this._addDragHandler))), this;
        }
        isDraggable() {
          return this._draggable;
        }
        setRotation(e22) {
          return this._rotation = e22 || gl.rotation, this._update(), this;
        }
        getRotation() {
          return this._rotation;
        }
        setRotationAlignment(e22) {
          return this._rotationAlignment = e22 || gl.rotationAlignment, this._update(), this;
        }
        getRotationAlignment() {
          return "auto" === this._rotationAlignment || "horizon" === this._rotationAlignment && this._map && !this._map._showingGlobe() ? "viewport" : this._rotationAlignment;
        }
        setPitchAlignment(e22) {
          return this._pitchAlignment = e22 || gl.pitchAlignment, this._update(), this;
        }
        getPitchAlignment() {
          return "auto" === this._pitchAlignment ? this.getRotationAlignment() : this._pitchAlignment;
        }
        setOccludedOpacity(e22) {
          return this._occludedOpacity = e22 || gl.occludedOpacity, this._update(), this;
        }
        getOccludedOpacity() {
          return this._occludedOpacity;
        }
      }
      const yl = { positionOptions: { enableHighAccuracy: false, maximumAge: 0, timeout: 6e3 }, fitBoundsOptions: { maxZoom: 15 }, trackUserLocation: false, showAccuracyCircle: true, showUserLocation: true, showUserHeading: false }, xl = { maxWidth: 100, unit: "metric" }, bl = { kilometer: "km", meter: "m", mile: "mi", foot: "ft", "nautical-mile": "nm" }, wl = { closeButton: true, closeOnClick: true, focusAfterOpen: true, className: "", maxWidth: "240px", altitude: 0 }, Tl = ["a[href]", "[tabindex]:not([tabindex='-1'])", "[contenteditable]:not([contenteditable='false'])", "button:not([disabled])", "input:not([disabled])", "select:not([disabled])", "textarea:not([disabled])"].join(", ");
      function El(t22 = new e2.P(0, 0), i22 = "bottom") {
        if ("number" == typeof t22) {
          const o2 = Math.round(Math.sqrt(0.5 * Math.pow(t22, 2)));
          switch (i22) {
            case "top":
              return new e2.P(0, t22);
            case "top-left":
              return new e2.P(o2, o2);
            case "top-right":
              return new e2.P(-o2, o2);
            case "bottom":
              return new e2.P(0, -t22);
            case "bottom-left":
              return new e2.P(o2, -o2);
            case "bottom-right":
              return new e2.P(-o2, -o2);
            case "left":
              return new e2.P(t22, 0);
            case "right":
              return new e2.P(-t22, 0);
          }
          return new e2.P(0, 0);
        }
        return t22 instanceof e2.P || Array.isArray(t22) ? e2.P.convert(t22) : e2.P.convert(t22[i22] || [0, 0]);
      }
      const Sl = { version: t2, supported: a2.supported, setRTLTextPlugin: e2.eN, getRTLTextPluginStatus: e2.eO, Map: class extends ol {
        constructor(t22) {
          o.mark(i2.create);
          const s2 = t22;
          if (null != (t22 = e2.l({}, ul, t22)).minZoom && null != t22.maxZoom && t22.minZoom > t22.maxZoom) throw new Error("maxZoom must be greater than or equal to minZoom");
          if (null != t22.minPitch && null != t22.maxPitch && t22.minPitch > t22.maxPitch) throw new Error("maxPitch must be greater than or equal to minPitch");
          if (null != t22.minPitch && t22.minPitch < 0) throw new Error("minPitch must be greater than or equal to 0");
          if (null != t22.maxPitch && t22.maxPitch > 85) throw new Error("maxPitch must be less than or equal to 85");
          if (t22.antialias && e2.eI(window) && (t22.antialias = false, e2.w("Antialiasing is disabled for this WebGL context to avoid browser bug: https://github.com/mapbox/mapbox-gl-js/issues/11609")), super(new Qi(t22.minZoom, t22.maxZoom, t22.minPitch, t22.maxPitch, t22.renderWorldCopies, null, null), t22), this._repaint = !!t22.repaint, this._interactive = t22.interactive, this._minTileCacheSize = t22.minTileCacheSize, this._maxTileCacheSize = t22.maxTileCacheSize, this._failIfMajorPerformanceCaveat = t22.failIfMajorPerformanceCaveat, this._preserveDrawingBuffer = t22.preserveDrawingBuffer, this._antialias = t22.antialias, this._trackResize = t22.trackResize, this._bearingSnap = t22.bearingSnap, this._refreshExpiredTiles = t22.refreshExpiredTiles, this._fadeDuration = t22.fadeDuration, this._isInitialLoad = true, this._crossSourceCollisions = t22.crossSourceCollisions, this._collectResourceTiming = t22.collectResourceTiming, this._language = this._parseLanguage(t22.language), this._worldview = t22.worldview, this._renderTaskQueue = new nl(), this._domRenderTaskQueue = new nl(), this._controls = [], this._markers = [], this._popups = [], this._mapId = e2.a$(), this._locale = e2.l({}, ll, t22.locale), this._clickTolerance = t22.clickTolerance, this._cooperativeGestures = t22.cooperativeGestures, this._performanceMetricsCollection = t22.performanceMetricsCollection, this._tessellationStep = t22.tessellationStep, this._containerWidth = 0, this._containerHeight = 0, this._showParseStatus = true, this._precompilePrograms = t22.precompilePrograms, this._scaleFactorChanged = false, this._averageElevationLastSampledAt = -1 / 0, this._averageElevationExaggeration = 0, this._averageElevation = new al(0), this._interactionRange = [1 / 0, -1 / 0], this._visibilityHidden = 0, this._useExplicitProjection = false, this._frameId = 0, this._scaleFactor = t22.scaleFactor, this._requestManager = new T(t22.transformRequest, t22.accessToken, t22.testMode), this._silenceAuthErrors = !!t22.testMode, this._contextCreateOptions = t22.contextCreateOptions ? Object.assign({}, t22.contextCreateOptions) : {}, "string" == typeof t22.container) {
            const e22 = document.getElementById(t22.container);
            if (!e22) throw new Error(`Container '${t22.container.toString()}' not found.`);
            this._container = e22;
          } else {
            if (!(t22.container instanceof HTMLElement)) throw new Error("Invalid type: 'container' must be a String or HTMLElement.");
            this._container = t22.container;
          }
          if (this._container.childNodes.length > 0 && e2.w("The map container element should be empty, otherwise the map's interactivity will be negatively impacted. If you want to display a message when WebGL is not supported, use the Mapbox GL Supported plugin instead."), t22.maxBounds && this.setMaxBounds(t22.maxBounds), this._spriteFormat = t22.spriteFormat, e2.aV(["_onWindowOnline", "_onWindowResize", "_onVisibilityChange", "_onMapScroll", "_contextLost", "_contextRestored"], this), this._setupContainer(), this._tp || (this._tp = new jn()), this._tp.registerParameter(this, ["Debug"], "showOverdrawInspector"), this._tp.registerParameter(this, ["Debug"], "showTileBoundaries"), this._tp.registerParameter(this, ["Debug"], "showParseStatus"), this._tp.registerParameter(this, ["Debug"], "repaint"), this._tp.registerParameter(this, ["Debug"], "showTileAABBs"), this._tp.registerParameter(this, ["Debug"], "showPadding"), this._tp.registerParameter(this, ["Debug"], "showCollisionBoxes", { noSave: true }), this._tp.registerParameter(this.transform, ["Debug"], "freezeTileCoverage", { noSave: true }, () => {
            this._update();
          }), this._tp.registerParameter(this, ["Debug", "Wireframe"], "showTerrainWireframe"), this._tp.registerParameter(this, ["Debug", "Wireframe"], "showLayers2DWireframe"), this._tp.registerParameter(this, ["Debug", "Wireframe"], "showLayers3DWireframe"), this._tp.registerParameter(this, ["Scaling"], "_scaleFactor", { min: 0.1, max: 10, step: 0.1 }, () => {
            this.setScaleFactor(this._scaleFactor);
          }), this._setupPainter(), void 0 === this.painter) throw new Error("Failed to initialize WebGL.");
          if (this.on("move", () => this._update(false)), this.on("moveend", () => this._update(false)), this.on("zoom", () => this._update(true)), this._fullscreenchangeEvent = "onfullscreenchange" in document ? "fullscreenchange" : "webkitfullscreenchange", window.addEventListener("online", this._onWindowOnline, false), window.addEventListener("resize", this._onWindowResize, false), window.addEventListener("orientationchange", this._onWindowResize, false), window.addEventListener(this._fullscreenchangeEvent, this._onWindowResize, false), window.addEventListener("visibilitychange", this._onVisibilityChange, false), this.handlers = new tl(this, t22), this._localFontFamily = t22.localFontFamily, this._localIdeographFontFamily = t22.localIdeographFontFamily, (t22.style || !t22.testMode) && this.setStyle(t22.style || e2.e.DEFAULT_STYLE, { config: t22.config, localFontFamily: this._localFontFamily, localIdeographFontFamily: this._localIdeographFontFamily }), t22.projection && this.setProjection(t22.projection), this.indoor = new po(this), t22.hash && (this._hash = new sa("string" == typeof t22.hash && t22.hash || void 0).addTo(this)), !this._hash || !this._hash._onHashChange()) {
            null == s2.center && null == s2.zoom || (this.transform._unmodified = false), this.jumpTo({ center: t22.center, zoom: t22.zoom, bearing: t22.bearing, pitch: t22.pitch });
            const i22 = t22.bounds;
            i22 && (this.resize(), this.fitBounds(i22, e2.l({}, t22.fitBoundsOptions, { duration: 0 })));
          }
          this.resize(), t22.attributionControl && this.addControl(new sl({ customAttribution: t22.customAttribution })), this._logoControl = new rl(), this.addControl(this._logoControl, t22.logoPosition), this.on("style.load", () => {
            this.transform.unmodified && this.jumpTo(this.style.stylesheet), this._postStyleLoadEvent();
          }), this.on("data", (t3) => {
            this._update("style" === t3.dataType), this.fire(new e2.A(`${t3.dataType}data`, t3));
          }), this.on("dataloading", (t3) => {
            this.fire(new e2.A(`${t3.dataType}dataloading`, t3));
          }), this._interactions = new hl(this);
        }
        _getMapId() {
          return this._mapId;
        }
        addControl(t22, i22) {
          if (void 0 === i22 && (i22 = t22.getDefaultPosition ? t22.getDefaultPosition() : "top-right"), !t22 || !t22.onAdd) return this.fire(new e2.z(new Error("Invalid argument to map.addControl(). Argument must be a control with onAdd and onRemove methods.")));
          const o2 = t22.onAdd(this);
          this._controls.push(t22);
          const s2 = this._controlPositions[i22];
          return -1 !== i22.indexOf("bottom") ? s2.insertBefore(o2, s2.firstChild) : s2.appendChild(o2), this;
        }
        removeControl(t22) {
          if (!t22 || !t22.onRemove) return this.fire(new e2.z(new Error("Invalid argument to map.removeControl(). Argument must be a control with onAdd and onRemove methods.")));
          const i22 = this._controls.indexOf(t22);
          return i22 > -1 && this._controls.splice(i22, 1), t22.onRemove(this), this;
        }
        hasControl(e22) {
          return this._controls.indexOf(e22) > -1;
        }
        getContainer() {
          return this._container;
        }
        getCanvasContainer() {
          return this._canvasContainer;
        }
        getCanvas() {
          return this._canvas;
        }
        resize(t22) {
          if (this._updateContainerDimensions(), this._containerWidth === this.transform.width && this._containerHeight === this.transform.height) return this;
          this._resizeCanvas(this._containerWidth, this._containerHeight), this.transform.resize(this._containerWidth, this._containerHeight), this.painter.resize(Math.ceil(this._containerWidth), Math.ceil(this._containerHeight));
          const i22 = !this._moving;
          return i22 && this.fire(new e2.A("movestart", t22)).fire(new e2.A("move", t22)), this.fire(new e2.A("resize", t22)), i22 && this.fire(new e2.A("moveend", t22)), this;
        }
        getBounds() {
          return this.transform.getBounds();
        }
        getMaxBounds() {
          return this.transform.getMaxBounds() || null;
        }
        setMaxBounds(t22) {
          return this.transform.setMaxBounds(e2.aG.convert(t22)), this._update();
        }
        setMinZoom(t22) {
          if ((t22 = t22 ?? -2) >= -2 && t22 <= this.transform.maxZoom) return this.transform.minZoom = t22, this._update(), this.getZoom() < t22 ? this.setZoom(t22) : this.fire(new e2.A("zoomstart")).fire(new e2.A("zoom")).fire(new e2.A("zoomend")), this;
          throw new Error("minZoom must be between -2 and the current maxZoom, inclusive");
        }
        getMinZoom() {
          return this.transform.minZoom;
        }
        setMaxZoom(t22) {
          if ((t22 = t22 ?? 22) >= this.transform.minZoom) return this.transform.maxZoom = t22, this._update(), this.getZoom() > t22 ? this.setZoom(t22) : this.fire(new e2.A("zoomstart")).fire(new e2.A("zoom")).fire(new e2.A("zoomend")), this;
          throw new Error("maxZoom must be greater than the current minZoom");
        }
        getMaxZoom() {
          return this.transform.maxZoom;
        }
        setMinPitch(t22) {
          if ((t22 = t22 ?? 0) < 0) throw new Error("minPitch must be greater than or equal to 0");
          if (t22 >= 0 && t22 <= this.transform.maxPitch) return this.transform.minPitch = t22, this._update(), this.getPitch() < t22 ? this.setPitch(t22) : this.fire(new e2.A("pitchstart")).fire(new e2.A("pitch")).fire(new e2.A("pitchend")), this;
          throw new Error("minPitch must be between 0 and the current maxPitch, inclusive");
        }
        getMinPitch() {
          return this.transform.minPitch;
        }
        setMaxPitch(t22) {
          if ((t22 = t22 ?? 85) > 85) throw new Error("maxPitch must be less than or equal to 85");
          if (t22 >= this.transform.minPitch) return this.transform.maxPitch = t22, this._update(), this.getPitch() > t22 ? this.setPitch(t22) : this.fire(new e2.A("pitchstart")).fire(new e2.A("pitch")).fire(new e2.A("pitchend")), this;
          throw new Error("maxPitch must be greater than or equal to minPitch");
        }
        getMaxPitch() {
          return this.transform.maxPitch;
        }
        getScaleFactor() {
          return this._scaleFactor;
        }
        setScaleFactor(e22) {
          return this._scaleFactor = e22, this.painter.scaleFactor = e22, this._tp.refreshUI(), this._scaleFactorChanged = true, this.style._updateFilteredLayers((e3) => "symbol" === e3.type), this._update(true), this;
        }
        getRenderWorldCopies() {
          return this.transform.renderWorldCopies;
        }
        setRenderWorldCopies(e22) {
          return this.transform.renderWorldCopies = e22, this.transform.renderWorldCopies || this._forceMarkerAndPopupUpdate(true), this._update();
        }
        getLanguage() {
          return this._language;
        }
        _parseLanguage(e22) {
          return "auto" === e22 ? navigator.language : Array.isArray(e22) ? 0 === e22.length ? void 0 : e22.map((e3) => "auto" === e3 ? navigator.language : e3) : e22;
        }
        setLanguage(e22) {
          const t22 = this._parseLanguage(e22);
          if (!this.style || t22 === this._language) return this;
          this._language = t22, this.style.reloadSources();
          for (const e3 of this._controls) e3._setLanguage && e3._setLanguage(this._language);
          return this;
        }
        getWorldview() {
          return this._worldview;
        }
        setWorldview(e22) {
          return this.style && e22 !== this._worldview ? (this._worldview = e22, this.style.reloadSources(), this) : this;
        }
        getProjection() {
          return this.transform.mercatorFromTransition ? { name: "globe", center: [0, 0] } : this.transform.getProjection();
        }
        _showingGlobe() {
          return "globe" === this.transform.projection.name;
        }
        setProjection(e22) {
          return this._lazyInitEmptyStyle(), e22 ? "string" == typeof e22 && (e22 = { name: e22 }) : e22 = null, this._useExplicitProjection = !!e22, this._prioritizeAndUpdateProjection(e22, this.style.projection);
        }
        _updateProjectionTransition() {
          if ("globe" !== this.getProjection().name) return;
          const t22 = this.transform, i22 = t22.projection.name;
          let o2;
          "globe" === i22 && t22.zoom >= e2.cx ? (t22.setMercatorFromTransition(), o2 = true) : "mercator" === i22 && t22.zoom < e2.cx && (t22.setProjection({ name: "globe" }), o2 = true), o2 && (this.style.applyProjectionUpdate(), this.style._forceSymbolLayerUpdate());
        }
        _prioritizeAndUpdateProjection(e22, t22) {
          return this._updateProjection(e22 || t22 || { name: "mercator" });
        }
        _updateProjection(t22) {
          let i22;
          return i22 = "globe" === t22.name && this.transform.zoom >= e2.cx ? this.transform.setMercatorFromTransition() : this.transform.setProjection(t22), this.style.applyProjectionUpdate(), i22 && (this.painter.clearBackgroundTiles(), this.style.clearSources(), this._update(true), this._forceMarkerAndPopupUpdate(true)), this;
        }
        project(t22, i22) {
          return this.transform.locationPoint3D(e2.cd.convert(t22), i22);
        }
        unproject(t22, i22) {
          return this.transform.pointLocation3D(e2.P.convert(t22), i22);
        }
        isMoving() {
          return this._moving || this.handlers && this.handlers.isMoving() || false;
        }
        isZooming() {
          return this._zooming || this.handlers && this.handlers.isZooming() || false;
        }
        isRotating() {
          return this._rotating || this.handlers && this.handlers.isRotating() || false;
        }
        _isDragging() {
          return this.handlers && this.handlers._isDragging() || false;
        }
        _createDelegatedListener(e22, t22, i22) {
          const o2 = (e3) => {
            let i3 = [];
            if (Array.isArray(t22)) {
              const o3 = t22.filter((e4) => this.getLayer(e4));
              i3 = o3.length ? this.queryRenderedFeatures(e3, { layers: o3 }) : [];
            } else i3 = this.queryRenderedFeatures(e3, { target: t22 });
            return i3;
          };
          if ("mouseenter" === e22 || "mouseover" === e22) {
            let s2 = false;
            const r22 = (t3) => {
              const r3 = o2(t3.point);
              r3.length ? s2 || (s2 = true, i22.call(this, new pa(e22, this, t3.originalEvent, { features: r3 }))) : s2 = false;
            };
            return { listener: i22, targets: t22, delegates: { mousemove: r22, mouseout: () => {
              s2 = false;
            } } };
          }
          if ("mouseleave" === e22 || "mouseout" === e22) {
            let s2 = false;
            const r22 = (t3) => {
              o2(t3.point).length ? s2 = true : s2 && (s2 = false, i22.call(this, new pa(e22, this, t3.originalEvent)));
            }, n22 = (t3) => {
              s2 && (s2 = false, i22.call(this, new pa(e22, this, t3.originalEvent)));
            };
            return { listener: i22, targets: t22, delegates: { mousemove: r22, mouseout: n22 } };
          }
          {
            const s2 = (e3) => {
              const t3 = o2(e3.point);
              t3.length && (e3.features = t3, i22.call(this, e3), delete e3.features);
            };
            return { listener: i22, targets: t22, delegates: { [e22]: s2 } };
          }
        }
        on(e22, t22, i22) {
          if ("function" == typeof t22 || void 0 === i22) return super.on(e22, t22);
          if ("string" == typeof t22 && (t22 = [t22]), !this._areTargetsValid(t22)) return this;
          const o2 = this._createDelegatedListener(e22, t22, i22);
          this._delegatedListeners = this._delegatedListeners || {}, this._delegatedListeners[e22] = this._delegatedListeners[e22] || [], this._delegatedListeners[e22].push(o2);
          for (const e3 in o2.delegates) this.on(e3, o2.delegates[e3]);
          return this;
        }
        once(e22, t22, i22) {
          if ("function" == typeof t22 || void 0 === i22) return super.once(e22, t22);
          if ("string" == typeof t22 && (t22 = [t22]), !this._areTargetsValid(t22)) return this;
          const o2 = this._createDelegatedListener(e22, t22, i22);
          for (const e3 in o2.delegates) this.once(e3, o2.delegates[e3]);
          return this;
        }
        off(e22, t22, i22) {
          if ("function" == typeof t22 || void 0 === i22) return super.off(e22, t22);
          if ("string" == typeof t22 && (t22 = [t22]), !this._areTargetsValid(t22)) return this;
          const o2 = this._delegatedListeners ? this._delegatedListeners[e22] : void 0;
          return o2 && ((e3) => {
            for (let o3 = 0; o3 < e3.length; o3++) {
              const s2 = e3[o3];
              if (s2.listener === i22 && dl(s2.targets, t22)) {
                for (const e4 in s2.delegates) this.off(e4, s2.delegates[e4]);
                return e3.splice(o3, 1), this;
              }
            }
          })(o2), this;
        }
        queryRenderedFeatures(t22, i22) {
          if (!this.style) return [];
          if (void 0 === t22 || t22 instanceof e2.P || Array.isArray(t22) || void 0 !== i22 || (i22 = t22, t22 = void 0), t22 = t22 || [[0, 0], [this.transform.width, this.transform.height]], !i22) {
            const e22 = this.style.queryRenderedFeatures(t22, void 0, this.transform), i3 = this.style.queryRenderedFeatureset(t22, void 0, this.transform);
            return e22.concat(i3);
          }
          let o2 = true;
          if (i22.target && (o2 = this._isTargetValid(i22.target), o2 && !i22.layers)) return this.style.queryRenderedFeatureset(t22, i22, this.transform);
          let s2 = true;
          if (i22.layers && Array.isArray(i22.layers)) {
            for (const e22 of i22.layers) if (!this._isValidId(e22)) {
              s2 = false;
              break;
            }
            if (s2 && !i22.target) return this.style.queryRenderedFeatures(t22, i22, this.transform);
          }
          let r22 = [];
          return s2 && (r22 = r22.concat(this.style.queryRenderedFeatures(t22, i22, this.transform))), o2 && (r22 = r22.concat(this.style.queryRenderedFeatureset(t22, i22, this.transform))), r22;
        }
        querySourceFeatures(e22, t22) {
          return !e22 || "string" == typeof e22 && !this._isValidId(e22) ? [] : this.style.querySourceFeatures(e22, t22);
        }
        isPointOnSurface(t22) {
          const { name: i22 } = this.transform.projection;
          return "globe" !== i22 && "mercator" !== i22 && e2.w(`${i22} projection does not support isPointOnSurface, this API may behave unexpectedly.`), this.transform.isPointOnSurface(e2.P.convert(t22));
        }
        addInteraction(e22, t22) {
          return this._interactions.add(e22, t22), this;
        }
        removeInteraction(e22) {
          return this._interactions.remove(e22), this;
        }
        getCooperativeGestures() {
          return this._cooperativeGestures;
        }
        setCooperativeGestures(e22) {
          return this._cooperativeGestures = e22, this;
        }
        setStyle(t22, i22) {
          return i22 = e2.l({}, { localIdeographFontFamily: this._localIdeographFontFamily, localFontFamily: this._localFontFamily }, i22), this.style && t22 && false !== i22.diff && i22.localFontFamily === this._localFontFamily && i22.localIdeographFontFamily === this._localIdeographFontFamily && !i22.config ? (this.style._diffStyle(t22, (o2, s2) => {
            if (o2) {
              const s3 = "string" == typeof o2 ? o2 : o2 instanceof Error ? o2.message : o2.error;
              e2.w(`Unable to perform style diff: ${s3}. Rebuilding the style from scratch.`), this._updateStyle(t22, i22);
            } else s2 && this._update(true);
          }, () => this._postStyleLoadEvent()), this) : (this._localIdeographFontFamily = i22.localIdeographFontFamily, this._localFontFamily = i22.localFontFamily, this._updateStyle(t22, i22));
        }
        _getUIString(e22) {
          const t22 = this._locale[e22];
          if (null == t22) throw new Error(`Missing UI string '${e22}'`);
          return t22;
        }
        _updateStyle(t22, i22) {
          if (this.style && (this.style.setEventedParent(null), this.style._remove(), this.style = void 0), t22) {
            const o2 = e2.l({}, i22);
            i22 && i22.config && (o2.initialConfig = i22.config, delete o2.config), this.style = new Eo(this, o2).load(t22), this.style.setEventedParent(this, { style: this.style });
          }
          return this._updateTerrain(), this;
        }
        _lazyInitEmptyStyle() {
          this.style || (this.style = new Eo(this, {}), this.style.setEventedParent(this, { style: this.style }), this.style.loadEmpty());
        }
        getStyle() {
          if (this.style) return this.style.serialize();
        }
        isStyleLoaded() {
          return this.style ? this.style.loaded() : (e2.w("There is no style added to the map."), false);
        }
        _isValidId(t22) {
          return null == t22 ? (this.fire(new e2.z(new Error("IDs can't be empty."))), false) : !e2.d9(t22) || (this.fire(new e2.z(new Error(`IDs can't contain special symbols: "${t22}".`))), false);
        }
        _isTargetValid(e22) {
          return "featuresetId" in e22 ? this._isValidId("importId" in e22 ? e22.importId : e22.featuresetId) : "layerId" in e22 && this._isValidId(e22.layerId);
        }
        _areTargetsValid(e22) {
          if (Array.isArray(e22)) {
            for (const t22 of e22) if (!this._isValidId(t22)) return false;
            return true;
          }
          return this._isTargetValid(e22);
        }
        addSource(e22, t22) {
          return this._isValidId(e22) ? (this._lazyInitEmptyStyle(), this.style.addSource(e22, t22), this._update(true)) : this;
        }
        isSourceLoaded(e22) {
          return !!this._isValidId(e22) && !!this.style && this.style._isSourceCacheLoaded(e22);
        }
        areTilesLoaded() {
          return this.style.areTilesLoaded();
        }
        addSourceType(e22, t22, i22) {
          this._lazyInitEmptyStyle(), this.style.addSourceType(e22, t22, i22);
        }
        removeSource(e22) {
          return this._isValidId(e22) ? (this.style.removeSource(e22), this._updateTerrain(), this._update(true)) : this;
        }
        getSource(e22) {
          return this._isValidId(e22) ? this.style.getOwnSource(e22) : null;
        }
        addImage(t22, i22, { pixelRatio: o2 = 1, sdf: s2 = false, stretchX: r22, stretchY: n22, content: a22 } = {}) {
          this._lazyInitEmptyStyle();
          const l22 = e2.I.from(t22);
          if (i22 instanceof HTMLImageElement || ImageBitmap && i22 instanceof ImageBitmap) {
            const { width: t3, height: c22, data: h22 } = e2.q.getImageData(i22);
            this.style.addImage(l22, { data: new e2.r({ width: t3, height: c22 }, h22), pixelRatio: o2, stretchX: r22, stretchY: n22, content: a22, sdf: s2, version: 0, usvg: false });
          } else if (void 0 === i22.width || void 0 === i22.height) this.fire(new e2.z(new Error("Invalid arguments to map.addImage(). The second argument must be an `HTMLImageElement`, `ImageData`, `ImageBitmap`, or object with `width`, `height`, and `data` properties with the same format as `ImageData`")));
          else {
            const { width: c22, height: h22 } = i22, d22 = i22;
            this.style.addImage(l22, { data: new e2.r({ width: c22, height: h22 }, new Uint8Array(d22.data)), pixelRatio: o2, stretchX: r22, stretchY: n22, content: a22, sdf: s2, usvg: false, version: 0, userImage: d22 }), d22.onAdd && d22.onAdd(this, t22);
          }
        }
        updateImage(t22, i22) {
          this._lazyInitEmptyStyle();
          const o2 = e2.I.from(t22), s2 = this.style.getImage(o2);
          if (!s2) return void this.fire(new e2.z(new Error("The map has no image with that id. If you are adding a new image use `map.addImage(...)` instead.")));
          const r22 = i22 instanceof HTMLImageElement || ImageBitmap && i22 instanceof ImageBitmap ? e2.q.getImageData(i22) : i22, { width: n22, height: a22, data: l22 } = r22;
          if (void 0 === n22 || void 0 === a22) return void this.fire(new e2.z(new Error("Invalid arguments to map.updateImage(). The second argument must be an `HTMLImageElement`, `ImageData`, `ImageBitmap`, or object with `width`, `height`, and `data` properties with the same format as `ImageData`")));
          if (n22 !== (s2.usvg ? s2.icon.usvg_tree.width : s2.data.width) || a22 !== (s2.usvg ? s2.icon.usvg_tree.height : s2.data.height)) return void this.fire(new e2.z(new Error(`The width and height of the updated image (${n22}, ${a22})
                must be that same as the previous version of the image
                (${s2.data.width}, ${s2.data.height})`)));
          const c22 = !(i22 instanceof HTMLImageElement || ImageBitmap && i22 instanceof ImageBitmap);
          let h22 = false;
          s2.usvg ? (s2.data = new e2.r({ width: n22, height: a22 }, new Uint8Array(l22)), s2.usvg = false, s2.icon = void 0, h22 = true) : s2.data.replace(l22, c22), this.style.updateImage(o2, s2, h22);
        }
        hasImage(t22) {
          return t22 ? !!this.style && !!this.style.getImage(e2.I.from(t22)) : (this.fire(new e2.z(new Error("Missing required image id"))), false);
        }
        removeImage(t22) {
          this.style.removeImage(e2.I.from(t22));
        }
        loadImage(t22, i22) {
          e2.o(this._requestManager.transformRequest(t22, e2.R.Image), (t3, o2) => {
            i22(t3, o2 instanceof HTMLImageElement ? e2.q.getImageData(o2) : o2);
          });
        }
        listImages() {
          return this.style.listImages().map((e22) => e22.name);
        }
        addModel(e22, t22) {
          this._lazyInitEmptyStyle(), this.style.addModel(e22, t22);
        }
        hasModel(t22) {
          return t22 ? this.style.hasModel(t22) : (this.fire(new e2.z(new Error("Missing required model id"))), false);
        }
        removeModel(e22) {
          this.style.removeModel(e22);
        }
        listModels() {
          return this.style.listModels();
        }
        addLayer(e22, t22) {
          return this._isValidId(e22.id) ? (this._lazyInitEmptyStyle(), this.style.addLayer(e22, t22), this._update(true)) : this;
        }
        getSlot(e22) {
          const t22 = this.getLayer(e22);
          return t22 && t22.slot || null;
        }
        setSlot(e22, t22) {
          return this.style.setSlot(e22, t22), this.style.mergeLayers(), this._update(true);
        }
        addImport(t22, i22) {
          return this.style.addImport(t22, i22).catch((t3) => this.fire(new e2.z(new Error("Failed to add import", t3)))), this;
        }
        updateImport(e22, t22) {
          return "string" != typeof t22 && t22.id !== e22 ? (this.removeImport(e22), this.addImport(t22)) : (this.style.updateImport(e22, t22), this._update(true));
        }
        removeImport(e22) {
          return this.style.removeImport(e22), this;
        }
        moveImport(e22, t22) {
          return this.style.moveImport(e22, t22), this._update(true);
        }
        moveLayer(e22, t22) {
          return this._isValidId(e22) ? (this.style.moveLayer(e22, t22), this._update(true)) : this;
        }
        removeLayer(e22) {
          return this._isValidId(e22) ? (this.style.removeLayer(e22), this._update(true)) : this;
        }
        getLayer(e22) {
          if (!this._isValidId(e22)) return null;
          const t22 = this.style.getOwnLayer(e22);
          return t22 ? "custom" === t22.type ? t22.implementation : t22.serialize() : void 0;
        }
        getSlots() {
          return this.style.getSlots();
        }
        setLayerZoomRange(e22, t22, i22) {
          return this._isValidId(e22) ? (this.style.setLayerZoomRange(e22, t22, i22), this._update(true)) : this;
        }
        setFilter(e22, t22, i22 = {}) {
          return this._isValidId(e22) ? (this.style.setFilter(e22, t22, i22), this._update(true)) : this;
        }
        getFilter(e22) {
          return this._isValidId(e22) ? this.style.getFilter(e22) : null;
        }
        setPaintProperty(e22, t22, i22, o2 = {}) {
          return this._isValidId(e22) ? (this.style.setPaintProperty(e22, t22, i22, o2), this._update(true)) : this;
        }
        getPaintProperty(e22, t22) {
          return this._isValidId(e22) ? this.style.getPaintProperty(e22, t22) : null;
        }
        setLayoutProperty(e22, t22, i22, o2 = {}) {
          return this._isValidId(e22) ? (this.style.setLayoutProperty(e22, t22, i22, o2), this._update(true)) : this;
        }
        getLayoutProperty(e22, t22) {
          return this._isValidId(e22) ? this.style.getLayoutProperty(e22, t22) : null;
        }
        getGlyphsUrl() {
          return this.style.getGlyphsUrl();
        }
        setGlyphsUrl(e22) {
          return this.style.setGlyphsUrl(e22), this._update(true);
        }
        getSchema(e22) {
          return this.style.getSchema(e22);
        }
        setSchema(e22, t22) {
          return this.style.setSchema(e22, t22), this._update(true);
        }
        getConfig(e22) {
          return this.style.getConfig(e22);
        }
        setConfig(e22, t22) {
          return this.style.setConfig(e22, t22), this._update(true);
        }
        getConfigProperty(e22, t22) {
          return this.style.getConfigProperty(e22, t22);
        }
        setConfigProperty(e22, t22, i22) {
          return this.style.setConfigProperty(e22, t22, i22), this._update(true);
        }
        getFeaturesetDescriptors(e22) {
          return this.style.getFeaturesetDescriptors(e22);
        }
        setLights(e22) {
          if (this._lazyInitEmptyStyle(), e22 && 1 === e22.length && "flat" === e22[0].type) {
            const t22 = e22[0];
            t22.properties ? this.style.setFlatLight(t22.properties, t22.id, {}) : this.style.setFlatLight({}, "flat");
          } else this.style.setLights(e22), this.painter.terrain && (this.painter.terrain.invalidateRenderCache = true);
          return this._update(true);
        }
        getLights() {
          const e22 = this.style.getLights() || [];
          return 0 === e22.length && e22.push({ id: this.style.light.id, type: "flat", properties: this.style.getFlatLight() }), e22;
        }
        setLight(e22, t22 = {}) {
          return console.log("The `map.setLight` function is deprecated, prefer using `map.setLights` with `flat` light type instead."), this.setLights([{ id: "flat", type: "flat", properties: e22 }]);
        }
        getLight() {
          return console.log("The `map.getLight` function is deprecated, prefer using `map.getLights` instead."), this.style.getFlatLight();
        }
        setTerrain(e22) {
          return this._lazyInitEmptyStyle(), !e22 && this.transform.projection.requiresDraping ? this.style.setTerrainForDraping() : this.style.setTerrain(e22), this._averageElevationLastSampledAt = -1 / 0, this._update(true);
        }
        getTerrain() {
          return this.style ? this.style.getTerrain() : null;
        }
        setFog(e22) {
          return this._lazyInitEmptyStyle(), this.style.setFog(e22), this._update(true);
        }
        getFog() {
          return this.style ? this.style.getFog() : null;
        }
        setSnow(e22) {
          return this._lazyInitEmptyStyle(), this.style.setSnow(e22), this._update(true);
        }
        getSnow() {
          return this.style ? this.style.getSnow() : null;
        }
        setRain(e22) {
          return this._lazyInitEmptyStyle(), this.style.setRain(e22), this._update(true);
        }
        getRain() {
          return this.style ? this.style.getRain() : null;
        }
        setColorTheme(e22) {
          return this._lazyInitEmptyStyle(), this.style.setColorTheme(e22), this._update(true);
        }
        setImportColorTheme(e22, t22) {
          return this._lazyInitEmptyStyle(), this.style.setImportColorTheme(e22, t22), this._update(true);
        }
        setCamera(e22) {
          return this.style.setCamera(e22), this._triggerCameraUpdate(e22);
        }
        _triggerCameraUpdate(e22) {
          return this._update(this.transform.setOrthographicProjectionAtLowPitch("orthographic" === e22["camera-projection"]));
        }
        getCamera() {
          return this.style.camera;
        }
        _queryFogOpacity(t22) {
          return this.style && this.style.fog ? this.style.fog.getOpacityAtLatLng(e2.cd.convert(t22), this.transform) : 0;
        }
        setFeatureState(e22, t22) {
          return e22.source && !this._isValidId(e22.source) ? this : (this.style.setFeatureState(e22, t22), this._update());
        }
        removeFeatureState(e22, t22) {
          return e22.source && !this._isValidId(e22.source) ? this : (this.style.removeFeatureState(e22, t22), this._update());
        }
        getFeatureState(e22) {
          return e22.source && !this._isValidId(e22.source) ? null : this.style.getFeatureState(e22);
        }
        _updateContainerDimensions() {
          if (!this._container) return;
          const e22 = this._container.getBoundingClientRect().width || 400, t22 = this._container.getBoundingClientRect().height || 300;
          let i22, o2, s2, r22 = this._container;
          for (; r22 && (!o2 || !s2); ) {
            const e3 = window.getComputedStyle(r22).transform;
            e3 && "none" !== e3 && (i22 = e3.match(/matrix.*\((.+)\)/)[1].split(", "), i22[0] && "0" !== i22[0] && "1" !== i22[0] && (o2 = i22[0]), i22[3] && "0" !== i22[3] && "1" !== i22[3] && (s2 = i22[3])), r22 = r22.parentElement;
          }
          this._containerWidth = o2 ? Math.abs(e22 / o2) : e22, this._containerHeight = s2 ? Math.abs(t22 / s2) : t22;
        }
        _detectMissingCSS() {
          "rgb(250, 128, 114)" !== window.getComputedStyle(this._missingCSSCanary).getPropertyValue("background-color") && e2.w("This page appears to be missing CSS declarations for Mapbox GL JS, which may cause the map to display incorrectly. Please ensure your page includes mapbox-gl.css, as described in https://www.mapbox.com/mapbox-gl-js/api/.");
        }
        _setupContainer() {
          const e22 = this._container;
          e22.classList.add("mapboxgl-map"), (this._missingCSSCanary = l2("div", "mapboxgl-canary", e22)).style.visibility = "hidden", this._detectMissingCSS();
          const t22 = this._canvasContainer = l2("div", "mapboxgl-canvas-container", e22);
          this._canvas = l2("canvas", "mapboxgl-canvas", t22), this._interactive && (t22.classList.add("mapboxgl-interactive"), this._canvas.setAttribute("tabindex", "0")), this._canvas.addEventListener("webglcontextlost", this._contextLost, false), this._canvas.addEventListener("webglcontextrestored", this._contextRestored, false), this._canvas.setAttribute("aria-label", this._getUIString("Map.Title")), this._canvas.setAttribute("role", "region"), this._updateContainerDimensions(), this._resizeCanvas(this._containerWidth, this._containerHeight);
          const i22 = this._controlContainer = l2("div", "mapboxgl-control-container", e22), o2 = this._controlPositions = {};
          ["top-left", "top", "top-right", "right", "bottom-right", "bottom", "bottom-left", "left"].forEach((e3) => {
            o2[e3] = l2("div", `mapboxgl-ctrl-${e3}`, i22);
          }), this._container.addEventListener("scroll", this._onMapScroll, false);
        }
        _resizeCanvas(t22, i22) {
          const o2 = e2.q.devicePixelRatio || 1;
          this._canvas.width = o2 * Math.ceil(t22), this._canvas.height = o2 * Math.ceil(i22), this._canvas.style.width = `${t22}px`, this._canvas.style.height = `${i22}px`;
        }
        _addMarker(e22) {
          this._markers.push(e22);
        }
        _removeMarker(e22) {
          const t22 = this._markers.indexOf(e22);
          -1 !== t22 && this._markers.splice(t22, 1);
        }
        _addPopup(e22) {
          this._popups.push(e22);
        }
        _removePopup(e22) {
          const t22 = this._popups.indexOf(e22);
          -1 !== t22 && this._popups.splice(t22, 1);
        }
        _setupPainter() {
          const t22 = e2.l({}, a2.supported.webGLContextAttributes, { failIfMajorPerformanceCaveat: this._failIfMajorPerformanceCaveat, preserveDrawingBuffer: this._preserveDrawingBuffer, antialias: this._antialias || false }), i22 = this._canvas.getContext("webgl2", t22);
          i22 ? (j2(i22, true), this.painter = new ia(i22, this._contextCreateOptions, this.transform, this._scaleFactor, this._tp), this.on("data", (e22) => {
            "source" === e22.dataType && this.painter.setTileLoadedFlag(true);
          }), e2.m.testSupport(i22)) : this.fire(new e2.z(new Error("Failed to initialize WebGL")));
        }
        _contextLost(t22) {
          t22.preventDefault(), this._frame && (this._frame.cancel(), this._frame = null), this.fire(new e2.A("webglcontextlost", { originalEvent: t22 }));
        }
        _contextRestored(t22) {
          this._setupPainter(), this.painter.resize(Math.ceil(this._containerWidth), Math.ceil(this._containerHeight)), this._updateTerrain(), this.style && (this.style.reloadModels(), this.style.clearSources()), this._update(), this.fire(new e2.A("webglcontextrestored", { originalEvent: t22 }));
        }
        _onMapScroll(e22) {
          if (e22.target === this._container) return this._container.scrollTop = 0, this._container.scrollLeft = 0, false;
        }
        idle() {
          return !this.isMoving() && this.loaded();
        }
        loaded() {
          return !this._styleDirty && !this._sourcesDirty && !!this.style && this.style.loaded();
        }
        frameReady() {
          return this.loaded() && !this._placementDirty;
        }
        _update(e22) {
          return this.style ? (this._styleDirty = this._styleDirty || e22, this._sourcesDirty = true, this.triggerRepaint(), this) : this;
        }
        _requestRenderFrame(e22) {
          return this._update(), this._renderTaskQueue.add(e22);
        }
        _cancelRenderFrame(e22) {
          this._renderTaskQueue.remove(e22);
        }
        _requestDomTask(e22) {
          !this.loaded() || this.loaded() && !this.isMoving() ? e22() : this._domRenderTaskQueue.add(e22);
        }
        _render(t22) {
          let s2;
          this.fire(new e2.A("renderstart")), ++this._frameId;
          const r22 = this.painter.context.extTimerQuery, n22 = e2.q.now(), a22 = this.painter.context.gl;
          if (this.listens("gpu-timing-frame") && (s2 = a22.createQuery(), a22.beginQuery(r22.TIME_ELAPSED_EXT, s2)), this.painter.context.setDirty(), this.painter.setBaseState(), (this.isMoving() || this.isRotating() || this.isZooming()) && (this._interactionRange[0] = Math.min(this._interactionRange[0], performance.now()), this._interactionRange[1] = Math.max(this._interactionRange[1], performance.now())), this._renderTaskQueue.run(t22), this._domRenderTaskQueue.run(t22), this._removed) return;
          this._updateProjectionTransition();
          const l22 = this._isInitialLoad ? 0 : this._fadeDuration;
          if (this.style && this._styleDirty) {
            this._styleDirty = false;
            const t3 = this.transform.zoom, i22 = this.transform.pitch, o2 = e2.q.now(), s3 = new e2.aa(t3, { now: o2, fadeDuration: l22, pitch: i22, transition: this.style.transition });
            this.style.update(s3);
          }
          this.style && this.style.hasFogTransition() && (this.style._markersNeedUpdate = true, this._sourcesDirty = true);
          let c22 = false;
          this.style && this._sourcesDirty ? (this._sourcesDirty = false, this.painter._updateFog(this.style), this._updateTerrain(), c22 = this._updateAverageElevation(n22), this.style.updateSources(this.transform), this.style.updateImageProviders(), this.isMoving() || this._forceMarkerAndPopupUpdate()) : c22 = this._updateAverageElevation(n22);
          const h22 = this.style && this.style._updatePlacement(this.painter, this.painter.transform, this.showCollisionBoxes, l22, this._crossSourceCollisions, this.painter.replacementSource, this._scaleFactorChanged);
          if (this._scaleFactorChanged && (this._scaleFactorChanged = false), h22 && (this._placementDirty = h22.needsRerender), this.style && this.painter.render(this.style, { showTileBoundaries: this.showTileBoundaries, showParseStatus: this.showParseStatus, wireframe: { terrain: this.showTerrainWireframe, layers2D: this.showLayers2DWireframe, layers3D: this.showLayers3DWireframe }, showOverdrawInspector: this._showOverdrawInspector, showQueryGeometry: !!this._showQueryGeometry, showTileAABBs: this.showTileAABBs, rotating: this.isRotating(), zooming: this.isZooming(), moving: this.isMoving(), fadeDuration: l22, isInitialLoad: this._isInitialLoad, showPadding: this.showPadding, gpuTiming: !!this.listens("gpu-timing-layer"), gpuTimingDeferredRender: !!this.listens("gpu-timing-deferred-render"), speedIndexTiming: this.speedIndexTiming }), this.fire(new e2.A("render")), this.loaded() && !this._loaded && (this._loaded = true, o.mark(i2.load), this.fire(new e2.A("load"))), this.style && this.style.hasTransitions() && (this._styleDirty = true), this.style && (this.style.snow || this.style.rain) && (this._styleDirty = true), this.style && this.style.imageManager.hasPatternsInFlight() && (this._styleDirty = true), this.style && !this.style.modelManager.isLoaded() && (this._styleDirty = true), this.style && !this._placementDirty && this.style._releaseSymbolFadeTiles(), s2) {
            const t3 = e2.q.now() - n22;
            a22.endQuery(r22.TIME_ELAPSED_EXT), setTimeout(() => {
              const i22 = a22.getQueryParameter(s2, a22.QUERY_RESULT) / 1e6;
              a22.deleteQuery(s2), this.fire(new e2.A("gpu-timing-frame", { cpuTime: t3, gpuTime: i22 }));
            }, 50);
          }
          if (this.listens("gpu-timing-layer")) {
            const t3 = this.painter.collectGpuTimers();
            setTimeout(() => {
              const i22 = this.painter.queryGpuTimers(t3);
              this.fire(new e2.A("gpu-timing-layer", { layerTimes: i22 }));
            }, 50);
          }
          if (this.listens("gpu-timing-deferred-render")) {
            const t3 = this.painter.collectDeferredRenderGpuQueries();
            setTimeout(() => {
              const i22 = this.painter.queryGpuTimeDeferredRender(t3);
              this.fire(new e2.A("gpu-timing-deferred-render", { gpuTime: i22 }));
            }, 50);
          }
          const d22 = this._sourcesDirty || this._styleDirty || this._placementDirty || c22;
          if (d22 || this._repaint) this.triggerRepaint();
          else {
            const t3 = this.idle();
            if (t3 && (c22 = this._updateAverageElevation(n22, true)), c22) this.triggerRepaint();
            else if (this._triggerFrame(false), t3 && (this.fire(new e2.A("idle")), this._isInitialLoad = false, this.speedIndexTiming)) {
              const t4 = this._calculateSpeedIndex();
              this.fire(new e2.A("speedindexcompleted", { speedIndex: t4 })), this.speedIndexTiming = false;
            }
          }
          !this._loaded || this._fullyLoaded || d22 || (this._fullyLoaded = true, o.mark(i2.fullLoad), this._performanceMetricsCollection && B2(this._requestManager._customAccessToken, { width: this.painter.width, height: this.painter.height, interactionRange: this._interactionRange, visibilityHidden: this._visibilityHidden, terrainEnabled: !!this.painter.style.getTerrain(), fogEnabled: !!this.painter.style.getFog(), projection: this.getProjection().name, zoom: this.transform.zoom, renderer: this.painter.context.renderer, vendor: this.painter.context.vendor }), this._authenticate());
        }
        _forceMarkerAndPopupUpdate(e22) {
          for (const t22 of this._markers) e22 && !this.getRenderWorldCopies() && (t22._lngLat = t22._lngLat.wrap()), t22._update();
          for (const t22 of this._popups) !e22 || this.getRenderWorldCopies() || t22._trackPointer || (t22._lngLat = t22._lngLat.wrap()), t22._update();
        }
        _updateAverageElevation(e22, t22 = false) {
          const i22 = (e3) => (this.transform.averageElevation = e3, this._update(false), true);
          if (!this.painter.averageElevationNeedsEasing()) return 0 !== this.transform.averageElevation && i22(0);
          const o2 = this.transform.elevation && this.transform.elevation.exaggeration() !== this._averageElevationExaggeration;
          if (o2 || (t22 || e22 - this._averageElevationLastSampledAt > 500) && !this._averageElevation.isEasing(e22)) {
            const t3 = this.transform.averageElevation;
            let s2 = this.transform.sampleAverageElevation();
            null != this.transform.elevation && (this._averageElevationExaggeration = this.transform.elevation.exaggeration()), isNaN(s2) ? s2 = 0 : this._averageElevationLastSampledAt = e22;
            const r22 = Math.abs(t3 - s2);
            if (r22 > 1) {
              if (this._isInitialLoad || o2) return this._averageElevation.jumpTo(s2), i22(s2);
              this._averageElevation.easeTo(s2, e22, 300);
            } else if (r22 > 1e-4) return this._averageElevation.jumpTo(s2), i22(s2);
          }
          return !!this._averageElevation.isEasing(e22) && i22(this._averageElevation.getValue(e22));
        }
        _authenticate() {
          N2(this._getMapId(), this._requestManager._skuToken, this._requestManager._customAccessToken, (t22) => {
            if (t22 && (t22.message === w2 || 401 === t22.status)) {
              const t3 = this.painter.context.gl;
              j2(t3, false), this._logoControl instanceof rl && this._logoControl._updateLogo(), t3 && t3.clear(t3.DEPTH_BUFFER_BIT | t3.COLOR_BUFFER_BIT | t3.STENCIL_BUFFER_BIT), this._silenceAuthErrors || this.fire(new e2.z(new Error("A valid Mapbox access token is required to use Mapbox GL JS. To create an account or a new access token, visit https://account.mapbox.com/")));
            }
          }), z2(this._getMapId(), this._requestManager._skuToken, this._requestManager._customAccessToken, () => {
          });
        }
        _postStyleLoadEvent() {
          this.style.globalId && O(this._requestManager._customAccessToken, { map: this, style: this.style.globalId, importedStyles: this.style.getImportGlobalIds() });
        }
        _updateTerrain() {
          const e22 = this._isDragging();
          this.painter.updateTerrain(this.style, e22);
        }
        _calculateSpeedIndex() {
          const e22 = this.painter.canvasCopy(), t22 = this.painter.getCanvasCopiesAndTimestamps();
          t22.timeStamps.push(performance.now());
          const i22 = this.painter.context.gl, o2 = i22.createFramebuffer();
          function s2(e3) {
            i22.framebufferTexture2D(i22.FRAMEBUFFER, i22.COLOR_ATTACHMENT0, i22.TEXTURE_2D, e3, 0);
            const t3 = new Uint8Array(i22.drawingBufferWidth * i22.drawingBufferHeight * 4);
            return i22.readPixels(0, 0, i22.drawingBufferWidth, i22.drawingBufferHeight, i22.RGBA, i22.UNSIGNED_BYTE, t3), t3;
          }
          return i22.bindFramebuffer(i22.FRAMEBUFFER, o2), this._canvasPixelComparison(s2(e22), t22.canvasCopies.map(s2), t22.timeStamps);
        }
        _canvasPixelComparison(e22, t22, i22) {
          let o2 = i22[1] - i22[0];
          const s2 = e22.length / 4;
          for (let r22 = 0; r22 < t22.length; r22++) {
            const n22 = t22[r22];
            let a22 = 0;
            for (let t3 = 0; t3 < n22.length; t3 += 4) n22[t3] === e22[t3] && n22[t3 + 1] === e22[t3 + 1] && n22[t3 + 2] === e22[t3 + 2] && n22[t3 + 3] === e22[t3 + 3] && (a22 += 1);
            o2 += (i22[r22 + 2] - i22[r22 + 1]) * (1 - a22 / s2);
          }
          return o2;
        }
        remove() {
          this._hash && this._hash.remove();
          for (const e22 of this._controls) e22.onRemove(this);
          this._controls = [], this._frame && (this._frame.cancel(), this._frame = null), this._renderTaskQueue.clear(), this._domRenderTaskQueue.clear(), this.style && this.style.destroy(), this.indoor.destroy(), this.painter.destroy(), this.handlers && this.handlers.destroy(), this.handlers = void 0, this.setStyle(null), window.removeEventListener("resize", this._onWindowResize, false), window.removeEventListener("orientationchange", this._onWindowResize, false), window.removeEventListener(this._fullscreenchangeEvent, this._onWindowResize, false), window.removeEventListener("online", this._onWindowOnline, false), window.removeEventListener("visibilitychange", this._onVisibilityChange, false);
          const t22 = this.painter.context.gl.getExtension("WEBGL_lose_context");
          t22 && t22.loseContext(), this._canvas.removeEventListener("webglcontextlost", this._contextLost, false), this._canvas.removeEventListener("webglcontextrestored", this._contextRestored, false), this._canvasContainer.remove(), this._controlContainer.remove(), this._missingCSSCanary.remove(), this._canvas = void 0, this._canvasContainer = void 0, this._controlContainer = void 0, this._missingCSSCanary = void 0, this._container.classList.remove("mapboxgl-map"), this._container.removeEventListener("scroll", this._onMapScroll, false), U2.delete(this.painter.context.gl), k2.remove(), P2.remove(), this._removed = true, this.fire(new e2.A("remove"));
        }
        triggerRepaint() {
          this._triggerFrame(true);
        }
        _triggerFrame(t22) {
          this._renderNextFrame = this._renderNextFrame || t22, this.style && !this._frame && (this._frame = e2.q.frame((e22) => {
            const t3 = !!this._renderNextFrame;
            this._frame = null, this._renderNextFrame = null, t3 && this._render(e22);
          }));
        }
        _preloadTiles(t22) {
          const i22 = this.style ? this.style.getSourceCaches() : [];
          return e2.bt(i22, (e22, i3) => e22._preloadTiles(t22, i3), () => {
            this.triggerRepaint();
          }), this;
        }
        _onWindowOnline() {
          this._update();
        }
        _onWindowResize(e22) {
          this._trackResize && this.resize({ originalEvent: e22 })._update();
        }
        _onVisibilityChange() {
          "hidden" === document.visibilityState && this._visibilityHidden++;
        }
        get showTileBoundaries() {
          return !!this._showTileBoundaries;
        }
        set showTileBoundaries(e22) {
          this._showTileBoundaries !== e22 && (this._showTileBoundaries = e22, this._tp.refreshUI(), this._update());
        }
        get showParseStatus() {
          return !!this._showParseStatus;
        }
        set showParseStatus(e22) {
          this._showParseStatus !== e22 && (this._showParseStatus = e22, this._tp.refreshUI(), this._update());
        }
        get showTerrainWireframe() {
          return !!this._showTerrainWireframe;
        }
        set showTerrainWireframe(e22) {
          this._showTerrainWireframe !== e22 && (this._showTerrainWireframe = e22, this._tp.refreshUI(), this._update());
        }
        get showLayers2DWireframe() {
          return !!this._showLayers2DWireframe;
        }
        set showLayers2DWireframe(e22) {
          this._showLayers2DWireframe !== e22 && (this._showLayers2DWireframe = e22, this._tp.refreshUI(), this._update());
        }
        get showLayers3DWireframe() {
          return !!this._showLayers3DWireframe;
        }
        set showLayers3DWireframe(e22) {
          this._showLayers3DWireframe !== e22 && (this._showLayers3DWireframe = e22, this._tp.refreshUI(), this._update());
        }
        get speedIndexTiming() {
          return !!this._speedIndexTiming;
        }
        set speedIndexTiming(e22) {
          this._speedIndexTiming !== e22 && (this._speedIndexTiming = e22, this._update());
        }
        get showPadding() {
          return !!this._showPadding;
        }
        set showPadding(e22) {
          this._showPadding !== e22 && (this._showPadding = e22, this._tp.refreshUI(), this._update());
        }
        get showCollisionBoxes() {
          return !!this._showCollisionBoxes;
        }
        set showCollisionBoxes(e22) {
          this._showCollisionBoxes !== e22 && (this._showCollisionBoxes = e22, this._tp.refreshUI(), e22 ? this.style._generateCollisionBoxes() : this._update());
        }
        get showOverdrawInspector() {
          return !!this._showOverdrawInspector;
        }
        set showOverdrawInspector(e22) {
          this._showOverdrawInspector !== e22 && (this._showOverdrawInspector = e22, this._tp.refreshUI(), this._update());
        }
        get repaint() {
          return !!this._repaint;
        }
        set repaint(e22) {
          this._repaint !== e22 && (this._repaint = e22, this._tp.refreshUI(), this.triggerRepaint());
        }
        get vertices() {
          return !!this._vertices;
        }
        set vertices(e22) {
          this._vertices = e22, this._update();
        }
        get showTileAABBs() {
          return !!this._showTileAABBs;
        }
        set showTileAABBs(e22) {
          this._showTileAABBs !== e22 && (this._showTileAABBs = e22, this._tp.refreshUI(), e22 && this._update());
        }
        _setCacheLimits(t22, i22) {
          e2.eJ(t22, i22);
        }
        get version() {
          return t2;
        }
      }, NavigationControl: class {
        constructor(t22 = {}) {
          this.options = e2.l({}, _l, t22), this._container = l2("div", "mapboxgl-ctrl mapboxgl-ctrl-group"), this._container.addEventListener("contextmenu", (e22) => e22.preventDefault()), this.options.showZoom && (e2.aV(["_setButtonTitle", "_updateZoomButtons"], this), this._zoomInButton = this._createButton("mapboxgl-ctrl-zoom-in", (e22) => {
            this._map && this._map.zoomIn({}, { originalEvent: e22 });
          }), l2("span", "mapboxgl-ctrl-icon", this._zoomInButton).setAttribute("aria-hidden", "true"), this._zoomOutButton = this._createButton("mapboxgl-ctrl-zoom-out", (e22) => {
            this._map && this._map.zoomOut({}, { originalEvent: e22 });
          }), l2("span", "mapboxgl-ctrl-icon", this._zoomOutButton).setAttribute("aria-hidden", "true")), this.options.showCompass && (e2.aV(["_rotateCompassArrow"], this), this._compass = this._createButton("mapboxgl-ctrl-compass", (e22) => {
            const t3 = this._map;
            t3 && (this.options.visualizePitch ? t3.resetNorthPitch({}, { originalEvent: e22 }) : t3.resetNorth({}, { originalEvent: e22 }));
          }), this._compassIcon = l2("span", "mapboxgl-ctrl-icon", this._compass), this._compassIcon.setAttribute("aria-hidden", "true"));
        }
        _updateZoomButtons() {
          const e22 = this._map;
          if (!e22) return;
          const t22 = e22.getZoom(), i22 = t22 === e22.getMaxZoom(), o2 = t22 === e22.getMinZoom();
          this._zoomInButton.disabled = i22, this._zoomOutButton.disabled = o2, this._zoomInButton.setAttribute("aria-disabled", i22.toString()), this._zoomOutButton.setAttribute("aria-disabled", o2.toString());
        }
        _rotateCompassArrow() {
          const e22 = this._map;
          if (!e22) return;
          const t22 = this.options.visualizePitch ? `scale(${1 / Math.pow(Math.cos(e22.transform.pitch * (Math.PI / 180)), 0.5)}) rotateX(${e22.transform.pitch}deg) rotateZ(${e22.transform.angle * (180 / Math.PI)}deg)` : `rotate(${e22.transform.angle * (180 / Math.PI)}deg)`;
          e22._requestDomTask(() => {
            this._compassIcon && (this._compassIcon.style.transform = t22);
          });
        }
        onAdd(e22) {
          return this._map = e22, this.options.showZoom && (this._setButtonTitle(this._zoomInButton, "ZoomIn"), this._setButtonTitle(this._zoomOutButton, "ZoomOut"), e22.on("zoom", this._updateZoomButtons), this._updateZoomButtons()), this.options.showCompass && (this._setButtonTitle(this._compass, "ResetBearing"), this.options.visualizePitch && e22.on("pitch", this._rotateCompassArrow), e22.on("rotate", this._rotateCompassArrow), this._rotateCompassArrow(), this._handler = new pl(e22, this._compass, this.options.visualizePitch)), this._container;
        }
        onRemove() {
          const e22 = this._map;
          e22 && (this._container.remove(), this.options.showZoom && e22.off("zoom", this._updateZoomButtons), this.options.showCompass && (this.options.visualizePitch && e22.off("pitch", this._rotateCompassArrow), e22.off("rotate", this._rotateCompassArrow), this._handler && this._handler.off(), this._handler = void 0), this._map = void 0);
        }
        _createButton(e22, t22) {
          const i22 = l2("button", e22, this._container);
          return i22.type = "button", i22.addEventListener("click", t22), i22;
        }
        _setButtonTitle(e22, t22) {
          if (!this._map) return;
          const i22 = this._map._getUIString(`NavigationControl.${t22}`);
          e22.setAttribute("aria-label", i22), e22.firstElementChild && e22.firstElementChild.setAttribute("title", i22);
        }
      }, GeolocateControl: class extends e2.E {
        constructor(t22 = {}) {
          super();
          const i22 = navigator.geolocation;
          this.options = e2.l({ geolocation: i22 }, yl, t22), e2.aV(["_onSuccess", "_onError", "_onZoom", "_finish", "_setupUI", "_updateCamera", "_updateMarker", "_updateMarkerRotation", "_onDeviceOrientation"], this), this._updateMarkerRotationThrottled = oa(this._updateMarkerRotation, 20), this._numberOfWatches = 0;
        }
        onAdd(e22) {
          return this._map = e22, this._container = l2("div", "mapboxgl-ctrl mapboxgl-ctrl-group"), this._checkGeolocationSupport(this._setupUI), this._container;
        }
        onRemove() {
          void 0 !== this._geolocationWatchID && (this.options.geolocation.clearWatch(this._geolocationWatchID), this._geolocationWatchID = void 0), this.options.showUserLocation && this._userLocationDotMarker && this._userLocationDotMarker.remove(), this.options.showAccuracyCircle && this._accuracyCircleMarker && this._accuracyCircleMarker.remove(), this._container.remove(), this._map.off("zoom", this._onZoom), this._map = void 0, this._numberOfWatches = 0, this._noTimeout = false;
        }
        _checkGeolocationSupport(e22) {
          const t22 = (t3 = !!this.options.geolocation) => {
            this._supportsGeolocation = t3, e22(t3);
          };
          void 0 !== this._supportsGeolocation ? e22(this._supportsGeolocation) : void 0 !== navigator.permissions ? navigator.permissions.query({ name: "geolocation" }).then((e3) => t22("denied" !== e3.state)).catch(() => t22()) : t22();
        }
        _isOutOfMapMaxBounds(e22) {
          const t22 = this._map.getMaxBounds(), i22 = e22.coords;
          return !!t22 && (i22.longitude < t22.getWest() || i22.longitude > t22.getEast() || i22.latitude < t22.getSouth() || i22.latitude > t22.getNorth());
        }
        _setErrorState() {
          switch (this._watchState) {
            case "WAITING_ACTIVE":
              this._watchState = "ACTIVE_ERROR", this._geolocateButton.classList.remove("mapboxgl-ctrl-geolocate-active"), this._geolocateButton.classList.add("mapboxgl-ctrl-geolocate-active-error");
              break;
            case "ACTIVE_LOCK":
              this._watchState = "ACTIVE_ERROR", this._geolocateButton.classList.remove("mapboxgl-ctrl-geolocate-active"), this._geolocateButton.classList.add("mapboxgl-ctrl-geolocate-active-error"), this._geolocateButton.classList.add("mapboxgl-ctrl-geolocate-waiting");
              break;
            case "BACKGROUND":
              this._watchState = "BACKGROUND_ERROR", this._geolocateButton.classList.remove("mapboxgl-ctrl-geolocate-background"), this._geolocateButton.classList.add("mapboxgl-ctrl-geolocate-background-error"), this._geolocateButton.classList.add("mapboxgl-ctrl-geolocate-waiting");
          }
        }
        _onSuccess(t22) {
          if (this._map) {
            if (this._isOutOfMapMaxBounds(t22)) return this._setErrorState(), this.fire(new e2.A("outofmaxbounds", t22)), this._updateMarker(), void this._finish();
            if (this.options.trackUserLocation) switch (this._lastKnownPosition = t22, this._watchState) {
              case "WAITING_ACTIVE":
              case "ACTIVE_LOCK":
              case "ACTIVE_ERROR":
                this._watchState = "ACTIVE_LOCK", this._geolocateButton.classList.remove("mapboxgl-ctrl-geolocate-waiting"), this._geolocateButton.classList.remove("mapboxgl-ctrl-geolocate-active-error"), this._geolocateButton.classList.add("mapboxgl-ctrl-geolocate-active");
                break;
              case "BACKGROUND":
              case "BACKGROUND_ERROR":
                this._watchState = "BACKGROUND", this._geolocateButton.classList.remove("mapboxgl-ctrl-geolocate-waiting"), this._geolocateButton.classList.remove("mapboxgl-ctrl-geolocate-background-error"), this._geolocateButton.classList.add("mapboxgl-ctrl-geolocate-background");
            }
            this.options.showUserLocation && "OFF" !== this._watchState && this._updateMarker(t22), this.options.trackUserLocation && "ACTIVE_LOCK" !== this._watchState || this._updateCamera(t22), this.options.showUserLocation && this._userLocationDotMarker.removeClassName("mapboxgl-user-location-dot-stale"), this.fire(new e2.A("geolocate", t22)), this._finish();
          }
        }
        _updateCamera(t22) {
          const i22 = new e2.cd(t22.coords.longitude, t22.coords.latitude), o2 = t22.coords.accuracy, s2 = this._map.getBearing(), r22 = e2.l({ bearing: s2 }, this.options.fitBoundsOptions);
          this._map.fitBounds(i22.toBounds(o2), r22, { geolocateSource: true });
        }
        _updateMarker(t22) {
          if (t22) {
            const i22 = new e2.cd(t22.coords.longitude, t22.coords.latitude);
            this._accuracyCircleMarker.setLngLat(i22).addTo(this._map), this._userLocationDotMarker.setLngLat(i22).addTo(this._map), this._accuracy = t22.coords.accuracy, this.options.showUserLocation && this.options.showAccuracyCircle && this._updateCircleRadius();
          } else this._userLocationDotMarker.remove(), this._accuracyCircleMarker.remove();
        }
        _updateCircleRadius() {
          const t22 = this._map.transform, i22 = e2.c6(1, t22._center.lat) * t22.worldSize, o2 = Math.ceil(2 * this._accuracy * i22);
          this._circleElement.style.width = `${o2}px`, this._circleElement.style.height = `${o2}px`;
        }
        _onZoom() {
          this.options.showUserLocation && this.options.showAccuracyCircle && this._updateCircleRadius();
        }
        _updateMarkerRotation() {
          this._userLocationDotMarker && "number" == typeof this._heading ? (this._userLocationDotMarker.setRotation(this._heading), this._userLocationDotMarker.addClassName("mapboxgl-user-location-show-heading")) : (this._userLocationDotMarker.removeClassName("mapboxgl-user-location-show-heading"), this._userLocationDotMarker.setRotation(0));
        }
        _onError(t22) {
          if (this._map) {
            if (this.options.trackUserLocation) if (1 === t22.code) {
              this._watchState = "OFF", this._geolocateButton.classList.remove("mapboxgl-ctrl-geolocate-waiting"), this._geolocateButton.classList.remove("mapboxgl-ctrl-geolocate-active"), this._geolocateButton.classList.remove("mapboxgl-ctrl-geolocate-active-error"), this._geolocateButton.classList.remove("mapboxgl-ctrl-geolocate-background"), this._geolocateButton.classList.remove("mapboxgl-ctrl-geolocate-background-error"), this._geolocateButton.disabled = true;
              const e22 = this._map._getUIString("GeolocateControl.LocationNotAvailable");
              this._geolocateButton.setAttribute("aria-label", e22), this._geolocateButton.firstElementChild && this._geolocateButton.firstElementChild.setAttribute("title", e22), void 0 !== this._geolocationWatchID && this._clearWatch();
            } else {
              if (3 === t22.code && this._noTimeout) return;
              this._setErrorState();
            }
            "OFF" !== this._watchState && this.options.showUserLocation && this._userLocationDotMarker.addClassName("mapboxgl-user-location-dot-stale"), this.fire(new e2.A("error", t22)), this._finish();
          }
        }
        _finish() {
          this._timeoutId && clearTimeout(this._timeoutId), this._timeoutId = void 0;
        }
        _setupUI(t22) {
          if (void 0 !== this._map) {
            if (this._container.addEventListener("contextmenu", (e22) => e22.preventDefault()), this._geolocateButton = l2("button", "mapboxgl-ctrl-geolocate", this._container), l2("span", "mapboxgl-ctrl-icon", this._geolocateButton).setAttribute("aria-hidden", "true"), this._geolocateButton.type = "button", false === t22) {
              e2.w("Geolocation support is not available so the GeolocateControl will be disabled.");
              const t3 = this._map._getUIString("GeolocateControl.LocationNotAvailable");
              this._geolocateButton.disabled = true, this._geolocateButton.setAttribute("aria-label", t3), this._geolocateButton.firstElementChild && this._geolocateButton.firstElementChild.setAttribute("title", t3);
            } else {
              const e22 = this._map._getUIString("GeolocateControl.FindMyLocation");
              this._geolocateButton.setAttribute("aria-label", e22), this._geolocateButton.firstElementChild && this._geolocateButton.firstElementChild.setAttribute("title", e22);
            }
            this.options.trackUserLocation && (this._geolocateButton.setAttribute("aria-pressed", "false"), this._watchState = "OFF"), this.options.showUserLocation && (this._dotElement = l2("div", "mapboxgl-user-location"), this._dotElement.appendChild(l2("div", "mapboxgl-user-location-dot")), this._dotElement.appendChild(l2("div", "mapboxgl-user-location-heading")), this._userLocationDotMarker = new vl({ element: this._dotElement, rotationAlignment: "map", pitchAlignment: "map" }), this._circleElement = l2("div", "mapboxgl-user-location-accuracy-circle"), this._accuracyCircleMarker = new vl({ element: this._circleElement, pitchAlignment: "map" }), this.options.trackUserLocation && (this._watchState = "OFF"), this._map.on("zoom", this._onZoom)), this._geolocateButton.addEventListener("click", this.trigger.bind(this)), this._setup = true, this.options.trackUserLocation && this._map.on("movestart", (t3) => {
              t3.geolocateSource || "ACTIVE_LOCK" !== this._watchState || t3.originalEvent && "resize" === t3.originalEvent.type || (this._watchState = "BACKGROUND", this._geolocateButton.classList.add("mapboxgl-ctrl-geolocate-background"), this._geolocateButton.classList.remove("mapboxgl-ctrl-geolocate-active"), this.fire(new e2.A("trackuserlocationend")));
            });
          }
        }
        _onDeviceOrientation(e22) {
          this._userLocationDotMarker && (e22.webkitCompassHeading ? this._heading = e22.webkitCompassHeading : true === e22.absolute && (this._heading = -1 * e22.alpha), this._updateMarkerRotationThrottled());
        }
        trigger() {
          if (!this._setup) return e2.w("Geolocate control triggered before added to a map"), false;
          if (this.options.trackUserLocation) {
            switch (this._watchState) {
              case "OFF":
                this._watchState = "WAITING_ACTIVE", this.fire(new e2.A("trackuserlocationstart"));
                break;
              case "WAITING_ACTIVE":
              case "ACTIVE_LOCK":
              case "ACTIVE_ERROR":
              case "BACKGROUND_ERROR":
                this._numberOfWatches--, this._noTimeout = false, this._watchState = "OFF", this._geolocateButton.classList.remove("mapboxgl-ctrl-geolocate-waiting"), this._geolocateButton.classList.remove("mapboxgl-ctrl-geolocate-active"), this._geolocateButton.classList.remove("mapboxgl-ctrl-geolocate-active-error"), this._geolocateButton.classList.remove("mapboxgl-ctrl-geolocate-background"), this._geolocateButton.classList.remove("mapboxgl-ctrl-geolocate-background-error"), this.fire(new e2.A("trackuserlocationend"));
                break;
              case "BACKGROUND":
                this._watchState = "ACTIVE_LOCK", this._geolocateButton.classList.remove("mapboxgl-ctrl-geolocate-background"), this._lastKnownPosition && this._updateCamera(this._lastKnownPosition), this.fire(new e2.A("trackuserlocationstart"));
            }
            switch (this._watchState) {
              case "WAITING_ACTIVE":
                this._geolocateButton.classList.add("mapboxgl-ctrl-geolocate-waiting"), this._geolocateButton.classList.add("mapboxgl-ctrl-geolocate-active");
                break;
              case "ACTIVE_LOCK":
                this._geolocateButton.classList.add("mapboxgl-ctrl-geolocate-active");
                break;
              case "ACTIVE_ERROR":
                this._geolocateButton.classList.add("mapboxgl-ctrl-geolocate-waiting"), this._geolocateButton.classList.add("mapboxgl-ctrl-geolocate-active-error");
                break;
              case "BACKGROUND":
                this._geolocateButton.classList.add("mapboxgl-ctrl-geolocate-background");
                break;
              case "BACKGROUND_ERROR":
                this._geolocateButton.classList.add("mapboxgl-ctrl-geolocate-waiting"), this._geolocateButton.classList.add("mapboxgl-ctrl-geolocate-background-error");
            }
            if ("OFF" === this._watchState && void 0 !== this._geolocationWatchID) this._clearWatch();
            else if (void 0 === this._geolocationWatchID) {
              let e22;
              this._geolocateButton.classList.add("mapboxgl-ctrl-geolocate-waiting"), this._geolocateButton.setAttribute("aria-pressed", "true"), this._numberOfWatches++, this._numberOfWatches > 1 ? (e22 = { maximumAge: 6e5, timeout: 0 }, this._noTimeout = true) : (e22 = this.options.positionOptions, this._noTimeout = false), this._geolocationWatchID = this.options.geolocation.watchPosition(this._onSuccess, this._onError, e22), this.options.showUserHeading && this._addDeviceOrientationListener();
            }
          } else this.options.geolocation.getCurrentPosition(this._onSuccess, this._onError, this.options.positionOptions), this._timeoutId = window.setTimeout(this._finish, 1e4);
          return true;
        }
        _addDeviceOrientationListener() {
          const e22 = () => {
            "ondeviceorientationabsolute" in window ? window.addEventListener("deviceorientationabsolute", this._onDeviceOrientation) : window.addEventListener("deviceorientation", this._onDeviceOrientation);
          };
          "undefined" != typeof DeviceMotionEvent && "function" == typeof DeviceMotionEvent.requestPermission ? DeviceOrientationEvent.requestPermission().then((t22) => {
            "granted" === t22 && e22();
          }).catch(console.error) : e22();
        }
        _clearWatch() {
          this.options.geolocation.clearWatch(this._geolocationWatchID), window.removeEventListener("deviceorientation", this._onDeviceOrientation), window.removeEventListener("deviceorientationabsolute", this._onDeviceOrientation), this._geolocationWatchID = void 0, this._geolocateButton.classList.remove("mapboxgl-ctrl-geolocate-waiting"), this._geolocateButton.setAttribute("aria-pressed", "false"), this.options.showUserLocation && this._updateMarker(null);
        }
      }, AttributionControl: sl, ScaleControl: class {
        constructor(t22 = {}) {
          this.options = e2.l({}, xl, t22), this._isNumberFormatSupported = function() {
            try {
              return new Intl.NumberFormat("en", { style: "unit", unitDisplay: "short", unit: "meter" }), true;
            } catch (e22) {
              return false;
            }
          }(), e2.aV(["_update", "_setScale", "setUnit"], this);
        }
        getDefaultPosition() {
          return "bottom-left";
        }
        _update() {
          const e22 = this.options.maxWidth || 100, t22 = this._map, i22 = t22._containerHeight / 2, o2 = t22._containerWidth / 2 - e22 / 2, s2 = t22.unproject([o2, i22]), r22 = t22.unproject([o2 + e22, i22]), n22 = s2.distanceTo(r22);
          if ("imperial" === this.options.unit) {
            const t3 = 3.2808 * n22;
            t3 > 5280 ? this._setScale(e22, t3 / 5280, "mile") : this._setScale(e22, t3, "foot");
          } else "nautical" === this.options.unit ? this._setScale(e22, n22 / 1852, "nautical-mile") : n22 >= 1e3 ? this._setScale(e22, n22 / 1e3, "kilometer") : this._setScale(e22, n22, "meter");
        }
        _setScale(e22, t22, i22) {
          this._map._requestDomTask(() => {
            const o2 = function(e3) {
              const t3 = Math.pow(10, `${Math.floor(e3)}`.length - 1);
              let i3 = e3 / t3;
              return i3 = i3 >= 10 ? 10 : i3 >= 5 ? 5 : i3 >= 3 ? 3 : i3 >= 2 ? 2 : i3 >= 1 ? 1 : function(e4) {
                const t4 = Math.pow(10, Math.ceil(-Math.log(e4) / Math.LN10));
                return Math.round(e4 * t4) / t4;
              }(i3), t3 * i3;
            }(t22), s2 = o2 / t22;
            this._container.innerHTML = this._isNumberFormatSupported && "nautical-mile" !== i22 ? new Intl.NumberFormat(this._language, { style: "unit", unitDisplay: "short", unit: i22 }).format(o2) : `${o2}&nbsp;${bl[i22]}`, this._container.style.width = e22 * s2 + "px";
          });
        }
        onAdd(e22) {
          return this._map = e22, this._language = e22.getLanguage(), this._container = l2("div", "mapboxgl-ctrl mapboxgl-ctrl-scale", e22.getContainer()), this._container.dir = "auto", this._map.on("move", this._update), this._update(), this._container;
        }
        onRemove() {
          this._container.remove(), this._map.off("move", this._update), this._map = void 0;
        }
        _setLanguage(e22) {
          this._language = e22, this._update();
        }
        setUnit(e22) {
          this.options.unit = e22, this._update();
        }
      }, FullscreenControl: class {
        constructor(t22 = {}) {
          this._fullscreen = false, t22 && t22.container && (t22.container instanceof HTMLElement ? this._container = t22.container : e2.w("Full screen control 'container' must be a DOM element.")), e2.aV(["_onClickFullscreen", "_changeIcon"], this), "onfullscreenchange" in document ? this._fullscreenchange = "fullscreenchange" : "onwebkitfullscreenchange" in document && (this._fullscreenchange = "webkitfullscreenchange");
        }
        onAdd(t22) {
          return this._map = t22, this._container || (this._container = this._map.getContainer()), this._controlContainer = l2("div", "mapboxgl-ctrl mapboxgl-ctrl-group"), this._checkFullscreenSupport() ? this._setupUI() : (this._controlContainer.style.display = "none", e2.w("This device does not support fullscreen mode.")), this._controlContainer;
        }
        onRemove() {
          this._controlContainer.remove(), this._map = null, document.removeEventListener(this._fullscreenchange, this._changeIcon);
        }
        _checkFullscreenSupport() {
          return !(!document.fullscreenEnabled && !document.webkitFullscreenEnabled);
        }
        _setupUI() {
          const e22 = this._fullscreenButton = l2("button", "mapboxgl-ctrl-fullscreen", this._controlContainer);
          l2("span", "mapboxgl-ctrl-icon", e22).setAttribute("aria-hidden", "true"), e22.type = "button", this._updateTitle(), this._fullscreenButton.addEventListener("click", this._onClickFullscreen), document.addEventListener(this._fullscreenchange, this._changeIcon);
        }
        _updateTitle() {
          const e22 = this._getTitle();
          this._fullscreenButton.setAttribute("aria-label", e22), this._fullscreenButton.firstElementChild && this._fullscreenButton.firstElementChild.setAttribute("title", e22);
        }
        _getTitle() {
          return this._map._getUIString(this._isFullscreen() ? "FullscreenControl.Exit" : "FullscreenControl.Enter");
        }
        _isFullscreen() {
          return this._fullscreen;
        }
        _changeIcon() {
          (document.fullscreenElement || document.webkitFullscreenElement) === this._container !== this._fullscreen && (this._fullscreen = !this._fullscreen, this._fullscreenButton.classList.toggle("mapboxgl-ctrl-shrink"), this._fullscreenButton.classList.toggle("mapboxgl-ctrl-fullscreen"), this._updateTitle());
        }
        _onClickFullscreen() {
          this._isFullscreen() ? document.exitFullscreen ? document.exitFullscreen() : document.webkitCancelFullScreen && document.webkitCancelFullScreen() : this._container.requestFullscreen ? this._container.requestFullscreen() : this._container.webkitRequestFullscreen && this._container.webkitRequestFullscreen();
        }
      }, Popup: class extends e2.E {
        constructor(t22) {
          super(), this.options = e2.l(Object.create(wl), t22), this._altitude = this.options.altitude, e2.aV(["_update", "_onClose", "remove", "_onMouseEvent"], this), this._classList = new Set(t22 && t22.className ? t22.className.trim().split(/\s+/) : []);
        }
        addTo(t22) {
          return this._map && this.remove(), this._map = t22, this.options.closeOnClick && t22.on("preclick", this._onClose), this.options.closeOnMove && t22.on("move", this._onClose), t22.on("remove", this.remove), this._update(), t22._addPopup(this), this._focusFirstElement(), this._trackPointer ? (t22.on("mousemove", this._onMouseEvent), t22.on("mouseup", this._onMouseEvent), t22._canvasContainer.classList.add("mapboxgl-track-pointer")) : t22.on("move", this._update), this.fire(new e2.A("open")), this;
        }
        isOpen() {
          return !!this._map;
        }
        remove() {
          this._content && this._content.remove(), this._container && (this._container.remove(), this._container = void 0);
          const t22 = this._map;
          return t22 && (t22.off("move", this._update), t22.off("move", this._onClose), t22.off("preclick", this._onClose), t22.off("click", this._onClose), t22.off("remove", this.remove), t22.off("mousemove", this._onMouseEvent), t22.off("mouseup", this._onMouseEvent), t22.off("drag", this._onMouseEvent), t22._canvasContainer && t22._canvasContainer.classList.remove("mapboxgl-track-pointer"), t22._removePopup(this), this._map = void 0), this.fire(new e2.A("close")), this;
        }
        getLngLat() {
          return this._lngLat;
        }
        setLngLat(t22) {
          this._lngLat = e2.cd.convert(t22), this._pos = null, this._trackPointer = false, this._update();
          const i22 = this._map;
          return i22 && (i22.on("move", this._update), i22.off("mousemove", this._onMouseEvent), i22._canvasContainer.classList.remove("mapboxgl-track-pointer")), this;
        }
        getAltitude() {
          return this._altitude;
        }
        setAltitude(e22) {
          return this._altitude = e22, this._update(), this;
        }
        trackPointer() {
          this._trackPointer = true, this._pos = null, this._update();
          const e22 = this._map;
          return e22 && (e22.off("move", this._update), e22.on("mousemove", this._onMouseEvent), e22.on("drag", this._onMouseEvent), e22._canvasContainer.classList.add("mapboxgl-track-pointer")), this;
        }
        getElement() {
          return this._container;
        }
        setText(e22) {
          return this.setDOMContent(document.createTextNode(e22));
        }
        setHTML(e22) {
          const t22 = document.createDocumentFragment(), i22 = document.createElement("body");
          let o2;
          for (i22.innerHTML = e22; o2 = i22.firstChild, o2; ) t22.appendChild(o2);
          return this.setDOMContent(t22);
        }
        getMaxWidth() {
          return this._container && this._container.style.maxWidth;
        }
        setMaxWidth(e22) {
          return this.options.maxWidth = e22, this._update(), this;
        }
        setDOMContent(e22) {
          let t22 = this._content;
          if (t22) for (; t22.hasChildNodes(); ) t22.firstChild && t22.removeChild(t22.firstChild);
          else t22 = this._content = l2("div", "mapboxgl-popup-content", this._container || void 0);
          if (t22.appendChild(e22), this.options.closeButton) {
            const e3 = this._closeButton = l2("button", "mapboxgl-popup-close-button", t22);
            e3.type = "button", e3.setAttribute("aria-label", "Close popup"), e3.innerHTML = '<span aria-hidden="true">&#215;</span>', e3.addEventListener("click", this._onClose);
          }
          return this._update(), this._focusFirstElement(), this;
        }
        addClassName(e22) {
          return this._classList.add(e22), this._updateClassList(), this;
        }
        removeClassName(e22) {
          return this._classList.delete(e22), this._updateClassList(), this;
        }
        setOffset(e22) {
          return this.options.offset = e22, this._update(), this;
        }
        toggleClassName(e22) {
          let t22;
          return this._classList.delete(e22) ? t22 = false : (this._classList.add(e22), t22 = true), this._updateClassList(), t22;
        }
        _onMouseEvent(e22) {
          this._update(e22.point);
        }
        _getAnchor(e22) {
          if (this.options.anchor) return this.options.anchor;
          const t22 = this._map, i22 = this._container, o2 = this._pos;
          if (!t22 || !i22 || !o2) return "bottom";
          const s2 = i22.offsetWidth, r22 = i22.offsetHeight, n22 = o2.x < s2 / 2, a22 = o2.x > t22.transform.width - s2 / 2;
          if (o2.y + e22 < r22) return n22 ? "top-left" : a22 ? "top-right" : "top";
          if (o2.y > t22.transform.height - r22) {
            if (n22) return "bottom-left";
            if (a22) return "bottom-right";
          }
          return n22 ? "left" : a22 ? "right" : "bottom";
        }
        _updateClassList() {
          const e22 = this._container;
          if (!e22) return;
          const t22 = [...this._classList];
          t22.push("mapboxgl-popup"), this._anchor && t22.push(`mapboxgl-popup-anchor-${this._anchor}`), this._trackPointer && t22.push("mapboxgl-popup-track-pointer"), e22.className = t22.join(" ");
        }
        _update(t22) {
          const i22 = this._map, o2 = this._content;
          if (!i22 || !this._lngLat && !this._trackPointer || !o2) return;
          let s2 = this._container;
          if (s2 || (s2 = this._container = l2("div", "mapboxgl-popup", i22.getContainer()), this._tip = l2("div", "mapboxgl-popup-tip", s2), s2.appendChild(o2)), this.options.maxWidth && s2.style.maxWidth !== this.options.maxWidth && (s2.style.maxWidth = this.options.maxWidth), i22.transform.renderWorldCopies && !this._trackPointer && (this._lngLat = fl(this._lngLat, this._pos, i22.transform)), !this._trackPointer || t22) {
            const o3 = this._pos = this._trackPointer && t22 instanceof e2.P ? t22 : i22.project(this._lngLat, this._altitude), s3 = El(this.options.offset), r22 = this._anchor = this._getAnchor(s3.y), n22 = El(this.options.offset, r22), a22 = o3.add(n22).round();
            i22._requestDomTask(() => {
              this._container && r22 && (this._container.style.transform = `${ml[r22]} translate(${a22.x}px,${a22.y}px)`);
            });
          }
          if (!this._marker && i22._showingGlobe()) {
            const t3 = e2.eK(i22.transform, this._lngLat) ? 0 : 1;
            this._setOpacity(t3);
          }
          this._updateClassList();
        }
        _focusFirstElement() {
          if (!this.options.focusAfterOpen || !this._container) return;
          const e22 = this._container.querySelector(Tl);
          e22 && e22.focus();
        }
        _onClose() {
          this.remove();
        }
        _setOpacity(e22) {
          this._container && (this._container.style.opacity = `${e22}`), this._content && (this._content.style.pointerEvents = e22 ? "auto" : "none");
        }
      }, Marker: vl, Style: Eo, LngLat: e2.cd, LngLatBounds: e2.aG, Point: e2.P, MercatorCoordinate: e2.ac, FreeCameraOptions: $i, Evented: e2.E, config: e2.e, prewarm: e2.eP, clearPrewarmedResources: e2.eQ, get accessToken() {
        return e2.e.ACCESS_TOKEN;
      }, set accessToken(t22) {
        e2.e.ACCESS_TOKEN = t22;
      }, get baseApiUrl() {
        return e2.e.API_URL;
      }, set baseApiUrl(t22) {
        e2.e.API_URL = t22;
      }, get workerCount() {
        return e2.eR.workerCount;
      }, set workerCount(t22) {
        e2.eR.workerCount = t22;
      }, get maxParallelImageRequests() {
        return e2.e.MAX_PARALLEL_IMAGE_REQUESTS;
      }, set maxParallelImageRequests(t22) {
        e2.e.MAX_PARALLEL_IMAGE_REQUESTS = t22;
      }, clearStorage(t22) {
        e2.eS(t22);
      }, get workerUrl() {
        return e2.eT.workerUrl;
      }, set workerUrl(t22) {
        e2.eT.workerUrl = t22;
      }, get workerClass() {
        return e2.eT.workerClass;
      }, set workerClass(t22) {
        e2.eT.workerClass = t22;
      }, get workerParams() {
        return e2.eT.workerParams;
      }, set workerParams(t22) {
        e2.eT.workerParams = t22;
      }, get dracoUrl() {
        return e2.eU();
      }, set dracoUrl(t22) {
        e2.eV(t22);
      }, get meshoptUrl() {
        return e2.eW();
      }, set meshoptUrl(t22) {
        e2.eX(t22);
      }, setNow: e2.q.setNow, restoreNow: e2.q.restoreNow };
      return Sl;
    });
    var mapboxgl$1 = mapboxgl2;
    return mapboxgl$1;
  });
})(mapboxGl);
var mapboxGlExports = mapboxGl.exports;
const mapboxgl = /* @__PURE__ */ getDefaultExportFromCjs(mapboxGlExports);
const useUserRole = () => {
  const { user } = useAuth();
  const [userRole, setUserRole] = reactExports.useState("user");
  const [loading, setLoading] = reactExports.useState(true);
  reactExports.useEffect(() => {
    if (!user) {
      setUserRole("user");
      setLoading(false);
      return;
    }
    const fetchUserRole = async () => {
      try {
        const { data, error } = await supabase.rpc("get_user_role", { _user_id: user.id });
        if (error) {
          console.error("Error fetching user role:", error);
          setUserRole("user");
        } else {
          setUserRole(data || "user");
        }
      } catch (error) {
        console.error("Error fetching user role:", error);
        setUserRole("user");
      } finally {
        setLoading(false);
      }
    };
    fetchUserRole();
  }, [user]);
  const isAdmin = () => userRole === "admin" || userRole === "master_admin";
  const isMasterAdmin = () => userRole === "master_admin";
  const isUser = () => userRole === "user";
  const canDeleteIncident = (incidentUserId) => {
    if (!user) return false;
    if (isAdmin()) return true;
    return user.id === incidentUserId;
  };
  const canDeleteMessage = (messageUserId) => {
    if (!user) return false;
    if (isAdmin()) return true;
    return user.id === messageUserId;
  };
  const canDeleteThread = (threadCreatorId) => {
    if (!user) return false;
    if (isAdmin()) return true;
    return user.id === threadCreatorId;
  };
  const canDeleteWantedPerson = (wantedPersonUserId) => {
    if (!user) return false;
    if (isAdmin()) return true;
    return user.id === wantedPersonUserId;
  };
  const canDeleteCommunityReport = (reportUserId) => {
    if (!user) return false;
    if (isAdmin()) return true;
    return user.id === reportUserId;
  };
  const canManageUserRole = (targetUserRole) => {
    if (!user) return false;
    if (isMasterAdmin()) return true;
    if (isAdmin() && targetUserRole === "user") return true;
    if (isAdmin() && targetUserRole === "master_admin") return false;
    return false;
  };
  const canDeleteUser = (targetUserRole) => {
    if (!user) return false;
    if (isMasterAdmin()) return true;
    if (isAdmin() && targetUserRole === "user") return true;
    return false;
  };
  return {
    userRole,
    loading,
    isAdmin,
    isMasterAdmin,
    isUser,
    canDeleteIncident,
    canDeleteMessage,
    canDeleteThread,
    canDeleteWantedPerson,
    canDeleteCommunityReport,
    canManageUserRole,
    canDeleteUser
  };
};
const useIncidentsRealtime = () => {
  const [incidents2, setIncidents] = reactExports.useState([]);
  const [loading, setLoading] = reactExports.useState(true);
  const { user } = useAuth();
  const channelRef = reactExports.useRef(null);
  const loadIncidents = reactExports.useCallback(async () => {
    console.log("--- useIncidentsRealtime: loadIncidents START ---");
    try {
      const { data, error } = await supabase.from("incidents").select(`
          *,
          user:profiles(full_name, avatar_url, email)
        `).order("created_at", { ascending: false });
      if (error) {
        console.error("--- useIncidentsRealtime: ERROR ---", error);
        return;
      }
      console.log("--- useIncidentsRealtime: DATA FROM SUPABASE ---", data);
      if (!data || data.length === 0) {
        setIncidents([]);
        return;
      }
      const incidentIds = data.map((incident) => incident.id);
      const { data: commentsData } = await supabase.from("incident_comments").select("incident_id").in("incident_id", incidentIds);
      const { data: confirmationsData } = await supabase.from("incident_confirmations").select("incident_id").in("incident_id", incidentIds);
      const { data: rejectionsData } = await supabase.from("incident_rejections").select("incident_id").in("incident_id", incidentIds);
      let userReactions = {};
      if (user) {
        const { data: userConfirmations } = await supabase.from("incident_confirmations").select("incident_id").eq("user_id", user.id).in("incident_id", incidentIds);
        const { data: userRejections } = await supabase.from("incident_rejections").select("incident_id").eq("user_id", user.id).in("incident_id", incidentIds);
        (userConfirmations || []).forEach((conf) => {
          userReactions[conf.incident_id] = "confirm";
        });
        (userRejections || []).forEach((rej) => {
          userReactions[rej.incident_id] = "reject";
        });
      }
      const commentCounts = (commentsData || []).reduce((acc, comment2) => {
        acc[comment2.incident_id] = (acc[comment2.incident_id] || 0) + 1;
        return acc;
      }, {});
      const confirmCounts = (confirmationsData || []).reduce((acc, conf) => {
        acc[conf.incident_id] = (acc[conf.incident_id] || 0) + 1;
        return acc;
      }, {});
      const rejectCounts = (rejectionsData || []).reduce((acc, rej) => {
        acc[rej.incident_id] = (acc[rej.incident_id] || 0) + 1;
        return acc;
      }, {});
      const processedIncidents = data.map((incident) => ({
        ...incident,
        comments_count: commentCounts[incident.id] || 0,
        confirm_count: confirmCounts[incident.id] || 0,
        reject_count: rejectCounts[incident.id] || 0,
        user_reaction: userReactions[incident.id] || null
      }));
      setIncidents(processedIncidents);
      console.log("--- useIncidentsRealtime: PROCESSED ---", processedIncidents.length);
      console.log("📊 Sample incident with counts:", processedIncidents[0]);
    } catch (error) {
      console.error("--- useIncidentsRealtime: CATCH ERROR ---", error);
    } finally {
      setLoading(false);
      console.log("--- useIncidentsRealtime: loadIncidents FINISH ---");
    }
  }, [user]);
  const createIncident = reactExports.useCallback(async (incidentData) => {
    if (!user) {
      Jt.error("Необходима авторизация");
      return { success: false };
    }
    try {
      const { data, error } = await supabase.from("incidents").insert([{
        ...incidentData,
        user_id: user.id
      }]).select(`
          *,
          user:profiles(full_name, avatar_url, email, role)
        `).single();
      if (error) {
        console.error("Error creating incident:", error);
        Jt.error("Ошибка при создании инцидента");
        return { success: false };
      }
      const newIncident = {
        ...data,
        comments_count: 0,
        confirm_count: 0,
        reject_count: 0
      };
      setIncidents((prev2) => [newIncident, ...prev2]);
      Jt.success("Инцидент успешно создан");
      return { success: true, data: newIncident };
    } catch (error) {
      console.error("Error in createIncident:", error);
      Jt.error("Ошибка при создании инцидента");
      return { success: false };
    }
  }, [user]);
  const deleteIncident = reactExports.useCallback(async (incidentId) => {
    try {
      const { error } = await supabase.rpc("archive_and_delete_incident", {
        incident_id: incidentId
      });
      if (error) {
        console.error("Error archiving incident:", error);
        Jt.error("Ошибка при архивации инцидента");
        return { success: false };
      }
      setIncidents((prev2) => prev2.filter((incident) => incident.id !== incidentId));
      Jt.success("Инцидент успешно архивирован");
      return { success: true };
    } catch (error) {
      console.error("Error in deleteIncident:", error);
      Jt.error("Ошибка при архивации инцидента");
      return { success: false };
    }
  }, []);
  const updateIncident = reactExports.useCallback(async (incidentId, updates) => {
    try {
      const { data, error } = await supabase.from("incidents").update(updates).eq("id", incidentId).select(`
          *,
          user:profiles(full_name, avatar_url, email, role)
        `).single();
      if (error) {
        console.error("Error updating incident:", error);
        Jt.error("Ошибка при обновлении инцидента");
        return { success: false };
      }
      const updatedIncident = {
        ...data,
        comments_count: 0,
        confirm_count: 0,
        reject_count: 0
      };
      setIncidents((prev2) => prev2.map(
        (incident) => incident.id === incidentId ? { ...incident, ...updatedIncident } : incident
      ));
      Jt.success("Инцидент успешно обновлен");
      return { success: true, data: updatedIncident };
    } catch (error) {
      console.error("Error in updateIncident:", error);
      Jt.error("Ошибка при обновлении инцидента");
      return { success: false };
    }
  }, []);
  const updateIncidentReaction = reactExports.useCallback((incidentId, reactionType, countChange) => {
    console.log("🚀 Updating incident reaction locally:", { incidentId, reactionType, countChange });
    setIncidents((prev2) => prev2.map((incident) => {
      if (incident.id === incidentId) {
        return {
          ...incident,
          user_reaction: reactionType,
          confirm_count: (incident.confirm_count || 0) + (countChange.confirm || 0),
          reject_count: (incident.reject_count || 0) + (countChange.reject || 0)
        };
      }
      return incident;
    }));
  }, []);
  reactExports.useEffect(() => {
    if (user) {
      loadIncidents();
    } else {
      setLoading(false);
    }
  }, [user, loadIncidents]);
  reactExports.useEffect(() => {
    if (!channelRef.current) {
      const channel = realtimeService.getChannel("incidents-simple-realtime");
      if (!channel) {
        console.log("[useIncidentsRealtime] Channel not ready, skipping setup");
        return;
      }
      channelRef.current = channel.on(
        "postgres_changes",
        { event: "*", schema: "public", table: "incidents" },
        (payload) => {
          console.log("Realtime change received on incidents table:", payload);
          loadIncidents();
        }
      );
    }
    return () => {
      realtimeService.dropChannel("incidents-simple-realtime");
      channelRef.current = null;
    };
  }, [user, loadIncidents]);
  return {
    incidents: incidents2,
    loading,
    createIncident,
    deleteIncident,
    updateIncident,
    updateIncidentReaction,
    refetch: loadIncidents
  };
};
const useHistoricalIncidents = () => {
  const [historicalIncidents, setHistoricalIncidents] = reactExports.useState([]);
  const [loading, setLoading] = reactExports.useState(true);
  const [error, setError] = reactExports.useState(null);
  const fetchHistoricalIncidents = reactExports.useCallback(async () => {
    setLoading(true);
    setError(null);
    try {
      const { data, error: fetchError } = await supabase.from("historical_incidents").select("*");
      if (fetchError) {
        throw fetchError;
      }
      setHistoricalIncidents(data || []);
    } catch (e2) {
      console.error("Error fetching historical incidents:", e2);
      setError(e2);
    } finally {
      setLoading(false);
    }
  }, []);
  reactExports.useEffect(() => {
    fetchHistoricalIncidents();
  }, [fetchHistoricalIncidents]);
  return { historicalIncidents, loading, error, refetch: fetchHistoricalIncidents };
};
const _IncidentCleanupService = class _IncidentCleanupService {
  constructor() {
    __publicField(this, "cleanupInterval", null);
  }
  static getInstance() {
    if (!_IncidentCleanupService.instance) {
      _IncidentCleanupService.instance = new _IncidentCleanupService();
    }
    return _IncidentCleanupService.instance;
  }
  /**
   * Запускает автоматическую очистку истекших инцидентов
   * @param intervalMinutes - Интервал проверки в минутах (по умолчанию 30 минут)
   */
  startCleanup(intervalMinutes = 30) {
    if (this.cleanupInterval) {
      clearInterval(this.cleanupInterval);
    }
    this.cleanupExpiredIncidents();
    this.cleanupInterval = setInterval(() => {
      this.cleanupExpiredIncidents();
    }, intervalMinutes * 60 * 1e3);
    console.log(`🧹 Incident cleanup service started with ${intervalMinutes} minute intervals`);
  }
  /**
   * Останавливает автоматическую очистку
   */
  stopCleanup() {
    if (this.cleanupInterval) {
      clearInterval(this.cleanupInterval);
      this.cleanupInterval = null;
      console.log("🛑 Incident cleanup service stopped");
    }
  }
  /**
   * Очищает истекшие инциденты из базы данных (с улучшенным мониторингом)
   */
  async cleanupExpiredIncidents() {
    const startTime = Date.now();
    try {
      console.log(`🧹 [${(/* @__PURE__ */ new Date()).toISOString()}] Starting cleanup of expired incidents...`);
      const now2 = /* @__PURE__ */ new Date();
      const expiredIncidents = [];
      const processingStats = {};
      for (const [incidentType, durationHours] of Object.entries(INCIDENT_DURATION_LIMITS)) {
        const expirationTime = new Date(now2.getTime() - durationHours * 60 * 60 * 1e3);
        const dbIncidentType = incidentType === "suspicious" ? "suspicious_activity" : incidentType;
        const { data: incidents2, error } = await supabase.from("incidents").select("id, incident_type, created_at").eq("incident_type", dbIncidentType).lt("created_at", expirationTime.toISOString());
        if (error) {
          console.error(`❌ Error fetching expired ${incidentType} incidents:`, error);
          continue;
        }
        if (incidents2 && incidents2.length > 0) {
          expiredIncidents.push(...incidents2);
          processingStats[incidentType] = incidents2.length;
          console.log(`📋 Found ${incidents2.length} expired ${incidentType} incidents`);
        }
      }
      if (expiredIncidents.length === 0) {
        const processingTime2 = Date.now() - startTime;
        console.log(`✅ [${processingTime2}ms] No expired incidents found`);
        return 0;
      }
      console.log(`🗑️ Found ${expiredIncidents.length} total expired incidents to remove`);
      console.log("📊 Processing stats by type:", processingStats);
      let successfullyArchived = 0;
      for (const incident of expiredIncidents) {
        try {
          const { error } = await supabase.rpc("archive_and_delete_incident", {
            incident_id: incident.id
          });
          if (error) {
            console.error(`❌ Error archiving incident ${incident.id}:`, error);
          } else {
            successfullyArchived++;
          }
        } catch (error) {
          console.error(`❌ Error archiving incident ${incident.id}:`, error);
        }
      }
      const processingTime = Date.now() - startTime;
      console.log(`✅ [${processingTime}ms] Successfully archived ${successfullyArchived}/${expiredIncidents.length} expired incidents`);
      const typeStats = expiredIncidents.reduce((acc, incident) => {
        acc[incident.incident_type] = (acc[incident.incident_type] || 0) + 1;
        return acc;
      }, {});
      console.log("📊 Final cleanup statistics:", typeStats);
      console.log(`⚡ Cleanup completed in ${processingTime}ms`);
      return successfullyArchived;
    } catch (error) {
      const processingTime = Date.now() - startTime;
      console.error(`❌ [${processingTime}ms] Error in cleanup process:`, error);
      return 0;
    }
  }
  /**
   * Получает статистику по инцидентам и их времени жизни
   */
  async getIncidentStats() {
    try {
      const { data: incidents2, error } = await supabase.from("incidents").select("incident_type, created_at");
      if (error) {
        console.error("❌ Error fetching incident stats:", error);
        return { total: 0, byType: {} };
      }
      if (!incidents2) {
        return { total: 0, byType: {} };
      }
      const now2 = /* @__PURE__ */ new Date();
      const stats = {};
      for (const incident of incidents2) {
        const type = incident.incident_type;
        const createdAt = new Date(incident.created_at);
        const ageHours = (now2.getTime() - createdAt.getTime()) / (1e3 * 60 * 60);
        const durationLimit = INCIDENT_DURATION_LIMITS[type] || 24;
        const remainingHours = durationLimit - ageHours;
        if (!stats[type]) {
          stats[type] = { count: 0, avgAge: 0, expiringSoon: 0 };
        }
        stats[type].count++;
        stats[type].avgAge += ageHours;
        if (remainingHours > 0 && remainingHours < durationLimit * 0.25) {
          stats[type].expiringSoon++;
        }
      }
      for (const type in stats) {
        stats[type].avgAge = stats[type].avgAge / stats[type].count;
      }
      return {
        total: incidents2.length,
        byType: stats
      };
    } catch (error) {
      console.error("❌ Error calculating incident stats:", error);
      return { total: 0, byType: {} };
    }
  }
  /**
   * Принудительная очистка всех истекших инцидентов (для тестирования)
   */
  async forceCleanup() {
    console.log("🚀 Force cleanup triggered");
    return await this.cleanupExpiredIncidents();
  }
};
__publicField(_IncidentCleanupService, "instance");
let IncidentCleanupService = _IncidentCleanupService;
const UserRoleBadge = ({
  role,
  size: size2 = "sm",
  showIcon = true
}) => {
  const getRoleConfig = (role2) => {
    const iconSize = size2 === "xs" ? "w-2 h-2" : "w-3 h-3";
    switch (role2) {
      case "master_admin":
        return {
          label: "Master Admin",
          // Фиксированное английское название
          className: "bg-gradient-to-r from-yellow-500 to-orange-500 text-white border-yellow-400",
          icon: /* @__PURE__ */ jsxRuntimeExports.jsx(Crown, { className: iconSize })
        };
      case "admin":
        return {
          label: "Admin",
          // Фиксированное английское название
          className: "bg-gradient-to-r from-blue-600 to-purple-600 text-white border-blue-400",
          icon: /* @__PURE__ */ jsxRuntimeExports.jsx(Shield, { className: iconSize })
        };
      case "user":
      default:
        return {
          label: "User",
          // Фиксированное английское название
          className: "bg-gray-600 text-white border-gray-500",
          icon: /* @__PURE__ */ jsxRuntimeExports.jsx(User, { className: iconSize })
        };
    }
  };
  const config2 = getRoleConfig(role);
  const sizeClass = size2 === "lg" ? "text-sm px-3 py-1" : size2 === "md" ? "text-xs px-2 py-1" : size2 === "xs" ? "text-[8px] px-1 py-0.5" : "text-[10px] px-1 py-0.5 sm:text-xs sm:px-1.5";
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(
    Badge,
    {
      className: `${config2.className} ${sizeClass} flex items-center gap-1 font-medium whitespace-nowrap`,
      variant: "outline",
      children: [
        showIcon && config2.icon,
        config2.label
      ]
    }
  );
};
var AVATAR_NAME = "Avatar";
var [createAvatarContext, createAvatarScope] = createContextScope$3(AVATAR_NAME);
var [AvatarProvider, useAvatarContext] = createAvatarContext(AVATAR_NAME);
var Avatar$1 = reactExports.forwardRef(
  (props, forwardedRef) => {
    const { __scopeAvatar, ...avatarProps } = props;
    const [imageLoadingStatus, setImageLoadingStatus] = reactExports.useState("idle");
    return /* @__PURE__ */ jsxRuntimeExports.jsx(
      AvatarProvider,
      {
        scope: __scopeAvatar,
        imageLoadingStatus,
        onImageLoadingStatusChange: setImageLoadingStatus,
        children: /* @__PURE__ */ jsxRuntimeExports.jsx(Primitive.span, { ...avatarProps, ref: forwardedRef })
      }
    );
  }
);
Avatar$1.displayName = AVATAR_NAME;
var IMAGE_NAME = "AvatarImage";
var AvatarImage$1 = reactExports.forwardRef(
  (props, forwardedRef) => {
    const { __scopeAvatar, src, onLoadingStatusChange = () => {
    }, ...imageProps } = props;
    const context = useAvatarContext(IMAGE_NAME, __scopeAvatar);
    const imageLoadingStatus = useImageLoadingStatus(src, imageProps.referrerPolicy);
    const handleLoadingStatusChange = useCallbackRef$1((status) => {
      onLoadingStatusChange(status);
      context.onImageLoadingStatusChange(status);
    });
    useLayoutEffect2(() => {
      if (imageLoadingStatus !== "idle") {
        handleLoadingStatusChange(imageLoadingStatus);
      }
    }, [imageLoadingStatus, handleLoadingStatusChange]);
    return imageLoadingStatus === "loaded" ? /* @__PURE__ */ jsxRuntimeExports.jsx(Primitive.img, { ...imageProps, ref: forwardedRef, src }) : null;
  }
);
AvatarImage$1.displayName = IMAGE_NAME;
var FALLBACK_NAME = "AvatarFallback";
var AvatarFallback$1 = reactExports.forwardRef(
  (props, forwardedRef) => {
    const { __scopeAvatar, delayMs, ...fallbackProps } = props;
    const context = useAvatarContext(FALLBACK_NAME, __scopeAvatar);
    const [canRender, setCanRender] = reactExports.useState(delayMs === void 0);
    reactExports.useEffect(() => {
      if (delayMs !== void 0) {
        const timerId2 = window.setTimeout(() => setCanRender(true), delayMs);
        return () => window.clearTimeout(timerId2);
      }
    }, [delayMs]);
    return canRender && context.imageLoadingStatus !== "loaded" ? /* @__PURE__ */ jsxRuntimeExports.jsx(Primitive.span, { ...fallbackProps, ref: forwardedRef }) : null;
  }
);
AvatarFallback$1.displayName = FALLBACK_NAME;
function useImageLoadingStatus(src, referrerPolicy) {
  const [loadingStatus, setLoadingStatus] = reactExports.useState("idle");
  useLayoutEffect2(() => {
    if (!src) {
      setLoadingStatus("error");
      return;
    }
    let isMounted = true;
    const image = new window.Image();
    const updateStatus = (status) => () => {
      if (!isMounted) return;
      setLoadingStatus(status);
    };
    setLoadingStatus("loading");
    image.onload = updateStatus("loaded");
    image.onerror = updateStatus("error");
    image.src = src;
    if (referrerPolicy) {
      image.referrerPolicy = referrerPolicy;
    }
    return () => {
      isMounted = false;
    };
  }, [src, referrerPolicy]);
  return loadingStatus;
}
var Root$2 = Avatar$1;
var Image$1 = AvatarImage$1;
var Fallback = AvatarFallback$1;
const Avatar = reactExports.forwardRef(({ className, ...props }, ref) => /* @__PURE__ */ jsxRuntimeExports.jsx(
  Root$2,
  {
    ref,
    className: cn(
      "relative flex h-10 w-10 shrink-0 overflow-hidden rounded-full",
      className
    ),
    ...props
  }
));
Avatar.displayName = Root$2.displayName;
const AvatarImage = reactExports.forwardRef(({ className, ...props }, ref) => /* @__PURE__ */ jsxRuntimeExports.jsx(
  Image$1,
  {
    ref,
    className: cn("aspect-square h-full w-full", className),
    ...props
  }
));
AvatarImage.displayName = Image$1.displayName;
const AvatarFallback = reactExports.forwardRef(({ className, ...props }, ref) => /* @__PURE__ */ jsxRuntimeExports.jsx(
  Fallback,
  {
    ref,
    className: cn(
      "flex h-full w-full items-center justify-center rounded-full bg-muted",
      className
    ),
    ...props
  }
));
AvatarFallback.displayName = Fallback.displayName;
const _XPService = class _XPService {
  constructor() {
    // Конфигурация уровней (расширенная система без ограничений)
    __publicField(this, "levels", [
      { level: 1, name: "Observador", emoji: "🐣", minXP: 0, maxXP: 4 },
      { level: 2, name: "Reportero", emoji: "👁️", minXP: 5, maxXP: 9 },
      { level: 3, name: "Radar Ciudadano", emoji: "🧭", minXP: 10, maxXP: 19 },
      { level: 4, name: "Vigilante", emoji: "🛡️", minXP: 20, maxXP: 39 },
      { level: 5, name: "Patrullero", emoji: "👑", minXP: 40, maxXP: 69 },
      { level: 6, name: "Comandante", emoji: "🔥", minXP: 70, maxXP: 119 },
      { level: 7, name: "Ayudante", emoji: "🤝", minXP: 120, maxXP: 199 },
      { level: 8, name: "Participante", emoji: "🎯", minXP: 200, maxXP: 319 },
      { level: 9, name: "Constante", emoji: "🔄", minXP: 320, maxXP: 499 },
      { level: 10, name: "Activo", emoji: "⚡", minXP: 500, maxXP: 749 },
      { level: 11, name: "Conocedor", emoji: "🧠", minXP: 750, maxXP: 1099 },
      { level: 12, name: "Hábil", emoji: "🎨", minXP: 1100, maxXP: 1599 },
      { level: 13, name: "Avanzado", emoji: "🚀", minXP: 1600, maxXP: 2199 },
      { level: 14, name: "Experimentado", emoji: "💎", minXP: 2200, maxXP: 2999 },
      { level: 15, name: "Veterano", emoji: "🏆", minXP: 3e3, maxXP: 3999 },
      { level: 16, name: "Especialista", emoji: "⭐", minXP: 4e3, maxXP: 5199 },
      { level: 17, name: "Profesional", emoji: "🌟", minXP: 5200, maxXP: 6499 },
      { level: 18, name: "Experto", emoji: "💫", minXP: 6500, maxXP: 7999 },
      { level: 19, name: "Maestro", emoji: "🌠", minXP: 8e3, maxXP: 9999 },
      { level: 20, name: "Leyenda", emoji: "🌌", minXP: 1e4, maxXP: 999999 }
    ]);
    // Конфигурация XP за действия (реалистичные награды)
    __publicField(this, "xpRewards", {
      report_created: 2,
      // основная награда за отчет
      report_confirmed: 1,
      // за подтверждение
      report_with_photo: 1,
      // бонус за фото
      chat_message: 1,
      // за активность в чате
      first_responder: 3,
      // за быструю реакцию
      daily_login: 1,
      // за ежедневный вход
      profile_updated: 1,
      // за обновление профиля
      community_participation: 1
      // за участие в сообществе
    });
  }
  static getInstance() {
    if (!_XPService.instance) {
      _XPService.instance = new _XPService();
    }
    return _XPService.instance;
  }
  // Получить XP пользователя
  async getUserXP(userId) {
    try {
      const { data, error } = await supabase.from("user_stats").select("user_id, total_xp, level, created_at").eq("user_id", userId).single();
      if (error && error.code !== "PGRST116") {
        console.error("Error fetching user XP:", error);
        return null;
      }
      if (!data) {
        return await this.initializeUserXP(userId);
      }
      return {
        id: data.user_id,
        user_id: data.user_id,
        total_xp: data.total_xp || 0,
        current_level: data.level || 1,
        created_at: data.created_at || (/* @__PURE__ */ new Date()).toISOString(),
        updated_at: data.created_at || (/* @__PURE__ */ new Date()).toISOString()
      };
    } catch (error) {
      console.error("Error in getUserXP:", error);
      return null;
    }
  }
  // Инициализация XP для нового пользователя
  async initializeUserXP(userId) {
    try {
      const { data, error } = await supabase.from("user_stats").insert({
        user_id: userId,
        total_xp: 0,
        level: 1,
        total_reports: 0,
        total_messages: 0,
        total_threads: 0
      }).select("user_id, total_xp, level, created_at").single();
      if (error) {
        console.error("Error initializing user XP:", error);
        return null;
      }
      return {
        id: data.user_id,
        user_id: data.user_id,
        total_xp: data.total_xp || 0,
        current_level: data.level || 1,
        created_at: data.created_at || (/* @__PURE__ */ new Date()).toISOString(),
        updated_at: data.created_at || (/* @__PURE__ */ new Date()).toISOString()
      };
    } catch (error) {
      console.error("Error in initializeUserXP:", error);
      return null;
    }
  }
  // Добавить XP пользователю
  async addXP(userId, actionType, referenceId, customAmount) {
    try {
      const xpAmount = customAmount || this.xpRewards[actionType] || 0;
      if (xpAmount === 0) {
        console.warn(`No XP reward defined for action: ${actionType}`);
        return false;
      }
      const { error } = await supabase.rpc("add_user_xp", {
        p_user_id: userId,
        p_xp_change: xpAmount,
        p_action_type: actionType,
        p_reference_id: referenceId,
        p_description: `${actionType} (+${xpAmount} XP)`
      });
      if (error) {
        console.error("Error adding XP:", error);
        return false;
      }
      console.log(`Added ${xpAmount} XP to user ${userId} for ${actionType}`);
      return true;
    } catch (error) {
      console.error("Error in addXP:", error);
      return false;
    }
  }
  // Вычесть XP (для штрафов)
  async subtractXP(userId, amount, reason, referenceId) {
    try {
      const { error } = await supabase.rpc("add_user_xp", {
        p_user_id: userId,
        p_xp_change: -amount,
        p_action_type: "penalty",
        p_reference_id: referenceId,
        p_description: `${reason} (-${amount} XP)`
      });
      if (error) {
        console.error("Error subtracting XP:", error);
        return false;
      }
      console.log(`Subtracted ${amount} XP from user ${userId} for ${reason}`);
      return true;
    } catch (error) {
      console.error("Error in subtractXP:", error);
      return false;
    }
  }
  // Получить информацию об уровне
  getLevelInfo(level) {
    return this.levels.find((l2) => l2.level === level) || null;
  }
  // Получить информацию об уровне по XP
  getLevelByXP(xp) {
    for (let i2 = this.levels.length - 1; i2 >= 0; i2--) {
      if (xp >= this.levels[i2].minXP) {
        return this.levels[i2];
      }
    }
    return this.levels[0];
  }
  // Получить прогресс до следующего уровня
  getProgressToNextLevel(currentXP, currentLevel) {
    const correctLevel = this.getLevelByXP(currentXP);
    const actualLevel = correctLevel.level;
    const currentLevelInfo = this.getLevelInfo(actualLevel);
    const nextLevelInfo = this.getLevelInfo(actualLevel + 1);
    if (!currentLevelInfo || !nextLevelInfo) {
      return {
        currentLevelXP: currentXP,
        nextLevelXP: currentXP,
        progress: 100,
        isMaxLevel: true
      };
    }
    const currentLevelXP = currentXP - currentLevelInfo.minXP;
    const nextLevelXP = nextLevelInfo.minXP - currentLevelInfo.minXP;
    const progress2 = Math.min(100, Math.max(0, currentLevelXP / nextLevelXP * 100));
    return {
      currentLevelXP: Math.max(0, currentLevelXP),
      // не может быть отрицательным
      nextLevelXP,
      progress: progress2,
      isMaxLevel: actualLevel >= this.levels.length
    };
  }
  // Получить историю транзакций XP
  async getXPTransactions(userId, limit = 10) {
    try {
      const { data, error } = await supabase.from("xp_transactions").select("*").eq("user_id", userId).order("created_at", { ascending: false }).limit(limit);
      if (error) {
        console.error("Error fetching XP transactions:", error);
        return [];
      }
      return data || [];
    } catch (error) {
      console.error("Error in getXPTransactions:", error);
      return [];
    }
  }
  // Получить топ пользователей по XP
  async getTopUsers(limit = 10) {
    try {
      const { data, error } = await supabase.from("user_xp").select(`
          *,
          profiles:user_id (
            name,
            avatar_url
          )
        `).order("total_xp", { ascending: false }).limit(limit);
      if (error) {
        console.error("Error fetching top users:", error);
        return [];
      }
      return data || [];
    } catch (error) {
      console.error("Error in getTopUsers:", error);
      return [];
    }
  }
  // Получить статистику пользователя
  async getUserStats(userId) {
    const xp = await this.getUserXP(userId);
    const correctLevel = xp ? this.getLevelByXP(xp.total_xp) : null;
    const levelInfo = correctLevel ? this.getLevelInfo(correctLevel.level) : null;
    const progress2 = xp ? this.getProgressToNextLevel(xp.total_xp, xp.current_level) : {
      currentLevelXP: 0,
      nextLevelXP: 0,
      progress: 0,
      isMaxLevel: false
    };
    const recentTransactions = await this.getXPTransactions(userId, 5);
    return {
      xp,
      levelInfo,
      progress: progress2,
      recentTransactions
    };
  }
  // Получить все уровни
  getAllLevels() {
    return [...this.levels];
  }
  // Получить конфигурацию наград
  getXPRewards() {
    return { ...this.xpRewards };
  }
  // Принудительно пересчитать уровень пользователя
  async recalculateUserLevel(userId) {
    try {
      const userXP = await this.getUserXP(userId);
      if (!userXP) {
        console.error("User XP not found for recalculation");
        return false;
      }
      const correctLevel = this.getLevelByXP(userXP.total_xp);
      const { error } = await supabase.from("user_stats").update({ level: correctLevel.level }).eq("user_id", userId);
      if (error) {
        console.error("Error updating user level:", error);
        return false;
      }
      await supabase.from("user_xp").update({ current_level: correctLevel.level }).eq("user_id", userId);
      console.log(`Updated user ${userId} level to ${correctLevel.level} (${correctLevel.name})`);
      return true;
    } catch (error) {
      console.error("Error in recalculateUserLevel:", error);
      return false;
    }
  }
};
__publicField(_XPService, "instance");
let XPService = _XPService;
console.log("🌟 useUserStats module loaded");
const useUserStats = (userId) => {
  console.log("🎯 useUserStats called with userId:", userId);
  const [stats, setStats] = reactExports.useState({
    level: 1,
    total_xp: 0,
    total_reports: 0,
    total_messages: 0
  });
  const [loading, setLoading] = reactExports.useState(true);
  const [error, setError] = reactExports.useState(null);
  reactExports.useEffect(() => {
    console.log("🚀 useUserStats effect triggered for userId:", userId);
    if (!userId) {
      console.log("❌ No userId provided");
      setLoading(false);
      return;
    }
    const fetchUserStats = async () => {
      try {
        console.log("🔍 Starting fetchUserStats for user:", userId);
        setLoading(true);
        setError(null);
        console.log("🎯 Using XPService to get user XP...");
        const xpService = XPService.getInstance();
        let xpData = await xpService.getUserXP(userId);
        console.log("📊 XPService result:", xpData);
        let userLevel = 1;
        let userXP = 0;
        if (xpData) {
          userLevel = xpData.current_level || 1;
          userXP = xpData.total_xp || 0;
          console.log("✅ Found XP data via XPService:", { userLevel, userXP });
        } else {
          console.log("❌ No XP data found via XPService");
        }
        console.log("📈 Counting reports...");
        const { count: reportsCount, error: reportsError } = await supabase.from("incidents").select("*", { count: "exact", head: true }).eq("user_id", userId);
        console.log("📈 Reports result:", { reportsCount, reportsError });
        console.log("💬 Counting messages...");
        const { count: messagesCount, error: messagesError } = await supabase.from("community_messages").select("*", { count: "exact", head: true }).eq("user_id", userId);
        console.log("💬 Messages result:", { messagesCount, messagesError });
        const finalStats = {
          level: userLevel,
          total_xp: userXP,
          total_reports: reportsCount || 0,
          total_messages: messagesCount || 0
        };
        console.log("🎯 Setting final stats:", finalStats);
        setStats(finalStats);
      } catch (err) {
        console.error("💥 Error in fetchUserStats:", err);
        setError(err instanceof Error ? err.message : "Unknown error");
      } finally {
        console.log("✅ fetchUserStats completed");
        setLoading(false);
      }
    };
    fetchUserStats();
  }, [userId]);
  console.log("🔄 useUserStats returning:", { ...stats, loading, error });
  return { ...stats, loading, error };
};
const UserProfileCard = ({
  userId,
  isOpen,
  onClose
}) => {
  const { t: t2, language } = useLanguage$1();
  const [userProfile, setUserProfile] = reactExports.useState(null);
  const [loading, setLoading] = reactExports.useState(false);
  console.log("🔍 UserProfileCard: userId =", userId, "isOpen =", isOpen);
  const { level, total_xp, total_reports, total_messages, loading: statsLoading, error: statsError } = useUserStats(userId);
  console.log("📊 UserProfileCard: stats =", { level, total_xp, total_reports, total_messages, statsLoading, statsError });
  reactExports.useEffect(() => {
    if (isOpen && userId) {
      fetchUserProfile();
      testUserXP(userId);
    }
  }, [isOpen, userId]);
  const testUserXP = async (userId2) => {
    console.log("🧪 Testing user_xp access for userId:", userId2);
    try {
      const { data, error } = await supabase.from("user_xp").select("*").eq("user_id", userId2).maybeSingle();
      console.log("🧪 Direct test result:", { data, error });
    } catch (err) {
      console.error("🧪 Direct test error:", err);
    }
  };
  const fetchUserProfile = async () => {
    setLoading(true);
    try {
      const { data: profileData, error: profileError } = await supabase.from("profiles").select("id, full_name, avatar_url, bio").eq("id", userId).single();
      if (profileError) {
        console.error("Error fetching profile:", profileError);
        return;
      }
      const { data: roleData, error: roleError } = await supabase.rpc("get_user_role", { _user_id: userId });
      const role = roleData || "user";
      const { data: badgesData, error: badgesError } = await supabase.from("user_badges").select(`
          id,
          badges (
            id,
            name_en,
            name_es,
            emoji,
            category
          )
        `).eq("user_id", userId);
      const badges = badgesData?.map((ub) => ub.badges).filter(Boolean) || [];
      setUserProfile({
        id: profileData.id,
        full_name: profileData.full_name,
        avatar_url: profileData.avatar_url,
        bio: profileData.bio,
        role,
        badges
      });
    } catch (error) {
      console.error("Error fetching user profile:", error);
    } finally {
      setLoading(false);
    }
  };
  if (!userProfile && !loading) {
    return null;
  }
  const isAdmin = userProfile?.role === "admin" || userProfile?.role === "master_admin";
  const isSpecialUser = userProfile?.id === "bb@bbbbb.cc";
  const shouldHideName = isAdmin || isSpecialUser;
  const displayName = shouldHideName ? "" : userProfile?.full_name || (language === "es" ? "Usuario" : "User");
  const initials = shouldHideName ? "" : displayName.split(" ").map((n2) => n2[0]).join("").toUpperCase();
  return /* @__PURE__ */ jsxRuntimeExports.jsx(Dialog, { open: isOpen, onOpenChange: onClose, children: /* @__PURE__ */ jsxRuntimeExports.jsx(DialogContent, { className: "sm:max-w-[360px] bg-card/95 backdrop-blur-xl border border-white/10 rounded-3xl shadow-2xl", children: /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "flex flex-col items-center space-y-4 p-6", children: loading ? /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "animate-pulse space-y-4 w-full", children: [
    /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "w-20 h-20 bg-gray-600 rounded-full mx-auto" }),
    /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "h-4 bg-gray-600 rounded w-3/4 mx-auto" }),
    /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "h-3 bg-gray-600 rounded w-1/2 mx-auto" })
  ] }) : userProfile ? /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
    /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "relative", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsxs(Avatar, { className: "w-20 h-20 border-4 border-white/20 shadow-lg", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx(
          AvatarImage,
          {
            src: userProfile.avatar_url || void 0,
            alt: shouldHideName ? userProfile.role : displayName
          }
        ),
        /* @__PURE__ */ jsxRuntimeExports.jsx(AvatarFallback, { className: "bg-gradient-to-br from-gray-600 to-gray-800 text-white text-xl font-bold", children: initials || (shouldHideName ? userProfile.role.charAt(0).toUpperCase() : "?") })
      ] }),
      /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "absolute -bottom-2 -right-2 bg-gradient-to-r from-blue-500 to-purple-600 text-white text-xs font-bold px-2 py-1 rounded-full border-2 border-white/20", children: [
        language === "es" ? "Niv." : "Lvl.",
        " ",
        statsLoading ? "..." : level
      ] })
    ] }),
    /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "text-center space-y-2 w-full", children: [
      !shouldHideName && /* @__PURE__ */ jsxRuntimeExports.jsx("h3", { className: "text-lg font-semibold text-white", children: displayName }),
      /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "flex justify-center", children: /* @__PURE__ */ jsxRuntimeExports.jsx(UserRoleBadge, { role: userProfile.role, size: "sm", showIcon: true }) })
    ] }),
    userProfile.bio && /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "w-full", children: /* @__PURE__ */ jsxRuntimeExports.jsxs("p", { className: "text-sm text-gray-300 text-center italic bg-white/5 rounded-lg p-3 border border-white/10", children: [
      '"',
      userProfile.bio,
      '"'
    ] }) }),
    /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "grid grid-cols-3 gap-4 w-full", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "text-center bg-white/5 rounded-lg p-3 border border-white/10", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "text-lg font-bold text-white", children: statsLoading ? "..." : total_reports }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "text-xs text-gray-400", children: t2("reports") })
      ] }),
      /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "text-center bg-white/5 rounded-lg p-3 border border-white/10", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "text-lg font-bold text-white", children: statsLoading ? "..." : total_messages }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "text-xs text-gray-400", children: t2("messages") })
      ] }),
      /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "text-center bg-white/5 rounded-lg p-3 border border-white/10", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "text-lg font-bold text-white", children: statsLoading ? "..." : total_xp }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "text-xs text-gray-400", children: "XP" })
      ] })
    ] }),
    statsError && /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "w-full text-center text-red-400 text-sm bg-red-900/20 rounded-lg p-2 border border-red-500/20", children: language === "es" ? "Error al cargar estadísticas" : "Error loading stats" }),
    userProfile.badges.length > 0 && /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "flex flex-wrap justify-center gap-2", children: userProfile.badges.map((badge) => /* @__PURE__ */ jsxRuntimeExports.jsxs(
      Badge,
      {
        className: "flex items-center justify-center space-x-1 px-3 py-1 bg-white/10 hover:bg-white/20 text-center",
        children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("span", { children: badge.emoji }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("span", { children: language === "es" ? badge.name_es : badge.name_en })
        ]
      },
      badge.id
    )) })
  ] }) : null }) }) });
};
const UserDisplayWrapper = ({
  userId,
  size: size2 = "sm",
  showIcon = true,
  className
}) => {
  const [userProfile, setUserProfile] = reactExports.useState(null);
  const [loading, setLoading] = reactExports.useState(true);
  const [isProfileCardOpen, setIsProfileCardOpen] = reactExports.useState(false);
  reactExports.useEffect(() => {
    const fetchUserProfile = async () => {
      try {
        const { data: roleData, error: roleError } = await supabase.rpc("get_user_role", { _user_id: userId });
        if (roleError) {
          console.error("Error fetching user role:", roleError);
          setUserProfile({ full_name: null, role: "user" });
          setLoading(false);
          return;
        }
        const role = roleData || "user";
        if (role === "admin" || role === "master_admin") {
          setUserProfile({ full_name: null, role });
          setLoading(false);
          return;
        }
        const { data: profileData, error: profileError } = await supabase.from("profiles").select("full_name").eq("id", userId).single();
        if (profileError) {
          console.error("Error fetching user profile:", profileError);
          setUserProfile({ full_name: null, role });
        } else {
          setUserProfile({
            full_name: profileData.full_name,
            role
          });
        }
      } catch (error) {
        console.error("Error fetching user data:", error);
        setUserProfile({ full_name: null, role: "user" });
      } finally {
        setLoading(false);
      }
    };
    if (userId) {
      fetchUserProfile();
    } else {
      setLoading(false);
    }
  }, [userId]);
  const handleClick = (e2) => {
    e2.stopPropagation();
    setIsProfileCardOpen(true);
  };
  if (loading) {
    return null;
  }
  if (!userProfile) {
    return null;
  }
  if (userProfile.role === "admin" || userProfile.role === "master_admin") {
    return /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className, onClick: handleClick, children: /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "cursor-pointer", children: /* @__PURE__ */ jsxRuntimeExports.jsx(UserRoleBadge, { role: userProfile.role, size: size2, showIcon }) }) }),
      /* @__PURE__ */ jsxRuntimeExports.jsx(
        UserProfileCard,
        {
          userId,
          isOpen: isProfileCardOpen,
          onClose: () => setIsProfileCardOpen(false)
        }
      )
    ] });
  }
  const displayName = userProfile.full_name || "Пользователь";
  const sizeClasses = {
    xs: "px-2 py-0.5 text-xs",
    sm: "px-2.5 py-1 text-xs",
    md: "px-3 py-1.5 text-sm",
    lg: "px-4 py-2 text-base"
  };
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
    /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className, onClick: handleClick, children: /* @__PURE__ */ jsxRuntimeExports.jsxs(
      "div",
      {
        className: `
            inline-flex items-center gap-1.5 rounded-full font-medium cursor-pointer
            bg-gradient-to-r from-gray-600 via-gray-500 to-gray-600
            text-white shadow-sm border border-gray-400/20
            hover:from-gray-500 hover:via-gray-400 hover:to-gray-500
            transition-all duration-200
            ${sizeClasses[size2]}
          `,
        children: [
          showIcon && /* @__PURE__ */ jsxRuntimeExports.jsx("svg", { className: "w-3 h-3 opacity-80", fill: "currentColor", viewBox: "0 0 24 24", children: /* @__PURE__ */ jsxRuntimeExports.jsx("path", { d: "M12 12c2.21 0 4-1.79 4-4s-1.79-4-4-4-4 1.79-4 4 1.79 4 4 4zm0 2c-2.67 0-8 1.34-8 4v2h16v-2c0-2.66-5.33-4-8-4z" }) }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "truncate max-w-[120px]", children: displayName })
        ]
      }
    ) }),
    /* @__PURE__ */ jsxRuntimeExports.jsx(
      UserProfileCard,
      {
        userId,
        isOpen: isProfileCardOpen,
        onClose: () => setIsProfileCardOpen(false)
      }
    )
  ] });
};
const PhotoGallery = ({
  photos,
  isOpen,
  onClose,
  initialIndex = 0
}) => {
  const { t: t2 } = useLanguage$1();
  const [currentIndex, setCurrentIndex] = reactExports.useState(initialIndex);
  const [zoom, setZoom] = reactExports.useState(1);
  const [loading, setLoading] = reactExports.useState(false);
  reactExports.useEffect(() => {
    setCurrentIndex(initialIndex);
    setZoom(1);
  }, [initialIndex, isOpen]);
  reactExports.useEffect(() => {
    const handleKeyDown = (e2) => {
      if (!isOpen) return;
      switch (e2.key) {
        case "Escape":
          onClose();
          break;
        case "ArrowLeft":
          goToPrevious();
          break;
        case "ArrowRight":
          goToNext();
          break;
        case "+":
        case "=":
          zoomIn();
          break;
        case "-":
          zoomOut();
          break;
      }
    };
    document.addEventListener("keydown", handleKeyDown);
    return () => document.removeEventListener("keydown", handleKeyDown);
  }, [isOpen, currentIndex]);
  const goToNext = () => {
    setCurrentIndex((prev2) => (prev2 + 1) % photos.length);
    setZoom(1);
  };
  const goToPrevious = () => {
    setCurrentIndex((prev2) => (prev2 - 1 + photos.length) % photos.length);
    setZoom(1);
  };
  const zoomIn = () => {
    setZoom((prev2) => Math.min(prev2 + 0.5, 3));
  };
  const zoomOut = () => {
    setZoom((prev2) => Math.max(prev2 - 0.5, 0.5));
  };
  const downloadImage = async () => {
    setLoading(true);
    try {
      const response = await fetch(photos[currentIndex]);
      const blob = await response.blob();
      const url = window.URL.createObjectURL(blob);
      const link = document.createElement("a");
      link.href = url;
      link.download = `photo-${currentIndex + 1}.jpg`;
      document.body.appendChild(link);
      link.click();
      document.body.removeChild(link);
      window.URL.revokeObjectURL(url);
    } catch (error) {
      console.error("Error downloading image:", error);
    } finally {
      setLoading(false);
    }
  };
  if (!isOpen || photos.length === 0) return null;
  return /* @__PURE__ */ jsxRuntimeExports.jsx(Dialog, { open: isOpen, onOpenChange: onClose, children: /* @__PURE__ */ jsxRuntimeExports.jsxs(DialogContent, { className: "max-w-screen max-h-screen w-screen h-screen bg-black/95 p-0 border-0", children: [
    /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "absolute top-0 left-0 right-0 z-50 flex justify-between items-center p-4 bg-gradient-to-b from-black/70 to-transparent", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "flex items-center gap-2 text-white", children: /* @__PURE__ */ jsxRuntimeExports.jsxs("span", { className: "text-sm font-medium", children: [
        currentIndex + 1,
        " / ",
        photos.length
      ] }) }),
      /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex items-center gap-2", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx(
          Button$1,
          {
            variant: "ghost",
            size: "sm",
            onClick: zoomOut,
            disabled: zoom <= 0.5,
            className: "text-white hover:bg-white/20",
            title: t2("zoomOut"),
            children: /* @__PURE__ */ jsxRuntimeExports.jsx(ZoomOut, { className: "w-4 h-4" })
          }
        ),
        /* @__PURE__ */ jsxRuntimeExports.jsxs("span", { className: "text-white text-sm min-w-[3rem] text-center", children: [
          Math.round(zoom * 100),
          "%"
        ] }),
        /* @__PURE__ */ jsxRuntimeExports.jsx(
          Button$1,
          {
            variant: "ghost",
            size: "sm",
            onClick: zoomIn,
            disabled: zoom >= 3,
            className: "text-white hover:bg-white/20",
            title: t2("zoomIn"),
            children: /* @__PURE__ */ jsxRuntimeExports.jsx(ZoomIn, { className: "w-4 h-4" })
          }
        ),
        /* @__PURE__ */ jsxRuntimeExports.jsx(
          Button$1,
          {
            variant: "ghost",
            size: "sm",
            onClick: downloadImage,
            disabled: loading,
            className: "text-white hover:bg-white/20",
            title: t2("downloadPhoto"),
            children: /* @__PURE__ */ jsxRuntimeExports.jsx(Download, { className: "w-4 h-4" })
          }
        ),
        /* @__PURE__ */ jsxRuntimeExports.jsx(
          Button$1,
          {
            variant: "ghost",
            size: "sm",
            onClick: onClose,
            className: "text-white hover:bg-white/20",
            title: t2("close"),
            children: /* @__PURE__ */ jsxRuntimeExports.jsx(X, { className: "w-4 h-4" })
          }
        )
      ] })
    ] }),
    /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "flex items-center justify-center w-full h-full overflow-hidden", children: /* @__PURE__ */ jsxRuntimeExports.jsx(
      "img",
      {
        src: photos[currentIndex],
        alt: `${t2("photo")} ${currentIndex + 1}`,
        className: "max-w-full max-h-full object-contain transition-transform duration-200 ease-in-out cursor-grab active:cursor-grabbing",
        style: {
          transform: `scale(${zoom})`
        },
        draggable: false
      }
    ) }),
    photos.length > 1 && /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx(
        Button$1,
        {
          variant: "ghost",
          size: "lg",
          onClick: goToPrevious,
          className: "absolute left-4 top-1/2 -translate-y-1/2 text-white hover:bg-white/20 p-3",
          title: t2("previousPhoto"),
          children: /* @__PURE__ */ jsxRuntimeExports.jsx(ChevronLeft, { className: "w-6 h-6" })
        }
      ),
      /* @__PURE__ */ jsxRuntimeExports.jsx(
        Button$1,
        {
          variant: "ghost",
          size: "lg",
          onClick: goToNext,
          className: "absolute right-4 top-1/2 -translate-y-1/2 text-white hover:bg-white/20 p-3",
          title: t2("nextPhoto"),
          children: /* @__PURE__ */ jsxRuntimeExports.jsx(ChevronRight, { className: "w-6 h-6" })
        }
      )
    ] }),
    photos.length > 1 && /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "absolute bottom-0 left-0 right-0 p-4 bg-gradient-to-t from-black/70 to-transparent", children: /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "flex justify-center gap-2 overflow-x-auto max-w-full", children: photos.map((photo, index2) => /* @__PURE__ */ jsxRuntimeExports.jsx(
      "button",
      {
        onClick: () => {
          setCurrentIndex(index2);
          setZoom(1);
        },
        className: `flex-shrink-0 w-12 h-12 rounded-lg overflow-hidden border-2 transition-all ${index2 === currentIndex ? "border-white shadow-lg" : "border-transparent opacity-70 hover:opacity-100"}`,
        title: `${t2("photo")} ${index2 + 1}`,
        children: /* @__PURE__ */ jsxRuntimeExports.jsx(
          "img",
          {
            src: photo,
            alt: `${t2("photo")} ${index2 + 1}`,
            className: "w-full h-full object-cover"
          }
        )
      },
      index2
    )) }) }),
    /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "absolute bottom-4 left-4 text-white/70 text-xs", children: /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "bg-black/50 p-2 rounded", children: /* @__PURE__ */ jsxRuntimeExports.jsxs("p", { children: [
      "ESC: ",
      t2("close"),
      " | ←/→: ",
      t2("navigate"),
      " | +/-: ",
      t2("zoom")
    ] }) }) })
  ] }) });
};
class IncidentEventEmitter {
  constructor() {
    __publicField(this, "listeners", {});
  }
  subscribe(event, callback) {
    if (!this.listeners[event]) {
      this.listeners[event] = [];
    }
    this.listeners[event].push(callback);
    return () => {
      if (this.listeners[event]) {
        this.listeners[event] = this.listeners[event].filter((cb) => cb !== callback);
      }
    };
  }
  emit(event, payload) {
    console.log(`📡 Emitting event '${event}':`, payload);
    if (this.listeners[event]) {
      this.listeners[event].forEach((callback) => {
        try {
          callback(payload);
        } catch (error) {
          console.error(`Error in event callback for ${event}:`, error);
        }
      });
    }
  }
}
const incidentEventEmitter = new IncidentEventEmitter();
const useIncidentReactionsMutations = (updateReactionFn) => {
  const { user } = useAuth();
  const { t: t2 } = useLanguage$1();
  const queryClient = useQueryClient();
  const confirmIncident = useMutation({
    mutationFn: async ({ incidentId, currentReaction }) => {
      if (!user) throw new Error("Usuario no autenticado");
      const { data: existingConfirmation } = await supabase.from("incident_confirmations").select("id").eq("incident_id", incidentId).eq("user_id", user.id).maybeSingle();
      if (existingConfirmation) {
        const { error } = await supabase.from("incident_confirmations").delete().eq("incident_id", incidentId).eq("user_id", user.id);
        if (error) throw error;
        return { action: "removed" };
      } else {
        const { data: existingRejection } = await supabase.from("incident_rejections").select("id").eq("incident_id", incidentId).eq("user_id", user.id).maybeSingle();
        if (existingRejection) {
          await supabase.from("incident_rejections").delete().eq("incident_id", incidentId).eq("user_id", user.id);
        }
        const { error } = await supabase.from("incident_confirmations").insert({
          incident_id: incidentId,
          user_id: user.id
        });
        if (error) throw error;
        return { action: "added", overrode_rejection: !!existingRejection };
      }
    },
    onMutate: async ({ incidentId, currentReaction }) => {
      console.log("🚀 Optimistic confirm reaction for incident:", incidentId, "current:", currentReaction);
      const wasConfirmed = currentReaction === "confirm";
      const wasRejected = currentReaction === "reject";
      {
        console.log("❌ No update function provided");
      }
      if (wasConfirmed) {
        console.log("📤 Emitting: remove confirmation");
        incidentEventEmitter.emit({
          incidentId,
          reactionType: null,
          countChange: { confirm: -1 }
        });
      } else {
        console.log("📤 Emitting: add confirmation");
        incidentEventEmitter.emit({
          incidentId,
          reactionType: "confirm",
          countChange: {
            confirm: 1,
            reject: wasRejected ? -1 : 0
          }
        });
      }
      return { incidentId };
    },
    onSuccess: () => {
      console.log("✅ Confirm reaction successful");
      setTimeout(() => {
        queryClient.invalidateQueries({ queryKey: ["incidents-realtime"] });
      }, 500);
    },
    onError: (error, variables) => {
      console.error("❌ Error confirming incident:", error);
      queryClient.invalidateQueries({ queryKey: ["incidents-realtime"] });
      toast({
        title: t2("error"),
        description: t2("errorSavingReaction"),
        variant: "destructive"
      });
    }
  });
  const rejectIncident = useMutation({
    mutationFn: async ({ incidentId, currentReaction }) => {
      if (!user) throw new Error("Usuario no autenticado");
      const { data: existingRejection } = await supabase.from("incident_rejections").select("id").eq("incident_id", incidentId).eq("user_id", user.id).maybeSingle();
      if (existingRejection) {
        const { error } = await supabase.from("incident_rejections").delete().eq("incident_id", incidentId).eq("user_id", user.id);
        if (error) throw error;
        return { action: "removed" };
      } else {
        const { data: existingConfirmation } = await supabase.from("incident_confirmations").select("id").eq("incident_id", incidentId).eq("user_id", user.id).maybeSingle();
        if (existingConfirmation) {
          await supabase.from("incident_confirmations").delete().eq("incident_id", incidentId).eq("user_id", user.id);
        }
        const { error } = await supabase.from("incident_rejections").insert({
          incident_id: incidentId,
          user_id: user.id
        });
        if (error) throw error;
        return { action: "added", overrode_confirmation: !!existingConfirmation };
      }
    },
    onMutate: async ({ incidentId, currentReaction }) => {
      console.log("🚀 Optimistic reject reaction for incident:", incidentId, "current:", currentReaction);
      const wasRejected = currentReaction === "reject";
      const wasConfirmed = currentReaction === "confirm";
      {
        console.log("❌ No update function provided");
      }
      if (wasRejected) {
        console.log("📤 Emitting: remove rejection");
        incidentEventEmitter.emit({
          incidentId,
          reactionType: null,
          countChange: { reject: -1 }
        });
      } else {
        console.log("📤 Emitting: add rejection");
        incidentEventEmitter.emit({
          incidentId,
          reactionType: "reject",
          countChange: {
            reject: 1,
            confirm: wasConfirmed ? -1 : 0
          }
        });
      }
      return { incidentId };
    },
    onSuccess: () => {
      console.log("✅ Reject reaction successful");
      setTimeout(() => {
        queryClient.invalidateQueries({ queryKey: ["incidents-realtime"] });
      }, 500);
    },
    onError: (error, variables) => {
      console.error("❌ Error rejecting incident:", error);
      queryClient.invalidateQueries({ queryKey: ["incidents-realtime"] });
      toast({
        title: t2("error"),
        description: t2("errorSavingReaction"),
        variant: "destructive"
      });
    }
  });
  return {
    confirmIncident,
    rejectIncident,
    isConfirmingIncident: confirmIncident.isPending,
    isRejectingIncident: rejectIncident.isPending
  };
};
const IncidentReactions = ({
  incidentId,
  confirmCount,
  rejectCount,
  userReaction,
  className,
  isPendingDeletion
}) => {
  const { t: t2 } = useLanguage$1();
  const { confirmIncident, rejectIncident, isConfirmingIncident, isRejectingIncident } = useIncidentReactionsMutations();
  const [localConfirmCount, setLocalConfirmCount] = reactExports.useState(confirmCount);
  const [localRejectCount, setLocalRejectCount] = reactExports.useState(rejectCount);
  const [localUserReaction, setLocalUserReaction] = reactExports.useState(userReaction);
  reactExports.useEffect(() => {
    console.log("🔄 Syncing local state with props:", { confirmCount, rejectCount, userReaction });
    setLocalConfirmCount(confirmCount);
    setLocalRejectCount(rejectCount);
    setLocalUserReaction(userReaction);
  }, [confirmCount, rejectCount, userReaction]);
  const totalReactions = localConfirmCount + localRejectCount;
  const rejectPercentage = totalReactions > 0 ? localRejectCount / totalReactions * 100 : 0;
  const handleConfirm = () => {
    console.log("🎯 Confirm button clicked for incident:", incidentId, "current reaction:", localUserReaction);
    const currentReactionForMutation = localUserReaction;
    if (localUserReaction === "confirm") {
      console.log("🔴 Removing confirmation");
      setLocalUserReaction(null);
      setLocalConfirmCount((prev2) => Math.max(prev2 - 1, 0));
    } else {
      console.log("🟢 Adding confirmation");
      setLocalUserReaction("confirm");
      setLocalConfirmCount((prev2) => prev2 + 1);
      if (localUserReaction === "reject") {
        setLocalRejectCount((prev2) => Math.max(prev2 - 1, 0));
      }
    }
    confirmIncident.mutate({ incidentId, currentReaction: currentReactionForMutation });
  };
  const handleReject = () => {
    console.log("🎯 Reject button clicked for incident:", incidentId, "current reaction:", localUserReaction);
    const currentReactionForMutation = localUserReaction;
    if (localUserReaction === "reject") {
      console.log("🔴 Removing rejection");
      setLocalUserReaction(null);
      setLocalRejectCount((prev2) => Math.max(prev2 - 1, 0));
    } else {
      console.log("🔴 Adding rejection");
      setLocalUserReaction("reject");
      setLocalRejectCount((prev2) => prev2 + 1);
      if (localUserReaction === "confirm") {
        setLocalConfirmCount((prev2) => Math.max(prev2 - 1, 0));
      }
    }
    rejectIncident.mutate({ incidentId, currentReaction: currentReactionForMutation });
  };
  return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: cn("flex flex-col gap-2", className), children: [
    isPendingDeletion && rejectPercentage >= 90 && /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "bg-red-900/20 text-red-400 px-3 py-2 rounded-xl text-xs", children: t2("incidentPendingDeletion") }),
    /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex items-center gap-2", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsxs(
        Button$1,
        {
          variant: "outline",
          size: "sm",
          className: cn(
            "flex-1 rounded-lg h-10 text-sm font-medium transition-all duration-200",
            localUserReaction === "confirm" ? "bg-green-600 border-green-500 text-white hover:bg-green-700 hover:border-green-600" : "border-gray-600 text-gray-400 hover:border-green-500 hover:text-green-400 hover:bg-green-500/10"
          ),
          onClick: handleConfirm,
          disabled: isConfirmingIncident || isRejectingIncident,
          children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx(ThumbsUp, { className: "w-4 h-4 mr-2" }),
            localUserReaction === "confirm" ? t2("confirmed") : t2("confirm")
          ]
        }
      ),
      /* @__PURE__ */ jsxRuntimeExports.jsxs(
        Button$1,
        {
          variant: "outline",
          size: "sm",
          className: cn(
            "flex-1 rounded-lg h-10 text-sm font-medium transition-all duration-200",
            localUserReaction === "reject" ? "bg-red-600 border-red-500 text-white hover:bg-red-700 hover:border-red-600" : "border-gray-600 text-gray-400 hover:border-red-500 hover:text-red-400 hover:bg-red-500/10"
          ),
          onClick: handleReject,
          disabled: isConfirmingIncident || isRejectingIncident,
          children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx(ThumbsDown, { className: "w-4 h-4 mr-2" }),
            localUserReaction === "reject" ? t2("rejected") : t2("reject")
          ]
        }
      )
    ] }),
    /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex items-center gap-2 text-xs text-gray-400", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsxs("span", { className: "flex-1 text-center", children: [
        localConfirmCount,
        " ",
        t2("confirmations")
      ] }),
      /* @__PURE__ */ jsxRuntimeExports.jsxs("span", { className: "flex-1 text-center", children: [
        localRejectCount,
        " ",
        t2("rejections")
      ] })
    ] })
  ] });
};
const OptimizedTextarea = reactExports.memo(
  reactExports.forwardRef(
    ({ className, enableMobileFeatures, textType, ...props }, ref) => {
      const handleChange = reactExports.useCallback((e2) => {
        props.onChange?.(e2);
      }, [props.onChange]);
      const getMobileSettings = () => {
        if (enableMobileFeatures !== void 0) {
          return {
            autoCorrect: enableMobileFeatures ? "on" : "off",
            autoCapitalize: enableMobileFeatures ? "sentences" : "off",
            spellCheck: enableMobileFeatures
          };
        }
        switch (textType) {
          case "search":
            return {
              autoCorrect: "on",
              autoCapitalize: "off",
              spellCheck: false
            };
          case "comment":
          case "message":
          case "bio":
          case "description":
          case "text":
          default:
            return {
              autoCorrect: "on",
              autoCapitalize: "sentences",
              spellCheck: true
            };
        }
      };
      const mobileSettings = getMobileSettings();
      return /* @__PURE__ */ jsxRuntimeExports.jsx(
        "textarea",
        {
          className: cn(
            "flex min-h-[80px] w-full rounded-md border border-input bg-background px-3 py-2 text-sm ring-offset-background placeholder:text-muted-foreground focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2 disabled:cursor-not-allowed disabled:opacity-50 touch-manipulation resize-none will-change-auto",
            className
          ),
          ref,
          onChange: handleChange,
          autoComplete: props.autoComplete || "on",
          autoCorrect: mobileSettings.autoCorrect,
          autoCapitalize: mobileSettings.autoCapitalize,
          spellCheck: mobileSettings.spellCheck,
          style: {
            WebkitTapHighlightColor: "transparent",
            WebkitAppearance: "none",
            transform: "translateZ(0)",
            // Улучшения для мобильного удаления текста
            WebkitUserSelect: "text",
            userSelect: "text",
            // Улучшения для textarea
            lineHeight: "1.5",
            wordWrap: "break-word",
            ...props.style
          },
          ...props
        }
      );
    }
  )
);
OptimizedTextarea.displayName = "OptimizedTextarea";
const IncidentComments = ({
  incidentId,
  comments,
  onAddComment,
  onDeleteComment,
  className
}) => {
  const { t: t2 } = useLanguage$1();
  const { user } = useAuth();
  const { isAdmin } = useUserRole();
  const [commentList, setCommentList] = reactExports.useState(comments);
  const [newComment, setNewComment] = reactExports.useState("");
  const [isSubmitting, setIsSubmitting] = reactExports.useState(false);
  reactExports.useEffect(() => setCommentList(comments), [comments]);
  const handleSubmit = async () => {
    if (!newComment.trim()) return;
    setIsSubmitting(true);
    try {
      const newCommentData = await onAddComment(newComment.trim());
      if (newCommentData) {
        setCommentList((prev2) => [...prev2, newCommentData]);
      }
      setNewComment("");
    } catch (error) {
      console.error("Error adding comment:", error);
    } finally {
      setIsSubmitting(false);
    }
  };
  const getUserInitials = (fullName) => {
    return fullName.split(" ").map((name) => name[0]).join("").toUpperCase();
  };
  return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: cn("space-y-3", className), children: [
    /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex items-center gap-2 text-muted-foreground", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx(MessageSquare, { className: "w-3 h-3" }),
      /* @__PURE__ */ jsxRuntimeExports.jsxs("span", { className: "text-xs font-medium", children: [
        t2("comments"),
        " (",
        commentList.length,
        ")"
      ] })
    ] }),
    /* @__PURE__ */ jsxRuntimeExports.jsx(ScrollArea, { className: "h-[200px] pr-3", children: /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "space-y-2", children: [
      console.log("DEBUG: Rendering comments, list content:", JSON.stringify(commentList, null, 2)),
      commentList.filter(Boolean).map((comment2) => {
        if (!comment2 || !comment2.id) {
          console.error("DEBUG: Skipping invalid comment object:", comment2);
          return null;
        }
        const canDelete = user && (comment2.user_id === user.id || isAdmin());
        return /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "bg-black/20 rounded-xl p-2", children: /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex gap-2", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsxs(Avatar, { className: "w-6 h-6", children: [
            comment2.user?.avatar_url && /* @__PURE__ */ jsxRuntimeExports.jsx(AvatarImage, { src: comment2.user.avatar_url }),
            /* @__PURE__ */ jsxRuntimeExports.jsx(AvatarFallback, { className: "bg-primary/10 text-[10px]", children: getUserInitials(comment2.user?.full_name || "") })
          ] }),
          /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex-1 space-y-0.5", children: [
            /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex items-center gap-1.5", children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx(
                UserDisplayWrapper,
                {
                  userId: comment2.user_id,
                  isAnonymous: comment2.is_anonymous,
                  fullName: comment2.user?.full_name
                }
              ),
              /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "text-[10px] text-muted-foreground", children: formatDateTimeAMPM(new Date(comment2.created_at)) }),
              canDelete && /* @__PURE__ */ jsxRuntimeExports.jsx(
                "button",
                {
                  onClick: async () => {
                    await onDeleteComment(comment2.id);
                    setCommentList((prev2) => prev2.filter((c2) => c2.id !== comment2.id));
                  },
                  className: "ml-auto text-gray-400 hover:text-red-400",
                  children: /* @__PURE__ */ jsxRuntimeExports.jsx(Trash2, { className: "w-3 h-3" })
                }
              )
            ] }),
            /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: "text-xs text-foreground leading-relaxed", children: comment2.content })
          ] })
        ] }) }, comment2.id);
      })
    ] }) }),
    user && /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "space-y-1.5", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx(
        OptimizedTextarea,
        {
          value: newComment,
          onChange: (e2) => setNewComment(e2.target.value),
          placeholder: t2("addCommentPlaceholder"),
          className: "min-h-[60px] bg-black/20 border-none rounded-xl resize-none focus-visible:ring-primary/20 text-xs"
        }
      ),
      /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "flex items-center justify-end", children: /* @__PURE__ */ jsxRuntimeExports.jsxs(
        Button$1,
        {
          onClick: handleSubmit,
          disabled: !newComment.trim() || isSubmitting,
          size: "sm",
          className: "rounded-xl shadow-lg shadow-primary/20 h-7 text-xs",
          children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx(Send, { className: "w-3 h-3 mr-1.5" }),
            t2("send")
          ]
        }
      ) })
    ] })
  ] });
};
const IncidentDetailDialog = ({ incident, open, onOpenChange, onEdit, onDelete, updateIncidentReaction }) => {
  const { t: t2 } = useLanguage$1();
  const { user } = useAuth();
  const { canDeleteIncident } = useUserRole();
  const [commentList, setCommentList] = reactExports.useState([]);
  const [galleryOpen, setGalleryOpen] = reactExports.useState(false);
  const [selectedPhotoIndex, setSelectedPhotoIndex] = reactExports.useState(0);
  const queryClient = useQueryClient();
  reactExports.useEffect(() => {
    if (incident) {
      const fetchComments = async () => {
        const { data, error } = await supabase.from("incident_comments").select("*, user:profiles(full_name, avatar_url)").eq("incident_id", incident.id).order("created_at", { ascending: true });
        if (error) {
          console.error("Error fetching comments:", error);
        } else {
          setCommentList(data || []);
        }
      };
      fetchComments();
    }
  }, [incident]);
  if (!incident) return null;
  user && incident.user_id === user.id;
  const canDelete = canDeleteIncident(incident.user_id);
  const getSeverityColor = (severity) => {
    switch (severity) {
      case "high":
        return "border-danger text-danger";
      case "medium":
        return "border-warning text-warning";
      case "low":
        return "border-green-500 text-green-500";
      default:
        return "border-gray-500 text-gray-500";
    }
  };
  const handleDelete = async () => {
    if (window.confirm(t2("confirmDeleteIncident"))) {
      try {
        const { error } = await supabase.rpc("archive_and_delete_incident", {
          incident_id: incident.id
        });
        if (error) {
          toast({ title: t2("error"), description: t2("errorDeletingIncident"), variant: "destructive" });
          return;
        }
        toast({ title: t2("incidentDeleted"), description: t2("incidentDeletedMessage") });
        onOpenChange(false);
        if (onDelete) {
          onDelete(incident.id);
        }
        queryClient.invalidateQueries({ queryKey: ["incidents"] });
      } catch (error) {
        toast({ title: t2("error"), description: t2("errorDeletingIncident"), variant: "destructive" });
      }
    }
  };
  const handleAddComment = async (content, isAnonymous) => {
    if (!user) return;
    try {
      const { data, error } = await supabase.from("incident_comments").insert({
        incident_id: incident.id,
        user_id: user.id,
        content,
        is_anonymous: isAnonymous
      }).select(`*, user:profiles(full_name, avatar_url)`).single();
      if (error) throw error;
      queryClient.invalidateQueries({ queryKey: ["incidents"] });
      return data;
    } catch (error) {
      console.error("Error adding comment:", error);
      toast({ title: t2("error"), description: t2("errorAddingComment"), variant: "destructive" });
    }
  };
  const handleDeleteComment = async (commentId) => {
    try {
      const { error } = await supabase.from("incident_comments").delete().eq("id", commentId);
      if (error) throw error;
      setCommentList((prev2) => prev2.filter((c2) => c2.id !== commentId));
      queryClient.invalidateQueries({ queryKey: ["incidents"] });
    } catch (error) {
      console.error("Error deleting comment:", error);
      toast({ title: t2("error"), description: t2("errorDeletingComment"), variant: "destructive" });
    }
  };
  const openPhotoGallery = (index2) => {
    setSelectedPhotoIndex(index2);
    setGalleryOpen(true);
  };
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
    /* @__PURE__ */ jsxRuntimeExports.jsx(Dialog, { open, onOpenChange, children: /* @__PURE__ */ jsxRuntimeExports.jsx(DialogContent, { className: "max-w-md w-full bg-background/90 backdrop-blur-sm border-border/50 text-white rounded-2xl shadow-2xl p-0", children: /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "max-h-[85vh] overflow-y-auto", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "relative", children: [
        incident.photos && incident.photos.length > 0 && /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "relative", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("img", { src: incident.photos[0], alt: t2(incident.type), className: "w-full h-48 object-cover rounded-t-2xl" }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "absolute inset-0 bg-gradient-to-t from-background via-background/50 to-transparent" })
        ] }),
        /* @__PURE__ */ jsxRuntimeExports.jsx(DialogHeader, { className: "p-4 pt-2 absolute bottom-0 left-0", children: /* @__PURE__ */ jsxRuntimeExports.jsx(DialogTitle, { className: "text-xl font-bold text-white shadow-black [text-shadow:0_2px_4px_var(--tw-shadow-color)]", children: t2(incident.type) }) })
      ] }),
      /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "p-4 pt-2 space-y-3", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "flex items-center justify-between text-xs text-gray-400", children: /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex items-center gap-1.5", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx(MapPin, { className: "w-3 h-3" }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("span", { children: incident.address || t2("addressUnavailable") })
        ] }) }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "flex items-center gap-2", children: /* @__PURE__ */ jsxRuntimeExports.jsx(Badge, { variant: "outline", className: cn("text-xs", getSeverityColor(incident.severity)), children: t2(incident.severity) }) }),
        incident.description && /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: "text-sm text-gray-300 leading-relaxed", children: incident.description }),
        incident.photos && incident.photos.length > 0 && /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "space-y-1", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("h4", { className: "text-xs font-medium text-gray-300", children: t2("photos") }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "flex gap-1.5 overflow-x-auto pb-1.5 scrollbar-thin scrollbar-thumb-gray-600 scrollbar-track-transparent", children: incident.photos.map((photo, index2) => /* @__PURE__ */ jsxRuntimeExports.jsxs(
            "div",
            {
              className: "relative flex-shrink-0 cursor-pointer group",
              onClick: () => openPhotoGallery(index2),
              children: [
                /* @__PURE__ */ jsxRuntimeExports.jsx(
                  "img",
                  {
                    src: photo,
                    alt: `${t2("photo")} ${index2 + 1}`,
                    className: "w-20 h-20 object-cover rounded-xl border border-border transition-all duration-200 group-hover:brightness-75"
                  }
                ),
                /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "absolute inset-0 flex items-center justify-center opacity-0 group-hover:opacity-100 transition-opacity duration-200 bg-black/40 rounded-xl", children: /* @__PURE__ */ jsxRuntimeExports.jsx(Eye, { className: "w-4 h-4 text-white" }) }),
                incident.photos && incident.photos.length > 1 && /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "absolute top-1 right-1 bg-black/70 text-white text-[10px] px-1 py-0.5 rounded-full", children: [
                  index2 + 1,
                  "/",
                  incident.photos.length
                ] })
              ]
            },
            index2
          )) })
        ] }),
        /* @__PURE__ */ jsxRuntimeExports.jsx(
          IncidentReactions,
          {
            incidentId: incident.id,
            confirmCount: incident.confirm_count || 0,
            rejectCount: incident.reject_count || 0,
            userReaction: incident.user_reaction,
            isPendingDeletion: incident.is_pending_deletion,
            className: "pt-1",
            updateIncidentReaction
          }
        ),
        /* @__PURE__ */ jsxRuntimeExports.jsx(
          IncidentComments,
          {
            incidentId: incident.id,
            comments: commentList,
            onAddComment: handleAddComment,
            onDeleteComment: handleDeleteComment,
            className: "pt-1"
          }
        ),
        canDelete && /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "flex gap-2 pt-2 border-t border-border/30", children: /* @__PURE__ */ jsxRuntimeExports.jsxs(
          Button$1,
          {
            onClick: handleDelete,
            variant: "outline",
            size: "sm",
            className: "flex-1 border-red-500 text-red-400 hover:bg-red-500/20 rounded-xl h-8 text-xs",
            children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx(Trash2, { className: "w-3 h-3 mr-1.5" }),
              t2("delete")
            ]
          }
        ) })
      ] })
    ] }) }) }),
    incident.photos && /* @__PURE__ */ jsxRuntimeExports.jsx(
      PhotoGallery,
      {
        photos: incident.photos,
        isOpen: galleryOpen,
        onClose: () => setGalleryOpen(false),
        initialIndex: selectedPhotoIndex
      }
    )
  ] });
};
const useNotifications = () => {
  const [stats, setStats] = reactExports.useState({
    total: 0,
    unread: 0,
    archived: 0
  });
  const [loading, setLoading] = reactExports.useState(true);
  const [error, setError] = reactExports.useState(null);
  const { user } = useAuth();
  const channelRef = reactExports.useRef(null);
  const fetchNotificationStats = async () => {
    if (!user) {
      setStats({ total: 0, unread: 0, archived: 0 });
      setLoading(false);
      return;
    }
    try {
      setLoading(true);
      setError(null);
      const { data, error: statsError } = await supabase.from("notifications").select("id, is_read, created_at").eq("user_id", user.id);
      if (statsError) {
        console.error("Error fetching notification stats:", statsError);
        setError(statsError.message);
        return;
      }
      if (data) {
        const total = data.length;
        const unread = data.filter((n2) => !n2.is_read).length;
        const archived = 0;
        setStats({
          total,
          unread,
          archived
        });
      } else {
        setStats({ total: 0, unread: 0, archived: 0 });
      }
    } catch (err) {
      console.error("Error in fetchNotificationStats:", err);
      setError(err instanceof Error ? err.message : "Unknown error");
      setStats({ total: 0, unread: 0, archived: 0 });
    } finally {
      setLoading(false);
    }
  };
  const markAsRead = async (notificationId) => {
    if (!user) return false;
    try {
      const { data, error: error2 } = await supabase.from("notifications").update({ is_read: true }).eq("id", notificationId).eq("user_id", user.id);
      if (error2) {
        console.error("Error marking notification as read:", error2);
        return false;
      }
      await fetchNotificationStats();
      return data;
    } catch (err) {
      console.error("Error in markAsRead:", err);
      return false;
    }
  };
  const markAllAsRead = async () => {
    if (!user) return 0;
    try {
      const { data, error: error2 } = await supabase.from("notifications").update({ is_read: true }).eq("user_id", user.id).eq("is_read", false);
      if (error2) {
        console.error("Error marking all notifications as read:", error2);
        return 0;
      }
      await fetchNotificationStats();
      return data || 0;
    } catch (err) {
      console.error("Error in markAllAsRead:", err);
      return 0;
    }
  };
  const archiveNotification = async (notificationId) => {
    if (!user) return false;
    try {
      const { data, error: error2 } = await supabase.from("notifications").delete().eq("id", notificationId).eq("user_id", user.id);
      if (error2) {
        console.error("Error archiving notification:", error2);
        return false;
      }
      await fetchNotificationStats();
      return data;
    } catch (err) {
      console.error("Error in archiveNotification:", err);
      return false;
    }
  };
  reactExports.useEffect(() => {
    if (!user) return;
    fetchNotificationStats();
    const channelName = `notifications-changes-${user.id}`;
    const channel = realtimeService.getChannel(channelName);
    if (!channel) {
      console.log("[useNotifications] Channel not ready, skipping setup");
      return;
    }
    const configuredChannel = channel.on(
      "postgres_changes",
      {
        event: "*",
        schema: "public",
        table: "notifications",
        filter: `user_id=eq.${user.id}`
      },
      () => {
        fetchNotificationStats();
      }
    );
    const subscribedChannel = configuredChannel.subscribe();
    if (!channelRef.current) {
      channelRef.current = subscribedChannel;
    }
    return () => {
      realtimeService.dropChannel(`notifications-changes-${user.id}`);
      channelRef.current = null;
    };
  }, [user]);
  return {
    stats,
    loading,
    error,
    markAsRead,
    markAllAsRead,
    archiveNotification,
    refreshStats: fetchNotificationStats
  };
};
function createContextScope$1(scopeName, createContextScopeDeps = []) {
  let defaultContexts = [];
  function createContext3(rootComponentName, defaultContext2) {
    const BaseContext = reactExports.createContext(defaultContext2);
    const index2 = defaultContexts.length;
    defaultContexts = [...defaultContexts, defaultContext2];
    function Provider2(props) {
      const { scope, children, ...context } = props;
      const Context = scope?.[scopeName][index2] || BaseContext;
      const value = reactExports.useMemo(() => context, Object.values(context));
      return /* @__PURE__ */ jsxRuntimeExports.jsx(Context.Provider, { value, children });
    }
    function useContext2(consumerName, scope) {
      const Context = scope?.[scopeName][index2] || BaseContext;
      const context = reactExports.useContext(Context);
      if (context) return context;
      if (defaultContext2 !== void 0) return defaultContext2;
      throw new Error(`\`${consumerName}\` must be used within \`${rootComponentName}\``);
    }
    Provider2.displayName = rootComponentName + "Provider";
    return [Provider2, useContext2];
  }
  const createScope = () => {
    const scopeContexts = defaultContexts.map((defaultContext2) => {
      return reactExports.createContext(defaultContext2);
    });
    return function useScope(scope) {
      const contexts = scope?.[scopeName] || scopeContexts;
      return reactExports.useMemo(
        () => ({ [`__scope${scopeName}`]: { ...scope, [scopeName]: contexts } }),
        [scope, contexts]
      );
    };
  };
  createScope.scopeName = scopeName;
  return [createContext3, composeContextScopes$1(createScope, ...createContextScopeDeps)];
}
function composeContextScopes$1(...scopes) {
  const baseScope = scopes[0];
  if (scopes.length === 1) return baseScope;
  const createScope = () => {
    const scopeHooks = scopes.map((createScope2) => ({
      useScope: createScope2(),
      scopeName: createScope2.scopeName
    }));
    return function useComposedScopes(overrideScopes) {
      const nextScopes = scopeHooks.reduce((nextScopes2, { useScope, scopeName }) => {
        const scopeProps = useScope(overrideScopes);
        const currentScope = scopeProps[`__scope${scopeName}`];
        return { ...nextScopes2, ...currentScope };
      }, {});
      return reactExports.useMemo(() => ({ [`__scope${baseScope.scopeName}`]: nextScopes }), [nextScopes]);
    };
  };
  createScope.scopeName = baseScope.scopeName;
  return createScope;
}
function createCollection(name) {
  const PROVIDER_NAME2 = name + "CollectionProvider";
  const [createCollectionContext, createCollectionScope2] = createContextScope$1(PROVIDER_NAME2);
  const [CollectionProviderImpl, useCollectionContext] = createCollectionContext(
    PROVIDER_NAME2,
    { collectionRef: { current: null }, itemMap: /* @__PURE__ */ new Map() }
  );
  const CollectionProvider = (props) => {
    const { scope, children } = props;
    const ref = React.useRef(null);
    const itemMap = React.useRef(/* @__PURE__ */ new Map()).current;
    return /* @__PURE__ */ jsxRuntimeExports.jsx(CollectionProviderImpl, { scope, itemMap, collectionRef: ref, children });
  };
  CollectionProvider.displayName = PROVIDER_NAME2;
  const COLLECTION_SLOT_NAME = name + "CollectionSlot";
  const CollectionSlot = React.forwardRef(
    (props, forwardedRef) => {
      const { scope, children } = props;
      const context = useCollectionContext(COLLECTION_SLOT_NAME, scope);
      const composedRefs = useComposedRefs(forwardedRef, context.collectionRef);
      return /* @__PURE__ */ jsxRuntimeExports.jsx(Slot, { ref: composedRefs, children });
    }
  );
  CollectionSlot.displayName = COLLECTION_SLOT_NAME;
  const ITEM_SLOT_NAME = name + "CollectionItemSlot";
  const ITEM_DATA_ATTR = "data-radix-collection-item";
  const CollectionItemSlot = React.forwardRef(
    (props, forwardedRef) => {
      const { scope, children, ...itemData } = props;
      const ref = React.useRef(null);
      const composedRefs = useComposedRefs(forwardedRef, ref);
      const context = useCollectionContext(ITEM_SLOT_NAME, scope);
      React.useEffect(() => {
        context.itemMap.set(ref, { ref, ...itemData });
        return () => void context.itemMap.delete(ref);
      });
      return /* @__PURE__ */ jsxRuntimeExports.jsx(Slot, { ...{ [ITEM_DATA_ATTR]: "" }, ref: composedRefs, children });
    }
  );
  CollectionItemSlot.displayName = ITEM_SLOT_NAME;
  function useCollection2(scope) {
    const context = useCollectionContext(name + "CollectionConsumer", scope);
    const getItems = React.useCallback(() => {
      const collectionNode = context.collectionRef.current;
      if (!collectionNode) return [];
      const orderedNodes = Array.from(collectionNode.querySelectorAll(`[${ITEM_DATA_ATTR}]`));
      const items = Array.from(context.itemMap.values());
      const orderedItems = items.sort(
        (a2, b2) => orderedNodes.indexOf(a2.ref.current) - orderedNodes.indexOf(b2.ref.current)
      );
      return orderedItems;
    }, [context.collectionRef, context.itemMap]);
    return getItems;
  }
  return [
    { Provider: CollectionProvider, Slot: CollectionSlot, ItemSlot: CollectionItemSlot },
    useCollection2,
    createCollectionScope2
  ];
}
function createContextScope(scopeName, createContextScopeDeps = []) {
  let defaultContexts = [];
  function createContext3(rootComponentName, defaultContext2) {
    const BaseContext = reactExports.createContext(defaultContext2);
    const index2 = defaultContexts.length;
    defaultContexts = [...defaultContexts, defaultContext2];
    function Provider2(props) {
      const { scope, children, ...context } = props;
      const Context = scope?.[scopeName][index2] || BaseContext;
      const value = reactExports.useMemo(() => context, Object.values(context));
      return /* @__PURE__ */ jsxRuntimeExports.jsx(Context.Provider, { value, children });
    }
    function useContext2(consumerName, scope) {
      const Context = scope?.[scopeName][index2] || BaseContext;
      const context = reactExports.useContext(Context);
      if (context) return context;
      if (defaultContext2 !== void 0) return defaultContext2;
      throw new Error(`\`${consumerName}\` must be used within \`${rootComponentName}\``);
    }
    Provider2.displayName = rootComponentName + "Provider";
    return [Provider2, useContext2];
  }
  const createScope = () => {
    const scopeContexts = defaultContexts.map((defaultContext2) => {
      return reactExports.createContext(defaultContext2);
    });
    return function useScope(scope) {
      const contexts = scope?.[scopeName] || scopeContexts;
      return reactExports.useMemo(
        () => ({ [`__scope${scopeName}`]: { ...scope, [scopeName]: contexts } }),
        [scope, contexts]
      );
    };
  };
  createScope.scopeName = scopeName;
  return [createContext3, composeContextScopes(createScope, ...createContextScopeDeps)];
}
function composeContextScopes(...scopes) {
  const baseScope = scopes[0];
  if (scopes.length === 1) return baseScope;
  const createScope = () => {
    const scopeHooks = scopes.map((createScope2) => ({
      useScope: createScope2(),
      scopeName: createScope2.scopeName
    }));
    return function useComposedScopes(overrideScopes) {
      const nextScopes = scopeHooks.reduce((nextScopes2, { useScope, scopeName }) => {
        const scopeProps = useScope(overrideScopes);
        const currentScope = scopeProps[`__scope${scopeName}`];
        return { ...nextScopes2, ...currentScope };
      }, {});
      return reactExports.useMemo(() => ({ [`__scope${baseScope.scopeName}`]: nextScopes }), [nextScopes]);
    };
  };
  createScope.scopeName = baseScope.scopeName;
  return createScope;
}
var ENTRY_FOCUS = "rovingFocusGroup.onEntryFocus";
var EVENT_OPTIONS = { bubbles: false, cancelable: true };
var GROUP_NAME = "RovingFocusGroup";
var [Collection$1, useCollection$1, createCollectionScope$1] = createCollection(GROUP_NAME);
var [createRovingFocusGroupContext, createRovingFocusGroupScope] = createContextScope(
  GROUP_NAME,
  [createCollectionScope$1]
);
var [RovingFocusProvider, useRovingFocusContext] = createRovingFocusGroupContext(GROUP_NAME);
var RovingFocusGroup = reactExports.forwardRef(
  (props, forwardedRef) => {
    return /* @__PURE__ */ jsxRuntimeExports.jsx(Collection$1.Provider, { scope: props.__scopeRovingFocusGroup, children: /* @__PURE__ */ jsxRuntimeExports.jsx(Collection$1.Slot, { scope: props.__scopeRovingFocusGroup, children: /* @__PURE__ */ jsxRuntimeExports.jsx(RovingFocusGroupImpl, { ...props, ref: forwardedRef }) }) });
  }
);
RovingFocusGroup.displayName = GROUP_NAME;
var RovingFocusGroupImpl = reactExports.forwardRef((props, forwardedRef) => {
  const {
    __scopeRovingFocusGroup,
    orientation,
    loop = false,
    dir,
    currentTabStopId: currentTabStopIdProp,
    defaultCurrentTabStopId,
    onCurrentTabStopIdChange,
    onEntryFocus,
    preventScrollOnEntryFocus = false,
    ...groupProps
  } = props;
  const ref = reactExports.useRef(null);
  const composedRefs = useComposedRefs(forwardedRef, ref);
  const direction = useDirection(dir);
  const [currentTabStopId = null, setCurrentTabStopId] = useControllableState({
    prop: currentTabStopIdProp,
    defaultProp: defaultCurrentTabStopId,
    onChange: onCurrentTabStopIdChange
  });
  const [isTabbingBackOut, setIsTabbingBackOut] = reactExports.useState(false);
  const handleEntryFocus = useCallbackRef$1(onEntryFocus);
  const getItems = useCollection$1(__scopeRovingFocusGroup);
  const isClickFocusRef = reactExports.useRef(false);
  const [focusableItemsCount, setFocusableItemsCount] = reactExports.useState(0);
  reactExports.useEffect(() => {
    const node2 = ref.current;
    if (node2) {
      node2.addEventListener(ENTRY_FOCUS, handleEntryFocus);
      return () => node2.removeEventListener(ENTRY_FOCUS, handleEntryFocus);
    }
  }, [handleEntryFocus]);
  return /* @__PURE__ */ jsxRuntimeExports.jsx(
    RovingFocusProvider,
    {
      scope: __scopeRovingFocusGroup,
      orientation,
      dir: direction,
      loop,
      currentTabStopId,
      onItemFocus: reactExports.useCallback(
        (tabStopId) => setCurrentTabStopId(tabStopId),
        [setCurrentTabStopId]
      ),
      onItemShiftTab: reactExports.useCallback(() => setIsTabbingBackOut(true), []),
      onFocusableItemAdd: reactExports.useCallback(
        () => setFocusableItemsCount((prevCount) => prevCount + 1),
        []
      ),
      onFocusableItemRemove: reactExports.useCallback(
        () => setFocusableItemsCount((prevCount) => prevCount - 1),
        []
      ),
      children: /* @__PURE__ */ jsxRuntimeExports.jsx(
        Primitive.div,
        {
          tabIndex: isTabbingBackOut || focusableItemsCount === 0 ? -1 : 0,
          "data-orientation": orientation,
          ...groupProps,
          ref: composedRefs,
          style: { outline: "none", ...props.style },
          onMouseDown: composeEventHandlers(props.onMouseDown, () => {
            isClickFocusRef.current = true;
          }),
          onFocus: composeEventHandlers(props.onFocus, (event) => {
            const isKeyboardFocus = !isClickFocusRef.current;
            if (event.target === event.currentTarget && isKeyboardFocus && !isTabbingBackOut) {
              const entryFocusEvent = new CustomEvent(ENTRY_FOCUS, EVENT_OPTIONS);
              event.currentTarget.dispatchEvent(entryFocusEvent);
              if (!entryFocusEvent.defaultPrevented) {
                const items = getItems().filter((item) => item.focusable);
                const activeItem = items.find((item) => item.active);
                const currentItem = items.find((item) => item.id === currentTabStopId);
                const candidateItems = [activeItem, currentItem, ...items].filter(
                  Boolean
                );
                const candidateNodes = candidateItems.map((item) => item.ref.current);
                focusFirst(candidateNodes, preventScrollOnEntryFocus);
              }
            }
            isClickFocusRef.current = false;
          }),
          onBlur: composeEventHandlers(props.onBlur, () => setIsTabbingBackOut(false))
        }
      )
    }
  );
});
var ITEM_NAME = "RovingFocusGroupItem";
var RovingFocusGroupItem = reactExports.forwardRef(
  (props, forwardedRef) => {
    const {
      __scopeRovingFocusGroup,
      focusable = true,
      active = false,
      tabStopId,
      ...itemProps
    } = props;
    const autoId = useId$1();
    const id2 = tabStopId || autoId;
    const context = useRovingFocusContext(ITEM_NAME, __scopeRovingFocusGroup);
    const isCurrentTabStop = context.currentTabStopId === id2;
    const getItems = useCollection$1(__scopeRovingFocusGroup);
    const { onFocusableItemAdd, onFocusableItemRemove } = context;
    reactExports.useEffect(() => {
      if (focusable) {
        onFocusableItemAdd();
        return () => onFocusableItemRemove();
      }
    }, [focusable, onFocusableItemAdd, onFocusableItemRemove]);
    return /* @__PURE__ */ jsxRuntimeExports.jsx(
      Collection$1.ItemSlot,
      {
        scope: __scopeRovingFocusGroup,
        id: id2,
        focusable,
        active,
        children: /* @__PURE__ */ jsxRuntimeExports.jsx(
          Primitive.span,
          {
            tabIndex: isCurrentTabStop ? 0 : -1,
            "data-orientation": context.orientation,
            ...itemProps,
            ref: forwardedRef,
            onMouseDown: composeEventHandlers(props.onMouseDown, (event) => {
              if (!focusable) event.preventDefault();
              else context.onItemFocus(id2);
            }),
            onFocus: composeEventHandlers(props.onFocus, () => context.onItemFocus(id2)),
            onKeyDown: composeEventHandlers(props.onKeyDown, (event) => {
              if (event.key === "Tab" && event.shiftKey) {
                context.onItemShiftTab();
                return;
              }
              if (event.target !== event.currentTarget) return;
              const focusIntent = getFocusIntent(event, context.orientation, context.dir);
              if (focusIntent !== void 0) {
                if (event.metaKey || event.ctrlKey || event.altKey || event.shiftKey) return;
                event.preventDefault();
                const items = getItems().filter((item) => item.focusable);
                let candidateNodes = items.map((item) => item.ref.current);
                if (focusIntent === "last") candidateNodes.reverse();
                else if (focusIntent === "prev" || focusIntent === "next") {
                  if (focusIntent === "prev") candidateNodes.reverse();
                  const currentIndex = candidateNodes.indexOf(event.currentTarget);
                  candidateNodes = context.loop ? wrapArray(candidateNodes, currentIndex + 1) : candidateNodes.slice(currentIndex + 1);
                }
                setTimeout(() => focusFirst(candidateNodes));
              }
            })
          }
        )
      }
    );
  }
);
RovingFocusGroupItem.displayName = ITEM_NAME;
var MAP_KEY_TO_FOCUS_INTENT = {
  ArrowLeft: "prev",
  ArrowUp: "prev",
  ArrowRight: "next",
  ArrowDown: "next",
  PageUp: "first",
  Home: "first",
  PageDown: "last",
  End: "last"
};
function getDirectionAwareKey(key2, dir) {
  if (dir !== "rtl") return key2;
  return key2 === "ArrowLeft" ? "ArrowRight" : key2 === "ArrowRight" ? "ArrowLeft" : key2;
}
function getFocusIntent(event, orientation, dir) {
  const key2 = getDirectionAwareKey(event.key, dir);
  if (orientation === "vertical" && ["ArrowLeft", "ArrowRight"].includes(key2)) return void 0;
  if (orientation === "horizontal" && ["ArrowUp", "ArrowDown"].includes(key2)) return void 0;
  return MAP_KEY_TO_FOCUS_INTENT[key2];
}
function focusFirst(candidates, preventScroll = false) {
  const PREVIOUSLY_FOCUSED_ELEMENT = document.activeElement;
  for (const candidate of candidates) {
    if (candidate === PREVIOUSLY_FOCUSED_ELEMENT) return;
    candidate.focus({ preventScroll });
    if (document.activeElement !== PREVIOUSLY_FOCUSED_ELEMENT) return;
  }
}
function wrapArray(array, startIndex) {
  return array.map((_2, index2) => array[(startIndex + index2) % array.length]);
}
var Root$1 = RovingFocusGroup;
var Item = RovingFocusGroupItem;
var TABS_NAME = "Tabs";
var [createTabsContext, createTabsScope] = createContextScope$3(TABS_NAME, [
  createRovingFocusGroupScope
]);
var useRovingFocusGroupScope = createRovingFocusGroupScope();
var [TabsProvider, useTabsContext] = createTabsContext(TABS_NAME);
var Tabs$1 = reactExports.forwardRef(
  (props, forwardedRef) => {
    const {
      __scopeTabs,
      value: valueProp,
      onValueChange,
      defaultValue,
      orientation = "horizontal",
      dir,
      activationMode = "automatic",
      ...tabsProps
    } = props;
    const direction = useDirection(dir);
    const [value, setValue2] = useControllableState({
      prop: valueProp,
      onChange: onValueChange,
      defaultProp: defaultValue
    });
    return /* @__PURE__ */ jsxRuntimeExports.jsx(
      TabsProvider,
      {
        scope: __scopeTabs,
        baseId: useId$1(),
        value,
        onValueChange: setValue2,
        orientation,
        dir: direction,
        activationMode,
        children: /* @__PURE__ */ jsxRuntimeExports.jsx(
          Primitive.div,
          {
            dir: direction,
            "data-orientation": orientation,
            ...tabsProps,
            ref: forwardedRef
          }
        )
      }
    );
  }
);
Tabs$1.displayName = TABS_NAME;
var TAB_LIST_NAME = "TabsList";
var TabsList$1 = reactExports.forwardRef(
  (props, forwardedRef) => {
    const { __scopeTabs, loop = true, ...listProps } = props;
    const context = useTabsContext(TAB_LIST_NAME, __scopeTabs);
    const rovingFocusGroupScope = useRovingFocusGroupScope(__scopeTabs);
    return /* @__PURE__ */ jsxRuntimeExports.jsx(
      Root$1,
      {
        asChild: true,
        ...rovingFocusGroupScope,
        orientation: context.orientation,
        dir: context.dir,
        loop,
        children: /* @__PURE__ */ jsxRuntimeExports.jsx(
          Primitive.div,
          {
            role: "tablist",
            "aria-orientation": context.orientation,
            ...listProps,
            ref: forwardedRef
          }
        )
      }
    );
  }
);
TabsList$1.displayName = TAB_LIST_NAME;
var TRIGGER_NAME = "TabsTrigger";
var TabsTrigger$1 = reactExports.forwardRef(
  (props, forwardedRef) => {
    const { __scopeTabs, value, disabled = false, ...triggerProps } = props;
    const context = useTabsContext(TRIGGER_NAME, __scopeTabs);
    const rovingFocusGroupScope = useRovingFocusGroupScope(__scopeTabs);
    const triggerId = makeTriggerId(context.baseId, value);
    const contentId = makeContentId(context.baseId, value);
    const isSelected = value === context.value;
    return /* @__PURE__ */ jsxRuntimeExports.jsx(
      Item,
      {
        asChild: true,
        ...rovingFocusGroupScope,
        focusable: !disabled,
        active: isSelected,
        children: /* @__PURE__ */ jsxRuntimeExports.jsx(
          Primitive.button,
          {
            type: "button",
            role: "tab",
            "aria-selected": isSelected,
            "aria-controls": contentId,
            "data-state": isSelected ? "active" : "inactive",
            "data-disabled": disabled ? "" : void 0,
            disabled,
            id: triggerId,
            ...triggerProps,
            ref: forwardedRef,
            onMouseDown: composeEventHandlers(props.onMouseDown, (event) => {
              if (!disabled && event.button === 0 && event.ctrlKey === false) {
                context.onValueChange(value);
              } else {
                event.preventDefault();
              }
            }),
            onKeyDown: composeEventHandlers(props.onKeyDown, (event) => {
              if ([" ", "Enter"].includes(event.key)) context.onValueChange(value);
            }),
            onFocus: composeEventHandlers(props.onFocus, () => {
              const isAutomaticActivation = context.activationMode !== "manual";
              if (!isSelected && !disabled && isAutomaticActivation) {
                context.onValueChange(value);
              }
            })
          }
        )
      }
    );
  }
);
TabsTrigger$1.displayName = TRIGGER_NAME;
var CONTENT_NAME = "TabsContent";
var TabsContent$1 = reactExports.forwardRef(
  (props, forwardedRef) => {
    const { __scopeTabs, value, forceMount, children, ...contentProps } = props;
    const context = useTabsContext(CONTENT_NAME, __scopeTabs);
    const triggerId = makeTriggerId(context.baseId, value);
    const contentId = makeContentId(context.baseId, value);
    const isSelected = value === context.value;
    const isMountAnimationPreventedRef = reactExports.useRef(isSelected);
    reactExports.useEffect(() => {
      const rAF = requestAnimationFrame(() => isMountAnimationPreventedRef.current = false);
      return () => cancelAnimationFrame(rAF);
    }, []);
    return /* @__PURE__ */ jsxRuntimeExports.jsx(Presence, { present: forceMount || isSelected, children: ({ present }) => /* @__PURE__ */ jsxRuntimeExports.jsx(
      Primitive.div,
      {
        "data-state": isSelected ? "active" : "inactive",
        "data-orientation": context.orientation,
        role: "tabpanel",
        "aria-labelledby": triggerId,
        hidden: !present,
        id: contentId,
        tabIndex: 0,
        ...contentProps,
        ref: forwardedRef,
        style: {
          ...props.style,
          animationDuration: isMountAnimationPreventedRef.current ? "0s" : void 0
        },
        children: present && children
      }
    ) });
  }
);
TabsContent$1.displayName = CONTENT_NAME;
function makeTriggerId(baseId, value) {
  return `${baseId}-trigger-${value}`;
}
function makeContentId(baseId, value) {
  return `${baseId}-content-${value}`;
}
var Root2 = Tabs$1;
var List = TabsList$1;
var Trigger = TabsTrigger$1;
var Content = TabsContent$1;
const Tabs = Root2;
const TabsList = reactExports.forwardRef(({ className, ...props }, ref) => /* @__PURE__ */ jsxRuntimeExports.jsx(
  List,
  {
    ref,
    className: cn(
      "inline-flex h-10 items-center justify-center rounded-md bg-muted p-1 text-muted-foreground",
      className
    ),
    ...props
  }
));
TabsList.displayName = List.displayName;
const TabsTrigger = reactExports.forwardRef(({ className, ...props }, ref) => /* @__PURE__ */ jsxRuntimeExports.jsx(
  Trigger,
  {
    ref,
    className: cn(
      "inline-flex items-center justify-center whitespace-nowrap rounded-sm px-3 py-1.5 text-sm font-medium ring-offset-background transition-all focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2 disabled:pointer-events-none disabled:opacity-50 data-[state=active]:bg-background data-[state=active]:text-foreground data-[state=active]:shadow-sm",
      className
    ),
    ...props
  }
));
TabsTrigger.displayName = Trigger.displayName;
const TabsContent = reactExports.forwardRef(({ className, ...props }, ref) => /* @__PURE__ */ jsxRuntimeExports.jsx(
  Content,
  {
    ref,
    className: cn(
      "mt-2 ring-offset-background focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2",
      className
    ),
    ...props
  }
));
TabsContent.displayName = Content.displayName;
const NotificationsCenter = ({ onNotificationClick }) => {
  const { language } = useLanguage$1();
  const t2 = language === "en" ? en.notifications : es.notifications;
  const { stats, markAllAsRead, markAsRead, refreshStats } = useNotifications();
  const [filter2, setFilter] = reactExports.useState({ type: "all" });
  const [notifications, setNotifications] = reactExports.useState([]);
  reactExports.useState(false);
  reactExports.useEffect(() => {
  }, []);
  const filteredNotifications = notifications.filter((notification) => {
    if (filter2.type === "unread") return !notification.is_read;
    if (filter2.type === "archived") return false;
    return true;
  });
  const formatTime = (dateString) => {
    const date = new Date(dateString);
    const now2 = /* @__PURE__ */ new Date();
    const diffInMinutes = Math.floor((now2.getTime() - date.getTime()) / (1e3 * 60));
    if (diffInMinutes < 1) return t2.time.now;
    if (diffInMinutes < 60) return t2.time.minutesAgo(diffInMinutes);
    const diffInHours = Math.floor(diffInMinutes / 60);
    if (diffInHours < 24) return t2.time.hoursAgo(diffInHours);
    const diffInDays = Math.floor(diffInHours / 24);
    if (diffInDays === 1) return t2.time.yesterday;
    if (diffInDays < 7) return t2.time.daysAgo(diffInDays);
    const diffInWeeks = Math.floor(diffInDays / 7);
    if (diffInWeeks < 4) return t2.time.weeksAgo(diffInWeeks);
    const diffInMonths = Math.floor(diffInDays / 30);
    return t2.time.monthsAgo(diffInMonths);
  };
  const handleNotificationClick = (notification) => {
    if (!notification.is_read) {
      setNotifications(
        (prev2) => prev2.map((n2) => n2.id === notification.id ? { ...n2, is_read: true } : n2)
      );
      markAsRead(notification.id);
    }
    if (onNotificationClick) {
      onNotificationClick(notification);
    }
  };
  const handleMarkAllAsRead = async () => {
    await markAllAsRead();
  };
  return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex flex-col h-full", children: [
    /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "flex items-center justify-between p-4 border-b border-border/30 flex-shrink-0", children: /* @__PURE__ */ jsxRuntimeExports.jsx(
      Button$1,
      {
        variant: "ghost",
        size: "sm",
        onClick: handleMarkAllAsRead,
        className: "text-blue-600 hover:text-blue-700 text-sm",
        children: t2.markAllAsRead
      }
    ) }),
    /* @__PURE__ */ jsxRuntimeExports.jsxs(Tabs, { value: filter2.type || "all", onValueChange: (value) => setFilter({ ...filter2, type: value }), className: "flex flex-col flex-1 min-h-0", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsxs(TabsList, { className: "grid w-full grid-cols-3 mx-4 mt-4 flex-shrink-0", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsxs(TabsTrigger, { value: "all", className: "flex items-center gap-2 text-sm", children: [
          t2.all,
          /* @__PURE__ */ jsxRuntimeExports.jsx(Badge, { variant: "secondary", className: "text-xs h-4 px-1", children: stats?.total || 0 })
        ] }),
        /* @__PURE__ */ jsxRuntimeExports.jsxs(TabsTrigger, { value: "unread", className: "flex items-center gap-2 text-sm", children: [
          t2.unread,
          /* @__PURE__ */ jsxRuntimeExports.jsx(Badge, { variant: "secondary", className: "text-xs h-4 px-1", children: stats?.unread || 0 })
        ] }),
        /* @__PURE__ */ jsxRuntimeExports.jsxs(TabsTrigger, { value: "archived", className: "flex items-center gap-2 text-sm", children: [
          t2.archive,
          /* @__PURE__ */ jsxRuntimeExports.jsx(Badge, { variant: "secondary", className: "text-xs h-4 px-1", children: stats?.archived || 0 })
        ] })
      ] }),
      /* @__PURE__ */ jsxRuntimeExports.jsx(TabsContent, { value: filter2.type || "all", className: "flex-1 overflow-hidden min-h-0 mt-4", children: /* @__PURE__ */ jsxRuntimeExports.jsx(ScrollArea, { className: "h-full px-4", children: filteredNotifications.length === 0 ? /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "flex items-center justify-center h-48 text-muted-foreground text-sm", children: filter2.type === "unread" ? t2.empty.unread : filter2.type === "archived" ? t2.empty.archive : t2.empty.all }) : /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "space-y-3 py-4", children: filteredNotifications.map((notification) => /* @__PURE__ */ jsxRuntimeExports.jsx(
        "div",
        {
          onClick: () => handleNotificationClick(notification),
          className: `p-4 rounded-lg cursor-pointer transition-colors hover:bg-accent/50 ${!notification.is_read ? "bg-accent/20" : ""}`,
          children: /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex items-start gap-3", children: [
            /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "relative flex-shrink-0", children: [
              /* @__PURE__ */ jsxRuntimeExports.jsxs(Avatar, { className: "w-10 h-10", children: [
                /* @__PURE__ */ jsxRuntimeExports.jsx(AvatarImage, { src: notification.actor_avatar }),
                /* @__PURE__ */ jsxRuntimeExports.jsx(AvatarFallback, { className: "text-sm", children: notification.actor_name.charAt(0) })
              ] }),
              !notification.is_read && /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "absolute -top-1 -right-1 w-3 h-3 bg-blue-600 rounded-full border-2 border-background" })
            ] }),
            /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex-1 min-w-0", children: [
              /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex items-start justify-between gap-2", children: [
                /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: "text-sm font-medium leading-relaxed", children: t2.messages[notification.type]?.(notification.actor_name, notification.metadata) || notification.message }),
                /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "text-xs text-muted-foreground flex-shrink-0", children: formatTime(notification.created_at) })
              ] }),
              notification.metadata?.file_name && /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex items-center gap-2 mt-2 p-2 bg-accent/30 rounded-md", children: [
                /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "p-1 bg-purple-100 rounded", children: /* @__PURE__ */ jsxRuntimeExports.jsx("svg", { className: "w-4 h-4 text-purple-600", fill: "currentColor", viewBox: "0 0 20 20", children: /* @__PURE__ */ jsxRuntimeExports.jsx("path", { d: "M4 4v12h12V8.414L12.414 4H4zm8 0l4 4h-4V4z" }) }) }),
                /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex-1 min-w-0", children: [
                  /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: "text-sm font-medium truncate", children: notification.metadata.file_name }),
                  /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: "text-xs text-muted-foreground", children: notification.metadata.file_size })
                ] })
              ] }),
              notification.type === "follow" && /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex gap-2 mt-2", children: [
                /* @__PURE__ */ jsxRuntimeExports.jsx(Button$1, { size: "sm", className: "bg-blue-600 hover:bg-blue-700 text-xs h-7", children: t2.actions.accept }),
                /* @__PURE__ */ jsxRuntimeExports.jsx(Button$1, { size: "sm", variant: "outline", className: "text-xs h-7", children: t2.actions.decline })
              ] })
            ] })
          ] })
        },
        notification.id
      )) }) }) })
    ] }),
    /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex items-center justify-between p-4 border-t border-border/30 flex-shrink-0", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx(Button$1, { variant: "ghost", size: "sm", className: "text-sm", children: t2.settings }),
      /* @__PURE__ */ jsxRuntimeExports.jsx(Button$1, { variant: "ghost", size: "sm", className: "text-sm", children: t2.archiveAll })
    ] })
  ] });
};
const ChatNotificationBox = ({
  unreadCount = 0,
  onNotificationClick
}) => {
  const [isOpen, setIsOpen] = reactExports.useState(false);
  const boxRef = reactExports.useRef(null);
  reactExports.useEffect(() => {
    const handleClickOutside = (event) => {
      if (boxRef.current && !boxRef.current.contains(event.target)) {
        setIsOpen(false);
      }
    };
    if (isOpen) {
      document.addEventListener("mousedown", handleClickOutside);
    }
    return () => {
      document.removeEventListener("mousedown", handleClickOutside);
    };
  }, [isOpen]);
  const handleNotificationClick = (notification) => {
    setIsOpen(false);
    if (onNotificationClick) {
      onNotificationClick(notification);
    }
  };
  return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "relative", ref: boxRef, children: [
    /* @__PURE__ */ jsxRuntimeExports.jsxs(
      Button$1,
      {
        variant: "ghost",
        size: "sm",
        onClick: () => setIsOpen(!isOpen),
        className: "relative p-2 hover:bg-white/10 rounded-lg transition-all duration-200",
        children: [
          /* @__PURE__ */ jsxRuntimeExports.jsxs(
            "svg",
            {
              xmlns: "http://www.w3.org/2000/svg",
              width: "24",
              height: "24",
              viewBox: "0 0 24 24",
              fill: "#fff",
              className: "w-6 h-6",
              children: [
                /* @__PURE__ */ jsxRuntimeExports.jsxs("g", { clipPath: "url(#clip0_4418_6964)", children: [
                  /* @__PURE__ */ jsxRuntimeExports.jsx("path", { d: "M12 22.81C11.31 22.81 10.66 22.46 10.2 21.85L8.7 19.85C8.67 19.81 8.55 19.76 8.5 19.75H8C3.83 19.75 1.25 18.62 1.25 13V8C1.25 3.58 3.58 1.25 8 1.25H16C20.42 1.25 22.75 3.58 22.75 8V13C22.75 17.42 20.42 19.75 16 19.75H15.5C15.42 19.75 15.35 19.79 15.3 19.85L13.8 21.85C13.34 22.46 12.69 22.81 12 22.81ZM8 2.75C4.42 2.75 2.75 4.42 2.75 8V13C2.75 17.52 4.3 18.25 8 18.25H8.5C9.01 18.25 9.59 18.54 9.9 18.95L11.4 20.95C11.75 21.41 12.25 21.41 12.6 20.95L14.1 18.95C14.43 18.51 14.95 18.25 15.5 18.25H16C19.58 18.25 21.25 16.58 21.25 13V8C21.25 4.42 19.58 2.75 16 2.75H8Z", fill: "white" }),
                  /* @__PURE__ */ jsxRuntimeExports.jsx("path", { d: "M17 8.75H7C6.59 8.75 6.25 8.41 6.25 8C6.25 7.59 6.59 7.25 7 7.25H17C17.41 7.25 17.75 7.59 17.75 8C17.75 8.41 17.41 8.75 17 8.75Z", fill: "white" }),
                  /* @__PURE__ */ jsxRuntimeExports.jsx("path", { d: "M13 13.75H7C6.59 13.75 6.25 13.41 6.25 13C6.25 12.59 6.59 12.25 7 12.25H13C13.41 12.25 13.75 12.59 13.75 13C13.75 13.41 13.41 13.75 13 13.75Z", fill: "white" })
                ] }),
                /* @__PURE__ */ jsxRuntimeExports.jsx("defs", { children: /* @__PURE__ */ jsxRuntimeExports.jsx("clipPath", { id: "clip0_4418_6964", children: /* @__PURE__ */ jsxRuntimeExports.jsx("rect", { width: "24", height: "24", fill: "white" }) }) })
              ]
            }
          ),
          unreadCount > 0 && /* @__PURE__ */ jsxRuntimeExports.jsx(
            Badge,
            {
              variant: "destructive",
              className: "absolute -top-1 -right-1 h-5 w-5 p-0 text-xs flex items-center justify-center rounded-full bg-[#f3533b] text-white border-2 border-white",
              children: unreadCount > 99 ? "99+" : unreadCount
            }
          )
        ]
      }
    ),
    /* @__PURE__ */ jsxRuntimeExports.jsx(AnimatePresence, { children: isOpen && /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx(
        motion.div,
        {
          initial: { opacity: 0 },
          animate: { opacity: 1 },
          exit: { opacity: 0 },
          className: "fixed inset-0 bg-black/20 z-[60]",
          onClick: () => setIsOpen(false)
        }
      ),
      /* @__PURE__ */ jsxRuntimeExports.jsxs(
        motion.div,
        {
          initial: { opacity: 0, scale: 0.95, y: -10 },
          animate: { opacity: 1, scale: 1, y: 0 },
          exit: { opacity: 0, scale: 0.95, y: -10 },
          transition: { duration: 0.2, ease: "easeOut" },
          className: "fixed top-2 right-2 bg-card/95 backdrop-blur-2xl border border-border/50 rounded-2xl shadow-2xl overflow-hidden flex flex-col w-[350px] max-w-[calc(100vw-16px)] max-h-[calc(100vh-120px)] min-h-[400px] z-[61]",
          children: [
            /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex items-center justify-between px-4 py-3 border-b border-border/30 flex-shrink-0", children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx("h3", { className: "text-lg font-semibold text-white", children: "Notifications" }),
              /* @__PURE__ */ jsxRuntimeExports.jsx(
                Button$1,
                {
                  variant: "ghost",
                  size: "sm",
                  onClick: () => setIsOpen(false),
                  className: "h-8 w-8 p-0 hover:bg-white/10 rounded-full transition-colors",
                  children: /* @__PURE__ */ jsxRuntimeExports.jsx(X, { className: "h-4 w-4 text-white/70" })
                }
              )
            ] }),
            /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "flex-1 overflow-hidden min-h-0", children: /* @__PURE__ */ jsxRuntimeExports.jsx(NotificationsCenter, { onNotificationClick: handleNotificationClick }) })
          ]
        }
      )
    ] }) })
  ] });
};
const Input = reactExports.forwardRef(
  ({ className, type, enableMobileFeatures, textType, ...props }, ref) => {
    const getMobileSettings = () => {
      if (enableMobileFeatures !== void 0) {
        return {
          autoCorrect: enableMobileFeatures ? "on" : "off",
          autoCapitalize: enableMobileFeatures ? "sentences" : "off",
          spellCheck: enableMobileFeatures
        };
      }
      const fieldType = textType || type;
      switch (fieldType) {
        case "email":
        case "password":
        case "username":
          return {
            autoCorrect: "off",
            autoCapitalize: "off",
            spellCheck: false
          };
        case "name":
          return {
            autoCorrect: "on",
            autoCapitalize: "words",
            spellCheck: true
          };
        case "search":
          return {
            autoCorrect: "on",
            autoCapitalize: "off",
            spellCheck: false
          };
        case "text":
        default:
          return {
            autoCorrect: "on",
            autoCapitalize: "sentences",
            spellCheck: true
          };
      }
    };
    const mobileSettings = getMobileSettings();
    return /* @__PURE__ */ jsxRuntimeExports.jsx(
      "input",
      {
        type,
        className: cn(
          "flex h-10 w-full rounded-md border border-input bg-background px-3 py-2 text-base ring-offset-background file:border-0 file:bg-transparent file:text-sm file:font-medium file:text-foreground placeholder:text-muted-foreground focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2 disabled:cursor-not-allowed disabled:opacity-50 md:text-sm",
          // Mobile optimizations for better performance
          "touch-manipulation",
          className
        ),
        ref,
        autoComplete: props.autoComplete || (type === "email" ? "email" : type === "password" ? "current-password" : "on"),
        autoCorrect: mobileSettings.autoCorrect,
        autoCapitalize: mobileSettings.autoCapitalize,
        spellCheck: mobileSettings.spellCheck,
        inputMode: type === "email" ? "email" : type === "tel" ? "tel" : type === "number" ? "numeric" : type === "search" ? "search" : "text",
        style: {
          // Улучшения для мобильного удаления текста
          WebkitUserSelect: "text",
          userSelect: "text",
          ...props.style
        },
        ...props
      }
    );
  }
);
Input.displayName = "Input";
const _UserService = class _UserService {
  static getInstance() {
    if (!_UserService.instance) {
      _UserService.instance = new _UserService();
    }
    return _UserService.instance;
  }
  /**
   * Поиск пользователей по запросу
   */
  async searchUsers(query, currentUserId, limit = 20) {
    if (query.trim().length < 2) {
      return [];
    }
    try {
      const { data, error } = await supabase.rpc("search_users", {
        p_search_term: query,
        p_current_user_id: currentUserId
      });
      if (error) {
        console.error("Error searching users:", error);
        return [];
      }
      return data || [];
    } catch (error) {
      console.error("Error searching users:", error);
      return [];
    }
  }
  /**
   * Отправка запроса на дружбу
   */
  async sendFriendRequest(userId, friendId) {
    try {
      console.log("Sending friend request:", { userId, friendId });
      const { data, error } = await supabase.rpc("send_friend_request", {
        p_sender_id: userId,
        p_receiver_id: friendId
      });
      console.log("Friend request response:", { data, error });
      if (error) {
        console.error("Error sending friend request:", error);
        return false;
      }
      return data === true;
    } catch (error) {
      console.error("Error sending friend request:", error);
      return false;
    }
  }
  /**
   * Принятие запроса на дружбу
   */
  async acceptFriendRequest(requestId, userId) {
    try {
      const { data, error } = await supabase.rpc("accept_friend_request", {
        p_request_id: requestId,
        p_user_id: userId
      });
      if (error) {
        console.error("Error accepting friend request:", error);
        return false;
      }
      return data === true;
    } catch (error) {
      console.error("Error accepting friend request:", error);
      return false;
    }
  }
  /**
   * Отклонение запроса на дружбу
   */
  async declineFriendRequest(requestId, userId) {
    try {
      const { data, error } = await supabase.rpc("decline_friend_request", {
        p_request_id: requestId,
        p_user_id: userId
      });
      if (error) {
        console.error("Error declining friend request:", error);
        return false;
      }
      return data === true;
    } catch (error) {
      console.error("Error declining friend request:", error);
      return false;
    }
  }
  /**
   * Отмена исходящего запроса на дружбу
   */
  async cancelFriendRequest(requestId, userId) {
    try {
      const { data, error } = await supabase.rpc("cancel_friend_request", {
        p_request_id: requestId,
        p_user_id: userId
      });
      if (error) {
        console.error("Error canceling friend request:", error);
        return false;
      }
      return data === true;
    } catch (error) {
      console.error("Error canceling friend request:", error);
      return false;
    }
  }
  /**
   * Удаление из друзей
   */
  async removeFriend(userId, friendId) {
    try {
      const { data, error } = await supabase.rpc("remove_friend", {
        p_user_id: userId,
        p_friend_id: friendId
      });
      if (error) {
        console.error("Error removing friend:", error);
        return false;
      }
      return data === true;
    } catch (error) {
      console.error("Error removing friend:", error);
      return false;
    }
  }
  /**
   * Блокировка пользователя
   */
  async blockUser(userId, blockedUserId) {
    try {
      const { data, error } = await supabase.rpc("block_user", {
        p_blocker_id: userId,
        p_blocked_id: blockedUserId
      });
      if (error) {
        console.error("Error blocking user:", error);
        return false;
      }
      return data === true;
    } catch (error) {
      console.error("Error blocking user:", error);
      return false;
    }
  }
  /**
   * Разблокировка пользователя
   */
  async unblockUser(userId, blockedUserId) {
    try {
      const { data, error } = await supabase.rpc("unblock_user", {
        p_blocker_id: userId,
        p_blocked_id: blockedUserId
      });
      if (error) {
        console.error("Error unblocking user:", error);
        return false;
      }
      return data === true;
    } catch (error) {
      console.error("Error unblocking user:", error);
      return false;
    }
  }
  /**
   * Получение списка друзей
   */
  async getFriends(userId, status = "accepted", limit = 50, offset2 = 0) {
    try {
      const { data, error } = await supabase.rpc("get_user_friends", {
        p_user_id: userId,
        p_status: status,
        p_limit: limit,
        p_offset: offset2
      });
      if (error) {
        console.error("Error getting friends:", error);
        return [];
      }
      const transformedData = (data || []).map((friend) => ({
        id: friend.id,
        user_id: userId,
        friend_id: friend.friend_id,
        status: friend.status,
        created_at: friend.created_at,
        updated_at: friend.created_at,
        friend_info: {
          id: friend.friend_id,
          username: friend.friend_username || "",
          full_name: friend.friend_full_name || "",
          avatar_url: friend.friend_avatar_url || "",
          email: friend.friend_email || "",
          is_online: friend.is_online || false,
          last_seen: friend.last_seen || ""
        }
      }));
      return transformedData;
    } catch (error) {
      console.error("Error getting friends:", error);
      return [];
    }
  }
  /**
   * Получение входящих запросов на дружбу
   */
  async getFriendRequests(userId, limit = 50, offset2 = 0) {
    try {
      const { data, error } = await supabase.rpc("get_friend_requests", {
        p_user_id: userId,
        p_limit: limit,
        p_offset: offset2
      });
      if (error) {
        console.error("Error getting friend requests:", error);
        return [];
      }
      const transformedData = (data || []).map((request) => ({
        id: request.id,
        requester_id: request.requester_id,
        addressee_id: userId,
        status: "pending",
        created_at: request.created_at,
        updated_at: request.created_at,
        request_type: request.request_type,
        requester_info: {
          id: request.requester_id,
          username: request.requester_username || "",
          full_name: request.requester_full_name || "",
          avatar_url: request.requester_avatar_url || "",
          email: request.requester_email || ""
        }
      }));
      return transformedData;
    } catch (error) {
      console.error("Error getting friend requests:", error);
      return [];
    }
  }
  /**
   * Получение статистики друзей
   */
  async getFriendsStats(userId) {
    try {
      const { data, error } = await supabase.rpc("get_friends_stats", {
        p_user_id: userId
      });
      if (error) {
        console.error("Error getting friends stats:", error);
        return {
          total_friends: 0,
          pending_requests: 0,
          sent_requests: 0,
          blocked_users: 0
        };
      }
      if (data && data.length > 0) {
        return {
          total_friends: data[0].total_friends || 0,
          pending_requests: data[0].pending_requests || 0,
          sent_requests: data[0].sent_requests || 0,
          blocked_users: data[0].blocked_users || 0
        };
      }
      return {
        total_friends: 0,
        pending_requests: 0,
        sent_requests: 0,
        blocked_users: 0
      };
    } catch (error) {
      console.error("Error getting friends stats:", error);
      return {
        total_friends: 0,
        pending_requests: 0,
        sent_requests: 0,
        blocked_users: 0
      };
    }
  }
  /**
   * Получение рекомендаций друзей
   */
  async getFriendSuggestions(userId, limit = 10) {
    try {
      const { data, error } = await supabase.rpc("get_friend_suggestions", {
        p_user_id: userId,
        p_limit: limit
      });
      if (error) {
        console.error("Error getting friend suggestions:", error);
        return [];
      }
      return data?.map((user) => ({
        id: user.id,
        username: user.username,
        full_name: user.full_name,
        avatar_url: user.avatar_url,
        email: "",
        is_friend: false,
        friendship_status: "none",
        mutual_friends_count: user.mutual_friends_count
      })) || [];
    } catch (error) {
      console.error("Error getting friend suggestions:", error);
      return [];
    }
  }
  /**
   * Получение взаимных друзей
   */
  async getMutualFriends(userId, otherUserId, limit = 10) {
    try {
      const { data, error } = await supabase.rpc("get_mutual_friends", {
        p_user_id: userId,
        p_other_user_id: otherUserId,
        p_limit: limit
      });
      if (error) {
        console.error("Error getting mutual friends:", error);
        return [];
      }
      return data || [];
    } catch (error) {
      console.error("Error getting mutual friends:", error);
      return [];
    }
  }
  /**
   * Обновление онлайн статуса пользователя
   */
  async updateOnlineStatus(userId, isOnline) {
    try {
      const { data, error } = await supabase.rpc("update_user_online_status", {
        p_user_id: userId,
        p_is_online: isOnline
      });
      if (error) {
        console.error("Error updating online status:", error);
        return false;
      }
      return data === true;
    } catch (error) {
      console.error("Error updating online status:", error);
      return false;
    }
  }
  /**
   * Получение информации о пользователе по ID
   */
  async getUserById(userId) {
    try {
      const { data, error } = await supabase.from("profiles").select("id, username, full_name, avatar_url, email, is_online, last_seen").eq("id", userId).single();
      if (error) {
        console.error("Error getting user by ID:", error);
        return null;
      }
      return {
        id: data.id,
        username: data.username || data.email,
        full_name: data.full_name,
        avatar_url: data.avatar_url,
        email: data.email,
        is_friend: false,
        friendship_status: "none",
        mutual_friends_count: 0
      };
    } catch (error) {
      console.error("Error getting user by ID:", error);
      return null;
    }
  }
  /**
   * Проверка доступности username
   */
  async checkUsernameAvailability(username) {
    try {
      const { data, error } = await supabase.rpc("check_username_availability", {
        input_username: username
      });
      if (error) {
        console.error("Error checking username availability:", error);
        return false;
      }
      return data === true;
    } catch (error) {
      console.error("Error checking username availability:", error);
      return false;
    }
  }
  /**
   * Обновление username пользователя
   */
  async updateUsername(userId, newUsername) {
    try {
      const { error } = await supabase.from("profiles").update({ username: newUsername }).eq("id", userId);
      if (error) {
        console.error("Error updating username:", error);
        return false;
      }
      return true;
    } catch (error) {
      console.error("Error updating username:", error);
      return false;
    }
  }
};
__publicField(_UserService, "instance");
let UserService = _UserService;
const UserMenu = ({ isOpen, onClose }) => {
  const navigate = useNavigate();
  const { user } = useAuth();
  const { language } = useLanguage$1();
  const t2 = language === "en" ? en.friends : es.friends;
  console.log("UserMenu render:", { isOpen, userId: user?.id });
  const [searchQuery, setSearchQuery] = reactExports.useState("");
  const [searchResults, setSearchResults] = reactExports.useState([]);
  const [isSearching, setIsSearching] = reactExports.useState(false);
  const [suggestions, setSuggestions] = reactExports.useState([]);
  const [friendRequests, setFriendRequests] = reactExports.useState([]);
  const [activeTab, setActiveTab] = reactExports.useState("search");
  const [selectedUserId, setSelectedUserId] = reactExports.useState(null);
  const [isProfileCardOpen, setIsProfileCardOpen] = reactExports.useState(false);
  const userService = UserService.getInstance();
  reactExports.useEffect(() => {
    console.log("UserMenu useEffect triggered:", { isOpen, userId: user?.id });
    if (isOpen && user?.id) {
      console.log("Loading friend data...");
      loadFriendSuggestions();
      loadFriendRequests();
    }
  }, [isOpen, user?.id]);
  reactExports.useEffect(() => {
    if (activeTab === "requests" && user?.id) {
      loadFriendRequests();
    }
  }, [activeTab, user?.id]);
  reactExports.useEffect(() => {
    if (user?.id) {
      loadFriendRequests();
      const interval = setInterval(() => {
        loadFriendRequests();
      }, 3e4);
      return () => clearInterval(interval);
    }
  }, [user?.id]);
  reactExports.useEffect(() => {
    const timeoutId = setTimeout(() => {
      if (searchQuery.trim().length >= 2) {
        searchUsers(searchQuery);
      } else {
        setSearchResults([]);
      }
    }, 300);
    return () => clearTimeout(timeoutId);
  }, [searchQuery, user?.id]);
  const loadFriendSuggestions = async () => {
    if (!user?.id) return;
    try {
      console.log("Loading friend suggestions...");
      const suggestions2 = await userService.getFriendSuggestions(user.id, 5);
      console.log("Friend suggestions loaded:", suggestions2);
      setSuggestions(suggestions2);
    } catch (error) {
      console.error("Error loading friend suggestions:", error);
    }
  };
  const loadFriendRequests = async () => {
    if (!user?.id) return;
    console.log("Loading friend requests for user:", user.id);
    try {
      const requests = await userService.getFriendRequests(user.id);
      console.log("Friend requests loaded:", requests);
      setFriendRequests(requests);
    } catch (error) {
      console.error("Error loading friend requests:", error);
    }
  };
  const searchUsers = async (query) => {
    if (!user?.id || query.trim().length < 2) {
      setSearchResults([]);
      return;
    }
    setIsSearching(true);
    try {
      const results = await userService.searchUsers(query, user.id, 20);
      setSearchResults(results);
    } catch (error) {
      console.error("Error searching users:", error);
      setSearchResults([]);
    } finally {
      setIsSearching(false);
    }
  };
  const handleSendFriendRequest = async (userId) => {
    if (!user?.id) return;
    console.log("Sending friend request from:", user.id, "to:", userId);
    try {
      const success = await userService.sendFriendRequest(user.id, userId);
      console.log("Friend request result:", success);
      if (success) {
        setSearchResults(
          (prev2) => prev2.map(
            (u2) => u2.id === userId ? { ...u2, friendship_status: "request_sent" } : u2
          )
        );
        setSuggestions((prev2) => prev2.filter((u2) => u2.id !== userId));
        loadFriendRequests();
      }
    } catch (error) {
      console.error("Error sending friend request:", error);
    }
  };
  const handleAcceptFriendRequest = async (requestId) => {
    if (!user?.id) return;
    try {
      const success = await userService.acceptFriendRequest(requestId, user.id);
      if (success) {
        const request = friendRequests.find((r2) => r2.id === requestId);
        if (request) {
          setSearchResults(
            (prev2) => prev2.map(
              (u2) => u2.id === request.requester_id ? { ...u2, friendship_status: "friends" } : u2
            )
          );
          setSuggestions((prev2) => prev2.filter((u2) => u2.id !== request.requester_id));
        }
        loadFriendRequests();
      }
    } catch (error) {
      console.error("Error accepting friend request:", error);
    }
  };
  const handleDeclineFriendRequest = async (requestId) => {
    if (!user?.id) return;
    try {
      const success = await userService.declineFriendRequest(requestId, user.id);
      if (success) {
        const request = friendRequests.find((r2) => r2.id === requestId);
        if (request) {
          setSearchResults(
            (prev2) => prev2.map(
              (u2) => u2.id === request.requester_id ? { ...u2, friendship_status: "none" } : u2
            )
          );
          setSuggestions((prev2) => prev2.filter((u2) => u2.id !== request.requester_id));
        }
        loadFriendRequests();
      }
    } catch (error) {
      console.error("Error declining friend request:", error);
    }
  };
  const handleCancelFriendRequest = async (requestId) => {
    if (!user?.id) return;
    try {
      const success = await userService.cancelFriendRequest(requestId, user.id);
      if (success) {
        const request = friendRequests.find((r2) => r2.id === requestId);
        if (request) {
          setSearchResults(
            (prev2) => prev2.map(
              (u2) => u2.id === request.addressee_id ? { ...u2, friendship_status: "none" } : u2
            )
          );
          setSuggestions((prev2) => prev2.filter((u2) => u2.id !== request.addressee_id));
        }
        loadFriendRequests();
      }
    } catch (error) {
      console.error("Error canceling friend request:", error);
    }
  };
  const handleRemoveFriend = async (userId) => {
    if (!user?.id) return;
    try {
      const success = await userService.removeFriend(user.id, userId);
      if (success) {
        setSearchResults(
          (prev2) => prev2.map(
            (u2) => u2.id === userId ? { ...u2, friendship_status: "none" } : u2
          )
        );
      }
    } catch (error) {
      console.error("Error removing friend:", error);
    }
  };
  const handleSendMessage = async (userId) => {
    console.log("Send message to:", userId);
  };
  const handleViewProfile = (userId) => {
    setSelectedUserId(userId);
    setIsProfileCardOpen(true);
  };
  const getUserActionButton = (user2) => {
    if (user2.friendship_status === "friends") {
      return /* @__PURE__ */ jsxRuntimeExports.jsxs(
        Button$1,
        {
          variant: "outline",
          size: "sm",
          onClick: () => handleRemoveFriend(user2.id),
          className: "text-red-600 hover:text-red-700 hover:bg-red-50",
          children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx(UserMinus, { className: "h-4 w-4 mr-1" }),
            t2.removeFriend
          ]
        }
      );
    }
    if (user2.friendship_status === "request_sent") {
      return /* @__PURE__ */ jsxRuntimeExports.jsxs(
        Button$1,
        {
          variant: "outline",
          size: "sm",
          disabled: true,
          className: "text-gray-500",
          children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx(Clock$1, { className: "h-4 w-4 mr-1" }),
            t2.requestSent
          ]
        }
      );
    }
    if (user2.friendship_status === "request_received") {
      return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex gap-2", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsxs(
          Button$1,
          {
            variant: "outline",
            size: "sm",
            onClick: () => handleAcceptFriendRequest(user2.id),
            className: "text-green-600 hover:text-green-700 hover:bg-green-50",
            children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx(UserCheck, { className: "h-4 w-4 mr-1" }),
              t2.accept
            ]
          }
        ),
        /* @__PURE__ */ jsxRuntimeExports.jsxs(
          Button$1,
          {
            variant: "outline",
            size: "sm",
            onClick: () => handleDeclineFriendRequest(user2.id),
            className: "text-red-600 hover:text-red-700 hover:bg-red-50",
            children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx(UserX, { className: "h-4 w-4 mr-1" }),
              t2.decline
            ]
          }
        )
      ] });
    }
    if (user2.friendship_status === "blocked") {
      return /* @__PURE__ */ jsxRuntimeExports.jsxs(
        Button$1,
        {
          variant: "outline",
          size: "sm",
          disabled: true,
          className: "text-gray-500",
          children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx(Shield, { className: "h-4 w-4 mr-1" }),
            t2.blocked
          ]
        }
      );
    }
    return /* @__PURE__ */ jsxRuntimeExports.jsxs(
      Button$1,
      {
        variant: "outline",
        size: "sm",
        onClick: () => handleSendFriendRequest(user2.id),
        className: "text-blue-600 hover:text-blue-700 hover:bg-blue-50",
        children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx(UserPlus, { className: "h-4 w-4 mr-1" }),
          t2.addFriend
        ]
      }
    );
  };
  if (!user) {
    console.log("UserMenu: No user, not rendering");
    return null;
  }
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
    /* @__PURE__ */ jsxRuntimeExports.jsx(AnimatePresence, { children: isOpen && /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx(
        motion.div,
        {
          initial: { opacity: 0 },
          animate: { opacity: 1 },
          exit: { opacity: 0 },
          className: "fixed inset-0 bg-black/20 z-40",
          onClick: (e2) => {
            console.log("Overlay clicked, closing menu");
            setTimeout(() => {
              onClose();
            }, 100);
          }
        }
      ),
      /* @__PURE__ */ jsxRuntimeExports.jsxs(
        motion.div,
        {
          initial: { opacity: 0, scale: 0.95, y: -10 },
          animate: { opacity: 1, scale: 1, y: 0 },
          exit: { opacity: 0, scale: 0.95, y: -10 },
          transition: { duration: 0.2, ease: "easeOut" },
          className: "fixed top-1 right-1 bg-card/95 backdrop-blur-xl border border-border/40 rounded-2xl shadow-2xl overflow-hidden flex flex-col w-[320px] h-[600px] z-50",
          children: [
            /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex items-center justify-between p-4 border-b border-border/30 flex-shrink-0", children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx("h3", { className: "text-lg font-semibold text-white", children: t2.title }),
              /* @__PURE__ */ jsxRuntimeExports.jsx(
                Button$1,
                {
                  variant: "ghost",
                  size: "sm",
                  onClick: onClose,
                  className: "h-8 w-8 p-0 hover:bg-white/10 rounded-full transition-colors",
                  children: /* @__PURE__ */ jsxRuntimeExports.jsx(X, { className: "h-4 w-4 text-white/70" })
                }
              )
            ] }),
            /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex border-b border-border/30", children: [
              /* @__PURE__ */ jsxRuntimeExports.jsxs(
                Button$1,
                {
                  variant: activeTab === "search" ? "default" : "ghost",
                  size: "sm",
                  onClick: () => setActiveTab("search"),
                  className: "flex-1 rounded-none border-none",
                  children: [
                    /* @__PURE__ */ jsxRuntimeExports.jsx(Search, { className: "h-4 w-4 mr-2" }),
                    t2.search
                  ]
                }
              ),
              /* @__PURE__ */ jsxRuntimeExports.jsxs(
                Button$1,
                {
                  variant: activeTab === "requests" ? "default" : "ghost",
                  size: "sm",
                  onClick: () => setActiveTab("requests"),
                  className: "flex-1 rounded-none border-none relative",
                  children: [
                    /* @__PURE__ */ jsxRuntimeExports.jsx(Users, { className: "h-4 w-4 mr-2" }),
                    t2.requests,
                    friendRequests.length > 0 && /* @__PURE__ */ jsxRuntimeExports.jsx(Badge, { className: "absolute top-1 right-1 h-4 w-4 p-0 flex items-center justify-center text-xs", children: friendRequests.length })
                  ]
                }
              )
            ] }),
            activeTab === "search" && /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "p-4 border-b border-border/30 flex-shrink-0", children: /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "relative", children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx(Search, { className: "absolute left-3 top-1/2 transform -translate-y-1/2 text-muted-foreground w-4 h-4" }),
              /* @__PURE__ */ jsxRuntimeExports.jsx(
                Input,
                {
                  placeholder: t2.searchUsers,
                  value: searchQuery,
                  onChange: (e2) => setSearchQuery(e2.target.value),
                  className: "pl-10"
                }
              ),
              isSearching && /* @__PURE__ */ jsxRuntimeExports.jsx(LoaderCircle, { className: "absolute right-3 top-1/2 transform -translate-y-1/2 text-muted-foreground w-4 h-4 animate-spin" })
            ] }) }),
            /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "p-4 border-b border-border/30 flex-shrink-0", children: /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "grid grid-cols-2 gap-3", children: [
              /* @__PURE__ */ jsxRuntimeExports.jsxs(
                Button$1,
                {
                  variant: "outline",
                  size: "sm",
                  onClick: () => {
                    navigate("/friends");
                    onClose();
                  },
                  className: "flex items-center gap-2",
                  children: [
                    /* @__PURE__ */ jsxRuntimeExports.jsx(Users, { className: "w-4 h-4" }),
                    t2.allFriends
                  ]
                }
              ),
              /* @__PURE__ */ jsxRuntimeExports.jsxs(
                Button$1,
                {
                  variant: "outline",
                  size: "sm",
                  onClick: () => {
                    navigate("/profile");
                    onClose();
                  },
                  className: "flex items-center gap-2",
                  children: [
                    /* @__PURE__ */ jsxRuntimeExports.jsx(Settings, { className: "w-4 h-4" }),
                    "Settings"
                  ]
                }
              )
            ] }) }),
            /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "flex-1 overflow-hidden min-h-0", children: /* @__PURE__ */ jsxRuntimeExports.jsx(ScrollArea, { className: "h-full px-4", children: activeTab === "search" ? /* @__PURE__ */ jsxRuntimeExports.jsx(jsxRuntimeExports.Fragment, { children: isSearching ? /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "flex items-center justify-center h-32 text-muted-foreground", children: /* @__PURE__ */ jsxRuntimeExports.jsx(LoaderCircle, { className: "w-6 h-6 animate-spin" }) }) : searchQuery.trim().length >= 2 ? searchResults.length === 0 ? /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "flex items-center justify-center h-32 text-muted-foreground text-sm", children: t2.noSearchResults }) : /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "space-y-3 py-4", children: searchResults.map((user2) => /* @__PURE__ */ jsxRuntimeExports.jsxs(
              "div",
              {
                className: "flex items-center justify-between p-3 rounded-lg hover:bg-accent/50 transition-colors",
                children: [
                  /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex items-center gap-3", children: [
                    /* @__PURE__ */ jsxRuntimeExports.jsxs(
                      Avatar,
                      {
                        className: "w-10 h-10 cursor-pointer hover:ring-2 hover:ring-blue-400 transition-all",
                        onClick: () => handleViewProfile(user2.id),
                        children: [
                          /* @__PURE__ */ jsxRuntimeExports.jsx(AvatarImage, { src: user2.avatar_url }),
                          /* @__PURE__ */ jsxRuntimeExports.jsx(AvatarFallback, { children: user2.username?.charAt(0).toUpperCase() || "U" })
                        ]
                      }
                    ),
                    /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex-1", children: [
                      /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "flex items-center gap-2", children: /* @__PURE__ */ jsxRuntimeExports.jsx(
                        "h3",
                        {
                          className: "font-medium text-sm cursor-pointer hover:text-blue-400 transition-colors",
                          onClick: () => handleViewProfile(user2.id),
                          children: user2.full_name || user2.username
                        }
                      ) }),
                      /* @__PURE__ */ jsxRuntimeExports.jsxs(
                        "p",
                        {
                          className: "text-xs text-muted-foreground cursor-pointer hover:text-blue-400 transition-colors",
                          onClick: () => handleViewProfile(user2.id),
                          children: [
                            "@",
                            user2.username
                          ]
                        }
                      ),
                      user2.mutual_friends_count > 0 && /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: "text-xs text-muted-foreground", children: t2.mutualFriends(user2.mutual_friends_count) })
                    ] })
                  ] }),
                  /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "flex-shrink-0", children: user2.friendship_status === "friends" ? /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex gap-2", children: [
                    /* @__PURE__ */ jsxRuntimeExports.jsxs(
                      Button$1,
                      {
                        variant: "outline",
                        size: "sm",
                        onClick: () => handleSendMessage(user2.id),
                        className: "text-blue-600 hover:text-blue-700 hover:bg-blue-50",
                        children: [
                          /* @__PURE__ */ jsxRuntimeExports.jsx(MessageCircle, { className: "h-4 w-4 mr-1" }),
                          t2.sendMessage
                        ]
                      }
                    ),
                    /* @__PURE__ */ jsxRuntimeExports.jsxs(
                      Button$1,
                      {
                        variant: "outline",
                        size: "sm",
                        onClick: () => handleViewProfile(user2.id),
                        className: "text-gray-600 hover:text-gray-700 hover:bg-gray-50",
                        children: [
                          /* @__PURE__ */ jsxRuntimeExports.jsx(Eye, { className: "h-4 w-4 mr-1" }),
                          t2.viewProfile
                        ]
                      }
                    )
                  ] }) : getUserActionButton(user2) })
                ]
              },
              user2.id
            )) }) : /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "flex items-center justify-center h-32 text-muted-foreground text-sm", children: "Search for friends by username" }) }) : /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "py-4", children: friendRequests.length === 0 ? /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex flex-col items-center justify-center h-32 text-muted-foreground text-sm", children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx(Users, { className: "w-12 h-12 mx-auto mb-4 opacity-50" }),
              /* @__PURE__ */ jsxRuntimeExports.jsx("p", { children: "No friend requests" })
            ] }) : /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "space-y-3", children: friendRequests.map((request) => /* @__PURE__ */ jsxRuntimeExports.jsxs(
              "div",
              {
                className: "flex items-center justify-between p-3 rounded-lg hover:bg-accent/50 transition-colors",
                children: [
                  /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex items-center gap-3 flex-1 overflow-hidden", children: [
                    /* @__PURE__ */ jsxRuntimeExports.jsxs(
                      Avatar,
                      {
                        className: "w-9 h-9 cursor-pointer hover:ring-2 hover:ring-blue-400 transition-all flex-shrink-0",
                        onClick: () => handleViewProfile(request.requester_id),
                        children: [
                          /* @__PURE__ */ jsxRuntimeExports.jsx(AvatarImage, { src: request.requester_info?.avatar_url }),
                          /* @__PURE__ */ jsxRuntimeExports.jsx(AvatarFallback, { children: (request.requester_info?.full_name?.charAt(0) || request.requester_info?.username?.charAt(0))?.toUpperCase() || "U" })
                        ]
                      }
                    ),
                    /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex-1 min-w-0 space-y-0.5", children: [
                      /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex items-center gap-1.5", children: [
                        /* @__PURE__ */ jsxRuntimeExports.jsx(
                          "h3",
                          {
                            className: "font-medium text-sm cursor-pointer hover:text-blue-400 transition-colors truncate",
                            onClick: () => handleViewProfile(request.requester_id),
                            style: { maxWidth: "120px" },
                            children: request.requester_info?.full_name || request.requester_info?.username || "Unknown User"
                          }
                        ),
                        /* @__PURE__ */ jsxRuntimeExports.jsx(
                          Badge,
                          {
                            variant: "outline",
                            className: `text-[10px] px-1.5 py-0 flex-shrink-0 ${request.request_type === "incoming" ? "text-blue-600 border-blue-200" : "text-orange-600 border-orange-200"}`,
                            children: request.request_type === "incoming" ? "Incoming" : "Sent"
                          }
                        )
                      ] }),
                      /* @__PURE__ */ jsxRuntimeExports.jsxs(
                        "p",
                        {
                          className: "text-[11px] text-muted-foreground cursor-pointer hover:text-blue-400 transition-colors truncate",
                          onClick: () => handleViewProfile(request.requester_id),
                          children: [
                            "@",
                            request.requester_info?.username || "unknown"
                          ]
                        }
                      )
                    ] })
                  ] }),
                  /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "flex gap-1.5 flex-shrink-0 ml-1", children: request.request_type === "incoming" ? /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
                    /* @__PURE__ */ jsxRuntimeExports.jsxs(
                      Button$1,
                      {
                        variant: "outline",
                        size: "sm",
                        onClick: () => handleAcceptFriendRequest(request.id),
                        className: "text-green-600 hover:text-green-700 hover:bg-green-50 text-xs px-2 py-1 h-7",
                        children: [
                          /* @__PURE__ */ jsxRuntimeExports.jsx(UserCheck, { className: "h-3 w-3 mr-0.5" }),
                          t2.accept
                        ]
                      }
                    ),
                    /* @__PURE__ */ jsxRuntimeExports.jsxs(
                      Button$1,
                      {
                        variant: "outline",
                        size: "sm",
                        onClick: () => handleDeclineFriendRequest(request.id),
                        className: "text-red-600 hover:text-red-700 hover:bg-red-50 text-xs px-2 py-1 h-7",
                        children: [
                          /* @__PURE__ */ jsxRuntimeExports.jsx(UserX, { className: "h-3 w-3 mr-0.5" }),
                          t2.decline
                        ]
                      }
                    )
                  ] }) : /* @__PURE__ */ jsxRuntimeExports.jsxs(
                    Button$1,
                    {
                      variant: "outline",
                      size: "sm",
                      onClick: () => handleCancelFriendRequest(request.id),
                      className: "text-gray-600 hover:text-gray-700 hover:bg-gray-50 text-xs px-2 py-1 h-7",
                      children: [
                        /* @__PURE__ */ jsxRuntimeExports.jsx(X, { className: "h-3 w-3 mr-0.5" }),
                        t2.cancel
                      ]
                    }
                  ) })
                ]
              },
              request.id
            )) }) }) }) })
          ]
        }
      )
    ] }) }),
    selectedUserId && /* @__PURE__ */ jsxRuntimeExports.jsx(
      UserProfileCard,
      {
        userId: selectedUserId,
        isOpen: isProfileCardOpen,
        onClose: () => {
          setIsProfileCardOpen(false);
          setSelectedUserId(null);
        }
      }
    )
  ] });
};
function usePrevious(value) {
  const ref = reactExports.useRef({ value, previous: value });
  return reactExports.useMemo(() => {
    if (ref.current.value !== value) {
      ref.current.previous = ref.current.value;
      ref.current.value = value;
    }
    return ref.current.previous;
  }, [value]);
}
var PAGE_KEYS = ["PageUp", "PageDown"];
var ARROW_KEYS = ["ArrowUp", "ArrowDown", "ArrowLeft", "ArrowRight"];
var BACK_KEYS = {
  "from-left": ["Home", "PageDown", "ArrowDown", "ArrowLeft"],
  "from-right": ["Home", "PageDown", "ArrowDown", "ArrowRight"],
  "from-bottom": ["Home", "PageDown", "ArrowDown", "ArrowLeft"],
  "from-top": ["Home", "PageDown", "ArrowUp", "ArrowLeft"]
};
var SLIDER_NAME = "Slider";
var [Collection, useCollection, createCollectionScope] = createCollection(SLIDER_NAME);
var [createSliderContext, createSliderScope] = createContextScope$3(SLIDER_NAME, [
  createCollectionScope
]);
var [SliderProvider, useSliderContext] = createSliderContext(SLIDER_NAME);
var Slider$1 = reactExports.forwardRef(
  (props, forwardedRef) => {
    const {
      name,
      min: min2 = 0,
      max: max2 = 100,
      step = 1,
      orientation = "horizontal",
      disabled = false,
      minStepsBetweenThumbs = 0,
      defaultValue = [min2],
      value,
      onValueChange = () => {
      },
      onValueCommit = () => {
      },
      inverted = false,
      form,
      ...sliderProps
    } = props;
    const thumbRefs = reactExports.useRef(/* @__PURE__ */ new Set());
    const valueIndexToChangeRef = reactExports.useRef(0);
    const isHorizontal = orientation === "horizontal";
    const SliderOrientation = isHorizontal ? SliderHorizontal : SliderVertical;
    const [values2 = [], setValues] = useControllableState({
      prop: value,
      defaultProp: defaultValue,
      onChange: (value2) => {
        const thumbs = [...thumbRefs.current];
        thumbs[valueIndexToChangeRef.current]?.focus();
        onValueChange(value2);
      }
    });
    const valuesBeforeSlideStartRef = reactExports.useRef(values2);
    function handleSlideStart(value2) {
      const closestIndex = getClosestValueIndex(values2, value2);
      updateValues(value2, closestIndex);
    }
    function handleSlideMove(value2) {
      updateValues(value2, valueIndexToChangeRef.current);
    }
    function handleSlideEnd() {
      const prevValue = valuesBeforeSlideStartRef.current[valueIndexToChangeRef.current];
      const nextValue = values2[valueIndexToChangeRef.current];
      const hasChanged = nextValue !== prevValue;
      if (hasChanged) onValueCommit(values2);
    }
    function updateValues(value2, atIndex, { commit } = { commit: false }) {
      const decimalCount = getDecimalCount(step);
      const snapToStep = roundValue(Math.round((value2 - min2) / step) * step + min2, decimalCount);
      const nextValue = clamp$2(snapToStep, [min2, max2]);
      setValues((prevValues = []) => {
        const nextValues = getNextSortedValues(prevValues, nextValue, atIndex);
        if (hasMinStepsBetweenValues(nextValues, minStepsBetweenThumbs * step)) {
          valueIndexToChangeRef.current = nextValues.indexOf(nextValue);
          const hasChanged = String(nextValues) !== String(prevValues);
          if (hasChanged && commit) onValueCommit(nextValues);
          return hasChanged ? nextValues : prevValues;
        } else {
          return prevValues;
        }
      });
    }
    return /* @__PURE__ */ jsxRuntimeExports.jsx(
      SliderProvider,
      {
        scope: props.__scopeSlider,
        name,
        disabled,
        min: min2,
        max: max2,
        valueIndexToChangeRef,
        thumbs: thumbRefs.current,
        values: values2,
        orientation,
        form,
        children: /* @__PURE__ */ jsxRuntimeExports.jsx(Collection.Provider, { scope: props.__scopeSlider, children: /* @__PURE__ */ jsxRuntimeExports.jsx(Collection.Slot, { scope: props.__scopeSlider, children: /* @__PURE__ */ jsxRuntimeExports.jsx(
          SliderOrientation,
          {
            "aria-disabled": disabled,
            "data-disabled": disabled ? "" : void 0,
            ...sliderProps,
            ref: forwardedRef,
            onPointerDown: composeEventHandlers(sliderProps.onPointerDown, () => {
              if (!disabled) valuesBeforeSlideStartRef.current = values2;
            }),
            min: min2,
            max: max2,
            inverted,
            onSlideStart: disabled ? void 0 : handleSlideStart,
            onSlideMove: disabled ? void 0 : handleSlideMove,
            onSlideEnd: disabled ? void 0 : handleSlideEnd,
            onHomeKeyDown: () => !disabled && updateValues(min2, 0, { commit: true }),
            onEndKeyDown: () => !disabled && updateValues(max2, values2.length - 1, { commit: true }),
            onStepKeyDown: ({ event, direction: stepDirection }) => {
              if (!disabled) {
                const isPageKey = PAGE_KEYS.includes(event.key);
                const isSkipKey = isPageKey || event.shiftKey && ARROW_KEYS.includes(event.key);
                const multiplier = isSkipKey ? 10 : 1;
                const atIndex = valueIndexToChangeRef.current;
                const value2 = values2[atIndex];
                const stepInDirection = step * multiplier * stepDirection;
                updateValues(value2 + stepInDirection, atIndex, { commit: true });
              }
            }
          }
        ) }) })
      }
    );
  }
);
Slider$1.displayName = SLIDER_NAME;
var [SliderOrientationProvider, useSliderOrientationContext] = createSliderContext(SLIDER_NAME, {
  startEdge: "left",
  endEdge: "right",
  size: "width",
  direction: 1
});
var SliderHorizontal = reactExports.forwardRef(
  (props, forwardedRef) => {
    const {
      min: min2,
      max: max2,
      dir,
      inverted,
      onSlideStart,
      onSlideMove,
      onSlideEnd,
      onStepKeyDown,
      ...sliderProps
    } = props;
    const [slider, setSlider] = reactExports.useState(null);
    const composedRefs = useComposedRefs(forwardedRef, (node2) => setSlider(node2));
    const rectRef = reactExports.useRef();
    const direction = useDirection(dir);
    const isDirectionLTR = direction === "ltr";
    const isSlidingFromLeft = isDirectionLTR && !inverted || !isDirectionLTR && inverted;
    function getValueFromPointer(pointerPosition) {
      const rect = rectRef.current || slider.getBoundingClientRect();
      const input = [0, rect.width];
      const output = isSlidingFromLeft ? [min2, max2] : [max2, min2];
      const value = linearScale(input, output);
      rectRef.current = rect;
      return value(pointerPosition - rect.left);
    }
    return /* @__PURE__ */ jsxRuntimeExports.jsx(
      SliderOrientationProvider,
      {
        scope: props.__scopeSlider,
        startEdge: isSlidingFromLeft ? "left" : "right",
        endEdge: isSlidingFromLeft ? "right" : "left",
        direction: isSlidingFromLeft ? 1 : -1,
        size: "width",
        children: /* @__PURE__ */ jsxRuntimeExports.jsx(
          SliderImpl,
          {
            dir: direction,
            "data-orientation": "horizontal",
            ...sliderProps,
            ref: composedRefs,
            style: {
              ...sliderProps.style,
              ["--radix-slider-thumb-transform"]: "translateX(-50%)"
            },
            onSlideStart: (event) => {
              const value = getValueFromPointer(event.clientX);
              onSlideStart?.(value);
            },
            onSlideMove: (event) => {
              const value = getValueFromPointer(event.clientX);
              onSlideMove?.(value);
            },
            onSlideEnd: () => {
              rectRef.current = void 0;
              onSlideEnd?.();
            },
            onStepKeyDown: (event) => {
              const slideDirection = isSlidingFromLeft ? "from-left" : "from-right";
              const isBackKey = BACK_KEYS[slideDirection].includes(event.key);
              onStepKeyDown?.({ event, direction: isBackKey ? -1 : 1 });
            }
          }
        )
      }
    );
  }
);
var SliderVertical = reactExports.forwardRef(
  (props, forwardedRef) => {
    const {
      min: min2,
      max: max2,
      inverted,
      onSlideStart,
      onSlideMove,
      onSlideEnd,
      onStepKeyDown,
      ...sliderProps
    } = props;
    const sliderRef = reactExports.useRef(null);
    const ref = useComposedRefs(forwardedRef, sliderRef);
    const rectRef = reactExports.useRef();
    const isSlidingFromBottom = !inverted;
    function getValueFromPointer(pointerPosition) {
      const rect = rectRef.current || sliderRef.current.getBoundingClientRect();
      const input = [0, rect.height];
      const output = isSlidingFromBottom ? [max2, min2] : [min2, max2];
      const value = linearScale(input, output);
      rectRef.current = rect;
      return value(pointerPosition - rect.top);
    }
    return /* @__PURE__ */ jsxRuntimeExports.jsx(
      SliderOrientationProvider,
      {
        scope: props.__scopeSlider,
        startEdge: isSlidingFromBottom ? "bottom" : "top",
        endEdge: isSlidingFromBottom ? "top" : "bottom",
        size: "height",
        direction: isSlidingFromBottom ? 1 : -1,
        children: /* @__PURE__ */ jsxRuntimeExports.jsx(
          SliderImpl,
          {
            "data-orientation": "vertical",
            ...sliderProps,
            ref,
            style: {
              ...sliderProps.style,
              ["--radix-slider-thumb-transform"]: "translateY(50%)"
            },
            onSlideStart: (event) => {
              const value = getValueFromPointer(event.clientY);
              onSlideStart?.(value);
            },
            onSlideMove: (event) => {
              const value = getValueFromPointer(event.clientY);
              onSlideMove?.(value);
            },
            onSlideEnd: () => {
              rectRef.current = void 0;
              onSlideEnd?.();
            },
            onStepKeyDown: (event) => {
              const slideDirection = isSlidingFromBottom ? "from-bottom" : "from-top";
              const isBackKey = BACK_KEYS[slideDirection].includes(event.key);
              onStepKeyDown?.({ event, direction: isBackKey ? -1 : 1 });
            }
          }
        )
      }
    );
  }
);
var SliderImpl = reactExports.forwardRef(
  (props, forwardedRef) => {
    const {
      __scopeSlider,
      onSlideStart,
      onSlideMove,
      onSlideEnd,
      onHomeKeyDown,
      onEndKeyDown,
      onStepKeyDown,
      ...sliderProps
    } = props;
    const context = useSliderContext(SLIDER_NAME, __scopeSlider);
    return /* @__PURE__ */ jsxRuntimeExports.jsx(
      Primitive.span,
      {
        ...sliderProps,
        ref: forwardedRef,
        onKeyDown: composeEventHandlers(props.onKeyDown, (event) => {
          if (event.key === "Home") {
            onHomeKeyDown(event);
            event.preventDefault();
          } else if (event.key === "End") {
            onEndKeyDown(event);
            event.preventDefault();
          } else if (PAGE_KEYS.concat(ARROW_KEYS).includes(event.key)) {
            onStepKeyDown(event);
            event.preventDefault();
          }
        }),
        onPointerDown: composeEventHandlers(props.onPointerDown, (event) => {
          const target = event.target;
          target.setPointerCapture(event.pointerId);
          event.preventDefault();
          if (context.thumbs.has(target)) {
            target.focus();
          } else {
            onSlideStart(event);
          }
        }),
        onPointerMove: composeEventHandlers(props.onPointerMove, (event) => {
          const target = event.target;
          if (target.hasPointerCapture(event.pointerId)) onSlideMove(event);
        }),
        onPointerUp: composeEventHandlers(props.onPointerUp, (event) => {
          const target = event.target;
          if (target.hasPointerCapture(event.pointerId)) {
            target.releasePointerCapture(event.pointerId);
            onSlideEnd(event);
          }
        })
      }
    );
  }
);
var TRACK_NAME = "SliderTrack";
var SliderTrack = reactExports.forwardRef(
  (props, forwardedRef) => {
    const { __scopeSlider, ...trackProps } = props;
    const context = useSliderContext(TRACK_NAME, __scopeSlider);
    return /* @__PURE__ */ jsxRuntimeExports.jsx(
      Primitive.span,
      {
        "data-disabled": context.disabled ? "" : void 0,
        "data-orientation": context.orientation,
        ...trackProps,
        ref: forwardedRef
      }
    );
  }
);
SliderTrack.displayName = TRACK_NAME;
var RANGE_NAME = "SliderRange";
var SliderRange = reactExports.forwardRef(
  (props, forwardedRef) => {
    const { __scopeSlider, ...rangeProps } = props;
    const context = useSliderContext(RANGE_NAME, __scopeSlider);
    const orientation = useSliderOrientationContext(RANGE_NAME, __scopeSlider);
    const ref = reactExports.useRef(null);
    const composedRefs = useComposedRefs(forwardedRef, ref);
    const valuesCount = context.values.length;
    const percentages = context.values.map(
      (value) => convertValueToPercentage(value, context.min, context.max)
    );
    const offsetStart = valuesCount > 1 ? Math.min(...percentages) : 0;
    const offsetEnd = 100 - Math.max(...percentages);
    return /* @__PURE__ */ jsxRuntimeExports.jsx(
      Primitive.span,
      {
        "data-orientation": context.orientation,
        "data-disabled": context.disabled ? "" : void 0,
        ...rangeProps,
        ref: composedRefs,
        style: {
          ...props.style,
          [orientation.startEdge]: offsetStart + "%",
          [orientation.endEdge]: offsetEnd + "%"
        }
      }
    );
  }
);
SliderRange.displayName = RANGE_NAME;
var THUMB_NAME = "SliderThumb";
var SliderThumb = reactExports.forwardRef(
  (props, forwardedRef) => {
    const getItems = useCollection(props.__scopeSlider);
    const [thumb, setThumb] = reactExports.useState(null);
    const composedRefs = useComposedRefs(forwardedRef, (node2) => setThumb(node2));
    const index2 = reactExports.useMemo(
      () => thumb ? getItems().findIndex((item) => item.ref.current === thumb) : -1,
      [getItems, thumb]
    );
    return /* @__PURE__ */ jsxRuntimeExports.jsx(SliderThumbImpl, { ...props, ref: composedRefs, index: index2 });
  }
);
var SliderThumbImpl = reactExports.forwardRef(
  (props, forwardedRef) => {
    const { __scopeSlider, index: index2, name, ...thumbProps } = props;
    const context = useSliderContext(THUMB_NAME, __scopeSlider);
    const orientation = useSliderOrientationContext(THUMB_NAME, __scopeSlider);
    const [thumb, setThumb] = reactExports.useState(null);
    const composedRefs = useComposedRefs(forwardedRef, (node2) => setThumb(node2));
    const isFormControl = thumb ? context.form || !!thumb.closest("form") : true;
    const size2 = useSize(thumb);
    const value = context.values[index2];
    const percent2 = value === void 0 ? 0 : convertValueToPercentage(value, context.min, context.max);
    const label = getLabel(index2, context.values.length);
    const orientationSize = size2?.[orientation.size];
    const thumbInBoundsOffset = orientationSize ? getThumbInBoundsOffset(orientationSize, percent2, orientation.direction) : 0;
    reactExports.useEffect(() => {
      if (thumb) {
        context.thumbs.add(thumb);
        return () => {
          context.thumbs.delete(thumb);
        };
      }
    }, [thumb, context.thumbs]);
    return /* @__PURE__ */ jsxRuntimeExports.jsxs(
      "span",
      {
        style: {
          transform: "var(--radix-slider-thumb-transform)",
          position: "absolute",
          [orientation.startEdge]: `calc(${percent2}% + ${thumbInBoundsOffset}px)`
        },
        children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx(Collection.ItemSlot, { scope: props.__scopeSlider, children: /* @__PURE__ */ jsxRuntimeExports.jsx(
            Primitive.span,
            {
              role: "slider",
              "aria-label": props["aria-label"] || label,
              "aria-valuemin": context.min,
              "aria-valuenow": value,
              "aria-valuemax": context.max,
              "aria-orientation": context.orientation,
              "data-orientation": context.orientation,
              "data-disabled": context.disabled ? "" : void 0,
              tabIndex: context.disabled ? void 0 : 0,
              ...thumbProps,
              ref: composedRefs,
              style: value === void 0 ? { display: "none" } : props.style,
              onFocus: composeEventHandlers(props.onFocus, () => {
                context.valueIndexToChangeRef.current = index2;
              })
            }
          ) }),
          isFormControl && /* @__PURE__ */ jsxRuntimeExports.jsx(
            BubbleInput,
            {
              name: name ?? (context.name ? context.name + (context.values.length > 1 ? "[]" : "") : void 0),
              form: context.form,
              value
            },
            index2
          )
        ]
      }
    );
  }
);
SliderThumb.displayName = THUMB_NAME;
var BubbleInput = (props) => {
  const { value, ...inputProps } = props;
  const ref = reactExports.useRef(null);
  const prevValue = usePrevious(value);
  reactExports.useEffect(() => {
    const input = ref.current;
    const inputProto = window.HTMLInputElement.prototype;
    const descriptor = Object.getOwnPropertyDescriptor(inputProto, "value");
    const setValue2 = descriptor.set;
    if (prevValue !== value && setValue2) {
      const event = new Event("input", { bubbles: true });
      setValue2.call(input, value);
      input.dispatchEvent(event);
    }
  }, [prevValue, value]);
  return /* @__PURE__ */ jsxRuntimeExports.jsx("input", { style: { display: "none" }, ...inputProps, ref, defaultValue: value });
};
function getNextSortedValues(prevValues = [], nextValue, atIndex) {
  const nextValues = [...prevValues];
  nextValues[atIndex] = nextValue;
  return nextValues.sort((a2, b2) => a2 - b2);
}
function convertValueToPercentage(value, min2, max2) {
  const maxSteps = max2 - min2;
  const percentPerStep = 100 / maxSteps;
  const percentage = percentPerStep * (value - min2);
  return clamp$2(percentage, [0, 100]);
}
function getLabel(index2, totalValues) {
  if (totalValues > 2) {
    return `Value ${index2 + 1} of ${totalValues}`;
  } else if (totalValues === 2) {
    return ["Minimum", "Maximum"][index2];
  } else {
    return void 0;
  }
}
function getClosestValueIndex(values2, nextValue) {
  if (values2.length === 1) return 0;
  const distances = values2.map((value) => Math.abs(value - nextValue));
  const closestDistance = Math.min(...distances);
  return distances.indexOf(closestDistance);
}
function getThumbInBoundsOffset(width2, left, direction) {
  const halfWidth = width2 / 2;
  const halfPercent = 50;
  const offset2 = linearScale([0, halfPercent], [0, halfWidth]);
  return (halfWidth - offset2(left) * direction) * direction;
}
function getStepsBetweenValues(values2) {
  return values2.slice(0, -1).map((value, index2) => values2[index2 + 1] - value);
}
function hasMinStepsBetweenValues(values2, minStepsBetweenValues) {
  if (minStepsBetweenValues > 0) {
    const stepsBetweenValues = getStepsBetweenValues(values2);
    const actualMinStepsBetweenValues = Math.min(...stepsBetweenValues);
    return actualMinStepsBetweenValues >= minStepsBetweenValues;
  }
  return true;
}
function linearScale(input, output) {
  return (value) => {
    if (input[0] === input[1] || output[0] === output[1]) return output[0];
    const ratio = (output[1] - output[0]) / (input[1] - input[0]);
    return output[0] + ratio * (value - input[0]);
  };
}
function getDecimalCount(value) {
  return (String(value).split(".")[1] || "").length;
}
function roundValue(value, decimalCount) {
  const rounder = Math.pow(10, decimalCount);
  return Math.round(value * rounder) / rounder;
}
var Root = Slider$1;
var Track = SliderTrack;
var Range = SliderRange;
var Thumb = SliderThumb;
const Slider = reactExports.forwardRef(({ className, ...props }, ref) => /* @__PURE__ */ jsxRuntimeExports.jsxs(
  Root,
  {
    ref,
    className: cn(
      "relative flex w-full touch-none select-none items-center",
      className
    ),
    ...props,
    children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx(Track, { className: "relative h-2 w-full grow overflow-hidden rounded-full bg-secondary", children: /* @__PURE__ */ jsxRuntimeExports.jsx(Range, { className: "absolute h-full bg-primary" }) }),
      /* @__PURE__ */ jsxRuntimeExports.jsx(Thumb, { className: "block h-5 w-5 rounded-full border-2 border-primary bg-background ring-offset-background transition-colors focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2 disabled:pointer-events-none disabled:opacity-50" })
    ]
  }
));
Slider.displayName = Root.displayName;
const AlertRadiusDialog = ({
  isOpen,
  onClose,
  currentRadius,
  onRadiusChange
}) => {
  const { t: t2 } = useLanguage$1();
  const [radius, setRadius] = reactExports.useState([1e3]);
  reactExports.useEffect(() => {
    if (currentRadius) {
      setRadius([currentRadius]);
    } else {
      const savedRadius = localStorage.getItem("alertRadius");
      if (savedRadius) {
        setRadius([parseInt(savedRadius)]);
      }
    }
  }, [currentRadius, isOpen]);
  const handleSave = () => {
    localStorage.setItem("alertRadius", radius[0].toString());
    if (onRadiusChange) {
      onRadiusChange(radius[0]);
    }
    window.dispatchEvent(new CustomEvent("alertRadiusUpdated"));
    toast({
      title: t2("radiusUpdated"),
      description: t2("radiusUpdateMessage"),
      variant: "default",
      duration: 3e3,
      className: "bg-card border-border"
    });
    onClose();
  };
  const formatDistance = (meters) => {
    if (meters >= 1e3) {
      return `${(meters / 1e3).toFixed(1)} km`;
    }
    return `${meters} ${t2("meters")}`;
  };
  return /* @__PURE__ */ jsxRuntimeExports.jsx(AnimatePresence, { children: isOpen && /* @__PURE__ */ jsxRuntimeExports.jsx(Dialog, { open: isOpen, onOpenChange: onClose, children: /* @__PURE__ */ jsxRuntimeExports.jsx(
    motion.div,
    {
      initial: { opacity: 0, y: 32 },
      animate: { opacity: 1, y: 0 },
      exit: { opacity: 0, y: 32 },
      transition: { duration: 0.25, ease: "easeInOut" },
      children: /* @__PURE__ */ jsxRuntimeExports.jsxs(
        DialogContent,
        {
          className: "bg-[#1e2327] border-border/50 rounded-3xl shadow-2xl",
          style: {
            background: "#1e2327",
            boxShadow: "0 25px 50px -12px rgba(0, 0, 0, 0.5), 0 0 0 1px rgba(255, 255, 255, 0.05)"
          },
          children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx(DialogHeader, { children: /* @__PURE__ */ jsxRuntimeExports.jsxs(DialogTitle, { className: "text-white flex items-center", children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx(
                motion.div,
                {
                  initial: { rotate: 0 },
                  animate: { rotate: 360 },
                  transition: { duration: 1, ease: "easeInOut" },
                  children: /* @__PURE__ */ jsxRuntimeExports.jsx(MapPin, { className: "w-5 h-5 mr-2 text-white" })
                }
              ),
              t2("setAlertRadius")
            ] }) }),
            /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "space-y-6", children: [
              /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "space-y-4", children: [
                /* @__PURE__ */ jsxRuntimeExports.jsx(Label, { className: "text-white", children: t2("radiusInMeters") }),
                /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "space-y-4", children: [
                  /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "text-center", children: [
                    /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "text-2xl font-bold text-warning", children: formatDistance(radius[0]) }),
                    /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "text-sm text-gray-400", children: t2("currentRadius") })
                  ] }),
                  /* @__PURE__ */ jsxRuntimeExports.jsx(
                    Slider,
                    {
                      value: radius,
                      onValueChange: setRadius,
                      max: 5e3,
                      min: 100,
                      step: 100,
                      className: "w-full"
                    }
                  ),
                  /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex justify-between text-xs text-gray-400", children: [
                    /* @__PURE__ */ jsxRuntimeExports.jsx("span", { children: "100m" }),
                    /* @__PURE__ */ jsxRuntimeExports.jsx("span", { children: "2.5km" }),
                    /* @__PURE__ */ jsxRuntimeExports.jsx("span", { children: "5km" })
                  ] })
                ] }),
                /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "text-sm text-gray-400 text-center", children: t2("alertRadiusDesc") })
              ] }),
              /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex gap-3", children: [
                /* @__PURE__ */ jsxRuntimeExports.jsx(
                  motion.div,
                  {
                    className: "flex-1",
                    whileHover: { scale: 1.02 },
                    whileTap: { scale: 0.98 },
                    children: /* @__PURE__ */ jsxRuntimeExports.jsx(
                      Button$1,
                      {
                        onClick: handleSave,
                        className: "w-full bg-green-600 hover:bg-green-700 text-white rounded-xl",
                        children: t2("saveChanges")
                      }
                    )
                  }
                ),
                /* @__PURE__ */ jsxRuntimeExports.jsx(
                  motion.div,
                  {
                    className: "flex-1",
                    whileHover: { scale: 1.02 },
                    whileTap: { scale: 0.98 },
                    children: /* @__PURE__ */ jsxRuntimeExports.jsx(
                      Button$1,
                      {
                        onClick: onClose,
                        variant: "outline",
                        className: "w-full border-border text-white rounded-xl",
                        children: t2("cancel")
                      }
                    )
                  }
                )
              ] })
            ] })
          ]
        }
      )
    }
  ) }) });
};
const _TrafficAnalysisService = class _TrafficAnalysisService {
  constructor() {
    __publicField(this, "userMovementHistory", []);
    __publicField(this, "lastTrafficCheck", 0);
    __publicField(this, "activeAlerts", /* @__PURE__ */ new Map());
    __publicField(this, "pushService");
    __publicField(this, "t", (key2) => key2);
    this.pushService = PushNotificationService.getInstance();
  }
  static getInstance() {
    if (!_TrafficAnalysisService.instance) {
      _TrafficAnalysisService.instance = new _TrafficAnalysisService();
    }
    return _TrafficAnalysisService.instance;
  }
  setTranslationFunction(t2) {
    this.t = t2;
  }
  // Обновляем позицию пользователя и анализируем движение
  updateUserPosition(position2) {
    const now2 = Date.now();
    const lastMovement = this.userMovementHistory[this.userMovementHistory.length - 1];
    if (lastMovement) {
      const distance2 = this.calculateDistance(
        lastMovement.currentPosition.lat,
        lastMovement.currentPosition.lng,
        position2.lat,
        position2.lng
      );
      const timeDiff = (now2 - lastMovement.timestamp) / 1e3;
      const speed = distance2 > 0 && timeDiff > 0 ? distance2 / timeDiff * 3.6 : 0;
      const heading = this.calculateBearing(
        lastMovement.currentPosition.lat,
        lastMovement.currentPosition.lng,
        position2.lat,
        position2.lng
      );
      const movement = {
        currentPosition: position2,
        previousPosition: lastMovement.currentPosition,
        speed,
        heading,
        timestamp: now2
      };
      this.userMovementHistory.push(movement);
      if (this.userMovementHistory.length > 10) {
        this.userMovementHistory.shift();
      }
      return movement;
    } else {
      const movement = {
        currentPosition: position2,
        speed: 0,
        heading: 0,
        timestamp: now2
      };
      this.userMovementHistory.push(movement);
      return movement;
    }
  }
  // Анализируем пробки впереди по маршруту
  async analyzeTrafficAhead(map, alertRadius) {
    const now2 = Date.now();
    if (now2 - this.lastTrafficCheck < 3e4) return;
    this.lastTrafficCheck = now2;
    const currentMovement = this.getCurrentMovement();
    if (!currentMovement || currentMovement.speed < 5) return;
    try {
      const trafficData = await this.getTrafficDataAhead(map, currentMovement, alertRadius);
      const alerts = this.analyzeTrafficData(trafficData, currentMovement, alertRadius);
      for (const alert2 of alerts) {
        if (!this.activeAlerts.has(alert2.id)) {
          this.activeAlerts.set(alert2.id, alert2);
          await this.sendTrafficAlert(alert2, currentMovement.currentPosition);
        }
      }
      this.cleanupOldAlerts();
    } catch (error) {
      console.error("Ошибка анализа пробок:", error);
    }
  }
  // Отправляем push-уведомление о пробке
  async sendTrafficAlert(alert2, userPosition) {
    const congestionLevel = alert2.congestionLevel;
    await this.pushService.sendTrafficNotification(
      congestionLevel,
      alert2.distance,
      alert2.estimatedDelay,
      {
        lat: userPosition.lat,
        lng: userPosition.lng,
        address: `${userPosition.lat.toFixed(4)}, ${userPosition.lng.toFixed(4)}`
      }
    );
    console.log(`🚦 Traffic notification sent: ${alert2.message}`);
  }
  // Получаем данные о пробках впереди (симуляция)
  async getTrafficDataAhead(map, movement, radius) {
    const searchPoints = this.getSearchPointsAhead(movement, radius);
    const mockTrafficData = this.generateMockTrafficData(searchPoints, movement);
    return mockTrafficData;
  }
  // Генерируем mock данные о пробках для демонстрации
  generateMockTrafficData(searchPoints, movement) {
    const trafficData = [];
    searchPoints.forEach((point2, index2) => {
      const random = Math.random();
      if (random > 0.85) {
        let congestion;
        if (random > 0.98) congestion = "severe";
        else if (random > 0.94) congestion = "heavy";
        else if (random > 0.89) congestion = "moderate";
        else congestion = "low";
        trafficData.push({
          congestion,
          coordinates: [[point2.lng, point2.lat]],
          speed: this.getSpeedByCongestion(congestion),
          distance: this.calculateDistance(
            movement.currentPosition.lat,
            movement.currentPosition.lng,
            point2.lat,
            point2.lng
          )
        });
      }
    });
    return trafficData;
  }
  // Анализируем данные о пробках и создаем уведомления
  analyzeTrafficData(trafficData, movement, alertRadius) {
    const alerts = [];
    trafficData.forEach((traffic) => {
      if (traffic.distance > alertRadius) return;
      const alert2 = this.createTrafficAlert(traffic, movement);
      if (alert2) {
        alerts.push(alert2);
      }
    });
    return alerts;
  }
  // Создаем уведомление о пробке
  createTrafficAlert(traffic, movement) {
    const alertId = `traffic_${Math.round(traffic.coordinates[0][0] * 1e3)}_${Math.round(traffic.coordinates[0][1] * 1e3)}`;
    let type;
    let severity;
    let message;
    const distanceText = traffic.distance > 1e3 ? `${(traffic.distance / 1e3).toFixed(1)}${this.t("km") || "km"}` : `${Math.round(traffic.distance)}${this.t("m") || "m"}`;
    switch (traffic.congestion) {
      case "severe":
        type = "severe_jam";
        severity = "high";
        message = this.t("trafficSevereMessage").replace("{distance}", distanceText).replace("{delay}", this.calculateDelay(traffic).toString());
        break;
      case "heavy":
        type = "heavy_congestion";
        severity = "high";
        message = this.t("trafficHeavyMessage").replace("{distance}", distanceText).replace("{delay}", this.calculateDelay(traffic).toString());
        break;
      case "moderate":
        type = "traffic_ahead";
        severity = "moderate";
        message = this.t("trafficModerateMessage").replace("{distance}", distanceText).replace("{delay}", this.calculateDelay(traffic).toString());
        break;
      default:
        return null;
    }
    return {
      id: alertId,
      type,
      severity,
      distance: traffic.distance,
      estimatedDelay: this.calculateDelay(traffic),
      congestionLevel: traffic.congestion,
      coordinates: {
        lat: traffic.coordinates[0][1],
        lng: traffic.coordinates[0][0]
      },
      message,
      timestamp: Date.now()
    };
  }
  // Вычисляем точки поиска впереди по направлению движения
  getSearchPointsAhead(movement, radius) {
    const points = [];
    const stepDistance = 200;
    const numSteps = Math.ceil(radius / stepDistance);
    for (let i2 = 1; i2 <= numSteps; i2++) {
      const distance2 = i2 * stepDistance;
      const point2 = this.getPointAtDistance(
        movement.currentPosition.lat,
        movement.currentPosition.lng,
        movement.heading,
        distance2
      );
      points.push(point2);
    }
    return points;
  }
  // Получаем точку на расстоянии по направлению
  getPointAtDistance(lat, lng, bearing, distance2) {
    const R2 = 6371e3;
    const lat1 = lat * Math.PI / 180;
    const lng1 = lng * Math.PI / 180;
    const brng = bearing * Math.PI / 180;
    const lat2 = Math.asin(Math.sin(lat1) * Math.cos(distance2 / R2) + Math.cos(lat1) * Math.sin(distance2 / R2) * Math.cos(brng));
    const lng2 = lng1 + Math.atan2(
      Math.sin(brng) * Math.sin(distance2 / R2) * Math.cos(lat1),
      Math.cos(distance2 / R2) - Math.sin(lat1) * Math.sin(lat2)
    );
    return {
      lat: lat2 * 180 / Math.PI,
      lng: lng2 * 180 / Math.PI
    };
  }
  // Вычисляем направление движения
  calculateBearing(lat1, lng1, lat2, lng2) {
    const latRad1 = lat1 * Math.PI / 180;
    const latRad2 = lat2 * Math.PI / 180;
    const deltaLng = (lng2 - lng1) * Math.PI / 180;
    const y2 = Math.sin(deltaLng) * Math.cos(latRad2);
    const x2 = Math.cos(latRad1) * Math.sin(latRad2) - Math.sin(latRad1) * Math.cos(latRad2) * Math.cos(deltaLng);
    const brng = Math.atan2(y2, x2);
    return (brng * 180 / Math.PI + 360) % 360;
  }
  // Вычисляем расстояние между точками
  calculateDistance(lat1, lng1, lat2, lng2) {
    const R2 = 6371e3;
    const latRad1 = lat1 * Math.PI / 180;
    const latRad2 = lat2 * Math.PI / 180;
    const deltaLat = (lat2 - lat1) * Math.PI / 180;
    const deltaLng = (lng2 - lng1) * Math.PI / 180;
    const a2 = Math.sin(deltaLat / 2) * Math.sin(deltaLat / 2) + Math.cos(latRad1) * Math.cos(latRad2) * Math.sin(deltaLng / 2) * Math.sin(deltaLng / 2);
    const c2 = 2 * Math.atan2(Math.sqrt(a2), Math.sqrt(1 - a2));
    return R2 * c2;
  }
  // Получаем скорость по уровню пробки
  getSpeedByCongestion(congestion) {
    switch (congestion) {
      case "severe":
        return 5;
      case "heavy":
        return 15;
      case "moderate":
        return 30;
      case "low":
        return 50;
      default:
        return 60;
    }
  }
  // Вычисляем задержку
  calculateDelay(traffic) {
    const normalSpeed = 60;
    const currentSpeed = traffic.speed || this.getSpeedByCongestion(traffic.congestion);
    const distance2 = traffic.distance / 1e3;
    const normalTime = distance2 / normalSpeed * 60;
    const currentTime = distance2 / currentSpeed * 60;
    return Math.max(0, Math.round(currentTime - normalTime));
  }
  // Получаем текущее движение
  getCurrentMovement() {
    return this.userMovementHistory[this.userMovementHistory.length - 1] || null;
  }
  // Очищаем старые уведомления
  cleanupOldAlerts() {
    const now2 = Date.now();
    const maxAge = 10 * 60 * 1e3;
    for (const [id2, alert2] of this.activeAlerts.entries()) {
      if (now2 - alert2.timestamp > maxAge) {
        this.activeAlerts.delete(id2);
      }
    }
  }
  // Получаем среднюю скорость движения
  getAverageSpeed() {
    if (this.userMovementHistory.length < 2) return 0;
    const recentMovements = this.userMovementHistory.slice(-5);
    const totalSpeed = recentMovements.reduce((sum2, movement) => sum2 + movement.speed, 0);
    return totalSpeed / recentMovements.length;
  }
  // Проверяем движется ли пользователь
  isUserMoving() {
    const avgSpeed = this.getAverageSpeed();
    return avgSpeed > 5;
  }
};
__publicField(_TrafficAnalysisService, "instance");
let TrafficAnalysisService = _TrafficAnalysisService;
const MiniMap = ({
  lat,
  lng,
  className,
  size: size2 = "sm",
  onClick
}) => {
  const sizeClasses = {
    sm: "w-16 h-16",
    // было w-12 h-12
    md: "w-20 h-20",
    lg: "w-24 h-24"
  };
  const mapboxToken = "pk.eyJ1IjoiaWNyeXB0b2ZyZWFrIiwiYSI6ImNtYnhieGE4cjFhcW8ya3B1NXRreThxZXIifQ.s32qHjkFoiS-Qauyqa6REg";
  const apiSize = size2 === "sm" ? "128x128@2x" : size2 === "md" ? "160x160@2x" : "192x192@2x";
  const zoomLevel = 16;
  const staticMapUrl = `https://api.mapbox.com/styles/v1/mapbox/dark-v11/static/pin-s+6b7280(${lng},${lat})/${lng},${lat},${zoomLevel}/${apiSize}?access_token=${mapboxToken}`;
  const handleClick = (e2) => {
    e2.stopPropagation();
    if (onClick) {
      onClick(lat, lng);
    }
  };
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(
    "div",
    {
      className: cn(
        "relative rounded-xl overflow-hidden border-2 border-white/10 bg-card shadow-lg hover:shadow-xl transition-all duration-300 hover:scale-105 hover:border-gray-400/50 hover:shadow-gray-400/20 animate-minimap-appear group",
        onClick && "cursor-pointer",
        sizeClasses[size2],
        className
      ),
      onClick: handleClick,
      title: "Нажмите чтобы показать на карте",
      children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx(
          "img",
          {
            src: staticMapUrl,
            alt: "Location map",
            className: "w-full h-full object-cover transition-opacity duration-300 group-hover:opacity-90",
            style: {
              filter: "contrast(1.1) brightness(0.9)"
            },
            onLoad: (e2) => {
              const target = e2.target;
              const fallback = target.nextElementSibling;
              if (fallback) {
                fallback.style.display = "none";
              }
            },
            onError: (e2) => {
              const target = e2.target;
              target.style.display = "none";
              const fallback = target.nextElementSibling;
              if (fallback) {
                fallback.style.display = "flex";
              }
            }
          }
        ),
        /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "absolute bottom-0 right-0 w-full h-4 bg-gradient-to-t from-card to-transparent pointer-events-none" }),
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "absolute inset-0 flex items-center justify-center bg-card", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsxs(
            "svg",
            {
              viewBox: "0 0 64 64",
              className: "w-full h-full opacity-40",
              fill: "none",
              children: [
                /* @__PURE__ */ jsxRuntimeExports.jsxs("defs", { children: [
                  /* @__PURE__ */ jsxRuntimeExports.jsx(
                    "pattern",
                    {
                      id: `grid-${lat}-${lng}`,
                      width: "8",
                      height: "8",
                      patternUnits: "userSpaceOnUse",
                      children: /* @__PURE__ */ jsxRuntimeExports.jsx(
                        "path",
                        {
                          d: "M 8 0 L 0 0 0 8",
                          fill: "none",
                          stroke: "rgba(255,255,255,0.1)",
                          strokeWidth: "0.5"
                        }
                      )
                    }
                  ),
                  /* @__PURE__ */ jsxRuntimeExports.jsxs("linearGradient", { id: `roadGradient-${lat}-${lng}`, x1: "0%", y1: "0%", x2: "100%", y2: "100%", children: [
                    /* @__PURE__ */ jsxRuntimeExports.jsx("stop", { offset: "0%", stopColor: "rgba(255,255,255,0.2)" }),
                    /* @__PURE__ */ jsxRuntimeExports.jsx("stop", { offset: "100%", stopColor: "rgba(255,255,255,0.05)" })
                  ] })
                ] }),
                /* @__PURE__ */ jsxRuntimeExports.jsx("rect", { width: "64", height: "64", fill: `url(#grid-${lat}-${lng})` }),
                /* @__PURE__ */ jsxRuntimeExports.jsx(
                  "path",
                  {
                    d: "M0 25 Q16 23 32 25 T64 27",
                    stroke: `url(#roadGradient-${lat}-${lng})`,
                    strokeWidth: "2.5",
                    fill: "none",
                    opacity: "0.6"
                  }
                ),
                /* @__PURE__ */ jsxRuntimeExports.jsx(
                  "path",
                  {
                    d: "M0 40 Q20 38 40 40 T64 42",
                    stroke: "rgba(255,255,255,0.15)",
                    strokeWidth: "2",
                    fill: "none"
                  }
                ),
                /* @__PURE__ */ jsxRuntimeExports.jsx(
                  "path",
                  {
                    d: "M25 0 Q23 16 25 32 T27 64",
                    stroke: "rgba(255,255,255,0.1)",
                    strokeWidth: "2",
                    fill: "none"
                  }
                ),
                /* @__PURE__ */ jsxRuntimeExports.jsx("circle", { cx: "16", cy: "16", r: "1.5", fill: "rgba(255,255,255,0.3)" }),
                /* @__PURE__ */ jsxRuntimeExports.jsx("circle", { cx: "48", cy: "48", r: "1.5", fill: "rgba(255,255,255,0.3)" }),
                /* @__PURE__ */ jsxRuntimeExports.jsx("rect", { x: "40", y: "20", width: "3", height: "3", fill: "rgba(255,255,255,0.2)" }),
                /* @__PURE__ */ jsxRuntimeExports.jsx("rect", { x: "20", y: "45", width: "2", height: "2", fill: "rgba(255,255,255,0.15)" })
              ]
            }
          ),
          /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "absolute inset-0 flex items-center justify-center", children: /* @__PURE__ */ jsxRuntimeExports.jsx("svg", { className: "w-6 h-6 text-gray-500", fill: "currentColor", viewBox: "0 0 24 24", children: /* @__PURE__ */ jsxRuntimeExports.jsx("path", { d: "M12 2C8.13 2 5 5.13 5 9c0 5.25 7 13 7 13s7-7.75 7-13c0-3.87-3.13-7-7-7zm0 9.5c-1.38 0-2.5-1.12-2.5-2.5s1.12-2.5 2.5-2.5 2.5 1.12 2.5 2.5-1.12 2.5-2.5 2.5z" }) }) })
        ] }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "absolute inset-0 bg-gradient-to-br from-transparent via-transparent to-black/10 pointer-events-none" }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "absolute inset-0 bg-gradient-to-br from-white/5 via-white/2 to-transparent pointer-events-none" }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "absolute inset-0 rounded-xl border border-white/20 pointer-events-none shadow-inner group-hover:border-gray-400/50 transition-colors duration-300" }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "absolute inset-0 bg-white/0 group-hover:bg-gray-400/5 transition-all duration-300 rounded-xl pointer-events-none" }),
        onClick && /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "absolute top-1 right-1 opacity-0 group-hover:opacity-100 transition-opacity duration-200", children: /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "w-4 h-4 bg-black/60 rounded-full flex items-center justify-center", children: /* @__PURE__ */ jsxRuntimeExports.jsx("svg", { className: "w-2.5 h-2.5 text-white", fill: "none", stroke: "currentColor", viewBox: "0 0 24 24", children: /* @__PURE__ */ jsxRuntimeExports.jsx("path", { strokeLinecap: "round", strokeLinejoin: "round", strokeWidth: 2, d: "M21 21l-6-6m2-5a7 7 0 11-14 0 7 7 0 0114 0zM10 7v3m0 0v3m0-3h3m-3 0H7" }) }) }) })
      ]
    }
  );
};
const NOTIFICATION_LIMITS = {
  MAX_NOTIFICATIONS_PER_PERIOD: 3,
  // Максимум 3 уведомления за период
  RESET_PERIOD_MS: 15 * 60 * 1e3,
  // 15 минут
  MIN_INTERVAL_MS: 5 * 60 * 1e3,
  // 5 минут между уведомлениями
  STABILITY_THRESHOLD: 50,
  // Минимальное изменение расстояния для нового уведомления (метры)
  MIN_CONSECUTIVE_STATES: 2
  // Минимум состояний подряд для стабильности
};
const _DangerZoneMonitoringService = class _DangerZoneMonitoringService {
  constructor() {
    __publicField(this, "pushService");
    __publicField(this, "barrios", []);
    __publicField(this, "lastUserLocation", null);
    __publicField(this, "proximityThreshold", 1e3);
    // метров - порог приближения к зоне
    __publicField(this, "isMonitoring", false);
    __publicField(this, "monitoringInterval", null);
    // Новая унифицированная система управления состоянием зон
    __publicField(this, "zoneStates", /* @__PURE__ */ new Map());
    this.pushService = PushNotificationService.getInstance();
    this.loadBarrios();
  }
  static getInstance() {
    if (!_DangerZoneMonitoringService.instance) {
      _DangerZoneMonitoringService.instance = new _DangerZoneMonitoringService();
    }
    return _DangerZoneMonitoringService.instance;
  }
  // Загружаем список баррио (районов) из базы данных
  async loadBarrios() {
    try {
      const { data, error } = await supabase.from("barrios").select("id, name, risk_level, geometry, is_danger_zone").eq("is_danger_zone", true);
      if (error) {
        console.error("❌ Error loading barrios:", error);
        return;
      }
      if (data) {
        this.barrios = data;
        console.log(`🗺️ Loaded ${this.barrios.length} danger zones for monitoring`);
      }
    } catch (error) {
      console.error("❌ Exception loading barrios:", error);
    }
  }
  // ==================== НОВАЯ СИСТЕМА УПРАВЛЕНИЯ СОСТОЯНИЕМ ====================
  /**
   * Получает или создает состояние для указанной зоны
   */
  getOrCreateZoneState(zoneId) {
    if (!this.zoneStates.has(zoneId)) {
      const now2 = Date.now();
      this.zoneStates.set(zoneId, {
        zoneId,
        lastNotificationTime: 0,
        notificationCount: 0,
        currentTier: "safe",
        resetTime: now2 + NOTIFICATION_LIMITS.RESET_PERIOD_MS,
        lastResetTime: now2,
        lastStableDistance: -1,
        consecutiveSameStateCount: 0
      });
    }
    return this.zoneStates.get(zoneId);
  }
  /**
   * Проверяет можно ли отправить уведомление для зоны с учетом всех лимитов
   */
  canSendNotification(zoneId, newTier, distance2) {
    const state = this.getOrCreateZoneState(zoneId);
    const now2 = Date.now();
    if (now2 >= state.resetTime) {
      state.notificationCount = 0;
      state.lastResetTime = now2;
      state.resetTime = now2 + NOTIFICATION_LIMITS.RESET_PERIOD_MS;
      console.log(`🔄 Reset notification counter for zone ${zoneId}`);
    }
    if (state.notificationCount >= NOTIFICATION_LIMITS.MAX_NOTIFICATIONS_PER_PERIOD) {
      console.log(`🚫 Notification limit reached for zone ${zoneId} (${state.notificationCount}/${NOTIFICATION_LIMITS.MAX_NOTIFICATIONS_PER_PERIOD})`);
      return false;
    }
    if (now2 - state.lastNotificationTime < NOTIFICATION_LIMITS.MIN_INTERVAL_MS) {
      console.log(`⏰ Too soon for next notification for zone ${zoneId} (${Math.round((now2 - state.lastNotificationTime) / 1e3)}s < ${NOTIFICATION_LIMITS.MIN_INTERVAL_MS / 1e3}s)`);
      return false;
    }
    if (newTier === state.currentTier) {
      state.consecutiveSameStateCount++;
      return false;
    }
    if (state.lastStableDistance !== -1 && Math.abs(distance2 - state.lastStableDistance) < NOTIFICATION_LIMITS.STABILITY_THRESHOLD && newTier !== "inside" && state.currentTier !== "inside") {
      console.log(`📏 Distance change too small for zone ${zoneId}: ${Math.abs(distance2 - state.lastStableDistance)}m < ${NOTIFICATION_LIMITS.STABILITY_THRESHOLD}m`);
      return false;
    }
    if (newTier !== "inside" && state.currentTier !== "inside" && state.consecutiveSameStateCount < NOTIFICATION_LIMITS.MIN_CONSECUTIVE_STATES) {
      console.log(`⚖️ Need more consecutive states for stability: ${state.consecutiveSameStateCount} < ${NOTIFICATION_LIMITS.MIN_CONSECUTIVE_STATES}`);
      return false;
    }
    return true;
  }
  /**
   * Определяет tier на основе расстояния и факта нахождения внутри
   */
  determineTier(distance2, isInside) {
    if (isInside) {
      return "inside";
    }
    if (distance2 <= this.proximityThreshold) {
      return "nearby";
    }
    return "safe";
  }
  /**
   * Обновляет состояние зоны после отправки уведомления
   */
  updateZoneStateAfterNotification(zoneId, newTier, distance2) {
    const state = this.getOrCreateZoneState(zoneId);
    const now2 = Date.now();
    state.lastNotificationTime = now2;
    state.notificationCount++;
    state.currentTier = newTier;
    state.lastStableDistance = distance2;
    state.consecutiveSameStateCount = 1;
    console.log(`✅ Updated zone ${zoneId} state: tier=${newTier}, count=${state.notificationCount}/${NOTIFICATION_LIMITS.MAX_NOTIFICATIONS_PER_PERIOD}, distance=${distance2}m`);
  }
  // ==================== КОНЕЦ СИСТЕМЫ УПРАВЛЕНИЯ СОСТОЯНИЕМ ====================
  // Запускаем мониторинг пользователя
  startMonitoring(userLocation) {
    if (!userLocation || typeof userLocation.lat !== "number" || typeof userLocation.lng !== "number") {
      console.warn("⚠️ Cannot start monitoring: UserLocation is invalid or missing coordinates:", userLocation);
      return;
    }
    this.lastUserLocation = userLocation;
    this.isMonitoring = true;
    this.checkProximityToBarrios(userLocation);
    if (this.monitoringInterval) {
      clearInterval(this.monitoringInterval);
    }
    this.monitoringInterval = setInterval(() => {
      if (this.lastUserLocation) {
        this.checkProximityToBarrios(this.lastUserLocation);
      }
    }, 1e4);
    console.log("🔍 Danger zone monitoring started");
  }
  // Останавливаем мониторинг
  stopMonitoring() {
    this.isMonitoring = false;
    if (this.monitoringInterval) {
      clearInterval(this.monitoringInterval);
      this.monitoringInterval = null;
    }
    console.log("⏹️ Danger zone monitoring stopped");
  }
  // Обновляем позицию пользователя
  updateUserLocation(userLocation) {
    if (!userLocation || typeof userLocation.lat !== "number" || typeof userLocation.lng !== "number") {
      console.warn("⚠️ Cannot update location: UserLocation is invalid or missing coordinates:", userLocation);
      return;
    }
    this.lastUserLocation = userLocation;
    if (this.isMonitoring) {
      this.checkProximityToBarrios(userLocation);
    }
  }
  // Проверяем близость к опасным районам (НОВАЯ ЛОГИКА)
  async checkProximityToBarrios(userLocation) {
    if (!userLocation || typeof userLocation.lat !== "number" || typeof userLocation.lng !== "number") {
      console.warn("⚠️ Cannot check proximity: UserLocation is invalid or missing coordinates:", userLocation);
      return;
    }
    console.log("🔍 DangerZoneMonitoring: Проверяем близость к опасным зонам...", {
      userLocation,
      barriosCount: this.barrios.length,
      isMonitoring: this.isMonitoring
    });
    for (const barrio of this.barrios) {
      try {
        const { isNear: isNear2, distance: distance2, isInside } = await this.checkDistanceToBarrio(userLocation, barrio);
        const zoneId = `${barrio.id}`;
        const newTier = this.determineTier(distance2, isInside);
        console.log(`🔍 Zone ${barrio.name || `Zona #${barrio.id}`}: distance=${distance2}m, isInside=${isInside}, tier=${newTier}`);
        if (this.canSendNotification(zoneId, newTier, distance2)) {
          if (newTier === "inside") {
            await this.sendUnifiedNotification(barrio, userLocation, true);
            this.updateZoneStateAfterNotification(zoneId, newTier, distance2);
          } else if (newTier === "nearby") {
            await this.sendUnifiedNotification(barrio, userLocation, false);
            this.updateZoneStateAfterNotification(zoneId, newTier, distance2);
          } else if (newTier === "safe") {
            const state = this.getOrCreateZoneState(zoneId);
            if (state.currentTier === "inside" || state.currentTier === "nearby") {
              await this.sendExitNotification(barrio, userLocation);
              this.updateZoneStateAfterNotification(zoneId, newTier, distance2);
            }
          }
        } else {
          const state = this.getOrCreateZoneState(zoneId);
          if (newTier === state.currentTier) {
            state.consecutiveSameStateCount++;
          } else {
            state.consecutiveSameStateCount = 1;
            state.currentTier = newTier;
            state.lastStableDistance = distance2;
          }
        }
      } catch (error) {
        console.error(`❌ Error checking distance to barrio ${barrio.name || barrio.id}:`, error);
      }
    }
  }
  // Проверяем расстояние до конкретного баррио
  async checkDistanceToBarrio(userLocation, barrio) {
    if (!userLocation || typeof userLocation.lat !== "number" || typeof userLocation.lng !== "number") {
      console.warn("⚠️ UserLocation is invalid or missing coordinates:", userLocation);
      return { isNear: false, distance: 0, isInside: false };
    }
    try {
      const { data, error } = await supabase.rpc("check_point_proximity_to_barrio", {
        user_lat: userLocation.lat,
        user_lng: userLocation.lng,
        barrio_id: barrio.id,
        proximity_threshold: this.proximityThreshold
      });
      if (error) {
        console.warn(`⚠️ SQL function failed for barrio ${barrio.name}, using fallback:`, error);
        return this.calculateSimpleDistance(userLocation, barrio);
      }
      if (data) {
        const result = Array.isArray(data) ? data[0] : data;
        console.log(`🔍 RPC result for barrio ${barrio.id}:`, result);
        return {
          isNear: result.is_near || result.is_inside,
          distance: Math.round(result.distance || 0),
          isInside: result.is_inside || false
        };
      }
      return this.calculateSimpleDistance(userLocation, barrio);
    } catch (error) {
      console.warn(`⚠️ Exception in distance calculation for barrio ${barrio.name}:`, error);
      return this.calculateSimpleDistance(userLocation, barrio);
    }
  }
  // Простой расчет расстояния как fallback
  calculateSimpleDistance(userLocation, barrio) {
    if (!userLocation || typeof userLocation.lat !== "number" || typeof userLocation.lng !== "number") {
      console.warn("⚠️ UserLocation is invalid or missing coordinates:", userLocation);
      return { isNear: false, distance: 0, isInside: false };
    }
    if (!barrio.geometry?.coordinates) {
      console.warn("⚠️ Barrio geometry is missing:", barrio.id);
      return { isNear: false, distance: 0, isInside: false };
    }
    try {
      const userPoint = point([userLocation.lng, userLocation.lat]);
      const barrioPolygon = polygon(barrio.geometry.coordinates);
      const isInside = booleanPointInPolygon(userPoint, barrioPolygon);
      let distance2 = 0;
      if (!isInside) {
        const polygonLine = polygonToLine(barrioPolygon);
        distance2 = pointToLineDistance(userPoint, polygonLine, { units: "meters" });
      }
      const isNear2 = isInside || distance2 <= 1e3;
      return {
        isNear: isNear2,
        distance: Math.round(distance2),
        isInside
      };
    } catch (error) {
      console.error("❌ Error in calculateSimpleDistance:", error);
      return { isNear: false, distance: 0, isInside: false };
    }
  }
  // Получаем границы зоны
  getZoneBounds(geometry) {
    if (!geometry || !geometry.coordinates || !geometry.coordinates[0]) {
      return { north: 0, south: 0, east: 0, west: 0 };
    }
    const coords = geometry.coordinates[0];
    let north = -90, south = 90, east = -180, west = 180;
    coords.forEach((coord) => {
      const [lng, lat] = coord;
      if (lat > north) north = lat;
      if (lat < south) south = lat;
      if (lng > east) east = lng;
      if (lng < west) west = lng;
    });
    return { north, south, east, west };
  }
  // Calculate distance using Haversine formula
  haversineDistance(pos1, pos2) {
    const R2 = 6371e3;
    const lat1 = pos1.lat * Math.PI / 180;
    const lat2 = pos2.lat * Math.PI / 180;
    const deltaLat = (pos2.lat - pos1.lat) * Math.PI / 180;
    const deltaLng = (pos2.lng - pos1.lng) * Math.PI / 180;
    const a2 = Math.sin(deltaLat / 2) * Math.sin(deltaLat / 2) + Math.cos(lat1) * Math.cos(lat2) * Math.sin(deltaLng / 2) * Math.sin(deltaLng / 2);
    const c2 = 2 * Math.atan2(Math.sqrt(a2), Math.sqrt(1 - a2));
    return R2 * c2;
  }
  // Отправляем уведомление о входе в опасный район
  async sendZoneEntryNotification(barrio, userLocation, distance2) {
    const zoneName = barrio.name || `Zona de Riesgo #${barrio.id}`;
    const notification = {
      id: `barrio_entry_${barrio.id}`,
      type: "zone_entry",
      title: DangerZoneTranslations.getEntryTitle(barrio.risk_level),
      message: DangerZoneTranslations.getEntryMessage(zoneName),
      priority: this.getPriorityByRisk(barrio.risk_level),
      location: {
        lat: userLocation.lat,
        lng: userLocation.lng,
        address: zoneName
      },
      timestamp: /* @__PURE__ */ new Date(),
      actionRequired: barrio.risk_level >= 4,
      suggestedActions: this.getSuggestedActionsByRisk(barrio.risk_level, true),
      aiConfidence: 0.95
    };
    console.log(`🚨 Sending barrio entry notification for ${zoneName} (risk: ${barrio.risk_level})`);
    await this.pushService.sendLocalNotification(notification);
  }
  // Отправляем уведомление о приближении к опасному району
  async sendProximityNotification(barrio, userLocation, distance2) {
    const zoneName = barrio.name || `Zona de Riesgo #${barrio.id}`;
    const notification = {
      id: `barrio_proximity_${barrio.id}`,
      type: "zone_entry",
      title: DangerZoneTranslations.getProximityTitle(barrio.risk_level),
      message: DangerZoneTranslations.getProximityMessage(zoneName, distance2),
      priority: this.getPriorityByRisk(barrio.risk_level),
      location: {
        lat: userLocation.lat,
        lng: userLocation.lng,
        address: DangerZoneTranslations.getNearByText(zoneName)
      },
      timestamp: /* @__PURE__ */ new Date(),
      actionRequired: barrio.risk_level >= 4,
      suggestedActions: this.getSuggestedActionsByRisk(barrio.risk_level, false),
      aiConfidence: 0.9
    };
    console.log(`⚠️ Sending proximity notification for ${zoneName} (${distance2}m, risk: ${barrio.risk_level})`);
    await this.pushService.sendLocalNotification(notification);
  }
  // Отправляем уведомление о выходе из опасного района
  async sendExitNotification(barrio, userLocation) {
    const notification = {
      id: `barrio_exit_${barrio.id}`,
      type: "zone_entry",
      // Используем существующий тип для консистентности
      title: DangerZoneTranslations.getExitTitle(),
      message: DangerZoneTranslations.getExitMessage(),
      priority: "low",
      // Выход - обычное событие
      location: {
        lat: userLocation.lat,
        lng: userLocation.lng,
        address: "Left danger zone"
        // Упрощенное название
      },
      timestamp: /* @__PURE__ */ new Date(),
      actionRequired: false,
      suggestedActions: [],
      aiConfidence: 0.85
    };
    console.log(`🚪 Sending exit notification for zone ${barrio.id}`);
    await this.pushService.sendLocalNotification(notification);
  }
  // ==================== НОВАЯ УНИФИЦИРОВАННАЯ СИСТЕМА УВЕДОМЛЕНИЙ ====================
  /**
   * Отправляет унифицированное уведомление (nearby или inside) с правильными текстами
   */
  async sendUnifiedNotification(barrio, userLocation, isInside) {
    const currentLanguage = getCurrentLanguage();
    const notificationTexts = this.getUnifiedNotificationTexts(isInside, currentLanguage);
    const notification = {
      id: `unified_${isInside ? "inside" : "nearby"}_${barrio.id}`,
      type: "zone_entry",
      title: notificationTexts.title,
      message: notificationTexts.message,
      priority: this.getPriorityByRisk(barrio.risk_level),
      location: {
        lat: userLocation.lat,
        lng: userLocation.lng,
        address: isInside ? "Inside danger zone" : "Near danger zone"
        // Не показываем сырые названия
      },
      timestamp: /* @__PURE__ */ new Date(),
      actionRequired: isInside || barrio.risk_level >= 4,
      // Более осторожно для внутри зон
      suggestedActions: [],
      // Убираем сложные действия, фокус на открытие карты
      aiConfidence: 0.95
    };
    console.log(`🚨 Sending unified ${isInside ? "INSIDE" : "NEARBY"} notification for zone ${barrio.id} (risk: ${barrio.risk_level})`);
    await this.pushService.sendLocalNotification(notification);
    const userId = await getCurrentUserId();
    if (userId) {
      await this.pushService.sendDangerZoneAlert(
        userId,
        isInside ? "Inside danger zone" : "Near danger zone",
        // Унифицированные названия
        isInside ? "TIER_1" : "TIER_2",
        barrio.risk_level
      );
    }
  }
  /**
   * Получает унифицированные тексты уведомлений в зависимости от языка и состояния
   */
  getUnifiedNotificationTexts(isInside, language) {
    if (isInside) {
      return {
        title: DangerZoneTranslations.getInsideTitle(),
        message: DangerZoneTranslations.getInsideMessage()
      };
    } else {
      return {
        title: DangerZoneTranslations.getNearTitle(),
        message: DangerZoneTranslations.getNearMessage()
      };
    }
  }
  // ==================== КОНЕЦ УНИФИЦИРОВАННОЙ СИСТЕМЫ УВЕДОМЛЕНИЙ ====================
  // Получаем приоритет уведомления в зависимости от уровня риска
  getPriorityByRisk(riskLevel) {
    switch (riskLevel) {
      case 5:
        return "urgent";
      case 4:
        return "high";
      case 3:
        return "medium";
      default:
        return "low";
    }
  }
  // Получаем рекомендуемые действия в зависимости от уровня риска
  getSuggestedActionsByRisk(riskLevel, isInside) {
    const baseActions = DangerZoneTranslations.getBasicActions();
    if (riskLevel >= 4) {
      const highRiskActions = DangerZoneTranslations.getHighRiskActions(isInside);
      return [...highRiskActions, ...baseActions];
    }
    if (riskLevel === 3) {
      const moderateActions = DangerZoneTranslations.getModerateActions();
      return [...moderateActions, ...baseActions];
    }
    return baseActions;
  }
  // ==================== УДАЛЕННЫЕ СТАРЫЕ МЕТОДЫ TIER СИСТЕМЫ ====================
  // Старые методы getTier() и isMoreDangerous() удалены - заменены на determineTier() 
  // и новую систему управления состоянием
  // ==================== УДАЛЕННЫЕ СТАРЫЕ МЕТОДЫ УВЕДОМЛЕНИЙ ====================
  // Старые методы sendTierNotification() и sendExitNotification() удалены
  // Заменены на единый sendUnifiedNotification() с упрощенной логикой
  // Настройка порога приближения
  setProximityThreshold(meters) {
    this.proximityThreshold = Math.max(50, Math.min(1e4, meters));
    console.log(`🎯 Proximity threshold set to ${this.proximityThreshold}m`);
  }
  // Получение текущего порога
  getProximityThreshold() {
    return this.proximityThreshold;
  }
  // Получение статуса мониторинга
  isCurrentlyMonitoring() {
    return this.isMonitoring;
  }
  // Очистка кэша уведомлений (для тестирования) - ОБНОВЛЕНО для новой системы
  clearNotificationCache() {
    this.zoneStates.clear();
    console.log("🧹 Zone notification states cleared");
  }
  // Получение статистики по зонам (для отладки)
  getZoneStatesInfo() {
    const info = [];
    this.zoneStates.forEach((state, zoneId) => {
      info.push(`Zone ${zoneId}: ${state.currentTier}, notifications: ${state.notificationCount}/${NOTIFICATION_LIMITS.MAX_NOTIFICATIONS_PER_PERIOD}, last: ${new Date(state.lastNotificationTime).toLocaleTimeString()}`);
    });
    return info;
  }
  // Принудительный сброс лимитов для зоны (для тестирования)
  resetZoneLimits(zoneId) {
    const state = this.zoneStates.get(zoneId);
    if (state) {
      const now2 = Date.now();
      state.notificationCount = 0;
      state.lastResetTime = now2;
      state.resetTime = now2 + NOTIFICATION_LIMITS.RESET_PERIOD_MS;
      console.log(`🔄 Limits reset for zone ${zoneId}`);
    }
  }
  // Устанавливаем push-сервис
  setPushService(pushService) {
    this.pushService = pushService;
  }
  // Получаем push-сервис
  getPushService() {
    return this.pushService;
  }
};
__publicField(_DangerZoneMonitoringService, "instance");
let DangerZoneMonitoringService = _DangerZoneMonitoringService;
const Geolocation = registerPlugin("Geolocation", {
  web: () => __vitePreload(() => import("./web-T21xEGcd.js"), true ? __vite__mapDeps([3,1]) : void 0).then((m2) => new m2.GeolocationWeb())
});
const isCapacitor = () => {
  const hasCapacitor = window.Capacitor !== void 0;
  const isNative2 = hasCapacitor && window.Capacitor.isNativePlatform && window.Capacitor.isNativePlatform();
  console.log("🔍 Platform detection:", {
    hasCapacitor,
    isNative: isNative2,
    userAgent: navigator.userAgent,
    platform: navigator.platform
  });
  return hasCapacitor && isNative2;
};
async function getAndroidFCMToken() {
  try {
    console.log("📱 Getting Android FCM token...");
    if (!isCapacitor()) {
      console.log("❌ Not running in Capacitor environment");
      return null;
    }
    const { PushNotifications: PushNotifications2 } = await __vitePreload(async () => {
      const { PushNotifications: PushNotifications3 } = await Promise.resolve().then(() => index);
      return { PushNotifications: PushNotifications3 };
    }, true ? void 0 : void 0);
    console.log("🔐 Requesting push notification permission...");
    const permResult = await PushNotifications2.requestPermissions();
    if (permResult.receive !== "granted") {
      console.log("❌ Push notification permission denied");
      return null;
    }
    console.log("✅ Push notification permission granted");
    await PushNotifications2.register();
    return new Promise(async (resolve) => {
      let resolved = false;
      const registrationListener = await PushNotifications2.addListener("registration", (token2) => {
        if (!resolved) {
          resolved = true;
          console.log("✅ Android FCM token obtained:", token2.value);
          registrationListener.remove();
          errorListener.remove();
          resolve(token2.value);
        }
      });
      const errorListener = await PushNotifications2.addListener("registrationError", (error) => {
        if (!resolved) {
          resolved = true;
          console.error("❌ Android FCM registration error:", error);
          registrationListener.remove();
          errorListener.remove();
          resolve(null);
        }
      });
      setTimeout(() => {
        if (!resolved) {
          resolved = true;
          console.log("⏰ Android FCM token timeout");
          registrationListener.remove();
          errorListener.remove();
          resolve(null);
        }
      }, 1e4);
    });
  } catch (error) {
    console.error("❌ Error getting Android FCM token:", error);
    return null;
  }
}
async function getWebFCMToken() {
  try {
    console.log("🔔 Starting web FCM token retrieval...");
    if (!("Notification" in window)) {
      console.log("❌ This browser does not support notifications");
      return null;
    }
    console.log("✅ Browser supports notifications");
    const permission = await Notification.requestPermission();
    console.log("🔐 Notification permission:", permission);
    if (permission !== "granted") {
      console.log("❌ Notification permission denied");
      return null;
    }
    console.log("✅ Notification permission granted");
    if (!("serviceWorker" in navigator)) {
      console.log("❌ Service Worker not supported");
      return null;
    }
    console.log("✅ Service Worker supported");
    console.log("📦 Importing Firebase modules...");
    const { getMessaging, getToken } = await __vitePreload(async () => {
      const { getMessaging: getMessaging2, getToken: getToken2 } = await import("./index.esm-4Q1Ufeeo.js");
      return { getMessaging: getMessaging2, getToken: getToken2 };
    }, true ? __vite__mapDeps([4,5]) : void 0);
    const { initializeApp } = await __vitePreload(async () => {
      const { initializeApp: initializeApp2 } = await import("./index.esm-BB3lfauv.js");
      return { initializeApp: initializeApp2 };
    }, true ? __vite__mapDeps([6,5]) : void 0);
    console.log("✅ Firebase modules imported");
    const firebaseConfig = {
      apiKey: "AIzaSyDzhARcf5psBIWRGarOOTRk2bMqrj2qyig",
      authDomain: "radar-31017.firebaseapp.com",
      projectId: "radar-31017",
      storageBucket: "radar-31017.firebasestorage.app",
      messagingSenderId: "210340122791",
      appId: "1:210340122791:web:d799a0ad5ea61ff2b88b82",
      measurementId: "G-108PC3R7LG"
    };
    console.log("🔥 Initializing Firebase...");
    const app = initializeApp(firebaseConfig);
    const messaging = getMessaging(app);
    console.log("✅ Firebase initialized");
    console.log("🎫 Getting FCM token...");
    const token2 = await getToken(messaging, {
      vapidKey: "BCC3peAm5wD42b9gy7WlU-iNSf2XLXcKW9yPGZtJMiXoRUsMjRQSlWEyR9iy1ILIlPUXeTnu2w8k8P1OrN4IR7g"
    });
    if (token2) {
      console.log("✅ Web FCM token obtained:", token2);
      return token2;
    } else {
      console.log("❌ No web FCM token available");
      return null;
    }
  } catch (error) {
    console.error("❌ Error getting web FCM token:", error);
    console.error("Error details:", {
      name: error.name,
      message: error.message,
      code: error.code,
      stack: error.stack
    });
    return null;
  }
}
async function getFCMToken() {
  if (isCapacitor()) {
    console.log("📱 Running in mobile app - getting Android FCM token");
    return await getAndroidFCMToken();
  } else {
    console.log("🌐 Running in web browser - getting web FCM token");
    return await getWebFCMToken();
  }
}
async function registerFCMToken(token2) {
  try {
    const userId = await getCurrentUserId();
    if (!userId) {
      console.error("User not authenticated");
      return false;
    }
    const deviceType = isCapacitor() ? "android" : "web";
    console.log(`📝 Registering ${deviceType} FCM token...`);
    const { data: existingTokens, error: checkError } = await supabase.from("push_notification_tokens").select("id, fcm_token").eq("user_id", userId).eq("device_type", deviceType).eq("fcm_token", token2).eq("is_active", true);
    if (checkError) {
      console.error("Error checking existing tokens:", checkError);
      return false;
    }
    if (existingTokens && existingTokens.length > 0) {
      console.log(`✅ ${deviceType} FCM token already registered and active`);
      return true;
    }
    await supabase.from("push_notification_tokens").update({ is_active: false }).eq("user_id", userId).eq("device_type", deviceType).eq("is_active", true);
    const { error } = await supabase.from("push_notification_tokens").insert({
      user_id: userId,
      fcm_token: token2,
      device_type: deviceType,
      is_active: true
    });
    if (error) {
      console.error("Error registering FCM token:", error);
      return false;
    }
    console.log(`✅ ${deviceType} FCM token registered successfully`);
    return true;
  } catch (error) {
    console.error("Error registering FCM token:", error);
    return false;
  }
}
async function generateTokenOnly() {
  try {
    const platform2 = isCapacitor() ? "Android App" : "Web Browser";
    console.log(`🔐 Generating FCM token for ${platform2} (onboarding)...`);
    const token2 = await getFCMToken();
    if (!token2) {
      console.error("❌ Failed to get FCM token during onboarding");
      return null;
    }
    console.log("🎫 FCM token obtained during onboarding:", token2.substring(0, 20) + "...");
    const registered = await registerFCMToken(token2);
    if (!registered) {
      console.error("❌ Failed to register FCM token during onboarding");
      return null;
    }
    console.log("✅ FCM token generated and registered successfully during onboarding");
    return token2;
  } catch (error) {
    console.error("❌ Error generating FCM token during onboarding:", error);
    return null;
  }
}
async function setupPushNotifications() {
  try {
    const platform2 = isCapacitor() ? "Android App" : "Web Browser";
    console.log(`🔔 Setting up push notifications for ${platform2}...`);
    const token2 = await getFCMToken();
    if (!token2) {
      console.error("❌ Failed to get FCM token");
      return null;
    }
    const registered = await registerFCMToken(token2);
    if (!registered) {
      console.error("❌ Failed to register FCM token");
      return null;
    }
    console.log("✅ Push notifications setup completed");
    console.log("FCM Token:", token2);
    return token2;
  } catch (error) {
    console.error("❌ Error setting up push notifications:", error);
    return null;
  }
}
async function testPushNotifications() {
  try {
    const platform2 = isCapacitor() ? "Android App" : "Web Browser";
    console.log(`🧪 Testing push notifications for ${platform2}...`);
    const userId = await getCurrentUserId();
    if (!userId) {
      console.error("❌ User not authenticated");
      return;
    }
    console.log("👤 User ID:", userId);
    const deviceType = isCapacitor() ? "android" : "web";
    const { data: tokens, error } = await supabase.from("push_notification_tokens").select("fcm_token, device_type, is_active, created_at").eq("user_id", userId).eq("device_type", deviceType).eq("is_active", true).order("updated_at", { ascending: false }).limit(1);
    if (error) {
      console.error("❌ Error fetching FCM token:", error);
      return;
    }
    if (!tokens || tokens.length === 0) {
      console.log(`❌ No ${deviceType} FCM token found. Setting up push notifications...`);
      const token2 = await setupPushNotifications();
      if (!token2) {
        console.error("❌ Failed to setup push notifications");
        return;
      }
    } else {
      console.log(`✅ ${deviceType} FCM token found:`, tokens[0].fcm_token.substring(0, 20) + "...");
    }
    console.log("📤 Testing Edge Function...");
    const testData = {
      user_id: userId,
      tier: "TIER_1",
      zone_name: "Test Danger Zone",
      risk_level: 8
    };
    const { data: { session } } = await supabase.auth.getSession();
    if (!session) {
      console.error("❌ No active session found");
      return;
    }
    const response = await supabase.functions.invoke("send_danger_zone_push", {
      body: testData,
      headers: {
        "Authorization": `Bearer ${session.access_token}`
      }
    });
    if (response.error) {
      console.error("❌ Failed to send push notification");
      console.error("Error:", response.error);
    } else {
      console.log("✅ Push notification sent successfully!");
      console.log("Response:", response.data);
    }
  } catch (error) {
    console.error("❌ Error testing push notifications:", error);
  }
}
window.setupPushNotifications = setupPushNotifications;
window.testPushNotifications = testPushNotifications;
window.getFCMToken = getFCMToken;
window.registerFCMToken = registerFCMToken;
window.generateTokenOnly = generateTokenOnly;
class TestPushNotifications {
  constructor() {
    __publicField(this, "pushService", PushNotificationService.getInstance());
  }
  // Тест 1: Проверка FCM токена
  async testFCMTokenStorage() {
    try {
      const userId = await getCurrentUserId();
      if (!userId) {
        console.error("❌ No user ID found");
        return false;
      }
      const deviceType = isCapacitor() ? "android" : "web";
      const { data, error } = await supabase.from("push_notification_tokens").select("*").eq("user_id", userId).eq("device_type", deviceType).eq("is_active", true).order("updated_at", { ascending: false }).limit(1);
      if (error) {
        console.error("❌ Error checking FCM token:", error);
        return false;
      }
      if (!data || data.length === 0) {
        console.warn("⚠️ No active FCM token found for user");
        return false;
      }
      const token2 = data[0];
      console.log("✅ FCM token found:", {
        token: token2.fcm_token.substring(0, 20) + "...",
        device_type: token2.device_type,
        is_active: token2.is_active,
        updated_at: token2.updated_at
      });
      return true;
    } catch (error) {
      console.error("❌ Error in FCM token test:", error);
      return false;
    }
  }
  // Тест 2: Простое push-уведомление
  async testSimplePush() {
    try {
      const userId = await getCurrentUserId();
      if (!userId) {
        console.error("❌ No user ID found");
        return false;
      }
      console.log("📤 Sending test push notification...");
      await this.pushService.sendPushNotification(
        userId,
        "Test Notification",
        "This is a test push notification from RADAR app",
        { test: true, timestamp: (/* @__PURE__ */ new Date()).toISOString() },
        "system_alert",
        "medium"
      );
      console.log("✅ Test push notification sent successfully");
      return true;
    } catch (error) {
      console.error("❌ Error sending test push:", error);
      return false;
    }
  }
  // Тест 3: Push-уведомление об опасной зоне
  async testDangerZonePush() {
    try {
      const userId = await getCurrentUserId();
      if (!userId) {
        console.error("❌ No user ID found");
        return false;
      }
      console.log("🚨 Sending danger zone test notification...");
      await this.pushService.sendDangerZoneAlert(
        userId,
        "Test Danger Zone",
        "TIER_1",
        8
      );
      console.log("✅ Danger zone test notification sent successfully");
      return true;
    } catch (error) {
      console.error("❌ Error sending danger zone test:", error);
      return false;
    }
  }
  // Тест 4: Проверка настроек уведомлений
  async testNotificationSettings() {
    try {
      const userId = await getCurrentUserId();
      if (!userId) {
        console.error("❌ No user ID found");
        return false;
      }
      const settings = await this.pushService.getNotificationSettings();
      if (!settings) {
        console.warn("⚠️ No notification settings found");
        return false;
      }
      console.log("✅ Notification settings found:", {
        enabled: settings.enabled,
        push_enabled: settings.push_enabled,
        danger_zone_alerts: settings.danger_zone_alerts,
        incident_alerts: settings.incident_alerts
      });
      return true;
    } catch (error) {
      console.error("❌ Error checking notification settings:", error);
      return false;
    }
  }
  // Полный тест всех функций
  async runFullTest() {
    console.log("🧪 Starting full push notification test...");
    console.log("=====================================");
    const results = {
      fcmToken: await this.testFCMTokenStorage(),
      settings: await this.testNotificationSettings(),
      simplePush: await this.testSimplePush(),
      dangerZonePush: await this.testDangerZonePush()
    };
    console.log("=====================================");
    console.log("📊 Test Results:");
    console.log("- FCM Token:", results.fcmToken ? "✅ PASS" : "❌ FAIL");
    console.log("- Settings:", results.settings ? "✅ PASS" : "❌ FAIL");
    console.log("- Simple Push:", results.simplePush ? "✅ PASS" : "❌ FAIL");
    console.log("- Danger Zone Push:", results.dangerZonePush ? "✅ PASS" : "❌ FAIL");
    const allPassed = Object.values(results).every((result) => result);
    console.log("=====================================");
    console.log("🎯 Overall:", allPassed ? "✅ ALL TESTS PASSED" : "❌ SOME TESTS FAILED");
    if (allPassed) {
      console.log("🎉 Push notification system is ready for testing!");
    } else {
      console.log("⚠️ Fix the failing tests before proceeding");
    }
  }
  // Тест только опасных зон
  async testDangerZoneOnly() {
    console.log("🚨 Testing danger zone notifications only...");
    console.log("=====================================");
    const userId = await getCurrentUserId();
    if (!userId) {
      console.error("❌ No user ID found");
      return;
    }
    console.log("👤 User ID:", userId);
    const fcmResult = await this.testFCMTokenStorage();
    const settingsResult = await this.testNotificationSettings();
    const dangerZoneResult = await this.testDangerZonePush();
    console.log("=====================================");
    console.log("📊 Danger Zone Test Results:");
    console.log("- FCM Token:", fcmResult ? "✅ PASS" : "❌ FAIL");
    console.log("- Settings:", settingsResult ? "✅ PASS" : "❌ FAIL");
    console.log("- Danger Zone Push:", dangerZoneResult ? "✅ PASS" : "❌ FAIL");
    const allPassed = fcmResult && settingsResult && dangerZoneResult;
    console.log("=====================================");
    console.log("🎯 Overall:", allPassed ? "✅ ALL TESTS PASSED" : "❌ SOME TESTS FAILED");
  }
}
window.testPushNotifications = async () => {
  const tester = new TestPushNotifications();
  await tester.runFullTest();
};
window.testDangerZone = async () => {
  const tester = new TestPushNotifications();
  await tester.testDangerZoneOnly();
};
const dangerZoneService = DangerZoneMonitoringService.getInstance();
let BackgroundGeolocation;
const initBackgroundGeolocation = async () => {
  if (Capacitor.isNativePlatform()) {
    try {
      const moduleBase = "@capacitor-community/";
      const moduleName = "background-geolocation";
      const modulePath = moduleBase + moduleName;
      const module = await import(
        /* @vite-ignore */
        modulePath
      );
      BackgroundGeolocation = module.BackgroundGeolocation;
    } catch (error) {
      console.log("Background geolocation not available:", error);
    }
  }
};
async function startBackgroundTracking() {
  if (!Capacitor.isNativePlatform()) {
    console.log("Background tracking is only available on native platforms");
    return;
  }
  await initBackgroundGeolocation();
  if (!BackgroundGeolocation) {
    console.log("Background geolocation not available");
    return;
  }
  try {
    const config2 = {
      desiredAccuracy: BackgroundGeolocation.DESIRED_ACCURACY_HIGH,
      stationaryRadius: 50,
      distanceFilter: 100,
      notificationTitle: "RADAR Background Location",
      notificationText: "Enabled",
      debug: true,
      // Sound/vibrate on events (dev only)
      interval: 3e5,
      // 5 min
      fastestInterval: 12e4,
      // 2 min
      activitiesInterval: 1e4
    };
    await BackgroundGeolocation.configure(config2);
    BackgroundGeolocation.on("location", async (location2) => {
      console.log("Background location update:", location2);
      const userId = await getCurrentUserId();
      if (!userId) return;
      const position2 = { latitude: location2.latitude, longitude: location2.longitude };
      await supabase.from("user_locations").upsert({
        user_id: userId,
        last_location: `POINT(${location2.longitude} ${location2.latitude})`,
        updated_at: (/* @__PURE__ */ new Date()).toISOString()
      });
      dangerZoneService.updateUserLocation({
        lat: position2.latitude,
        lng: position2.longitude
      });
    });
    await BackgroundGeolocation.start();
    if (Capacitor.getPlatform() === "android") {
      await BackgroundGeolocation.requestIgnoreBatteryOptimizations();
    }
    console.log("Background tracking started");
  } catch (error) {
    console.error("Error starting background tracking:", error);
  }
}
async function stopBackgroundTracking() {
  if (!Capacitor.isNativePlatform()) return;
  if (!BackgroundGeolocation) {
    console.log("BackgroundGeolocation not available, skipping stop");
    return;
  }
  try {
    await BackgroundGeolocation.stop();
    console.log("Background tracking stopped");
  } catch (error) {
    console.error("Error stopping background tracking:", error);
  }
}
if (Capacitor.isNativePlatform()) {
  (async () => {
    await initBackgroundGeolocation();
    if (!BackgroundGeolocation) return;
    BackgroundGeolocation.on("error", (error) => {
      console.error("BackgroundGeolocation error:", error);
    });
    BackgroundGeolocation.on("authorization", (status) => {
      console.log("Authorization status:", status);
      if (status !== BackgroundGeolocation.AUTHORIZATION_STATUS_GRANTED) {
        BackgroundGeolocation.openSettings();
      }
    });
  })();
}
if (!Capacitor.isNativePlatform()) {
  window.simulateLocation = async (lat, lng) => {
    const userId = await getCurrentUserId();
    if (!userId) return;
    await supabase.from("user_locations").upsert({
      user_id: userId,
      last_location: `POINT(${lng} ${lat})`,
      updated_at: (/* @__PURE__ */ new Date()).toISOString()
    });
    dangerZoneService.updateUserLocation({ lat, lng });
    console.log("Mock location simulated:", { latitude: lat, longitude: lng });
  };
}
const createIncidentsGeoJSON = (incidents2, t2) => {
  return {
    type: "FeatureCollection",
    features: incidents2.map((incident) => {
      const { latitude, longitude, id: id2, title, incident_type, expired_at } = incident;
      return {
        type: "Feature",
        geometry: {
          type: "Point",
          coordinates: [longitude, latitude]
        },
        properties: {
          id: id2,
          title,
          incident_type,
          expired_at
        }
      };
    })
  };
};
const createHistoricalHeatmapGeoJSON = (incidents2) => {
  return {
    type: "FeatureCollection",
    features: incidents2.map((incident) => ({
      type: "Feature",
      geometry: {
        type: "Point",
        coordinates: [incident.longitude, incident.latitude]
      },
      properties: {
        weight: 0.7
        // Assign a fixed, slightly lower weight to historical incidents
      }
    }))
  };
};
const MainScreen$1 = () => {
  const navigate = useNavigate();
  const location2 = useLocation();
  const { t: t2, language } = useLanguage$1();
  useTypedLanguage();
  const { user } = useAuth();
  const { getUserKey } = useOnboarding();
  const { isAdmin, canDeleteIncident } = useUserRole();
  const { stats: notificationStats } = useNotifications();
  const { incidents: rawIncidents, loading: incidentsLoading, refetch, updateIncidentReaction } = useIncidentsRealtime();
  const { historicalIncidents, loading: historicalLoading, error: historicalError } = useHistoricalIncidents();
  const {
    appState,
    setTrafficAnalysisEnabled,
    setTrafficVisible,
    setHeatmapVisible,
    setGeolocationEnabled,
    setUserLocation
  } = useAppState();
  const mapRef = reactExports.useRef(null);
  const geolocateControlRef = reactExports.useRef(null);
  const incidents2 = React.useMemo(() => {
    return rawIncidents.map((incident) => ({
      ...incident,
      type: incident.incident_type,
      location: {
        lat: Number(incident.latitude),
        lng: Number(incident.longitude),
        address: incident.address || `${incident.latitude}, ${incident.longitude}`
      },
      coordinates: {
        latitude: Number(incident.latitude),
        longitude: Number(incident.longitude)
      },
      timestamp: new Date(incident.created_at),
      severity: incident.severity,
      photos: incident.image_url ? [incident.image_url] : [],
      confirm_count: incident.confirm_count || 0,
      reject_count: incident.reject_count || 0,
      user_reaction: incident.user_reaction || null,
      comments: Array(incident.comments_count || 0).fill(null)
      // Создаем массив нужной длины для совместимости
    }));
  }, [rawIncidents]);
  const [selectedFilter, setSelectedFilter] = reactExports.useState("all");
  const [map, setMap] = reactExports.useState(null);
  const [selectedIncident, setSelectedIncident] = reactExports.useState(null);
  const [isDialogOpen, setIsDialogOpen] = reactExports.useState(false);
  const [markers, setMarkers] = reactExports.useState(/* @__PURE__ */ new Map());
  const [isHistoricalVisible, setIsHistoricalVisible] = reactExports.useState(false);
  const [isDangerZonesVisible, setIsDangerZonesVisible] = reactExports.useState(true);
  const [dangerZonesData, setDangerZonesData] = reactExports.useState(null);
  const [notificationFilter, setNotificationFilter] = reactExports.useState("all");
  const [isRadiusDialogOpen, setIsRadiusDialogOpen] = reactExports.useState(false);
  const [alertRadius, setAlertRadius] = reactExports.useState(1e3);
  const [isLegendOpen, setIsLegendOpen] = reactExports.useState(false);
  const [isTrafficAnimating, setIsTrafficAnimating] = reactExports.useState(false);
  reactExports.useState("🚗");
  const [isVibrating, setIsVibrating] = reactExports.useState(false);
  const [isBottomSheetOpen, setIsBottomSheetOpen] = reactExports.useState(true);
  const sheetY = useMotionValue(0);
  useTransform(sheetY, [0, 300], [70, 25]);
  useTransform(sheetY, [0, 300], [30, 75]);
  const [userProfile, setUserProfile] = reactExports.useState({ username: null, avatar_url: null });
  const [isUserMenuOpen, setIsUserMenuOpen] = reactExports.useState(false);
  const [friendRequests, setFriendRequests] = reactExports.useState([]);
  const SHEET_HEIGHT_EXPANDED = 70;
  const isTrafficAnalysisEnabled = appState.isTrafficAnalysisEnabled;
  const isGeolocationEnabled = appState.isGeolocationEnabled;
  const isTrafficVisible = appState.isTrafficVisible;
  const isHeatmapVisible = appState.isHeatmapVisible;
  const userLocation = appState.userLocation;
  reactExports.useEffect(() => {
  }, [isTrafficAnalysisEnabled, isGeolocationEnabled, isTrafficVisible, isHeatmapVisible, userLocation]);
  const [trafficAnalysisService] = reactExports.useState(() => TrafficAnalysisService.getInstance());
  const MAPBOX_TOKEN2 = "pk.eyJ1IjoiaWNyeXB0b2ZyZWFrIiwiYSI6ImNtYnhieGE4cjFhcW8ya3B1NXRreThxZXIifQ.s32qHjkFoiS-Qauyqa6REg";
  const [notifications, setNotifications] = reactExports.useState([]);
  const [dismissedNotifications, setDismissedNotifications] = reactExports.useState(/* @__PURE__ */ new Set());
  const pushService = PushNotificationService.getInstance();
  const dangerZoneMonitor = DangerZoneMonitoringService.getInstance();
  reactExports.useEffect(() => {
    const fetchDangerZones = async () => {
      try {
        const { data: zones, error } = await supabase.from("barrios").select("*").eq("is_danger_zone", true);
        if (error) throw error;
        if (!zones || zones.length === 0) {
          if (false) ;
          return;
        }
        const features = zones.map((zone) => ({
          type: "Feature",
          geometry: {
            type: "Polygon",
            coordinates: zone.geometry.coordinates
          },
          properties: {
            id: zone.id,
            name: zone.name || `Zona de Riesgo #${zone.id}`,
            risk_level: zone.risk_level || "medium"
          }
        }));
        const geoJson = {
          type: "FeatureCollection",
          features
        };
        if (false) ;
        setDangerZonesData(geoJson);
      } catch (error) {
        ErrorLogger.logError("Error loading danger zones:", error);
      }
    };
    if (isDangerZonesVisible) {
      fetchDangerZones();
    }
  }, [isDangerZonesVisible]);
  reactExports.useEffect(() => {
    const loadUserProfile = async () => {
      if (!user) return;
      try {
        const { data, error } = await supabase.from("profiles").select("username, avatar_url").eq("id", user.id).single();
        if (error) {
          console.error("Error loading user profile:", error);
        } else {
          setUserProfile({ username: data?.username || null, avatar_url: data?.avatar_url || null });
        }
      } catch (error) {
        console.error("Error loading user profile:", error);
      }
    };
    loadUserProfile();
  }, [user]);
  reactExports.useEffect(() => {
    const loadFriendRequests = async () => {
      if (!user?.id) return;
      try {
        const userService = UserService.getInstance();
        const requests = await userService.getFriendRequests(user.id);
        setFriendRequests(requests);
      } catch (error) {
        console.error("Error loading friend requests:", error);
      }
    };
    loadFriendRequests();
    const interval = setInterval(loadFriendRequests, 3e4);
    return () => clearInterval(interval);
  }, [user?.id]);
  const handleNewNotifications = reactExports.useCallback((newNotifications) => {
    setNotifications((prev2) => {
      const notificationMap = /* @__PURE__ */ new Map();
      prev2.forEach((n2) => {
        if (!dismissedNotifications.has(n2.id)) {
          notificationMap.set(n2.id, n2);
        }
      });
      newNotifications.forEach((n2) => {
        if (!dismissedNotifications.has(n2.id)) {
          notificationMap.set(n2.id, n2);
        }
      });
      const sorted = Array.from(notificationMap.values()).sort((a2, b2) => b2.timestamp.getTime() - a2.timestamp.getTime()).slice(0, 5);
      return sorted;
    });
  }, [dismissedNotifications]);
  reactExports.useEffect(() => {
    pushService.setTranslationFunction(t2);
    trafficAnalysisService.setTranslationFunction(t2);
    dangerZoneMonitor.setPushService(pushService);
  }, [t2, pushService, trafficAnalysisService, dangerZoneMonitor]);
  reactExports.useEffect(() => {
    const restoreState = async () => {
      if (isTrafficAnalysisEnabled) {
        try {
          await requestNotificationPermission2();
          await pushService.initialize();
        } catch (error) {
          console.error("Failed to restore push notifications:", error);
          toast({
            title: "Ошибка восстановления Push",
            description: error.message,
            variant: "destructive"
          });
        }
      }
    };
    restoreState();
  }, []);
  reactExports.useEffect(() => {
    if (map && isGeolocationEnabled && geolocateControlRef.current) {
      console.log("Восстанавливаем геолокацию...");
      setTimeout(() => {
        if (geolocateControlRef.current) {
          geolocateControlRef.current.trigger();
        }
      }, 1e3);
    }
  }, [map, isGeolocationEnabled]);
  reactExports.useEffect(() => {
    const savedRadius = localStorage.getItem("alertRadius");
    if (savedRadius) {
      setAlertRadius(parseInt(savedRadius));
    }
  }, []);
  reactExports.useEffect(() => {
    let vibrationTimer;
    if (isHeatmapVisible) {
      setIsVibrating(true);
      vibrationTimer = setTimeout(() => {
        setIsVibrating(false);
      }, 5e3);
    } else {
      setIsVibrating(false);
    }
    return () => {
      if (vibrationTimer) {
        clearTimeout(vibrationTimer);
      }
    };
  }, [isHeatmapVisible]);
  reactExports.useEffect(() => {
    if (!isTrafficAnalysisEnabled || !map || !userLocation) return;
    let positionWatcher;
    let analysisInterval;
    const startTrafficAnalysis = () => {
      if (navigator.geolocation) {
        positionWatcher = navigator.geolocation.watchPosition(
          (position2) => {
            const newPosition = {
              lat: position2.coords.latitude,
              lng: position2.coords.longitude
            };
            trafficAnalysisService.updateUserPosition(newPosition);
          },
          (error) => {
            console.error("Ошибка отслеживания позиции:", error);
          },
          {
            enableHighAccuracy: true,
            timeout: 1e4,
            maximumAge: 5e3
          }
        );
      }
      analysisInterval = setInterval(async () => {
        if (trafficAnalysisService.isUserMoving()) {
          await trafficAnalysisService.analyzeTrafficAhead(map, alertRadius);
        }
      }, 3e4);
    };
    startTrafficAnalysis();
    return () => {
      if (positionWatcher) {
        navigator.geolocation.clearWatch(positionWatcher);
      }
      if (analysisInterval) {
        clearInterval(analysisInterval);
      }
    };
  }, [isTrafficAnalysisEnabled, map, userLocation, alertRadius, trafficAnalysisService]);
  const calculateDistance = (lat1, lng1, lat2, lng2) => {
    const R2 = 6371e3;
    const φ1 = lat1 * Math.PI / 180;
    const φ2 = lat2 * Math.PI / 180;
    const Δφ = (lat2 - lat1) * Math.PI / 180;
    const Δλ = (lng2 - lng1) * Math.PI / 180;
    const a2 = Math.sin(Δφ / 2) * Math.sin(Δφ / 2) + Math.cos(φ1) * Math.cos(φ2) * Math.sin(Δλ / 2) * Math.sin(Δλ / 2);
    const c2 = 2 * Math.atan2(Math.sqrt(a2), Math.sqrt(1 - a2));
    return R2 * c2;
  };
  const getIncidentMarkerColor = (type) => {
    switch (type) {
      case "assault":
        return "#dc2626";
      case "traffic_accident":
        return "#b91c1c";
      case "theft":
        return "#ea580c";
      case "vandalism":
        return "#d97706";
      case "suspicious_activity":
        return "#2563eb";
      case "other":
        return "#6b7280";
      default:
        return "#6b7280";
    }
  };
  const updateMapMarkers = (incidentsData) => {
    if (!map) return;
    markers.forEach((marker) => marker.remove());
    const newMarkers = /* @__PURE__ */ new Map();
    const activeIncidentsForMap = incidentsData.filter((incident) => {
      const incidentWithCreatedAt = {
        ...incident,
        created_at: incident.created_at || incident.timestamp.toISOString()
      };
      const activeIncidents = filterActiveIncidents([incidentWithCreatedAt]);
      return activeIncidents.length > 0;
    });
    activeIncidentsForMap.forEach((incident) => {
      const markerColor = getIncidentMarkerColor(incident.type);
      const markerElement = document.createElement("div");
      markerElement.innerHTML = `
        <svg width="30" height="30" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg">
          <circle cx="12" cy="12" r="10" fill="${markerColor}"/>
          <path d="M12 8v4m0 4h.01" stroke="white" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/>
        </svg>
      `;
      markerElement.style.cursor = "pointer";
      const popup = new mapboxgl.Popup({
        offset: 8,
        closeButton: false,
        closeOnClick: true,
        className: "custom-popup"
      }).setHTML(`
          <div style="color: #333; padding: 8px; max-width: 130px; background: white; border-radius: 8px; box-shadow: 0 2px 8px rgba(0,0,0,0.15);">
            <p style="margin: 0 0 3px 0; font-size: 11px; line-height: 1.2;">${incident.title}</p>
                            <p style="margin: 0; font-size: 8px; color: #999;">⏰ ${formatDateTimeAMPM(new Date(incident.timestamp))}</p>
          </div>
        `);
      const marker = new mapboxgl.Marker(markerElement).setLngLat([incident.location.lng, incident.location.lat]).setPopup(popup).addTo(map);
      newMarkers.set(incident.id, marker);
    });
    setMarkers(newMarkers);
  };
  reactExports.useEffect(() => {
    if (!user) return;
    const cleanupService = IncidentCleanupService.getInstance();
    cleanupService.startCleanup(30);
    return () => {
      cleanupService.stopCleanup();
    };
  }, [user]);
  reactExports.useEffect(() => {
    if (map && incidents2.length > 0) {
      updateMapMarkers(incidents2);
    }
  }, [incidents2, map]);
  const checkExpiredIncidentsRealtime = () => {
    const expiredIds = [];
    markers.forEach((marker, id2) => {
      const incident = incidents2.find((inc) => inc.id === id2);
      if (incident && isIncidentExpired(incident)) {
        marker.remove();
        expiredIds.push(id2);
      }
    });
    if (expiredIds.length > 0) {
      const newMarkers = new Map(markers);
      expiredIds.forEach((id2) => newMarkers.delete(id2));
      setMarkers(newMarkers);
    }
  };
  reactExports.useEffect(() => {
    const interval = setInterval(() => {
      checkExpiredIncidentsRealtime();
    }, 6e4);
    return () => clearInterval(interval);
  }, [markers, incidents2]);
  reactExports.useEffect(() => {
    updateHeatmapData();
  }, [incidents2, map, isHeatmapVisible]);
  reactExports.useEffect(() => {
    const handleClickOutside = (event) => {
      if (isLegendOpen && !event.target.closest(".legend-container")) {
        setIsLegendOpen(false);
      }
    };
    document.addEventListener("mousedown", handleClickOutside);
    return () => document.removeEventListener("mousedown", handleClickOutside);
  }, [isLegendOpen]);
  reactExports.useEffect(() => {
  }, []);
  reactExports.useEffect(() => {
    initializeMapbox();
  }, []);
  const initializeMapbox = () => {
    if (!mapRef.current) return;
    mapboxgl.accessToken = MAPBOX_TOKEN2;
    const style2 = document.createElement("style");
    style2.textContent = `
      .custom-popup .mapboxgl-popup-content {
        background: transparent !important;
        padding: 0 !important;
        border-radius: 0 !important;
        box-shadow: none !important;
      }
      .custom-popup .mapboxgl-popup-tip {
        display: none !important;
      }
      .mapboxgl-ctrl-logo, .mapboxgl-ctrl-attrib {
        display: none !important;
      }
      .mapboxgl-ctrl-geolocate,
      .mapboxgl-ctrl-zoom,
      .mapboxgl-ctrl-group,
      .mapboxgl-ctrl-top-left,
      .mapboxgl-ctrl-top-right,
      .mapboxgl-ctrl-bottom-left,
      .mapboxgl-ctrl-bottom-right {
        display: none !important;
      }
    `;
    document.head.appendChild(style2);
    const newMap = new mapboxgl.Map({
      container: mapRef.current,
      style: "mapbox://styles/mapbox/dark-v11",
      center: [-66.8792, 10.491],
      zoom: 15,
      pitch: 0,
      bearing: 0,
      attributionControl: false,
      // Отключаем контрол атрибуции
      preserveDrawingBuffer: true,
      // Сохраняем буфер рисования
      antialias: true,
      // Включаем сглаживание
      maxBounds: [
        [-67.5, 10],
        // Юго-западный угол
        [-66.2, 10.9]
        // Северо-восточный угол
      ]
      // Ограничиваем перемещение картой в районе Каракаса
    });
    newMap.addControl(new mapboxgl.NavigationControl(), "top-right");
    const geolocateControl = new mapboxgl.GeolocateControl({
      positionOptions: {
        enableHighAccuracy: true
      },
      trackUserLocation: true,
      showUserHeading: true
    });
    geolocateControlRef.current = geolocateControl;
    newMap.addControl(geolocateControl, "top-left");
    newMap.scrollZoom.disable();
    newMap.on("load", () => {
      setMap(newMap);
      setTimeout(() => {
        newMap.resize();
        newMap.setCenter([-66.8792, 10.491]);
        newMap.setZoom(15);
      }, 100);
    });
    newMap.on("moveend", () => {
      newMap.getCenter();
      newMap.getZoom();
    });
    geolocateControl.on("geolocate", (e2) => {
      setUserLocation({ lat: e2.coords.latitude, lng: e2.coords.longitude });
      setGeolocationEnabled(true);
    });
    geolocateControl.on("error", (e2) => {
      console.error("Ошибка геолокации:", e2);
    });
  };
  const requestNotificationPermission2 = async () => {
    try {
      if ("Notification" in window) {
        const permission = await Notification.requestPermission();
        if (permission === "granted") {
          const fcmToken = await pushService.initialize();
          if (false) ;
          await Preferences.set({ key: "notificationsEnabled", value: "true" });
        }
      } else {
        if (false) ;
      }
    } catch (error) {
      ErrorLogger.error("Error requesting notification permission:", error);
    }
  };
  const getIncidentTypeColor = (type) => {
    switch (type) {
      case "theft":
        return "bg-warning";
      case "assault":
        return "bg-danger";
      case "vandalism":
        return "bg-orange-500";
      case "suspicious":
        return "bg-yellow-500";
      case "traffic_accident":
        return "bg-red-600";
      default:
        return "bg-gray-500";
    }
  };
  const getSeverityColor = (severity) => {
    switch (severity) {
      case "high":
        return "border-danger text-danger";
      case "medium":
        return "border-warning text-warning";
      case "low":
        return "border-green-500 text-green-500";
      default:
        return "border-gray-500 text-gray-500";
    }
  };
  const createHeatmapData = (incidentsData) => {
    const activeIncidents = incidentsData.filter((incident) => {
      const incidentWithCreatedAt = {
        ...incident,
        created_at: incident.created_at || incident.timestamp.toISOString()
      };
      const activeIncidents2 = filterActiveIncidents([incidentWithCreatedAt]);
      return activeIncidents2.length > 0;
    });
    return {
      type: "geojson",
      data: {
        type: "FeatureCollection",
        features: activeIncidents.map((incident) => ({
          type: "Feature",
          properties: {
            weight: incident.severity === "high" ? 3 : incident.severity === "medium" ? 2 : 1
          },
          geometry: {
            type: "Point",
            coordinates: [incident.location.lng, incident.location.lat]
          }
        }))
      }
    };
  };
  const toggleHeatmap = () => {
    if (!map) return;
    const newHeatmapState = !isHeatmapVisible;
    setHeatmapVisible(newHeatmapState);
    const historicalCircleLayerId = "historical-circles";
    const historicalLabelLayerId = "historical-labels";
    if (newHeatmapState) {
      if (!map.getSource("incidents-heatmap")) {
        map.addSource("incidents-heatmap", createHeatmapData(incidents2));
      }
      if (!map.getLayer("incidents-heatmap-layer")) {
        map.addLayer({
          id: "incidents-heatmap-layer",
          type: "heatmap",
          source: "incidents-heatmap",
          paint: {
            "heatmap-weight": ["get", "weight"],
            "heatmap-intensity": 0.8,
            "heatmap-color": [
              "interpolate",
              ["linear"],
              ["heatmap-density"],
              0,
              "transparent",
              0.2,
              "#3b82f6",
              0.4,
              "#10b981",
              0.6,
              "#f59e0b",
              0.8,
              "#ef4444",
              1,
              "#991b1b"
            ],
            "heatmap-radius": 30,
            "heatmap-opacity": 0.8
          }
        });
      }
      markers.forEach((marker) => marker.getElement().style.display = "none");
      if (map.getLayer(historicalCircleLayerId)) map.setLayoutProperty(historicalCircleLayerId, "visibility", "none");
      if (map.getLayer(historicalLabelLayerId)) map.setLayoutProperty(historicalLabelLayerId, "visibility", "none");
    } else {
      if (map.getLayer("incidents-heatmap-layer")) {
        map.removeLayer("incidents-heatmap-layer");
      }
      if (map.getSource("incidents-heatmap")) {
        map.removeSource("incidents-heatmap");
      }
      markers.forEach((marker) => marker.getElement().style.display = "block");
      if (isHistoricalVisible && map.getLayer(historicalCircleLayerId)) map.setLayoutProperty(historicalCircleLayerId, "visibility", "visible");
      if (isHistoricalVisible && map.getLayer(historicalLabelLayerId)) map.setLayoutProperty(historicalLabelLayerId, "visibility", "visible");
    }
  };
  const updateHeatmapData = () => {
    if (!map || !isHeatmapVisible) return;
    const source = map.getSource("incidents-heatmap");
    if (source) {
      source.setData(createHeatmapData(incidents2).data);
    }
  };
  const toggleTraffic = () => {
    if (!map) return;
    if (!isTrafficVisible) {
      map.setLayoutProperty("mapbox-traffic", "visibility", "visible");
    } else {
      map.setLayoutProperty("mapbox-traffic", "visibility", "none");
    }
    setTrafficVisible(!isTrafficVisible);
  };
  const toggleTrafficPush = async () => {
    const newState = !isTrafficAnalysisEnabled;
    setTrafficAnalysisEnabled(newState);
    if (newState) {
      try {
        await requestNotificationPermission2();
        await pushService.initialize();
        toast({
          title: t2("trafficPushEnabled"),
          description: t2("trafficPushEnabledDesc"),
          duration: 3e3
        });
      } catch (error) {
        console.error("Error enabling push notifications:", error);
        await ErrorLogger.logError(error, "MainScreen.toggleTrafficPush");
        toast({
          title: "Ошибка",
          description: "Не удалось включить push-уведомления",
          variant: "destructive",
          duration: 3e3
        });
      }
    } else {
      toast({
        title: t2("trafficPushDisabled"),
        description: t2("trafficPushDisabledDesc"),
        duration: 3e3
      });
    }
  };
  const filteredIncidents = incidents2.filter((incident) => {
    const incidentWithCreatedAt = {
      ...incident,
      created_at: incident.created_at || incident.timestamp.toISOString()
    };
    const activeIncidents = filterActiveIncidents([incidentWithCreatedAt]);
    if (activeIncidents.length === 0) return false;
    let typeMatch = false;
    if (selectedFilter === "all") {
      typeMatch = true;
    } else if (selectedFilter === "mine") {
      typeMatch = incident.user_id === user?.id;
    } else {
      typeMatch = incident.type === selectedFilter;
    }
    if (!typeMatch) return false;
    if (notificationFilter === "nearby" && userLocation) {
      const distance2 = calculateDistance(
        userLocation.lat,
        userLocation.lng,
        incident.location.lat,
        incident.location.lng
      );
      return distance2 <= alertRadius;
    }
    return true;
  });
  const handleIncidentClick = (incident) => {
    setSelectedIncident(incident);
    setIsDialogOpen(true);
  };
  const handleEditIncident = (incident) => {
    navigate("/report", { state: { editIncident: incident } });
  };
  const handleQuickDeleteIncident = async (incidentId, incidentUserId, event) => {
    if (event) {
      event.stopPropagation();
    }
    if (!canDeleteIncident(incidentUserId)) {
      toast({
        title: "Ошибка доступа",
        description: "У вас нет прав для удаления этого инцидента",
        variant: "destructive"
      });
      return;
    }
    if (window.confirm("Вы уверены, что хотите удалить этот инцидент?")) {
      try {
        const { error } = await supabase.rpc("archive_and_delete_incident", {
          incident_id: incidentId
        });
        if (error) {
          console.error("Error archiving incident:", error);
          toast({
            title: t2("error"),
            description: t2("errorDeletingIncident"),
            variant: "destructive"
          });
          return;
        }
        toast({
          title: t2("incidentDeleted"),
          description: t2("incidentDeletedMessage")
        });
        if (map && markers.has(incidentId)) {
          const marker = markers.get(incidentId);
          if (marker) {
            marker.remove();
          }
          const newMarkers = new Map(markers);
          newMarkers.delete(incidentId);
          setMarkers(newMarkers);
        }
        refetch();
      } catch (error) {
        console.error("Error archiving incident:", error);
        toast({
          title: "Ошибка",
          description: "Не удалось удалить инцидент",
          variant: "destructive"
        });
      }
    }
  };
  const dismissNotification = (notificationId) => {
    setDismissedNotifications((prev2) => new Set(prev2).add(notificationId));
    setNotifications((prev2) => prev2.filter((n2) => n2.id !== notificationId));
  };
  const flyToLocation = (lat, lng) => {
    if (map) {
      map.flyTo({
        center: [lng, lat],
        zoom: 16,
        duration: 2e3
      });
    }
  };
  const handleRadiusChange = () => {
    const savedRadius = localStorage.getItem("alertRadius");
    if (savedRadius) {
      setAlertRadius(parseInt(savedRadius));
    }
  };
  const formatDistance = (meters) => {
    if (meters >= 1e3) {
      return `${(meters / 1e3).toFixed(1)} km`;
    }
    return `${meters} m`;
  };
  const sheetRef = reactExports.useRef(null);
  const currentAnimeRef = reactExports.useRef(null);
  const toggleBottomSheet = () => {
    const newState = !isBottomSheetOpen;
    setIsBottomSheetOpen(newState);
    const targetY = newState ? 0 : 300;
    animateSheetToPosition(targetY);
  };
  const animateSheetToPosition = (targetY, duration2 = 400) => {
    if (currentAnimeRef.current) {
      currentAnimeRef.current.pause();
    }
    const currentY = sheetY.get();
    const animationTarget2 = { y: currentY };
    currentAnimeRef.current = animate(animationTarget2, {
      y: targetY,
      duration: duration2,
      easing: "easeOutCubic",
      update: () => {
        sheetY.set(animationTarget2.y);
      },
      complete: () => {
        currentAnimeRef.current = null;
      }
    });
  };
  const handleSheetDrag = (event, info) => {
    if (currentAnimeRef.current) {
      currentAnimeRef.current.pause();
      currentAnimeRef.current = null;
    }
    const currentY = info.offset.y;
    const constrainedY = Math.max(0, Math.min(300, currentY));
    sheetY.set(constrainedY);
  };
  const handleSheetDragEnd = (event, info) => {
    const currentY = sheetY.get();
    const velocity = info.velocity.y;
    const dragDistance = Math.abs(info.offset.y);
    let targetY;
    let animationDuration;
    if (dragDistance < 30) {
      targetY = isBottomSheetOpen ? 0 : 300;
      animationDuration = 200;
    } else {
      if (Math.abs(velocity) > 800) {
        targetY = velocity > 0 ? 300 : 0;
        animationDuration = Math.max(200, 400 - Math.abs(velocity) * 0.1);
      } else {
        targetY = currentY > 150 ? 300 : 0;
        animationDuration = 350;
      }
    }
    const shouldOpen = targetY === 0;
    if (shouldOpen !== isBottomSheetOpen) {
      setIsBottomSheetOpen(shouldOpen);
    }
    animateSheetToPosition(targetY, animationDuration);
  };
  reactExports.useEffect(() => {
    if (map) {
      const timeoutId = setTimeout(() => {
        map.resize();
        const currentCenter = map.getCenter();
        const currentZoom = map.getZoom();
        const caracasCenter = [-66.8792, 10.491];
        const distance2 = Math.sqrt(
          Math.pow(currentCenter.lng - caracasCenter[0], 2) + Math.pow(currentCenter.lat - caracasCenter[1], 2)
        );
        if (distance2 > 0.1 && currentZoom < 10) {
          console.log("🗺️ Восстанавливаем центр карты");
          map.setCenter(caracasCenter);
          map.setZoom(15);
        }
      }, 100);
      return () => clearTimeout(timeoutId);
    }
  }, [map, isBottomSheetOpen]);
  reactExports.useEffect(() => {
    if (map) {
      const handleResize = () => {
        setTimeout(() => {
          map.resize();
          const container = map.getContainer();
          const rect = container.getBoundingClientRect();
          if (rect.width > 0 && rect.height > 0) {
            map.resize();
          }
        }, 150);
      };
      window.addEventListener("resize", handleResize);
      document.addEventListener("visibilitychange", handleResize);
      const observer = new IntersectionObserver((entries) => {
        entries.forEach((entry) => {
          if (entry.isIntersecting && entry.target === map.getContainer()) {
            handleResize();
          }
        });
      });
      observer.observe(map.getContainer());
      return () => {
        window.removeEventListener("resize", handleResize);
        document.removeEventListener("visibilitychange", handleResize);
        observer.disconnect();
      };
    }
  }, [map]);
  reactExports.useEffect(() => {
  }, [isTrafficAnalysisEnabled, isGeolocationEnabled, isTrafficVisible, isHeatmapVisible, userLocation]);
  reactExports.useEffect(() => {
  }, [selectedFilter, isHistoricalVisible, isDangerZonesVisible, notificationFilter, alertRadius]);
  reactExports.useEffect(() => {
    if (location2.state?.refreshIncidents) {
      refetch();
      navigate(".", { replace: true, state: null });
    }
  }, [location2.state, refetch, navigate]);
  const toggleHistorical = () => {
    setIsHistoricalVisible((prev2) => !prev2);
  };
  const toggleDangerZones = () => {
    setIsDangerZonesVisible((prev2) => !prev2);
  };
  reactExports.useEffect(() => {
    if (!map || !dangerZonesData) return;
    const sourceId = "danger-zones-source";
    const fillLayerId = "danger-zones-fill";
    const lineLayerId = "danger-zones-line";
    const source = map.getSource(sourceId);
    if (map.getLayer(fillLayerId)) map.removeLayer(fillLayerId);
    if (map.getLayer(lineLayerId)) map.removeLayer(lineLayerId);
    if (source) map.removeSource(sourceId);
    if (isDangerZonesVisible) {
      map.addSource(sourceId, {
        type: "geojson",
        data: dangerZonesData
      });
      map.addLayer({
        id: fillLayerId,
        type: "fill",
        source: sourceId,
        paint: {
          "fill-color": "#dc2626",
          // Красный цвет
          "fill-opacity": 0.3
        }
      });
      map.addLayer({
        id: lineLayerId,
        type: "line",
        source: sourceId,
        paint: {
          "line-color": "#dc2626",
          "line-width": 1
        }
      });
    }
  }, [map, isDangerZonesVisible, dangerZonesData]);
  const updateHistoricalMarkers = reactExports.useCallback((map2, incidents22, t22) => {
    const sourceId = "historical-incidents";
    const circleLayerId = "historical-circles";
    const labelLayerId = "historical-labels";
    const geojsonData = createIncidentsGeoJSON(incidents22);
    const source = map2.getSource(sourceId);
    if (source) {
      source.setData(geojsonData);
    } else {
      map2.addSource(sourceId, { type: "geojson", data: geojsonData });
    }
    if (!map2.getLayer(circleLayerId)) {
      map2.addLayer({
        id: circleLayerId,
        type: "circle",
        source: sourceId,
        paint: {
          "circle-color": ["match", ["get", "incident_type"], "theft", "#FFC300", "assault", "#FF5733", "vandalism", "#C70039", "suspicious", "#900C3F", "traffic_accident", "#581845", "#AAAAAA"],
          "circle-radius": ["interpolate", ["linear"], ["zoom"], 12, 1, 16, 8],
          "circle-stroke-width": 2,
          "circle-stroke-color": "#ffffff",
          "circle-opacity": ["interpolate", ["linear"], ["zoom"], 12, 0, 13, 0.7],
          "circle-stroke-opacity": ["interpolate", ["linear"], ["zoom"], 12, 0, 13, 1]
        }
      });
    }
    if (!map2.getLayer(labelLayerId)) {
      map2.addLayer({
        id: labelLayerId,
        type: "symbol",
        source: sourceId,
        layout: {
          "icon-image": "historical-clock",
          "icon-size": ["interpolate", ["linear"], ["zoom"], 12, 0.2, 16, 0.4],
          "icon-allow-overlap": true
        },
        paint: {
          "icon-opacity": ["interpolate", ["linear"], ["zoom"], 12, 0, 13, 1]
        }
      });
    }
    map2.setLayoutProperty(circleLayerId, "visibility", "visible");
    map2.setLayoutProperty(labelLayerId, "visibility", "visible");
  }, []);
  const clearHistoricalMarkers = reactExports.useCallback((map2) => {
    const layers = ["historical-circles", "historical-labels"];
    const sources = ["historical-incidents"];
    layers.forEach((id2) => {
      if (map2.getLayer(id2)) map2.removeLayer(id2);
    });
    sources.forEach((id2) => {
      if (map2.getSource(id2)) map2.removeSource(id2);
    });
  }, []);
  const updateHistoricalHeatmap = reactExports.useCallback((map2, incidents22, visible) => {
    const sourceId = "historical-heatmap-source";
    const layerId = "historical-heatmap";
    if (!visible) {
      if (map2.getLayer(layerId)) map2.removeLayer(layerId);
      if (map2.getSource(sourceId)) map2.removeSource(sourceId);
      return;
    }
    const geojsonData = createHistoricalHeatmapGeoJSON(incidents22);
    const source = map2.getSource(sourceId);
    if (source) {
      source.setData(geojsonData);
    } else {
      map2.addSource(sourceId, { type: "geojson", data: geojsonData });
    }
    if (!map2.getLayer(layerId)) {
      map2.addLayer({
        id: layerId,
        type: "heatmap",
        source: sourceId,
        maxzoom: 15,
        paint: {
          "heatmap-weight": ["get", "weight"],
          "heatmap-intensity": ["interpolate", ["linear"], ["zoom"], 11, 1, 15, 3],
          "heatmap-color": ["interpolate", ["linear"], ["heatmap-density"], 0, "rgba(33,102,172,0)", 0.2, "rgb(103,169,207)", 0.4, "rgb(209,229,240)", 0.6, "rgb(253,219,199)", 0.8, "rgb(239,138,98)", 1, "rgb(178,24,43)"],
          "heatmap-radius": ["interpolate", ["linear"], ["zoom"], 11, 15, 15, 20],
          "heatmap-opacity": ["interpolate", ["linear"], ["zoom"], 12, 1, 15, 0]
        }
      }, "waterway-label");
    }
    map2.setLayoutProperty(layerId, "visibility", isHeatmapVisible ? "visible" : "none");
  }, [isHeatmapVisible]);
  reactExports.useEffect(() => {
    if (map && historicalIncidents.length > 0) {
      if (isHistoricalVisible) {
        updateHistoricalMarkers(map, historicalIncidents, t2);
        updateHistoricalHeatmap(map, historicalIncidents, true);
      } else {
        clearHistoricalMarkers(map);
        updateHistoricalHeatmap(map, historicalIncidents, false);
      }
    }
  }, [map, isHistoricalVisible, historicalIncidents, t2, updateHistoricalMarkers, clearHistoricalMarkers, updateHistoricalHeatmap]);
  reactExports.useEffect(() => {
    if (!map) return;
    const handleHistoricalClick = (e2) => {
      if (e2.features && e2.features.length > 0) {
        const feature2 = e2.features[0];
        const properties2 = feature2.properties;
        const coordinates = feature2.geometry.coordinates.slice();
        while (Math.abs(e2.lngLat.lng - coordinates[0]) > 180) {
          coordinates[0] += e2.lngLat.lng > coordinates[0] ? 360 : -360;
        }
        const getTypeLabel2 = (type) => {
          switch (type) {
            case "theft":
              return t2("theft", "Theft");
            case "assault":
              return t2("assault", "Assault");
            case "vandalism":
              return t2("vandalism", "Vandalism");
            case "suspicious":
              return t2("suspicious", "Suspicious Activity");
            case "traffic_accident":
              return t2("traffic_accident", "Traffic Accident");
            case "other":
              return t2("other", "Other");
            default:
              return type;
          }
        };
        const typeLabel = getTypeLabel2(properties2.incident_type);
        const date = new Date(properties2.expired_at);
        const formattedDate = !isNaN(date.getTime()) ? date.toLocaleDateString() + " " + date.toLocaleTimeString([], { hour: "2-digit", minute: "2-digit" }) : "N/A";
        const typeLabelText = language === "ru" ? "Тип" : "Type";
        const dateLabelText = language === "ru" ? "Дата" : "Date";
        const content = `
          <h3>${properties2.title}</h3>
          <p><strong>${typeLabelText}:</strong> ${typeLabel}</p>
          <p><strong>${dateLabelText}:</strong> ${formattedDate}</p>
        `;
        new mapboxgl.Popup({ className: "historical-popup" }).setLngLat(coordinates).setHTML(content).addTo(map);
      }
    };
    const layerId = "historical-circles";
    const onMouseEnter = () => {
      if (map) map.getCanvas().style.cursor = "pointer";
    };
    const onMouseLeave = () => {
      if (map) map.getCanvas().style.cursor = "";
    };
    map.on("click", layerId, handleHistoricalClick);
    map.on("mouseenter", layerId, onMouseEnter);
    map.on("mouseleave", layerId, onMouseLeave);
    return () => {
      map.off("click", layerId, handleHistoricalClick);
      map.off("mouseenter", layerId, onMouseEnter);
      map.off("mouseleave", layerId, onMouseLeave);
    };
  }, [map, t2, language, formatDateTimeAMPM]);
  reactExports.useEffect(() => {
    t2("Type");
    t2("dateLabel");
  }, [t2]);
  reactExports.useEffect(() => {
    if (userLocation && isGeolocationEnabled) {
      if (typeof userLocation.lat === "number" && typeof userLocation.lng === "number") {
        dangerZoneMonitor.updateUserLocation(userLocation);
        dangerZoneMonitor.startMonitoring(userLocation);
      } else {
        console.warn("⚠️ Cannot start monitoring: UserLocation has invalid coordinates:", userLocation);
      }
    } else {
      dangerZoneMonitor.stopMonitoring();
    }
  }, [userLocation]);
  const [wasGeolocationActive, setWasGeolocationActive] = reactExports.useState(false);
  const [geoError, setGeoError] = reactExports.useState(false);
  const [geoState, setGeoState] = reactExports.useState("inactive");
  reactExports.useEffect(() => {
    if (isGeolocationEnabled) {
      setWasGeolocationActive(true);
    } else if (wasGeolocationActive) {
      setWasGeolocationActive(false);
    }
  }, [isGeolocationEnabled, wasGeolocationActive]);
  reactExports.useEffect(() => {
    if (!geolocateControlRef.current) return;
    const control = geolocateControlRef.current;
    const updateState = () => {
      const state = control._watchState;
      if (geoError) {
        setGeoState("error");
      } else if (state === "OFF") {
        setGeoState("inactive");
      } else if (state === "WAITING_ACTIVE") {
        setGeoState("searching");
      } else if (state === "ACTIVE_LOCK" || state === "BACKGROUND") {
        setGeoState("active");
      } else {
        setGeoState("inactive");
      }
    };
    const handleTrackStart = () => {
      setGeoError(false);
      updateState();
    };
    const handleTrackEnd = () => {
      setWasGeolocationActive(false);
      updateState();
    };
    const handleGeolocate = () => {
      setWasGeolocationActive(true);
      setGeoError(false);
      updateState();
    };
    const handleError = () => {
      setWasGeolocationActive(false);
      setGeoError(true);
      setGeoState("error");
    };
    control.on("trackuserlocationstart", handleTrackStart);
    control.on("trackuserlocationend", handleTrackEnd);
    control.on("geolocate", handleGeolocate);
    control.on("error", handleError);
    updateState();
    return () => {
      control.off("trackuserlocationstart", handleTrackStart);
      control.off("trackuserlocationend", handleTrackEnd);
      control.off("geolocate", handleGeolocate);
      control.off("error", handleError);
    };
  }, [geolocateControlRef.current, geoError]);
  const handleCustomGeolocateClick = () => {
    const control = geolocateControlRef.current;
    if (!control) {
      alert("Mapbox GeolocateControl не инициализирован!");
      return;
    }
    control.trigger();
  };
  reactExports.useEffect(() => {
    if (!map) return;
    const hideGeolocate = () => {
      const el = document.querySelector(".mapboxgl-ctrl-geolocate");
      if (el) el.style.display = "none";
    };
    hideGeolocate();
    const observer = new MutationObserver(() => {
      hideGeolocate();
    });
    const mapContainer = map.getContainer();
    observer.observe(mapContainer, { childList: true, subtree: true });
    const t1 = setTimeout(hideGeolocate, 1e3);
    const t22 = setTimeout(hideGeolocate, 2e3);
    return () => {
      observer.disconnect();
      clearTimeout(t1);
      clearTimeout(t22);
    };
  }, [map]);
  reactExports.useEffect(() => {
    if (!map) return;
    const hideZoom = () => {
      const el = document.querySelector(".mapboxgl-ctrl-zoom");
      if (el) el.style.display = "none";
    };
    hideZoom();
    const observer = new MutationObserver(() => {
      hideZoom();
    });
    const mapContainer = map.getContainer();
    observer.observe(mapContainer, { childList: true, subtree: true });
    const t1 = setTimeout(hideZoom, 1e3);
    const t22 = setTimeout(hideZoom, 2e3);
    return () => {
      observer.disconnect();
      clearTimeout(t1);
      clearTimeout(t22);
    };
  }, [map]);
  reactExports.useEffect(() => {
    restorePermissions();
  }, []);
  reactExports.useEffect(() => {
    if (userLocation && isGeolocationEnabled) {
      if (typeof userLocation.lat === "number" && typeof userLocation.lng === "number") {
        console.log("🔍 Запускаем мониторинг опасных зон для позиции:", userLocation);
        dangerZoneMonitor.startMonitoring(userLocation);
        dangerZoneMonitor.updateUserLocation(userLocation);
      } else {
        console.warn("⚠️ Cannot start monitoring: UserLocation has invalid coordinates:", userLocation);
      }
    } else {
      console.log("⏹️ Останавливаем мониторинг опасных зон");
      dangerZoneMonitor.stopMonitoring();
    }
  }, [userLocation, isGeolocationEnabled, dangerZoneMonitor]);
  const restorePermissions = async () => {
    try {
      if (false) ;
      const { value: locationEnabled } = await Preferences.get({ key: "locationEnabled" });
      if (locationEnabled === "true") {
        setGeolocationEnabled(true);
        const position2 = await Geolocation.getCurrentPosition({
          enableHighAccuracy: true,
          timeout: 1e4,
          maximumAge: 6e4
        });
        if (position2) {
          setUserLocation({
            lat: position2.coords.latitude,
            lng: position2.coords.longitude
          });
        }
      }
      const { value: notificationsEnabled } = await Preferences.get({ key: "notificationsEnabled" });
      if (notificationsEnabled === "true") {
        await PushNotificationService.getInstance().initialize();
      }
      const { value: trafficEnabled } = await Preferences.get({ key: "trafficEnabled" });
      if (trafficEnabled === "true") {
        setTrafficAnalysisEnabled(true);
      }
    } catch (error) {
      ErrorLogger.logError("Error restoring permissions:", error);
    }
  };
  reactExports.useEffect(() => {
    const initPushNotifications = async () => {
      if (await requestNotificationPermission2()) {
        const token2 = await getFCMToken$1();
        if (token2) await uploadFCMTokenToSupabase();
      }
    };
    initPushNotifications();
    const unsubscribe = setupForegroundHandler((message) => {
      const title = message.notification?.title || "Notification";
      const body = message.notification?.body || "";
      toast({ title, description: body, variant: "default" });
    });
    return () => unsubscribe();
  }, []);
  reactExports.useEffect(() => {
    if (!user || !isGeolocationEnabled || Capacitor.getPlatform() !== "android") return;
    startBackgroundTracking();
    return () => {
      stopBackgroundTracking();
    };
  }, [user, isGeolocationEnabled]);
  reactExports.useEffect(() => {
    const notificationStatus = localStorage.getItem(getUserKey("notification_permission_status"));
    if (notificationStatus === "granted") {
      const setupHandler = async () => {
        const unsubscribe = setupForegroundHandler((message) => {
          const title = message.notification?.title || "Notification";
          const body = message.notification?.body || "";
          toast({ title, description: body, variant: "default" });
        });
        return unsubscribe;
      };
      setupHandler();
    }
  }, []);
  reactExports.useEffect(() => {
    if (map) {
      const restoreMapOnReturn = () => {
        setTimeout(() => {
          console.log("🔄 Восстанавливаем карту при возврате на MainScreen");
          map.resize();
          if (!userLocation || !isGeolocationEnabled) {
            map.setCenter([-66.8792, 10.491]);
            map.setZoom(15);
          } else {
            map.setCenter([userLocation.lng, userLocation.lat]);
            map.setZoom(16);
          }
        }, 200);
      };
      restoreMapOnReturn();
    }
  }, []);
  reactExports.useEffect(() => {
    if (map && location2.pathname === "/") {
      setTimeout(() => {
        console.log("🗺️ Восстанавливаем карту после перехода на главный экран");
        map.resize();
      }, 100);
    }
  }, [location2.pathname, map]);
  const recenterMap = reactExports.useCallback(() => {
    if (!map) return;
    const caracasCenter = [-66.8792, 10.491];
    if (userLocation && isGeolocationEnabled) {
      console.log("🎯 Центрируем карту на пользователе:", userLocation);
      map.flyTo({
        center: [userLocation.lng, userLocation.lat],
        zoom: 16,
        duration: 1e3,
        essential: true
      });
    } else {
      console.log("🏙️ Центрируем карту на Каракасе");
      map.flyTo({
        center: caracasCenter,
        zoom: 15,
        duration: 1e3,
        essential: true
      });
    }
  }, [map, userLocation, isGeolocationEnabled]);
  reactExports.useEffect(() => {
    if (map) {
      const stabilizeMap = () => {
        map.resize();
        recenterMap();
      };
      const handleVisibilityChange = () => {
        if (!document.hidden && map.getContainer().offsetWidth > 0) {
          setTimeout(stabilizeMap, 100);
        }
      };
      document.addEventListener("visibilitychange", handleVisibilityChange);
      return () => {
        document.removeEventListener("visibilitychange", handleVisibilityChange);
      };
    }
  }, [map, recenterMap]);
  return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "min-h-screen relative overflow-hidden", children: [
    /* @__PURE__ */ jsxRuntimeExports.jsxs(
      "div",
      {
        className: "relative map-container",
        style: {
          height: "100vh"
        },
        children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            "div",
            {
              ref: mapRef,
              className: "w-full h-full",
              style: { minHeight: "256px" }
            }
          ),
          /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "absolute left-3 bottom-[50vh] z-10 legend-container flex flex-col space-y-2", children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx(
              Button$1,
              {
                variant: "ghost",
                size: "sm",
                onClick: handleCustomGeolocateClick,
                className: `map-control-button p-3 rounded-lg shadow-md flex items-center justify-center
              ${geoState === "searching" ? "bg-blue-600/30 animate-blink" : geoState === "active" ? "bg-blue-600/30" : "bg-neutral-800"}
            `,
                style: { position: "relative", zIndex: 1e4 },
                children: /* @__PURE__ */ jsxRuntimeExports.jsx(
                  "span",
                  {
                    className: geoState === "error" ? "text-red-400 animate-shake" : geoState === "active" || geoState === "searching" ? "text-blue-400" : "text-white",
                    children: /* @__PURE__ */ jsxRuntimeExports.jsx(Target, { className: "w-5 h-5" })
                  }
                )
              }
            ),
            /* @__PURE__ */ jsxRuntimeExports.jsx(
              Button$1,
              {
                variant: "ghost",
                size: "lg",
                onClick: () => setIsLegendOpen(!isLegendOpen),
                className: "map-control-button p-2 rounded-lg shadow-md",
                children: /* @__PURE__ */ jsxRuntimeExports.jsx(Info$1, { className: "w-5 h-5" })
              }
            ),
            /* @__PURE__ */ jsxRuntimeExports.jsx(
              Button$1,
              {
                variant: isHistoricalVisible ? "default" : "ghost",
                size: "sm",
                onClick: toggleHistorical,
                className: `p-2 rounded-lg shadow-md ${isHistoricalVisible ? "bg-purple-600/30 hover:bg-purple-700/30 text-white" : "map-control-button"}`,
                children: /* @__PURE__ */ jsxRuntimeExports.jsxs("svg", { xmlns: "http://www.w3.org/2000/svg", width: "20", height: "20", viewBox: "0 0 24 24", fill: "none", children: [
                  /* @__PURE__ */ jsxRuntimeExports.jsxs("g", { clipPath: "url(#clip0_4418_3876)", children: [
                    /* @__PURE__ */ jsxRuntimeExports.jsx("path", { d: "M15.7099 15.1798L12.6099 13.3298C12.0699 13.0098 11.6299 12.2398 11.6299 11.6098V7.50977", stroke: "#fff", strokeWidth: "1.5", strokeLinecap: "round", strokeLinejoin: "round" }),
                    /* @__PURE__ */ jsxRuntimeExports.jsx("path", { d: "M4 6C2.75 7.67 2 9.75 2 12C2 17.52 6.48 22 12 22C17.52 22 22 17.52 22 12C22 6.48 17.52 2 12 2C10.57 2 9.2 2.3 7.97 2.85", stroke: "#fff", strokeWidth: "1.5", strokeLinecap: "round", strokeLinejoin: "round" })
                  ] }),
                  /* @__PURE__ */ jsxRuntimeExports.jsx("defs", { children: /* @__PURE__ */ jsxRuntimeExports.jsx("clipPath", { id: "clip0_4418_3876", children: /* @__PURE__ */ jsxRuntimeExports.jsx("rect", { width: "24", height: "24", fill: "white" }) }) })
                ] })
              }
            ),
            /* @__PURE__ */ jsxRuntimeExports.jsx(
              Button$1,
              {
                variant: isDangerZonesVisible ? "default" : "ghost",
                size: "sm",
                onClick: toggleDangerZones,
                className: `p-2 rounded-lg shadow-md ${isDangerZonesVisible ? "bg-red-600/30 hover:bg-red-700/30 text-white" : "map-control-button"}`,
                children: /* @__PURE__ */ jsxRuntimeExports.jsx("svg", { xmlns: "http://www.w3.org/2000/svg", viewBox: "0 0 24 24", fill: "currentColor", className: "w-5 h-5", children: /* @__PURE__ */ jsxRuntimeExports.jsx("path", { fillRule: "evenodd", d: "M10.083 2.917a1.5 1.5 0 0 1 1.834 0l6.25 4.375a1.5 1.5 0 0 1 .833 1.34V18a1.5 1.5 0 0 1-1.5 1.5H5.5a1.5 1.5 0 0 1-1.5-1.5V8.632a1.5 1.5 0 0 1 .833-1.34l6.25-4.375Zm2.112 5.395a.75.75 0 0 1-.31.79l-4.25 2.969a.75.75 0 1 1-.864-1.226l4.25-2.969a.75.75 0 0 1 1.174.437Z", clipRule: "evenodd" }) })
              }
            ),
            isLegendOpen && /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "absolute left-full ml-2 bottom-0 incident-types-menu p-2 shadow-lg min-w-36 animate-in slide-in-from-left-2 duration-200", children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "mb-1 font-semibold text-center border-b border-gray-200/10 pb-1", style: { fontSize: "10px" }, children: t2("incidentTypes") }),
              /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "space-y-1", children: [
                /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex items-center space-x-1 incident-type-item", children: [
                  /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "w-2 h-2 rounded-full", style: { backgroundColor: "#dc2626" } }),
                  /* @__PURE__ */ jsxRuntimeExports.jsx("span", { style: { fontSize: "10px" }, children: t2("assault") })
                ] }),
                /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex items-center space-x-1 incident-type-item", children: [
                  /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "w-2 h-2 rounded-full", style: { backgroundColor: "#b91c1c" } }),
                  /* @__PURE__ */ jsxRuntimeExports.jsx("span", { style: { fontSize: "10px" }, children: t2("traffic_accident") })
                ] }),
                /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex items-center space-x-1 incident-type-item", children: [
                  /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "w-2 h-2 rounded-full", style: { backgroundColor: "#ea580c" } }),
                  /* @__PURE__ */ jsxRuntimeExports.jsx("span", { style: { fontSize: "10px" }, children: t2("theft") })
                ] }),
                /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex items-center space-x-1 incident-type-item", children: [
                  /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "w-2 h-2 rounded-full", style: { backgroundColor: "#d97706" } }),
                  /* @__PURE__ */ jsxRuntimeExports.jsx("span", { style: { fontSize: "10px" }, children: t2("vandalism") })
                ] }),
                /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex items-center space-x-1 incident-type-item", children: [
                  /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "w-2 h-2 rounded-full", style: { backgroundColor: "#2563eb" } }),
                  /* @__PURE__ */ jsxRuntimeExports.jsx("span", { style: { fontSize: "10px" }, children: t2("suspicious") })
                ] })
              ] })
            ] })
          ] }),
          location2.pathname === "/main" && /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "absolute top-4 right-4 z-20", children: /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "bg-gradient-to-r from-[#1e2327cc] via-[#1e2327b3] to-[#1e2327cc] opacity-90 backdrop-blur-sm border border-slate-600/50 rounded-xl p-3 shadow-lg hover:shadow-xl transition-all duration-300 hover:glow-effect sm:p-2 sm:rounded-lg", children: /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex items-center space-x-3 sm:space-x-2", children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx(
              ChatNotificationBox,
              {
                unreadCount: notificationStats.unread,
                onNotificationClick: (notification) => {
                  console.log("Notification clicked:", notification);
                }
              }
            ),
            /* @__PURE__ */ jsxRuntimeExports.jsxs(
              Button$1,
              {
                variant: "ghost",
                size: "sm",
                onClick: () => setIsUserMenuOpen(true),
                className: "relative h-8 w-8 p-0 hover:bg-white/10 rounded-full transition-colors",
                children: [
                  /* @__PURE__ */ jsxRuntimeExports.jsxs("svg", { xmlns: "http://www.w3.org/2000/svg", width: "24", height: "24", viewBox: "0 0 24 24", fill: "none", className: "w-5 h-5", children: [
                    /* @__PURE__ */ jsxRuntimeExports.jsxs("g", { clipPath: "url(#clip0_3111_32737)", children: [
                      /* @__PURE__ */ jsxRuntimeExports.jsx("path", { d: "M18 18.86H17.24C16.44 18.86 15.68 19.17 15.12 19.73L13.41 21.42C12.63 22.19 11.36 22.19 10.58 21.42L8.87 19.73C8.31 19.17 7.54 18.86 6.75 18.86H6C4.34 18.86 3 17.53 3 15.89V4.97C3 3.33 4.34 2 6 2H18C19.66 2 21 3.33 21 4.97V15.88C21 17.52 19.66 18.86 18 18.86Z", stroke: "#fff", strokeWidth: "1.5", strokeMiterlimit: "10", strokeLinecap: "round", strokeLinejoin: "round" }),
                      /* @__PURE__ */ jsxRuntimeExports.jsx("path", { d: "M12.0701 8.9498C12.0301 8.9498 11.97 8.9498 11.92 8.9498C10.87 8.9098 10.04 8.0598 10.04 6.9998C10.04 5.9198 10.9101 5.0498 11.9901 5.0498C13.0701 5.0498 13.9401 5.9298 13.9401 6.9998C13.9501 8.0598 13.1201 8.9198 12.0701 8.9498Z", stroke: "#fff", strokeWidth: "1.5", strokeLinecap: "round", strokeLinejoin: "round" }),
                      /* @__PURE__ */ jsxRuntimeExports.jsx("path", { d: "M9.24994 11.96C7.91994 12.85 7.91994 14.3 9.24994 15.19C10.7599 16.2 13.2399 16.2 14.7499 15.19C16.0799 14.3 16.0799 12.85 14.7499 11.96C13.2399 10.96 10.7699 10.96 9.24994 11.96Z", stroke: "#fff", strokeWidth: "1.5", strokeLinecap: "round", strokeLinejoin: "round" })
                    ] }),
                    /* @__PURE__ */ jsxRuntimeExports.jsx("defs", { children: /* @__PURE__ */ jsxRuntimeExports.jsx("clipPath", { id: "clip0_3111_32737", children: /* @__PURE__ */ jsxRuntimeExports.jsx("rect", { width: "24", height: "24", fill: "white" }) }) })
                  ] }),
                  friendRequests.length > 0 && /* @__PURE__ */ jsxRuntimeExports.jsx(
                    Badge,
                    {
                      variant: "destructive",
                      className: "absolute -top-1 -right-1 h-5 w-5 p-0 text-xs flex items-center justify-center rounded-full bg-[#f3533b] text-white border-2 border-white",
                      children: friendRequests.length > 99 ? "99+" : friendRequests.length
                    }
                  )
                ]
              }
            ),
            /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "h-8 w-px bg-white/60 mx-2", style: { minWidth: "1px" } }),
            /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "flex items-center justify-center w-8 h-8 rounded-full overflow-hidden bg-gray-700 border border-gray-600", children: userProfile.avatar_url ? /* @__PURE__ */ jsxRuntimeExports.jsx("img", { src: userProfile.avatar_url, alt: "avatar", className: "w-full h-full object-cover" }) : /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "text-white text-sm font-bold", children: userProfile.username ? userProfile.username.charAt(0).toUpperCase() : "U" }) }),
            /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "text-white text-sm sm:text-xs font-medium ml-2", children: userProfile.username ? `@${userProfile.username}` : "Аноним" }),
            /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "h-8 w-px bg-white/60 mx-2 hidden sm:inline-block", style: { minWidth: "1px" } }),
            /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "flex items-center", children: /* @__PURE__ */ jsxRuntimeExports.jsx(LanguageToggle, {}) })
          ] }) }) })
        ]
      }
    ),
    /* @__PURE__ */ jsxRuntimeExports.jsxs(
      motion.div,
      {
        ref: sheetRef,
        className: "fixed bottom-0 left-0 right-0 bg-card/90 backdrop-blur-sm border-t border-border z-10 rounded-t-3xl shadow-2xl",
        style: {
          height: `${SHEET_HEIGHT_EXPANDED}vh`,
          y: sheetY
        },
        initial: { y: 0 },
        animate: { y: isBottomSheetOpen ? 0 : 300 },
        transition: {
          type: "spring",
          damping: 30,
          // Увеличиваем демпфирование для более плавного движения
          stiffness: 200,
          // Увеличиваем жесткость для более отзывчивого движения
          mass: 1,
          // Стандартная масса для естественного движения
          velocity: 0,
          // Начальная скорость 0 для предотвращения резких движений
          restDelta: 0.01
          // Уменьшаем порог остановки для более точного позиционирования
        },
        drag: "y",
        dragConstraints: { top: 0, bottom: 300 },
        dragElastic: 0,
        dragMomentum: false,
        dragTransition: {
          // Настройки для плавного перетаскивания
          bounceStiffness: 300,
          bounceDamping: 40,
          power: 0.3,
          timeConstant: 200
        },
        onDrag: handleSheetDrag,
        onDragEnd: handleSheetDragEnd,
        children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "w-full py-4 cursor-grab active:cursor-grabbing rounded-t-3xl flex justify-center items-center", children: /* @__PURE__ */ jsxRuntimeExports.jsx(
            motion.div,
            {
              className: "transform -rotate-45 drag-handle-icon",
              whileHover: { scale: 1.1, rotate: -50 },
              whileTap: { scale: 0.9 },
              children: /* @__PURE__ */ jsxRuntimeExports.jsxs("svg", { xmlns: "http://www.w3.org/2000/svg", width: "20", height: "20", viewBox: "0 0 24 24", fill: "none", children: [
                /* @__PURE__ */ jsxRuntimeExports.jsxs("g", { clipPath: "url(#clip0_4418_4043)", children: [
                  /* @__PURE__ */ jsxRuntimeExports.jsx("path", { d: "M19.72 14.9004C18.44 16.3404 16.57 17.2504 14.5 17.2504H3.5", stroke: "#fff", strokeWidth: "1.5", strokeMiterlimit: "10", strokeLinecap: "round", strokeLinejoin: "round" }),
                  /* @__PURE__ */ jsxRuntimeExports.jsx("path", { d: "M9.5 3.25H14.5C18.35 3.25 21.5 6.4 21.5 10.25", stroke: "#fff", strokeWidth: "1.5", strokeMiterlimit: "10", strokeLinecap: "round", strokeLinejoin: "round" }),
                  /* @__PURE__ */ jsxRuntimeExports.jsx("path", { d: "M3.16992 6.75H13.8099C15.8399 6.75 17.4999 8.41 17.4999 10.44C17.4999 12.47 15.8399 14.13 13.8099 14.13H7.99994", stroke: "#fff", strokeWidth: "1.5", strokeMiterlimit: "10", strokeLinecap: "round", strokeLinejoin: "round" }),
                  /* @__PURE__ */ jsxRuntimeExports.jsx("path", { d: "M8.5 10.75H5.5", stroke: "#fff", strokeWidth: "1.5", strokeMiterlimit: "10", strokeLinecap: "round", strokeLinejoin: "round" }),
                  /* @__PURE__ */ jsxRuntimeExports.jsx("path", { d: "M6.5 20.75H2.5", stroke: "#fff", strokeWidth: "1.5", strokeMiterlimit: "10", strokeLinecap: "round", strokeLinejoin: "round" })
                ] }),
                /* @__PURE__ */ jsxRuntimeExports.jsx("defs", { children: /* @__PURE__ */ jsxRuntimeExports.jsx("clipPath", { id: "clip0_4418_4043", children: /* @__PURE__ */ jsxRuntimeExports.jsx("rect", { width: "24", height: "24", fill: "white" }) }) })
              ] })
            }
          ) }),
          /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "px-4 py-2 overflow-y-auto smooth-scroll", style: { height: "calc(100% - 32px)" }, children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "border-b border-border/30 pb-4 mb-4 bg-white/5 rounded-2xl p-4 -mx-4 mx-4", children: /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex flex-col space-y-2", children: [
              /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex items-center justify-between", children: [
                /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex items-center space-x-2", children: [
                  /* @__PURE__ */ jsxRuntimeExports.jsx(Filter, { className: "w-4 h-4 text-white/70" }),
                  /* @__PURE__ */ jsxRuntimeExports.jsxs("span", { className: "text-sm text-white/70", children: [
                    t2("filterAlerts"),
                    ":"
                  ] })
                ] }),
                /* @__PURE__ */ jsxRuntimeExports.jsx(
                  Button$1,
                  {
                    variant: "ghost",
                    size: "sm",
                    onClick: toggleBottomSheet,
                    className: "text-white/70 hover:text-white p-1",
                    children: isBottomSheetOpen ? /* @__PURE__ */ jsxRuntimeExports.jsx("svg", { xmlns: "http://www.w3.org/2000/svg", viewBox: "0 0 24 24", fill: "currentColor", className: "w-4 h-4", children: /* @__PURE__ */ jsxRuntimeExports.jsx("path", { fillRule: "evenodd", d: "M11.47 7.72a.75.75 0 0 1 1.06 0l7.5 7.5a.75.75 0 1 1-1.06 1.06L12 9.31l-6.97 6.97a.75.75 0 0 1-1.06-1.06l7.5-7.5Z", clipRule: "evenodd" }) }) : /* @__PURE__ */ jsxRuntimeExports.jsx("svg", { xmlns: "http://www.w3.org/2000/svg", viewBox: "0 0 24 24", fill: "currentColor", className: "w-4 h-4", children: /* @__PURE__ */ jsxRuntimeExports.jsx("path", { fillRule: "evenodd", d: "M12.53 16.28a.75.75 0 0 1-1.06 0l-7.5-7.5a.75.75 0 0 1 1.06-1.06L12 14.69l6.97-6.97a.75.75 0 1 1 1.06 1.06l-7.5 7.5Z", clipRule: "evenodd" }) })
                  }
                )
              ] }),
              /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex flex-col space-y-2", children: [
                /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex flex-wrap gap-2", children: [
                  /* @__PURE__ */ jsxRuntimeExports.jsx(
                    Button$1,
                    {
                      variant: notificationFilter === "all" ? "default" : "outline",
                      size: "sm",
                      onClick: () => setNotificationFilter("all"),
                      className: notificationFilter === "all" ? "bg-[#4fcbe9] hover:bg-[#4fcbe9]/90 text-white text-xs h-7 flex-shrink-0" : "border-border text-gray-400 hover:text-white text-xs h-7 flex-shrink-0",
                      children: t2("allAlerts")
                    }
                  ),
                  /* @__PURE__ */ jsxRuntimeExports.jsxs(
                    Button$1,
                    {
                      variant: notificationFilter === "nearby" ? "default" : "outline",
                      size: "sm",
                      onClick: () => setNotificationFilter("nearby"),
                      className: notificationFilter === "nearby" ? "bg-[#4fcbe9] hover:bg-[#4fcbe9]/90 text-white text-xs h-7 flex-shrink-0" : "border-border text-gray-400 hover:text-white text-xs h-7 flex-shrink-0",
                      children: [
                        t2("nearbyAlerts"),
                        " (",
                        formatDistance(alertRadius),
                        ")"
                      ]
                    }
                  ),
                  /* @__PURE__ */ jsxRuntimeExports.jsxs(
                    Button$1,
                    {
                      variant: isHeatmapVisible ? "default" : "outline",
                      size: "sm",
                      onClick: toggleHeatmap,
                      className: `${isHeatmapVisible ? "bg-orange-600/30 hover:bg-orange-700/30 text-white" : "border-border text-gray-400 hover:text-white"} text-xs h-7 flex-shrink-0 transition-all duration-200 ${isVibrating ? "animate-pulse" : ""}`,
                      style: {
                        animation: isVibrating ? "vibrate 0.3s infinite linear" : "none"
                      },
                      children: [
                        /* @__PURE__ */ jsxRuntimeExports.jsx("svg", { xmlns: "http://www.w3.org/2000/svg", viewBox: "0 0 24 24", fill: "currentColor", className: "w-4 h-4 mr-1", children: /* @__PURE__ */ jsxRuntimeExports.jsx("path", { fillRule: "evenodd", d: "M12.963 2.286a.75.75 0 0 0-1.071-.136 9.742 9.742 0 0 0-3.539 6.176 7.547 7.547 0 0 1-1.705-1.715.75.75 0 0 0-1.152-.082A9 9 0 1 0 15.68 4.534a7.46 7.46 0 0 1-2.717-2.248ZM15.75 14.25a3.75 3.75 0 1 1-7.313-1.172c.628.465 1.35.81 2.133 1a5.99 5.99 0 0 1 1.925-3.546 3.75 3.75 0 0 1 3.255 3.718Z", clipRule: "evenodd" }) }),
                        t2("heatmap")
                      ]
                    }
                  ),
                  /* @__PURE__ */ jsxRuntimeExports.jsxs(
                    Button$1,
                    {
                      variant: isTrafficVisible ? "default" : "outline",
                      size: "sm",
                      onClick: toggleTraffic,
                      className: `${isTrafficVisible ? "bg-blue-600 hover:bg-blue-700 text-white text-xs h-7 flex-shrink-0" : "border-border text-gray-400 hover:text-white text-xs h-7 flex-shrink-0"} ${isTrafficAnimating ? "traffic-light-animation" : ""}`,
                      children: [
                        /* @__PURE__ */ jsxRuntimeExports.jsx("svg", { xmlns: "http://www.w3.org/2000/svg", viewBox: "0 0 24 24", fill: "currentColor", className: "w-4 h-4 mr-1", children: /* @__PURE__ */ jsxRuntimeExports.jsx("path", { d: "M5,11L6.5,6.5H17.5L19,11M17.5,16A1.5,1.5 0 0,1 16,14.5A1.5,1.5 0 0,1 17.5,13A1.5,1.5 0 0,1 19,14.5A1.5,1.5 0 0,1 17.5,16M6.5,16A1.5,1.5 0 0,1 5,14.5A1.5,1.5 0 0,1 6.5,13A1.5,1.5 0 0,1 8,14.5A1.5,1.5 0 0,1 6.5,16M18.92,6C18.72,5.42 18.16,5 17.5,5H6.5C5.84,5 5.28,5.42 5.08,6L3,12V20A1,1 0 0,0 4,21H5A1,1 0 0,0 6,20V19H18V20A1,1 0 0,0 19,21H20A1,1 0 0,0 21,20V12L18.92,6Z" }) }),
                        t2("traffic")
                      ]
                    }
                  ),
                  /* @__PURE__ */ jsxRuntimeExports.jsxs(
                    Button$1,
                    {
                      variant: isTrafficAnalysisEnabled ? "default" : "outline",
                      size: "sm",
                      onClick: toggleTrafficPush,
                      className: isTrafficAnalysisEnabled ? "bg-blue-600 hover:bg-blue-700 text-white text-xs h-7 flex-shrink-0" : "border-border text-gray-400 hover:text-white text-xs h-7 flex-shrink-0",
                      title: isTrafficAnalysisEnabled ? "Отключить уведомления о пробках" : "Включить уведомления о пробках",
                      children: [
                        isTrafficAnalysisEnabled ? /* @__PURE__ */ jsxRuntimeExports.jsxs("svg", { xmlns: "http://www.w3.org/2000/svg", viewBox: "0 0 24 24", fill: "currentColor", className: "w-4 h-4 mr-1", children: [
                          /* @__PURE__ */ jsxRuntimeExports.jsx("path", { d: "M5.85 3.5a.75.75 0 0 0-1.117-1 9.719 9.719 0 0 0-2.348 4.876.75.75 0 0 0 1.479.248A8.219 8.219 0 0 1 5.85 3.5ZM19.267 2.5a.75.75 0 1 0-1.118 1 8.22 8.22 0 0 1 1.987 4.124.75.75 0 0 0 1.48-.248A9.72 9.72 0 0 0 19.266 2.5Z" }),
                          /* @__PURE__ */ jsxRuntimeExports.jsx("path", { fillRule: "evenodd", d: "M12 2.25A6.75 6.75 0 0 0 5.25 9v.75a8.217 8.217 0 0 1-2.119 5.52.75.75 0 0 0 .298 1.206c1.544.57 3.16.99 4.831 1.243a3.75 3.75 0 1 0 7.48 0 24.583 24.583 0 0 0 4.83-1.244.75.75 0 0 0 .298-1.205 8.217 8.217 0 0 1-2.118-5.52V9A6.75 6.75 0 0 0 12 2.25ZM9.75 18c0-.034 0-.067.002-.1a25.05 25.05 0 0 0 4.496 0l.002.1a2.25 2.25 0 1 1-4.5 0Z", clipRule: "evenodd" })
                        ] }) : /* @__PURE__ */ jsxRuntimeExports.jsxs("svg", { xmlns: "http://www.w3.org/2000/svg", viewBox: "0 0 24 24", fill: "currentColor", className: "w-4 h-4 mr-1", children: [
                          /* @__PURE__ */ jsxRuntimeExports.jsx("path", { d: "M3.53 2.47a.75.75 0 0 0-1.06 1.06l18 18a.75.75 0 1 0 1.06-1.06l-18-18ZM20.57 16.476c-.223.082-.448.161-.674.238L7.319 4.137A6.75 6.75 0 0 1 18.75 9v.75c0 2.123.8 4.057 2.118 5.52a.75.75 0 0 1-.297 1.206Z" }),
                          /* @__PURE__ */ jsxRuntimeExports.jsx("path", { fillRule: "evenodd", d: "M5.25 9c0-.184.007-.366.022-.546l10.384 10.384a3.751 3.751 0 0 1-7.396-1.119 24.585 24.585 0 0 1-4.831-1.244.75.75 0 0 1-.298-1.205A8.217 8.217 0 0 0 5.25 9.75V9Zm4.502 8.9a2.25 2.25 0 1 0 4.496 0 25.057 25.057 0 0 1-4.496 0Z", clipRule: "evenodd" })
                        ] }),
                        "Push"
                      ]
                    }
                  ),
                  /* @__PURE__ */ jsxRuntimeExports.jsxs(
                    Button$1,
                    {
                      variant: isHistoricalVisible ? "default" : "outline",
                      size: "sm",
                      onClick: toggleHistorical,
                      className: isHistoricalVisible ? "bg-purple-600/30 hover:bg-purple-700/30 text-white text-xs h-7 flex-shrink-0" : "border-border text-gray-400 hover:text-white text-xs h-7 flex-shrink-0",
                      children: [
                        /* @__PURE__ */ jsxRuntimeExports.jsxs("svg", { xmlns: "http://www.w3.org/2000/svg", width: "24", height: "24", viewBox: "0 0 24 24", fill: "none", className: "w-4 h-4 mr-1", children: [
                          /* @__PURE__ */ jsxRuntimeExports.jsxs("g", { clipPath: "url(#clip0_4418_3876)", children: [
                            /* @__PURE__ */ jsxRuntimeExports.jsx("path", { d: "M15.7099 15.1798L12.6099 13.3298C12.0699 13.0098 11.6299 12.2398 11.6299 11.6098V7.50977", stroke: "currentColor", strokeWidth: "1.5", strokeLinecap: "round", strokeLinejoin: "round" }),
                            /* @__PURE__ */ jsxRuntimeExports.jsx("path", { d: "M4 6C2.75 7.67 2 9.75 2 12C2 17.52 6.48 22 12 22C17.52 22 22 17.52 22 12C22 6.48 17.52 2 12 2C10.57 2 9.2 2.3 7.97 2.85", stroke: "currentColor", strokeWidth: "1.5", strokeLinecap: "round", strokeLinejoin: "round" })
                          ] }),
                          /* @__PURE__ */ jsxRuntimeExports.jsx("defs", { children: /* @__PURE__ */ jsxRuntimeExports.jsx("clipPath", { id: "clip0_4418_3876", children: /* @__PURE__ */ jsxRuntimeExports.jsx("rect", { width: "24", height: "24", fill: "white" }) }) })
                        ] }),
                        t2("History")
                      ]
                    }
                  )
                ] }),
                /* @__PURE__ */ jsxRuntimeExports.jsxs(
                  motion.div,
                  {
                    onClick: () => setIsRadiusDialogOpen(true),
                    className: "text-white/70 hover:text-white text-xs h-7 w-full sm:w-auto flex items-center justify-center cursor-pointer rounded-lg px-3 py-1 transition-colors duration-200",
                    layout: true,
                    initial: { borderRadius: "8px" },
                    whileHover: {
                      scale: 1.05,
                      backgroundColor: "rgba(255, 255, 255, 0.1)",
                      borderRadius: "12px"
                    },
                    whileTap: {
                      scale: 0.95,
                      backgroundColor: "rgba(255, 255, 255, 0.05)"
                    },
                    transition: {
                      type: "spring",
                      damping: 20,
                      stiffness: 300
                    },
                    children: [
                      /* @__PURE__ */ jsxRuntimeExports.jsx(Target, { className: "w-3 h-3 mr-1" }),
                      t2("radiusSettings")
                    ]
                  }
                )
              ] })
            ] }) }),
            /* @__PURE__ */ jsxRuntimeExports.jsx(
              EnhancedNotifications,
              {
                notifications: notifications.filter((n2) => !dismissedNotifications.has(n2.id)),
                onDismiss: dismissNotification,
                onNotificationClick: flyToLocation
              }
            ),
            /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "p-4", children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "flex justify-between items-center mb-3", children: /* @__PURE__ */ jsxRuntimeExports.jsx("h3", { className: "text-sm font-medium text-white/70", children: t2("filters") }) }),
              /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "flex space-x-2 overflow-x-auto", children: [
                { key: "all", label: t2("filterAll") },
                { key: "mine", label: t2("filterMine") },
                { key: "theft", label: t2("filterTheft") },
                { key: "assault", label: t2("filterAssault") },
                { key: "vandalism", label: t2("filterVandalism") },
                { key: "suspicious", label: t2("filterSuspicious") },
                { key: "traffic_accident", label: t2("filterAccident") }
              ].map((filter2) => /* @__PURE__ */ jsxRuntimeExports.jsx(
                Button$1,
                {
                  variant: selectedFilter === filter2.key ? "default" : "outline",
                  size: "sm",
                  onClick: () => setSelectedFilter(filter2.key),
                  className: selectedFilter === filter2.key ? "bg-[#f3533b] hover:bg-[#f3533b]/90 text-white" : "border-border text-gray-400 hover:text-white",
                  children: filter2.label
                },
                filter2.key
              )) })
            ] }),
            /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "pb-4", children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "flex justify-between items-center mb-4", children: /* @__PURE__ */ jsxRuntimeExports.jsxs("h2", { className: "text-lg font-semibold text-white", children: [
                t2("recentIncidents"),
                " (",
                filteredIncidents.length,
                ")"
              ] }) }),
              /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "space-y-3", children: filteredIncidents.length === 0 ? /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "text-center text-gray-500 py-8", children: [
                /* @__PURE__ */ jsxRuntimeExports.jsx("p", { children: t2("noIncidents") }),
                /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: "text-sm", children: t2("beFirstToReport") })
              ] }) : filteredIncidents.map((incident) => /* @__PURE__ */ jsxRuntimeExports.jsx(
                Card,
                {
                  className: "bg-card/90 border-border cursor-pointer hover:bg-card/70 transition-colors rounded-2xl",
                  style: {
                    borderRadius: "14px"
                  },
                  onClick: () => handleIncidentClick(incident),
                  children: /* @__PURE__ */ jsxRuntimeExports.jsx(CardContent, { className: "p-4", children: /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "space-y-2", children: [
                    /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "flex justify-between items-start mb-2", children: /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex items-center space-x-2 flex-1", children: [
                      /* @__PURE__ */ jsxRuntimeExports.jsx(Badge, { className: `${getIncidentTypeColor(incident.type)} text-white`, children: t2(incident.type) }),
                      /* @__PURE__ */ jsxRuntimeExports.jsx(
                        Badge,
                        {
                          variant: "outline",
                          className: getSeverityColor(incident.severity),
                          children: t2(incident.severity)
                        }
                      ),
                      incident.user_id === user?.id && /* @__PURE__ */ jsxRuntimeExports.jsx(Badge, { variant: "outline", className: "border-blue-500 text-blue-400 text-xs", children: t2("createdByYou") }),
                      canDeleteIncident(incident.user_id) && /* @__PURE__ */ jsxRuntimeExports.jsx(
                        Button$1,
                        {
                          variant: "ghost",
                          size: "icon",
                          className: "h-6 w-6 text-gray-400 hover:text-red-400 hover:bg-red-500/10 ml-2",
                          onClick: (e2) => handleQuickDeleteIncident(incident.id, incident.user_id, e2),
                          children: /* @__PURE__ */ jsxRuntimeExports.jsx(Trash2, { className: "w-3 h-3" })
                        }
                      )
                    ] }) }),
                    /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "flex items-center justify-between mb-2", children: /* @__PURE__ */ jsxRuntimeExports.jsx("h3", { className: "font-semibold text-white", children: incident.title }) }),
                    /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: "text-gray-400 text-sm mb-2", children: incident.description }),
                    /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex items-center justify-between", children: [
                      /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex items-center text-xs text-gray-500", children: [
                        /* @__PURE__ */ jsxRuntimeExports.jsx(MapPin, { className: "w-3 h-3 mr-1" }),
                        incident.location.address
                      ] }),
                      /* @__PURE__ */ jsxRuntimeExports.jsx(
                        MiniMap,
                        {
                          lat: incident.location.lat,
                          lng: incident.location.lng,
                          size: "sm",
                          className: "flex-shrink-0",
                          onClick: (lat, lng) => flyToLocation(lat, lng)
                        }
                      )
                    ] }),
                    /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "mt-2 pt-2 border-t border-border", children: /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "flex items-center justify-between text-xs text-gray-500", children: /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex items-center space-x-4", children: [
                      /* @__PURE__ */ jsxRuntimeExports.jsxs("span", { children: [
                        t2("createdAt"),
                        ": ",
                        formatDateTimeAMPM(new Date(incident.created_at || incident.timestamp))
                      ] }),
                      incident.user_id && /* @__PURE__ */ jsxRuntimeExports.jsx("div", { onClick: (e2) => e2.stopPropagation(), children: /* @__PURE__ */ jsxRuntimeExports.jsx(UserDisplayWrapper, { userId: incident.user_id, size: "xs" }) })
                    ] }) }) }),
                    isAdmin() && /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "mt-2 pt-2 border-t border-border", children: /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex items-center justify-between text-xs text-gray-500", children: [
                      /* @__PURE__ */ jsxRuntimeExports.jsxs("span", { children: [
                        t2("expiresAfter"),
                        " ",
                        INCIDENT_DURATION_LIMITS[incident.type] || 24,
                        " ",
                        t2("hoursShort")
                      ] }),
                      (() => {
                        const incidentWithCreatedAt = {
                          ...incident,
                          created_at: incident.created_at || incident.timestamp.toISOString()
                        };
                        const remainingHours = getRemainingTime(incidentWithCreatedAt);
                        const timeColor = getTimeIndicatorColor(remainingHours, INCIDENT_DURATION_LIMITS[incident.type] || 24);
                        return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: `flex items-center ${timeColor}`, children: [
                          /* @__PURE__ */ jsxRuntimeExports.jsx(Clock$1, { className: "w-3 h-3 mr-1" }),
                          formatRemainingTime(remainingHours, t2),
                          " ",
                          t2("remainingTime")
                        ] });
                      })()
                    ] }) }),
                    /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex items-center gap-3 mt-2 pt-2 border-t border-border text-xs text-gray-500", children: [
                      /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex items-center gap-1", children: [
                        /* @__PURE__ */ jsxRuntimeExports.jsx(ThumbsUp, { className: "w-3.5 h-3.5" }),
                        /* @__PURE__ */ jsxRuntimeExports.jsx("span", { children: incident.confirm_count || 0 })
                      ] }),
                      /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex items-center gap-1", children: [
                        /* @__PURE__ */ jsxRuntimeExports.jsx(ThumbsDown, { className: "w-3.5 h-3.5" }),
                        /* @__PURE__ */ jsxRuntimeExports.jsx("span", { children: incident.reject_count || 0 })
                      ] }),
                      /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex items-center gap-1", children: [
                        /* @__PURE__ */ jsxRuntimeExports.jsx(MessageSquare, { className: "w-3.5 h-3.5" }),
                        /* @__PURE__ */ jsxRuntimeExports.jsx("span", { children: incident.comments?.length || 0 })
                      ] })
                    ] })
                  ] }) })
                },
                incident.id
              )) })
            ] })
          ] })
        ]
      }
    ),
    /* @__PURE__ */ jsxRuntimeExports.jsx(
      IncidentDetailDialog,
      {
        incident: selectedIncident,
        open: isDialogOpen,
        onOpenChange: setIsDialogOpen,
        onEdit: handleEditIncident,
        onDelete: (deletedId) => {
          if (map && markers.has(deletedId)) {
            const marker = markers.get(deletedId);
            if (marker) {
              marker.remove();
            }
            const newMarkers = new Map(markers);
            newMarkers.delete(deletedId);
            setMarkers(newMarkers);
          }
          refetch();
        }
      }
    ),
    /* @__PURE__ */ jsxRuntimeExports.jsx(
      AlertRadiusDialog,
      {
        isOpen: isRadiusDialogOpen,
        onClose: () => {
          setIsRadiusDialogOpen(false);
          handleRadiusChange();
        }
      }
    ),
    /* @__PURE__ */ jsxRuntimeExports.jsx(
      SmartNotifications,
      {
        userLocation,
        alertRadius,
        onNotificationsGenerated: handleNewNotifications,
        showNearbyOnly: notificationFilter === "nearby"
      }
    ),
    /* @__PURE__ */ jsxRuntimeExports.jsx(
      UserMenu,
      {
        isOpen: isUserMenuOpen,
        onClose: () => setIsUserMenuOpen(false)
      }
    )
  ] });
};
const MainScreen$2 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  default: MainScreen$1
}, Symbol.toStringTag, { value: "Module" }));
const MapIcon = () => /* @__PURE__ */ jsxRuntimeExports.jsx("svg", { xmlns: "http://www.w3.org/2000/svg", fill: "none", viewBox: "0 0 24 24", strokeWidth: 1.5, stroke: "currentColor", className: "w-7 h-7", children: /* @__PURE__ */ jsxRuntimeExports.jsx("path", { strokeLinecap: "round", strokeLinejoin: "round", d: "M9 6.75V15m6-6v8.25m.503 3.498 4.875-2.437c.381-.19.622-.58.622-1.006V4.82c0-.836-.88-1.38-1.628-1.006l-3.869 1.934c-.317.159-.69.159-1.006 0L9.503 3.252a1.125 1.125 0 0 0-1.006 0L3.622 5.689C3.24 5.88 3 6.27 3 6.695V19.18c0 .836.88 1.38 1.628 1.006l3.869-1.934c-.317-.159-.69-.159-1.006 0l4.994 2.497c.317.158.69.158 1.006 0Z" }) });
const CommunityIcon = () => /* @__PURE__ */ jsxRuntimeExports.jsx("svg", { xmlns: "http://www.w3.org/2000/svg", fill: "none", viewBox: "0 0 24 24", strokeWidth: 1.5, stroke: "currentColor", className: "w-7 h-7", children: /* @__PURE__ */ jsxRuntimeExports.jsx("path", { strokeLinecap: "round", strokeLinejoin: "round", d: "M20.25 8.511c.884.284 1.5 1.128 1.5 2.097v4.286c0 1.136-.847 2.1-1.98 2.193-.34.027-.68.052-1.02.072v3.091l-3-3c-1.354 0-2.694-.055-4.02-.163a2.115 2.115 0 0 1-.825-.242m9.345-8.334a2.126 2.126 0 0 0-.476-.095 48.64 48.64 0 0 0-8.048 0c-1.131.094-1.976 1.057-1.976 2.192v4.286c0 .837.46 1.58 1.155 1.951m9.345-8.334V6.637c0-1.621-1.152-3.026-2.76-3.235A48.455 48.455 0 0 0 11.25 3c-2.115 0-4.198.137-6.24.402-1.608.209-2.76 1.614-2.76 3.235v6.226c0 1.621 1.152 3.026 2.76 3.235.577.075 1.157.14 1.74.194V21l4.155-4.155" }) });
const ReportIcon = () => /* @__PURE__ */ jsxRuntimeExports.jsx("svg", { xmlns: "http://www.w3.org/2000/svg", viewBox: "0 0 24 24", fill: "currentColor", className: "w-8 h-8", children: /* @__PURE__ */ jsxRuntimeExports.jsx("path", { fillRule: "evenodd", d: "M11.484 2.17a.75.75 0 0 1 1.032 0 11.209 11.209 0 0 0 7.877 3.08.75.75 0 0 1 .722.515 12.74 12.74 0 0 1 .635 3.985c0 5.942-4.064 10.933-9.563 12.348a.749.749 0 0 1-.374 0C6.314 20.683 2.25 15.692 2.25 9.75c0-1.39.223-2.73.635-3.985a.75.75 0 0 1 .722-.516l.143.001c2.996 0 5.718-1.17 7.734-3.08ZM12 8.25a.75.75 0 0 1 .75.75v3.75a.75.75 0 0 1-1.5 0V9a.75.75 0 0 1 .75-.75ZM12 15a.75.75 0 0 0-.75.75v.008c0 .414.336.75.75.75h.008a.75.75 0 0 0 .75-.75v-.008a.75.75 0 0 0-.75-.75H12Z", clipRule: "evenodd" }) });
const ProfileIcon = () => /* @__PURE__ */ jsxRuntimeExports.jsx("svg", { xmlns: "http://www.w3.org/2000/svg", viewBox: "0 0 24 24", fill: "currentColor", className: "w-7 h-7", children: /* @__PURE__ */ jsxRuntimeExports.jsx("path", { fillRule: "evenodd", d: "M11.078 2.25c-.917 0-1.699.663-1.85 1.567L9.05 4.889c-.02.12-.115.26-.297.348a7.493 7.493 0 0 0-.986.57c-.166.115-.334.126-.45.083L6.3 5.508a1.875 1.875 0 0 0-2.282.819l-.922 1.597a1.875 1.875 0 0 0 .432 2.385l.84.692c.095.078.17.229.154.43a7.598 7.598 0 0 0 0 1.139c.015.2-.059.352-.153.43l-.841.692a1.875 1.875 0 0 0-.432 2.385l.922 1.597a1.875 1.875 0 0 0 2.282.818l1.019-.382c.115-.043.283-.031.45.082.312.214.641.405.985.57.182.088.277.228.297.35l.178 1.071c.151.904.933 1.567 1.85 1.567h1.844c.916 0 1.699-.663 1.85-1.567l.178-1.072c.02-.12.114-.26.297-.349.344-.165.673-.356.985-.57.167-.114.335-.125.45-.082l1.02.382a1.875 1.875 0 0 0 2.28-.819l.923-1.597a1.875 1.875 0 0 0-.432-2.385l-.84-.692c-.095-.078-.17-.229-.154-.43a7.614 7.614 0 0 0 0-1.139c-.016-.2.059-.352.153-.43l.84-.692c.708-.582.891-1.59.433-2.385l-.922-1.597a1.875 1.875 0 0 0-2.282-.818l-1.02.382c-.114.043-.282.031-.449-.083a7.49 7.49 0 0 0-.985-.57c-.183-.087-.277-.227-.297-.348l-.179-1.072a1.875 1.875 0 0 0-1.85-1.567h-1.843ZM12 15.75a3.75 3.75 0 1 0 0-7.5 3.75 3.75 0 0 0 0 7.5Z", clipRule: "evenodd" }) });
const BottomNavigation = () => {
  const navigate = useNavigate();
  const location2 = useLocation();
  const { t: t2 } = useLanguage$1();
  const getButtonClass = (path) => {
    return location2.pathname === path ? "text-[#f3533b]" : "text-white hover:text-[#f3533b]/80";
  };
  return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "fixed bottom-4 left-1/2 transform -translate-x-1/2 w-[92%] max-w-[380px] min-w-[320px] mx-auto flex justify-between bg-card/60 rounded-3xl border border-white/20 backdrop-blur-2xl shadow-lg shadow-black/20 z-50", children: [
    /* @__PURE__ */ jsxRuntimeExports.jsxs(
      "button",
      {
        onClick: () => navigate("/main"),
        className: `inline-flex flex-col items-center text-xs font-medium py-3 px-2 flex-1 ${getButtonClass("/main")}`,
        children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx(MapIcon, {}),
          /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "mt-1", children: t2("map") })
        ]
      },
      "main-nav"
    ),
    /* @__PURE__ */ jsxRuntimeExports.jsxs(
      "button",
      {
        onClick: () => navigate("/community"),
        className: `inline-flex flex-col items-center text-xs font-medium py-3 px-2 flex-1 ${getButtonClass("/community")}`,
        children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx(CommunityIcon, {}),
          /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "mt-1", children: t2("community") })
        ]
      },
      "community-nav"
    ),
    /* @__PURE__ */ jsxRuntimeExports.jsx(
      "button",
      {
        onClick: () => navigate("/report"),
        className: "relative inline-flex flex-col items-center text-xs font-medium text-white py-3 px-2 flex-1",
        children: /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "absolute bottom-5 p-3 rounded-full border-4 border-white/20 bg-[#f3533b] hover:bg-[#f3533b]/90 shadow-lg shadow-[#f3533b]/40 animate-pulse-danger", children: /* @__PURE__ */ jsxRuntimeExports.jsx(ReportIcon, {}) })
      },
      "report-nav"
    ),
    /* @__PURE__ */ jsxRuntimeExports.jsxs(
      "button",
      {
        onClick: () => navigate("/wanted"),
        className: `inline-flex flex-col items-center text-xs font-medium py-3 px-2 flex-1 ${getButtonClass("/wanted")}`,
        children: [
          /* @__PURE__ */ jsxRuntimeExports.jsxs("svg", { xmlns: "http://www.w3.org/2000/svg", width: "24", height: "24", viewBox: "0 0 24 24", fill: "none", className: "w-7 h-7", children: [
            /* @__PURE__ */ jsxRuntimeExports.jsxs("g", { clipPath: "url(#clip0_3111_32745)", children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx("path", { d: "M12 12C14.7614 12 17 9.76142 17 7C17 4.23858 14.7614 2 12 2C9.23858 2 7 4.23858 7 7C7 9.76142 9.23858 12 12 12Z", stroke: "currentColor", strokeWidth: "1.5", strokeLinecap: "round", strokeLinejoin: "round" }),
              /* @__PURE__ */ jsxRuntimeExports.jsx("path", { d: "M3.41016 22C3.41016 18.13 7.26018 15 12.0002 15", stroke: "currentColor", strokeWidth: "1.5", strokeLinecap: "round", strokeLinejoin: "round" }),
              /* @__PURE__ */ jsxRuntimeExports.jsx("path", { d: "M18.2 21.4C19.9673 21.4 21.4 19.9673 21.4 18.2C21.4 16.4327 19.9673 15 18.2 15C16.4327 15 15 16.4327 15 18.2C15 19.9673 16.4327 21.4 18.2 21.4Z", stroke: "currentColor", strokeWidth: "1.5", strokeLinecap: "round", strokeLinejoin: "round" }),
              /* @__PURE__ */ jsxRuntimeExports.jsx("path", { d: "M22 22L21 21", stroke: "currentColor", strokeWidth: "1.5", strokeLinecap: "round", strokeLinejoin: "round" })
            ] }),
            /* @__PURE__ */ jsxRuntimeExports.jsx("defs", { children: /* @__PURE__ */ jsxRuntimeExports.jsx("clipPath", { id: "clip0_3111_32745", children: /* @__PURE__ */ jsxRuntimeExports.jsx("rect", { width: "24", height: "24", fill: "white" }) }) })
          ] }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "mt-1", children: t2("wanted") })
        ]
      },
      "wanted-nav"
    ),
    /* @__PURE__ */ jsxRuntimeExports.jsxs(
      "button",
      {
        onClick: () => navigate("/profile"),
        className: `inline-flex flex-col items-center text-xs font-medium py-3 px-2 flex-1 ${getButtonClass("/profile")}`,
        children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx(ProfileIcon, {}),
          /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "mt-1", children: t2("profile") })
        ]
      },
      "profile-nav"
    )
  ] });
};
const OptimizedPersistentLayout = reactExports.memo(() => {
  const location2 = useLocation();
  const previousLocationRef = reactExports.useRef(location2.pathname);
  const isMainRoute = location2.pathname === "/main";
  const routeVisibility = reactExports.useMemo(() => {
    return {
      isMainVisible: isMainRoute,
      isOverlayVisible: !isMainRoute,
      shouldShowOutlet: !isMainRoute
    };
  }, [isMainRoute]);
  reactExports.useEffect(() => {
    if (previousLocationRef.current !== location2.pathname) {
      console.log(`🚀 Navigation: ${previousLocationRef.current} → ${location2.pathname}`);
      previousLocationRef.current = location2.pathname;
    }
  }, [location2.pathname]);
  const overlayVariants = reactExports.useMemo(() => ({
    hidden: {
      opacity: 0,
      y: 20
    },
    visible: {
      opacity: 1,
      y: 0
    },
    exit: {
      opacity: 0,
      y: -10
    }
  }), []);
  const memoizedBottomNavigation = reactExports.useMemo(() => /* @__PURE__ */ jsxRuntimeExports.jsx(BottomNavigation, {}), []);
  const handleAnimationComplete = reactExports.useCallback(() => {
  }, []);
  return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "relative w-full h-full min-h-screen bg-dark overflow-hidden", children: [
    /* @__PURE__ */ jsxRuntimeExports.jsx(
      "div",
      {
        className: routeVisibility.isMainVisible ? "block" : "hidden",
        style: { height: "100%" },
        children: /* @__PURE__ */ jsxRuntimeExports.jsx(MainScreen$1, {})
      }
    ),
    /* @__PURE__ */ jsxRuntimeExports.jsx(AnimatePresence, { mode: "wait", initial: false, children: routeVisibility.shouldShowOutlet && /* @__PURE__ */ jsxRuntimeExports.jsx(
      motion.div,
      {
        className: "absolute inset-0 z-10 overflow-auto bg-dark",
        variants: overlayVariants,
        initial: "hidden",
        animate: "visible",
        exit: "exit",
        transition: {
          duration: 0.15,
          ease: "easeOut"
        },
        onAnimationComplete: handleAnimationComplete,
        style: {
          // Оптимизация для GPU
          willChange: "transform, opacity",
          backfaceVisibility: "hidden",
          WebkitBackfaceVisibility: "hidden"
        },
        children: /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "h-full", children: /* @__PURE__ */ jsxRuntimeExports.jsx(Outlet, {}) })
      },
      location2.pathname
    ) }),
    memoizedBottomNavigation
  ] });
});
OptimizedPersistentLayout.displayName = "OptimizedPersistentLayout";
const common = {
  black: "#000",
  white: "#fff"
};
const red = {
  50: "#ffebee",
  100: "#ffcdd2",
  200: "#ef9a9a",
  300: "#e57373",
  400: "#ef5350",
  500: "#f44336",
  600: "#e53935",
  700: "#d32f2f",
  800: "#c62828",
  900: "#b71c1c",
  A100: "#ff8a80",
  A200: "#ff5252",
  A400: "#ff1744",
  A700: "#d50000"
};
const purple = {
  50: "#f3e5f5",
  100: "#e1bee7",
  200: "#ce93d8",
  300: "#ba68c8",
  400: "#ab47bc",
  500: "#9c27b0",
  600: "#8e24aa",
  700: "#7b1fa2",
  800: "#6a1b9a",
  900: "#4a148c",
  A100: "#ea80fc",
  A200: "#e040fb",
  A400: "#d500f9",
  A700: "#aa00ff"
};
const blue = {
  50: "#e3f2fd",
  100: "#bbdefb",
  200: "#90caf9",
  300: "#64b5f6",
  400: "#42a5f5",
  500: "#2196f3",
  600: "#1e88e5",
  700: "#1976d2",
  800: "#1565c0",
  900: "#0d47a1",
  A100: "#82b1ff",
  A200: "#448aff",
  A400: "#2979ff",
  A700: "#2962ff"
};
const lightBlue = {
  50: "#e1f5fe",
  100: "#b3e5fc",
  200: "#81d4fa",
  300: "#4fc3f7",
  400: "#29b6f6",
  500: "#03a9f4",
  600: "#039be5",
  700: "#0288d1",
  800: "#0277bd",
  900: "#01579b",
  A100: "#80d8ff",
  A200: "#40c4ff",
  A400: "#00b0ff",
  A700: "#0091ea"
};
const green = {
  50: "#e8f5e9",
  100: "#c8e6c9",
  200: "#a5d6a7",
  300: "#81c784",
  400: "#66bb6a",
  500: "#4caf50",
  600: "#43a047",
  700: "#388e3c",
  800: "#2e7d32",
  900: "#1b5e20",
  A100: "#b9f6ca",
  A200: "#69f0ae",
  A400: "#00e676",
  A700: "#00c853"
};
const orange = {
  50: "#fff3e0",
  100: "#ffe0b2",
  200: "#ffcc80",
  300: "#ffb74d",
  400: "#ffa726",
  500: "#ff9800",
  600: "#fb8c00",
  700: "#f57c00",
  800: "#ef6c00",
  900: "#e65100",
  A100: "#ffd180",
  A200: "#ffab40",
  A400: "#ff9100",
  A700: "#ff6d00"
};
const grey = {
  50: "#fafafa",
  100: "#f5f5f5",
  200: "#eeeeee",
  300: "#e0e0e0",
  400: "#bdbdbd",
  500: "#9e9e9e",
  600: "#757575",
  700: "#616161",
  800: "#424242",
  900: "#212121",
  A100: "#f5f5f5",
  A200: "#eeeeee",
  A400: "#bdbdbd",
  A700: "#616161"
};
function formatMuiErrorMessage(code, ...args) {
  const url = new URL(`https://mui.com/production-error/?code=${code}`);
  args.forEach((arg2) => url.searchParams.append("args[]", arg2));
  return `Minified MUI error #${code}; visit ${url} for the full message.`;
}
const THEME_ID = "$$material";
var isDevelopment$3 = false;
function sheetForTag(tag) {
  if (tag.sheet) {
    return tag.sheet;
  }
  for (var i2 = 0; i2 < document.styleSheets.length; i2++) {
    if (document.styleSheets[i2].ownerNode === tag) {
      return document.styleSheets[i2];
    }
  }
  return void 0;
}
function createStyleElement(options) {
  var tag = document.createElement("style");
  tag.setAttribute("data-emotion", options.key);
  if (options.nonce !== void 0) {
    tag.setAttribute("nonce", options.nonce);
  }
  tag.appendChild(document.createTextNode(""));
  tag.setAttribute("data-s", "");
  return tag;
}
var StyleSheet = /* @__PURE__ */ function() {
  function StyleSheet2(options) {
    var _this = this;
    this._insertTag = function(tag) {
      var before;
      if (_this.tags.length === 0) {
        if (_this.insertionPoint) {
          before = _this.insertionPoint.nextSibling;
        } else if (_this.prepend) {
          before = _this.container.firstChild;
        } else {
          before = _this.before;
        }
      } else {
        before = _this.tags[_this.tags.length - 1].nextSibling;
      }
      _this.container.insertBefore(tag, before);
      _this.tags.push(tag);
    };
    this.isSpeedy = options.speedy === void 0 ? !isDevelopment$3 : options.speedy;
    this.tags = [];
    this.ctr = 0;
    this.nonce = options.nonce;
    this.key = options.key;
    this.container = options.container;
    this.prepend = options.prepend;
    this.insertionPoint = options.insertionPoint;
    this.before = null;
  }
  var _proto = StyleSheet2.prototype;
  _proto.hydrate = function hydrate(nodes) {
    nodes.forEach(this._insertTag);
  };
  _proto.insert = function insert(rule) {
    if (this.ctr % (this.isSpeedy ? 65e3 : 1) === 0) {
      this._insertTag(createStyleElement(this));
    }
    var tag = this.tags[this.tags.length - 1];
    if (this.isSpeedy) {
      var sheet = sheetForTag(tag);
      try {
        sheet.insertRule(rule, sheet.cssRules.length);
      } catch (e2) {
      }
    } else {
      tag.appendChild(document.createTextNode(rule));
    }
    this.ctr++;
  };
  _proto.flush = function flush() {
    this.tags.forEach(function(tag) {
      var _tag$parentNode;
      return (_tag$parentNode = tag.parentNode) == null ? void 0 : _tag$parentNode.removeChild(tag);
    });
    this.tags = [];
    this.ctr = 0;
  };
  return StyleSheet2;
}();
var MS = "-ms-";
var MOZ = "-moz-";
var WEBKIT = "-webkit-";
var COMMENT = "comm";
var RULESET = "rule";
var DECLARATION = "decl";
var IMPORT = "@import";
var KEYFRAMES = "@keyframes";
var LAYER = "@layer";
var abs = Math.abs;
var from = String.fromCharCode;
var assign = Object.assign;
function hash(value, length2) {
  return charat(value, 0) ^ 45 ? (((length2 << 2 ^ charat(value, 0)) << 2 ^ charat(value, 1)) << 2 ^ charat(value, 2)) << 2 ^ charat(value, 3) : 0;
}
function trim(value) {
  return value.trim();
}
function match(value, pattern) {
  return (value = pattern.exec(value)) ? value[0] : value;
}
function replace(value, pattern, replacement) {
  return value.replace(pattern, replacement);
}
function indexof(value, search) {
  return value.indexOf(search);
}
function charat(value, index2) {
  return value.charCodeAt(index2) | 0;
}
function substr(value, begin, end) {
  return value.slice(begin, end);
}
function strlen(value) {
  return value.length;
}
function sizeof(value) {
  return value.length;
}
function append(value, array) {
  return array.push(value), value;
}
function combine(array, callback) {
  return array.map(callback).join("");
}
var line = 1;
var column = 1;
var length = 0;
var position = 0;
var character = 0;
var characters = "";
function node(value, root, parent2, type, props, children, length2) {
  return { value, root, parent: parent2, type, props, children, line, column, length: length2, return: "" };
}
function copy(root, props) {
  return assign(node("", null, null, "", null, null, 0), root, { length: -root.length }, props);
}
function char() {
  return character;
}
function prev() {
  character = position > 0 ? charat(characters, --position) : 0;
  if (column--, character === 10)
    column = 1, line--;
  return character;
}
function next() {
  character = position < length ? charat(characters, position++) : 0;
  if (column++, character === 10)
    column = 1, line++;
  return character;
}
function peek() {
  return charat(characters, position);
}
function caret() {
  return position;
}
function slice(begin, end) {
  return substr(characters, begin, end);
}
function token(type) {
  switch (type) {
    case 0:
    case 9:
    case 10:
    case 13:
    case 32:
      return 5;
    case 33:
    case 43:
    case 44:
    case 47:
    case 62:
    case 64:
    case 126:
    case 59:
    case 123:
    case 125:
      return 4;
    case 58:
      return 3;
    case 34:
    case 39:
    case 40:
    case 91:
      return 2;
    case 41:
    case 93:
      return 1;
  }
  return 0;
}
function alloc(value) {
  return line = column = 1, length = strlen(characters = value), position = 0, [];
}
function dealloc(value) {
  return characters = "", value;
}
function delimit(type) {
  return trim(slice(position - 1, delimiter(type === 91 ? type + 2 : type === 40 ? type + 1 : type)));
}
function whitespace(type) {
  while (character = peek())
    if (character < 33)
      next();
    else
      break;
  return token(type) > 2 || token(character) > 3 ? "" : " ";
}
function escaping(index2, count2) {
  while (--count2 && next())
    if (character < 48 || character > 102 || character > 57 && character < 65 || character > 70 && character < 97)
      break;
  return slice(index2, caret() + (count2 < 6 && peek() == 32 && next() == 32));
}
function delimiter(type) {
  while (next())
    switch (character) {
      case type:
        return position;
      case 34:
      case 39:
        if (type !== 34 && type !== 39)
          delimiter(character);
        break;
      case 40:
        if (type === 41)
          delimiter(type);
        break;
      case 92:
        next();
        break;
    }
  return position;
}
function commenter(type, index2) {
  while (next())
    if (type + character === 47 + 10)
      break;
    else if (type + character === 42 + 42 && peek() === 47)
      break;
  return "/*" + slice(index2, position - 1) + "*" + from(type === 47 ? type : next());
}
function identifier(index2) {
  while (!token(peek()))
    next();
  return slice(index2, position);
}
function compile(value) {
  return dealloc(parse("", null, null, null, [""], value = alloc(value), 0, [0], value));
}
function parse(value, root, parent2, rule, rules, rulesets, pseudo, points, declarations) {
  var index2 = 0;
  var offset2 = 0;
  var length2 = pseudo;
  var atrule = 0;
  var property = 0;
  var previous = 0;
  var variable = 1;
  var scanning = 1;
  var ampersand = 1;
  var character2 = 0;
  var type = "";
  var props = rules;
  var children = rulesets;
  var reference = rule;
  var characters2 = type;
  while (scanning)
    switch (previous = character2, character2 = next()) {
      case 40:
        if (previous != 108 && charat(characters2, length2 - 1) == 58) {
          if (indexof(characters2 += replace(delimit(character2), "&", "&\f"), "&\f") != -1)
            ampersand = -1;
          break;
        }
      case 34:
      case 39:
      case 91:
        characters2 += delimit(character2);
        break;
      case 9:
      case 10:
      case 13:
      case 32:
        characters2 += whitespace(previous);
        break;
      case 92:
        characters2 += escaping(caret() - 1, 7);
        continue;
      case 47:
        switch (peek()) {
          case 42:
          case 47:
            append(comment(commenter(next(), caret()), root, parent2), declarations);
            break;
          default:
            characters2 += "/";
        }
        break;
      case 123 * variable:
        points[index2++] = strlen(characters2) * ampersand;
      case 125 * variable:
      case 59:
      case 0:
        switch (character2) {
          case 0:
          case 125:
            scanning = 0;
          case 59 + offset2:
            if (ampersand == -1) characters2 = replace(characters2, /\f/g, "");
            if (property > 0 && strlen(characters2) - length2)
              append(property > 32 ? declaration(characters2 + ";", rule, parent2, length2 - 1) : declaration(replace(characters2, " ", "") + ";", rule, parent2, length2 - 2), declarations);
            break;
          case 59:
            characters2 += ";";
          default:
            append(reference = ruleset(characters2, root, parent2, index2, offset2, rules, points, type, props = [], children = [], length2), rulesets);
            if (character2 === 123)
              if (offset2 === 0)
                parse(characters2, root, reference, reference, props, rulesets, length2, points, children);
              else
                switch (atrule === 99 && charat(characters2, 3) === 110 ? 100 : atrule) {
                  case 100:
                  case 108:
                  case 109:
                  case 115:
                    parse(value, reference, reference, rule && append(ruleset(value, reference, reference, 0, 0, rules, points, type, rules, props = [], length2), children), rules, children, length2, points, rule ? props : children);
                    break;
                  default:
                    parse(characters2, reference, reference, reference, [""], children, 0, points, children);
                }
        }
        index2 = offset2 = property = 0, variable = ampersand = 1, type = characters2 = "", length2 = pseudo;
        break;
      case 58:
        length2 = 1 + strlen(characters2), property = previous;
      default:
        if (variable < 1) {
          if (character2 == 123)
            --variable;
          else if (character2 == 125 && variable++ == 0 && prev() == 125)
            continue;
        }
        switch (characters2 += from(character2), character2 * variable) {
          case 38:
            ampersand = offset2 > 0 ? 1 : (characters2 += "\f", -1);
            break;
          case 44:
            points[index2++] = (strlen(characters2) - 1) * ampersand, ampersand = 1;
            break;
          case 64:
            if (peek() === 45)
              characters2 += delimit(next());
            atrule = peek(), offset2 = length2 = strlen(type = characters2 += identifier(caret())), character2++;
            break;
          case 45:
            if (previous === 45 && strlen(characters2) == 2)
              variable = 0;
        }
    }
  return rulesets;
}
function ruleset(value, root, parent2, index2, offset2, rules, points, type, props, children, length2) {
  var post = offset2 - 1;
  var rule = offset2 === 0 ? rules : [""];
  var size2 = sizeof(rule);
  for (var i2 = 0, j2 = 0, k2 = 0; i2 < index2; ++i2)
    for (var x2 = 0, y2 = substr(value, post + 1, post = abs(j2 = points[i2])), z2 = value; x2 < size2; ++x2)
      if (z2 = trim(j2 > 0 ? rule[x2] + " " + y2 : replace(y2, /&\f/g, rule[x2])))
        props[k2++] = z2;
  return node(value, root, parent2, offset2 === 0 ? RULESET : type, props, children, length2);
}
function comment(value, root, parent2) {
  return node(value, root, parent2, COMMENT, from(char()), substr(value, 2, -2), 0);
}
function declaration(value, root, parent2, length2) {
  return node(value, root, parent2, DECLARATION, substr(value, 0, length2), substr(value, length2 + 1, -1), length2);
}
function serialize(children, callback) {
  var output = "";
  var length2 = sizeof(children);
  for (var i2 = 0; i2 < length2; i2++)
    output += callback(children[i2], i2, children, callback) || "";
  return output;
}
function stringify(element, index2, children, callback) {
  switch (element.type) {
    case LAYER:
      if (element.children.length) break;
    case IMPORT:
    case DECLARATION:
      return element.return = element.return || element.value;
    case COMMENT:
      return "";
    case KEYFRAMES:
      return element.return = element.value + "{" + serialize(element.children, callback) + "}";
    case RULESET:
      element.value = element.props.join(",");
  }
  return strlen(children = serialize(element.children, callback)) ? element.return = element.value + "{" + children + "}" : "";
}
function middleware(collection) {
  var length2 = sizeof(collection);
  return function(element, index2, children, callback) {
    var output = "";
    for (var i2 = 0; i2 < length2; i2++)
      output += collection[i2](element, index2, children, callback) || "";
    return output;
  };
}
function rulesheet(callback) {
  return function(element) {
    if (!element.root) {
      if (element = element.return)
        callback(element);
    }
  };
}
function memoize$1(fn) {
  var cache = /* @__PURE__ */ Object.create(null);
  return function(arg2) {
    if (cache[arg2] === void 0) cache[arg2] = fn(arg2);
    return cache[arg2];
  };
}
var identifierWithPointTracking = function identifierWithPointTracking2(begin, points, index2) {
  var previous = 0;
  var character2 = 0;
  while (true) {
    previous = character2;
    character2 = peek();
    if (previous === 38 && character2 === 12) {
      points[index2] = 1;
    }
    if (token(character2)) {
      break;
    }
    next();
  }
  return slice(begin, position);
};
var toRules = function toRules2(parsed, points) {
  var index2 = -1;
  var character2 = 44;
  do {
    switch (token(character2)) {
      case 0:
        if (character2 === 38 && peek() === 12) {
          points[index2] = 1;
        }
        parsed[index2] += identifierWithPointTracking(position - 1, points, index2);
        break;
      case 2:
        parsed[index2] += delimit(character2);
        break;
      case 4:
        if (character2 === 44) {
          parsed[++index2] = peek() === 58 ? "&\f" : "";
          points[index2] = parsed[index2].length;
          break;
        }
      default:
        parsed[index2] += from(character2);
    }
  } while (character2 = next());
  return parsed;
};
var getRules = function getRules2(value, points) {
  return dealloc(toRules(alloc(value), points));
};
var fixedElements = /* @__PURE__ */ new WeakMap();
var compat = function compat2(element) {
  if (element.type !== "rule" || !element.parent || // positive .length indicates that this rule contains pseudo
  // negative .length indicates that this rule has been already prefixed
  element.length < 1) {
    return;
  }
  var value = element.value;
  var parent2 = element.parent;
  var isImplicitRule = element.column === parent2.column && element.line === parent2.line;
  while (parent2.type !== "rule") {
    parent2 = parent2.parent;
    if (!parent2) return;
  }
  if (element.props.length === 1 && value.charCodeAt(0) !== 58 && !fixedElements.get(parent2)) {
    return;
  }
  if (isImplicitRule) {
    return;
  }
  fixedElements.set(element, true);
  var points = [];
  var rules = getRules(value, points);
  var parentRules = parent2.props;
  for (var i2 = 0, k2 = 0; i2 < rules.length; i2++) {
    for (var j2 = 0; j2 < parentRules.length; j2++, k2++) {
      element.props[k2] = points[i2] ? rules[i2].replace(/&\f/g, parentRules[j2]) : parentRules[j2] + " " + rules[i2];
    }
  }
};
var removeLabel = function removeLabel2(element) {
  if (element.type === "decl") {
    var value = element.value;
    if (
      // charcode for l
      value.charCodeAt(0) === 108 && // charcode for b
      value.charCodeAt(2) === 98
    ) {
      element["return"] = "";
      element.value = "";
    }
  }
};
function prefix(value, length2) {
  switch (hash(value, length2)) {
    case 5103:
      return WEBKIT + "print-" + value + value;
    case 5737:
    case 4201:
    case 3177:
    case 3433:
    case 1641:
    case 4457:
    case 2921:
    case 5572:
    case 6356:
    case 5844:
    case 3191:
    case 6645:
    case 3005:
    case 6391:
    case 5879:
    case 5623:
    case 6135:
    case 4599:
    case 4855:
    case 4215:
    case 6389:
    case 5109:
    case 5365:
    case 5621:
    case 3829:
      return WEBKIT + value + value;
    case 5349:
    case 4246:
    case 4810:
    case 6968:
    case 2756:
      return WEBKIT + value + MOZ + value + MS + value + value;
    case 6828:
    case 4268:
      return WEBKIT + value + MS + value + value;
    case 6165:
      return WEBKIT + value + MS + "flex-" + value + value;
    case 5187:
      return WEBKIT + value + replace(value, /(\w+).+(:[^]+)/, WEBKIT + "box-$1$2" + MS + "flex-$1$2") + value;
    case 5443:
      return WEBKIT + value + MS + "flex-item-" + replace(value, /flex-|-self/, "") + value;
    case 4675:
      return WEBKIT + value + MS + "flex-line-pack" + replace(value, /align-content|flex-|-self/, "") + value;
    case 5548:
      return WEBKIT + value + MS + replace(value, "shrink", "negative") + value;
    case 5292:
      return WEBKIT + value + MS + replace(value, "basis", "preferred-size") + value;
    case 6060:
      return WEBKIT + "box-" + replace(value, "-grow", "") + WEBKIT + value + MS + replace(value, "grow", "positive") + value;
    case 4554:
      return WEBKIT + replace(value, /([^-])(transform)/g, "$1" + WEBKIT + "$2") + value;
    case 6187:
      return replace(replace(replace(value, /(zoom-|grab)/, WEBKIT + "$1"), /(image-set)/, WEBKIT + "$1"), value, "") + value;
    case 5495:
    case 3959:
      return replace(value, /(image-set\([^]*)/, WEBKIT + "$1$`$1");
    case 4968:
      return replace(replace(value, /(.+:)(flex-)?(.*)/, WEBKIT + "box-pack:$3" + MS + "flex-pack:$3"), /s.+-b[^;]+/, "justify") + WEBKIT + value + value;
    case 4095:
    case 3583:
    case 4068:
    case 2532:
      return replace(value, /(.+)-inline(.+)/, WEBKIT + "$1$2") + value;
    case 8116:
    case 7059:
    case 5753:
    case 5535:
    case 5445:
    case 5701:
    case 4933:
    case 4677:
    case 5533:
    case 5789:
    case 5021:
    case 4765:
      if (strlen(value) - 1 - length2 > 6) switch (charat(value, length2 + 1)) {
        case 109:
          if (charat(value, length2 + 4) !== 45) break;
        case 102:
          return replace(value, /(.+:)(.+)-([^]+)/, "$1" + WEBKIT + "$2-$3$1" + MOZ + (charat(value, length2 + 3) == 108 ? "$3" : "$2-$3")) + value;
        case 115:
          return ~indexof(value, "stretch") ? prefix(replace(value, "stretch", "fill-available"), length2) + value : value;
      }
      break;
    case 4949:
      if (charat(value, length2 + 1) !== 115) break;
    case 6444:
      switch (charat(value, strlen(value) - 3 - (~indexof(value, "!important") && 10))) {
        case 107:
          return replace(value, ":", ":" + WEBKIT) + value;
        case 101:
          return replace(value, /(.+:)([^;!]+)(;|!.+)?/, "$1" + WEBKIT + (charat(value, 14) === 45 ? "inline-" : "") + "box$3$1" + WEBKIT + "$2$3$1" + MS + "$2box$3") + value;
      }
      break;
    case 5936:
      switch (charat(value, length2 + 11)) {
        case 114:
          return WEBKIT + value + MS + replace(value, /[svh]\w+-[tblr]{2}/, "tb") + value;
        case 108:
          return WEBKIT + value + MS + replace(value, /[svh]\w+-[tblr]{2}/, "tb-rl") + value;
        case 45:
          return WEBKIT + value + MS + replace(value, /[svh]\w+-[tblr]{2}/, "lr") + value;
      }
      return WEBKIT + value + MS + value + value;
  }
  return value;
}
var prefixer = function prefixer2(element, index2, children, callback) {
  if (element.length > -1) {
    if (!element["return"]) switch (element.type) {
      case DECLARATION:
        element["return"] = prefix(element.value, element.length);
        break;
      case KEYFRAMES:
        return serialize([copy(element, {
          value: replace(element.value, "@", "@" + WEBKIT)
        })], callback);
      case RULESET:
        if (element.length) return combine(element.props, function(value) {
          switch (match(value, /(::plac\w+|:read-\w+)/)) {
            case ":read-only":
            case ":read-write":
              return serialize([copy(element, {
                props: [replace(value, /:(read-\w+)/, ":" + MOZ + "$1")]
              })], callback);
            case "::placeholder":
              return serialize([copy(element, {
                props: [replace(value, /:(plac\w+)/, ":" + WEBKIT + "input-$1")]
              }), copy(element, {
                props: [replace(value, /:(plac\w+)/, ":" + MOZ + "$1")]
              }), copy(element, {
                props: [replace(value, /:(plac\w+)/, MS + "input-$1")]
              })], callback);
          }
          return "";
        });
    }
  }
};
var defaultStylisPlugins = [prefixer];
var createCache = function createCache2(options) {
  var key2 = options.key;
  if (key2 === "css") {
    var ssrStyles = document.querySelectorAll("style[data-emotion]:not([data-s])");
    Array.prototype.forEach.call(ssrStyles, function(node2) {
      var dataEmotionAttribute = node2.getAttribute("data-emotion");
      if (dataEmotionAttribute.indexOf(" ") === -1) {
        return;
      }
      document.head.appendChild(node2);
      node2.setAttribute("data-s", "");
    });
  }
  var stylisPlugins = options.stylisPlugins || defaultStylisPlugins;
  var inserted = {};
  var container;
  var nodesToHydrate = [];
  {
    container = options.container || document.head;
    Array.prototype.forEach.call(
      // this means we will ignore elements which don't have a space in them which
      // means that the style elements we're looking at are only Emotion 11 server-rendered style elements
      document.querySelectorAll('style[data-emotion^="' + key2 + ' "]'),
      function(node2) {
        var attrib = node2.getAttribute("data-emotion").split(" ");
        for (var i2 = 1; i2 < attrib.length; i2++) {
          inserted[attrib[i2]] = true;
        }
        nodesToHydrate.push(node2);
      }
    );
  }
  var _insert;
  var omnipresentPlugins = [compat, removeLabel];
  {
    var currentSheet;
    var finalizingPlugins = [stringify, rulesheet(function(rule) {
      currentSheet.insert(rule);
    })];
    var serializer = middleware(omnipresentPlugins.concat(stylisPlugins, finalizingPlugins));
    var stylis = function stylis2(styles2) {
      return serialize(compile(styles2), serializer);
    };
    _insert = function insert(selector, serialized, sheet, shouldCache) {
      currentSheet = sheet;
      stylis(selector ? selector + "{" + serialized.styles + "}" : serialized.styles);
      if (shouldCache) {
        cache.inserted[serialized.name] = true;
      }
    };
  }
  var cache = {
    key: key2,
    sheet: new StyleSheet({
      key: key2,
      container,
      nonce: options.nonce,
      speedy: options.speedy,
      prepend: options.prepend,
      insertionPoint: options.insertionPoint
    }),
    nonce: options.nonce,
    inserted,
    registered: {},
    insert: _insert
  };
  cache.sheet.hydrate(nodesToHydrate);
  return cache;
};
var reactIs$2 = { exports: {} };
var reactIs_production_min = {};
/** @license React v16.13.1
 * react-is.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var b = "function" === typeof Symbol && Symbol.for, c = b ? Symbol.for("react.element") : 60103, d = b ? Symbol.for("react.portal") : 60106, e = b ? Symbol.for("react.fragment") : 60107, f = b ? Symbol.for("react.strict_mode") : 60108, g = b ? Symbol.for("react.profiler") : 60114, h = b ? Symbol.for("react.provider") : 60109, k = b ? Symbol.for("react.context") : 60110, l = b ? Symbol.for("react.async_mode") : 60111, m = b ? Symbol.for("react.concurrent_mode") : 60111, n = b ? Symbol.for("react.forward_ref") : 60112, p = b ? Symbol.for("react.suspense") : 60113, q = b ? Symbol.for("react.suspense_list") : 60120, r = b ? Symbol.for("react.memo") : 60115, t = b ? Symbol.for("react.lazy") : 60116, v = b ? Symbol.for("react.block") : 60121, w = b ? Symbol.for("react.fundamental") : 60117, x = b ? Symbol.for("react.responder") : 60118, y = b ? Symbol.for("react.scope") : 60119;
function z(a2) {
  if ("object" === typeof a2 && null !== a2) {
    var u2 = a2.$$typeof;
    switch (u2) {
      case c:
        switch (a2 = a2.type, a2) {
          case l:
          case m:
          case e:
          case g:
          case f:
          case p:
            return a2;
          default:
            switch (a2 = a2 && a2.$$typeof, a2) {
              case k:
              case n:
              case t:
              case r:
              case h:
                return a2;
              default:
                return u2;
            }
        }
      case d:
        return u2;
    }
  }
}
function A(a2) {
  return z(a2) === m;
}
reactIs_production_min.AsyncMode = l;
reactIs_production_min.ConcurrentMode = m;
reactIs_production_min.ContextConsumer = k;
reactIs_production_min.ContextProvider = h;
reactIs_production_min.Element = c;
reactIs_production_min.ForwardRef = n;
reactIs_production_min.Fragment = e;
reactIs_production_min.Lazy = t;
reactIs_production_min.Memo = r;
reactIs_production_min.Portal = d;
reactIs_production_min.Profiler = g;
reactIs_production_min.StrictMode = f;
reactIs_production_min.Suspense = p;
reactIs_production_min.isAsyncMode = function(a2) {
  return A(a2) || z(a2) === l;
};
reactIs_production_min.isConcurrentMode = A;
reactIs_production_min.isContextConsumer = function(a2) {
  return z(a2) === k;
};
reactIs_production_min.isContextProvider = function(a2) {
  return z(a2) === h;
};
reactIs_production_min.isElement = function(a2) {
  return "object" === typeof a2 && null !== a2 && a2.$$typeof === c;
};
reactIs_production_min.isForwardRef = function(a2) {
  return z(a2) === n;
};
reactIs_production_min.isFragment = function(a2) {
  return z(a2) === e;
};
reactIs_production_min.isLazy = function(a2) {
  return z(a2) === t;
};
reactIs_production_min.isMemo = function(a2) {
  return z(a2) === r;
};
reactIs_production_min.isPortal = function(a2) {
  return z(a2) === d;
};
reactIs_production_min.isProfiler = function(a2) {
  return z(a2) === g;
};
reactIs_production_min.isStrictMode = function(a2) {
  return z(a2) === f;
};
reactIs_production_min.isSuspense = function(a2) {
  return z(a2) === p;
};
reactIs_production_min.isValidElementType = function(a2) {
  return "string" === typeof a2 || "function" === typeof a2 || a2 === e || a2 === m || a2 === g || a2 === f || a2 === p || a2 === q || "object" === typeof a2 && null !== a2 && (a2.$$typeof === t || a2.$$typeof === r || a2.$$typeof === h || a2.$$typeof === k || a2.$$typeof === n || a2.$$typeof === w || a2.$$typeof === x || a2.$$typeof === y || a2.$$typeof === v);
};
reactIs_production_min.typeOf = z;
{
  reactIs$2.exports = reactIs_production_min;
}
var reactIsExports$1 = reactIs$2.exports;
var reactIs$1 = reactIsExports$1;
var FORWARD_REF_STATICS = {
  "$$typeof": true,
  render: true,
  defaultProps: true,
  displayName: true,
  propTypes: true
};
var MEMO_STATICS = {
  "$$typeof": true,
  compare: true,
  defaultProps: true,
  displayName: true,
  propTypes: true,
  type: true
};
var TYPE_STATICS = {};
TYPE_STATICS[reactIs$1.ForwardRef] = FORWARD_REF_STATICS;
TYPE_STATICS[reactIs$1.Memo] = MEMO_STATICS;
var isBrowser = true;
function getRegisteredStyles(registered, registeredStyles, classNames) {
  var rawClassName = "";
  classNames.split(" ").forEach(function(className) {
    if (registered[className] !== void 0) {
      registeredStyles.push(registered[className] + ";");
    } else if (className) {
      rawClassName += className + " ";
    }
  });
  return rawClassName;
}
var registerStyles = function registerStyles2(cache, serialized, isStringTag2) {
  var className = cache.key + "-" + serialized.name;
  if (
    // we only need to add the styles to the registered cache if the
    // class name could be used further down
    // the tree but if it's a string tag, we know it won't
    // so we don't have to add it to registered cache.
    // this improves memory usage since we can avoid storing the whole style string
    (isStringTag2 === false || // we need to always store it if we're in compat mode and
    // in node since emotion-server relies on whether a style is in
    // the registered cache to know whether a style is global or not
    // also, note that this check will be dead code eliminated in the browser
    isBrowser === false) && cache.registered[className] === void 0
  ) {
    cache.registered[className] = serialized.styles;
  }
};
var insertStyles = function insertStyles2(cache, serialized, isStringTag2) {
  registerStyles(cache, serialized, isStringTag2);
  var className = cache.key + "-" + serialized.name;
  if (cache.inserted[serialized.name] === void 0) {
    var current = serialized;
    do {
      cache.insert(serialized === current ? "." + className : "", current, cache.sheet, true);
      current = current.next;
    } while (current !== void 0);
  }
};
function murmur2(str) {
  var h2 = 0;
  var k2, i2 = 0, len = str.length;
  for (; len >= 4; ++i2, len -= 4) {
    k2 = str.charCodeAt(i2) & 255 | (str.charCodeAt(++i2) & 255) << 8 | (str.charCodeAt(++i2) & 255) << 16 | (str.charCodeAt(++i2) & 255) << 24;
    k2 = /* Math.imul(k, m): */
    (k2 & 65535) * 1540483477 + ((k2 >>> 16) * 59797 << 16);
    k2 ^= /* k >>> r: */
    k2 >>> 24;
    h2 = /* Math.imul(k, m): */
    (k2 & 65535) * 1540483477 + ((k2 >>> 16) * 59797 << 16) ^ /* Math.imul(h, m): */
    (h2 & 65535) * 1540483477 + ((h2 >>> 16) * 59797 << 16);
  }
  switch (len) {
    case 3:
      h2 ^= (str.charCodeAt(i2 + 2) & 255) << 16;
    case 2:
      h2 ^= (str.charCodeAt(i2 + 1) & 255) << 8;
    case 1:
      h2 ^= str.charCodeAt(i2) & 255;
      h2 = /* Math.imul(h, m): */
      (h2 & 65535) * 1540483477 + ((h2 >>> 16) * 59797 << 16);
  }
  h2 ^= h2 >>> 13;
  h2 = /* Math.imul(h, m): */
  (h2 & 65535) * 1540483477 + ((h2 >>> 16) * 59797 << 16);
  return ((h2 ^ h2 >>> 15) >>> 0).toString(36);
}
var unitlessKeys = {
  animationIterationCount: 1,
  aspectRatio: 1,
  borderImageOutset: 1,
  borderImageSlice: 1,
  borderImageWidth: 1,
  boxFlex: 1,
  boxFlexGroup: 1,
  boxOrdinalGroup: 1,
  columnCount: 1,
  columns: 1,
  flex: 1,
  flexGrow: 1,
  flexPositive: 1,
  flexShrink: 1,
  flexNegative: 1,
  flexOrder: 1,
  gridRow: 1,
  gridRowEnd: 1,
  gridRowSpan: 1,
  gridRowStart: 1,
  gridColumn: 1,
  gridColumnEnd: 1,
  gridColumnSpan: 1,
  gridColumnStart: 1,
  msGridRow: 1,
  msGridRowSpan: 1,
  msGridColumn: 1,
  msGridColumnSpan: 1,
  fontWeight: 1,
  lineHeight: 1,
  opacity: 1,
  order: 1,
  orphans: 1,
  scale: 1,
  tabSize: 1,
  widows: 1,
  zIndex: 1,
  zoom: 1,
  WebkitLineClamp: 1,
  // SVG-related properties
  fillOpacity: 1,
  floodOpacity: 1,
  stopOpacity: 1,
  strokeDasharray: 1,
  strokeDashoffset: 1,
  strokeMiterlimit: 1,
  strokeOpacity: 1,
  strokeWidth: 1
};
var isDevelopment$2 = false;
var hyphenateRegex = /[A-Z]|^ms/g;
var animationRegex = /_EMO_([^_]+?)_([^]*?)_EMO_/g;
var isCustomProperty = function isCustomProperty2(property) {
  return property.charCodeAt(1) === 45;
};
var isProcessableValue = function isProcessableValue2(value) {
  return value != null && typeof value !== "boolean";
};
var processStyleName = /* @__PURE__ */ memoize$1(function(styleName) {
  return isCustomProperty(styleName) ? styleName : styleName.replace(hyphenateRegex, "-$&").toLowerCase();
});
var processStyleValue = function processStyleValue2(key2, value) {
  switch (key2) {
    case "animation":
    case "animationName": {
      if (typeof value === "string") {
        return value.replace(animationRegex, function(match2, p1, p2) {
          cursor = {
            name: p1,
            styles: p2,
            next: cursor
          };
          return p1;
        });
      }
    }
  }
  if (unitlessKeys[key2] !== 1 && !isCustomProperty(key2) && typeof value === "number" && value !== 0) {
    return value + "px";
  }
  return value;
};
var noComponentSelectorMessage = "Component selectors can only be used in conjunction with @emotion/babel-plugin, the swc Emotion plugin, or another Emotion-aware compiler transform.";
function handleInterpolation(mergedProps, registered, interpolation) {
  if (interpolation == null) {
    return "";
  }
  var componentSelector = interpolation;
  if (componentSelector.__emotion_styles !== void 0) {
    return componentSelector;
  }
  switch (typeof interpolation) {
    case "boolean": {
      return "";
    }
    case "object": {
      var keyframes2 = interpolation;
      if (keyframes2.anim === 1) {
        cursor = {
          name: keyframes2.name,
          styles: keyframes2.styles,
          next: cursor
        };
        return keyframes2.name;
      }
      var serializedStyles = interpolation;
      if (serializedStyles.styles !== void 0) {
        var next2 = serializedStyles.next;
        if (next2 !== void 0) {
          while (next2 !== void 0) {
            cursor = {
              name: next2.name,
              styles: next2.styles,
              next: cursor
            };
            next2 = next2.next;
          }
        }
        var styles2 = serializedStyles.styles + ";";
        return styles2;
      }
      return createStringFromObject(mergedProps, registered, interpolation);
    }
    case "function": {
      if (mergedProps !== void 0) {
        var previousCursor = cursor;
        var result = interpolation(mergedProps);
        cursor = previousCursor;
        return handleInterpolation(mergedProps, registered, result);
      }
      break;
    }
  }
  var asString = interpolation;
  if (registered == null) {
    return asString;
  }
  var cached = registered[asString];
  return cached !== void 0 ? cached : asString;
}
function createStringFromObject(mergedProps, registered, obj) {
  var string = "";
  if (Array.isArray(obj)) {
    for (var i2 = 0; i2 < obj.length; i2++) {
      string += handleInterpolation(mergedProps, registered, obj[i2]) + ";";
    }
  } else {
    for (var key2 in obj) {
      var value = obj[key2];
      if (typeof value !== "object") {
        var asString = value;
        if (registered != null && registered[asString] !== void 0) {
          string += key2 + "{" + registered[asString] + "}";
        } else if (isProcessableValue(asString)) {
          string += processStyleName(key2) + ":" + processStyleValue(key2, asString) + ";";
        }
      } else {
        if (key2 === "NO_COMPONENT_SELECTOR" && isDevelopment$2) {
          throw new Error(noComponentSelectorMessage);
        }
        if (Array.isArray(value) && typeof value[0] === "string" && (registered == null || registered[value[0]] === void 0)) {
          for (var _i2 = 0; _i2 < value.length; _i2++) {
            if (isProcessableValue(value[_i2])) {
              string += processStyleName(key2) + ":" + processStyleValue(key2, value[_i2]) + ";";
            }
          }
        } else {
          var interpolated = handleInterpolation(mergedProps, registered, value);
          switch (key2) {
            case "animation":
            case "animationName": {
              string += processStyleName(key2) + ":" + interpolated + ";";
              break;
            }
            default: {
              string += key2 + "{" + interpolated + "}";
            }
          }
        }
      }
    }
  }
  return string;
}
var labelPattern = /label:\s*([^\s;{]+)\s*(;|$)/g;
var cursor;
function serializeStyles(args, registered, mergedProps) {
  if (args.length === 1 && typeof args[0] === "object" && args[0] !== null && args[0].styles !== void 0) {
    return args[0];
  }
  var stringMode = true;
  var styles2 = "";
  cursor = void 0;
  var strings = args[0];
  if (strings == null || strings.raw === void 0) {
    stringMode = false;
    styles2 += handleInterpolation(mergedProps, registered, strings);
  } else {
    var asTemplateStringsArr = strings;
    styles2 += asTemplateStringsArr[0];
  }
  for (var i2 = 1; i2 < args.length; i2++) {
    styles2 += handleInterpolation(mergedProps, registered, args[i2]);
    if (stringMode) {
      var templateStringsArr = strings;
      styles2 += templateStringsArr[i2];
    }
  }
  labelPattern.lastIndex = 0;
  var identifierName = "";
  var match2;
  while ((match2 = labelPattern.exec(styles2)) !== null) {
    identifierName += "-" + match2[1];
  }
  var name = murmur2(styles2) + identifierName;
  return {
    name,
    styles: styles2,
    next: cursor
  };
}
var syncFallback = function syncFallback2(create) {
  return create();
};
var useInsertionEffect = React$1["useInsertionEffect"] ? React$1["useInsertionEffect"] : false;
var useInsertionEffectAlwaysWithSyncFallback = useInsertionEffect || syncFallback;
var useInsertionEffectWithLayoutFallback = useInsertionEffect || reactExports.useLayoutEffect;
var isDevelopment$1 = false;
var EmotionCacheContext = /* @__PURE__ */ reactExports.createContext(
  // we're doing this to avoid preconstruct's dead code elimination in this one case
  // because this module is primarily intended for the browser and node
  // but it's also required in react native and similar environments sometimes
  // and we could have a special build just for that
  // but this is much easier and the native packages
  // might use a different theme context in the future anyway
  typeof HTMLElement !== "undefined" ? /* @__PURE__ */ createCache({
    key: "css"
  }) : null
);
EmotionCacheContext.Provider;
var withEmotionCache = function withEmotionCache2(func) {
  return /* @__PURE__ */ reactExports.forwardRef(function(props, ref) {
    var cache = reactExports.useContext(EmotionCacheContext);
    return func(props, cache, ref);
  });
};
var ThemeContext$1 = /* @__PURE__ */ reactExports.createContext({});
var hasOwn = {}.hasOwnProperty;
var typePropName = "__EMOTION_TYPE_PLEASE_DO_NOT_USE__";
var createEmotionProps = function createEmotionProps2(type, props) {
  var newProps = {};
  for (var _key in props) {
    if (hasOwn.call(props, _key)) {
      newProps[_key] = props[_key];
    }
  }
  newProps[typePropName] = type;
  return newProps;
};
var Insertion$1 = function Insertion(_ref) {
  var cache = _ref.cache, serialized = _ref.serialized, isStringTag2 = _ref.isStringTag;
  registerStyles(cache, serialized, isStringTag2);
  useInsertionEffectAlwaysWithSyncFallback(function() {
    return insertStyles(cache, serialized, isStringTag2);
  });
  return null;
};
var Emotion = /* @__PURE__ */ withEmotionCache(function(props, cache, ref) {
  var cssProp = props.css;
  if (typeof cssProp === "string" && cache.registered[cssProp] !== void 0) {
    cssProp = cache.registered[cssProp];
  }
  var WrappedComponent = props[typePropName];
  var registeredStyles = [cssProp];
  var className = "";
  if (typeof props.className === "string") {
    className = getRegisteredStyles(cache.registered, registeredStyles, props.className);
  } else if (props.className != null) {
    className = props.className + " ";
  }
  var serialized = serializeStyles(registeredStyles, void 0, reactExports.useContext(ThemeContext$1));
  className += cache.key + "-" + serialized.name;
  var newProps = {};
  for (var _key2 in props) {
    if (hasOwn.call(props, _key2) && _key2 !== "css" && _key2 !== typePropName && !isDevelopment$1) {
      newProps[_key2] = props[_key2];
    }
  }
  newProps.className = className;
  if (ref) {
    newProps.ref = ref;
  }
  return /* @__PURE__ */ reactExports.createElement(reactExports.Fragment, null, /* @__PURE__ */ reactExports.createElement(Insertion$1, {
    cache,
    serialized,
    isStringTag: typeof WrappedComponent === "string"
  }), /* @__PURE__ */ reactExports.createElement(WrappedComponent, newProps));
});
var Emotion$1 = Emotion;
var jsx = function jsx2(type, props) {
  var args = arguments;
  if (props == null || !hasOwn.call(props, "css")) {
    return reactExports.createElement.apply(void 0, args);
  }
  var argsLength = args.length;
  var createElementArgArray = new Array(argsLength);
  createElementArgArray[0] = Emotion$1;
  createElementArgArray[1] = createEmotionProps(type, props);
  for (var i2 = 2; i2 < argsLength; i2++) {
    createElementArgArray[i2] = args[i2];
  }
  return reactExports.createElement.apply(null, createElementArgArray);
};
(function(_jsx) {
  var JSX;
  /* @__PURE__ */ (function(_JSX) {
  })(JSX || (JSX = _jsx.JSX || (_jsx.JSX = {})));
})(jsx || (jsx = {}));
var Global = /* @__PURE__ */ withEmotionCache(function(props, cache) {
  var styles2 = props.styles;
  var serialized = serializeStyles([styles2], void 0, reactExports.useContext(ThemeContext$1));
  var sheetRef = reactExports.useRef();
  useInsertionEffectWithLayoutFallback(function() {
    var key2 = cache.key + "-global";
    var sheet = new cache.sheet.constructor({
      key: key2,
      nonce: cache.sheet.nonce,
      container: cache.sheet.container,
      speedy: cache.sheet.isSpeedy
    });
    var rehydrating = false;
    var node2 = document.querySelector('style[data-emotion="' + key2 + " " + serialized.name + '"]');
    if (cache.sheet.tags.length) {
      sheet.before = cache.sheet.tags[0];
    }
    if (node2 !== null) {
      rehydrating = true;
      node2.setAttribute("data-emotion", key2);
      sheet.hydrate([node2]);
    }
    sheetRef.current = [sheet, rehydrating];
    return function() {
      sheet.flush();
    };
  }, [cache]);
  useInsertionEffectWithLayoutFallback(function() {
    var sheetRefCurrent = sheetRef.current;
    var sheet = sheetRefCurrent[0], rehydrating = sheetRefCurrent[1];
    if (rehydrating) {
      sheetRefCurrent[1] = false;
      return;
    }
    if (serialized.next !== void 0) {
      insertStyles(cache, serialized.next, true);
    }
    if (sheet.tags.length) {
      var element = sheet.tags[sheet.tags.length - 1].nextElementSibling;
      sheet.before = element;
      sheet.flush();
    }
    cache.insert("", serialized, sheet, false);
  }, [cache, serialized.name]);
  return null;
});
function css() {
  for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
    args[_key] = arguments[_key];
  }
  return serializeStyles(args);
}
function keyframes() {
  var insertable = css.apply(void 0, arguments);
  var name = "animation-" + insertable.name;
  return {
    name,
    styles: "@keyframes " + name + "{" + insertable.styles + "}",
    anim: 1,
    toString: function toString() {
      return "_EMO_" + this.name + "_" + this.styles + "_EMO_";
    }
  };
}
var reactPropsRegex = /^((children|dangerouslySetInnerHTML|key|ref|autoFocus|defaultValue|defaultChecked|innerHTML|suppressContentEditableWarning|suppressHydrationWarning|valueLink|abbr|accept|acceptCharset|accessKey|action|allow|allowUserMedia|allowPaymentRequest|allowFullScreen|allowTransparency|alt|async|autoComplete|autoPlay|capture|cellPadding|cellSpacing|challenge|charSet|checked|cite|classID|className|cols|colSpan|content|contentEditable|contextMenu|controls|controlsList|coords|crossOrigin|data|dateTime|decoding|default|defer|dir|disabled|disablePictureInPicture|disableRemotePlayback|download|draggable|encType|enterKeyHint|fetchpriority|fetchPriority|form|formAction|formEncType|formMethod|formNoValidate|formTarget|frameBorder|headers|height|hidden|high|href|hrefLang|htmlFor|httpEquiv|id|inputMode|integrity|is|keyParams|keyType|kind|label|lang|list|loading|loop|low|marginHeight|marginWidth|max|maxLength|media|mediaGroup|method|min|minLength|multiple|muted|name|nonce|noValidate|open|optimum|pattern|placeholder|playsInline|poster|preload|profile|radioGroup|readOnly|referrerPolicy|rel|required|reversed|role|rows|rowSpan|sandbox|scope|scoped|scrolling|seamless|selected|shape|size|sizes|slot|span|spellCheck|src|srcDoc|srcLang|srcSet|start|step|style|summary|tabIndex|target|title|translate|type|useMap|value|width|wmode|wrap|about|datatype|inlist|prefix|property|resource|typeof|vocab|autoCapitalize|autoCorrect|autoSave|color|incremental|fallback|inert|itemProp|itemScope|itemType|itemID|itemRef|on|option|results|security|unselectable|accentHeight|accumulate|additive|alignmentBaseline|allowReorder|alphabetic|amplitude|arabicForm|ascent|attributeName|attributeType|autoReverse|azimuth|baseFrequency|baselineShift|baseProfile|bbox|begin|bias|by|calcMode|capHeight|clip|clipPathUnits|clipPath|clipRule|colorInterpolation|colorInterpolationFilters|colorProfile|colorRendering|contentScriptType|contentStyleType|cursor|cx|cy|d|decelerate|descent|diffuseConstant|direction|display|divisor|dominantBaseline|dur|dx|dy|edgeMode|elevation|enableBackground|end|exponent|externalResourcesRequired|fill|fillOpacity|fillRule|filter|filterRes|filterUnits|floodColor|floodOpacity|focusable|fontFamily|fontSize|fontSizeAdjust|fontStretch|fontStyle|fontVariant|fontWeight|format|from|fr|fx|fy|g1|g2|glyphName|glyphOrientationHorizontal|glyphOrientationVertical|glyphRef|gradientTransform|gradientUnits|hanging|horizAdvX|horizOriginX|ideographic|imageRendering|in|in2|intercept|k|k1|k2|k3|k4|kernelMatrix|kernelUnitLength|kerning|keyPoints|keySplines|keyTimes|lengthAdjust|letterSpacing|lightingColor|limitingConeAngle|local|markerEnd|markerMid|markerStart|markerHeight|markerUnits|markerWidth|mask|maskContentUnits|maskUnits|mathematical|mode|numOctaves|offset|opacity|operator|order|orient|orientation|origin|overflow|overlinePosition|overlineThickness|panose1|paintOrder|pathLength|patternContentUnits|patternTransform|patternUnits|pointerEvents|points|pointsAtX|pointsAtY|pointsAtZ|preserveAlpha|preserveAspectRatio|primitiveUnits|r|radius|refX|refY|renderingIntent|repeatCount|repeatDur|requiredExtensions|requiredFeatures|restart|result|rotate|rx|ry|scale|seed|shapeRendering|slope|spacing|specularConstant|specularExponent|speed|spreadMethod|startOffset|stdDeviation|stemh|stemv|stitchTiles|stopColor|stopOpacity|strikethroughPosition|strikethroughThickness|string|stroke|strokeDasharray|strokeDashoffset|strokeLinecap|strokeLinejoin|strokeMiterlimit|strokeOpacity|strokeWidth|surfaceScale|systemLanguage|tableValues|targetX|targetY|textAnchor|textDecoration|textRendering|textLength|to|transform|u1|u2|underlinePosition|underlineThickness|unicode|unicodeBidi|unicodeRange|unitsPerEm|vAlphabetic|vHanging|vIdeographic|vMathematical|values|vectorEffect|version|vertAdvY|vertOriginX|vertOriginY|viewBox|viewTarget|visibility|widths|wordSpacing|writingMode|x|xHeight|x1|x2|xChannelSelector|xlinkActuate|xlinkArcrole|xlinkHref|xlinkRole|xlinkShow|xlinkTitle|xlinkType|xmlBase|xmlns|xmlnsXlink|xmlLang|xmlSpace|y|y1|y2|yChannelSelector|z|zoomAndPan|for|class|autofocus)|(([Dd][Aa][Tt][Aa]|[Aa][Rr][Ii][Aa]|x)-.*))$/;
var isPropValid = /* @__PURE__ */ memoize$1(
  function(prop) {
    return reactPropsRegex.test(prop) || prop.charCodeAt(0) === 111 && prop.charCodeAt(1) === 110 && prop.charCodeAt(2) < 91;
  }
  /* Z+1 */
);
var isDevelopment = false;
var testOmitPropsOnStringTag = isPropValid;
var testOmitPropsOnComponent = function testOmitPropsOnComponent2(key2) {
  return key2 !== "theme";
};
var getDefaultShouldForwardProp = function getDefaultShouldForwardProp2(tag) {
  return typeof tag === "string" && // 96 is one less than the char code
  // for "a" so this is checking that
  // it's a lowercase character
  tag.charCodeAt(0) > 96 ? testOmitPropsOnStringTag : testOmitPropsOnComponent;
};
var composeShouldForwardProps = function composeShouldForwardProps2(tag, options, isReal) {
  var shouldForwardProp2;
  if (options) {
    var optionsShouldForwardProp = options.shouldForwardProp;
    shouldForwardProp2 = tag.__emotion_forwardProp && optionsShouldForwardProp ? function(propName) {
      return tag.__emotion_forwardProp(propName) && optionsShouldForwardProp(propName);
    } : optionsShouldForwardProp;
  }
  if (typeof shouldForwardProp2 !== "function" && isReal) {
    shouldForwardProp2 = tag.__emotion_forwardProp;
  }
  return shouldForwardProp2;
};
var Insertion2 = function Insertion3(_ref) {
  var cache = _ref.cache, serialized = _ref.serialized, isStringTag2 = _ref.isStringTag;
  registerStyles(cache, serialized, isStringTag2);
  useInsertionEffectAlwaysWithSyncFallback(function() {
    return insertStyles(cache, serialized, isStringTag2);
  });
  return null;
};
var createStyled$1 = function createStyled(tag, options) {
  var isReal = tag.__emotion_real === tag;
  var baseTag = isReal && tag.__emotion_base || tag;
  var identifierName;
  var targetClassName;
  if (options !== void 0) {
    identifierName = options.label;
    targetClassName = options.target;
  }
  var shouldForwardProp2 = composeShouldForwardProps(tag, options, isReal);
  var defaultShouldForwardProp = shouldForwardProp2 || getDefaultShouldForwardProp(baseTag);
  var shouldUseAs = !defaultShouldForwardProp("as");
  return function() {
    var args = arguments;
    var styles2 = isReal && tag.__emotion_styles !== void 0 ? tag.__emotion_styles.slice(0) : [];
    if (identifierName !== void 0) {
      styles2.push("label:" + identifierName + ";");
    }
    if (args[0] == null || args[0].raw === void 0) {
      styles2.push.apply(styles2, args);
    } else {
      var templateStringsArr = args[0];
      styles2.push(templateStringsArr[0]);
      var len = args.length;
      var i2 = 1;
      for (; i2 < len; i2++) {
        styles2.push(args[i2], templateStringsArr[i2]);
      }
    }
    var Styled = withEmotionCache(function(props, cache, ref) {
      var FinalTag = shouldUseAs && props.as || baseTag;
      var className = "";
      var classInterpolations = [];
      var mergedProps = props;
      if (props.theme == null) {
        mergedProps = {};
        for (var key2 in props) {
          mergedProps[key2] = props[key2];
        }
        mergedProps.theme = reactExports.useContext(ThemeContext$1);
      }
      if (typeof props.className === "string") {
        className = getRegisteredStyles(cache.registered, classInterpolations, props.className);
      } else if (props.className != null) {
        className = props.className + " ";
      }
      var serialized = serializeStyles(styles2.concat(classInterpolations), cache.registered, mergedProps);
      className += cache.key + "-" + serialized.name;
      if (targetClassName !== void 0) {
        className += " " + targetClassName;
      }
      var finalShouldForwardProp = shouldUseAs && shouldForwardProp2 === void 0 ? getDefaultShouldForwardProp(FinalTag) : defaultShouldForwardProp;
      var newProps = {};
      for (var _key in props) {
        if (shouldUseAs && _key === "as") continue;
        if (finalShouldForwardProp(_key)) {
          newProps[_key] = props[_key];
        }
      }
      newProps.className = className;
      if (ref) {
        newProps.ref = ref;
      }
      return /* @__PURE__ */ reactExports.createElement(reactExports.Fragment, null, /* @__PURE__ */ reactExports.createElement(Insertion2, {
        cache,
        serialized,
        isStringTag: typeof FinalTag === "string"
      }), /* @__PURE__ */ reactExports.createElement(FinalTag, newProps));
    });
    Styled.displayName = identifierName !== void 0 ? identifierName : "Styled(" + (typeof baseTag === "string" ? baseTag : baseTag.displayName || baseTag.name || "Component") + ")";
    Styled.defaultProps = tag.defaultProps;
    Styled.__emotion_real = Styled;
    Styled.__emotion_base = baseTag;
    Styled.__emotion_styles = styles2;
    Styled.__emotion_forwardProp = shouldForwardProp2;
    Object.defineProperty(Styled, "toString", {
      value: function value() {
        if (targetClassName === void 0 && isDevelopment) {
          return "NO_COMPONENT_SELECTOR";
        }
        return "." + targetClassName;
      }
    });
    Styled.withComponent = function(nextTag, nextOptions) {
      var newStyled = createStyled(nextTag, _extends({}, options, nextOptions, {
        shouldForwardProp: composeShouldForwardProps(Styled, nextOptions, true)
      }));
      return newStyled.apply(void 0, styles2);
    };
    return Styled;
  };
};
var tags = [
  "a",
  "abbr",
  "address",
  "area",
  "article",
  "aside",
  "audio",
  "b",
  "base",
  "bdi",
  "bdo",
  "big",
  "blockquote",
  "body",
  "br",
  "button",
  "canvas",
  "caption",
  "cite",
  "code",
  "col",
  "colgroup",
  "data",
  "datalist",
  "dd",
  "del",
  "details",
  "dfn",
  "dialog",
  "div",
  "dl",
  "dt",
  "em",
  "embed",
  "fieldset",
  "figcaption",
  "figure",
  "footer",
  "form",
  "h1",
  "h2",
  "h3",
  "h4",
  "h5",
  "h6",
  "head",
  "header",
  "hgroup",
  "hr",
  "html",
  "i",
  "iframe",
  "img",
  "input",
  "ins",
  "kbd",
  "keygen",
  "label",
  "legend",
  "li",
  "link",
  "main",
  "map",
  "mark",
  "marquee",
  "menu",
  "menuitem",
  "meta",
  "meter",
  "nav",
  "noscript",
  "object",
  "ol",
  "optgroup",
  "option",
  "output",
  "p",
  "param",
  "picture",
  "pre",
  "progress",
  "q",
  "rp",
  "rt",
  "ruby",
  "s",
  "samp",
  "script",
  "section",
  "select",
  "small",
  "source",
  "span",
  "strong",
  "style",
  "sub",
  "summary",
  "sup",
  "table",
  "tbody",
  "td",
  "textarea",
  "tfoot",
  "th",
  "thead",
  "time",
  "title",
  "tr",
  "track",
  "u",
  "ul",
  "var",
  "video",
  "wbr",
  // SVG
  "circle",
  "clipPath",
  "defs",
  "ellipse",
  "foreignObject",
  "g",
  "image",
  "line",
  "linearGradient",
  "mask",
  "path",
  "pattern",
  "polygon",
  "polyline",
  "radialGradient",
  "rect",
  "stop",
  "svg",
  "text",
  "tspan"
];
var styled$3 = createStyled$1.bind(null);
tags.forEach(function(tagName) {
  styled$3[tagName] = styled$3(tagName);
});
function isEmpty(obj) {
  return obj === void 0 || obj === null || Object.keys(obj).length === 0;
}
function GlobalStyles$2(props) {
  const {
    styles: styles2,
    defaultTheme: defaultTheme2 = {}
  } = props;
  const globalStyles = typeof styles2 === "function" ? (themeInput) => styles2(isEmpty(themeInput) ? defaultTheme2 : themeInput) : styles2;
  return /* @__PURE__ */ jsxRuntimeExports.jsx(Global, {
    styles: globalStyles
  });
}
function styled$2(tag, options) {
  const stylesFactory = styled$3(tag, options);
  return stylesFactory;
}
function internal_mutateStyles(tag, processor) {
  if (Array.isArray(tag.__emotion_styles)) {
    tag.__emotion_styles = processor(tag.__emotion_styles);
  }
}
const wrapper = [];
function internal_serializeStyles(styles2) {
  wrapper[0] = styles2;
  return serializeStyles(wrapper);
}
var reactIs = { exports: {} };
var reactIs_production = {};
/**
 * @license React
 * react-is.production.js
 *
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var REACT_ELEMENT_TYPE = Symbol.for("react.transitional.element"), REACT_PORTAL_TYPE = Symbol.for("react.portal"), REACT_FRAGMENT_TYPE = Symbol.for("react.fragment"), REACT_STRICT_MODE_TYPE = Symbol.for("react.strict_mode"), REACT_PROFILER_TYPE = Symbol.for("react.profiler");
var REACT_CONSUMER_TYPE = Symbol.for("react.consumer"), REACT_CONTEXT_TYPE = Symbol.for("react.context"), REACT_FORWARD_REF_TYPE = Symbol.for("react.forward_ref"), REACT_SUSPENSE_TYPE = Symbol.for("react.suspense"), REACT_SUSPENSE_LIST_TYPE = Symbol.for("react.suspense_list"), REACT_MEMO_TYPE = Symbol.for("react.memo"), REACT_LAZY_TYPE = Symbol.for("react.lazy"), REACT_VIEW_TRANSITION_TYPE = Symbol.for("react.view_transition"), REACT_CLIENT_REFERENCE = Symbol.for("react.client.reference");
function typeOf(object) {
  if ("object" === typeof object && null !== object) {
    var $$typeof = object.$$typeof;
    switch ($$typeof) {
      case REACT_ELEMENT_TYPE:
        switch (object = object.type, object) {
          case REACT_FRAGMENT_TYPE:
          case REACT_PROFILER_TYPE:
          case REACT_STRICT_MODE_TYPE:
          case REACT_SUSPENSE_TYPE:
          case REACT_SUSPENSE_LIST_TYPE:
          case REACT_VIEW_TRANSITION_TYPE:
            return object;
          default:
            switch (object = object && object.$$typeof, object) {
              case REACT_CONTEXT_TYPE:
              case REACT_FORWARD_REF_TYPE:
              case REACT_LAZY_TYPE:
              case REACT_MEMO_TYPE:
                return object;
              case REACT_CONSUMER_TYPE:
                return object;
              default:
                return $$typeof;
            }
        }
      case REACT_PORTAL_TYPE:
        return $$typeof;
    }
  }
}
reactIs_production.ContextConsumer = REACT_CONSUMER_TYPE;
reactIs_production.ContextProvider = REACT_CONTEXT_TYPE;
reactIs_production.Element = REACT_ELEMENT_TYPE;
reactIs_production.ForwardRef = REACT_FORWARD_REF_TYPE;
reactIs_production.Fragment = REACT_FRAGMENT_TYPE;
reactIs_production.Lazy = REACT_LAZY_TYPE;
reactIs_production.Memo = REACT_MEMO_TYPE;
reactIs_production.Portal = REACT_PORTAL_TYPE;
reactIs_production.Profiler = REACT_PROFILER_TYPE;
reactIs_production.StrictMode = REACT_STRICT_MODE_TYPE;
reactIs_production.Suspense = REACT_SUSPENSE_TYPE;
reactIs_production.SuspenseList = REACT_SUSPENSE_LIST_TYPE;
reactIs_production.isContextConsumer = function(object) {
  return typeOf(object) === REACT_CONSUMER_TYPE;
};
reactIs_production.isContextProvider = function(object) {
  return typeOf(object) === REACT_CONTEXT_TYPE;
};
reactIs_production.isElement = function(object) {
  return "object" === typeof object && null !== object && object.$$typeof === REACT_ELEMENT_TYPE;
};
reactIs_production.isForwardRef = function(object) {
  return typeOf(object) === REACT_FORWARD_REF_TYPE;
};
reactIs_production.isFragment = function(object) {
  return typeOf(object) === REACT_FRAGMENT_TYPE;
};
reactIs_production.isLazy = function(object) {
  return typeOf(object) === REACT_LAZY_TYPE;
};
reactIs_production.isMemo = function(object) {
  return typeOf(object) === REACT_MEMO_TYPE;
};
reactIs_production.isPortal = function(object) {
  return typeOf(object) === REACT_PORTAL_TYPE;
};
reactIs_production.isProfiler = function(object) {
  return typeOf(object) === REACT_PROFILER_TYPE;
};
reactIs_production.isStrictMode = function(object) {
  return typeOf(object) === REACT_STRICT_MODE_TYPE;
};
reactIs_production.isSuspense = function(object) {
  return typeOf(object) === REACT_SUSPENSE_TYPE;
};
reactIs_production.isSuspenseList = function(object) {
  return typeOf(object) === REACT_SUSPENSE_LIST_TYPE;
};
reactIs_production.isValidElementType = function(type) {
  return "string" === typeof type || "function" === typeof type || type === REACT_FRAGMENT_TYPE || type === REACT_PROFILER_TYPE || type === REACT_STRICT_MODE_TYPE || type === REACT_SUSPENSE_TYPE || type === REACT_SUSPENSE_LIST_TYPE || "object" === typeof type && null !== type && (type.$$typeof === REACT_LAZY_TYPE || type.$$typeof === REACT_MEMO_TYPE || type.$$typeof === REACT_CONTEXT_TYPE || type.$$typeof === REACT_CONSUMER_TYPE || type.$$typeof === REACT_FORWARD_REF_TYPE || type.$$typeof === REACT_CLIENT_REFERENCE || void 0 !== type.getModuleId) ? true : false;
};
reactIs_production.typeOf = typeOf;
{
  reactIs.exports = reactIs_production;
}
var reactIsExports = reactIs.exports;
function isPlainObject(item) {
  if (typeof item !== "object" || item === null) {
    return false;
  }
  const prototype = Object.getPrototypeOf(item);
  return (prototype === null || prototype === Object.prototype || Object.getPrototypeOf(prototype) === null) && !(Symbol.toStringTag in item) && !(Symbol.iterator in item);
}
function deepClone(source) {
  if (/* @__PURE__ */ reactExports.isValidElement(source) || reactIsExports.isValidElementType(source) || !isPlainObject(source)) {
    return source;
  }
  const output = {};
  Object.keys(source).forEach((key2) => {
    output[key2] = deepClone(source[key2]);
  });
  return output;
}
function deepmerge(target, source, options = {
  clone: true
}) {
  const output = options.clone ? {
    ...target
  } : target;
  if (isPlainObject(target) && isPlainObject(source)) {
    Object.keys(source).forEach((key2) => {
      if (/* @__PURE__ */ reactExports.isValidElement(source[key2]) || reactIsExports.isValidElementType(source[key2])) {
        output[key2] = source[key2];
      } else if (isPlainObject(source[key2]) && // Avoid prototype pollution
      Object.prototype.hasOwnProperty.call(target, key2) && isPlainObject(target[key2])) {
        output[key2] = deepmerge(target[key2], source[key2], options);
      } else if (options.clone) {
        output[key2] = isPlainObject(source[key2]) ? deepClone(source[key2]) : source[key2];
      } else {
        output[key2] = source[key2];
      }
    });
  }
  return output;
}
const sortBreakpointsValues = (values2) => {
  const breakpointsAsArray = Object.keys(values2).map((key2) => ({
    key: key2,
    val: values2[key2]
  })) || [];
  breakpointsAsArray.sort((breakpoint1, breakpoint2) => breakpoint1.val - breakpoint2.val);
  return breakpointsAsArray.reduce((acc, obj) => {
    return {
      ...acc,
      [obj.key]: obj.val
    };
  }, {});
};
function createBreakpoints(breakpoints) {
  const {
    // The breakpoint **start** at this value.
    // For instance with the first breakpoint xs: [xs, sm).
    values: values2 = {
      xs: 0,
      // phone
      sm: 600,
      // tablet
      md: 900,
      // small laptop
      lg: 1200,
      // desktop
      xl: 1536
      // large screen
    },
    unit = "px",
    step = 5,
    ...other
  } = breakpoints;
  const sortedValues = sortBreakpointsValues(values2);
  const keys = Object.keys(sortedValues);
  function up(key2) {
    const value = typeof values2[key2] === "number" ? values2[key2] : key2;
    return `@media (min-width:${value}${unit})`;
  }
  function down(key2) {
    const value = typeof values2[key2] === "number" ? values2[key2] : key2;
    return `@media (max-width:${value - step / 100}${unit})`;
  }
  function between(start, end) {
    const endIndex = keys.indexOf(end);
    return `@media (min-width:${typeof values2[start] === "number" ? values2[start] : start}${unit}) and (max-width:${(endIndex !== -1 && typeof values2[keys[endIndex]] === "number" ? values2[keys[endIndex]] : end) - step / 100}${unit})`;
  }
  function only(key2) {
    if (keys.indexOf(key2) + 1 < keys.length) {
      return between(key2, keys[keys.indexOf(key2) + 1]);
    }
    return up(key2);
  }
  function not(key2) {
    const keyIndex = keys.indexOf(key2);
    if (keyIndex === 0) {
      return up(keys[1]);
    }
    if (keyIndex === keys.length - 1) {
      return down(keys[keyIndex]);
    }
    return between(key2, keys[keys.indexOf(key2) + 1]).replace("@media", "@media not all and");
  }
  return {
    keys,
    values: sortedValues,
    up,
    down,
    between,
    only,
    not,
    unit,
    ...other
  };
}
function sortContainerQueries(theme, css2) {
  if (!theme.containerQueries) {
    return css2;
  }
  const sorted = Object.keys(css2).filter((key2) => key2.startsWith("@container")).sort((a2, b2) => {
    const regex = /min-width:\s*([0-9.]+)/;
    return +(a2.match(regex)?.[1] || 0) - +(b2.match(regex)?.[1] || 0);
  });
  if (!sorted.length) {
    return css2;
  }
  return sorted.reduce((acc, key2) => {
    const value = css2[key2];
    delete acc[key2];
    acc[key2] = value;
    return acc;
  }, {
    ...css2
  });
}
function isCqShorthand(breakpointKeys, value) {
  return value === "@" || value.startsWith("@") && (breakpointKeys.some((key2) => value.startsWith(`@${key2}`)) || !!value.match(/^@\d/));
}
function getContainerQuery(theme, shorthand) {
  const matches = shorthand.match(/^@([^/]+)?\/?(.+)?$/);
  if (!matches) {
    return null;
  }
  const [, containerQuery, containerName] = matches;
  const value = Number.isNaN(+containerQuery) ? containerQuery || 0 : +containerQuery;
  return theme.containerQueries(containerName).up(value);
}
function cssContainerQueries(themeInput) {
  const toContainerQuery = (mediaQuery, name) => mediaQuery.replace("@media", name ? `@container ${name}` : "@container");
  function attachCq(node22, name) {
    node22.up = (...args) => toContainerQuery(themeInput.breakpoints.up(...args), name);
    node22.down = (...args) => toContainerQuery(themeInput.breakpoints.down(...args), name);
    node22.between = (...args) => toContainerQuery(themeInput.breakpoints.between(...args), name);
    node22.only = (...args) => toContainerQuery(themeInput.breakpoints.only(...args), name);
    node22.not = (...args) => {
      const result = toContainerQuery(themeInput.breakpoints.not(...args), name);
      if (result.includes("not all and")) {
        return result.replace("not all and ", "").replace("min-width:", "width<").replace("max-width:", "width>").replace("and", "or");
      }
      return result;
    };
  }
  const node2 = {};
  const containerQueries = (name) => {
    attachCq(node2, name);
    return node2;
  };
  attachCq(containerQueries);
  return {
    ...themeInput,
    containerQueries
  };
}
const shape = {
  borderRadius: 4
};
function merge(acc, item) {
  if (!item) {
    return acc;
  }
  return deepmerge(acc, item, {
    clone: false
    // No need to clone deep, it's way faster.
  });
}
const values$1 = {
  xs: 0,
  // phone
  sm: 600,
  // tablet
  md: 900,
  // small laptop
  lg: 1200,
  // desktop
  xl: 1536
  // large screen
};
const defaultBreakpoints = {
  // Sorted ASC by size. That's important.
  // It can't be configured as it's used statically for propTypes.
  keys: ["xs", "sm", "md", "lg", "xl"],
  up: (key2) => `@media (min-width:${values$1[key2]}px)`
};
const defaultContainerQueries = {
  containerQueries: (containerName) => ({
    up: (key2) => {
      let result = typeof key2 === "number" ? key2 : values$1[key2] || key2;
      if (typeof result === "number") {
        result = `${result}px`;
      }
      return containerName ? `@container ${containerName} (min-width:${result})` : `@container (min-width:${result})`;
    }
  })
};
function handleBreakpoints(props, propValue, styleFromPropValue) {
  const theme = props.theme || {};
  if (Array.isArray(propValue)) {
    const themeBreakpoints = theme.breakpoints || defaultBreakpoints;
    return propValue.reduce((acc, item, index2) => {
      acc[themeBreakpoints.up(themeBreakpoints.keys[index2])] = styleFromPropValue(propValue[index2]);
      return acc;
    }, {});
  }
  if (typeof propValue === "object") {
    const themeBreakpoints = theme.breakpoints || defaultBreakpoints;
    return Object.keys(propValue).reduce((acc, breakpoint) => {
      if (isCqShorthand(themeBreakpoints.keys, breakpoint)) {
        const containerKey = getContainerQuery(theme.containerQueries ? theme : defaultContainerQueries, breakpoint);
        if (containerKey) {
          acc[containerKey] = styleFromPropValue(propValue[breakpoint], breakpoint);
        }
      } else if (Object.keys(themeBreakpoints.values || values$1).includes(breakpoint)) {
        const mediaKey = themeBreakpoints.up(breakpoint);
        acc[mediaKey] = styleFromPropValue(propValue[breakpoint], breakpoint);
      } else {
        const cssKey = breakpoint;
        acc[cssKey] = propValue[cssKey];
      }
      return acc;
    }, {});
  }
  const output = styleFromPropValue(propValue);
  return output;
}
function createEmptyBreakpointObject(breakpointsInput = {}) {
  const breakpointsInOrder = breakpointsInput.keys?.reduce((acc, key2) => {
    const breakpointStyleKey = breakpointsInput.up(key2);
    acc[breakpointStyleKey] = {};
    return acc;
  }, {});
  return breakpointsInOrder || {};
}
function removeUnusedBreakpoints(breakpointKeys, style2) {
  return breakpointKeys.reduce((acc, key2) => {
    const breakpointOutput = acc[key2];
    const isBreakpointUnused = !breakpointOutput || Object.keys(breakpointOutput).length === 0;
    if (isBreakpointUnused) {
      delete acc[key2];
    }
    return acc;
  }, style2);
}
function capitalize(string) {
  if (typeof string !== "string") {
    throw new Error(formatMuiErrorMessage(7));
  }
  return string.charAt(0).toUpperCase() + string.slice(1);
}
function getPath(obj, path, checkVars = true) {
  if (!path || typeof path !== "string") {
    return null;
  }
  if (obj && obj.vars && checkVars) {
    const val = `vars.${path}`.split(".").reduce((acc, item) => acc && acc[item] ? acc[item] : null, obj);
    if (val != null) {
      return val;
    }
  }
  return path.split(".").reduce((acc, item) => {
    if (acc && acc[item] != null) {
      return acc[item];
    }
    return null;
  }, obj);
}
function getStyleValue(themeMapping, transform2, propValueFinal, userValue = propValueFinal) {
  let value;
  if (typeof themeMapping === "function") {
    value = themeMapping(propValueFinal);
  } else if (Array.isArray(themeMapping)) {
    value = themeMapping[propValueFinal] || userValue;
  } else {
    value = getPath(themeMapping, propValueFinal) || userValue;
  }
  if (transform2) {
    value = transform2(value, userValue, themeMapping);
  }
  return value;
}
function style$1(options) {
  const {
    prop,
    cssProperty = options.prop,
    themeKey,
    transform: transform2
  } = options;
  const fn = (props) => {
    if (props[prop] == null) {
      return null;
    }
    const propValue = props[prop];
    const theme = props.theme;
    const themeMapping = getPath(theme, themeKey) || {};
    const styleFromPropValue = (propValueFinal) => {
      let value = getStyleValue(themeMapping, transform2, propValueFinal);
      if (propValueFinal === value && typeof propValueFinal === "string") {
        value = getStyleValue(themeMapping, transform2, `${prop}${propValueFinal === "default" ? "" : capitalize(propValueFinal)}`, propValueFinal);
      }
      if (cssProperty === false) {
        return value;
      }
      return {
        [cssProperty]: value
      };
    };
    return handleBreakpoints(props, propValue, styleFromPropValue);
  };
  fn.propTypes = {};
  fn.filterProps = [prop];
  return fn;
}
function memoize(fn) {
  const cache = {};
  return (arg2) => {
    if (cache[arg2] === void 0) {
      cache[arg2] = fn(arg2);
    }
    return cache[arg2];
  };
}
const properties = {
  m: "margin",
  p: "padding"
};
const directions = {
  t: "Top",
  r: "Right",
  b: "Bottom",
  l: "Left",
  x: ["Left", "Right"],
  y: ["Top", "Bottom"]
};
const aliases = {
  marginX: "mx",
  marginY: "my",
  paddingX: "px",
  paddingY: "py"
};
const getCssProperties = memoize((prop) => {
  if (prop.length > 2) {
    if (aliases[prop]) {
      prop = aliases[prop];
    } else {
      return [prop];
    }
  }
  const [a2, b2] = prop.split("");
  const property = properties[a2];
  const direction = directions[b2] || "";
  return Array.isArray(direction) ? direction.map((dir) => property + dir) : [property + direction];
});
const marginKeys = ["m", "mt", "mr", "mb", "ml", "mx", "my", "margin", "marginTop", "marginRight", "marginBottom", "marginLeft", "marginX", "marginY", "marginInline", "marginInlineStart", "marginInlineEnd", "marginBlock", "marginBlockStart", "marginBlockEnd"];
const paddingKeys = ["p", "pt", "pr", "pb", "pl", "px", "py", "padding", "paddingTop", "paddingRight", "paddingBottom", "paddingLeft", "paddingX", "paddingY", "paddingInline", "paddingInlineStart", "paddingInlineEnd", "paddingBlock", "paddingBlockStart", "paddingBlockEnd"];
[...marginKeys, ...paddingKeys];
function createUnaryUnit(theme, themeKey, defaultValue, propName) {
  const themeSpacing = getPath(theme, themeKey, true) ?? defaultValue;
  if (typeof themeSpacing === "number" || typeof themeSpacing === "string") {
    return (val) => {
      if (typeof val === "string") {
        return val;
      }
      if (typeof themeSpacing === "string") {
        if (themeSpacing.startsWith("var(") && val === 0) {
          return 0;
        }
        if (themeSpacing.startsWith("var(") && val === 1) {
          return themeSpacing;
        }
        return `calc(${val} * ${themeSpacing})`;
      }
      return themeSpacing * val;
    };
  }
  if (Array.isArray(themeSpacing)) {
    return (val) => {
      if (typeof val === "string") {
        return val;
      }
      const abs2 = Math.abs(val);
      const transformed = themeSpacing[abs2];
      if (val >= 0) {
        return transformed;
      }
      if (typeof transformed === "number") {
        return -transformed;
      }
      if (typeof transformed === "string" && transformed.startsWith("var(")) {
        return `calc(-1 * ${transformed})`;
      }
      return `-${transformed}`;
    };
  }
  if (typeof themeSpacing === "function") {
    return themeSpacing;
  }
  return () => void 0;
}
function createUnarySpacing(theme) {
  return createUnaryUnit(theme, "spacing", 8);
}
function getValue(transformer, propValue) {
  if (typeof propValue === "string" || propValue == null) {
    return propValue;
  }
  return transformer(propValue);
}
function getStyleFromPropValue(cssProperties, transformer) {
  return (propValue) => cssProperties.reduce((acc, cssProperty) => {
    acc[cssProperty] = getValue(transformer, propValue);
    return acc;
  }, {});
}
function resolveCssProperty(props, keys, prop, transformer) {
  if (!keys.includes(prop)) {
    return null;
  }
  const cssProperties = getCssProperties(prop);
  const styleFromPropValue = getStyleFromPropValue(cssProperties, transformer);
  const propValue = props[prop];
  return handleBreakpoints(props, propValue, styleFromPropValue);
}
function style(props, keys) {
  const transformer = createUnarySpacing(props.theme);
  return Object.keys(props).map((prop) => resolveCssProperty(props, keys, prop, transformer)).reduce(merge, {});
}
function margin(props) {
  return style(props, marginKeys);
}
margin.propTypes = {};
margin.filterProps = marginKeys;
function padding(props) {
  return style(props, paddingKeys);
}
padding.propTypes = {};
padding.filterProps = paddingKeys;
function createSpacing(spacingInput = 8, transform2 = createUnarySpacing({
  spacing: spacingInput
})) {
  if (spacingInput.mui) {
    return spacingInput;
  }
  const spacing = (...argsInput) => {
    const args = argsInput.length === 0 ? [1] : argsInput;
    return args.map((argument) => {
      const output = transform2(argument);
      return typeof output === "number" ? `${output}px` : output;
    }).join(" ");
  };
  spacing.mui = true;
  return spacing;
}
function compose(...styles2) {
  const handlers = styles2.reduce((acc, style2) => {
    style2.filterProps.forEach((prop) => {
      acc[prop] = style2;
    });
    return acc;
  }, {});
  const fn = (props) => {
    return Object.keys(props).reduce((acc, prop) => {
      if (handlers[prop]) {
        return merge(acc, handlers[prop](props));
      }
      return acc;
    }, {});
  };
  fn.propTypes = {};
  fn.filterProps = styles2.reduce((acc, style2) => acc.concat(style2.filterProps), []);
  return fn;
}
function borderTransform(value) {
  if (typeof value !== "number") {
    return value;
  }
  return `${value}px solid`;
}
function createBorderStyle(prop, transform2) {
  return style$1({
    prop,
    themeKey: "borders",
    transform: transform2
  });
}
const border = createBorderStyle("border", borderTransform);
const borderTop = createBorderStyle("borderTop", borderTransform);
const borderRight = createBorderStyle("borderRight", borderTransform);
const borderBottom = createBorderStyle("borderBottom", borderTransform);
const borderLeft = createBorderStyle("borderLeft", borderTransform);
const borderColor = createBorderStyle("borderColor");
const borderTopColor = createBorderStyle("borderTopColor");
const borderRightColor = createBorderStyle("borderRightColor");
const borderBottomColor = createBorderStyle("borderBottomColor");
const borderLeftColor = createBorderStyle("borderLeftColor");
const outline = createBorderStyle("outline", borderTransform);
const outlineColor = createBorderStyle("outlineColor");
const borderRadius = (props) => {
  if (props.borderRadius !== void 0 && props.borderRadius !== null) {
    const transformer = createUnaryUnit(props.theme, "shape.borderRadius", 4);
    const styleFromPropValue = (propValue) => ({
      borderRadius: getValue(transformer, propValue)
    });
    return handleBreakpoints(props, props.borderRadius, styleFromPropValue);
  }
  return null;
};
borderRadius.propTypes = {};
borderRadius.filterProps = ["borderRadius"];
compose(border, borderTop, borderRight, borderBottom, borderLeft, borderColor, borderTopColor, borderRightColor, borderBottomColor, borderLeftColor, borderRadius, outline, outlineColor);
const gap = (props) => {
  if (props.gap !== void 0 && props.gap !== null) {
    const transformer = createUnaryUnit(props.theme, "spacing", 8);
    const styleFromPropValue = (propValue) => ({
      gap: getValue(transformer, propValue)
    });
    return handleBreakpoints(props, props.gap, styleFromPropValue);
  }
  return null;
};
gap.propTypes = {};
gap.filterProps = ["gap"];
const columnGap = (props) => {
  if (props.columnGap !== void 0 && props.columnGap !== null) {
    const transformer = createUnaryUnit(props.theme, "spacing", 8);
    const styleFromPropValue = (propValue) => ({
      columnGap: getValue(transformer, propValue)
    });
    return handleBreakpoints(props, props.columnGap, styleFromPropValue);
  }
  return null;
};
columnGap.propTypes = {};
columnGap.filterProps = ["columnGap"];
const rowGap = (props) => {
  if (props.rowGap !== void 0 && props.rowGap !== null) {
    const transformer = createUnaryUnit(props.theme, "spacing", 8);
    const styleFromPropValue = (propValue) => ({
      rowGap: getValue(transformer, propValue)
    });
    return handleBreakpoints(props, props.rowGap, styleFromPropValue);
  }
  return null;
};
rowGap.propTypes = {};
rowGap.filterProps = ["rowGap"];
const gridColumn = style$1({
  prop: "gridColumn"
});
const gridRow = style$1({
  prop: "gridRow"
});
const gridAutoFlow = style$1({
  prop: "gridAutoFlow"
});
const gridAutoColumns = style$1({
  prop: "gridAutoColumns"
});
const gridAutoRows = style$1({
  prop: "gridAutoRows"
});
const gridTemplateColumns = style$1({
  prop: "gridTemplateColumns"
});
const gridTemplateRows = style$1({
  prop: "gridTemplateRows"
});
const gridTemplateAreas = style$1({
  prop: "gridTemplateAreas"
});
const gridArea = style$1({
  prop: "gridArea"
});
compose(gap, columnGap, rowGap, gridColumn, gridRow, gridAutoFlow, gridAutoColumns, gridAutoRows, gridTemplateColumns, gridTemplateRows, gridTemplateAreas, gridArea);
function paletteTransform(value, userValue) {
  if (userValue === "grey") {
    return userValue;
  }
  return value;
}
const color = style$1({
  prop: "color",
  themeKey: "palette",
  transform: paletteTransform
});
const bgcolor = style$1({
  prop: "bgcolor",
  cssProperty: "backgroundColor",
  themeKey: "palette",
  transform: paletteTransform
});
const backgroundColor = style$1({
  prop: "backgroundColor",
  themeKey: "palette",
  transform: paletteTransform
});
compose(color, bgcolor, backgroundColor);
function sizingTransform(value) {
  return value <= 1 && value !== 0 ? `${value * 100}%` : value;
}
const width = style$1({
  prop: "width",
  transform: sizingTransform
});
const maxWidth = (props) => {
  if (props.maxWidth !== void 0 && props.maxWidth !== null) {
    const styleFromPropValue = (propValue) => {
      const breakpoint = props.theme?.breakpoints?.values?.[propValue] || values$1[propValue];
      if (!breakpoint) {
        return {
          maxWidth: sizingTransform(propValue)
        };
      }
      if (props.theme?.breakpoints?.unit !== "px") {
        return {
          maxWidth: `${breakpoint}${props.theme.breakpoints.unit}`
        };
      }
      return {
        maxWidth: breakpoint
      };
    };
    return handleBreakpoints(props, props.maxWidth, styleFromPropValue);
  }
  return null;
};
maxWidth.filterProps = ["maxWidth"];
const minWidth = style$1({
  prop: "minWidth",
  transform: sizingTransform
});
const height = style$1({
  prop: "height",
  transform: sizingTransform
});
const maxHeight = style$1({
  prop: "maxHeight",
  transform: sizingTransform
});
const minHeight = style$1({
  prop: "minHeight",
  transform: sizingTransform
});
style$1({
  prop: "size",
  cssProperty: "width",
  transform: sizingTransform
});
style$1({
  prop: "size",
  cssProperty: "height",
  transform: sizingTransform
});
const boxSizing = style$1({
  prop: "boxSizing"
});
compose(width, maxWidth, minWidth, height, maxHeight, minHeight, boxSizing);
const defaultSxConfig = {
  // borders
  border: {
    themeKey: "borders",
    transform: borderTransform
  },
  borderTop: {
    themeKey: "borders",
    transform: borderTransform
  },
  borderRight: {
    themeKey: "borders",
    transform: borderTransform
  },
  borderBottom: {
    themeKey: "borders",
    transform: borderTransform
  },
  borderLeft: {
    themeKey: "borders",
    transform: borderTransform
  },
  borderColor: {
    themeKey: "palette"
  },
  borderTopColor: {
    themeKey: "palette"
  },
  borderRightColor: {
    themeKey: "palette"
  },
  borderBottomColor: {
    themeKey: "palette"
  },
  borderLeftColor: {
    themeKey: "palette"
  },
  outline: {
    themeKey: "borders",
    transform: borderTransform
  },
  outlineColor: {
    themeKey: "palette"
  },
  borderRadius: {
    themeKey: "shape.borderRadius",
    style: borderRadius
  },
  // palette
  color: {
    themeKey: "palette",
    transform: paletteTransform
  },
  bgcolor: {
    themeKey: "palette",
    cssProperty: "backgroundColor",
    transform: paletteTransform
  },
  backgroundColor: {
    themeKey: "palette",
    transform: paletteTransform
  },
  // spacing
  p: {
    style: padding
  },
  pt: {
    style: padding
  },
  pr: {
    style: padding
  },
  pb: {
    style: padding
  },
  pl: {
    style: padding
  },
  px: {
    style: padding
  },
  py: {
    style: padding
  },
  padding: {
    style: padding
  },
  paddingTop: {
    style: padding
  },
  paddingRight: {
    style: padding
  },
  paddingBottom: {
    style: padding
  },
  paddingLeft: {
    style: padding
  },
  paddingX: {
    style: padding
  },
  paddingY: {
    style: padding
  },
  paddingInline: {
    style: padding
  },
  paddingInlineStart: {
    style: padding
  },
  paddingInlineEnd: {
    style: padding
  },
  paddingBlock: {
    style: padding
  },
  paddingBlockStart: {
    style: padding
  },
  paddingBlockEnd: {
    style: padding
  },
  m: {
    style: margin
  },
  mt: {
    style: margin
  },
  mr: {
    style: margin
  },
  mb: {
    style: margin
  },
  ml: {
    style: margin
  },
  mx: {
    style: margin
  },
  my: {
    style: margin
  },
  margin: {
    style: margin
  },
  marginTop: {
    style: margin
  },
  marginRight: {
    style: margin
  },
  marginBottom: {
    style: margin
  },
  marginLeft: {
    style: margin
  },
  marginX: {
    style: margin
  },
  marginY: {
    style: margin
  },
  marginInline: {
    style: margin
  },
  marginInlineStart: {
    style: margin
  },
  marginInlineEnd: {
    style: margin
  },
  marginBlock: {
    style: margin
  },
  marginBlockStart: {
    style: margin
  },
  marginBlockEnd: {
    style: margin
  },
  // display
  displayPrint: {
    cssProperty: false,
    transform: (value) => ({
      "@media print": {
        display: value
      }
    })
  },
  display: {},
  overflow: {},
  textOverflow: {},
  visibility: {},
  whiteSpace: {},
  // flexbox
  flexBasis: {},
  flexDirection: {},
  flexWrap: {},
  justifyContent: {},
  alignItems: {},
  alignContent: {},
  order: {},
  flex: {},
  flexGrow: {},
  flexShrink: {},
  alignSelf: {},
  justifyItems: {},
  justifySelf: {},
  // grid
  gap: {
    style: gap
  },
  rowGap: {
    style: rowGap
  },
  columnGap: {
    style: columnGap
  },
  gridColumn: {},
  gridRow: {},
  gridAutoFlow: {},
  gridAutoColumns: {},
  gridAutoRows: {},
  gridTemplateColumns: {},
  gridTemplateRows: {},
  gridTemplateAreas: {},
  gridArea: {},
  // positions
  position: {},
  zIndex: {
    themeKey: "zIndex"
  },
  top: {},
  right: {},
  bottom: {},
  left: {},
  // shadows
  boxShadow: {
    themeKey: "shadows"
  },
  // sizing
  width: {
    transform: sizingTransform
  },
  maxWidth: {
    style: maxWidth
  },
  minWidth: {
    transform: sizingTransform
  },
  height: {
    transform: sizingTransform
  },
  maxHeight: {
    transform: sizingTransform
  },
  minHeight: {
    transform: sizingTransform
  },
  boxSizing: {},
  // typography
  font: {
    themeKey: "font"
  },
  fontFamily: {
    themeKey: "typography"
  },
  fontSize: {
    themeKey: "typography"
  },
  fontStyle: {
    themeKey: "typography"
  },
  fontWeight: {
    themeKey: "typography"
  },
  letterSpacing: {},
  textTransform: {},
  lineHeight: {},
  textAlign: {},
  typography: {
    cssProperty: false,
    themeKey: "typography"
  }
};
function objectsHaveSameKeys(...objects) {
  const allKeys = objects.reduce((keys, object) => keys.concat(Object.keys(object)), []);
  const union = new Set(allKeys);
  return objects.every((object) => union.size === Object.keys(object).length);
}
function callIfFn(maybeFn, arg2) {
  return typeof maybeFn === "function" ? maybeFn(arg2) : maybeFn;
}
function unstable_createStyleFunctionSx() {
  function getThemeValue(prop, val, theme, config2) {
    const props = {
      [prop]: val,
      theme
    };
    const options = config2[prop];
    if (!options) {
      return {
        [prop]: val
      };
    }
    const {
      cssProperty = prop,
      themeKey,
      transform: transform2,
      style: style2
    } = options;
    if (val == null) {
      return null;
    }
    if (themeKey === "typography" && val === "inherit") {
      return {
        [prop]: val
      };
    }
    const themeMapping = getPath(theme, themeKey) || {};
    if (style2) {
      return style2(props);
    }
    const styleFromPropValue = (propValueFinal) => {
      let value = getStyleValue(themeMapping, transform2, propValueFinal);
      if (propValueFinal === value && typeof propValueFinal === "string") {
        value = getStyleValue(themeMapping, transform2, `${prop}${propValueFinal === "default" ? "" : capitalize(propValueFinal)}`, propValueFinal);
      }
      if (cssProperty === false) {
        return value;
      }
      return {
        [cssProperty]: value
      };
    };
    return handleBreakpoints(props, val, styleFromPropValue);
  }
  function styleFunctionSx2(props) {
    const {
      sx,
      theme = {},
      nested: nested2
    } = props || {};
    if (!sx) {
      return null;
    }
    const config2 = theme.unstable_sxConfig ?? defaultSxConfig;
    function traverse(sxInput) {
      let sxObject = sxInput;
      if (typeof sxInput === "function") {
        sxObject = sxInput(theme);
      } else if (typeof sxInput !== "object") {
        return sxInput;
      }
      if (!sxObject) {
        return null;
      }
      const emptyBreakpoints = createEmptyBreakpointObject(theme.breakpoints);
      const breakpointsKeys = Object.keys(emptyBreakpoints);
      let css2 = emptyBreakpoints;
      Object.keys(sxObject).forEach((styleKey) => {
        const value = callIfFn(sxObject[styleKey], theme);
        if (value !== null && value !== void 0) {
          if (typeof value === "object") {
            if (config2[styleKey]) {
              css2 = merge(css2, getThemeValue(styleKey, value, theme, config2));
            } else {
              const breakpointsValues = handleBreakpoints({
                theme
              }, value, (x2) => ({
                [styleKey]: x2
              }));
              if (objectsHaveSameKeys(breakpointsValues, value)) {
                css2[styleKey] = styleFunctionSx2({
                  sx: value,
                  theme,
                  nested: true
                });
              } else {
                css2 = merge(css2, breakpointsValues);
              }
            }
          } else {
            css2 = merge(css2, getThemeValue(styleKey, value, theme, config2));
          }
        }
      });
      if (!nested2 && theme.modularCssLayers) {
        return {
          "@layer sx": sortContainerQueries(theme, removeUnusedBreakpoints(breakpointsKeys, css2))
        };
      }
      return sortContainerQueries(theme, removeUnusedBreakpoints(breakpointsKeys, css2));
    }
    return Array.isArray(sx) ? sx.map(traverse) : traverse(sx);
  }
  return styleFunctionSx2;
}
const styleFunctionSx = unstable_createStyleFunctionSx();
styleFunctionSx.filterProps = ["sx"];
function applyStyles(key2, styles2) {
  const theme = this;
  if (theme.vars) {
    if (!theme.colorSchemes?.[key2] || typeof theme.getColorSchemeSelector !== "function") {
      return {};
    }
    let selector = theme.getColorSchemeSelector(key2);
    if (selector === "&") {
      return styles2;
    }
    if (selector.includes("data-") || selector.includes(".")) {
      selector = `*:where(${selector.replace(/\s*&$/, "")}) &`;
    }
    return {
      [selector]: styles2
    };
  }
  if (theme.palette.mode === key2) {
    return styles2;
  }
  return {};
}
function createTheme$1(options = {}, ...args) {
  const {
    breakpoints: breakpointsInput = {},
    palette: paletteInput = {},
    spacing: spacingInput,
    shape: shapeInput = {},
    ...other
  } = options;
  const breakpoints = createBreakpoints(breakpointsInput);
  const spacing = createSpacing(spacingInput);
  let muiTheme = deepmerge({
    breakpoints,
    direction: "ltr",
    components: {},
    // Inject component definitions.
    palette: {
      mode: "light",
      ...paletteInput
    },
    spacing,
    shape: {
      ...shape,
      ...shapeInput
    }
  }, other);
  muiTheme = cssContainerQueries(muiTheme);
  muiTheme.applyStyles = applyStyles;
  muiTheme = args.reduce((acc, argument) => deepmerge(acc, argument), muiTheme);
  muiTheme.unstable_sxConfig = {
    ...defaultSxConfig,
    ...other?.unstable_sxConfig
  };
  muiTheme.unstable_sx = function sx(props) {
    return styleFunctionSx({
      sx: props,
      theme: this
    });
  };
  return muiTheme;
}
function isObjectEmpty$1(obj) {
  return Object.keys(obj).length === 0;
}
function useTheme$3(defaultTheme2 = null) {
  const contextTheme = reactExports.useContext(ThemeContext$1);
  return !contextTheme || isObjectEmpty$1(contextTheme) ? defaultTheme2 : contextTheme;
}
const systemDefaultTheme$1 = createTheme$1();
function useTheme$2(defaultTheme2 = systemDefaultTheme$1) {
  return useTheme$3(defaultTheme2);
}
function wrapGlobalLayer(styles2) {
  const serialized = internal_serializeStyles(styles2);
  if (styles2 !== serialized && serialized.styles) {
    if (!serialized.styles.match(/^@layer\s+[^{]*$/)) {
      serialized.styles = `@layer global{${serialized.styles}}`;
    }
    return serialized;
  }
  return styles2;
}
function GlobalStyles$1({
  styles: styles2,
  themeId,
  defaultTheme: defaultTheme2 = {}
}) {
  const upperTheme = useTheme$2(defaultTheme2);
  const resolvedTheme = themeId ? upperTheme[themeId] || upperTheme : upperTheme;
  let globalStyles = typeof styles2 === "function" ? styles2(resolvedTheme) : styles2;
  if (resolvedTheme.modularCssLayers) {
    if (Array.isArray(globalStyles)) {
      globalStyles = globalStyles.map((styleArg) => {
        if (typeof styleArg === "function") {
          return wrapGlobalLayer(styleArg(resolvedTheme));
        }
        return wrapGlobalLayer(styleArg);
      });
    } else {
      globalStyles = wrapGlobalLayer(globalStyles);
    }
  }
  return /* @__PURE__ */ jsxRuntimeExports.jsx(GlobalStyles$2, {
    styles: globalStyles
  });
}
const splitProps = (props) => {
  const result = {
    systemProps: {},
    otherProps: {}
  };
  const config2 = props?.theme?.unstable_sxConfig ?? defaultSxConfig;
  Object.keys(props).forEach((prop) => {
    if (config2[prop]) {
      result.systemProps[prop] = props[prop];
    } else {
      result.otherProps[prop] = props[prop];
    }
  });
  return result;
};
function extendSxProp$1(props) {
  const {
    sx: inSx,
    ...other
  } = props;
  const {
    systemProps,
    otherProps
  } = splitProps(other);
  let finalSx;
  if (Array.isArray(inSx)) {
    finalSx = [systemProps, ...inSx];
  } else if (typeof inSx === "function") {
    finalSx = (...args) => {
      const result = inSx(...args);
      if (!isPlainObject(result)) {
        return systemProps;
      }
      return {
        ...systemProps,
        ...result
      };
    };
  } else {
    finalSx = {
      ...systemProps,
      ...inSx
    };
  }
  return {
    ...otherProps,
    sx: finalSx
  };
}
const defaultGenerator = (componentName) => componentName;
const createClassNameGenerator = () => {
  let generate = defaultGenerator;
  return {
    configure(generator) {
      generate = generator;
    },
    generate(componentName) {
      return generate(componentName);
    },
    reset() {
      generate = defaultGenerator;
    }
  };
};
const ClassNameGenerator = createClassNameGenerator();
function createBox(options = {}) {
  const {
    themeId,
    defaultTheme: defaultTheme2,
    defaultClassName = "MuiBox-root",
    generateClassName
  } = options;
  const BoxRoot = styled$2("div", {
    shouldForwardProp: (prop) => prop !== "theme" && prop !== "sx" && prop !== "as"
  })(styleFunctionSx);
  const Box2 = /* @__PURE__ */ reactExports.forwardRef(function Box3(inProps, ref) {
    const theme = useTheme$2(defaultTheme2);
    const {
      className,
      component = "div",
      ...other
    } = extendSxProp$1(inProps);
    return /* @__PURE__ */ jsxRuntimeExports.jsx(BoxRoot, {
      as: component,
      ref,
      className: clsx(className, generateClassName ? generateClassName(defaultClassName) : defaultClassName),
      theme: themeId ? theme[themeId] || theme : theme,
      ...other
    });
  });
  return Box2;
}
const globalStateClasses = {
  active: "active",
  checked: "checked",
  completed: "completed",
  disabled: "disabled",
  error: "error",
  expanded: "expanded",
  focused: "focused",
  focusVisible: "focusVisible",
  open: "open",
  readOnly: "readOnly",
  required: "required",
  selected: "selected"
};
function generateUtilityClass(componentName, slot, globalStatePrefix = "Mui") {
  const globalStateClass = globalStateClasses[slot];
  return globalStateClass ? `${globalStatePrefix}-${globalStateClass}` : `${ClassNameGenerator.generate(componentName)}-${slot}`;
}
function generateUtilityClasses(componentName, slots, globalStatePrefix = "Mui") {
  const result = {};
  slots.forEach((slot) => {
    result[slot] = generateUtilityClass(componentName, slot, globalStatePrefix);
  });
  return result;
}
function preprocessStyles(input) {
  const {
    variants,
    ...style2
  } = input;
  const result = {
    variants,
    style: internal_serializeStyles(style2),
    isProcessed: true
  };
  if (result.style === style2) {
    return result;
  }
  if (variants) {
    variants.forEach((variant) => {
      if (typeof variant.style !== "function") {
        variant.style = internal_serializeStyles(variant.style);
      }
    });
  }
  return result;
}
const systemDefaultTheme = createTheme$1();
function shouldForwardProp(prop) {
  return prop !== "ownerState" && prop !== "theme" && prop !== "sx" && prop !== "as";
}
function shallowLayer(serialized, layerName) {
  if (layerName && serialized && typeof serialized === "object" && serialized.styles && !serialized.styles.startsWith("@layer")) {
    serialized.styles = `@layer ${layerName}{${String(serialized.styles)}}`;
  }
  return serialized;
}
function defaultOverridesResolver(slot) {
  if (!slot) {
    return null;
  }
  return (_props, styles2) => styles2[slot];
}
function attachTheme(props, themeId, defaultTheme2) {
  props.theme = isObjectEmpty(props.theme) ? defaultTheme2 : props.theme[themeId] || props.theme;
}
function processStyle(props, style2, layerName) {
  const resolvedStyle = typeof style2 === "function" ? style2(props) : style2;
  if (Array.isArray(resolvedStyle)) {
    return resolvedStyle.flatMap((subStyle) => processStyle(props, subStyle, layerName));
  }
  if (Array.isArray(resolvedStyle?.variants)) {
    let rootStyle;
    if (resolvedStyle.isProcessed) {
      rootStyle = layerName ? shallowLayer(resolvedStyle.style, layerName) : resolvedStyle.style;
    } else {
      const {
        variants,
        ...otherStyles
      } = resolvedStyle;
      rootStyle = layerName ? shallowLayer(internal_serializeStyles(otherStyles), layerName) : otherStyles;
    }
    return processStyleVariants(props, resolvedStyle.variants, [rootStyle], layerName);
  }
  if (resolvedStyle?.isProcessed) {
    return layerName ? shallowLayer(internal_serializeStyles(resolvedStyle.style), layerName) : resolvedStyle.style;
  }
  return layerName ? shallowLayer(internal_serializeStyles(resolvedStyle), layerName) : resolvedStyle;
}
function processStyleVariants(props, variants, results = [], layerName = void 0) {
  let mergedState;
  variantLoop: for (let i2 = 0; i2 < variants.length; i2 += 1) {
    const variant = variants[i2];
    if (typeof variant.props === "function") {
      mergedState ?? (mergedState = {
        ...props,
        ...props.ownerState,
        ownerState: props.ownerState
      });
      if (!variant.props(mergedState)) {
        continue;
      }
    } else {
      for (const key2 in variant.props) {
        if (props[key2] !== variant.props[key2] && props.ownerState?.[key2] !== variant.props[key2]) {
          continue variantLoop;
        }
      }
    }
    if (typeof variant.style === "function") {
      mergedState ?? (mergedState = {
        ...props,
        ...props.ownerState,
        ownerState: props.ownerState
      });
      results.push(layerName ? shallowLayer(internal_serializeStyles(variant.style(mergedState)), layerName) : variant.style(mergedState));
    } else {
      results.push(layerName ? shallowLayer(internal_serializeStyles(variant.style), layerName) : variant.style);
    }
  }
  return results;
}
function createStyled2(input = {}) {
  const {
    themeId,
    defaultTheme: defaultTheme2 = systemDefaultTheme,
    rootShouldForwardProp: rootShouldForwardProp2 = shouldForwardProp,
    slotShouldForwardProp: slotShouldForwardProp2 = shouldForwardProp
  } = input;
  function styleAttachTheme(props) {
    attachTheme(props, themeId, defaultTheme2);
  }
  const styled2 = (tag, inputOptions = {}) => {
    internal_mutateStyles(tag, (styles2) => styles2.filter((style2) => style2 !== styleFunctionSx));
    const {
      name: componentName,
      slot: componentSlot,
      skipVariantsResolver: inputSkipVariantsResolver,
      skipSx: inputSkipSx,
      // TODO v6: remove `lowercaseFirstLetter()` in the next major release
      // For more details: https://github.com/mui/material-ui/pull/37908
      overridesResolver = defaultOverridesResolver(lowercaseFirstLetter(componentSlot)),
      ...options
    } = inputOptions;
    const layerName = componentName && componentName.startsWith("Mui") || !!componentSlot ? "components" : "custom";
    const skipVariantsResolver = inputSkipVariantsResolver !== void 0 ? inputSkipVariantsResolver : (
      // TODO v6: remove `Root` in the next major release
      // For more details: https://github.com/mui/material-ui/pull/37908
      componentSlot && componentSlot !== "Root" && componentSlot !== "root" || false
    );
    const skipSx = inputSkipSx || false;
    let shouldForwardPropOption = shouldForwardProp;
    if (componentSlot === "Root" || componentSlot === "root") {
      shouldForwardPropOption = rootShouldForwardProp2;
    } else if (componentSlot) {
      shouldForwardPropOption = slotShouldForwardProp2;
    } else if (isStringTag(tag)) {
      shouldForwardPropOption = void 0;
    }
    const defaultStyledResolver = styled$2(tag, {
      shouldForwardProp: shouldForwardPropOption,
      label: generateStyledLabel(),
      ...options
    });
    const transformStyle = (style2) => {
      if (style2.__emotion_real === style2) {
        return style2;
      }
      if (typeof style2 === "function") {
        return function styleFunctionProcessor(props) {
          return processStyle(props, style2, props.theme.modularCssLayers ? layerName : void 0);
        };
      }
      if (isPlainObject(style2)) {
        const serialized = preprocessStyles(style2);
        return function styleObjectProcessor(props) {
          if (!serialized.variants) {
            return props.theme.modularCssLayers ? shallowLayer(serialized.style, layerName) : serialized.style;
          }
          return processStyle(props, serialized, props.theme.modularCssLayers ? layerName : void 0);
        };
      }
      return style2;
    };
    const muiStyledResolver = (...expressionsInput) => {
      const expressionsHead = [];
      const expressionsBody = expressionsInput.map(transformStyle);
      const expressionsTail = [];
      expressionsHead.push(styleAttachTheme);
      if (componentName && overridesResolver) {
        expressionsTail.push(function styleThemeOverrides(props) {
          const theme = props.theme;
          const styleOverrides = theme.components?.[componentName]?.styleOverrides;
          if (!styleOverrides) {
            return null;
          }
          const resolvedStyleOverrides = {};
          for (const slotKey in styleOverrides) {
            resolvedStyleOverrides[slotKey] = processStyle(props, styleOverrides[slotKey], props.theme.modularCssLayers ? "theme" : void 0);
          }
          return overridesResolver(props, resolvedStyleOverrides);
        });
      }
      if (componentName && !skipVariantsResolver) {
        expressionsTail.push(function styleThemeVariants(props) {
          const theme = props.theme;
          const themeVariants = theme?.components?.[componentName]?.variants;
          if (!themeVariants) {
            return null;
          }
          return processStyleVariants(props, themeVariants, [], props.theme.modularCssLayers ? "theme" : void 0);
        });
      }
      if (!skipSx) {
        expressionsTail.push(styleFunctionSx);
      }
      if (Array.isArray(expressionsBody[0])) {
        const inputStrings = expressionsBody.shift();
        const placeholdersHead = new Array(expressionsHead.length).fill("");
        const placeholdersTail = new Array(expressionsTail.length).fill("");
        let outputStrings;
        {
          outputStrings = [...placeholdersHead, ...inputStrings, ...placeholdersTail];
          outputStrings.raw = [...placeholdersHead, ...inputStrings.raw, ...placeholdersTail];
        }
        expressionsHead.unshift(outputStrings);
      }
      const expressions = [...expressionsHead, ...expressionsBody, ...expressionsTail];
      const Component = defaultStyledResolver(...expressions);
      if (tag.muiName) {
        Component.muiName = tag.muiName;
      }
      return Component;
    };
    if (defaultStyledResolver.withConfig) {
      muiStyledResolver.withConfig = defaultStyledResolver.withConfig;
    }
    return muiStyledResolver;
  };
  return styled2;
}
function generateStyledLabel(componentName, componentSlot) {
  let label;
  return label;
}
function isObjectEmpty(object) {
  for (const _2 in object) {
    return false;
  }
  return true;
}
function isStringTag(tag) {
  return typeof tag === "string" && // 96 is one less than the char code
  // for "a" so this is checking that
  // it's a lowercase character
  tag.charCodeAt(0) > 96;
}
function lowercaseFirstLetter(string) {
  if (!string) {
    return string;
  }
  return string.charAt(0).toLowerCase() + string.slice(1);
}
const styled$1 = createStyled2();
function resolveProps(defaultProps2, props, mergeClassNameAndStyle = false) {
  const output = {
    ...props
  };
  for (const key2 in defaultProps2) {
    if (Object.prototype.hasOwnProperty.call(defaultProps2, key2)) {
      const propName = key2;
      if (propName === "components" || propName === "slots") {
        output[propName] = {
          ...defaultProps2[propName],
          ...output[propName]
        };
      } else if (propName === "componentsProps" || propName === "slotProps") {
        const defaultSlotProps = defaultProps2[propName];
        const slotProps = props[propName];
        if (!slotProps) {
          output[propName] = defaultSlotProps || {};
        } else if (!defaultSlotProps) {
          output[propName] = slotProps;
        } else {
          output[propName] = {
            ...slotProps
          };
          for (const slotKey in defaultSlotProps) {
            if (Object.prototype.hasOwnProperty.call(defaultSlotProps, slotKey)) {
              const slotPropName = slotKey;
              output[propName][slotPropName] = resolveProps(defaultSlotProps[slotPropName], slotProps[slotPropName], mergeClassNameAndStyle);
            }
          }
        }
      } else if (propName === "className" && mergeClassNameAndStyle && props.className) {
        output.className = clsx(defaultProps2?.className, props?.className);
      } else if (propName === "style" && mergeClassNameAndStyle && props.style) {
        output.style = {
          ...defaultProps2?.style,
          ...props?.style
        };
      } else if (output[propName] === void 0) {
        output[propName] = defaultProps2[propName];
      }
    }
  }
  return output;
}
function getThemeProps$1(params) {
  const {
    theme,
    name,
    props
  } = params;
  if (!theme || !theme.components || !theme.components[name] || !theme.components[name].defaultProps) {
    return props;
  }
  return resolveProps(theme.components[name].defaultProps, props);
}
function useThemeProps({
  props,
  name,
  defaultTheme: defaultTheme2,
  themeId
}) {
  let theme = useTheme$2(defaultTheme2);
  if (themeId) {
    theme = theme[themeId] || theme;
  }
  return getThemeProps$1({
    theme,
    name,
    props
  });
}
const useEnhancedEffect = typeof window !== "undefined" ? reactExports.useLayoutEffect : reactExports.useEffect;
function clamp(val, min2 = Number.MIN_SAFE_INTEGER, max2 = Number.MAX_SAFE_INTEGER) {
  return Math.max(min2, Math.min(val, max2));
}
function clampWrapper(value, min2 = 0, max2 = 1) {
  return clamp(value, min2, max2);
}
function hexToRgb(color2) {
  color2 = color2.slice(1);
  const re = new RegExp(`.{1,${color2.length >= 6 ? 2 : 1}}`, "g");
  let colors = color2.match(re);
  if (colors && colors[0].length === 1) {
    colors = colors.map((n2) => n2 + n2);
  }
  return colors ? `rgb${colors.length === 4 ? "a" : ""}(${colors.map((n2, index2) => {
    return index2 < 3 ? parseInt(n2, 16) : Math.round(parseInt(n2, 16) / 255 * 1e3) / 1e3;
  }).join(", ")})` : "";
}
function decomposeColor(color2) {
  if (color2.type) {
    return color2;
  }
  if (color2.charAt(0) === "#") {
    return decomposeColor(hexToRgb(color2));
  }
  const marker = color2.indexOf("(");
  const type = color2.substring(0, marker);
  if (!["rgb", "rgba", "hsl", "hsla", "color"].includes(type)) {
    throw new Error(formatMuiErrorMessage(9, color2));
  }
  let values2 = color2.substring(marker + 1, color2.length - 1);
  let colorSpace;
  if (type === "color") {
    values2 = values2.split(" ");
    colorSpace = values2.shift();
    if (values2.length === 4 && values2[3].charAt(0) === "/") {
      values2[3] = values2[3].slice(1);
    }
    if (!["srgb", "display-p3", "a98-rgb", "prophoto-rgb", "rec-2020"].includes(colorSpace)) {
      throw new Error(formatMuiErrorMessage(10, colorSpace));
    }
  } else {
    values2 = values2.split(",");
  }
  values2 = values2.map((value) => parseFloat(value));
  return {
    type,
    values: values2,
    colorSpace
  };
}
const colorChannel = (color2) => {
  const decomposedColor = decomposeColor(color2);
  return decomposedColor.values.slice(0, 3).map((val, idx) => decomposedColor.type.includes("hsl") && idx !== 0 ? `${val}%` : val).join(" ");
};
const private_safeColorChannel = (color2, warning) => {
  try {
    return colorChannel(color2);
  } catch (error) {
    if (warning && false) {
      console.warn(warning);
    }
    return color2;
  }
};
function recomposeColor(color2) {
  const {
    type,
    colorSpace
  } = color2;
  let {
    values: values2
  } = color2;
  if (type.includes("rgb")) {
    values2 = values2.map((n2, i2) => i2 < 3 ? parseInt(n2, 10) : n2);
  } else if (type.includes("hsl")) {
    values2[1] = `${values2[1]}%`;
    values2[2] = `${values2[2]}%`;
  }
  if (type.includes("color")) {
    values2 = `${colorSpace} ${values2.join(" ")}`;
  } else {
    values2 = `${values2.join(", ")}`;
  }
  return `${type}(${values2})`;
}
function hslToRgb(color2) {
  color2 = decomposeColor(color2);
  const {
    values: values2
  } = color2;
  const h2 = values2[0];
  const s = values2[1] / 100;
  const l2 = values2[2] / 100;
  const a2 = s * Math.min(l2, 1 - l2);
  const f2 = (n2, k2 = (n2 + h2 / 30) % 12) => l2 - a2 * Math.max(Math.min(k2 - 3, 9 - k2, 1), -1);
  let type = "rgb";
  const rgb = [Math.round(f2(0) * 255), Math.round(f2(8) * 255), Math.round(f2(4) * 255)];
  if (color2.type === "hsla") {
    type += "a";
    rgb.push(values2[3]);
  }
  return recomposeColor({
    type,
    values: rgb
  });
}
function getLuminance(color2) {
  color2 = decomposeColor(color2);
  let rgb = color2.type === "hsl" || color2.type === "hsla" ? decomposeColor(hslToRgb(color2)).values : color2.values;
  rgb = rgb.map((val) => {
    if (color2.type !== "color") {
      val /= 255;
    }
    return val <= 0.03928 ? val / 12.92 : ((val + 0.055) / 1.055) ** 2.4;
  });
  return Number((0.2126 * rgb[0] + 0.7152 * rgb[1] + 0.0722 * rgb[2]).toFixed(3));
}
function getContrastRatio(foreground, background) {
  const lumA = getLuminance(foreground);
  const lumB = getLuminance(background);
  return (Math.max(lumA, lumB) + 0.05) / (Math.min(lumA, lumB) + 0.05);
}
function alpha(color2, value) {
  color2 = decomposeColor(color2);
  value = clampWrapper(value);
  if (color2.type === "rgb" || color2.type === "hsl") {
    color2.type += "a";
  }
  if (color2.type === "color") {
    color2.values[3] = `/${value}`;
  } else {
    color2.values[3] = value;
  }
  return recomposeColor(color2);
}
function private_safeAlpha(color2, value, warning) {
  try {
    return alpha(color2, value);
  } catch (error) {
    return color2;
  }
}
function darken(color2, coefficient) {
  color2 = decomposeColor(color2);
  coefficient = clampWrapper(coefficient);
  if (color2.type.includes("hsl")) {
    color2.values[2] *= 1 - coefficient;
  } else if (color2.type.includes("rgb") || color2.type.includes("color")) {
    for (let i2 = 0; i2 < 3; i2 += 1) {
      color2.values[i2] *= 1 - coefficient;
    }
  }
  return recomposeColor(color2);
}
function private_safeDarken(color2, coefficient, warning) {
  try {
    return darken(color2, coefficient);
  } catch (error) {
    return color2;
  }
}
function lighten(color2, coefficient) {
  color2 = decomposeColor(color2);
  coefficient = clampWrapper(coefficient);
  if (color2.type.includes("hsl")) {
    color2.values[2] += (100 - color2.values[2]) * coefficient;
  } else if (color2.type.includes("rgb")) {
    for (let i2 = 0; i2 < 3; i2 += 1) {
      color2.values[i2] += (255 - color2.values[i2]) * coefficient;
    }
  } else if (color2.type.includes("color")) {
    for (let i2 = 0; i2 < 3; i2 += 1) {
      color2.values[i2] += (1 - color2.values[i2]) * coefficient;
    }
  }
  return recomposeColor(color2);
}
function private_safeLighten(color2, coefficient, warning) {
  try {
    return lighten(color2, coefficient);
  } catch (error) {
    return color2;
  }
}
function emphasize(color2, coefficient = 0.15) {
  return getLuminance(color2) > 0.5 ? darken(color2, coefficient) : lighten(color2, coefficient);
}
function private_safeEmphasize(color2, coefficient, warning) {
  try {
    return emphasize(color2, coefficient);
  } catch (error) {
    return color2;
  }
}
const ThemeContext = /* @__PURE__ */ reactExports.createContext(null);
function useTheme$1() {
  const theme = reactExports.useContext(ThemeContext);
  return theme;
}
const hasSymbol = typeof Symbol === "function" && Symbol.for;
const nested = hasSymbol ? Symbol.for("mui.nested") : "__THEME_NESTED__";
function mergeOuterLocalTheme(outerTheme, localTheme) {
  if (typeof localTheme === "function") {
    const mergedTheme = localTheme(outerTheme);
    return mergedTheme;
  }
  return {
    ...outerTheme,
    ...localTheme
  };
}
function ThemeProvider$2(props) {
  const {
    children,
    theme: localTheme
  } = props;
  const outerTheme = useTheme$1();
  const theme = reactExports.useMemo(() => {
    const output = outerTheme === null ? {
      ...localTheme
    } : mergeOuterLocalTheme(outerTheme, localTheme);
    if (output != null) {
      output[nested] = outerTheme !== null;
    }
    return output;
  }, [localTheme, outerTheme]);
  return /* @__PURE__ */ jsxRuntimeExports.jsx(ThemeContext.Provider, {
    value: theme,
    children
  });
}
const RtlContext = /* @__PURE__ */ reactExports.createContext();
function RtlProvider({
  value,
  ...props
}) {
  return /* @__PURE__ */ jsxRuntimeExports.jsx(RtlContext.Provider, {
    value: value ?? true,
    ...props
  });
}
const useRtl = () => {
  const value = reactExports.useContext(RtlContext);
  return value ?? false;
};
const PropsContext = /* @__PURE__ */ reactExports.createContext(void 0);
function DefaultPropsProvider({
  value,
  children
}) {
  return /* @__PURE__ */ jsxRuntimeExports.jsx(PropsContext.Provider, {
    value,
    children
  });
}
function getThemeProps(params) {
  const {
    theme,
    name,
    props
  } = params;
  if (!theme || !theme.components || !theme.components[name]) {
    return props;
  }
  const config2 = theme.components[name];
  if (config2.defaultProps) {
    return resolveProps(config2.defaultProps, props, theme.components.mergeClassNameAndStyle);
  }
  if (!config2.styleOverrides && !config2.variants) {
    return resolveProps(config2, props, theme.components.mergeClassNameAndStyle);
  }
  return props;
}
function useDefaultProps$1({
  props,
  name
}) {
  const ctx = reactExports.useContext(PropsContext);
  return getThemeProps({
    props,
    name,
    theme: {
      components: ctx
    }
  });
}
let globalId = 0;
function useGlobalId(idOverride) {
  const [defaultId, setDefaultId] = reactExports.useState(idOverride);
  const id2 = idOverride || defaultId;
  reactExports.useEffect(() => {
    if (defaultId == null) {
      globalId += 1;
      setDefaultId(`mui-${globalId}`);
    }
  }, [defaultId]);
  return id2;
}
const safeReact = {
  ...React$1
};
const maybeReactUseId = safeReact.useId;
function useId(idOverride) {
  if (maybeReactUseId !== void 0) {
    const reactId = maybeReactUseId();
    return idOverride ?? reactId;
  }
  return useGlobalId(idOverride);
}
function useLayerOrder(theme) {
  const upperTheme = useTheme$3();
  const id2 = useId() || "";
  const {
    modularCssLayers
  } = theme;
  let layerOrder = "mui.global, mui.components, mui.theme, mui.custom, mui.sx";
  if (!modularCssLayers || upperTheme !== null) {
    layerOrder = "";
  } else if (typeof modularCssLayers === "string") {
    layerOrder = modularCssLayers.replace(/mui(?!\.)/g, layerOrder);
  } else {
    layerOrder = `@layer ${layerOrder};`;
  }
  useEnhancedEffect(() => {
    const head = document.querySelector("head");
    if (!head) {
      return;
    }
    const firstChild = head.firstChild;
    if (layerOrder) {
      if (firstChild && firstChild.hasAttribute?.("data-mui-layer-order") && firstChild.getAttribute("data-mui-layer-order") === id2) {
        return;
      }
      const styleElement = document.createElement("style");
      styleElement.setAttribute("data-mui-layer-order", id2);
      styleElement.textContent = layerOrder;
      head.prepend(styleElement);
    } else {
      head.querySelector(`style[data-mui-layer-order="${id2}"]`)?.remove();
    }
  }, [layerOrder, id2]);
  if (!layerOrder) {
    return null;
  }
  return /* @__PURE__ */ jsxRuntimeExports.jsx(GlobalStyles$1, {
    styles: layerOrder
  });
}
const EMPTY_THEME = {};
function useThemeScoping(themeId, upperTheme, localTheme, isPrivate = false) {
  return reactExports.useMemo(() => {
    const resolvedTheme = themeId ? upperTheme[themeId] || upperTheme : upperTheme;
    if (typeof localTheme === "function") {
      const mergedTheme = localTheme(resolvedTheme);
      const result = themeId ? {
        ...upperTheme,
        [themeId]: mergedTheme
      } : mergedTheme;
      if (isPrivate) {
        return () => result;
      }
      return result;
    }
    return themeId ? {
      ...upperTheme,
      [themeId]: localTheme
    } : {
      ...upperTheme,
      ...localTheme
    };
  }, [themeId, upperTheme, localTheme, isPrivate]);
}
function ThemeProvider$1(props) {
  const {
    children,
    theme: localTheme,
    themeId
  } = props;
  const upperTheme = useTheme$3(EMPTY_THEME);
  const upperPrivateTheme = useTheme$1() || EMPTY_THEME;
  const engineTheme = useThemeScoping(themeId, upperTheme, localTheme);
  const privateTheme = useThemeScoping(themeId, upperPrivateTheme, localTheme, true);
  const rtlValue = (themeId ? engineTheme[themeId] : engineTheme).direction === "rtl";
  const layerOrder = useLayerOrder(engineTheme);
  return /* @__PURE__ */ jsxRuntimeExports.jsx(ThemeProvider$2, {
    theme: privateTheme,
    children: /* @__PURE__ */ jsxRuntimeExports.jsx(ThemeContext$1.Provider, {
      value: engineTheme,
      children: /* @__PURE__ */ jsxRuntimeExports.jsx(RtlProvider, {
        value: rtlValue,
        children: /* @__PURE__ */ jsxRuntimeExports.jsxs(DefaultPropsProvider, {
          value: themeId ? engineTheme[themeId].components : engineTheme.components,
          children: [layerOrder, children]
        })
      })
    })
  });
}
const arg = {
  theme: void 0
};
function unstable_memoTheme(styleFn) {
  let lastValue;
  let lastTheme;
  return function styleMemoized(props) {
    let value = lastValue;
    if (value === void 0 || props.theme !== lastTheme) {
      arg.theme = props.theme;
      value = preprocessStyles(styleFn(arg));
      lastValue = value;
      lastTheme = props.theme;
    }
    return value;
  };
}
const DEFAULT_MODE_STORAGE_KEY = "mode";
const DEFAULT_COLOR_SCHEME_STORAGE_KEY = "color-scheme";
const DEFAULT_ATTRIBUTE = "data-color-scheme";
function InitColorSchemeScript(options) {
  const {
    defaultMode = "system",
    defaultLightColorScheme = "light",
    defaultDarkColorScheme = "dark",
    modeStorageKey = DEFAULT_MODE_STORAGE_KEY,
    colorSchemeStorageKey = DEFAULT_COLOR_SCHEME_STORAGE_KEY,
    attribute: initialAttribute = DEFAULT_ATTRIBUTE,
    colorSchemeNode = "document.documentElement",
    nonce
  } = options || {};
  let setter = "";
  let attribute = initialAttribute;
  if (initialAttribute === "class") {
    attribute = ".%s";
  }
  if (initialAttribute === "data") {
    attribute = "[data-%s]";
  }
  if (attribute.startsWith(".")) {
    const selector = attribute.substring(1);
    setter += `${colorSchemeNode}.classList.remove('${selector}'.replace('%s', light), '${selector}'.replace('%s', dark));
      ${colorSchemeNode}.classList.add('${selector}'.replace('%s', colorScheme));`;
  }
  const matches = attribute.match(/\[([^\]]+)\]/);
  if (matches) {
    const [attr, value] = matches[1].split("=");
    if (!value) {
      setter += `${colorSchemeNode}.removeAttribute('${attr}'.replace('%s', light));
      ${colorSchemeNode}.removeAttribute('${attr}'.replace('%s', dark));`;
    }
    setter += `
      ${colorSchemeNode}.setAttribute('${attr}'.replace('%s', colorScheme), ${value ? `${value}.replace('%s', colorScheme)` : '""'});`;
  } else {
    setter += `${colorSchemeNode}.setAttribute('${attribute}', colorScheme);`;
  }
  return /* @__PURE__ */ jsxRuntimeExports.jsx("script", {
    suppressHydrationWarning: true,
    nonce: typeof window === "undefined" ? nonce : "",
    dangerouslySetInnerHTML: {
      __html: `(function() {
try {
  let colorScheme = '';
  const mode = localStorage.getItem('${modeStorageKey}') || '${defaultMode}';
  const dark = localStorage.getItem('${colorSchemeStorageKey}-dark') || '${defaultDarkColorScheme}';
  const light = localStorage.getItem('${colorSchemeStorageKey}-light') || '${defaultLightColorScheme}';
  if (mode === 'system') {
    // handle system mode
    const mql = window.matchMedia('(prefers-color-scheme: dark)');
    if (mql.matches) {
      colorScheme = dark
    } else {
      colorScheme = light
    }
  }
  if (mode === 'light') {
    colorScheme = light;
  }
  if (mode === 'dark') {
    colorScheme = dark;
  }
  if (colorScheme) {
    ${setter}
  }
} catch(e){}})();`
    }
  }, "mui-color-scheme-init");
}
function noop$2() {
}
const localStorageManager = ({
  key: key2,
  storageWindow
}) => {
  if (!storageWindow && typeof window !== "undefined") {
    storageWindow = window;
  }
  return {
    get(defaultValue) {
      if (typeof window === "undefined") {
        return void 0;
      }
      if (!storageWindow) {
        return defaultValue;
      }
      let value;
      try {
        value = storageWindow.localStorage.getItem(key2);
      } catch {
      }
      return value || defaultValue;
    },
    set: (value) => {
      if (storageWindow) {
        try {
          storageWindow.localStorage.setItem(key2, value);
        } catch {
        }
      }
    },
    subscribe: (handler) => {
      if (!storageWindow) {
        return noop$2;
      }
      const listener = (event) => {
        const value = event.newValue;
        if (event.key === key2) {
          handler(value);
        }
      };
      storageWindow.addEventListener("storage", listener);
      return () => {
        storageWindow.removeEventListener("storage", listener);
      };
    }
  };
};
function noop$1() {
}
function getSystemMode(mode) {
  if (typeof window !== "undefined" && typeof window.matchMedia === "function" && mode === "system") {
    const mql = window.matchMedia("(prefers-color-scheme: dark)");
    if (mql.matches) {
      return "dark";
    }
    return "light";
  }
  return void 0;
}
function processState(state, callback) {
  if (state.mode === "light" || state.mode === "system" && state.systemMode === "light") {
    return callback("light");
  }
  if (state.mode === "dark" || state.mode === "system" && state.systemMode === "dark") {
    return callback("dark");
  }
  return void 0;
}
function getColorScheme(state) {
  return processState(state, (mode) => {
    if (mode === "light") {
      return state.lightColorScheme;
    }
    if (mode === "dark") {
      return state.darkColorScheme;
    }
    return void 0;
  });
}
function useCurrentColorScheme(options) {
  const {
    defaultMode = "light",
    defaultLightColorScheme,
    defaultDarkColorScheme,
    supportedColorSchemes = [],
    modeStorageKey = DEFAULT_MODE_STORAGE_KEY,
    colorSchemeStorageKey = DEFAULT_COLOR_SCHEME_STORAGE_KEY,
    storageWindow = typeof window === "undefined" ? void 0 : window,
    storageManager = localStorageManager,
    noSsr = false
  } = options;
  const joinedColorSchemes = supportedColorSchemes.join(",");
  const isMultiSchemes = supportedColorSchemes.length > 1;
  const modeStorage = reactExports.useMemo(() => storageManager?.({
    key: modeStorageKey,
    storageWindow
  }), [storageManager, modeStorageKey, storageWindow]);
  const lightStorage = reactExports.useMemo(() => storageManager?.({
    key: `${colorSchemeStorageKey}-light`,
    storageWindow
  }), [storageManager, colorSchemeStorageKey, storageWindow]);
  const darkStorage = reactExports.useMemo(() => storageManager?.({
    key: `${colorSchemeStorageKey}-dark`,
    storageWindow
  }), [storageManager, colorSchemeStorageKey, storageWindow]);
  const [state, setState] = reactExports.useState(() => {
    const initialMode = modeStorage?.get(defaultMode) || defaultMode;
    const lightColorScheme = lightStorage?.get(defaultLightColorScheme) || defaultLightColorScheme;
    const darkColorScheme = darkStorage?.get(defaultDarkColorScheme) || defaultDarkColorScheme;
    return {
      mode: initialMode,
      systemMode: getSystemMode(initialMode),
      lightColorScheme,
      darkColorScheme
    };
  });
  const [isClient, setIsClient] = reactExports.useState(noSsr || !isMultiSchemes);
  reactExports.useEffect(() => {
    setIsClient(true);
  }, []);
  const colorScheme = getColorScheme(state);
  const setMode = reactExports.useCallback((mode) => {
    setState((currentState) => {
      if (mode === currentState.mode) {
        return currentState;
      }
      const newMode = mode ?? defaultMode;
      modeStorage?.set(newMode);
      return {
        ...currentState,
        mode: newMode,
        systemMode: getSystemMode(newMode)
      };
    });
  }, [modeStorage, defaultMode]);
  const setColorScheme = reactExports.useCallback((value) => {
    if (!value) {
      setState((currentState) => {
        lightStorage?.set(defaultLightColorScheme);
        darkStorage?.set(defaultDarkColorScheme);
        return {
          ...currentState,
          lightColorScheme: defaultLightColorScheme,
          darkColorScheme: defaultDarkColorScheme
        };
      });
    } else if (typeof value === "string") {
      if (value && !joinedColorSchemes.includes(value)) {
        console.error(`\`${value}\` does not exist in \`theme.colorSchemes\`.`);
      } else {
        setState((currentState) => {
          const newState = {
            ...currentState
          };
          processState(currentState, (mode) => {
            if (mode === "light") {
              lightStorage?.set(value);
              newState.lightColorScheme = value;
            }
            if (mode === "dark") {
              darkStorage?.set(value);
              newState.darkColorScheme = value;
            }
          });
          return newState;
        });
      }
    } else {
      setState((currentState) => {
        const newState = {
          ...currentState
        };
        const newLightColorScheme = value.light === null ? defaultLightColorScheme : value.light;
        const newDarkColorScheme = value.dark === null ? defaultDarkColorScheme : value.dark;
        if (newLightColorScheme) {
          if (!joinedColorSchemes.includes(newLightColorScheme)) {
            console.error(`\`${newLightColorScheme}\` does not exist in \`theme.colorSchemes\`.`);
          } else {
            newState.lightColorScheme = newLightColorScheme;
            lightStorage?.set(newLightColorScheme);
          }
        }
        if (newDarkColorScheme) {
          if (!joinedColorSchemes.includes(newDarkColorScheme)) {
            console.error(`\`${newDarkColorScheme}\` does not exist in \`theme.colorSchemes\`.`);
          } else {
            newState.darkColorScheme = newDarkColorScheme;
            darkStorage?.set(newDarkColorScheme);
          }
        }
        return newState;
      });
    }
  }, [joinedColorSchemes, lightStorage, darkStorage, defaultLightColorScheme, defaultDarkColorScheme]);
  const handleMediaQuery = reactExports.useCallback((event) => {
    if (state.mode === "system") {
      setState((currentState) => {
        const systemMode = event?.matches ? "dark" : "light";
        if (currentState.systemMode === systemMode) {
          return currentState;
        }
        return {
          ...currentState,
          systemMode
        };
      });
    }
  }, [state.mode]);
  const mediaListener = reactExports.useRef(handleMediaQuery);
  mediaListener.current = handleMediaQuery;
  reactExports.useEffect(() => {
    if (typeof window.matchMedia !== "function" || !isMultiSchemes) {
      return void 0;
    }
    const handler = (...args) => mediaListener.current(...args);
    const media = window.matchMedia("(prefers-color-scheme: dark)");
    media.addListener(handler);
    handler(media);
    return () => {
      media.removeListener(handler);
    };
  }, [isMultiSchemes]);
  reactExports.useEffect(() => {
    if (isMultiSchemes) {
      const unsubscribeMode = modeStorage?.subscribe((value) => {
        if (!value || ["light", "dark", "system"].includes(value)) {
          setMode(value || defaultMode);
        }
      }) || noop$1;
      const unsubscribeLight = lightStorage?.subscribe((value) => {
        if (!value || joinedColorSchemes.match(value)) {
          setColorScheme({
            light: value
          });
        }
      }) || noop$1;
      const unsubscribeDark = darkStorage?.subscribe((value) => {
        if (!value || joinedColorSchemes.match(value)) {
          setColorScheme({
            dark: value
          });
        }
      }) || noop$1;
      return () => {
        unsubscribeMode();
        unsubscribeLight();
        unsubscribeDark();
      };
    }
    return void 0;
  }, [setColorScheme, setMode, joinedColorSchemes, defaultMode, storageWindow, isMultiSchemes, modeStorage, lightStorage, darkStorage]);
  return {
    ...state,
    mode: isClient ? state.mode : void 0,
    systemMode: isClient ? state.systemMode : void 0,
    colorScheme: isClient ? colorScheme : void 0,
    setMode,
    setColorScheme
  };
}
const DISABLE_CSS_TRANSITION = "*{-webkit-transition:none!important;-moz-transition:none!important;-o-transition:none!important;-ms-transition:none!important;transition:none!important}";
function createCssVarsProvider(options) {
  const {
    themeId,
    /**
     * This `theme` object needs to follow a certain structure to
     * be used correctly by the finel `CssVarsProvider`. It should have a
     * `colorSchemes` key with the light and dark (and any other) palette.
     * It should also ideally have a vars object created using `prepareCssVars`.
     */
    theme: defaultTheme2 = {},
    modeStorageKey: defaultModeStorageKey = DEFAULT_MODE_STORAGE_KEY,
    colorSchemeStorageKey: defaultColorSchemeStorageKey = DEFAULT_COLOR_SCHEME_STORAGE_KEY,
    disableTransitionOnChange: designSystemTransitionOnChange = false,
    defaultColorScheme,
    resolveTheme
  } = options;
  const defaultContext2 = {
    allColorSchemes: [],
    colorScheme: void 0,
    darkColorScheme: void 0,
    lightColorScheme: void 0,
    mode: void 0,
    setColorScheme: () => {
    },
    setMode: () => {
    },
    systemMode: void 0
  };
  const ColorSchemeContext = /* @__PURE__ */ reactExports.createContext(void 0);
  const useColorScheme2 = () => reactExports.useContext(ColorSchemeContext) || defaultContext2;
  const defaultColorSchemes = {};
  const defaultComponents = {};
  function CssVarsProvider2(props) {
    const {
      children,
      theme: themeProp,
      modeStorageKey = defaultModeStorageKey,
      colorSchemeStorageKey = defaultColorSchemeStorageKey,
      disableTransitionOnChange = designSystemTransitionOnChange,
      storageManager,
      storageWindow = typeof window === "undefined" ? void 0 : window,
      documentNode = typeof document === "undefined" ? void 0 : document,
      colorSchemeNode = typeof document === "undefined" ? void 0 : document.documentElement,
      disableNestedContext = false,
      disableStyleSheetGeneration = false,
      defaultMode: initialMode = "system",
      forceThemeRerender = false,
      noSsr
    } = props;
    const hasMounted = reactExports.useRef(false);
    const upperTheme = useTheme$1();
    const ctx = reactExports.useContext(ColorSchemeContext);
    const nested2 = !!ctx && !disableNestedContext;
    const initialTheme = reactExports.useMemo(() => {
      if (themeProp) {
        return themeProp;
      }
      return typeof defaultTheme2 === "function" ? defaultTheme2() : defaultTheme2;
    }, [themeProp]);
    const scopedTheme = initialTheme[themeId];
    const restThemeProp = scopedTheme || initialTheme;
    const {
      colorSchemes = defaultColorSchemes,
      components = defaultComponents,
      cssVarPrefix
    } = restThemeProp;
    const joinedColorSchemes = Object.keys(colorSchemes).filter((k2) => !!colorSchemes[k2]).join(",");
    const allColorSchemes = reactExports.useMemo(() => joinedColorSchemes.split(","), [joinedColorSchemes]);
    const defaultLightColorScheme2 = typeof defaultColorScheme === "string" ? defaultColorScheme : defaultColorScheme.light;
    const defaultDarkColorScheme2 = typeof defaultColorScheme === "string" ? defaultColorScheme : defaultColorScheme.dark;
    const defaultMode = colorSchemes[defaultLightColorScheme2] && colorSchemes[defaultDarkColorScheme2] ? initialMode : colorSchemes[restThemeProp.defaultColorScheme]?.palette?.mode || restThemeProp.palette?.mode;
    const {
      mode: stateMode,
      setMode,
      systemMode,
      lightColorScheme,
      darkColorScheme,
      colorScheme: stateColorScheme,
      setColorScheme
    } = useCurrentColorScheme({
      supportedColorSchemes: allColorSchemes,
      defaultLightColorScheme: defaultLightColorScheme2,
      defaultDarkColorScheme: defaultDarkColorScheme2,
      modeStorageKey,
      colorSchemeStorageKey,
      defaultMode,
      storageManager,
      storageWindow,
      noSsr
    });
    let mode = stateMode;
    let colorScheme = stateColorScheme;
    if (nested2) {
      mode = ctx.mode;
      colorScheme = ctx.colorScheme;
    }
    let calculatedColorScheme = colorScheme || restThemeProp.defaultColorScheme;
    if (restThemeProp.vars && !forceThemeRerender) {
      calculatedColorScheme = restThemeProp.defaultColorScheme;
    }
    const memoTheme2 = reactExports.useMemo(() => {
      const themeVars = restThemeProp.generateThemeVars?.() || restThemeProp.vars;
      const theme = {
        ...restThemeProp,
        components,
        colorSchemes,
        cssVarPrefix,
        vars: themeVars
      };
      if (typeof theme.generateSpacing === "function") {
        theme.spacing = theme.generateSpacing();
      }
      if (calculatedColorScheme) {
        const scheme = colorSchemes[calculatedColorScheme];
        if (scheme && typeof scheme === "object") {
          Object.keys(scheme).forEach((schemeKey) => {
            if (scheme[schemeKey] && typeof scheme[schemeKey] === "object") {
              theme[schemeKey] = {
                ...theme[schemeKey],
                ...scheme[schemeKey]
              };
            } else {
              theme[schemeKey] = scheme[schemeKey];
            }
          });
        }
      }
      return resolveTheme ? resolveTheme(theme) : theme;
    }, [restThemeProp, calculatedColorScheme, components, colorSchemes, cssVarPrefix]);
    const colorSchemeSelector = restThemeProp.colorSchemeSelector;
    useEnhancedEffect(() => {
      if (colorScheme && colorSchemeNode && colorSchemeSelector && colorSchemeSelector !== "media") {
        const selector = colorSchemeSelector;
        let rule = colorSchemeSelector;
        if (selector === "class") {
          rule = `.%s`;
        }
        if (selector === "data") {
          rule = `[data-%s]`;
        }
        if (selector?.startsWith("data-") && !selector.includes("%s")) {
          rule = `[${selector}="%s"]`;
        }
        if (rule.startsWith(".")) {
          colorSchemeNode.classList.remove(...allColorSchemes.map((scheme) => rule.substring(1).replace("%s", scheme)));
          colorSchemeNode.classList.add(rule.substring(1).replace("%s", colorScheme));
        } else {
          const matches = rule.replace("%s", colorScheme).match(/\[([^\]]+)\]/);
          if (matches) {
            const [attr, value] = matches[1].split("=");
            if (!value) {
              allColorSchemes.forEach((scheme) => {
                colorSchemeNode.removeAttribute(attr.replace(colorScheme, scheme));
              });
            }
            colorSchemeNode.setAttribute(attr, value ? value.replace(/"|'/g, "") : "");
          } else {
            colorSchemeNode.setAttribute(rule, colorScheme);
          }
        }
      }
    }, [colorScheme, colorSchemeSelector, colorSchemeNode, allColorSchemes]);
    reactExports.useEffect(() => {
      let timer;
      if (disableTransitionOnChange && hasMounted.current && documentNode) {
        const css2 = documentNode.createElement("style");
        css2.appendChild(documentNode.createTextNode(DISABLE_CSS_TRANSITION));
        documentNode.head.appendChild(css2);
        (() => window.getComputedStyle(documentNode.body))();
        timer = setTimeout(() => {
          documentNode.head.removeChild(css2);
        }, 1);
      }
      return () => {
        clearTimeout(timer);
      };
    }, [colorScheme, disableTransitionOnChange, documentNode]);
    reactExports.useEffect(() => {
      hasMounted.current = true;
      return () => {
        hasMounted.current = false;
      };
    }, []);
    const contextValue = reactExports.useMemo(() => ({
      allColorSchemes,
      colorScheme,
      darkColorScheme,
      lightColorScheme,
      mode,
      setColorScheme,
      setMode,
      systemMode
    }), [allColorSchemes, colorScheme, darkColorScheme, lightColorScheme, mode, setColorScheme, setMode, systemMode, memoTheme2.colorSchemeSelector]);
    let shouldGenerateStyleSheet = true;
    if (disableStyleSheetGeneration || restThemeProp.cssVariables === false || nested2 && upperTheme?.cssVarPrefix === cssVarPrefix) {
      shouldGenerateStyleSheet = false;
    }
    const element = /* @__PURE__ */ jsxRuntimeExports.jsxs(reactExports.Fragment, {
      children: [/* @__PURE__ */ jsxRuntimeExports.jsx(ThemeProvider$1, {
        themeId: scopedTheme ? themeId : void 0,
        theme: memoTheme2,
        children
      }), shouldGenerateStyleSheet && /* @__PURE__ */ jsxRuntimeExports.jsx(GlobalStyles$2, {
        styles: memoTheme2.generateStyleSheets?.() || []
      })]
    });
    if (nested2) {
      return element;
    }
    return /* @__PURE__ */ jsxRuntimeExports.jsx(ColorSchemeContext.Provider, {
      value: contextValue,
      children: element
    });
  }
  const defaultLightColorScheme = typeof defaultColorScheme === "string" ? defaultColorScheme : defaultColorScheme.light;
  const defaultDarkColorScheme = typeof defaultColorScheme === "string" ? defaultColorScheme : defaultColorScheme.dark;
  const getInitColorSchemeScript = (params) => InitColorSchemeScript({
    colorSchemeStorageKey: defaultColorSchemeStorageKey,
    defaultLightColorScheme,
    defaultDarkColorScheme,
    modeStorageKey: defaultModeStorageKey,
    ...params
  });
  return {
    CssVarsProvider: CssVarsProvider2,
    useColorScheme: useColorScheme2,
    getInitColorSchemeScript
  };
}
function createGetCssVar$1(prefix2 = "") {
  function appendVar(...vars) {
    if (!vars.length) {
      return "";
    }
    const value = vars[0];
    if (typeof value === "string" && !value.match(/(#|\(|\)|(-?(\d*\.)?\d+)(px|em|%|ex|ch|rem|vw|vh|vmin|vmax|cm|mm|in|pt|pc))|^(-?(\d*\.)?\d+)$|(\d+ \d+ \d+)/)) {
      return `, var(--${prefix2 ? `${prefix2}-` : ""}${value}${appendVar(...vars.slice(1))})`;
    }
    return `, ${value}`;
  }
  const getCssVar = (field, ...fallbacks) => {
    return `var(--${prefix2 ? `${prefix2}-` : ""}${field}${appendVar(...fallbacks)})`;
  };
  return getCssVar;
}
const assignNestedKeys = (obj, keys, value, arrayKeys = []) => {
  let temp = obj;
  keys.forEach((k2, index2) => {
    if (index2 === keys.length - 1) {
      if (Array.isArray(temp)) {
        temp[Number(k2)] = value;
      } else if (temp && typeof temp === "object") {
        temp[k2] = value;
      }
    } else if (temp && typeof temp === "object") {
      if (!temp[k2]) {
        temp[k2] = arrayKeys.includes(k2) ? [] : {};
      }
      temp = temp[k2];
    }
  });
};
const walkObjectDeep = (obj, callback, shouldSkipPaths) => {
  function recurse(object, parentKeys = [], arrayKeys = []) {
    Object.entries(object).forEach(([key2, value]) => {
      if (!shouldSkipPaths || shouldSkipPaths && !shouldSkipPaths([...parentKeys, key2])) {
        if (value !== void 0 && value !== null) {
          if (typeof value === "object" && Object.keys(value).length > 0) {
            recurse(value, [...parentKeys, key2], Array.isArray(value) ? [...arrayKeys, key2] : arrayKeys);
          } else {
            callback([...parentKeys, key2], value, arrayKeys);
          }
        }
      }
    });
  }
  recurse(obj);
};
const getCssValue = (keys, value) => {
  if (typeof value === "number") {
    if (["lineHeight", "fontWeight", "opacity", "zIndex"].some((prop) => keys.includes(prop))) {
      return value;
    }
    const lastKey = keys[keys.length - 1];
    if (lastKey.toLowerCase().includes("opacity")) {
      return value;
    }
    return `${value}px`;
  }
  return value;
};
function cssVarsParser(theme, options) {
  const {
    prefix: prefix2,
    shouldSkipGeneratingVar: shouldSkipGeneratingVar2
  } = options || {};
  const css2 = {};
  const vars = {};
  const varsWithDefaults = {};
  walkObjectDeep(
    theme,
    (keys, value, arrayKeys) => {
      if (typeof value === "string" || typeof value === "number") {
        if (!shouldSkipGeneratingVar2 || !shouldSkipGeneratingVar2(keys, value)) {
          const cssVar = `--${prefix2 ? `${prefix2}-` : ""}${keys.join("-")}`;
          const resolvedValue = getCssValue(keys, value);
          Object.assign(css2, {
            [cssVar]: resolvedValue
          });
          assignNestedKeys(vars, keys, `var(${cssVar})`, arrayKeys);
          assignNestedKeys(varsWithDefaults, keys, `var(${cssVar}, ${resolvedValue})`, arrayKeys);
        }
      }
    },
    (keys) => keys[0] === "vars"
    // skip 'vars/*' paths
  );
  return {
    css: css2,
    vars,
    varsWithDefaults
  };
}
function prepareCssVars(theme, parserConfig = {}) {
  const {
    getSelector = defaultGetSelector2,
    disableCssColorScheme,
    colorSchemeSelector: selector
  } = parserConfig;
  const {
    colorSchemes = {},
    components,
    defaultColorScheme = "light",
    ...otherTheme
  } = theme;
  const {
    vars: rootVars,
    css: rootCss,
    varsWithDefaults: rootVarsWithDefaults
  } = cssVarsParser(otherTheme, parserConfig);
  let themeVars = rootVarsWithDefaults;
  const colorSchemesMap = {};
  const {
    [defaultColorScheme]: defaultScheme,
    ...otherColorSchemes
  } = colorSchemes;
  Object.entries(otherColorSchemes || {}).forEach(([key2, scheme]) => {
    const {
      vars,
      css: css2,
      varsWithDefaults
    } = cssVarsParser(scheme, parserConfig);
    themeVars = deepmerge(themeVars, varsWithDefaults);
    colorSchemesMap[key2] = {
      css: css2,
      vars
    };
  });
  if (defaultScheme) {
    const {
      css: css2,
      vars,
      varsWithDefaults
    } = cssVarsParser(defaultScheme, parserConfig);
    themeVars = deepmerge(themeVars, varsWithDefaults);
    colorSchemesMap[defaultColorScheme] = {
      css: css2,
      vars
    };
  }
  function defaultGetSelector2(colorScheme, cssObject) {
    let rule = selector;
    if (selector === "class") {
      rule = ".%s";
    }
    if (selector === "data") {
      rule = "[data-%s]";
    }
    if (selector?.startsWith("data-") && !selector.includes("%s")) {
      rule = `[${selector}="%s"]`;
    }
    if (colorScheme) {
      if (rule === "media") {
        if (theme.defaultColorScheme === colorScheme) {
          return ":root";
        }
        const mode = colorSchemes[colorScheme]?.palette?.mode || colorScheme;
        return {
          [`@media (prefers-color-scheme: ${mode})`]: {
            ":root": cssObject
          }
        };
      }
      if (rule) {
        if (theme.defaultColorScheme === colorScheme) {
          return `:root, ${rule.replace("%s", String(colorScheme))}`;
        }
        return rule.replace("%s", String(colorScheme));
      }
    }
    return ":root";
  }
  const generateThemeVars = () => {
    let vars = {
      ...rootVars
    };
    Object.entries(colorSchemesMap).forEach(([, {
      vars: schemeVars
    }]) => {
      vars = deepmerge(vars, schemeVars);
    });
    return vars;
  };
  const generateStyleSheets = () => {
    const stylesheets = [];
    const colorScheme = theme.defaultColorScheme || "light";
    function insertStyleSheet(key2, css2) {
      if (Object.keys(css2).length) {
        stylesheets.push(typeof key2 === "string" ? {
          [key2]: {
            ...css2
          }
        } : key2);
      }
    }
    insertStyleSheet(getSelector(void 0, {
      ...rootCss
    }), rootCss);
    const {
      [colorScheme]: defaultSchemeVal,
      ...other
    } = colorSchemesMap;
    if (defaultSchemeVal) {
      const {
        css: css2
      } = defaultSchemeVal;
      const cssColorSheme = colorSchemes[colorScheme]?.palette?.mode;
      const finalCss = !disableCssColorScheme && cssColorSheme ? {
        colorScheme: cssColorSheme,
        ...css2
      } : {
        ...css2
      };
      insertStyleSheet(getSelector(colorScheme, {
        ...finalCss
      }), finalCss);
    }
    Object.entries(other).forEach(([key2, {
      css: css2
    }]) => {
      const cssColorSheme = colorSchemes[key2]?.palette?.mode;
      const finalCss = !disableCssColorScheme && cssColorSheme ? {
        colorScheme: cssColorSheme,
        ...css2
      } : {
        ...css2
      };
      insertStyleSheet(getSelector(key2, {
        ...finalCss
      }), finalCss);
    });
    return stylesheets;
  };
  return {
    vars: themeVars,
    generateThemeVars,
    generateStyleSheets
  };
}
function createGetColorSchemeSelector(selector) {
  return function getColorSchemeSelector(colorScheme) {
    if (selector === "media") {
      return `@media (prefers-color-scheme: ${colorScheme})`;
    }
    if (selector) {
      if (selector.startsWith("data-") && !selector.includes("%s")) {
        return `[${selector}="${colorScheme}"] &`;
      }
      if (selector === "class") {
        return `.${colorScheme} &`;
      }
      if (selector === "data") {
        return `[data-${colorScheme}] &`;
      }
      return `${selector.replace("%s", colorScheme)} &`;
    }
    return "&";
  };
}
function composeClasses(slots, getUtilityClass, classes = void 0) {
  const output = {};
  for (const slotName in slots) {
    const slot = slots[slotName];
    let buffer = "";
    let start = true;
    for (let i2 = 0; i2 < slot.length; i2 += 1) {
      const value = slot[i2];
      if (value) {
        buffer += (start === true ? "" : " ") + getUtilityClass(value);
        start = false;
        if (classes && classes[value]) {
          buffer += " " + classes[value];
        }
      }
    }
    output[slotName] = buffer;
  }
  return output;
}
const defaultTheme$2 = createTheme$1();
const defaultCreateStyledComponent = styled$1("div", {
  name: "MuiContainer",
  slot: "Root",
  overridesResolver: (props, styles2) => {
    const {
      ownerState
    } = props;
    return [styles2.root, styles2[`maxWidth${capitalize(String(ownerState.maxWidth))}`], ownerState.fixed && styles2.fixed, ownerState.disableGutters && styles2.disableGutters];
  }
});
const useThemePropsDefault = (inProps) => useThemeProps({
  props: inProps,
  name: "MuiContainer",
  defaultTheme: defaultTheme$2
});
const useUtilityClasses$f = (ownerState, componentName) => {
  const getContainerUtilityClass = (slot) => {
    return generateUtilityClass(componentName, slot);
  };
  const {
    classes,
    fixed,
    disableGutters,
    maxWidth: maxWidth2
  } = ownerState;
  const slots = {
    root: ["root", maxWidth2 && `maxWidth${capitalize(String(maxWidth2))}`, fixed && "fixed", disableGutters && "disableGutters"]
  };
  return composeClasses(slots, getContainerUtilityClass, classes);
};
function createContainer(options = {}) {
  const {
    // This will allow adding custom styled fn (for example for custom sx style function)
    createStyledComponent = defaultCreateStyledComponent,
    useThemeProps: useThemeProps2 = useThemePropsDefault,
    componentName = "MuiContainer"
  } = options;
  const ContainerRoot = createStyledComponent(({
    theme,
    ownerState
  }) => ({
    width: "100%",
    marginLeft: "auto",
    boxSizing: "border-box",
    marginRight: "auto",
    ...!ownerState.disableGutters && {
      paddingLeft: theme.spacing(2),
      paddingRight: theme.spacing(2),
      // @ts-ignore module augmentation fails if custom breakpoints are used
      [theme.breakpoints.up("sm")]: {
        paddingLeft: theme.spacing(3),
        paddingRight: theme.spacing(3)
      }
    }
  }), ({
    theme,
    ownerState
  }) => ownerState.fixed && Object.keys(theme.breakpoints.values).reduce((acc, breakpointValueKey) => {
    const breakpoint = breakpointValueKey;
    const value = theme.breakpoints.values[breakpoint];
    if (value !== 0) {
      acc[theme.breakpoints.up(breakpoint)] = {
        maxWidth: `${value}${theme.breakpoints.unit}`
      };
    }
    return acc;
  }, {}), ({
    theme,
    ownerState
  }) => ({
    // @ts-ignore module augmentation fails if custom breakpoints are used
    ...ownerState.maxWidth === "xs" && {
      // @ts-ignore module augmentation fails if custom breakpoints are used
      [theme.breakpoints.up("xs")]: {
        // @ts-ignore module augmentation fails if custom breakpoints are used
        maxWidth: Math.max(theme.breakpoints.values.xs, 444)
      }
    },
    ...ownerState.maxWidth && // @ts-ignore module augmentation fails if custom breakpoints are used
    ownerState.maxWidth !== "xs" && {
      // @ts-ignore module augmentation fails if custom breakpoints are used
      [theme.breakpoints.up(ownerState.maxWidth)]: {
        // @ts-ignore module augmentation fails if custom breakpoints are used
        maxWidth: `${theme.breakpoints.values[ownerState.maxWidth]}${theme.breakpoints.unit}`
      }
    }
  }));
  const Container2 = /* @__PURE__ */ reactExports.forwardRef(function Container22(inProps, ref) {
    const props = useThemeProps2(inProps);
    const {
      className,
      component = "div",
      disableGutters = false,
      fixed = false,
      maxWidth: maxWidth2 = "lg",
      classes: classesProp,
      ...other
    } = props;
    const ownerState = {
      ...props,
      component,
      disableGutters,
      fixed,
      maxWidth: maxWidth2
    };
    const classes = useUtilityClasses$f(ownerState, componentName);
    return (
      // @ts-ignore theme is injected by the styled util
      /* @__PURE__ */ jsxRuntimeExports.jsx(ContainerRoot, {
        as: component,
        ownerState,
        className: clsx(classes.root, className),
        ref,
        ...other
      })
    );
  });
  return Container2;
}
function getLight() {
  return {
    // The colors used to style the text.
    text: {
      // The most important text.
      primary: "rgba(0, 0, 0, 0.87)",
      // Secondary text.
      secondary: "rgba(0, 0, 0, 0.6)",
      // Disabled text have even lower visual prominence.
      disabled: "rgba(0, 0, 0, 0.38)"
    },
    // The color used to divide different elements.
    divider: "rgba(0, 0, 0, 0.12)",
    // The background colors used to style the surfaces.
    // Consistency between these values is important.
    background: {
      paper: common.white,
      default: common.white
    },
    // The colors used to style the action elements.
    action: {
      // The color of an active action like an icon button.
      active: "rgba(0, 0, 0, 0.54)",
      // The color of an hovered action.
      hover: "rgba(0, 0, 0, 0.04)",
      hoverOpacity: 0.04,
      // The color of a selected action.
      selected: "rgba(0, 0, 0, 0.08)",
      selectedOpacity: 0.08,
      // The color of a disabled action.
      disabled: "rgba(0, 0, 0, 0.26)",
      // The background color of a disabled action.
      disabledBackground: "rgba(0, 0, 0, 0.12)",
      disabledOpacity: 0.38,
      focus: "rgba(0, 0, 0, 0.12)",
      focusOpacity: 0.12,
      activatedOpacity: 0.12
    }
  };
}
const light = getLight();
function getDark() {
  return {
    text: {
      primary: common.white,
      secondary: "rgba(255, 255, 255, 0.7)",
      disabled: "rgba(255, 255, 255, 0.5)",
      icon: "rgba(255, 255, 255, 0.5)"
    },
    divider: "rgba(255, 255, 255, 0.12)",
    background: {
      paper: "#121212",
      default: "#121212"
    },
    action: {
      active: common.white,
      hover: "rgba(255, 255, 255, 0.08)",
      hoverOpacity: 0.08,
      selected: "rgba(255, 255, 255, 0.16)",
      selectedOpacity: 0.16,
      disabled: "rgba(255, 255, 255, 0.3)",
      disabledBackground: "rgba(255, 255, 255, 0.12)",
      disabledOpacity: 0.38,
      focus: "rgba(255, 255, 255, 0.12)",
      focusOpacity: 0.12,
      activatedOpacity: 0.24
    }
  };
}
const dark = getDark();
function addLightOrDark(intent, direction, shade, tonalOffset) {
  const tonalOffsetLight = tonalOffset.light || tonalOffset;
  const tonalOffsetDark = tonalOffset.dark || tonalOffset * 1.5;
  if (!intent[direction]) {
    if (intent.hasOwnProperty(shade)) {
      intent[direction] = intent[shade];
    } else if (direction === "light") {
      intent.light = lighten(intent.main, tonalOffsetLight);
    } else if (direction === "dark") {
      intent.dark = darken(intent.main, tonalOffsetDark);
    }
  }
}
function getDefaultPrimary(mode = "light") {
  if (mode === "dark") {
    return {
      main: blue[200],
      light: blue[50],
      dark: blue[400]
    };
  }
  return {
    main: blue[700],
    light: blue[400],
    dark: blue[800]
  };
}
function getDefaultSecondary(mode = "light") {
  if (mode === "dark") {
    return {
      main: purple[200],
      light: purple[50],
      dark: purple[400]
    };
  }
  return {
    main: purple[500],
    light: purple[300],
    dark: purple[700]
  };
}
function getDefaultError(mode = "light") {
  if (mode === "dark") {
    return {
      main: red[500],
      light: red[300],
      dark: red[700]
    };
  }
  return {
    main: red[700],
    light: red[400],
    dark: red[800]
  };
}
function getDefaultInfo(mode = "light") {
  if (mode === "dark") {
    return {
      main: lightBlue[400],
      light: lightBlue[300],
      dark: lightBlue[700]
    };
  }
  return {
    main: lightBlue[700],
    light: lightBlue[500],
    dark: lightBlue[900]
  };
}
function getDefaultSuccess(mode = "light") {
  if (mode === "dark") {
    return {
      main: green[400],
      light: green[300],
      dark: green[700]
    };
  }
  return {
    main: green[800],
    light: green[500],
    dark: green[900]
  };
}
function getDefaultWarning(mode = "light") {
  if (mode === "dark") {
    return {
      main: orange[400],
      light: orange[300],
      dark: orange[700]
    };
  }
  return {
    main: "#ed6c02",
    // closest to orange[800] that pass 3:1.
    light: orange[500],
    dark: orange[900]
  };
}
function createPalette(palette) {
  const {
    mode = "light",
    contrastThreshold = 3,
    tonalOffset = 0.2,
    ...other
  } = palette;
  const primary = palette.primary || getDefaultPrimary(mode);
  const secondary = palette.secondary || getDefaultSecondary(mode);
  const error = palette.error || getDefaultError(mode);
  const info = palette.info || getDefaultInfo(mode);
  const success = palette.success || getDefaultSuccess(mode);
  const warning = palette.warning || getDefaultWarning(mode);
  function getContrastText(background) {
    const contrastText = getContrastRatio(background, dark.text.primary) >= contrastThreshold ? dark.text.primary : light.text.primary;
    return contrastText;
  }
  const augmentColor = ({
    color: color2,
    name,
    mainShade = 500,
    lightShade = 300,
    darkShade = 700
  }) => {
    color2 = {
      ...color2
    };
    if (!color2.main && color2[mainShade]) {
      color2.main = color2[mainShade];
    }
    if (!color2.hasOwnProperty("main")) {
      throw new Error(formatMuiErrorMessage(11, name ? ` (${name})` : "", mainShade));
    }
    if (typeof color2.main !== "string") {
      throw new Error(formatMuiErrorMessage(12, name ? ` (${name})` : "", JSON.stringify(color2.main)));
    }
    addLightOrDark(color2, "light", lightShade, tonalOffset);
    addLightOrDark(color2, "dark", darkShade, tonalOffset);
    if (!color2.contrastText) {
      color2.contrastText = getContrastText(color2.main);
    }
    return color2;
  };
  let modeHydrated;
  if (mode === "light") {
    modeHydrated = getLight();
  } else if (mode === "dark") {
    modeHydrated = getDark();
  }
  const paletteOutput = deepmerge({
    // A collection of common colors.
    common: {
      ...common
    },
    // prevent mutable object.
    // The palette mode, can be light or dark.
    mode,
    // The colors used to represent primary interface elements for a user.
    primary: augmentColor({
      color: primary,
      name: "primary"
    }),
    // The colors used to represent secondary interface elements for a user.
    secondary: augmentColor({
      color: secondary,
      name: "secondary",
      mainShade: "A400",
      lightShade: "A200",
      darkShade: "A700"
    }),
    // The colors used to represent interface elements that the user should be made aware of.
    error: augmentColor({
      color: error,
      name: "error"
    }),
    // The colors used to represent potentially dangerous actions or important messages.
    warning: augmentColor({
      color: warning,
      name: "warning"
    }),
    // The colors used to present information to the user that is neutral and not necessarily important.
    info: augmentColor({
      color: info,
      name: "info"
    }),
    // The colors used to indicate the successful completion of an action that user triggered.
    success: augmentColor({
      color: success,
      name: "success"
    }),
    // The grey colors.
    grey,
    // Used by `getContrastText()` to maximize the contrast between
    // the background and the text.
    contrastThreshold,
    // Takes a background color and returns the text color that maximizes the contrast.
    getContrastText,
    // Generate a rich color object.
    augmentColor,
    // Used by the functions below to shift a color's luminance by approximately
    // two indexes within its tonal palette.
    // E.g., shift from Red 500 to Red 300 or Red 700.
    tonalOffset,
    // The light and dark mode object.
    ...modeHydrated
  }, other);
  return paletteOutput;
}
function prepareTypographyVars(typography) {
  const vars = {};
  const entries = Object.entries(typography);
  entries.forEach((entry) => {
    const [key2, value] = entry;
    if (typeof value === "object") {
      vars[key2] = `${value.fontStyle ? `${value.fontStyle} ` : ""}${value.fontVariant ? `${value.fontVariant} ` : ""}${value.fontWeight ? `${value.fontWeight} ` : ""}${value.fontStretch ? `${value.fontStretch} ` : ""}${value.fontSize || ""}${value.lineHeight ? `/${value.lineHeight} ` : ""}${value.fontFamily || ""}`;
    }
  });
  return vars;
}
function createMixins(breakpoints, mixins) {
  return {
    toolbar: {
      minHeight: 56,
      [breakpoints.up("xs")]: {
        "@media (orientation: landscape)": {
          minHeight: 48
        }
      },
      [breakpoints.up("sm")]: {
        minHeight: 64
      }
    },
    ...mixins
  };
}
function round(value) {
  return Math.round(value * 1e5) / 1e5;
}
const caseAllCaps = {
  textTransform: "uppercase"
};
const defaultFontFamily = '"Roboto", "Helvetica", "Arial", sans-serif';
function createTypography(palette, typography) {
  const {
    fontFamily = defaultFontFamily,
    // The default font size of the Material Specification.
    fontSize = 14,
    // px
    fontWeightLight = 300,
    fontWeightRegular = 400,
    fontWeightMedium = 500,
    fontWeightBold = 700,
    // Tell MUI what's the font-size on the html element.
    // 16px is the default font-size used by browsers.
    htmlFontSize = 16,
    // Apply the CSS properties to all the variants.
    allVariants,
    pxToRem: pxToRem2,
    ...other
  } = typeof typography === "function" ? typography(palette) : typography;
  const coef = fontSize / 14;
  const pxToRem = pxToRem2 || ((size2) => `${size2 / htmlFontSize * coef}rem`);
  const buildVariant = (fontWeight, size2, lineHeight, letterSpacing, casing) => ({
    fontFamily,
    fontWeight,
    fontSize: pxToRem(size2),
    // Unitless following https://meyerweb.com/eric/thoughts/2006/02/08/unitless-line-heights/
    lineHeight,
    // The letter spacing was designed for the Roboto font-family. Using the same letter-spacing
    // across font-families can cause issues with the kerning.
    ...fontFamily === defaultFontFamily ? {
      letterSpacing: `${round(letterSpacing / size2)}em`
    } : {},
    ...casing,
    ...allVariants
  });
  const variants = {
    h1: buildVariant(fontWeightLight, 96, 1.167, -1.5),
    h2: buildVariant(fontWeightLight, 60, 1.2, -0.5),
    h3: buildVariant(fontWeightRegular, 48, 1.167, 0),
    h4: buildVariant(fontWeightRegular, 34, 1.235, 0.25),
    h5: buildVariant(fontWeightRegular, 24, 1.334, 0),
    h6: buildVariant(fontWeightMedium, 20, 1.6, 0.15),
    subtitle1: buildVariant(fontWeightRegular, 16, 1.75, 0.15),
    subtitle2: buildVariant(fontWeightMedium, 14, 1.57, 0.1),
    body1: buildVariant(fontWeightRegular, 16, 1.5, 0.15),
    body2: buildVariant(fontWeightRegular, 14, 1.43, 0.15),
    button: buildVariant(fontWeightMedium, 14, 1.75, 0.4, caseAllCaps),
    caption: buildVariant(fontWeightRegular, 12, 1.66, 0.4),
    overline: buildVariant(fontWeightRegular, 12, 2.66, 1, caseAllCaps),
    // TODO v6: Remove handling of 'inherit' variant from the theme as it is already handled in Material UI's Typography component. Also, remember to remove the associated types.
    inherit: {
      fontFamily: "inherit",
      fontWeight: "inherit",
      fontSize: "inherit",
      lineHeight: "inherit",
      letterSpacing: "inherit"
    }
  };
  return deepmerge({
    htmlFontSize,
    pxToRem,
    fontFamily,
    fontSize,
    fontWeightLight,
    fontWeightRegular,
    fontWeightMedium,
    fontWeightBold,
    ...variants
  }, other, {
    clone: false
    // No need to clone deep
  });
}
const shadowKeyUmbraOpacity = 0.2;
const shadowKeyPenumbraOpacity = 0.14;
const shadowAmbientShadowOpacity = 0.12;
function createShadow(...px2) {
  return [`${px2[0]}px ${px2[1]}px ${px2[2]}px ${px2[3]}px rgba(0,0,0,${shadowKeyUmbraOpacity})`, `${px2[4]}px ${px2[5]}px ${px2[6]}px ${px2[7]}px rgba(0,0,0,${shadowKeyPenumbraOpacity})`, `${px2[8]}px ${px2[9]}px ${px2[10]}px ${px2[11]}px rgba(0,0,0,${shadowAmbientShadowOpacity})`].join(",");
}
const shadows = ["none", createShadow(0, 2, 1, -1, 0, 1, 1, 0, 0, 1, 3, 0), createShadow(0, 3, 1, -2, 0, 2, 2, 0, 0, 1, 5, 0), createShadow(0, 3, 3, -2, 0, 3, 4, 0, 0, 1, 8, 0), createShadow(0, 2, 4, -1, 0, 4, 5, 0, 0, 1, 10, 0), createShadow(0, 3, 5, -1, 0, 5, 8, 0, 0, 1, 14, 0), createShadow(0, 3, 5, -1, 0, 6, 10, 0, 0, 1, 18, 0), createShadow(0, 4, 5, -2, 0, 7, 10, 1, 0, 2, 16, 1), createShadow(0, 5, 5, -3, 0, 8, 10, 1, 0, 3, 14, 2), createShadow(0, 5, 6, -3, 0, 9, 12, 1, 0, 3, 16, 2), createShadow(0, 6, 6, -3, 0, 10, 14, 1, 0, 4, 18, 3), createShadow(0, 6, 7, -4, 0, 11, 15, 1, 0, 4, 20, 3), createShadow(0, 7, 8, -4, 0, 12, 17, 2, 0, 5, 22, 4), createShadow(0, 7, 8, -4, 0, 13, 19, 2, 0, 5, 24, 4), createShadow(0, 7, 9, -4, 0, 14, 21, 2, 0, 5, 26, 4), createShadow(0, 8, 9, -5, 0, 15, 22, 2, 0, 6, 28, 5), createShadow(0, 8, 10, -5, 0, 16, 24, 2, 0, 6, 30, 5), createShadow(0, 8, 11, -5, 0, 17, 26, 2, 0, 6, 32, 5), createShadow(0, 9, 11, -5, 0, 18, 28, 2, 0, 7, 34, 6), createShadow(0, 9, 12, -6, 0, 19, 29, 2, 0, 7, 36, 6), createShadow(0, 10, 13, -6, 0, 20, 31, 3, 0, 8, 38, 7), createShadow(0, 10, 13, -6, 0, 21, 33, 3, 0, 8, 40, 7), createShadow(0, 10, 14, -6, 0, 22, 35, 3, 0, 8, 42, 7), createShadow(0, 11, 14, -7, 0, 23, 36, 3, 0, 9, 44, 8), createShadow(0, 11, 15, -7, 0, 24, 38, 3, 0, 9, 46, 8)];
const easing = {
  // This is the most common easing curve.
  easeInOut: "cubic-bezier(0.4, 0, 0.2, 1)",
  // Objects enter the screen at full velocity from off-screen and
  // slowly decelerate to a resting point.
  easeOut: "cubic-bezier(0.0, 0, 0.2, 1)",
  // Objects leave the screen at full velocity. They do not decelerate when off-screen.
  easeIn: "cubic-bezier(0.4, 0, 1, 1)",
  // The sharp curve is used by objects that may return to the screen at any time.
  sharp: "cubic-bezier(0.4, 0, 0.6, 1)"
};
const duration = {
  shortest: 150,
  shorter: 200,
  short: 250,
  // most basic recommended timing
  standard: 300,
  // this is to be used in complex animations
  complex: 375,
  // recommended when something is entering screen
  enteringScreen: 225,
  // recommended when something is leaving screen
  leavingScreen: 195
};
function formatMs(milliseconds) {
  return `${Math.round(milliseconds)}ms`;
}
function getAutoHeightDuration(height2) {
  if (!height2) {
    return 0;
  }
  const constant = height2 / 36;
  return Math.min(Math.round((4 + 15 * constant ** 0.25 + constant / 5) * 10), 3e3);
}
function createTransitions(inputTransitions) {
  const mergedEasing = {
    ...easing,
    ...inputTransitions.easing
  };
  const mergedDuration = {
    ...duration,
    ...inputTransitions.duration
  };
  const create = (props = ["all"], options = {}) => {
    const {
      duration: durationOption = mergedDuration.standard,
      easing: easingOption = mergedEasing.easeInOut,
      delay: delay2 = 0,
      ...other
    } = options;
    return (Array.isArray(props) ? props : [props]).map((animatedProp) => `${animatedProp} ${typeof durationOption === "string" ? durationOption : formatMs(durationOption)} ${easingOption} ${typeof delay2 === "string" ? delay2 : formatMs(delay2)}`).join(",");
  };
  return {
    getAutoHeightDuration,
    create,
    ...inputTransitions,
    easing: mergedEasing,
    duration: mergedDuration
  };
}
const zIndex = {
  mobileStepper: 1e3,
  fab: 1050,
  speedDial: 1050,
  appBar: 1100,
  drawer: 1200,
  modal: 1300,
  snackbar: 1400,
  tooltip: 1500
};
function isSerializable(val) {
  return isPlainObject(val) || typeof val === "undefined" || typeof val === "string" || typeof val === "boolean" || typeof val === "number" || Array.isArray(val);
}
function stringifyTheme(baseTheme = {}) {
  const serializableTheme = {
    ...baseTheme
  };
  function serializeTheme(object) {
    const array = Object.entries(object);
    for (let index2 = 0; index2 < array.length; index2++) {
      const [key2, value] = array[index2];
      if (!isSerializable(value) || key2.startsWith("unstable_")) {
        delete object[key2];
      } else if (isPlainObject(value)) {
        object[key2] = {
          ...value
        };
        serializeTheme(object[key2]);
      }
    }
  }
  serializeTheme(serializableTheme);
  return `import { unstable_createBreakpoints as createBreakpoints, createTransitions } from '@mui/material/styles';

const theme = ${JSON.stringify(serializableTheme, null, 2)};

theme.breakpoints = createBreakpoints(theme.breakpoints || {});
theme.transitions = createTransitions(theme.transitions || {});

export default theme;`;
}
function createThemeNoVars(options = {}, ...args) {
  const {
    breakpoints: breakpointsInput,
    mixins: mixinsInput = {},
    spacing: spacingInput,
    palette: paletteInput = {},
    transitions: transitionsInput = {},
    typography: typographyInput = {},
    shape: shapeInput,
    ...other
  } = options;
  if (options.vars && // The error should throw only for the root theme creation because user is not allowed to use a custom node `vars`.
  // `generateThemeVars` is the closest identifier for checking that the `options` is a result of `createTheme` with CSS variables so that user can create new theme for nested ThemeProvider.
  options.generateThemeVars === void 0) {
    throw new Error(formatMuiErrorMessage(20));
  }
  const palette = createPalette(paletteInput);
  const systemTheme = createTheme$1(options);
  let muiTheme = deepmerge(systemTheme, {
    mixins: createMixins(systemTheme.breakpoints, mixinsInput),
    palette,
    // Don't use [...shadows] until you've verified its transpiled code is not invoking the iterator protocol.
    shadows: shadows.slice(),
    typography: createTypography(palette, typographyInput),
    transitions: createTransitions(transitionsInput),
    zIndex: {
      ...zIndex
    }
  });
  muiTheme = deepmerge(muiTheme, other);
  muiTheme = args.reduce((acc, argument) => deepmerge(acc, argument), muiTheme);
  muiTheme.unstable_sxConfig = {
    ...defaultSxConfig,
    ...other?.unstable_sxConfig
  };
  muiTheme.unstable_sx = function sx(props) {
    return styleFunctionSx({
      sx: props,
      theme: this
    });
  };
  muiTheme.toRuntimeSource = stringifyTheme;
  return muiTheme;
}
function getOverlayAlpha(elevation) {
  let alphaValue;
  if (elevation < 1) {
    alphaValue = 5.11916 * elevation ** 2;
  } else {
    alphaValue = 4.5 * Math.log(elevation + 1) + 2;
  }
  return Math.round(alphaValue * 10) / 1e3;
}
const defaultDarkOverlays = [...Array(25)].map((_2, index2) => {
  if (index2 === 0) {
    return "none";
  }
  const overlay = getOverlayAlpha(index2);
  return `linear-gradient(rgba(255 255 255 / ${overlay}), rgba(255 255 255 / ${overlay}))`;
});
function getOpacity(mode) {
  return {
    inputPlaceholder: mode === "dark" ? 0.5 : 0.42,
    inputUnderline: mode === "dark" ? 0.7 : 0.42,
    switchTrackDisabled: mode === "dark" ? 0.2 : 0.12,
    switchTrack: mode === "dark" ? 0.3 : 0.38
  };
}
function getOverlays(mode) {
  return mode === "dark" ? defaultDarkOverlays : [];
}
function createColorScheme(options) {
  const {
    palette: paletteInput = {
      mode: "light"
    },
    // need to cast to avoid module augmentation test
    opacity,
    overlays,
    ...rest
  } = options;
  const palette = createPalette(paletteInput);
  return {
    palette,
    opacity: {
      ...getOpacity(palette.mode),
      ...opacity
    },
    overlays: overlays || getOverlays(palette.mode),
    ...rest
  };
}
function shouldSkipGeneratingVar(keys) {
  return !!keys[0].match(/(cssVarPrefix|colorSchemeSelector|modularCssLayers|rootSelector|typography|mixins|breakpoints|direction|transitions)/) || !!keys[0].match(/sxConfig$/) || // ends with sxConfig
  keys[0] === "palette" && !!keys[1]?.match(/(mode|contrastThreshold|tonalOffset)/);
}
const excludeVariablesFromRoot = (cssVarPrefix) => [...[...Array(25)].map((_2, index2) => `--${cssVarPrefix ? `${cssVarPrefix}-` : ""}overlays-${index2}`), `--${cssVarPrefix ? `${cssVarPrefix}-` : ""}palette-AppBar-darkBg`, `--${cssVarPrefix ? `${cssVarPrefix}-` : ""}palette-AppBar-darkColor`];
const defaultGetSelector = (theme) => (colorScheme, css2) => {
  const root = theme.rootSelector || ":root";
  const selector = theme.colorSchemeSelector;
  let rule = selector;
  if (selector === "class") {
    rule = ".%s";
  }
  if (selector === "data") {
    rule = "[data-%s]";
  }
  if (selector?.startsWith("data-") && !selector.includes("%s")) {
    rule = `[${selector}="%s"]`;
  }
  if (theme.defaultColorScheme === colorScheme) {
    if (colorScheme === "dark") {
      const excludedVariables = {};
      excludeVariablesFromRoot(theme.cssVarPrefix).forEach((cssVar) => {
        excludedVariables[cssVar] = css2[cssVar];
        delete css2[cssVar];
      });
      if (rule === "media") {
        return {
          [root]: css2,
          [`@media (prefers-color-scheme: dark)`]: {
            [root]: excludedVariables
          }
        };
      }
      if (rule) {
        return {
          [rule.replace("%s", colorScheme)]: excludedVariables,
          [`${root}, ${rule.replace("%s", colorScheme)}`]: css2
        };
      }
      return {
        [root]: {
          ...css2,
          ...excludedVariables
        }
      };
    }
    if (rule && rule !== "media") {
      return `${root}, ${rule.replace("%s", String(colorScheme))}`;
    }
  } else if (colorScheme) {
    if (rule === "media") {
      return {
        [`@media (prefers-color-scheme: ${String(colorScheme)})`]: {
          [root]: css2
        }
      };
    }
    if (rule) {
      return rule.replace("%s", String(colorScheme));
    }
  }
  return root;
};
function assignNode(obj, keys) {
  keys.forEach((k2) => {
    if (!obj[k2]) {
      obj[k2] = {};
    }
  });
}
function setColor(obj, key2, defaultValue) {
  if (!obj[key2] && defaultValue) {
    obj[key2] = defaultValue;
  }
}
function toRgb(color2) {
  if (typeof color2 !== "string" || !color2.startsWith("hsl")) {
    return color2;
  }
  return hslToRgb(color2);
}
function setColorChannel(obj, key2) {
  if (!(`${key2}Channel` in obj)) {
    obj[`${key2}Channel`] = private_safeColorChannel(toRgb(obj[key2]), `MUI: Can't create \`palette.${key2}Channel\` because \`palette.${key2}\` is not one of these formats: #nnn, #nnnnnn, rgb(), rgba(), hsl(), hsla(), color().
To suppress this warning, you need to explicitly provide the \`palette.${key2}Channel\` as a string (in rgb format, for example "12 12 12") or undefined if you want to remove the channel token.`);
  }
}
function getSpacingVal(spacingInput) {
  if (typeof spacingInput === "number") {
    return `${spacingInput}px`;
  }
  if (typeof spacingInput === "string" || typeof spacingInput === "function" || Array.isArray(spacingInput)) {
    return spacingInput;
  }
  return "8px";
}
const silent = (fn) => {
  try {
    return fn();
  } catch (error) {
  }
  return void 0;
};
const createGetCssVar = (cssVarPrefix = "mui") => createGetCssVar$1(cssVarPrefix);
function attachColorScheme$1(colorSchemes, scheme, restTheme, colorScheme) {
  if (!scheme) {
    return void 0;
  }
  scheme = scheme === true ? {} : scheme;
  const mode = colorScheme === "dark" ? "dark" : "light";
  if (!restTheme) {
    colorSchemes[colorScheme] = createColorScheme({
      ...scheme,
      palette: {
        mode,
        ...scheme?.palette
      }
    });
    return void 0;
  }
  const {
    palette,
    ...muiTheme
  } = createThemeNoVars({
    ...restTheme,
    palette: {
      mode,
      ...scheme?.palette
    }
  });
  colorSchemes[colorScheme] = {
    ...scheme,
    palette,
    opacity: {
      ...getOpacity(mode),
      ...scheme?.opacity
    },
    overlays: scheme?.overlays || getOverlays(mode)
  };
  return muiTheme;
}
function createThemeWithVars(options = {}, ...args) {
  const {
    colorSchemes: colorSchemesInput = {
      light: true
    },
    defaultColorScheme: defaultColorSchemeInput,
    disableCssColorScheme = false,
    cssVarPrefix = "mui",
    shouldSkipGeneratingVar: shouldSkipGeneratingVar$1 = shouldSkipGeneratingVar,
    colorSchemeSelector: selector = colorSchemesInput.light && colorSchemesInput.dark ? "media" : void 0,
    rootSelector = ":root",
    ...input
  } = options;
  const firstColorScheme = Object.keys(colorSchemesInput)[0];
  const defaultColorScheme = defaultColorSchemeInput || (colorSchemesInput.light && firstColorScheme !== "light" ? "light" : firstColorScheme);
  const getCssVar = createGetCssVar(cssVarPrefix);
  const {
    [defaultColorScheme]: defaultSchemeInput,
    light: builtInLight,
    dark: builtInDark,
    ...customColorSchemes
  } = colorSchemesInput;
  const colorSchemes = {
    ...customColorSchemes
  };
  let defaultScheme = defaultSchemeInput;
  if (defaultColorScheme === "dark" && !("dark" in colorSchemesInput) || defaultColorScheme === "light" && !("light" in colorSchemesInput)) {
    defaultScheme = true;
  }
  if (!defaultScheme) {
    throw new Error(formatMuiErrorMessage(21, defaultColorScheme));
  }
  const muiTheme = attachColorScheme$1(colorSchemes, defaultScheme, input, defaultColorScheme);
  if (builtInLight && !colorSchemes.light) {
    attachColorScheme$1(colorSchemes, builtInLight, void 0, "light");
  }
  if (builtInDark && !colorSchemes.dark) {
    attachColorScheme$1(colorSchemes, builtInDark, void 0, "dark");
  }
  let theme = {
    defaultColorScheme,
    ...muiTheme,
    cssVarPrefix,
    colorSchemeSelector: selector,
    rootSelector,
    getCssVar,
    colorSchemes,
    font: {
      ...prepareTypographyVars(muiTheme.typography),
      ...muiTheme.font
    },
    spacing: getSpacingVal(input.spacing)
  };
  Object.keys(theme.colorSchemes).forEach((key2) => {
    const palette = theme.colorSchemes[key2].palette;
    const setCssVarColor = (cssVar) => {
      const tokens = cssVar.split("-");
      const color2 = tokens[1];
      const colorToken = tokens[2];
      return getCssVar(cssVar, palette[color2][colorToken]);
    };
    if (palette.mode === "light") {
      setColor(palette.common, "background", "#fff");
      setColor(palette.common, "onBackground", "#000");
    }
    if (palette.mode === "dark") {
      setColor(palette.common, "background", "#000");
      setColor(palette.common, "onBackground", "#fff");
    }
    assignNode(palette, ["Alert", "AppBar", "Avatar", "Button", "Chip", "FilledInput", "LinearProgress", "Skeleton", "Slider", "SnackbarContent", "SpeedDialAction", "StepConnector", "StepContent", "Switch", "TableCell", "Tooltip"]);
    if (palette.mode === "light") {
      setColor(palette.Alert, "errorColor", private_safeDarken(palette.error.light, 0.6));
      setColor(palette.Alert, "infoColor", private_safeDarken(palette.info.light, 0.6));
      setColor(palette.Alert, "successColor", private_safeDarken(palette.success.light, 0.6));
      setColor(palette.Alert, "warningColor", private_safeDarken(palette.warning.light, 0.6));
      setColor(palette.Alert, "errorFilledBg", setCssVarColor("palette-error-main"));
      setColor(palette.Alert, "infoFilledBg", setCssVarColor("palette-info-main"));
      setColor(palette.Alert, "successFilledBg", setCssVarColor("palette-success-main"));
      setColor(palette.Alert, "warningFilledBg", setCssVarColor("palette-warning-main"));
      setColor(palette.Alert, "errorFilledColor", silent(() => palette.getContrastText(palette.error.main)));
      setColor(palette.Alert, "infoFilledColor", silent(() => palette.getContrastText(palette.info.main)));
      setColor(palette.Alert, "successFilledColor", silent(() => palette.getContrastText(palette.success.main)));
      setColor(palette.Alert, "warningFilledColor", silent(() => palette.getContrastText(palette.warning.main)));
      setColor(palette.Alert, "errorStandardBg", private_safeLighten(palette.error.light, 0.9));
      setColor(palette.Alert, "infoStandardBg", private_safeLighten(palette.info.light, 0.9));
      setColor(palette.Alert, "successStandardBg", private_safeLighten(palette.success.light, 0.9));
      setColor(palette.Alert, "warningStandardBg", private_safeLighten(palette.warning.light, 0.9));
      setColor(palette.Alert, "errorIconColor", setCssVarColor("palette-error-main"));
      setColor(palette.Alert, "infoIconColor", setCssVarColor("palette-info-main"));
      setColor(palette.Alert, "successIconColor", setCssVarColor("palette-success-main"));
      setColor(palette.Alert, "warningIconColor", setCssVarColor("palette-warning-main"));
      setColor(palette.AppBar, "defaultBg", setCssVarColor("palette-grey-100"));
      setColor(palette.Avatar, "defaultBg", setCssVarColor("palette-grey-400"));
      setColor(palette.Button, "inheritContainedBg", setCssVarColor("palette-grey-300"));
      setColor(palette.Button, "inheritContainedHoverBg", setCssVarColor("palette-grey-A100"));
      setColor(palette.Chip, "defaultBorder", setCssVarColor("palette-grey-400"));
      setColor(palette.Chip, "defaultAvatarColor", setCssVarColor("palette-grey-700"));
      setColor(palette.Chip, "defaultIconColor", setCssVarColor("palette-grey-700"));
      setColor(palette.FilledInput, "bg", "rgba(0, 0, 0, 0.06)");
      setColor(palette.FilledInput, "hoverBg", "rgba(0, 0, 0, 0.09)");
      setColor(palette.FilledInput, "disabledBg", "rgba(0, 0, 0, 0.12)");
      setColor(palette.LinearProgress, "primaryBg", private_safeLighten(palette.primary.main, 0.62));
      setColor(palette.LinearProgress, "secondaryBg", private_safeLighten(palette.secondary.main, 0.62));
      setColor(palette.LinearProgress, "errorBg", private_safeLighten(palette.error.main, 0.62));
      setColor(palette.LinearProgress, "infoBg", private_safeLighten(palette.info.main, 0.62));
      setColor(palette.LinearProgress, "successBg", private_safeLighten(palette.success.main, 0.62));
      setColor(palette.LinearProgress, "warningBg", private_safeLighten(palette.warning.main, 0.62));
      setColor(palette.Skeleton, "bg", `rgba(${setCssVarColor("palette-text-primaryChannel")} / 0.11)`);
      setColor(palette.Slider, "primaryTrack", private_safeLighten(palette.primary.main, 0.62));
      setColor(palette.Slider, "secondaryTrack", private_safeLighten(palette.secondary.main, 0.62));
      setColor(palette.Slider, "errorTrack", private_safeLighten(palette.error.main, 0.62));
      setColor(palette.Slider, "infoTrack", private_safeLighten(palette.info.main, 0.62));
      setColor(palette.Slider, "successTrack", private_safeLighten(palette.success.main, 0.62));
      setColor(palette.Slider, "warningTrack", private_safeLighten(palette.warning.main, 0.62));
      const snackbarContentBackground = private_safeEmphasize(palette.background.default, 0.8);
      setColor(palette.SnackbarContent, "bg", snackbarContentBackground);
      setColor(palette.SnackbarContent, "color", silent(() => palette.getContrastText(snackbarContentBackground)));
      setColor(palette.SpeedDialAction, "fabHoverBg", private_safeEmphasize(palette.background.paper, 0.15));
      setColor(palette.StepConnector, "border", setCssVarColor("palette-grey-400"));
      setColor(palette.StepContent, "border", setCssVarColor("palette-grey-400"));
      setColor(palette.Switch, "defaultColor", setCssVarColor("palette-common-white"));
      setColor(palette.Switch, "defaultDisabledColor", setCssVarColor("palette-grey-100"));
      setColor(palette.Switch, "primaryDisabledColor", private_safeLighten(palette.primary.main, 0.62));
      setColor(palette.Switch, "secondaryDisabledColor", private_safeLighten(palette.secondary.main, 0.62));
      setColor(palette.Switch, "errorDisabledColor", private_safeLighten(palette.error.main, 0.62));
      setColor(palette.Switch, "infoDisabledColor", private_safeLighten(palette.info.main, 0.62));
      setColor(palette.Switch, "successDisabledColor", private_safeLighten(palette.success.main, 0.62));
      setColor(palette.Switch, "warningDisabledColor", private_safeLighten(palette.warning.main, 0.62));
      setColor(palette.TableCell, "border", private_safeLighten(private_safeAlpha(palette.divider, 1), 0.88));
      setColor(palette.Tooltip, "bg", private_safeAlpha(palette.grey[700], 0.92));
    }
    if (palette.mode === "dark") {
      setColor(palette.Alert, "errorColor", private_safeLighten(palette.error.light, 0.6));
      setColor(palette.Alert, "infoColor", private_safeLighten(palette.info.light, 0.6));
      setColor(palette.Alert, "successColor", private_safeLighten(palette.success.light, 0.6));
      setColor(palette.Alert, "warningColor", private_safeLighten(palette.warning.light, 0.6));
      setColor(palette.Alert, "errorFilledBg", setCssVarColor("palette-error-dark"));
      setColor(palette.Alert, "infoFilledBg", setCssVarColor("palette-info-dark"));
      setColor(palette.Alert, "successFilledBg", setCssVarColor("palette-success-dark"));
      setColor(palette.Alert, "warningFilledBg", setCssVarColor("palette-warning-dark"));
      setColor(palette.Alert, "errorFilledColor", silent(() => palette.getContrastText(palette.error.dark)));
      setColor(palette.Alert, "infoFilledColor", silent(() => palette.getContrastText(palette.info.dark)));
      setColor(palette.Alert, "successFilledColor", silent(() => palette.getContrastText(palette.success.dark)));
      setColor(palette.Alert, "warningFilledColor", silent(() => palette.getContrastText(palette.warning.dark)));
      setColor(palette.Alert, "errorStandardBg", private_safeDarken(palette.error.light, 0.9));
      setColor(palette.Alert, "infoStandardBg", private_safeDarken(palette.info.light, 0.9));
      setColor(palette.Alert, "successStandardBg", private_safeDarken(palette.success.light, 0.9));
      setColor(palette.Alert, "warningStandardBg", private_safeDarken(palette.warning.light, 0.9));
      setColor(palette.Alert, "errorIconColor", setCssVarColor("palette-error-main"));
      setColor(palette.Alert, "infoIconColor", setCssVarColor("palette-info-main"));
      setColor(palette.Alert, "successIconColor", setCssVarColor("palette-success-main"));
      setColor(palette.Alert, "warningIconColor", setCssVarColor("palette-warning-main"));
      setColor(palette.AppBar, "defaultBg", setCssVarColor("palette-grey-900"));
      setColor(palette.AppBar, "darkBg", setCssVarColor("palette-background-paper"));
      setColor(palette.AppBar, "darkColor", setCssVarColor("palette-text-primary"));
      setColor(palette.Avatar, "defaultBg", setCssVarColor("palette-grey-600"));
      setColor(palette.Button, "inheritContainedBg", setCssVarColor("palette-grey-800"));
      setColor(palette.Button, "inheritContainedHoverBg", setCssVarColor("palette-grey-700"));
      setColor(palette.Chip, "defaultBorder", setCssVarColor("palette-grey-700"));
      setColor(palette.Chip, "defaultAvatarColor", setCssVarColor("palette-grey-300"));
      setColor(palette.Chip, "defaultIconColor", setCssVarColor("palette-grey-300"));
      setColor(palette.FilledInput, "bg", "rgba(255, 255, 255, 0.09)");
      setColor(palette.FilledInput, "hoverBg", "rgba(255, 255, 255, 0.13)");
      setColor(palette.FilledInput, "disabledBg", "rgba(255, 255, 255, 0.12)");
      setColor(palette.LinearProgress, "primaryBg", private_safeDarken(palette.primary.main, 0.5));
      setColor(palette.LinearProgress, "secondaryBg", private_safeDarken(palette.secondary.main, 0.5));
      setColor(palette.LinearProgress, "errorBg", private_safeDarken(palette.error.main, 0.5));
      setColor(palette.LinearProgress, "infoBg", private_safeDarken(palette.info.main, 0.5));
      setColor(palette.LinearProgress, "successBg", private_safeDarken(palette.success.main, 0.5));
      setColor(palette.LinearProgress, "warningBg", private_safeDarken(palette.warning.main, 0.5));
      setColor(palette.Skeleton, "bg", `rgba(${setCssVarColor("palette-text-primaryChannel")} / 0.13)`);
      setColor(palette.Slider, "primaryTrack", private_safeDarken(palette.primary.main, 0.5));
      setColor(palette.Slider, "secondaryTrack", private_safeDarken(palette.secondary.main, 0.5));
      setColor(palette.Slider, "errorTrack", private_safeDarken(palette.error.main, 0.5));
      setColor(palette.Slider, "infoTrack", private_safeDarken(palette.info.main, 0.5));
      setColor(palette.Slider, "successTrack", private_safeDarken(palette.success.main, 0.5));
      setColor(palette.Slider, "warningTrack", private_safeDarken(palette.warning.main, 0.5));
      const snackbarContentBackground = private_safeEmphasize(palette.background.default, 0.98);
      setColor(palette.SnackbarContent, "bg", snackbarContentBackground);
      setColor(palette.SnackbarContent, "color", silent(() => palette.getContrastText(snackbarContentBackground)));
      setColor(palette.SpeedDialAction, "fabHoverBg", private_safeEmphasize(palette.background.paper, 0.15));
      setColor(palette.StepConnector, "border", setCssVarColor("palette-grey-600"));
      setColor(palette.StepContent, "border", setCssVarColor("palette-grey-600"));
      setColor(palette.Switch, "defaultColor", setCssVarColor("palette-grey-300"));
      setColor(palette.Switch, "defaultDisabledColor", setCssVarColor("palette-grey-600"));
      setColor(palette.Switch, "primaryDisabledColor", private_safeDarken(palette.primary.main, 0.55));
      setColor(palette.Switch, "secondaryDisabledColor", private_safeDarken(palette.secondary.main, 0.55));
      setColor(palette.Switch, "errorDisabledColor", private_safeDarken(palette.error.main, 0.55));
      setColor(palette.Switch, "infoDisabledColor", private_safeDarken(palette.info.main, 0.55));
      setColor(palette.Switch, "successDisabledColor", private_safeDarken(palette.success.main, 0.55));
      setColor(palette.Switch, "warningDisabledColor", private_safeDarken(palette.warning.main, 0.55));
      setColor(palette.TableCell, "border", private_safeDarken(private_safeAlpha(palette.divider, 1), 0.68));
      setColor(palette.Tooltip, "bg", private_safeAlpha(palette.grey[700], 0.92));
    }
    setColorChannel(palette.background, "default");
    setColorChannel(palette.background, "paper");
    setColorChannel(palette.common, "background");
    setColorChannel(palette.common, "onBackground");
    setColorChannel(palette, "divider");
    Object.keys(palette).forEach((color2) => {
      const colors = palette[color2];
      if (color2 !== "tonalOffset" && colors && typeof colors === "object") {
        if (colors.main) {
          setColor(palette[color2], "mainChannel", private_safeColorChannel(toRgb(colors.main)));
        }
        if (colors.light) {
          setColor(palette[color2], "lightChannel", private_safeColorChannel(toRgb(colors.light)));
        }
        if (colors.dark) {
          setColor(palette[color2], "darkChannel", private_safeColorChannel(toRgb(colors.dark)));
        }
        if (colors.contrastText) {
          setColor(palette[color2], "contrastTextChannel", private_safeColorChannel(toRgb(colors.contrastText)));
        }
        if (color2 === "text") {
          setColorChannel(palette[color2], "primary");
          setColorChannel(palette[color2], "secondary");
        }
        if (color2 === "action") {
          if (colors.active) {
            setColorChannel(palette[color2], "active");
          }
          if (colors.selected) {
            setColorChannel(palette[color2], "selected");
          }
        }
      }
    });
  });
  theme = args.reduce((acc, argument) => deepmerge(acc, argument), theme);
  const parserConfig = {
    prefix: cssVarPrefix,
    disableCssColorScheme,
    shouldSkipGeneratingVar: shouldSkipGeneratingVar$1,
    getSelector: defaultGetSelector(theme)
  };
  const {
    vars,
    generateThemeVars,
    generateStyleSheets
  } = prepareCssVars(theme, parserConfig);
  theme.vars = vars;
  Object.entries(theme.colorSchemes[theme.defaultColorScheme]).forEach(([key2, value]) => {
    theme[key2] = value;
  });
  theme.generateThemeVars = generateThemeVars;
  theme.generateStyleSheets = generateStyleSheets;
  theme.generateSpacing = function generateSpacing() {
    return createSpacing(input.spacing, createUnarySpacing(this));
  };
  theme.getColorSchemeSelector = createGetColorSchemeSelector(selector);
  theme.spacing = theme.generateSpacing();
  theme.shouldSkipGeneratingVar = shouldSkipGeneratingVar$1;
  theme.unstable_sxConfig = {
    ...defaultSxConfig,
    ...input?.unstable_sxConfig
  };
  theme.unstable_sx = function sx(props) {
    return styleFunctionSx({
      sx: props,
      theme: this
    });
  };
  theme.toRuntimeSource = stringifyTheme;
  return theme;
}
function attachColorScheme(theme, scheme, colorScheme) {
  if (!theme.colorSchemes) {
    return void 0;
  }
  if (colorScheme) {
    theme.colorSchemes[scheme] = {
      ...colorScheme !== true && colorScheme,
      palette: createPalette({
        ...colorScheme === true ? {} : colorScheme.palette,
        mode: scheme
      })
      // cast type to skip module augmentation test
    };
  }
}
function createTheme(options = {}, ...args) {
  const {
    palette,
    cssVariables = false,
    colorSchemes: initialColorSchemes = !palette ? {
      light: true
    } : void 0,
    defaultColorScheme: initialDefaultColorScheme = palette?.mode,
    ...rest
  } = options;
  const defaultColorSchemeInput = initialDefaultColorScheme || "light";
  const defaultScheme = initialColorSchemes?.[defaultColorSchemeInput];
  const colorSchemesInput = {
    ...initialColorSchemes,
    ...palette ? {
      [defaultColorSchemeInput]: {
        ...typeof defaultScheme !== "boolean" && defaultScheme,
        palette
      }
    } : void 0
  };
  if (cssVariables === false) {
    if (!("colorSchemes" in options)) {
      return createThemeNoVars(options, ...args);
    }
    let paletteOptions = palette;
    if (!("palette" in options)) {
      if (colorSchemesInput[defaultColorSchemeInput]) {
        if (colorSchemesInput[defaultColorSchemeInput] !== true) {
          paletteOptions = colorSchemesInput[defaultColorSchemeInput].palette;
        } else if (defaultColorSchemeInput === "dark") {
          paletteOptions = {
            mode: "dark"
          };
        }
      }
    }
    const theme = createThemeNoVars({
      ...options,
      palette: paletteOptions
    }, ...args);
    theme.defaultColorScheme = defaultColorSchemeInput;
    theme.colorSchemes = colorSchemesInput;
    if (theme.palette.mode === "light") {
      theme.colorSchemes.light = {
        ...colorSchemesInput.light !== true && colorSchemesInput.light,
        palette: theme.palette
      };
      attachColorScheme(theme, "dark", colorSchemesInput.dark);
    }
    if (theme.palette.mode === "dark") {
      theme.colorSchemes.dark = {
        ...colorSchemesInput.dark !== true && colorSchemesInput.dark,
        palette: theme.palette
      };
      attachColorScheme(theme, "light", colorSchemesInput.light);
    }
    return theme;
  }
  if (!palette && !("light" in colorSchemesInput) && defaultColorSchemeInput === "light") {
    colorSchemesInput.light = true;
  }
  return createThemeWithVars({
    ...rest,
    colorSchemes: colorSchemesInput,
    defaultColorScheme: defaultColorSchemeInput,
    ...typeof cssVariables !== "boolean" && cssVariables
  }, ...args);
}
const defaultTheme$1 = createTheme();
function useTheme() {
  const theme = useTheme$2(defaultTheme$1);
  return theme[THEME_ID] || theme;
}
function slotShouldForwardProp(prop) {
  return prop !== "ownerState" && prop !== "theme" && prop !== "sx" && prop !== "as";
}
const rootShouldForwardProp = (prop) => slotShouldForwardProp(prop) && prop !== "classes";
const styled = createStyled2({
  themeId: THEME_ID,
  defaultTheme: defaultTheme$1,
  rootShouldForwardProp
});
function ThemeProviderNoVars({
  theme: themeInput,
  ...props
}) {
  const scopedTheme = THEME_ID in themeInput ? themeInput[THEME_ID] : void 0;
  return /* @__PURE__ */ jsxRuntimeExports.jsx(ThemeProvider$1, {
    ...props,
    themeId: scopedTheme ? THEME_ID : void 0,
    theme: scopedTheme || themeInput
  });
}
const defaultConfig = {
  attribute: "data-mui-color-scheme",
  colorSchemeStorageKey: "mui-color-scheme",
  defaultLightColorScheme: "light",
  defaultDarkColorScheme: "dark",
  modeStorageKey: "mui-mode"
};
const {
  CssVarsProvider: InternalCssVarsProvider,
  useColorScheme,
  getInitColorSchemeScript: deprecatedGetInitColorSchemeScript
} = createCssVarsProvider({
  themeId: THEME_ID,
  // @ts-ignore ignore module augmentation tests
  theme: () => createTheme({
    cssVariables: true
  }),
  colorSchemeStorageKey: defaultConfig.colorSchemeStorageKey,
  modeStorageKey: defaultConfig.modeStorageKey,
  defaultColorScheme: {
    light: defaultConfig.defaultLightColorScheme,
    dark: defaultConfig.defaultDarkColorScheme
  },
  resolveTheme: (theme) => {
    const newTheme = {
      ...theme,
      typography: createTypography(theme.palette, theme.typography)
    };
    newTheme.unstable_sx = function sx(props) {
      return styleFunctionSx({
        sx: props,
        theme: this
      });
    };
    return newTheme;
  }
});
const CssVarsProvider = InternalCssVarsProvider;
function ThemeProvider({
  theme,
  ...props
}) {
  const noVarsTheme = reactExports.useMemo(() => {
    if (typeof theme === "function") {
      return theme;
    }
    const muiTheme = THEME_ID in theme ? theme[THEME_ID] : theme;
    if (!("colorSchemes" in muiTheme)) {
      if (!("vars" in muiTheme)) {
        return {
          ...theme,
          vars: null
        };
      }
      return theme;
    }
    return null;
  }, [theme]);
  if (noVarsTheme) {
    return /* @__PURE__ */ jsxRuntimeExports.jsx(ThemeProviderNoVars, {
      theme: noVarsTheme,
      ...props
    });
  }
  return /* @__PURE__ */ jsxRuntimeExports.jsx(CssVarsProvider, {
    theme,
    ...props
  });
}
function GlobalStyles(props) {
  return /* @__PURE__ */ jsxRuntimeExports.jsx(GlobalStyles$1, {
    ...props,
    defaultTheme: defaultTheme$1,
    themeId: THEME_ID
  });
}
function globalCss(styles2) {
  return function GlobalStylesWrapper(props) {
    return (
      // Pigment CSS `globalCss` support callback with theme inside an object but `GlobalStyles` support theme as a callback value.
      /* @__PURE__ */ jsxRuntimeExports.jsx(GlobalStyles, {
        styles: typeof styles2 === "function" ? (theme) => styles2({
          theme,
          ...props
        }) : styles2
      })
    );
  };
}
function internal_createExtendSxProp() {
  return extendSxProp$1;
}
const memoTheme = unstable_memoTheme;
function useDefaultProps(params) {
  return useDefaultProps$1(params);
}
function getSvgIconUtilityClass(slot) {
  return generateUtilityClass("MuiSvgIcon", slot);
}
generateUtilityClasses("MuiSvgIcon", ["root", "colorPrimary", "colorSecondary", "colorAction", "colorError", "colorDisabled", "fontSizeInherit", "fontSizeSmall", "fontSizeMedium", "fontSizeLarge"]);
const useUtilityClasses$e = (ownerState) => {
  const {
    color: color2,
    fontSize,
    classes
  } = ownerState;
  const slots = {
    root: ["root", color2 !== "inherit" && `color${capitalize(color2)}`, `fontSize${capitalize(fontSize)}`]
  };
  return composeClasses(slots, getSvgIconUtilityClass, classes);
};
const SvgIconRoot = styled("svg", {
  name: "MuiSvgIcon",
  slot: "Root",
  overridesResolver: (props, styles2) => {
    const {
      ownerState
    } = props;
    return [styles2.root, ownerState.color !== "inherit" && styles2[`color${capitalize(ownerState.color)}`], styles2[`fontSize${capitalize(ownerState.fontSize)}`]];
  }
})(memoTheme(({
  theme
}) => ({
  userSelect: "none",
  width: "1em",
  height: "1em",
  display: "inline-block",
  flexShrink: 0,
  transition: theme.transitions?.create?.("fill", {
    duration: (theme.vars ?? theme).transitions?.duration?.shorter
  }),
  variants: [
    {
      props: (props) => !props.hasSvgAsChild,
      style: {
        // the <svg> will define the property that has `currentColor`
        // for example heroicons uses fill="none" and stroke="currentColor"
        fill: "currentColor"
      }
    },
    {
      props: {
        fontSize: "inherit"
      },
      style: {
        fontSize: "inherit"
      }
    },
    {
      props: {
        fontSize: "small"
      },
      style: {
        fontSize: theme.typography?.pxToRem?.(20) || "1.25rem"
      }
    },
    {
      props: {
        fontSize: "medium"
      },
      style: {
        fontSize: theme.typography?.pxToRem?.(24) || "1.5rem"
      }
    },
    {
      props: {
        fontSize: "large"
      },
      style: {
        fontSize: theme.typography?.pxToRem?.(35) || "2.1875rem"
      }
    },
    // TODO v5 deprecate color prop, v6 remove for sx
    ...Object.entries((theme.vars ?? theme).palette).filter(([, value]) => value && value.main).map(([color2]) => ({
      props: {
        color: color2
      },
      style: {
        color: (theme.vars ?? theme).palette?.[color2]?.main
      }
    })),
    {
      props: {
        color: "action"
      },
      style: {
        color: (theme.vars ?? theme).palette?.action?.active
      }
    },
    {
      props: {
        color: "disabled"
      },
      style: {
        color: (theme.vars ?? theme).palette?.action?.disabled
      }
    },
    {
      props: {
        color: "inherit"
      },
      style: {
        color: void 0
      }
    }
  ]
})));
const SvgIcon = /* @__PURE__ */ reactExports.forwardRef(function SvgIcon2(inProps, ref) {
  const props = useDefaultProps({
    props: inProps,
    name: "MuiSvgIcon"
  });
  const {
    children,
    className,
    color: color2 = "inherit",
    component = "svg",
    fontSize = "medium",
    htmlColor,
    inheritViewBox = false,
    titleAccess,
    viewBox = "0 0 24 24",
    ...other
  } = props;
  const hasSvgAsChild = /* @__PURE__ */ reactExports.isValidElement(children) && children.type === "svg";
  const ownerState = {
    ...props,
    color: color2,
    component,
    fontSize,
    instanceFontSize: inProps.fontSize,
    inheritViewBox,
    viewBox,
    hasSvgAsChild
  };
  const more = {};
  if (!inheritViewBox) {
    more.viewBox = viewBox;
  }
  const classes = useUtilityClasses$e(ownerState);
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(SvgIconRoot, {
    as: component,
    className: clsx(classes.root, className),
    focusable: "false",
    color: htmlColor,
    "aria-hidden": titleAccess ? void 0 : true,
    role: titleAccess ? "img" : void 0,
    ref,
    ...more,
    ...other,
    ...hasSvgAsChild && children.props,
    ownerState,
    children: [hasSvgAsChild ? children.props.children : children, titleAccess ? /* @__PURE__ */ jsxRuntimeExports.jsx("title", {
      children: titleAccess
    }) : null]
  });
});
SvgIcon.muiName = "SvgIcon";
function createSvgIcon(path, displayName) {
  function Component(props, ref) {
    return /* @__PURE__ */ jsxRuntimeExports.jsx(SvgIcon, {
      "data-testid": void 0,
      ref,
      ...props,
      children: path
    });
  }
  Component.muiName = SvgIcon.muiName;
  return /* @__PURE__ */ reactExports.memo(/* @__PURE__ */ reactExports.forwardRef(Component));
}
function ownerDocument(node2) {
  return node2 && node2.ownerDocument || document;
}
function useEventCallback(fn) {
  const ref = reactExports.useRef(fn);
  useEnhancedEffect(() => {
    ref.current = fn;
  });
  return reactExports.useRef((...args) => (
    // @ts-expect-error hide `this`
    (0, ref.current)(...args)
  )).current;
}
function useForkRef(...refs) {
  const cleanupRef = reactExports.useRef(void 0);
  const refEffect = reactExports.useCallback((instance) => {
    const cleanups = refs.map((ref) => {
      if (ref == null) {
        return null;
      }
      if (typeof ref === "function") {
        const refCallback = ref;
        const refCleanup = refCallback(instance);
        return typeof refCleanup === "function" ? refCleanup : () => {
          refCallback(null);
        };
      }
      ref.current = instance;
      return () => {
        ref.current = null;
      };
    });
    return () => {
      cleanups.forEach((refCleanup) => refCleanup?.());
    };
  }, refs);
  return reactExports.useMemo(() => {
    if (refs.every((ref) => ref == null)) {
      return null;
    }
    return (value) => {
      if (cleanupRef.current) {
        cleanupRef.current();
        cleanupRef.current = void 0;
      }
      if (value != null) {
        cleanupRef.current = refEffect(value);
      }
    };
  }, refs);
}
function _setPrototypeOf(t2, e2) {
  return _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function(t3, e3) {
    return t3.__proto__ = e3, t3;
  }, _setPrototypeOf(t2, e2);
}
function _inheritsLoose(t2, o) {
  t2.prototype = Object.create(o.prototype), t2.prototype.constructor = t2, _setPrototypeOf(t2, o);
}
const config = {
  disabled: false
};
const TransitionGroupContext = React.createContext(null);
var forceReflow = function forceReflow2(node2) {
  return node2.scrollTop;
};
var UNMOUNTED = "unmounted";
var EXITED = "exited";
var ENTERING = "entering";
var ENTERED = "entered";
var EXITING = "exiting";
var Transition = /* @__PURE__ */ function(_React$Component) {
  _inheritsLoose(Transition2, _React$Component);
  function Transition2(props, context) {
    var _this;
    _this = _React$Component.call(this, props, context) || this;
    var parentGroup = context;
    var appear = parentGroup && !parentGroup.isMounting ? props.enter : props.appear;
    var initialStatus;
    _this.appearStatus = null;
    if (props.in) {
      if (appear) {
        initialStatus = EXITED;
        _this.appearStatus = ENTERING;
      } else {
        initialStatus = ENTERED;
      }
    } else {
      if (props.unmountOnExit || props.mountOnEnter) {
        initialStatus = UNMOUNTED;
      } else {
        initialStatus = EXITED;
      }
    }
    _this.state = {
      status: initialStatus
    };
    _this.nextCallback = null;
    return _this;
  }
  Transition2.getDerivedStateFromProps = function getDerivedStateFromProps(_ref, prevState) {
    var nextIn = _ref.in;
    if (nextIn && prevState.status === UNMOUNTED) {
      return {
        status: EXITED
      };
    }
    return null;
  };
  var _proto = Transition2.prototype;
  _proto.componentDidMount = function componentDidMount() {
    this.updateStatus(true, this.appearStatus);
  };
  _proto.componentDidUpdate = function componentDidUpdate(prevProps) {
    var nextStatus = null;
    if (prevProps !== this.props) {
      var status = this.state.status;
      if (this.props.in) {
        if (status !== ENTERING && status !== ENTERED) {
          nextStatus = ENTERING;
        }
      } else {
        if (status === ENTERING || status === ENTERED) {
          nextStatus = EXITING;
        }
      }
    }
    this.updateStatus(false, nextStatus);
  };
  _proto.componentWillUnmount = function componentWillUnmount() {
    this.cancelNextCallback();
  };
  _proto.getTimeouts = function getTimeouts() {
    var timeout2 = this.props.timeout;
    var exit, enter, appear;
    exit = enter = appear = timeout2;
    if (timeout2 != null && typeof timeout2 !== "number") {
      exit = timeout2.exit;
      enter = timeout2.enter;
      appear = timeout2.appear !== void 0 ? timeout2.appear : enter;
    }
    return {
      exit,
      enter,
      appear
    };
  };
  _proto.updateStatus = function updateStatus(mounting, nextStatus) {
    if (mounting === void 0) {
      mounting = false;
    }
    if (nextStatus !== null) {
      this.cancelNextCallback();
      if (nextStatus === ENTERING) {
        if (this.props.unmountOnExit || this.props.mountOnEnter) {
          var node2 = this.props.nodeRef ? this.props.nodeRef.current : ReactDOM.findDOMNode(this);
          if (node2) forceReflow(node2);
        }
        this.performEnter(mounting);
      } else {
        this.performExit();
      }
    } else if (this.props.unmountOnExit && this.state.status === EXITED) {
      this.setState({
        status: UNMOUNTED
      });
    }
  };
  _proto.performEnter = function performEnter(mounting) {
    var _this2 = this;
    var enter = this.props.enter;
    var appearing = this.context ? this.context.isMounting : mounting;
    var _ref2 = this.props.nodeRef ? [appearing] : [ReactDOM.findDOMNode(this), appearing], maybeNode = _ref2[0], maybeAppearing = _ref2[1];
    var timeouts = this.getTimeouts();
    var enterTimeout = appearing ? timeouts.appear : timeouts.enter;
    if (!mounting && !enter || config.disabled) {
      this.safeSetState({
        status: ENTERED
      }, function() {
        _this2.props.onEntered(maybeNode);
      });
      return;
    }
    this.props.onEnter(maybeNode, maybeAppearing);
    this.safeSetState({
      status: ENTERING
    }, function() {
      _this2.props.onEntering(maybeNode, maybeAppearing);
      _this2.onTransitionEnd(enterTimeout, function() {
        _this2.safeSetState({
          status: ENTERED
        }, function() {
          _this2.props.onEntered(maybeNode, maybeAppearing);
        });
      });
    });
  };
  _proto.performExit = function performExit() {
    var _this3 = this;
    var exit = this.props.exit;
    var timeouts = this.getTimeouts();
    var maybeNode = this.props.nodeRef ? void 0 : ReactDOM.findDOMNode(this);
    if (!exit || config.disabled) {
      this.safeSetState({
        status: EXITED
      }, function() {
        _this3.props.onExited(maybeNode);
      });
      return;
    }
    this.props.onExit(maybeNode);
    this.safeSetState({
      status: EXITING
    }, function() {
      _this3.props.onExiting(maybeNode);
      _this3.onTransitionEnd(timeouts.exit, function() {
        _this3.safeSetState({
          status: EXITED
        }, function() {
          _this3.props.onExited(maybeNode);
        });
      });
    });
  };
  _proto.cancelNextCallback = function cancelNextCallback() {
    if (this.nextCallback !== null) {
      this.nextCallback.cancel();
      this.nextCallback = null;
    }
  };
  _proto.safeSetState = function safeSetState(nextState, callback) {
    callback = this.setNextCallback(callback);
    this.setState(nextState, callback);
  };
  _proto.setNextCallback = function setNextCallback(callback) {
    var _this4 = this;
    var active = true;
    this.nextCallback = function(event) {
      if (active) {
        active = false;
        _this4.nextCallback = null;
        callback(event);
      }
    };
    this.nextCallback.cancel = function() {
      active = false;
    };
    return this.nextCallback;
  };
  _proto.onTransitionEnd = function onTransitionEnd(timeout2, handler) {
    this.setNextCallback(handler);
    var node2 = this.props.nodeRef ? this.props.nodeRef.current : ReactDOM.findDOMNode(this);
    var doesNotHaveTimeoutOrListener = timeout2 == null && !this.props.addEndListener;
    if (!node2 || doesNotHaveTimeoutOrListener) {
      setTimeout(this.nextCallback, 0);
      return;
    }
    if (this.props.addEndListener) {
      var _ref3 = this.props.nodeRef ? [this.nextCallback] : [node2, this.nextCallback], maybeNode = _ref3[0], maybeNextCallback = _ref3[1];
      this.props.addEndListener(maybeNode, maybeNextCallback);
    }
    if (timeout2 != null) {
      setTimeout(this.nextCallback, timeout2);
    }
  };
  _proto.render = function render2() {
    var status = this.state.status;
    if (status === UNMOUNTED) {
      return null;
    }
    var _this$props = this.props, children = _this$props.children;
    _this$props.in;
    _this$props.mountOnEnter;
    _this$props.unmountOnExit;
    _this$props.appear;
    _this$props.enter;
    _this$props.exit;
    _this$props.timeout;
    _this$props.addEndListener;
    _this$props.onEnter;
    _this$props.onEntering;
    _this$props.onEntered;
    _this$props.onExit;
    _this$props.onExiting;
    _this$props.onExited;
    _this$props.nodeRef;
    var childProps = _objectWithoutPropertiesLoose(_this$props, ["children", "in", "mountOnEnter", "unmountOnExit", "appear", "enter", "exit", "timeout", "addEndListener", "onEnter", "onEntering", "onEntered", "onExit", "onExiting", "onExited", "nodeRef"]);
    return (
      // allows for nested Transitions
      /* @__PURE__ */ React.createElement(TransitionGroupContext.Provider, {
        value: null
      }, typeof children === "function" ? children(status, childProps) : React.cloneElement(React.Children.only(children), childProps))
    );
  };
  return Transition2;
}(React.Component);
Transition.contextType = TransitionGroupContext;
Transition.propTypes = {};
function noop() {
}
Transition.defaultProps = {
  in: false,
  mountOnEnter: false,
  unmountOnExit: false,
  appear: false,
  enter: true,
  exit: true,
  onEnter: noop,
  onEntering: noop,
  onEntered: noop,
  onExit: noop,
  onExiting: noop,
  onExited: noop
};
Transition.UNMOUNTED = UNMOUNTED;
Transition.EXITED = EXITED;
Transition.ENTERING = ENTERING;
Transition.ENTERED = ENTERED;
Transition.EXITING = EXITING;
function _assertThisInitialized(e2) {
  if (void 0 === e2) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  return e2;
}
function getChildMapping(children, mapFn) {
  var mapper = function mapper2(child) {
    return mapFn && reactExports.isValidElement(child) ? mapFn(child) : child;
  };
  var result = /* @__PURE__ */ Object.create(null);
  if (children) reactExports.Children.map(children, function(c2) {
    return c2;
  }).forEach(function(child) {
    result[child.key] = mapper(child);
  });
  return result;
}
function mergeChildMappings(prev2, next2) {
  prev2 = prev2 || {};
  next2 = next2 || {};
  function getValueForKey(key2) {
    return key2 in next2 ? next2[key2] : prev2[key2];
  }
  var nextKeysPending = /* @__PURE__ */ Object.create(null);
  var pendingKeys = [];
  for (var prevKey in prev2) {
    if (prevKey in next2) {
      if (pendingKeys.length) {
        nextKeysPending[prevKey] = pendingKeys;
        pendingKeys = [];
      }
    } else {
      pendingKeys.push(prevKey);
    }
  }
  var i2;
  var childMapping = {};
  for (var nextKey in next2) {
    if (nextKeysPending[nextKey]) {
      for (i2 = 0; i2 < nextKeysPending[nextKey].length; i2++) {
        var pendingNextKey = nextKeysPending[nextKey][i2];
        childMapping[nextKeysPending[nextKey][i2]] = getValueForKey(pendingNextKey);
      }
    }
    childMapping[nextKey] = getValueForKey(nextKey);
  }
  for (i2 = 0; i2 < pendingKeys.length; i2++) {
    childMapping[pendingKeys[i2]] = getValueForKey(pendingKeys[i2]);
  }
  return childMapping;
}
function getProp(child, prop, props) {
  return props[prop] != null ? props[prop] : child.props[prop];
}
function getInitialChildMapping(props, onExited) {
  return getChildMapping(props.children, function(child) {
    return reactExports.cloneElement(child, {
      onExited: onExited.bind(null, child),
      in: true,
      appear: getProp(child, "appear", props),
      enter: getProp(child, "enter", props),
      exit: getProp(child, "exit", props)
    });
  });
}
function getNextChildMapping(nextProps, prevChildMapping, onExited) {
  var nextChildMapping = getChildMapping(nextProps.children);
  var children = mergeChildMappings(prevChildMapping, nextChildMapping);
  Object.keys(children).forEach(function(key2) {
    var child = children[key2];
    if (!reactExports.isValidElement(child)) return;
    var hasPrev = key2 in prevChildMapping;
    var hasNext = key2 in nextChildMapping;
    var prevChild = prevChildMapping[key2];
    var isLeaving = reactExports.isValidElement(prevChild) && !prevChild.props.in;
    if (hasNext && (!hasPrev || isLeaving)) {
      children[key2] = reactExports.cloneElement(child, {
        onExited: onExited.bind(null, child),
        in: true,
        exit: getProp(child, "exit", nextProps),
        enter: getProp(child, "enter", nextProps)
      });
    } else if (!hasNext && hasPrev && !isLeaving) {
      children[key2] = reactExports.cloneElement(child, {
        in: false
      });
    } else if (hasNext && hasPrev && reactExports.isValidElement(prevChild)) {
      children[key2] = reactExports.cloneElement(child, {
        onExited: onExited.bind(null, child),
        in: prevChild.props.in,
        exit: getProp(child, "exit", nextProps),
        enter: getProp(child, "enter", nextProps)
      });
    }
  });
  return children;
}
var values = Object.values || function(obj) {
  return Object.keys(obj).map(function(k2) {
    return obj[k2];
  });
};
var defaultProps = {
  component: "div",
  childFactory: function childFactory(child) {
    return child;
  }
};
var TransitionGroup = /* @__PURE__ */ function(_React$Component) {
  _inheritsLoose(TransitionGroup2, _React$Component);
  function TransitionGroup2(props, context) {
    var _this;
    _this = _React$Component.call(this, props, context) || this;
    var handleExited = _this.handleExited.bind(_assertThisInitialized(_this));
    _this.state = {
      contextValue: {
        isMounting: true
      },
      handleExited,
      firstRender: true
    };
    return _this;
  }
  var _proto = TransitionGroup2.prototype;
  _proto.componentDidMount = function componentDidMount() {
    this.mounted = true;
    this.setState({
      contextValue: {
        isMounting: false
      }
    });
  };
  _proto.componentWillUnmount = function componentWillUnmount() {
    this.mounted = false;
  };
  TransitionGroup2.getDerivedStateFromProps = function getDerivedStateFromProps(nextProps, _ref) {
    var prevChildMapping = _ref.children, handleExited = _ref.handleExited, firstRender = _ref.firstRender;
    return {
      children: firstRender ? getInitialChildMapping(nextProps, handleExited) : getNextChildMapping(nextProps, prevChildMapping, handleExited),
      firstRender: false
    };
  };
  _proto.handleExited = function handleExited(child, node2) {
    var currentChildMapping = getChildMapping(this.props.children);
    if (child.key in currentChildMapping) return;
    if (child.props.onExited) {
      child.props.onExited(node2);
    }
    if (this.mounted) {
      this.setState(function(state) {
        var children = _extends({}, state.children);
        delete children[child.key];
        return {
          children
        };
      });
    }
  };
  _proto.render = function render2() {
    var _this$props = this.props, Component = _this$props.component, childFactory2 = _this$props.childFactory, props = _objectWithoutPropertiesLoose(_this$props, ["component", "childFactory"]);
    var contextValue = this.state.contextValue;
    var children = values(this.state.children).map(childFactory2);
    delete props.appear;
    delete props.enter;
    delete props.exit;
    if (Component === null) {
      return /* @__PURE__ */ React.createElement(TransitionGroupContext.Provider, {
        value: contextValue
      }, children);
    }
    return /* @__PURE__ */ React.createElement(TransitionGroupContext.Provider, {
      value: contextValue
    }, /* @__PURE__ */ React.createElement(Component, props, children));
  };
  return TransitionGroup2;
}(React.Component);
TransitionGroup.propTypes = {};
TransitionGroup.defaultProps = defaultProps;
const UNINITIALIZED = {};
function useLazyRef(init, initArg) {
  const ref = reactExports.useRef(UNINITIALIZED);
  if (ref.current === UNINITIALIZED) {
    ref.current = init(initArg);
  }
  return ref;
}
const EMPTY = [];
function useOnMount(fn) {
  reactExports.useEffect(fn, EMPTY);
}
class Timeout {
  constructor() {
    __publicField(this, "currentId", null);
    __publicField(this, "clear", () => {
      if (this.currentId !== null) {
        clearTimeout(this.currentId);
        this.currentId = null;
      }
    });
    __publicField(this, "disposeEffect", () => {
      return this.clear;
    });
  }
  static create() {
    return new Timeout();
  }
  /**
   * Executes `fn` after `delay`, clearing any previously scheduled call.
   */
  start(delay2, fn) {
    this.clear();
    this.currentId = setTimeout(() => {
      this.currentId = null;
      fn();
    }, delay2);
  }
}
function useTimeout() {
  const timeout = useLazyRef(Timeout.create).current;
  useOnMount(timeout.disposeEffect);
  return timeout;
}
const reflow = (node2) => node2.scrollTop;
function getTransitionProps(props, options) {
  const {
    timeout,
    easing: easing2,
    style: style2 = {}
  } = props;
  return {
    duration: style2.transitionDuration ?? (typeof timeout === "number" ? timeout : timeout[options.mode] || 0),
    easing: style2.transitionTimingFunction ?? (typeof easing2 === "object" ? easing2[options.mode] : easing2),
    delay: style2.transitionDelay
  };
}
function getPaperUtilityClass(slot) {
  return generateUtilityClass("MuiPaper", slot);
}
generateUtilityClasses("MuiPaper", ["root", "rounded", "outlined", "elevation", "elevation0", "elevation1", "elevation2", "elevation3", "elevation4", "elevation5", "elevation6", "elevation7", "elevation8", "elevation9", "elevation10", "elevation11", "elevation12", "elevation13", "elevation14", "elevation15", "elevation16", "elevation17", "elevation18", "elevation19", "elevation20", "elevation21", "elevation22", "elevation23", "elevation24"]);
const useUtilityClasses$d = (ownerState) => {
  const {
    square,
    elevation,
    variant,
    classes
  } = ownerState;
  const slots = {
    root: ["root", variant, !square && "rounded", variant === "elevation" && `elevation${elevation}`]
  };
  return composeClasses(slots, getPaperUtilityClass, classes);
};
const PaperRoot = styled("div", {
  name: "MuiPaper",
  slot: "Root",
  overridesResolver: (props, styles2) => {
    const {
      ownerState
    } = props;
    return [styles2.root, styles2[ownerState.variant], !ownerState.square && styles2.rounded, ownerState.variant === "elevation" && styles2[`elevation${ownerState.elevation}`]];
  }
})(memoTheme(({
  theme
}) => ({
  backgroundColor: (theme.vars || theme).palette.background.paper,
  color: (theme.vars || theme).palette.text.primary,
  transition: theme.transitions.create("box-shadow"),
  variants: [{
    props: ({
      ownerState
    }) => !ownerState.square,
    style: {
      borderRadius: theme.shape.borderRadius
    }
  }, {
    props: {
      variant: "outlined"
    },
    style: {
      border: `1px solid ${(theme.vars || theme).palette.divider}`
    }
  }, {
    props: {
      variant: "elevation"
    },
    style: {
      boxShadow: "var(--Paper-shadow)",
      backgroundImage: "var(--Paper-overlay)"
    }
  }]
})));
const Paper = /* @__PURE__ */ reactExports.forwardRef(function Paper2(inProps, ref) {
  const props = useDefaultProps({
    props: inProps,
    name: "MuiPaper"
  });
  const theme = useTheme();
  const {
    className,
    component = "div",
    elevation = 1,
    square = false,
    variant = "elevation",
    ...other
  } = props;
  const ownerState = {
    ...props,
    component,
    elevation,
    square,
    variant
  };
  const classes = useUtilityClasses$d(ownerState);
  return /* @__PURE__ */ jsxRuntimeExports.jsx(PaperRoot, {
    as: component,
    ownerState,
    className: clsx(classes.root, className),
    ref,
    ...other,
    style: {
      ...variant === "elevation" && {
        "--Paper-shadow": (theme.vars || theme).shadows[elevation],
        ...theme.vars && {
          "--Paper-overlay": theme.vars.overlays?.[elevation]
        },
        ...!theme.vars && theme.palette.mode === "dark" && {
          "--Paper-overlay": `linear-gradient(${alpha("#fff", getOverlayAlpha(elevation))}, ${alpha("#fff", getOverlayAlpha(elevation))})`
        }
      },
      ...other.style
    }
  });
});
function isHostComponent(element) {
  return typeof element === "string";
}
function appendOwnerState(elementType, otherProps, ownerState) {
  if (elementType === void 0 || isHostComponent(elementType)) {
    return otherProps;
  }
  return {
    ...otherProps,
    ownerState: {
      ...otherProps.ownerState,
      ...ownerState
    }
  };
}
function resolveComponentProps(componentProps, ownerState, slotState) {
  if (typeof componentProps === "function") {
    return componentProps(ownerState, slotState);
  }
  return componentProps;
}
function extractEventHandlers(object, excludeKeys = []) {
  if (object === void 0) {
    return {};
  }
  const result = {};
  Object.keys(object).filter((prop) => prop.match(/^on[A-Z]/) && typeof object[prop] === "function" && !excludeKeys.includes(prop)).forEach((prop) => {
    result[prop] = object[prop];
  });
  return result;
}
function omitEventHandlers(object) {
  if (object === void 0) {
    return {};
  }
  const result = {};
  Object.keys(object).filter((prop) => !(prop.match(/^on[A-Z]/) && typeof object[prop] === "function")).forEach((prop) => {
    result[prop] = object[prop];
  });
  return result;
}
function mergeSlotProps(parameters) {
  const {
    getSlotProps,
    additionalProps,
    externalSlotProps,
    externalForwardedProps,
    className
  } = parameters;
  if (!getSlotProps) {
    const joinedClasses2 = clsx(additionalProps?.className, className, externalForwardedProps?.className, externalSlotProps?.className);
    const mergedStyle2 = {
      ...additionalProps?.style,
      ...externalForwardedProps?.style,
      ...externalSlotProps?.style
    };
    const props2 = {
      ...additionalProps,
      ...externalForwardedProps,
      ...externalSlotProps
    };
    if (joinedClasses2.length > 0) {
      props2.className = joinedClasses2;
    }
    if (Object.keys(mergedStyle2).length > 0) {
      props2.style = mergedStyle2;
    }
    return {
      props: props2,
      internalRef: void 0
    };
  }
  const eventHandlers = extractEventHandlers({
    ...externalForwardedProps,
    ...externalSlotProps
  });
  const componentsPropsWithoutEventHandlers = omitEventHandlers(externalSlotProps);
  const otherPropsWithoutEventHandlers = omitEventHandlers(externalForwardedProps);
  const internalSlotProps = getSlotProps(eventHandlers);
  const joinedClasses = clsx(internalSlotProps?.className, additionalProps?.className, className, externalForwardedProps?.className, externalSlotProps?.className);
  const mergedStyle = {
    ...internalSlotProps?.style,
    ...additionalProps?.style,
    ...externalForwardedProps?.style,
    ...externalSlotProps?.style
  };
  const props = {
    ...internalSlotProps,
    ...additionalProps,
    ...otherPropsWithoutEventHandlers,
    ...componentsPropsWithoutEventHandlers
  };
  if (joinedClasses.length > 0) {
    props.className = joinedClasses;
  }
  if (Object.keys(mergedStyle).length > 0) {
    props.style = mergedStyle;
  }
  return {
    props,
    internalRef: internalSlotProps.ref
  };
}
function useSlot(name, parameters) {
  const {
    className,
    elementType: initialElementType,
    ownerState,
    externalForwardedProps,
    internalForwardedProps,
    shouldForwardComponentProp = false,
    ...useSlotPropsParams
  } = parameters;
  const {
    component: rootComponent,
    slots = {
      [name]: void 0
    },
    slotProps = {
      [name]: void 0
    },
    ...other
  } = externalForwardedProps;
  const elementType = slots[name] || initialElementType;
  const resolvedComponentsProps = resolveComponentProps(slotProps[name], ownerState);
  const {
    props: {
      component: slotComponent,
      ...mergedProps
    },
    internalRef
  } = mergeSlotProps({
    className,
    ...useSlotPropsParams,
    externalForwardedProps: name === "root" ? other : void 0,
    externalSlotProps: resolvedComponentsProps
  });
  const ref = useForkRef(internalRef, resolvedComponentsProps?.ref, parameters.ref);
  const LeafComponent = name === "root" ? slotComponent || rootComponent : slotComponent;
  const props = appendOwnerState(elementType, {
    ...name === "root" && !rootComponent && !slots[name] && internalForwardedProps,
    ...name !== "root" && !slots[name] && internalForwardedProps,
    ...mergedProps,
    ...LeafComponent && !shouldForwardComponentProp && {
      as: LeafComponent
    },
    ...LeafComponent && shouldForwardComponentProp && {
      component: LeafComponent
    },
    ref
  }, ownerState);
  return [elementType, props];
}
function isFocusVisible(element) {
  try {
    return element.matches(":focus-visible");
  } catch (error) {
  }
  return false;
}
class LazyRipple {
  constructor() {
    __publicField(this, "mountEffect", () => {
      if (this.shouldMount && !this.didMount) {
        if (this.ref.current !== null) {
          this.didMount = true;
          this.mounted.resolve();
        }
      }
    });
    this.ref = {
      current: null
    };
    this.mounted = null;
    this.didMount = false;
    this.shouldMount = false;
    this.setShouldMount = null;
  }
  /** React ref to the ripple instance */
  /** If the ripple component should be mounted */
  /** Promise that resolves when the ripple component is mounted */
  /** If the ripple component has been mounted */
  /** React state hook setter */
  static create() {
    return new LazyRipple();
  }
  static use() {
    const ripple = useLazyRef(LazyRipple.create).current;
    const [shouldMount, setShouldMount] = reactExports.useState(false);
    ripple.shouldMount = shouldMount;
    ripple.setShouldMount = setShouldMount;
    reactExports.useEffect(ripple.mountEffect, [shouldMount]);
    return ripple;
  }
  mount() {
    if (!this.mounted) {
      this.mounted = createControlledPromise();
      this.shouldMount = true;
      this.setShouldMount(this.shouldMount);
    }
    return this.mounted;
  }
  /* Ripple API */
  start(...args) {
    this.mount().then(() => this.ref.current?.start(...args));
  }
  stop(...args) {
    this.mount().then(() => this.ref.current?.stop(...args));
  }
  pulsate(...args) {
    this.mount().then(() => this.ref.current?.pulsate(...args));
  }
}
function useLazyRipple() {
  return LazyRipple.use();
}
function createControlledPromise() {
  let resolve;
  let reject;
  const p2 = new Promise((resolveFn, rejectFn) => {
    resolve = resolveFn;
    reject = rejectFn;
  });
  p2.resolve = resolve;
  p2.reject = reject;
  return p2;
}
function Ripple(props) {
  const {
    className,
    classes,
    pulsate = false,
    rippleX,
    rippleY,
    rippleSize,
    in: inProp,
    onExited,
    timeout
  } = props;
  const [leaving, setLeaving] = reactExports.useState(false);
  const rippleClassName = clsx(className, classes.ripple, classes.rippleVisible, pulsate && classes.ripplePulsate);
  const rippleStyles = {
    width: rippleSize,
    height: rippleSize,
    top: -(rippleSize / 2) + rippleY,
    left: -(rippleSize / 2) + rippleX
  };
  const childClassName = clsx(classes.child, leaving && classes.childLeaving, pulsate && classes.childPulsate);
  if (!inProp && !leaving) {
    setLeaving(true);
  }
  reactExports.useEffect(() => {
    if (!inProp && onExited != null) {
      const timeoutId = setTimeout(onExited, timeout);
      return () => {
        clearTimeout(timeoutId);
      };
    }
    return void 0;
  }, [onExited, inProp, timeout]);
  return /* @__PURE__ */ jsxRuntimeExports.jsx("span", {
    className: rippleClassName,
    style: rippleStyles,
    children: /* @__PURE__ */ jsxRuntimeExports.jsx("span", {
      className: childClassName
    })
  });
}
const touchRippleClasses = generateUtilityClasses("MuiTouchRipple", ["root", "ripple", "rippleVisible", "ripplePulsate", "child", "childLeaving", "childPulsate"]);
const DURATION = 550;
const DELAY_RIPPLE = 80;
const enterKeyframe = keyframes`
  0% {
    transform: scale(0);
    opacity: 0.1;
  }

  100% {
    transform: scale(1);
    opacity: 0.3;
  }
`;
const exitKeyframe = keyframes`
  0% {
    opacity: 1;
  }

  100% {
    opacity: 0;
  }
`;
const pulsateKeyframe = keyframes`
  0% {
    transform: scale(1);
  }

  50% {
    transform: scale(0.92);
  }

  100% {
    transform: scale(1);
  }
`;
const TouchRippleRoot = styled("span", {
  name: "MuiTouchRipple",
  slot: "Root"
})({
  overflow: "hidden",
  pointerEvents: "none",
  position: "absolute",
  zIndex: 0,
  top: 0,
  right: 0,
  bottom: 0,
  left: 0,
  borderRadius: "inherit"
});
const TouchRippleRipple = styled(Ripple, {
  name: "MuiTouchRipple",
  slot: "Ripple"
})`
  opacity: 0;
  position: absolute;

  &.${touchRippleClasses.rippleVisible} {
    opacity: 0.3;
    transform: scale(1);
    animation-name: ${enterKeyframe};
    animation-duration: ${DURATION}ms;
    animation-timing-function: ${({
  theme
}) => theme.transitions.easing.easeInOut};
  }

  &.${touchRippleClasses.ripplePulsate} {
    animation-duration: ${({
  theme
}) => theme.transitions.duration.shorter}ms;
  }

  & .${touchRippleClasses.child} {
    opacity: 1;
    display: block;
    width: 100%;
    height: 100%;
    border-radius: 50%;
    background-color: currentColor;
  }

  & .${touchRippleClasses.childLeaving} {
    opacity: 0;
    animation-name: ${exitKeyframe};
    animation-duration: ${DURATION}ms;
    animation-timing-function: ${({
  theme
}) => theme.transitions.easing.easeInOut};
  }

  & .${touchRippleClasses.childPulsate} {
    position: absolute;
    /* @noflip */
    left: 0px;
    top: 0;
    animation-name: ${pulsateKeyframe};
    animation-duration: 2500ms;
    animation-timing-function: ${({
  theme
}) => theme.transitions.easing.easeInOut};
    animation-iteration-count: infinite;
    animation-delay: 200ms;
  }
`;
const TouchRipple = /* @__PURE__ */ reactExports.forwardRef(function TouchRipple2(inProps, ref) {
  const props = useDefaultProps({
    props: inProps,
    name: "MuiTouchRipple"
  });
  const {
    center: centerProp = false,
    classes = {},
    className,
    ...other
  } = props;
  const [ripples, setRipples] = reactExports.useState([]);
  const nextKey = reactExports.useRef(0);
  const rippleCallback = reactExports.useRef(null);
  reactExports.useEffect(() => {
    if (rippleCallback.current) {
      rippleCallback.current();
      rippleCallback.current = null;
    }
  }, [ripples]);
  const ignoringMouseDown = reactExports.useRef(false);
  const startTimer = useTimeout();
  const startTimerCommit = reactExports.useRef(null);
  const container = reactExports.useRef(null);
  const startCommit = reactExports.useCallback((params) => {
    const {
      pulsate: pulsate2,
      rippleX,
      rippleY,
      rippleSize,
      cb
    } = params;
    setRipples((oldRipples) => [...oldRipples, /* @__PURE__ */ jsxRuntimeExports.jsx(TouchRippleRipple, {
      classes: {
        ripple: clsx(classes.ripple, touchRippleClasses.ripple),
        rippleVisible: clsx(classes.rippleVisible, touchRippleClasses.rippleVisible),
        ripplePulsate: clsx(classes.ripplePulsate, touchRippleClasses.ripplePulsate),
        child: clsx(classes.child, touchRippleClasses.child),
        childLeaving: clsx(classes.childLeaving, touchRippleClasses.childLeaving),
        childPulsate: clsx(classes.childPulsate, touchRippleClasses.childPulsate)
      },
      timeout: DURATION,
      pulsate: pulsate2,
      rippleX,
      rippleY,
      rippleSize
    }, nextKey.current)]);
    nextKey.current += 1;
    rippleCallback.current = cb;
  }, [classes]);
  const start = reactExports.useCallback((event = {}, options = {}, cb = () => {
  }) => {
    const {
      pulsate: pulsate2 = false,
      center = centerProp || options.pulsate,
      fakeElement = false
      // For test purposes
    } = options;
    if (event?.type === "mousedown" && ignoringMouseDown.current) {
      ignoringMouseDown.current = false;
      return;
    }
    if (event?.type === "touchstart") {
      ignoringMouseDown.current = true;
    }
    const element = fakeElement ? null : container.current;
    const rect = element ? element.getBoundingClientRect() : {
      width: 0,
      height: 0,
      left: 0,
      top: 0
    };
    let rippleX;
    let rippleY;
    let rippleSize;
    if (center || event === void 0 || event.clientX === 0 && event.clientY === 0 || !event.clientX && !event.touches) {
      rippleX = Math.round(rect.width / 2);
      rippleY = Math.round(rect.height / 2);
    } else {
      const {
        clientX,
        clientY
      } = event.touches && event.touches.length > 0 ? event.touches[0] : event;
      rippleX = Math.round(clientX - rect.left);
      rippleY = Math.round(clientY - rect.top);
    }
    if (center) {
      rippleSize = Math.sqrt((2 * rect.width ** 2 + rect.height ** 2) / 3);
      if (rippleSize % 2 === 0) {
        rippleSize += 1;
      }
    } else {
      const sizeX = Math.max(Math.abs((element ? element.clientWidth : 0) - rippleX), rippleX) * 2 + 2;
      const sizeY = Math.max(Math.abs((element ? element.clientHeight : 0) - rippleY), rippleY) * 2 + 2;
      rippleSize = Math.sqrt(sizeX ** 2 + sizeY ** 2);
    }
    if (event?.touches) {
      if (startTimerCommit.current === null) {
        startTimerCommit.current = () => {
          startCommit({
            pulsate: pulsate2,
            rippleX,
            rippleY,
            rippleSize,
            cb
          });
        };
        startTimer.start(DELAY_RIPPLE, () => {
          if (startTimerCommit.current) {
            startTimerCommit.current();
            startTimerCommit.current = null;
          }
        });
      }
    } else {
      startCommit({
        pulsate: pulsate2,
        rippleX,
        rippleY,
        rippleSize,
        cb
      });
    }
  }, [centerProp, startCommit, startTimer]);
  const pulsate = reactExports.useCallback(() => {
    start({}, {
      pulsate: true
    });
  }, [start]);
  const stop = reactExports.useCallback((event, cb) => {
    startTimer.clear();
    if (event?.type === "touchend" && startTimerCommit.current) {
      startTimerCommit.current();
      startTimerCommit.current = null;
      startTimer.start(0, () => {
        stop(event, cb);
      });
      return;
    }
    startTimerCommit.current = null;
    setRipples((oldRipples) => {
      if (oldRipples.length > 0) {
        return oldRipples.slice(1);
      }
      return oldRipples;
    });
    rippleCallback.current = cb;
  }, [startTimer]);
  reactExports.useImperativeHandle(ref, () => ({
    pulsate,
    start,
    stop
  }), [pulsate, start, stop]);
  return /* @__PURE__ */ jsxRuntimeExports.jsx(TouchRippleRoot, {
    className: clsx(touchRippleClasses.root, classes.root, className),
    ref: container,
    ...other,
    children: /* @__PURE__ */ jsxRuntimeExports.jsx(TransitionGroup, {
      component: null,
      exit: true,
      children: ripples
    })
  });
});
function getButtonBaseUtilityClass(slot) {
  return generateUtilityClass("MuiButtonBase", slot);
}
const buttonBaseClasses = generateUtilityClasses("MuiButtonBase", ["root", "disabled", "focusVisible"]);
const useUtilityClasses$c = (ownerState) => {
  const {
    disabled,
    focusVisible,
    focusVisibleClassName,
    classes
  } = ownerState;
  const slots = {
    root: ["root", disabled && "disabled", focusVisible && "focusVisible"]
  };
  const composedClasses = composeClasses(slots, getButtonBaseUtilityClass, classes);
  if (focusVisible && focusVisibleClassName) {
    composedClasses.root += ` ${focusVisibleClassName}`;
  }
  return composedClasses;
};
const ButtonBaseRoot = styled("button", {
  name: "MuiButtonBase",
  slot: "Root"
})({
  display: "inline-flex",
  alignItems: "center",
  justifyContent: "center",
  position: "relative",
  boxSizing: "border-box",
  WebkitTapHighlightColor: "transparent",
  backgroundColor: "transparent",
  // Reset default value
  // We disable the focus ring for mouse, touch and keyboard users.
  outline: 0,
  border: 0,
  margin: 0,
  // Remove the margin in Safari
  borderRadius: 0,
  padding: 0,
  // Remove the padding in Firefox
  cursor: "pointer",
  userSelect: "none",
  verticalAlign: "middle",
  MozAppearance: "none",
  // Reset
  WebkitAppearance: "none",
  // Reset
  textDecoration: "none",
  // So we take precedent over the style of a native <a /> element.
  color: "inherit",
  "&::-moz-focus-inner": {
    borderStyle: "none"
    // Remove Firefox dotted outline.
  },
  [`&.${buttonBaseClasses.disabled}`]: {
    pointerEvents: "none",
    // Disable link interactions
    cursor: "default"
  },
  "@media print": {
    colorAdjust: "exact"
  }
});
const ButtonBase = /* @__PURE__ */ reactExports.forwardRef(function ButtonBase2(inProps, ref) {
  const props = useDefaultProps({
    props: inProps,
    name: "MuiButtonBase"
  });
  const {
    action,
    centerRipple = false,
    children,
    className,
    component = "button",
    disabled = false,
    disableRipple = false,
    disableTouchRipple = false,
    focusRipple = false,
    focusVisibleClassName,
    LinkComponent = "a",
    onBlur,
    onClick,
    onContextMenu,
    onDragLeave,
    onFocus,
    onFocusVisible,
    onKeyDown,
    onKeyUp,
    onMouseDown,
    onMouseLeave,
    onMouseUp,
    onTouchEnd,
    onTouchMove,
    onTouchStart,
    tabIndex = 0,
    TouchRippleProps,
    touchRippleRef,
    type,
    ...other
  } = props;
  const buttonRef = reactExports.useRef(null);
  const ripple = useLazyRipple();
  const handleRippleRef = useForkRef(ripple.ref, touchRippleRef);
  const [focusVisible, setFocusVisible] = reactExports.useState(false);
  if (disabled && focusVisible) {
    setFocusVisible(false);
  }
  reactExports.useImperativeHandle(action, () => ({
    focusVisible: () => {
      setFocusVisible(true);
      buttonRef.current.focus();
    }
  }), []);
  const enableTouchRipple = ripple.shouldMount && !disableRipple && !disabled;
  reactExports.useEffect(() => {
    if (focusVisible && focusRipple && !disableRipple) {
      ripple.pulsate();
    }
  }, [disableRipple, focusRipple, focusVisible, ripple]);
  const handleMouseDown = useRippleHandler(ripple, "start", onMouseDown, disableTouchRipple);
  const handleContextMenu = useRippleHandler(ripple, "stop", onContextMenu, disableTouchRipple);
  const handleDragLeave = useRippleHandler(ripple, "stop", onDragLeave, disableTouchRipple);
  const handleMouseUp = useRippleHandler(ripple, "stop", onMouseUp, disableTouchRipple);
  const handleMouseLeave = useRippleHandler(ripple, "stop", (event) => {
    if (focusVisible) {
      event.preventDefault();
    }
    if (onMouseLeave) {
      onMouseLeave(event);
    }
  }, disableTouchRipple);
  const handleTouchStart = useRippleHandler(ripple, "start", onTouchStart, disableTouchRipple);
  const handleTouchEnd = useRippleHandler(ripple, "stop", onTouchEnd, disableTouchRipple);
  const handleTouchMove = useRippleHandler(ripple, "stop", onTouchMove, disableTouchRipple);
  const handleBlur = useRippleHandler(ripple, "stop", (event) => {
    if (!isFocusVisible(event.target)) {
      setFocusVisible(false);
    }
    if (onBlur) {
      onBlur(event);
    }
  }, false);
  const handleFocus = useEventCallback((event) => {
    if (!buttonRef.current) {
      buttonRef.current = event.currentTarget;
    }
    if (isFocusVisible(event.target)) {
      setFocusVisible(true);
      if (onFocusVisible) {
        onFocusVisible(event);
      }
    }
    if (onFocus) {
      onFocus(event);
    }
  });
  const isNonNativeButton = () => {
    const button2 = buttonRef.current;
    return component && component !== "button" && !(button2.tagName === "A" && button2.href);
  };
  const handleKeyDown = useEventCallback((event) => {
    if (focusRipple && !event.repeat && focusVisible && event.key === " ") {
      ripple.stop(event, () => {
        ripple.start(event);
      });
    }
    if (event.target === event.currentTarget && isNonNativeButton() && event.key === " ") {
      event.preventDefault();
    }
    if (onKeyDown) {
      onKeyDown(event);
    }
    if (event.target === event.currentTarget && isNonNativeButton() && event.key === "Enter" && !disabled) {
      event.preventDefault();
      if (onClick) {
        onClick(event);
      }
    }
  });
  const handleKeyUp = useEventCallback((event) => {
    if (focusRipple && event.key === " " && focusVisible && !event.defaultPrevented) {
      ripple.stop(event, () => {
        ripple.pulsate(event);
      });
    }
    if (onKeyUp) {
      onKeyUp(event);
    }
    if (onClick && event.target === event.currentTarget && isNonNativeButton() && event.key === " " && !event.defaultPrevented) {
      onClick(event);
    }
  });
  let ComponentProp = component;
  if (ComponentProp === "button" && (other.href || other.to)) {
    ComponentProp = LinkComponent;
  }
  const buttonProps = {};
  if (ComponentProp === "button") {
    buttonProps.type = type === void 0 ? "button" : type;
    buttonProps.disabled = disabled;
  } else {
    if (!other.href && !other.to) {
      buttonProps.role = "button";
    }
    if (disabled) {
      buttonProps["aria-disabled"] = disabled;
    }
  }
  const handleRef = useForkRef(ref, buttonRef);
  const ownerState = {
    ...props,
    centerRipple,
    component,
    disabled,
    disableRipple,
    disableTouchRipple,
    focusRipple,
    tabIndex,
    focusVisible
  };
  const classes = useUtilityClasses$c(ownerState);
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(ButtonBaseRoot, {
    as: ComponentProp,
    className: clsx(classes.root, className),
    ownerState,
    onBlur: handleBlur,
    onClick,
    onContextMenu: handleContextMenu,
    onFocus: handleFocus,
    onKeyDown: handleKeyDown,
    onKeyUp: handleKeyUp,
    onMouseDown: handleMouseDown,
    onMouseLeave: handleMouseLeave,
    onMouseUp: handleMouseUp,
    onDragLeave: handleDragLeave,
    onTouchEnd: handleTouchEnd,
    onTouchMove: handleTouchMove,
    onTouchStart: handleTouchStart,
    ref: handleRef,
    tabIndex: disabled ? -1 : tabIndex,
    type,
    ...buttonProps,
    ...other,
    children: [children, enableTouchRipple ? /* @__PURE__ */ jsxRuntimeExports.jsx(TouchRipple, {
      ref: handleRippleRef,
      center: centerRipple,
      ...TouchRippleProps
    }) : null]
  });
});
function useRippleHandler(ripple, rippleAction, eventCallback, skipRippleAction = false) {
  return useEventCallback((event) => {
    if (eventCallback) {
      eventCallback(event);
    }
    if (!skipRippleAction) {
      ripple[rippleAction](event);
    }
    return true;
  });
}
function hasCorrectMainProperty(obj) {
  return typeof obj.main === "string";
}
function checkSimplePaletteColorValues(obj, additionalPropertiesToCheck = []) {
  if (!hasCorrectMainProperty(obj)) {
    return false;
  }
  for (const value of additionalPropertiesToCheck) {
    if (!obj.hasOwnProperty(value) || typeof obj[value] !== "string") {
      return false;
    }
  }
  return true;
}
function createSimplePaletteValueFilter(additionalPropertiesToCheck = []) {
  return ([, value]) => value && checkSimplePaletteColorValues(value, additionalPropertiesToCheck);
}
function getAlertUtilityClass(slot) {
  return generateUtilityClass("MuiAlert", slot);
}
const alertClasses = generateUtilityClasses("MuiAlert", ["root", "action", "icon", "message", "filled", "colorSuccess", "colorInfo", "colorWarning", "colorError", "filledSuccess", "filledInfo", "filledWarning", "filledError", "outlined", "outlinedSuccess", "outlinedInfo", "outlinedWarning", "outlinedError", "standard", "standardSuccess", "standardInfo", "standardWarning", "standardError"]);
function getCircularProgressUtilityClass(slot) {
  return generateUtilityClass("MuiCircularProgress", slot);
}
generateUtilityClasses("MuiCircularProgress", ["root", "determinate", "indeterminate", "colorPrimary", "colorSecondary", "svg", "circle", "circleDeterminate", "circleIndeterminate", "circleDisableShrink"]);
const SIZE = 44;
const circularRotateKeyframe = keyframes`
  0% {
    transform: rotate(0deg);
  }

  100% {
    transform: rotate(360deg);
  }
`;
const circularDashKeyframe = keyframes`
  0% {
    stroke-dasharray: 1px, 200px;
    stroke-dashoffset: 0;
  }

  50% {
    stroke-dasharray: 100px, 200px;
    stroke-dashoffset: -15px;
  }

  100% {
    stroke-dasharray: 1px, 200px;
    stroke-dashoffset: -126px;
  }
`;
const rotateAnimation = typeof circularRotateKeyframe !== "string" ? css`
        animation: ${circularRotateKeyframe} 1.4s linear infinite;
      ` : null;
const dashAnimation = typeof circularDashKeyframe !== "string" ? css`
        animation: ${circularDashKeyframe} 1.4s ease-in-out infinite;
      ` : null;
const useUtilityClasses$b = (ownerState) => {
  const {
    classes,
    variant,
    color: color2,
    disableShrink
  } = ownerState;
  const slots = {
    root: ["root", variant, `color${capitalize(color2)}`],
    svg: ["svg"],
    circle: ["circle", `circle${capitalize(variant)}`, disableShrink && "circleDisableShrink"]
  };
  return composeClasses(slots, getCircularProgressUtilityClass, classes);
};
const CircularProgressRoot = styled("span", {
  name: "MuiCircularProgress",
  slot: "Root",
  overridesResolver: (props, styles2) => {
    const {
      ownerState
    } = props;
    return [styles2.root, styles2[ownerState.variant], styles2[`color${capitalize(ownerState.color)}`]];
  }
})(memoTheme(({
  theme
}) => ({
  display: "inline-block",
  variants: [{
    props: {
      variant: "determinate"
    },
    style: {
      transition: theme.transitions.create("transform")
    }
  }, {
    props: {
      variant: "indeterminate"
    },
    style: rotateAnimation || {
      animation: `${circularRotateKeyframe} 1.4s linear infinite`
    }
  }, ...Object.entries(theme.palette).filter(createSimplePaletteValueFilter()).map(([color2]) => ({
    props: {
      color: color2
    },
    style: {
      color: (theme.vars || theme).palette[color2].main
    }
  }))]
})));
const CircularProgressSVG = styled("svg", {
  name: "MuiCircularProgress",
  slot: "Svg"
})({
  display: "block"
  // Keeps the progress centered
});
const CircularProgressCircle = styled("circle", {
  name: "MuiCircularProgress",
  slot: "Circle",
  overridesResolver: (props, styles2) => {
    const {
      ownerState
    } = props;
    return [styles2.circle, styles2[`circle${capitalize(ownerState.variant)}`], ownerState.disableShrink && styles2.circleDisableShrink];
  }
})(memoTheme(({
  theme
}) => ({
  stroke: "currentColor",
  variants: [{
    props: {
      variant: "determinate"
    },
    style: {
      transition: theme.transitions.create("stroke-dashoffset")
    }
  }, {
    props: {
      variant: "indeterminate"
    },
    style: {
      // Some default value that looks fine waiting for the animation to kicks in.
      strokeDasharray: "80px, 200px",
      strokeDashoffset: 0
      // Add the unit to fix a Edge 16 and below bug.
    }
  }, {
    props: ({
      ownerState
    }) => ownerState.variant === "indeterminate" && !ownerState.disableShrink,
    style: dashAnimation || {
      // At runtime for Pigment CSS, `bufferAnimation` will be null and the generated keyframe will be used.
      animation: `${circularDashKeyframe} 1.4s ease-in-out infinite`
    }
  }]
})));
const CircularProgress = /* @__PURE__ */ reactExports.forwardRef(function CircularProgress2(inProps, ref) {
  const props = useDefaultProps({
    props: inProps,
    name: "MuiCircularProgress"
  });
  const {
    className,
    color: color2 = "primary",
    disableShrink = false,
    size: size2 = 40,
    style: style2,
    thickness = 3.6,
    value = 0,
    variant = "indeterminate",
    ...other
  } = props;
  const ownerState = {
    ...props,
    color: color2,
    disableShrink,
    size: size2,
    thickness,
    value,
    variant
  };
  const classes = useUtilityClasses$b(ownerState);
  const circleStyle = {};
  const rootStyle = {};
  const rootProps = {};
  if (variant === "determinate") {
    const circumference = 2 * Math.PI * ((SIZE - thickness) / 2);
    circleStyle.strokeDasharray = circumference.toFixed(3);
    rootProps["aria-valuenow"] = Math.round(value);
    circleStyle.strokeDashoffset = `${((100 - value) / 100 * circumference).toFixed(3)}px`;
    rootStyle.transform = "rotate(-90deg)";
  }
  return /* @__PURE__ */ jsxRuntimeExports.jsx(CircularProgressRoot, {
    className: clsx(classes.root, className),
    style: {
      width: size2,
      height: size2,
      ...rootStyle,
      ...style2
    },
    ownerState,
    ref,
    role: "progressbar",
    ...rootProps,
    ...other,
    children: /* @__PURE__ */ jsxRuntimeExports.jsx(CircularProgressSVG, {
      className: classes.svg,
      ownerState,
      viewBox: `${SIZE / 2} ${SIZE / 2} ${SIZE} ${SIZE}`,
      children: /* @__PURE__ */ jsxRuntimeExports.jsx(CircularProgressCircle, {
        className: classes.circle,
        style: circleStyle,
        ownerState,
        cx: SIZE,
        cy: SIZE,
        r: (SIZE - thickness) / 2,
        fill: "none",
        strokeWidth: thickness
      })
    })
  });
});
function getIconButtonUtilityClass(slot) {
  return generateUtilityClass("MuiIconButton", slot);
}
const iconButtonClasses = generateUtilityClasses("MuiIconButton", ["root", "disabled", "colorInherit", "colorPrimary", "colorSecondary", "colorError", "colorInfo", "colorSuccess", "colorWarning", "edgeStart", "edgeEnd", "sizeSmall", "sizeMedium", "sizeLarge", "loading", "loadingIndicator", "loadingWrapper"]);
const useUtilityClasses$a = (ownerState) => {
  const {
    classes,
    disabled,
    color: color2,
    edge,
    size: size2,
    loading
  } = ownerState;
  const slots = {
    root: ["root", loading && "loading", disabled && "disabled", color2 !== "default" && `color${capitalize(color2)}`, edge && `edge${capitalize(edge)}`, `size${capitalize(size2)}`],
    loadingIndicator: ["loadingIndicator"],
    loadingWrapper: ["loadingWrapper"]
  };
  return composeClasses(slots, getIconButtonUtilityClass, classes);
};
const IconButtonRoot = styled(ButtonBase, {
  name: "MuiIconButton",
  slot: "Root",
  overridesResolver: (props, styles2) => {
    const {
      ownerState
    } = props;
    return [styles2.root, ownerState.loading && styles2.loading, ownerState.color !== "default" && styles2[`color${capitalize(ownerState.color)}`], ownerState.edge && styles2[`edge${capitalize(ownerState.edge)}`], styles2[`size${capitalize(ownerState.size)}`]];
  }
})(memoTheme(({
  theme
}) => ({
  textAlign: "center",
  flex: "0 0 auto",
  fontSize: theme.typography.pxToRem(24),
  padding: 8,
  borderRadius: "50%",
  color: (theme.vars || theme).palette.action.active,
  transition: theme.transitions.create("background-color", {
    duration: theme.transitions.duration.shortest
  }),
  variants: [{
    props: (props) => !props.disableRipple,
    style: {
      "--IconButton-hoverBg": theme.vars ? `rgba(${theme.vars.palette.action.activeChannel} / ${theme.vars.palette.action.hoverOpacity})` : alpha(theme.palette.action.active, theme.palette.action.hoverOpacity),
      "&:hover": {
        backgroundColor: "var(--IconButton-hoverBg)",
        // Reset on touch devices, it doesn't add specificity
        "@media (hover: none)": {
          backgroundColor: "transparent"
        }
      }
    }
  }, {
    props: {
      edge: "start"
    },
    style: {
      marginLeft: -12
    }
  }, {
    props: {
      edge: "start",
      size: "small"
    },
    style: {
      marginLeft: -3
    }
  }, {
    props: {
      edge: "end"
    },
    style: {
      marginRight: -12
    }
  }, {
    props: {
      edge: "end",
      size: "small"
    },
    style: {
      marginRight: -3
    }
  }]
})), memoTheme(({
  theme
}) => ({
  variants: [{
    props: {
      color: "inherit"
    },
    style: {
      color: "inherit"
    }
  }, ...Object.entries(theme.palette).filter(createSimplePaletteValueFilter()).map(([color2]) => ({
    props: {
      color: color2
    },
    style: {
      color: (theme.vars || theme).palette[color2].main
    }
  })), ...Object.entries(theme.palette).filter(createSimplePaletteValueFilter()).map(([color2]) => ({
    props: {
      color: color2
    },
    style: {
      "--IconButton-hoverBg": theme.vars ? `rgba(${(theme.vars || theme).palette[color2].mainChannel} / ${theme.vars.palette.action.hoverOpacity})` : alpha((theme.vars || theme).palette[color2].main, theme.palette.action.hoverOpacity)
    }
  })), {
    props: {
      size: "small"
    },
    style: {
      padding: 5,
      fontSize: theme.typography.pxToRem(18)
    }
  }, {
    props: {
      size: "large"
    },
    style: {
      padding: 12,
      fontSize: theme.typography.pxToRem(28)
    }
  }],
  [`&.${iconButtonClasses.disabled}`]: {
    backgroundColor: "transparent",
    color: (theme.vars || theme).palette.action.disabled
  },
  [`&.${iconButtonClasses.loading}`]: {
    color: "transparent"
  }
})));
const IconButtonLoadingIndicator = styled("span", {
  name: "MuiIconButton",
  slot: "LoadingIndicator"
})(({
  theme
}) => ({
  display: "none",
  position: "absolute",
  visibility: "visible",
  top: "50%",
  left: "50%",
  transform: "translate(-50%, -50%)",
  color: (theme.vars || theme).palette.action.disabled,
  variants: [{
    props: {
      loading: true
    },
    style: {
      display: "flex"
    }
  }]
}));
const IconButton = /* @__PURE__ */ reactExports.forwardRef(function IconButton2(inProps, ref) {
  const props = useDefaultProps({
    props: inProps,
    name: "MuiIconButton"
  });
  const {
    edge = false,
    children,
    className,
    color: color2 = "default",
    disabled = false,
    disableFocusRipple = false,
    size: size2 = "medium",
    id: idProp,
    loading = null,
    loadingIndicator: loadingIndicatorProp,
    ...other
  } = props;
  const loadingId = useId(idProp);
  const loadingIndicator = loadingIndicatorProp ?? /* @__PURE__ */ jsxRuntimeExports.jsx(CircularProgress, {
    "aria-labelledby": loadingId,
    color: "inherit",
    size: 16
  });
  const ownerState = {
    ...props,
    edge,
    color: color2,
    disabled,
    disableFocusRipple,
    loading,
    loadingIndicator,
    size: size2
  };
  const classes = useUtilityClasses$a(ownerState);
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(IconButtonRoot, {
    id: loading ? loadingId : idProp,
    className: clsx(classes.root, className),
    centerRipple: true,
    focusRipple: !disableFocusRipple,
    disabled: disabled || loading,
    ref,
    ...other,
    ownerState,
    children: [typeof loading === "boolean" && // use plain HTML span to minimize the runtime overhead
    /* @__PURE__ */ jsxRuntimeExports.jsx("span", {
      className: classes.loadingWrapper,
      style: {
        display: "contents"
      },
      children: /* @__PURE__ */ jsxRuntimeExports.jsx(IconButtonLoadingIndicator, {
        className: classes.loadingIndicator,
        ownerState,
        children: loading && loadingIndicator
      })
    }), children]
  });
});
const SuccessOutlinedIcon = createSvgIcon(/* @__PURE__ */ jsxRuntimeExports.jsx("path", {
  d: "M20,12A8,8 0 0,1 12,20A8,8 0 0,1 4,12A8,8 0 0,1 12,4C12.76,4 13.5,4.11 14.2, 4.31L15.77,2.74C14.61,2.26 13.34,2 12,2A10,10 0 0,0 2,12A10,10 0 0,0 12,22A10,10 0 0, 0 22,12M7.91,10.08L6.5,11.5L11,16L21,6L19.59,4.58L11,13.17L7.91,10.08Z"
}));
const ReportProblemOutlinedIcon = createSvgIcon(/* @__PURE__ */ jsxRuntimeExports.jsx("path", {
  d: "M12 5.99L19.53 19H4.47L12 5.99M12 2L1 21h22L12 2zm1 14h-2v2h2v-2zm0-6h-2v4h2v-4z"
}));
const ErrorOutlineIcon = createSvgIcon(/* @__PURE__ */ jsxRuntimeExports.jsx("path", {
  d: "M11 15h2v2h-2zm0-8h2v6h-2zm.99-5C6.47 2 2 6.48 2 12s4.47 10 9.99 10C17.52 22 22 17.52 22 12S17.52 2 11.99 2zM12 20c-4.42 0-8-3.58-8-8s3.58-8 8-8 8 3.58 8 8-3.58 8-8 8z"
}));
const InfoOutlinedIcon = createSvgIcon(/* @__PURE__ */ jsxRuntimeExports.jsx("path", {
  d: "M11,9H13V7H11M12,20C7.59,20 4,16.41 4,12C4,7.59 7.59,4 12,4C16.41,4 20,7.59 20, 12C20,16.41 16.41,20 12,20M12,2A10,10 0 0,0 2,12A10,10 0 0,0 12,22A10,10 0 0,0 22,12A10, 10 0 0,0 12,2M11,17H13V11H11V17Z"
}));
const ClearIcon = createSvgIcon(/* @__PURE__ */ jsxRuntimeExports.jsx("path", {
  d: "M19 6.41L17.59 5 12 10.59 6.41 5 5 6.41 10.59 12 5 17.59 6.41 19 12 13.41 17.59 19 19 17.59 13.41 12z"
}));
const useUtilityClasses$9 = (ownerState) => {
  const {
    variant,
    color: color2,
    severity,
    classes
  } = ownerState;
  const slots = {
    root: ["root", `color${capitalize(color2 || severity)}`, `${variant}${capitalize(color2 || severity)}`, `${variant}`],
    icon: ["icon"],
    message: ["message"],
    action: ["action"]
  };
  return composeClasses(slots, getAlertUtilityClass, classes);
};
const AlertRoot = styled(Paper, {
  name: "MuiAlert",
  slot: "Root",
  overridesResolver: (props, styles2) => {
    const {
      ownerState
    } = props;
    return [styles2.root, styles2[ownerState.variant], styles2[`${ownerState.variant}${capitalize(ownerState.color || ownerState.severity)}`]];
  }
})(memoTheme(({
  theme
}) => {
  const getColor = theme.palette.mode === "light" ? darken : lighten;
  const getBackgroundColor = theme.palette.mode === "light" ? lighten : darken;
  return {
    ...theme.typography.body2,
    backgroundColor: "transparent",
    display: "flex",
    padding: "6px 16px",
    variants: [...Object.entries(theme.palette).filter(createSimplePaletteValueFilter(["light"])).map(([color2]) => ({
      props: {
        colorSeverity: color2,
        variant: "standard"
      },
      style: {
        color: theme.vars ? theme.vars.palette.Alert[`${color2}Color`] : getColor(theme.palette[color2].light, 0.6),
        backgroundColor: theme.vars ? theme.vars.palette.Alert[`${color2}StandardBg`] : getBackgroundColor(theme.palette[color2].light, 0.9),
        [`& .${alertClasses.icon}`]: theme.vars ? {
          color: theme.vars.palette.Alert[`${color2}IconColor`]
        } : {
          color: theme.palette[color2].main
        }
      }
    })), ...Object.entries(theme.palette).filter(createSimplePaletteValueFilter(["light"])).map(([color2]) => ({
      props: {
        colorSeverity: color2,
        variant: "outlined"
      },
      style: {
        color: theme.vars ? theme.vars.palette.Alert[`${color2}Color`] : getColor(theme.palette[color2].light, 0.6),
        border: `1px solid ${(theme.vars || theme).palette[color2].light}`,
        [`& .${alertClasses.icon}`]: theme.vars ? {
          color: theme.vars.palette.Alert[`${color2}IconColor`]
        } : {
          color: theme.palette[color2].main
        }
      }
    })), ...Object.entries(theme.palette).filter(createSimplePaletteValueFilter(["dark"])).map(([color2]) => ({
      props: {
        colorSeverity: color2,
        variant: "filled"
      },
      style: {
        fontWeight: theme.typography.fontWeightMedium,
        ...theme.vars ? {
          color: theme.vars.palette.Alert[`${color2}FilledColor`],
          backgroundColor: theme.vars.palette.Alert[`${color2}FilledBg`]
        } : {
          backgroundColor: theme.palette.mode === "dark" ? theme.palette[color2].dark : theme.palette[color2].main,
          color: theme.palette.getContrastText(theme.palette[color2].main)
        }
      }
    }))]
  };
}));
const AlertIcon = styled("div", {
  name: "MuiAlert",
  slot: "Icon"
})({
  marginRight: 12,
  padding: "7px 0",
  display: "flex",
  fontSize: 22,
  opacity: 0.9
});
const AlertMessage = styled("div", {
  name: "MuiAlert",
  slot: "Message"
})({
  padding: "8px 0",
  minWidth: 0,
  overflow: "auto"
});
const AlertAction = styled("div", {
  name: "MuiAlert",
  slot: "Action"
})({
  display: "flex",
  alignItems: "flex-start",
  padding: "4px 0 0 16px",
  marginLeft: "auto",
  marginRight: -8
});
const defaultIconMapping = {
  success: /* @__PURE__ */ jsxRuntimeExports.jsx(SuccessOutlinedIcon, {
    fontSize: "inherit"
  }),
  warning: /* @__PURE__ */ jsxRuntimeExports.jsx(ReportProblemOutlinedIcon, {
    fontSize: "inherit"
  }),
  error: /* @__PURE__ */ jsxRuntimeExports.jsx(ErrorOutlineIcon, {
    fontSize: "inherit"
  }),
  info: /* @__PURE__ */ jsxRuntimeExports.jsx(InfoOutlinedIcon, {
    fontSize: "inherit"
  })
};
const Alert = /* @__PURE__ */ reactExports.forwardRef(function Alert2(inProps, ref) {
  const props = useDefaultProps({
    props: inProps,
    name: "MuiAlert"
  });
  const {
    action,
    children,
    className,
    closeText = "Close",
    color: color2,
    components = {},
    componentsProps = {},
    icon,
    iconMapping = defaultIconMapping,
    onClose,
    role = "alert",
    severity = "success",
    slotProps = {},
    slots = {},
    variant = "standard",
    ...other
  } = props;
  const ownerState = {
    ...props,
    color: color2,
    severity,
    variant,
    colorSeverity: color2 || severity
  };
  const classes = useUtilityClasses$9(ownerState);
  const externalForwardedProps = {
    slots: {
      closeButton: components.CloseButton,
      closeIcon: components.CloseIcon,
      ...slots
    },
    slotProps: {
      ...componentsProps,
      ...slotProps
    }
  };
  const [RootSlot, rootSlotProps] = useSlot("root", {
    ref,
    shouldForwardComponentProp: true,
    className: clsx(classes.root, className),
    elementType: AlertRoot,
    externalForwardedProps: {
      ...externalForwardedProps,
      ...other
    },
    ownerState,
    additionalProps: {
      role,
      elevation: 0
    }
  });
  const [IconSlot, iconSlotProps] = useSlot("icon", {
    className: classes.icon,
    elementType: AlertIcon,
    externalForwardedProps,
    ownerState
  });
  const [MessageSlot, messageSlotProps] = useSlot("message", {
    className: classes.message,
    elementType: AlertMessage,
    externalForwardedProps,
    ownerState
  });
  const [ActionSlot, actionSlotProps] = useSlot("action", {
    className: classes.action,
    elementType: AlertAction,
    externalForwardedProps,
    ownerState
  });
  const [CloseButtonSlot, closeButtonProps] = useSlot("closeButton", {
    elementType: IconButton,
    externalForwardedProps,
    ownerState
  });
  const [CloseIconSlot, closeIconProps] = useSlot("closeIcon", {
    elementType: ClearIcon,
    externalForwardedProps,
    ownerState
  });
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(RootSlot, {
    ...rootSlotProps,
    children: [icon !== false ? /* @__PURE__ */ jsxRuntimeExports.jsx(IconSlot, {
      ...iconSlotProps,
      children: icon || iconMapping[severity] || defaultIconMapping[severity]
    }) : null, /* @__PURE__ */ jsxRuntimeExports.jsx(MessageSlot, {
      ...messageSlotProps,
      children
    }), action != null ? /* @__PURE__ */ jsxRuntimeExports.jsx(ActionSlot, {
      ...actionSlotProps,
      children: action
    }) : null, action == null && onClose ? /* @__PURE__ */ jsxRuntimeExports.jsx(ActionSlot, {
      ...actionSlotProps,
      children: /* @__PURE__ */ jsxRuntimeExports.jsx(CloseButtonSlot, {
        size: "small",
        "aria-label": closeText,
        title: closeText,
        color: "inherit",
        onClick: onClose,
        ...closeButtonProps,
        children: /* @__PURE__ */ jsxRuntimeExports.jsx(CloseIconSlot, {
          fontSize: "small",
          ...closeIconProps
        })
      })
    }) : null]
  });
});
function getTypographyUtilityClass(slot) {
  return generateUtilityClass("MuiTypography", slot);
}
generateUtilityClasses("MuiTypography", ["root", "h1", "h2", "h3", "h4", "h5", "h6", "subtitle1", "subtitle2", "body1", "body2", "inherit", "button", "caption", "overline", "alignLeft", "alignRight", "alignCenter", "alignJustify", "noWrap", "gutterBottom", "paragraph"]);
const v6Colors = {
  primary: true,
  secondary: true,
  error: true,
  info: true,
  success: true,
  warning: true,
  textPrimary: true,
  textSecondary: true,
  textDisabled: true
};
const extendSxProp = internal_createExtendSxProp();
const useUtilityClasses$8 = (ownerState) => {
  const {
    align,
    gutterBottom,
    noWrap,
    paragraph,
    variant,
    classes
  } = ownerState;
  const slots = {
    root: ["root", variant, ownerState.align !== "inherit" && `align${capitalize(align)}`, gutterBottom && "gutterBottom", noWrap && "noWrap", paragraph && "paragraph"]
  };
  return composeClasses(slots, getTypographyUtilityClass, classes);
};
const TypographyRoot = styled("span", {
  name: "MuiTypography",
  slot: "Root",
  overridesResolver: (props, styles2) => {
    const {
      ownerState
    } = props;
    return [styles2.root, ownerState.variant && styles2[ownerState.variant], ownerState.align !== "inherit" && styles2[`align${capitalize(ownerState.align)}`], ownerState.noWrap && styles2.noWrap, ownerState.gutterBottom && styles2.gutterBottom, ownerState.paragraph && styles2.paragraph];
  }
})(memoTheme(({
  theme
}) => ({
  margin: 0,
  variants: [{
    props: {
      variant: "inherit"
    },
    style: {
      // Some elements, like <button> on Chrome have default font that doesn't inherit, reset this.
      font: "inherit",
      lineHeight: "inherit",
      letterSpacing: "inherit"
    }
  }, ...Object.entries(theme.typography).filter(([variant, value]) => variant !== "inherit" && value && typeof value === "object").map(([variant, value]) => ({
    props: {
      variant
    },
    style: value
  })), ...Object.entries(theme.palette).filter(createSimplePaletteValueFilter()).map(([color2]) => ({
    props: {
      color: color2
    },
    style: {
      color: (theme.vars || theme).palette[color2].main
    }
  })), ...Object.entries(theme.palette?.text || {}).filter(([, value]) => typeof value === "string").map(([color2]) => ({
    props: {
      color: `text${capitalize(color2)}`
    },
    style: {
      color: (theme.vars || theme).palette.text[color2]
    }
  })), {
    props: ({
      ownerState
    }) => ownerState.align !== "inherit",
    style: {
      textAlign: "var(--Typography-textAlign)"
    }
  }, {
    props: ({
      ownerState
    }) => ownerState.noWrap,
    style: {
      overflow: "hidden",
      textOverflow: "ellipsis",
      whiteSpace: "nowrap"
    }
  }, {
    props: ({
      ownerState
    }) => ownerState.gutterBottom,
    style: {
      marginBottom: "0.35em"
    }
  }, {
    props: ({
      ownerState
    }) => ownerState.paragraph,
    style: {
      marginBottom: 16
    }
  }]
})));
const defaultVariantMapping = {
  h1: "h1",
  h2: "h2",
  h3: "h3",
  h4: "h4",
  h5: "h5",
  h6: "h6",
  subtitle1: "h6",
  subtitle2: "h6",
  body1: "p",
  body2: "p",
  inherit: "p"
};
const Typography = /* @__PURE__ */ reactExports.forwardRef(function Typography2(inProps, ref) {
  const {
    color: color2,
    ...themeProps
  } = useDefaultProps({
    props: inProps,
    name: "MuiTypography"
  });
  const isSxColor = !v6Colors[color2];
  const props = extendSxProp({
    ...themeProps,
    ...isSxColor && {
      color: color2
    }
  });
  const {
    align = "inherit",
    className,
    component,
    gutterBottom = false,
    noWrap = false,
    paragraph = false,
    variant = "body1",
    variantMapping = defaultVariantMapping,
    ...other
  } = props;
  const ownerState = {
    ...props,
    align,
    color: color2,
    className,
    component,
    gutterBottom,
    noWrap,
    paragraph,
    variant,
    variantMapping
  };
  const Component = component || (paragraph ? "p" : variantMapping[variant] || defaultVariantMapping[variant]) || "span";
  const classes = useUtilityClasses$8(ownerState);
  return /* @__PURE__ */ jsxRuntimeExports.jsx(TypographyRoot, {
    as: Component,
    ref,
    className: clsx(classes.root, className),
    ...other,
    ownerState,
    style: {
      ...align !== "inherit" && {
        "--Typography-textAlign": align
      },
      ...other.style
    }
  });
});
function getReactElementRef(element) {
  if (parseInt(reactExports.version, 10) >= 19) {
    return element?.props?.ref || null;
  }
  return element?.ref || null;
}
const boxClasses = generateUtilityClasses("MuiBox", ["root"]);
const defaultTheme = createTheme();
const Box = createBox({
  themeId: THEME_ID,
  defaultTheme,
  defaultClassName: boxClasses.root,
  generateClassName: ClassNameGenerator.generate
});
function getButtonUtilityClass(slot) {
  return generateUtilityClass("MuiButton", slot);
}
const buttonClasses = generateUtilityClasses("MuiButton", ["root", "text", "textInherit", "textPrimary", "textSecondary", "textSuccess", "textError", "textInfo", "textWarning", "outlined", "outlinedInherit", "outlinedPrimary", "outlinedSecondary", "outlinedSuccess", "outlinedError", "outlinedInfo", "outlinedWarning", "contained", "containedInherit", "containedPrimary", "containedSecondary", "containedSuccess", "containedError", "containedInfo", "containedWarning", "disableElevation", "focusVisible", "disabled", "colorInherit", "colorPrimary", "colorSecondary", "colorSuccess", "colorError", "colorInfo", "colorWarning", "textSizeSmall", "textSizeMedium", "textSizeLarge", "outlinedSizeSmall", "outlinedSizeMedium", "outlinedSizeLarge", "containedSizeSmall", "containedSizeMedium", "containedSizeLarge", "sizeMedium", "sizeSmall", "sizeLarge", "fullWidth", "startIcon", "endIcon", "icon", "iconSizeSmall", "iconSizeMedium", "iconSizeLarge", "loading", "loadingWrapper", "loadingIconPlaceholder", "loadingIndicator", "loadingPositionCenter", "loadingPositionStart", "loadingPositionEnd"]);
const ButtonGroupContext = /* @__PURE__ */ reactExports.createContext({});
const ButtonGroupButtonContext = /* @__PURE__ */ reactExports.createContext(void 0);
const useUtilityClasses$7 = (ownerState) => {
  const {
    color: color2,
    disableElevation,
    fullWidth,
    size: size2,
    variant,
    loading,
    loadingPosition,
    classes
  } = ownerState;
  const slots = {
    root: ["root", loading && "loading", variant, `${variant}${capitalize(color2)}`, `size${capitalize(size2)}`, `${variant}Size${capitalize(size2)}`, `color${capitalize(color2)}`, disableElevation && "disableElevation", fullWidth && "fullWidth", loading && `loadingPosition${capitalize(loadingPosition)}`],
    startIcon: ["icon", "startIcon", `iconSize${capitalize(size2)}`],
    endIcon: ["icon", "endIcon", `iconSize${capitalize(size2)}`],
    loadingIndicator: ["loadingIndicator"],
    loadingWrapper: ["loadingWrapper"]
  };
  const composedClasses = composeClasses(slots, getButtonUtilityClass, classes);
  return {
    ...classes,
    // forward the focused, disabled, etc. classes to the ButtonBase
    ...composedClasses
  };
};
const commonIconStyles = [{
  props: {
    size: "small"
  },
  style: {
    "& > *:nth-of-type(1)": {
      fontSize: 18
    }
  }
}, {
  props: {
    size: "medium"
  },
  style: {
    "& > *:nth-of-type(1)": {
      fontSize: 20
    }
  }
}, {
  props: {
    size: "large"
  },
  style: {
    "& > *:nth-of-type(1)": {
      fontSize: 22
    }
  }
}];
const ButtonRoot = styled(ButtonBase, {
  shouldForwardProp: (prop) => rootShouldForwardProp(prop) || prop === "classes",
  name: "MuiButton",
  slot: "Root",
  overridesResolver: (props, styles2) => {
    const {
      ownerState
    } = props;
    return [styles2.root, styles2[ownerState.variant], styles2[`${ownerState.variant}${capitalize(ownerState.color)}`], styles2[`size${capitalize(ownerState.size)}`], styles2[`${ownerState.variant}Size${capitalize(ownerState.size)}`], ownerState.color === "inherit" && styles2.colorInherit, ownerState.disableElevation && styles2.disableElevation, ownerState.fullWidth && styles2.fullWidth, ownerState.loading && styles2.loading];
  }
})(memoTheme(({
  theme
}) => {
  const inheritContainedBackgroundColor = theme.palette.mode === "light" ? theme.palette.grey[300] : theme.palette.grey[800];
  const inheritContainedHoverBackgroundColor = theme.palette.mode === "light" ? theme.palette.grey.A100 : theme.palette.grey[700];
  return {
    ...theme.typography.button,
    minWidth: 64,
    padding: "6px 16px",
    border: 0,
    borderRadius: (theme.vars || theme).shape.borderRadius,
    transition: theme.transitions.create(["background-color", "box-shadow", "border-color", "color"], {
      duration: theme.transitions.duration.short
    }),
    "&:hover": {
      textDecoration: "none"
    },
    [`&.${buttonClasses.disabled}`]: {
      color: (theme.vars || theme).palette.action.disabled
    },
    variants: [{
      props: {
        variant: "contained"
      },
      style: {
        color: `var(--variant-containedColor)`,
        backgroundColor: `var(--variant-containedBg)`,
        boxShadow: (theme.vars || theme).shadows[2],
        "&:hover": {
          boxShadow: (theme.vars || theme).shadows[4],
          // Reset on touch devices, it doesn't add specificity
          "@media (hover: none)": {
            boxShadow: (theme.vars || theme).shadows[2]
          }
        },
        "&:active": {
          boxShadow: (theme.vars || theme).shadows[8]
        },
        [`&.${buttonClasses.focusVisible}`]: {
          boxShadow: (theme.vars || theme).shadows[6]
        },
        [`&.${buttonClasses.disabled}`]: {
          color: (theme.vars || theme).palette.action.disabled,
          boxShadow: (theme.vars || theme).shadows[0],
          backgroundColor: (theme.vars || theme).palette.action.disabledBackground
        }
      }
    }, {
      props: {
        variant: "outlined"
      },
      style: {
        padding: "5px 15px",
        border: "1px solid currentColor",
        borderColor: `var(--variant-outlinedBorder, currentColor)`,
        backgroundColor: `var(--variant-outlinedBg)`,
        color: `var(--variant-outlinedColor)`,
        [`&.${buttonClasses.disabled}`]: {
          border: `1px solid ${(theme.vars || theme).palette.action.disabledBackground}`
        }
      }
    }, {
      props: {
        variant: "text"
      },
      style: {
        padding: "6px 8px",
        color: `var(--variant-textColor)`,
        backgroundColor: `var(--variant-textBg)`
      }
    }, ...Object.entries(theme.palette).filter(createSimplePaletteValueFilter()).map(([color2]) => ({
      props: {
        color: color2
      },
      style: {
        "--variant-textColor": (theme.vars || theme).palette[color2].main,
        "--variant-outlinedColor": (theme.vars || theme).palette[color2].main,
        "--variant-outlinedBorder": theme.vars ? `rgba(${theme.vars.palette[color2].mainChannel} / 0.5)` : alpha(theme.palette[color2].main, 0.5),
        "--variant-containedColor": (theme.vars || theme).palette[color2].contrastText,
        "--variant-containedBg": (theme.vars || theme).palette[color2].main,
        "@media (hover: hover)": {
          "&:hover": {
            "--variant-containedBg": (theme.vars || theme).palette[color2].dark,
            "--variant-textBg": theme.vars ? `rgba(${theme.vars.palette[color2].mainChannel} / ${theme.vars.palette.action.hoverOpacity})` : alpha(theme.palette[color2].main, theme.palette.action.hoverOpacity),
            "--variant-outlinedBorder": (theme.vars || theme).palette[color2].main,
            "--variant-outlinedBg": theme.vars ? `rgba(${theme.vars.palette[color2].mainChannel} / ${theme.vars.palette.action.hoverOpacity})` : alpha(theme.palette[color2].main, theme.palette.action.hoverOpacity)
          }
        }
      }
    })), {
      props: {
        color: "inherit"
      },
      style: {
        color: "inherit",
        borderColor: "currentColor",
        "--variant-containedBg": theme.vars ? theme.vars.palette.Button.inheritContainedBg : inheritContainedBackgroundColor,
        "@media (hover: hover)": {
          "&:hover": {
            "--variant-containedBg": theme.vars ? theme.vars.palette.Button.inheritContainedHoverBg : inheritContainedHoverBackgroundColor,
            "--variant-textBg": theme.vars ? `rgba(${theme.vars.palette.text.primaryChannel} / ${theme.vars.palette.action.hoverOpacity})` : alpha(theme.palette.text.primary, theme.palette.action.hoverOpacity),
            "--variant-outlinedBg": theme.vars ? `rgba(${theme.vars.palette.text.primaryChannel} / ${theme.vars.palette.action.hoverOpacity})` : alpha(theme.palette.text.primary, theme.palette.action.hoverOpacity)
          }
        }
      }
    }, {
      props: {
        size: "small",
        variant: "text"
      },
      style: {
        padding: "4px 5px",
        fontSize: theme.typography.pxToRem(13)
      }
    }, {
      props: {
        size: "large",
        variant: "text"
      },
      style: {
        padding: "8px 11px",
        fontSize: theme.typography.pxToRem(15)
      }
    }, {
      props: {
        size: "small",
        variant: "outlined"
      },
      style: {
        padding: "3px 9px",
        fontSize: theme.typography.pxToRem(13)
      }
    }, {
      props: {
        size: "large",
        variant: "outlined"
      },
      style: {
        padding: "7px 21px",
        fontSize: theme.typography.pxToRem(15)
      }
    }, {
      props: {
        size: "small",
        variant: "contained"
      },
      style: {
        padding: "4px 10px",
        fontSize: theme.typography.pxToRem(13)
      }
    }, {
      props: {
        size: "large",
        variant: "contained"
      },
      style: {
        padding: "8px 22px",
        fontSize: theme.typography.pxToRem(15)
      }
    }, {
      props: {
        disableElevation: true
      },
      style: {
        boxShadow: "none",
        "&:hover": {
          boxShadow: "none"
        },
        [`&.${buttonClasses.focusVisible}`]: {
          boxShadow: "none"
        },
        "&:active": {
          boxShadow: "none"
        },
        [`&.${buttonClasses.disabled}`]: {
          boxShadow: "none"
        }
      }
    }, {
      props: {
        fullWidth: true
      },
      style: {
        width: "100%"
      }
    }, {
      props: {
        loadingPosition: "center"
      },
      style: {
        transition: theme.transitions.create(["background-color", "box-shadow", "border-color"], {
          duration: theme.transitions.duration.short
        }),
        [`&.${buttonClasses.loading}`]: {
          color: "transparent"
        }
      }
    }]
  };
}));
const ButtonStartIcon = styled("span", {
  name: "MuiButton",
  slot: "StartIcon",
  overridesResolver: (props, styles2) => {
    const {
      ownerState
    } = props;
    return [styles2.startIcon, ownerState.loading && styles2.startIconLoadingStart, styles2[`iconSize${capitalize(ownerState.size)}`]];
  }
})(({
  theme
}) => ({
  display: "inherit",
  marginRight: 8,
  marginLeft: -4,
  variants: [{
    props: {
      size: "small"
    },
    style: {
      marginLeft: -2
    }
  }, {
    props: {
      loadingPosition: "start",
      loading: true
    },
    style: {
      transition: theme.transitions.create(["opacity"], {
        duration: theme.transitions.duration.short
      }),
      opacity: 0
    }
  }, {
    props: {
      loadingPosition: "start",
      loading: true,
      fullWidth: true
    },
    style: {
      marginRight: -8
    }
  }, ...commonIconStyles]
}));
const ButtonEndIcon = styled("span", {
  name: "MuiButton",
  slot: "EndIcon",
  overridesResolver: (props, styles2) => {
    const {
      ownerState
    } = props;
    return [styles2.endIcon, ownerState.loading && styles2.endIconLoadingEnd, styles2[`iconSize${capitalize(ownerState.size)}`]];
  }
})(({
  theme
}) => ({
  display: "inherit",
  marginRight: -4,
  marginLeft: 8,
  variants: [{
    props: {
      size: "small"
    },
    style: {
      marginRight: -2
    }
  }, {
    props: {
      loadingPosition: "end",
      loading: true
    },
    style: {
      transition: theme.transitions.create(["opacity"], {
        duration: theme.transitions.duration.short
      }),
      opacity: 0
    }
  }, {
    props: {
      loadingPosition: "end",
      loading: true,
      fullWidth: true
    },
    style: {
      marginLeft: -8
    }
  }, ...commonIconStyles]
}));
const ButtonLoadingIndicator = styled("span", {
  name: "MuiButton",
  slot: "LoadingIndicator"
})(({
  theme
}) => ({
  display: "none",
  position: "absolute",
  visibility: "visible",
  variants: [{
    props: {
      loading: true
    },
    style: {
      display: "flex"
    }
  }, {
    props: {
      loadingPosition: "start"
    },
    style: {
      left: 14
    }
  }, {
    props: {
      loadingPosition: "start",
      size: "small"
    },
    style: {
      left: 10
    }
  }, {
    props: {
      variant: "text",
      loadingPosition: "start"
    },
    style: {
      left: 6
    }
  }, {
    props: {
      loadingPosition: "center"
    },
    style: {
      left: "50%",
      transform: "translate(-50%)",
      color: (theme.vars || theme).palette.action.disabled
    }
  }, {
    props: {
      loadingPosition: "end"
    },
    style: {
      right: 14
    }
  }, {
    props: {
      loadingPosition: "end",
      size: "small"
    },
    style: {
      right: 10
    }
  }, {
    props: {
      variant: "text",
      loadingPosition: "end"
    },
    style: {
      right: 6
    }
  }, {
    props: {
      loadingPosition: "start",
      fullWidth: true
    },
    style: {
      position: "relative",
      left: -10
    }
  }, {
    props: {
      loadingPosition: "end",
      fullWidth: true
    },
    style: {
      position: "relative",
      right: -10
    }
  }]
}));
const ButtonLoadingIconPlaceholder = styled("span", {
  name: "MuiButton",
  slot: "LoadingIconPlaceholder"
})({
  display: "inline-block",
  width: "1em",
  height: "1em"
});
const Button = /* @__PURE__ */ reactExports.forwardRef(function Button2(inProps, ref) {
  const contextProps = reactExports.useContext(ButtonGroupContext);
  const buttonGroupButtonContextPositionClassName = reactExports.useContext(ButtonGroupButtonContext);
  const resolvedProps = resolveProps(contextProps, inProps);
  const props = useDefaultProps({
    props: resolvedProps,
    name: "MuiButton"
  });
  const {
    children,
    color: color2 = "primary",
    component = "button",
    className,
    disabled = false,
    disableElevation = false,
    disableFocusRipple = false,
    endIcon: endIconProp,
    focusVisibleClassName,
    fullWidth = false,
    id: idProp,
    loading = null,
    loadingIndicator: loadingIndicatorProp,
    loadingPosition = "center",
    size: size2 = "medium",
    startIcon: startIconProp,
    type,
    variant = "text",
    ...other
  } = props;
  const loadingId = useId(idProp);
  const loadingIndicator = loadingIndicatorProp ?? /* @__PURE__ */ jsxRuntimeExports.jsx(CircularProgress, {
    "aria-labelledby": loadingId,
    color: "inherit",
    size: 16
  });
  const ownerState = {
    ...props,
    color: color2,
    component,
    disabled,
    disableElevation,
    disableFocusRipple,
    fullWidth,
    loading,
    loadingIndicator,
    loadingPosition,
    size: size2,
    type,
    variant
  };
  const classes = useUtilityClasses$7(ownerState);
  const startIcon = (startIconProp || loading && loadingPosition === "start") && /* @__PURE__ */ jsxRuntimeExports.jsx(ButtonStartIcon, {
    className: classes.startIcon,
    ownerState,
    children: startIconProp || /* @__PURE__ */ jsxRuntimeExports.jsx(ButtonLoadingIconPlaceholder, {
      className: classes.loadingIconPlaceholder,
      ownerState
    })
  });
  const endIcon = (endIconProp || loading && loadingPosition === "end") && /* @__PURE__ */ jsxRuntimeExports.jsx(ButtonEndIcon, {
    className: classes.endIcon,
    ownerState,
    children: endIconProp || /* @__PURE__ */ jsxRuntimeExports.jsx(ButtonLoadingIconPlaceholder, {
      className: classes.loadingIconPlaceholder,
      ownerState
    })
  });
  const positionClassName = buttonGroupButtonContextPositionClassName || "";
  const loader = typeof loading === "boolean" ? (
    // use plain HTML span to minimize the runtime overhead
    /* @__PURE__ */ jsxRuntimeExports.jsx("span", {
      className: classes.loadingWrapper,
      style: {
        display: "contents"
      },
      children: loading && /* @__PURE__ */ jsxRuntimeExports.jsx(ButtonLoadingIndicator, {
        className: classes.loadingIndicator,
        ownerState,
        children: loadingIndicator
      })
    })
  ) : null;
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(ButtonRoot, {
    ownerState,
    className: clsx(contextProps.className, classes.root, className, positionClassName),
    component,
    disabled: disabled || loading,
    focusRipple: !disableFocusRipple,
    focusVisibleClassName: clsx(classes.focusVisible, focusVisibleClassName),
    ref,
    type,
    id: loading ? loadingId : idProp,
    ...other,
    classes,
    children: [startIcon, loadingPosition !== "end" && loader, children, loadingPosition === "end" && loader, endIcon]
  });
});
function mapEventPropToEvent(eventProp) {
  return eventProp.substring(2).toLowerCase();
}
function clickedRootScrollbar(event, doc2) {
  return doc2.documentElement.clientWidth < event.clientX || doc2.documentElement.clientHeight < event.clientY;
}
function ClickAwayListener(props) {
  const {
    children,
    disableReactTree = false,
    mouseEvent = "onClick",
    onClickAway,
    touchEvent = "onTouchEnd"
  } = props;
  const movedRef = reactExports.useRef(false);
  const nodeRef = reactExports.useRef(null);
  const activatedRef = reactExports.useRef(false);
  const syntheticEventRef = reactExports.useRef(false);
  reactExports.useEffect(() => {
    setTimeout(() => {
      activatedRef.current = true;
    }, 0);
    return () => {
      activatedRef.current = false;
    };
  }, []);
  const handleRef = useForkRef(getReactElementRef(children), nodeRef);
  const handleClickAway = useEventCallback((event) => {
    const insideReactTree = syntheticEventRef.current;
    syntheticEventRef.current = false;
    const doc2 = ownerDocument(nodeRef.current);
    if (!activatedRef.current || !nodeRef.current || "clientX" in event && clickedRootScrollbar(event, doc2)) {
      return;
    }
    if (movedRef.current) {
      movedRef.current = false;
      return;
    }
    let insideDOM;
    if (event.composedPath) {
      insideDOM = event.composedPath().includes(nodeRef.current);
    } else {
      insideDOM = !doc2.documentElement.contains(
        // @ts-expect-error returns `false` as intended when not dispatched from a Node
        event.target
      ) || nodeRef.current.contains(
        // @ts-expect-error returns `false` as intended when not dispatched from a Node
        event.target
      );
    }
    if (!insideDOM && (disableReactTree || !insideReactTree)) {
      onClickAway(event);
    }
  });
  const createHandleSynthetic = (handlerName) => (event) => {
    syntheticEventRef.current = true;
    const childrenPropsHandler = children.props[handlerName];
    if (childrenPropsHandler) {
      childrenPropsHandler(event);
    }
  };
  const childrenProps = {
    ref: handleRef
  };
  if (touchEvent !== false) {
    childrenProps[touchEvent] = createHandleSynthetic(touchEvent);
  }
  reactExports.useEffect(() => {
    if (touchEvent !== false) {
      const mappedTouchEvent = mapEventPropToEvent(touchEvent);
      const doc2 = ownerDocument(nodeRef.current);
      const handleTouchMove = () => {
        movedRef.current = true;
      };
      doc2.addEventListener(mappedTouchEvent, handleClickAway);
      doc2.addEventListener("touchmove", handleTouchMove);
      return () => {
        doc2.removeEventListener(mappedTouchEvent, handleClickAway);
        doc2.removeEventListener("touchmove", handleTouchMove);
      };
    }
    return void 0;
  }, [handleClickAway, touchEvent]);
  if (mouseEvent !== false) {
    childrenProps[mouseEvent] = createHandleSynthetic(mouseEvent);
  }
  reactExports.useEffect(() => {
    if (mouseEvent !== false) {
      const mappedMouseEvent = mapEventPropToEvent(mouseEvent);
      const doc2 = ownerDocument(nodeRef.current);
      doc2.addEventListener(mappedMouseEvent, handleClickAway);
      return () => {
        doc2.removeEventListener(mappedMouseEvent, handleClickAway);
      };
    }
    return void 0;
  }, [handleClickAway, mouseEvent]);
  return /* @__PURE__ */ reactExports.cloneElement(children, childrenProps);
}
const Container = createContainer({
  createStyledComponent: styled("div", {
    name: "MuiContainer",
    slot: "Root",
    overridesResolver: (props, styles2) => {
      const {
        ownerState
      } = props;
      return [styles2.root, styles2[`maxWidth${capitalize(String(ownerState.maxWidth))}`], ownerState.fixed && styles2.fixed, ownerState.disableGutters && styles2.disableGutters];
    }
  }),
  useThemeProps: (inProps) => useDefaultProps({
    props: inProps,
    name: "MuiContainer"
  })
});
function getScale(value) {
  return `scale(${value}, ${value ** 2})`;
}
const styles = {
  entering: {
    opacity: 1,
    transform: getScale(1)
  },
  entered: {
    opacity: 1,
    transform: "none"
  }
};
const isWebKit154 = typeof navigator !== "undefined" && /^((?!chrome|android).)*(safari|mobile)/i.test(navigator.userAgent) && /(os |version\/)15(.|_)4/i.test(navigator.userAgent);
const Grow = /* @__PURE__ */ reactExports.forwardRef(function Grow2(props, ref) {
  const {
    addEndListener,
    appear = true,
    children,
    easing: easing2,
    in: inProp,
    onEnter,
    onEntered,
    onEntering,
    onExit,
    onExited,
    onExiting,
    style: style2,
    timeout = "auto",
    // eslint-disable-next-line react/prop-types
    TransitionComponent = Transition,
    ...other
  } = props;
  const timer = useTimeout();
  const autoTimeout = reactExports.useRef();
  const theme = useTheme();
  const nodeRef = reactExports.useRef(null);
  const handleRef = useForkRef(nodeRef, getReactElementRef(children), ref);
  const normalizedTransitionCallback = (callback) => (maybeIsAppearing) => {
    if (callback) {
      const node2 = nodeRef.current;
      if (maybeIsAppearing === void 0) {
        callback(node2);
      } else {
        callback(node2, maybeIsAppearing);
      }
    }
  };
  const handleEntering = normalizedTransitionCallback(onEntering);
  const handleEnter = normalizedTransitionCallback((node2, isAppearing) => {
    reflow(node2);
    const {
      duration: transitionDuration,
      delay: delay2,
      easing: transitionTimingFunction
    } = getTransitionProps({
      style: style2,
      timeout,
      easing: easing2
    }, {
      mode: "enter"
    });
    let duration2;
    if (timeout === "auto") {
      duration2 = theme.transitions.getAutoHeightDuration(node2.clientHeight);
      autoTimeout.current = duration2;
    } else {
      duration2 = transitionDuration;
    }
    node2.style.transition = [theme.transitions.create("opacity", {
      duration: duration2,
      delay: delay2
    }), theme.transitions.create("transform", {
      duration: isWebKit154 ? duration2 : duration2 * 0.666,
      delay: delay2,
      easing: transitionTimingFunction
    })].join(",");
    if (onEnter) {
      onEnter(node2, isAppearing);
    }
  });
  const handleEntered = normalizedTransitionCallback(onEntered);
  const handleExiting = normalizedTransitionCallback(onExiting);
  const handleExit = normalizedTransitionCallback((node2) => {
    const {
      duration: transitionDuration,
      delay: delay2,
      easing: transitionTimingFunction
    } = getTransitionProps({
      style: style2,
      timeout,
      easing: easing2
    }, {
      mode: "exit"
    });
    let duration2;
    if (timeout === "auto") {
      duration2 = theme.transitions.getAutoHeightDuration(node2.clientHeight);
      autoTimeout.current = duration2;
    } else {
      duration2 = transitionDuration;
    }
    node2.style.transition = [theme.transitions.create("opacity", {
      duration: duration2,
      delay: delay2
    }), theme.transitions.create("transform", {
      duration: isWebKit154 ? duration2 : duration2 * 0.666,
      delay: isWebKit154 ? delay2 : delay2 || duration2 * 0.333,
      easing: transitionTimingFunction
    })].join(",");
    node2.style.opacity = 0;
    node2.style.transform = getScale(0.75);
    if (onExit) {
      onExit(node2);
    }
  });
  const handleExited = normalizedTransitionCallback(onExited);
  const handleAddEndListener = (next2) => {
    if (timeout === "auto") {
      timer.start(autoTimeout.current || 0, next2);
    }
    if (addEndListener) {
      addEndListener(nodeRef.current, next2);
    }
  };
  return /* @__PURE__ */ jsxRuntimeExports.jsx(TransitionComponent, {
    appear,
    in: inProp,
    nodeRef,
    onEnter: handleEnter,
    onEntered: handleEntered,
    onEntering: handleEntering,
    onExit: handleExit,
    onExited: handleExited,
    onExiting: handleExiting,
    addEndListener: handleAddEndListener,
    timeout: timeout === "auto" ? null : timeout,
    ...other,
    children: (state, {
      ownerState,
      ...restChildProps
    }) => {
      return /* @__PURE__ */ reactExports.cloneElement(children, {
        style: {
          opacity: 0,
          transform: getScale(0.75),
          visibility: state === "exited" && !inProp ? "hidden" : void 0,
          ...styles[state],
          ...style2,
          ...children.props.style
        },
        ref: handleRef,
        ...restChildProps
      });
    }
  });
});
if (Grow) {
  Grow.muiSupportAuto = true;
}
function useSnackbar(parameters = {}) {
  const {
    autoHideDuration = null,
    disableWindowBlurListener = false,
    onClose,
    open,
    resumeHideDuration
  } = parameters;
  const timerAutoHide = useTimeout();
  reactExports.useEffect(() => {
    if (!open) {
      return void 0;
    }
    function handleKeyDown(nativeEvent) {
      if (!nativeEvent.defaultPrevented) {
        if (nativeEvent.key === "Escape") {
          onClose?.(nativeEvent, "escapeKeyDown");
        }
      }
    }
    document.addEventListener("keydown", handleKeyDown);
    return () => {
      document.removeEventListener("keydown", handleKeyDown);
    };
  }, [open, onClose]);
  const handleClose = useEventCallback((event, reason) => {
    onClose?.(event, reason);
  });
  const setAutoHideTimer = useEventCallback((autoHideDurationParam) => {
    if (!onClose || autoHideDurationParam == null) {
      return;
    }
    timerAutoHide.start(autoHideDurationParam, () => {
      handleClose(null, "timeout");
    });
  });
  reactExports.useEffect(() => {
    if (open) {
      setAutoHideTimer(autoHideDuration);
    }
    return timerAutoHide.clear;
  }, [open, autoHideDuration, setAutoHideTimer, timerAutoHide]);
  const handleClickAway = (event) => {
    onClose?.(event, "clickaway");
  };
  const handlePause = timerAutoHide.clear;
  const handleResume = reactExports.useCallback(() => {
    if (autoHideDuration != null) {
      setAutoHideTimer(resumeHideDuration != null ? resumeHideDuration : autoHideDuration * 0.5);
    }
  }, [autoHideDuration, resumeHideDuration, setAutoHideTimer]);
  const createHandleBlur = (otherHandlers) => (event) => {
    const onBlurCallback = otherHandlers.onBlur;
    onBlurCallback?.(event);
    handleResume();
  };
  const createHandleFocus = (otherHandlers) => (event) => {
    const onFocusCallback = otherHandlers.onFocus;
    onFocusCallback?.(event);
    handlePause();
  };
  const createMouseEnter = (otherHandlers) => (event) => {
    const onMouseEnterCallback = otherHandlers.onMouseEnter;
    onMouseEnterCallback?.(event);
    handlePause();
  };
  const createMouseLeave = (otherHandlers) => (event) => {
    const onMouseLeaveCallback = otherHandlers.onMouseLeave;
    onMouseLeaveCallback?.(event);
    handleResume();
  };
  reactExports.useEffect(() => {
    if (!disableWindowBlurListener && open) {
      window.addEventListener("focus", handleResume);
      window.addEventListener("blur", handlePause);
      return () => {
        window.removeEventListener("focus", handleResume);
        window.removeEventListener("blur", handlePause);
      };
    }
    return void 0;
  }, [disableWindowBlurListener, open, handleResume, handlePause]);
  const getRootProps = (externalProps = {}) => {
    const externalEventHandlers = {
      ...extractEventHandlers(parameters),
      ...extractEventHandlers(externalProps)
    };
    return {
      // ClickAwayListener adds an `onClick` prop which results in the alert not being announced.
      // See https://github.com/mui/material-ui/issues/29080
      role: "presentation",
      ...externalProps,
      ...externalEventHandlers,
      onBlur: createHandleBlur(externalEventHandlers),
      onFocus: createHandleFocus(externalEventHandlers),
      onMouseEnter: createMouseEnter(externalEventHandlers),
      onMouseLeave: createMouseLeave(externalEventHandlers)
    };
  };
  return {
    getRootProps,
    onClickAway: handleClickAway
  };
}
function getSnackbarContentUtilityClass(slot) {
  return generateUtilityClass("MuiSnackbarContent", slot);
}
generateUtilityClasses("MuiSnackbarContent", ["root", "message", "action"]);
const useUtilityClasses$6 = (ownerState) => {
  const {
    classes
  } = ownerState;
  const slots = {
    root: ["root"],
    action: ["action"],
    message: ["message"]
  };
  return composeClasses(slots, getSnackbarContentUtilityClass, classes);
};
const SnackbarContentRoot = styled(Paper, {
  name: "MuiSnackbarContent",
  slot: "Root"
})(memoTheme(({
  theme
}) => {
  const emphasis = theme.palette.mode === "light" ? 0.8 : 0.98;
  return {
    ...theme.typography.body2,
    color: theme.vars ? theme.vars.palette.SnackbarContent.color : theme.palette.getContrastText(emphasize(theme.palette.background.default, emphasis)),
    backgroundColor: theme.vars ? theme.vars.palette.SnackbarContent.bg : emphasize(theme.palette.background.default, emphasis),
    display: "flex",
    alignItems: "center",
    flexWrap: "wrap",
    padding: "6px 16px",
    flexGrow: 1,
    [theme.breakpoints.up("sm")]: {
      flexGrow: "initial",
      minWidth: 288
    }
  };
}));
const SnackbarContentMessage = styled("div", {
  name: "MuiSnackbarContent",
  slot: "Message"
})({
  padding: "8px 0"
});
const SnackbarContentAction = styled("div", {
  name: "MuiSnackbarContent",
  slot: "Action"
})({
  display: "flex",
  alignItems: "center",
  marginLeft: "auto",
  paddingLeft: 16,
  marginRight: -8
});
const SnackbarContent = /* @__PURE__ */ reactExports.forwardRef(function SnackbarContent2(inProps, ref) {
  const props = useDefaultProps({
    props: inProps,
    name: "MuiSnackbarContent"
  });
  const {
    action,
    className,
    message,
    role = "alert",
    ...other
  } = props;
  const ownerState = props;
  const classes = useUtilityClasses$6(ownerState);
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(SnackbarContentRoot, {
    role,
    elevation: 6,
    className: clsx(classes.root, className),
    ownerState,
    ref,
    ...other,
    children: [/* @__PURE__ */ jsxRuntimeExports.jsx(SnackbarContentMessage, {
      className: classes.message,
      ownerState,
      children: message
    }), action ? /* @__PURE__ */ jsxRuntimeExports.jsx(SnackbarContentAction, {
      className: classes.action,
      ownerState,
      children: action
    }) : null]
  });
});
function getSnackbarUtilityClass(slot) {
  return generateUtilityClass("MuiSnackbar", slot);
}
generateUtilityClasses("MuiSnackbar", ["root", "anchorOriginTopCenter", "anchorOriginBottomCenter", "anchorOriginTopRight", "anchorOriginBottomRight", "anchorOriginTopLeft", "anchorOriginBottomLeft"]);
const useUtilityClasses$5 = (ownerState) => {
  const {
    classes,
    anchorOrigin
  } = ownerState;
  const slots = {
    root: ["root", `anchorOrigin${capitalize(anchorOrigin.vertical)}${capitalize(anchorOrigin.horizontal)}`]
  };
  return composeClasses(slots, getSnackbarUtilityClass, classes);
};
const SnackbarRoot = styled("div", {
  name: "MuiSnackbar",
  slot: "Root",
  overridesResolver: (props, styles2) => {
    const {
      ownerState
    } = props;
    return [styles2.root, styles2[`anchorOrigin${capitalize(ownerState.anchorOrigin.vertical)}${capitalize(ownerState.anchorOrigin.horizontal)}`]];
  }
})(memoTheme(({
  theme
}) => ({
  zIndex: (theme.vars || theme).zIndex.snackbar,
  position: "fixed",
  display: "flex",
  left: 8,
  right: 8,
  justifyContent: "center",
  alignItems: "center",
  variants: [{
    props: ({
      ownerState
    }) => ownerState.anchorOrigin.vertical === "top",
    style: {
      top: 8,
      [theme.breakpoints.up("sm")]: {
        top: 24
      }
    }
  }, {
    props: ({
      ownerState
    }) => ownerState.anchorOrigin.vertical !== "top",
    style: {
      bottom: 8,
      [theme.breakpoints.up("sm")]: {
        bottom: 24
      }
    }
  }, {
    props: ({
      ownerState
    }) => ownerState.anchorOrigin.horizontal === "left",
    style: {
      justifyContent: "flex-start",
      [theme.breakpoints.up("sm")]: {
        left: 24,
        right: "auto"
      }
    }
  }, {
    props: ({
      ownerState
    }) => ownerState.anchorOrigin.horizontal === "right",
    style: {
      justifyContent: "flex-end",
      [theme.breakpoints.up("sm")]: {
        right: 24,
        left: "auto"
      }
    }
  }, {
    props: ({
      ownerState
    }) => ownerState.anchorOrigin.horizontal === "center",
    style: {
      [theme.breakpoints.up("sm")]: {
        left: "50%",
        right: "auto",
        transform: "translateX(-50%)"
      }
    }
  }]
})));
const Snackbar = /* @__PURE__ */ reactExports.forwardRef(function Snackbar2(inProps, ref) {
  const props = useDefaultProps({
    props: inProps,
    name: "MuiSnackbar"
  });
  const theme = useTheme();
  const defaultTransitionDuration = {
    enter: theme.transitions.duration.enteringScreen,
    exit: theme.transitions.duration.leavingScreen
  };
  const {
    action,
    anchorOrigin: {
      vertical,
      horizontal
    } = {
      vertical: "bottom",
      horizontal: "left"
    },
    autoHideDuration = null,
    children,
    className,
    ClickAwayListenerProps: ClickAwayListenerPropsProp,
    ContentProps: ContentPropsProp,
    disableWindowBlurListener = false,
    message,
    onBlur,
    onClose,
    onFocus,
    onMouseEnter,
    onMouseLeave,
    open,
    resumeHideDuration,
    slots = {},
    slotProps = {},
    TransitionComponent: TransitionComponentProp,
    transitionDuration = defaultTransitionDuration,
    TransitionProps: {
      onEnter,
      onExited,
      ...TransitionPropsProp
    } = {},
    ...other
  } = props;
  const ownerState = {
    ...props,
    anchorOrigin: {
      vertical,
      horizontal
    },
    autoHideDuration,
    disableWindowBlurListener,
    TransitionComponent: TransitionComponentProp,
    transitionDuration
  };
  const classes = useUtilityClasses$5(ownerState);
  const {
    getRootProps,
    onClickAway
  } = useSnackbar({
    ...ownerState
  });
  const [exited, setExited] = reactExports.useState(true);
  const handleExited = (node2) => {
    setExited(true);
    if (onExited) {
      onExited(node2);
    }
  };
  const handleEnter = (node2, isAppearing) => {
    setExited(false);
    if (onEnter) {
      onEnter(node2, isAppearing);
    }
  };
  const externalForwardedProps = {
    slots: {
      transition: TransitionComponentProp,
      ...slots
    },
    slotProps: {
      content: ContentPropsProp,
      clickAwayListener: ClickAwayListenerPropsProp,
      transition: TransitionPropsProp,
      ...slotProps
    }
  };
  const [Root3, rootProps] = useSlot("root", {
    ref,
    className: [classes.root, className],
    elementType: SnackbarRoot,
    getSlotProps: getRootProps,
    externalForwardedProps: {
      ...externalForwardedProps,
      ...other
    },
    ownerState
  });
  const [ClickAwaySlot, {
    ownerState: clickAwayOwnerStateProp,
    ...clickAwayListenerProps
  }] = useSlot("clickAwayListener", {
    elementType: ClickAwayListener,
    externalForwardedProps,
    getSlotProps: (handlers) => ({
      onClickAway: (...params) => {
        const event = params[0];
        handlers.onClickAway?.(...params);
        if (event?.defaultMuiPrevented) {
          return;
        }
        onClickAway(...params);
      }
    }),
    ownerState
  });
  const [ContentSlot, contentSlotProps] = useSlot("content", {
    elementType: SnackbarContent,
    shouldForwardComponentProp: true,
    externalForwardedProps,
    additionalProps: {
      message,
      action
    },
    ownerState
  });
  const [TransitionSlot, transitionProps] = useSlot("transition", {
    elementType: Grow,
    externalForwardedProps,
    getSlotProps: (handlers) => ({
      onEnter: (...params) => {
        handlers.onEnter?.(...params);
        handleEnter(...params);
      },
      onExited: (...params) => {
        handlers.onExited?.(...params);
        handleExited(...params);
      }
    }),
    additionalProps: {
      appear: true,
      in: open,
      timeout: transitionDuration,
      direction: vertical === "top" ? "down" : "up"
    },
    ownerState
  });
  if (!open && exited) {
    return null;
  }
  return /* @__PURE__ */ jsxRuntimeExports.jsx(ClickAwaySlot, {
    ...clickAwayListenerProps,
    ...slots.clickAwayListener && {
      ownerState: clickAwayOwnerStateProp
    },
    children: /* @__PURE__ */ jsxRuntimeExports.jsx(Root3, {
      ...rootProps,
      children: /* @__PURE__ */ jsxRuntimeExports.jsx(TransitionSlot, {
        ...transitionProps,
        children: children || /* @__PURE__ */ jsxRuntimeExports.jsx(ContentSlot, {
          ...contentSlotProps
        })
      })
    })
  });
});
const StepperContext = /* @__PURE__ */ reactExports.createContext({});
const StepContext = /* @__PURE__ */ reactExports.createContext({});
function getStepUtilityClass(slot) {
  return generateUtilityClass("MuiStep", slot);
}
generateUtilityClasses("MuiStep", ["root", "horizontal", "vertical", "alternativeLabel", "completed"]);
const useUtilityClasses$4 = (ownerState) => {
  const {
    classes,
    orientation,
    alternativeLabel,
    completed
  } = ownerState;
  const slots = {
    root: ["root", orientation, alternativeLabel && "alternativeLabel", completed && "completed"]
  };
  return composeClasses(slots, getStepUtilityClass, classes);
};
const StepRoot = styled("div", {
  name: "MuiStep",
  slot: "Root",
  overridesResolver: (props, styles2) => {
    const {
      ownerState
    } = props;
    return [styles2.root, styles2[ownerState.orientation], ownerState.alternativeLabel && styles2.alternativeLabel, ownerState.completed && styles2.completed];
  }
})({
  variants: [{
    props: {
      orientation: "horizontal"
    },
    style: {
      paddingLeft: 8,
      paddingRight: 8
    }
  }, {
    props: {
      alternativeLabel: true
    },
    style: {
      flex: 1,
      position: "relative"
    }
  }]
});
const Step = /* @__PURE__ */ reactExports.forwardRef(function Step2(inProps, ref) {
  const props = useDefaultProps({
    props: inProps,
    name: "MuiStep"
  });
  const {
    active: activeProp,
    children,
    className,
    component = "div",
    completed: completedProp,
    disabled: disabledProp,
    expanded = false,
    index: index2,
    last,
    ...other
  } = props;
  const {
    activeStep,
    connector,
    alternativeLabel,
    orientation,
    nonLinear
  } = reactExports.useContext(StepperContext);
  let [active = false, completed = false, disabled = false] = [activeProp, completedProp, disabledProp];
  if (activeStep === index2) {
    active = activeProp !== void 0 ? activeProp : true;
  } else if (!nonLinear && activeStep > index2) {
    completed = completedProp !== void 0 ? completedProp : true;
  } else if (!nonLinear && activeStep < index2) {
    disabled = disabledProp !== void 0 ? disabledProp : true;
  }
  const contextValue = reactExports.useMemo(() => ({
    index: index2,
    last,
    expanded,
    icon: index2 + 1,
    active,
    completed,
    disabled
  }), [index2, last, expanded, active, completed, disabled]);
  const ownerState = {
    ...props,
    active,
    orientation,
    alternativeLabel,
    completed,
    disabled,
    expanded,
    component
  };
  const classes = useUtilityClasses$4(ownerState);
  const newChildren = /* @__PURE__ */ jsxRuntimeExports.jsxs(StepRoot, {
    as: component,
    className: clsx(classes.root, className),
    ref,
    ownerState,
    ...other,
    children: [connector && alternativeLabel && index2 !== 0 ? connector : null, children]
  });
  return /* @__PURE__ */ jsxRuntimeExports.jsx(StepContext.Provider, {
    value: contextValue,
    children: connector && !alternativeLabel && index2 !== 0 ? /* @__PURE__ */ jsxRuntimeExports.jsxs(reactExports.Fragment, {
      children: [connector, newChildren]
    }) : newChildren
  });
});
const CheckCircle = createSvgIcon(/* @__PURE__ */ jsxRuntimeExports.jsx("path", {
  d: "M12 0a12 12 0 1 0 0 24 12 12 0 0 0 0-24zm-2 17l-5-5 1.4-1.4 3.6 3.6 7.6-7.6L19 8l-9 9z"
}));
const Warning$1 = createSvgIcon(/* @__PURE__ */ jsxRuntimeExports.jsx("path", {
  d: "M1 21h22L12 2 1 21zm12-3h-2v-2h2v2zm0-4h-2v-4h2v4z"
}));
function getStepIconUtilityClass(slot) {
  return generateUtilityClass("MuiStepIcon", slot);
}
const stepIconClasses = generateUtilityClasses("MuiStepIcon", ["root", "active", "completed", "error", "text"]);
var _circle;
const useUtilityClasses$3 = (ownerState) => {
  const {
    classes,
    active,
    completed,
    error
  } = ownerState;
  const slots = {
    root: ["root", active && "active", completed && "completed", error && "error"],
    text: ["text"]
  };
  return composeClasses(slots, getStepIconUtilityClass, classes);
};
const StepIconRoot = styled(SvgIcon, {
  name: "MuiStepIcon",
  slot: "Root"
})(memoTheme(({
  theme
}) => ({
  display: "block",
  transition: theme.transitions.create("color", {
    duration: theme.transitions.duration.shortest
  }),
  color: (theme.vars || theme).palette.text.disabled,
  [`&.${stepIconClasses.completed}`]: {
    color: (theme.vars || theme).palette.primary.main
  },
  [`&.${stepIconClasses.active}`]: {
    color: (theme.vars || theme).palette.primary.main
  },
  [`&.${stepIconClasses.error}`]: {
    color: (theme.vars || theme).palette.error.main
  }
})));
const StepIconText = styled("text", {
  name: "MuiStepIcon",
  slot: "Text"
})(memoTheme(({
  theme
}) => ({
  fill: (theme.vars || theme).palette.primary.contrastText,
  fontSize: theme.typography.caption.fontSize,
  fontFamily: theme.typography.fontFamily
})));
const StepIcon = /* @__PURE__ */ reactExports.forwardRef(function StepIcon2(inProps, ref) {
  const props = useDefaultProps({
    props: inProps,
    name: "MuiStepIcon"
  });
  const {
    active = false,
    className: classNameProp,
    completed = false,
    error = false,
    icon,
    ...other
  } = props;
  const ownerState = {
    ...props,
    active,
    completed,
    error
  };
  const classes = useUtilityClasses$3(ownerState);
  if (typeof icon === "number" || typeof icon === "string") {
    const className = clsx(classNameProp, classes.root);
    if (error) {
      return /* @__PURE__ */ jsxRuntimeExports.jsx(StepIconRoot, {
        as: Warning$1,
        className,
        ref,
        ownerState,
        ...other
      });
    }
    if (completed) {
      return /* @__PURE__ */ jsxRuntimeExports.jsx(StepIconRoot, {
        as: CheckCircle,
        className,
        ref,
        ownerState,
        ...other
      });
    }
    return /* @__PURE__ */ jsxRuntimeExports.jsxs(StepIconRoot, {
      className,
      ref,
      ownerState,
      ...other,
      children: [_circle || (_circle = /* @__PURE__ */ jsxRuntimeExports.jsx("circle", {
        cx: "12",
        cy: "12",
        r: "12"
      })), /* @__PURE__ */ jsxRuntimeExports.jsx(StepIconText, {
        className: classes.text,
        x: "12",
        y: "12",
        textAnchor: "middle",
        dominantBaseline: "central",
        ownerState,
        children: icon
      })]
    });
  }
  return icon;
});
function getStepLabelUtilityClass(slot) {
  return generateUtilityClass("MuiStepLabel", slot);
}
const stepLabelClasses = generateUtilityClasses("MuiStepLabel", ["root", "horizontal", "vertical", "label", "active", "completed", "error", "disabled", "iconContainer", "alternativeLabel", "labelContainer"]);
const useUtilityClasses$2 = (ownerState) => {
  const {
    classes,
    orientation,
    active,
    completed,
    error,
    disabled,
    alternativeLabel
  } = ownerState;
  const slots = {
    root: ["root", orientation, error && "error", disabled && "disabled", alternativeLabel && "alternativeLabel"],
    label: ["label", active && "active", completed && "completed", error && "error", disabled && "disabled", alternativeLabel && "alternativeLabel"],
    iconContainer: ["iconContainer", active && "active", completed && "completed", error && "error", disabled && "disabled", alternativeLabel && "alternativeLabel"],
    labelContainer: ["labelContainer", alternativeLabel && "alternativeLabel"]
  };
  return composeClasses(slots, getStepLabelUtilityClass, classes);
};
const StepLabelRoot = styled("span", {
  name: "MuiStepLabel",
  slot: "Root",
  overridesResolver: (props, styles2) => {
    const {
      ownerState
    } = props;
    return [styles2.root, styles2[ownerState.orientation]];
  }
})({
  display: "flex",
  alignItems: "center",
  [`&.${stepLabelClasses.alternativeLabel}`]: {
    flexDirection: "column"
  },
  [`&.${stepLabelClasses.disabled}`]: {
    cursor: "default"
  },
  variants: [{
    props: {
      orientation: "vertical"
    },
    style: {
      textAlign: "left",
      padding: "8px 0"
    }
  }]
});
const StepLabelLabel = styled("span", {
  name: "MuiStepLabel",
  slot: "Label"
})(memoTheme(({
  theme
}) => ({
  ...theme.typography.body2,
  display: "block",
  transition: theme.transitions.create("color", {
    duration: theme.transitions.duration.shortest
  }),
  [`&.${stepLabelClasses.active}`]: {
    color: (theme.vars || theme).palette.text.primary,
    fontWeight: 500
  },
  [`&.${stepLabelClasses.completed}`]: {
    color: (theme.vars || theme).palette.text.primary,
    fontWeight: 500
  },
  [`&.${stepLabelClasses.alternativeLabel}`]: {
    marginTop: 16
  },
  [`&.${stepLabelClasses.error}`]: {
    color: (theme.vars || theme).palette.error.main
  }
})));
const StepLabelIconContainer = styled("span", {
  name: "MuiStepLabel",
  slot: "IconContainer"
})({
  flexShrink: 0,
  display: "flex",
  paddingRight: 8,
  [`&.${stepLabelClasses.alternativeLabel}`]: {
    paddingRight: 0
  }
});
const StepLabelLabelContainer = styled("span", {
  name: "MuiStepLabel",
  slot: "LabelContainer"
})(memoTheme(({
  theme
}) => ({
  width: "100%",
  color: (theme.vars || theme).palette.text.secondary,
  [`&.${stepLabelClasses.alternativeLabel}`]: {
    textAlign: "center"
  }
})));
const StepLabel = /* @__PURE__ */ reactExports.forwardRef(function StepLabel2(inProps, ref) {
  const props = useDefaultProps({
    props: inProps,
    name: "MuiStepLabel"
  });
  const {
    children,
    className,
    componentsProps = {},
    error = false,
    icon: iconProp,
    optional,
    slots = {},
    slotProps = {},
    StepIconComponent: StepIconComponentProp,
    StepIconProps,
    ...other
  } = props;
  const {
    alternativeLabel,
    orientation
  } = reactExports.useContext(StepperContext);
  const {
    active,
    disabled,
    completed,
    icon: iconContext
  } = reactExports.useContext(StepContext);
  const icon = iconProp || iconContext;
  let StepIconComponent = StepIconComponentProp;
  if (icon && !StepIconComponent) {
    StepIconComponent = StepIcon;
  }
  const ownerState = {
    ...props,
    active,
    alternativeLabel,
    completed,
    disabled,
    error,
    orientation
  };
  const classes = useUtilityClasses$2(ownerState);
  const externalForwardedProps = {
    slots,
    slotProps: {
      stepIcon: StepIconProps,
      ...componentsProps,
      ...slotProps
    }
  };
  const [RootSlot, rootProps] = useSlot("root", {
    elementType: StepLabelRoot,
    externalForwardedProps: {
      ...externalForwardedProps,
      ...other
    },
    ownerState,
    ref,
    className: clsx(classes.root, className)
  });
  const [LabelSlot, labelProps] = useSlot("label", {
    elementType: StepLabelLabel,
    externalForwardedProps,
    ownerState
  });
  const [StepIconSlot, stepIconProps] = useSlot("stepIcon", {
    elementType: StepIconComponent,
    externalForwardedProps,
    ownerState
  });
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(RootSlot, {
    ...rootProps,
    children: [icon || StepIconSlot ? /* @__PURE__ */ jsxRuntimeExports.jsx(StepLabelIconContainer, {
      className: classes.iconContainer,
      ownerState,
      children: /* @__PURE__ */ jsxRuntimeExports.jsx(StepIconSlot, {
        completed,
        active,
        error,
        icon,
        ...stepIconProps
      })
    }) : null, /* @__PURE__ */ jsxRuntimeExports.jsxs(StepLabelLabelContainer, {
      className: classes.labelContainer,
      ownerState,
      children: [children ? /* @__PURE__ */ jsxRuntimeExports.jsx(LabelSlot, {
        ...labelProps,
        className: clsx(classes.label, labelProps?.className),
        children
      }) : null, optional]
    })]
  });
});
StepLabel.muiName = "StepLabel";
function getStepConnectorUtilityClass(slot) {
  return generateUtilityClass("MuiStepConnector", slot);
}
generateUtilityClasses("MuiStepConnector", ["root", "horizontal", "vertical", "alternativeLabel", "active", "completed", "disabled", "line", "lineHorizontal", "lineVertical"]);
const useUtilityClasses$1 = (ownerState) => {
  const {
    classes,
    orientation,
    alternativeLabel,
    active,
    completed,
    disabled
  } = ownerState;
  const slots = {
    root: ["root", orientation, alternativeLabel && "alternativeLabel", active && "active", completed && "completed", disabled && "disabled"],
    line: ["line", `line${capitalize(orientation)}`]
  };
  return composeClasses(slots, getStepConnectorUtilityClass, classes);
};
const StepConnectorRoot = styled("div", {
  name: "MuiStepConnector",
  slot: "Root",
  overridesResolver: (props, styles2) => {
    const {
      ownerState
    } = props;
    return [styles2.root, styles2[ownerState.orientation], ownerState.alternativeLabel && styles2.alternativeLabel, ownerState.completed && styles2.completed];
  }
})({
  flex: "1 1 auto",
  variants: [{
    props: {
      orientation: "vertical"
    },
    style: {
      marginLeft: 12
      // half icon
    }
  }, {
    props: {
      alternativeLabel: true
    },
    style: {
      position: "absolute",
      top: 8 + 4,
      left: "calc(-50% + 20px)",
      right: "calc(50% + 20px)"
    }
  }]
});
const StepConnectorLine = styled("span", {
  name: "MuiStepConnector",
  slot: "Line",
  overridesResolver: (props, styles2) => {
    const {
      ownerState
    } = props;
    return [styles2.line, styles2[`line${capitalize(ownerState.orientation)}`]];
  }
})(memoTheme(({
  theme
}) => {
  const borderColor2 = theme.palette.mode === "light" ? theme.palette.grey[400] : theme.palette.grey[600];
  return {
    display: "block",
    borderColor: theme.vars ? theme.vars.palette.StepConnector.border : borderColor2,
    variants: [{
      props: {
        orientation: "horizontal"
      },
      style: {
        borderTopStyle: "solid",
        borderTopWidth: 1
      }
    }, {
      props: {
        orientation: "vertical"
      },
      style: {
        borderLeftStyle: "solid",
        borderLeftWidth: 1,
        minHeight: 24
      }
    }]
  };
}));
const StepConnector = /* @__PURE__ */ reactExports.forwardRef(function StepConnector2(inProps, ref) {
  const props = useDefaultProps({
    props: inProps,
    name: "MuiStepConnector"
  });
  const {
    className,
    ...other
  } = props;
  const {
    alternativeLabel,
    orientation = "horizontal"
  } = reactExports.useContext(StepperContext);
  const {
    active,
    disabled,
    completed
  } = reactExports.useContext(StepContext);
  const ownerState = {
    ...props,
    alternativeLabel,
    orientation,
    active,
    completed,
    disabled
  };
  const classes = useUtilityClasses$1(ownerState);
  return /* @__PURE__ */ jsxRuntimeExports.jsx(StepConnectorRoot, {
    className: clsx(classes.root, className),
    ref,
    ownerState,
    ...other,
    children: /* @__PURE__ */ jsxRuntimeExports.jsx(StepConnectorLine, {
      className: classes.line,
      ownerState
    })
  });
});
function getStepperUtilityClass(slot) {
  return generateUtilityClass("MuiStepper", slot);
}
generateUtilityClasses("MuiStepper", ["root", "horizontal", "vertical", "nonLinear", "alternativeLabel"]);
const useUtilityClasses = (ownerState) => {
  const {
    orientation,
    nonLinear,
    alternativeLabel,
    classes
  } = ownerState;
  const slots = {
    root: ["root", orientation, nonLinear && "nonLinear", alternativeLabel && "alternativeLabel"]
  };
  return composeClasses(slots, getStepperUtilityClass, classes);
};
const StepperRoot = styled("div", {
  name: "MuiStepper",
  slot: "Root",
  overridesResolver: (props, styles2) => {
    const {
      ownerState
    } = props;
    return [styles2.root, styles2[ownerState.orientation], ownerState.alternativeLabel && styles2.alternativeLabel, ownerState.nonLinear && styles2.nonLinear];
  }
})({
  display: "flex",
  variants: [{
    props: {
      orientation: "horizontal"
    },
    style: {
      flexDirection: "row",
      alignItems: "center"
    }
  }, {
    props: {
      orientation: "vertical"
    },
    style: {
      flexDirection: "column"
    }
  }, {
    props: {
      alternativeLabel: true
    },
    style: {
      alignItems: "flex-start"
    }
  }]
});
const defaultConnector = /* @__PURE__ */ jsxRuntimeExports.jsx(StepConnector, {});
const Stepper = /* @__PURE__ */ reactExports.forwardRef(function Stepper2(inProps, ref) {
  const props = useDefaultProps({
    props: inProps,
    name: "MuiStepper"
  });
  const {
    activeStep = 0,
    alternativeLabel = false,
    children,
    className,
    component = "div",
    connector = defaultConnector,
    nonLinear = false,
    orientation = "horizontal",
    ...other
  } = props;
  const ownerState = {
    ...props,
    nonLinear,
    alternativeLabel,
    orientation,
    component
  };
  const classes = useUtilityClasses(ownerState);
  const childrenArray = reactExports.Children.toArray(children).filter(Boolean);
  const steps2 = childrenArray.map((step, index2) => {
    return /* @__PURE__ */ reactExports.cloneElement(step, {
      index: index2,
      last: index2 + 1 === childrenArray.length,
      ...step.props
    });
  });
  const contextValue = reactExports.useMemo(() => ({
    activeStep,
    alternativeLabel,
    connector,
    nonLinear,
    orientation
  }), [activeStep, alternativeLabel, connector, nonLinear, orientation]);
  return /* @__PURE__ */ jsxRuntimeExports.jsx(StepperContext.Provider, {
    value: contextValue,
    children: /* @__PURE__ */ jsxRuntimeExports.jsx(StepperRoot, {
      as: component,
      ownerState,
      className: clsx(classes.root, className),
      ref,
      ...other,
      children: steps2
    })
  });
});
const Check = createSvgIcon(/* @__PURE__ */ jsxRuntimeExports.jsx("path", {
  d: "M9 16.17 4.83 12l-1.42 1.41L9 19 21 7l-1.41-1.41z"
}));
const Info = createSvgIcon(/* @__PURE__ */ jsxRuntimeExports.jsx("path", {
  d: "M12 2C6.48 2 2 6.48 2 12s4.48 10 10 10 10-4.48 10-10S17.52 2 12 2m1 15h-2v-6h2zm0-8h-2V7h2z"
}));
const LocationOn = createSvgIcon(/* @__PURE__ */ jsxRuntimeExports.jsx("path", {
  d: "M12 2C8.13 2 5 5.13 5 9c0 5.25 7 13 7 13s7-7.75 7-13c0-3.87-3.13-7-7-7m0 9.5c-1.38 0-2.5-1.12-2.5-2.5s1.12-2.5 2.5-2.5 2.5 1.12 2.5 2.5-1.12 2.5-2.5 2.5"
}));
const MyLocation = createSvgIcon(/* @__PURE__ */ jsxRuntimeExports.jsx("path", {
  d: "M12 8c-2.21 0-4 1.79-4 4s1.79 4 4 4 4-1.79 4-4-1.79-4-4-4m8.94 3c-.46-4.17-3.77-7.48-7.94-7.94V1h-2v2.06C6.83 3.52 3.52 6.83 3.06 11H1v2h2.06c.46 4.17 3.77 7.48 7.94 7.94V23h2v-2.06c4.17-.46 7.48-3.77 7.94-7.94H23v-2zM12 19c-3.87 0-7-3.13-7-7s3.13-7 7-7 7 3.13 7 7-3.13 7-7 7"
}));
const Notifications = createSvgIcon(/* @__PURE__ */ jsxRuntimeExports.jsx("path", {
  d: "M12 22c1.1 0 2-.9 2-2h-4c0 1.1.89 2 2 2m6-6v-5c0-3.07-1.64-5.64-4.5-6.32V4c0-.83-.67-1.5-1.5-1.5s-1.5.67-1.5 1.5v.68C7.63 5.36 6 7.92 6 11v5l-2 2v1h16v-1z"
}));
const RocketLaunch = createSvgIcon(/* @__PURE__ */ jsxRuntimeExports.jsx("path", {
  d: "M9.19 6.35c-2.04 2.29-3.44 5.58-3.57 5.89L2 10.69l4.05-4.05c.47-.47 1.15-.68 1.81-.55zM11.17 17s3.74-1.55 5.89-3.7c5.4-5.4 4.5-9.62 4.21-10.57-.95-.3-5.17-1.19-10.57 4.21C8.55 9.09 7 12.83 7 12.83zm6.48-2.19c-2.29 2.04-5.58 3.44-5.89 3.57L13.31 22l4.05-4.05c.47-.47.68-1.15.55-1.81zM9 18c0 .83-.34 1.58-.88 2.12C6.94 21.3 2 22 2 22s.7-4.94 1.88-6.12C4.42 15.34 5.17 15 6 15c1.66 0 3 1.34 3 3m4-9c0-1.1.9-2 2-2s2 .9 2 2-.9 2-2 2-2-.9-2-2"
}));
const Security = createSvgIcon(/* @__PURE__ */ jsxRuntimeExports.jsx("path", {
  d: "M12 1 3 5v6c0 5.55 3.84 10.74 9 12 5.16-1.26 9-6.45 9-12V5zm0 10.99h7c-.53 4.12-3.28 7.79-7 8.94V12H5V6.3l7-3.11z"
}));
const Warning = createSvgIcon(/* @__PURE__ */ jsxRuntimeExports.jsx("path", {
  d: "M1 21h22L12 2zm12-3h-2v-2h2zm0-4h-2v-4h2z"
}));
const PinContainer = ({
  children,
  title,
  href,
  className,
  containerClassName,
  onClick
}) => {
  const [transform2, setTransform] = reactExports.useState(
    "translate(-50%,-50%) rotateX(0deg)"
  );
  const onMouseEnter = () => {
    setTransform("translate(-50%,-50%) rotateX(40deg) scale(0.8)");
  };
  const onMouseLeave = () => {
    setTransform("translate(-50%,-50%) rotateX(0deg) scale(1)");
  };
  const handleClick = (e2) => {
    e2.preventDefault();
    if (onClick) {
      onClick();
    }
  };
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(
    "div",
    {
      className: cn(
        "relative group/pin z-50 cursor-pointer transition-all duration-500",
        containerClassName
      ),
      onMouseEnter,
      onMouseLeave,
      onClick: handleClick,
      style: {
        filter: "drop-shadow(0 0 15px rgba(156, 163, 175, 0.2))"
      },
      children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx(
          "div",
          {
            style: {
              perspective: "1000px",
              transform: "rotateX(70deg) translateZ(0deg)"
            },
            className: "absolute left-1/2 top-1/2 ml-[0.09375rem] mt-4 -translate-x-1/2 -translate-y-1/2",
            children: /* @__PURE__ */ jsxRuntimeExports.jsx(
              "div",
              {
                style: {
                  transform: transform2,
                  background: "linear-gradient(135deg, rgba(0,0,0,0.95) 0%, rgba(20,20,20,0.95) 100%)",
                  boxShadow: `
              0 0 20px rgba(156, 163, 175, 0.3),
              0 0 40px rgba(156, 163, 175, 0.1),
              0 8px 30px rgba(0, 0, 0, 0.6),
              inset 0 1px 0 rgba(255, 255, 255, 0.1)
            `,
                  border: "0.5px solid rgba(156, 163, 175, 0.15)",
                  backdropFilter: "blur(8px)",
                  transition: "all 0.7s ease"
                },
                className: "absolute left-1/2 p-3 top-1/2 flex justify-start items-start rounded-2xl overflow-hidden group-hover/pin:shadow-[0_0_30px_rgba(156,163,175,0.5),0_0_60px_rgba(156,163,175,0.2),0_8px_30px_rgba(0,0,0,0.6)] group-hover/pin:border-gray-400/30",
                children: /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: cn("relative z-50", className), children })
              }
            )
          }
        ),
        /* @__PURE__ */ jsxRuntimeExports.jsx(PinPerspective, { title, href })
      ]
    }
  );
};
const PinPerspective = ({
  title,
  href
}) => {
  return /* @__PURE__ */ jsxRuntimeExports.jsx(motion.div, { className: "pointer-events-none w-96 h-80 flex items-center justify-center opacity-0 group-hover/pin:opacity-100 z-[60] transition duration-500", children: /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "w-full h-full -mt-7 flex-none inset-0", children: [
    /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "absolute top-0 inset-x-0 flex justify-center", children: /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "relative flex space-x-2 items-center z-10 rounded-full bg-zinc-950 py-0.5 px-4 ring-1 ring-white/10", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "relative z-20 text-white text-xs font-bold inline-block py-0.5", children: title }),
      /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "absolute -bottom-0 left-[1.125rem] h-px w-[calc(100%-2.25rem)] bg-gradient-to-r from-emerald-400/0 via-emerald-400/90 to-emerald-400/0 transition-opacity duration-500 group-hover/btn:opacity-40" })
    ] }) }),
    /* @__PURE__ */ jsxRuntimeExports.jsx(
      "div",
      {
        style: {
          perspective: "1000px",
          transform: "rotateX(70deg) translateZ(0)"
        },
        className: "absolute left-1/2 top-1/2 ml-[0.09375rem] mt-4 -translate-x-1/2 -translate-y-1/2",
        children: /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            motion.div,
            {
              initial: {
                opacity: 0,
                scale: 0,
                x: "-50%",
                y: "-50%"
              },
              animate: {
                opacity: [0, 1, 0.5, 0],
                scale: 1,
                z: 0
              },
              transition: {
                duration: 6,
                repeat: Infinity,
                delay: 0
              },
              className: "absolute left-1/2 top-1/2 h-[11.25rem] w-[11.25rem] rounded-[50%] bg-sky-500/[0.08] shadow-[0_8px_16px_rgb(0_0_0/0.4)]"
            }
          ),
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            motion.div,
            {
              initial: {
                opacity: 0,
                scale: 0,
                x: "-50%",
                y: "-50%"
              },
              animate: {
                opacity: [0, 1, 0.5, 0],
                scale: 1,
                z: 0
              },
              transition: {
                duration: 6,
                repeat: Infinity,
                delay: 2
              },
              className: "absolute left-1/2 top-1/2 h-[11.25rem] w-[11.25rem] rounded-[50%] bg-sky-500/[0.08] shadow-[0_8px_16px_rgb(0_0_0/0.4)]"
            }
          ),
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            motion.div,
            {
              initial: {
                opacity: 0,
                scale: 0,
                x: "-50%",
                y: "-50%"
              },
              animate: {
                opacity: [0, 1, 0.5, 0],
                scale: 1,
                z: 0
              },
              transition: {
                duration: 6,
                repeat: Infinity,
                delay: 4
              },
              className: "absolute left-1/2 top-1/2 h-[11.25rem] w-[11.25rem] rounded-[50%] bg-sky-500/[0.08] shadow-[0_8px_16px_rgb(0_0_0/0.4)]"
            }
          )
        ] })
      }
    ),
    /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx(motion.div, { className: "absolute right-1/2 bottom-1/2 bg-gradient-to-b from-transparent to-cyan-500 translate-y-[14px] w-px h-20 group-hover/pin:h-40 blur-[2px]" }),
      /* @__PURE__ */ jsxRuntimeExports.jsx(motion.div, { className: "absolute right-1/2 bottom-1/2 bg-gradient-to-b from-transparent to-cyan-500 translate-y-[14px] w-px h-20 group-hover/pin:h-40" }),
      /* @__PURE__ */ jsxRuntimeExports.jsx(motion.div, { className: "absolute right-1/2 translate-x-[1.5px] bottom-1/2 bg-cyan-600 translate-y-[14px] w-[4px] h-[4px] rounded-full z-40 blur-[3px]" }),
      /* @__PURE__ */ jsxRuntimeExports.jsx(motion.div, { className: "absolute right-1/2 translate-x-[0.5px] bottom-1/2 bg-cyan-300 translate-y-[14px] w-[2px] h-[2px] rounded-full z-40" })
    ] })
  ] }) });
};
const Beam = ({
  width: width2,
  x: x2,
  delay: delay2,
  duration: duration2
}) => {
  const hue = Math.floor(Math.random() * 360);
  const ar = Math.floor(Math.random() * 10) + 1;
  return /* @__PURE__ */ jsxRuntimeExports.jsx(
    motion.div,
    {
      style: {
        "--x": `${x2}`,
        "--width": `${width2}`,
        "--aspect-ratio": `${ar}`,
        "--background": `linear-gradient(hsl(${hue} 80% 60%), transparent)`
      },
      className: `absolute left-[var(--x)] top-0 [aspect-ratio:1/var(--aspect-ratio)] [background:var(--background)] [width:var(--width)]`,
      initial: { y: "100cqmax", x: "-50%" },
      animate: { y: "-100%", x: "-50%" },
      transition: {
        duration: duration2,
        delay: delay2,
        repeat: Infinity,
        ease: "linear"
      }
    }
  );
};
const WarpBackground = ({
  children,
  perspective = 100,
  className,
  beamsPerSide = 3,
  beamSize = 5,
  beamDelayMax = 3,
  beamDelayMin = 0,
  beamDuration = 3,
  gridColor = "var(--border)",
  ...props
}) => {
  const generateBeams = reactExports.useCallback(() => {
    const beams = [];
    const cellsPerSide = Math.floor(100 / beamSize);
    const step = cellsPerSide / beamsPerSide;
    for (let i2 = 0; i2 < beamsPerSide; i2++) {
      const x2 = Math.floor(i2 * step);
      const delay2 = Math.random() * (beamDelayMax - beamDelayMin) + beamDelayMin;
      beams.push({ x: x2, delay: delay2 });
    }
    return beams;
  }, [beamsPerSide, beamSize, beamDelayMax, beamDelayMin]);
  const topBeams = reactExports.useMemo(() => generateBeams(), [generateBeams]);
  const rightBeams = reactExports.useMemo(() => generateBeams(), [generateBeams]);
  const bottomBeams = reactExports.useMemo(() => generateBeams(), [generateBeams]);
  const leftBeams = reactExports.useMemo(() => generateBeams(), [generateBeams]);
  return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: cn("relative rounded border p-20", className), ...props, children: [
    /* @__PURE__ */ jsxRuntimeExports.jsxs(
      "div",
      {
        style: {
          "--perspective": `${perspective}px`,
          "--grid-color": gridColor,
          "--beam-size": `${beamSize}%`
        },
        className: "pointer-events-none absolute left-0 top-0 size-full overflow-hidden [clipPath:inset(0)] [container-type:size] [perspective:var(--perspective)] [transform-style:preserve-3d]",
        children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "absolute z-20 [transform-style:preserve-3d] [background-size:var(--beam-size)_var(--beam-size)] [background:linear-gradient(var(--grid-color)_0_1px,_transparent_1px_var(--beam-size))_50%_-0.5px_/var(--beam-size)_var(--beam-size),linear-gradient(90deg,_var(--grid-color)_0_1px,_transparent_1px_var(--beam-size))_50%_50%_/var(--beam-size)_var(--beam-size)] [container-type:inline-size] [height:100cqmax] [transform-origin:50%_0%] [transform:rotateX(-90deg)] [width:100cqi]", children: topBeams.map((beam, index2) => /* @__PURE__ */ jsxRuntimeExports.jsx(
            Beam,
            {
              width: `${beamSize}%`,
              x: `${beam.x * beamSize}%`,
              delay: beam.delay,
              duration: beamDuration
            },
            `top-${index2}`
          )) }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "absolute top-full [transform-style:preserve-3d] [background-size:var(--beam-size)_var(--beam-size)] [background:linear-gradient(var(--grid-color)_0_1px,_transparent_1px_var(--beam-size))_50%_-0.5px_/var(--beam-size)_var(--beam-size),linear-gradient(90deg,_var(--grid-color)_0_1px,_transparent_1px_var(--beam-size))_50%_50%_/var(--beam-size)_var(--beam-size)] [container-type:inline-size] [height:100cqmax] [transform-origin:50%_0%] [transform:rotateX(-90deg)] [width:100cqi]", children: bottomBeams.map((beam, index2) => /* @__PURE__ */ jsxRuntimeExports.jsx(
            Beam,
            {
              width: `${beamSize}%`,
              x: `${beam.x * beamSize}%`,
              delay: beam.delay,
              duration: beamDuration
            },
            `bottom-${index2}`
          )) }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "absolute left-0 top-0 [transform-style:preserve-3d] [background-size:var(--beam-size)_var(--beam-size)] [background:linear-gradient(var(--grid-color)_0_1px,_transparent_1px_var(--beam-size))_50%_-0.5px_/var(--beam-size)_var(--beam-size),linear-gradient(90deg,_var(--grid-color)_0_1px,_transparent_1px_var(--beam-size))_50%_50%_/var(--beam-size)_var(--beam-size)] [container-type:inline-size] [height:100cqmax] [transform-origin:0%_0%] [transform:rotate(90deg)_rotateX(-90deg)] [width:100cqh]", children: leftBeams.map((beam, index2) => /* @__PURE__ */ jsxRuntimeExports.jsx(
            Beam,
            {
              width: `${beamSize}%`,
              x: `${beam.x * beamSize}%`,
              delay: beam.delay,
              duration: beamDuration
            },
            `left-${index2}`
          )) }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "absolute right-0 top-0 [transform-style:preserve-3d] [background-size:var(--beam-size)_var(--beam-size)] [background:linear-gradient(var(--grid-color)_0_1px,_transparent_1px_var(--beam-size))_50%_-0.5px_/var(--beam-size)_var(--beam-size),linear-gradient(90deg,_var(--grid-color)_0_1px,_transparent_1px_var(--beam-size))_50%_50%_/var(--beam-size)_var(--beam-size)] [container-type:inline-size] [height:100cqmax] [width:100cqh] [transform-origin:100%_0%] [transform:rotate(-90deg)_rotateX(-90deg)]", children: rightBeams.map((beam, index2) => /* @__PURE__ */ jsxRuntimeExports.jsx(
            Beam,
            {
              width: `${beamSize}%`,
              x: `${beam.x * beamSize}%`,
              delay: beam.delay,
              duration: beamDuration
            },
            `right-${index2}`
          )) })
        ]
      }
    ),
    /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "relative", children })
  ] });
};
const MAPBOX_TOKEN = "pk.eyJ1IjoiaWNyeXB0b2ZyZWFrIiwiYSI6ImNtYnhieGE4cjFhcW8ya3B1NXRreThxZXIifQ.s32qHjkFoiS-Qauyqa6REg";
const darkTheme = createTheme({
  palette: {
    mode: "dark",
    primary: {
      main: "#4A5568"
      // Темно-серый
    },
    background: {
      default: "transparent",
      paper: "transparent"
    },
    text: {
      primary: "#FFFFFF",
      secondary: "#C7C7C7"
    }
  },
  typography: {
    fontFamily: '"Inter", "Roboto", "Helvetica", "Arial", sans-serif',
    h4: {
      fontWeight: 600,
      fontSize: "1.5rem",
      lineHeight: 1.3
    },
    body1: {
      fontSize: "1rem",
      lineHeight: 1.5
    }
  },
  components: {
    MuiStepper: {
      styleOverrides: {
        root: {
          "& .MuiStepLabel-root .Mui-active": {
            color: "#4A5568"
          },
          "& .MuiStepLabel-root .Mui-completed": {
            color: "#48BB78"
          }
        }
      }
    },
    MuiStepIcon: {
      styleOverrides: {
        root: {
          "&.Mui-active": {
            color: "#4A5568"
          },
          "&.Mui-completed": {
            color: "#48BB78"
          }
        }
      }
    },
    MuiButton: {
      styleOverrides: {
        root: {
          borderRadius: 12,
          textTransform: "none",
          fontWeight: 600,
          fontSize: "1rem",
          padding: "12px 32px",
          background: "linear-gradient(135deg, #2D3748 0%, #4A5568 100%)",
          "&:hover": {
            background: "linear-gradient(135deg, #1A202C 0%, #2D3748 100%)"
          },
          "&:disabled": {
            background: "linear-gradient(135deg, #2D3748 0%, #4A5568 100%)",
            opacity: 0.6
          }
        }
      }
    }
  }
});
const CustomStepIcon = ({ active, completed, icon }) => {
  const stepIcons = {
    1: /* @__PURE__ */ jsxRuntimeExports.jsx(LocationOn, {}),
    2: /* @__PURE__ */ jsxRuntimeExports.jsx(Notifications, {}),
    3: /* @__PURE__ */ jsxRuntimeExports.jsx(RocketLaunch, {})
  };
  if (completed) {
    return /* @__PURE__ */ jsxRuntimeExports.jsx(
      Box,
      {
        sx: {
          backgroundColor: "#48BB78",
          borderRadius: "50%",
          width: 24,
          height: 24,
          display: "flex",
          alignItems: "center",
          justifyContent: "center"
        },
        children: /* @__PURE__ */ jsxRuntimeExports.jsx(Check, { sx: { fontSize: 16, color: "white" } })
      }
    );
  }
  return /* @__PURE__ */ jsxRuntimeExports.jsx(
    Box,
    {
      sx: {
        backgroundColor: active ? "#4A5568" : "#2D3748",
        borderRadius: "50%",
        width: 24,
        height: 24,
        display: "flex",
        alignItems: "center",
        justifyContent: "center",
        color: "white"
      },
      children: React.cloneElement(stepIcons[String(icon)], { sx: { fontSize: 16 } })
    }
  );
};
const NotificationMockup = ({
  icon,
  title,
  message,
  severity,
  delay: delay2 = 0,
  position: position2,
  hasButton = false,
  buttonText = "Action",
  onButtonClick
}) => {
  const getSeverityColors = () => {
    switch (severity) {
      case "danger":
        return {
          background: "linear-gradient(135deg, #E53E3E 0%, #C53030 100%)",
          border: "#F56565",
          glow: "rgba(229, 62, 62, 0.4)"
        };
      case "warning":
        return {
          background: "linear-gradient(135deg, #DD6B20 0%, #C05621 100%)",
          border: "#F6AD55",
          glow: "rgba(221, 107, 32, 0.4)"
        };
      case "info":
        return {
          background: "linear-gradient(135deg, #3182CE 0%, #2C5282 100%)",
          border: "#63B3ED",
          glow: "rgba(49, 130, 206, 0.4)"
        };
      case "success":
        return {
          background: "linear-gradient(135deg, #48BB78 0%, #38A169 100%)",
          border: "#68D391",
          glow: "rgba(72, 187, 120, 0.4)"
        };
      default:
        return {
          background: "linear-gradient(135deg, #4A5568 0%, #2D3748 100%)",
          border: "#A0AEC0",
          glow: "rgba(74, 85, 104, 0.4)"
        };
    }
  };
  const colors = getSeverityColors();
  return /* @__PURE__ */ jsxRuntimeExports.jsx(
    motion.div,
    {
      initial: { opacity: 0, scale: 0.8, y: 20 },
      animate: { opacity: 1, scale: 1, y: 0 },
      transition: {
        delay: delay2,
        duration: 0.6
      },
      style: {
        position: "absolute",
        ...position2,
        zIndex: 10
      },
      children: /* @__PURE__ */ jsxRuntimeExports.jsxs(
        Box,
        {
          sx: {
            width: 280,
            background: colors.background,
            borderRadius: 2,
            p: 2,
            boxShadow: `0 8px 32px ${colors.glow}`,
            border: `1px solid ${colors.border}`,
            backdropFilter: "blur(10px)",
            cursor: "pointer",
            transition: "all 0.3s ease",
            "&:hover": {
              transform: "translateY(-8px) scale(1.05)",
              boxShadow: `0 16px 48px ${colors.glow}`,
              border: `2px solid ${colors.border}`
            }
          },
          children: [
            /* @__PURE__ */ jsxRuntimeExports.jsxs(Box, { sx: { display: "flex", alignItems: "flex-start", gap: 1.5 }, children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx(
                Box,
                {
                  sx: {
                    width: 32,
                    height: 32,
                    borderRadius: "50%",
                    background: "rgba(255, 255, 255, 0.2)",
                    display: "flex",
                    alignItems: "center",
                    justifyContent: "center",
                    flexShrink: 0,
                    mt: 0.5
                  },
                  children: React.cloneElement(icon, {
                    sx: { fontSize: 18, color: "white" }
                  })
                }
              ),
              /* @__PURE__ */ jsxRuntimeExports.jsxs(Box, { sx: { flex: 1, minWidth: 0 }, children: [
                /* @__PURE__ */ jsxRuntimeExports.jsx(
                  Typography,
                  {
                    variant: "subtitle2",
                    sx: {
                      color: "white",
                      fontWeight: 700,
                      fontSize: "0.9rem",
                      mb: 0.5,
                      lineHeight: 1.2
                    },
                    children: title
                  }
                ),
                /* @__PURE__ */ jsxRuntimeExports.jsx(
                  Typography,
                  {
                    variant: "body2",
                    sx: {
                      color: "rgba(255, 255, 255, 0.9)",
                      fontSize: "0.8rem",
                      lineHeight: 1.3,
                      mb: hasButton ? 1.5 : 0
                    },
                    children: message
                  }
                ),
                hasButton && /* @__PURE__ */ jsxRuntimeExports.jsx(
                  Button,
                  {
                    variant: "contained",
                    onClick: onButtonClick,
                    sx: {
                      mt: 1,
                      py: 0.75,
                      px: 2,
                      fontSize: "0.75rem",
                      fontWeight: 600,
                      borderRadius: 2,
                      background: "rgba(255, 255, 255, 0.2)",
                      color: "white",
                      backdropFilter: "blur(10px)",
                      border: "1px solid rgba(255, 255, 255, 0.3)",
                      textTransform: "none",
                      minWidth: "auto",
                      "&:hover": {
                        background: "rgba(255, 255, 255, 0.3)",
                        transform: "translateY(-1px)"
                      },
                      transition: "all 0.2s ease"
                    },
                    children: buttonText
                  }
                )
              ] })
            ] }),
            /* @__PURE__ */ jsxRuntimeExports.jsx(
              Box,
              {
                sx: {
                  mt: 1.5,
                  height: 2,
                  background: "rgba(255, 255, 255, 0.2)",
                  borderRadius: 1,
                  overflow: "hidden"
                },
                children: /* @__PURE__ */ jsxRuntimeExports.jsx(
                  motion.div,
                  {
                    initial: { width: "100%" },
                    animate: { width: "0%" },
                    transition: { duration: 5, delay: delay2 + 0.6, ease: "linear" },
                    style: {
                      height: "100%",
                      background: "rgba(255, 255, 255, 0.8)",
                      borderRadius: 4
                    }
                  }
                )
              }
            )
          ]
        }
      )
    }
  );
};
const OnboardingMinimal = () => {
  const navigate = useNavigate();
  const { t: t2 } = useTypedLanguage();
  const { getUserKey, markCompleted } = useOnboarding();
  const mapRef = reactExports.useRef(null);
  const mapInstanceRef = reactExports.useRef(null);
  const markerRef = reactExports.useRef(null);
  const [state, setState] = reactExports.useState({
    activeStep: 0,
    completedSteps: /* @__PURE__ */ new Set(),
    permissions: {
      geolocation: "pending",
      notifications: "pending"
    },
    userLocation: null,
    isSearchingLocation: false
  });
  const [showSuccess, setShowSuccess] = reactExports.useState(false);
  const [successMessage, setSuccessMessage] = reactExports.useState("");
  const steps2 = [
    {
      id: 0,
      title: t2("onboarding.locationTitle") || "Enable Location Access",
      description: t2("onboarding.locationDescription") || "To receive alerts about incidents near you and ensure accurate safety updates in real time.",
      buttonText: t2("onboarding.locationButton") || "Allow Location"
    },
    {
      id: 1,
      title: t2("onboarding.notificationsTitle") || "Enable Notifications",
      description: t2("onboarding.notificationsDescription") || "Stay informed instantly about important incidents, community updates, and emergency alerts.",
      buttonText: t2("onboarding.notificationsButton") || "Enable Notifications"
    },
    {
      id: 2,
      title: t2("onboarding.welcomeTitle") || "Welcome to RADAR",
      description: t2("onboarding.welcomeDescription") || "Your safety is in your hands. You're ready to receive real-time alerts and join your community.",
      buttonText: t2("onboarding.welcomeButton") || "Get Started"
    }
  ];
  reactExports.useEffect(() => {
    localStorage.setItem(getUserKey("onboarding_shown"), "true");
  }, [getUserKey]);
  reactExports.useEffect(() => {
    if (state.activeStep === 0 && mapRef.current && !mapInstanceRef.current) {
      initializeMap();
    }
  }, [state.activeStep]);
  const initializeMap = () => {
    if (!mapRef.current) return;
    mapboxgl.accessToken = MAPBOX_TOKEN;
    try {
      const map = new mapboxgl.Map({
        container: mapRef.current,
        style: "mapbox://styles/mapbox/dark-v11",
        center: [-66.9036, 10.4806],
        // Caracas coordinates
        zoom: 12,
        pitch: 0,
        bearing: 0,
        attributionControl: false,
        // Убираем копирайт
        logoPosition: "bottom-right"
        // Перемещаем логотип, но его все равно скроем через CSS
      });
      map.on("load", () => {
        mapInstanceRef.current = map;
      });
    } catch (error) {
      console.error("Error initializing Mapbox:", error);
    }
  };
  const addLocationMarker = (lat, lng) => {
    if (!mapInstanceRef.current) return;
    if (markerRef.current) {
      markerRef.current.remove();
    }
    const markerElement = document.createElement("div");
    markerElement.innerHTML = `
      <div style="
        position: relative;
        width: 24px;
        height: 24px;
      ">
        <!-- Пульсирующий круг -->
        <div style="
          position: absolute;
          width: 40px;
          height: 40px;
          border-radius: 50%;
          background: rgba(72, 187, 120, 0.3);
          top: -8px;
          left: -8px;
          animation: userLocationPulse 2s infinite;
        "></div>
        
        <!-- Основной маркер -->
        <div style="
          width: 24px;
          height: 24px;
          border-radius: 50%;
          background: linear-gradient(135deg, #4285F4 0%, #34A853 100%);
          border: 3px solid white;
          box-shadow: 0 2px 15px rgba(66, 133, 244, 0.6);
          position: relative;
          z-index: 2;
        ">
          <!-- Точка в центре -->
          <div style="
            width: 6px;
            height: 6px;
            border-radius: 50%;
            background: white;
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
          "></div>
        </div>
      </div>
    `;
    const marker = new mapboxgl.Marker(markerElement).setLngLat([lng, lat]).addTo(mapInstanceRef.current);
    markerRef.current = marker;
    mapInstanceRef.current.flyTo({
      center: [lng, lat],
      zoom: 16,
      duration: 1500
    });
  };
  const handleNext = () => {
    if (state.activeStep < 2) {
      setState((prev2) => ({
        ...prev2,
        activeStep: prev2.activeStep + 1,
        completedSteps: /* @__PURE__ */ new Set([...prev2.completedSteps, prev2.activeStep])
      }));
    }
  };
  const handleLocationPermission = async () => {
    setState((prev2) => ({ ...prev2, isSearchingLocation: true }));
    try {
      const isWeb = Capacitor.getPlatform() === "web";
      if (isWeb) {
        if (!navigator.geolocation) {
          throw new Error("Geolocation is not supported by this browser.");
        }
        navigator.geolocation.getCurrentPosition(
          (position2) => {
            const { latitude, longitude } = position2.coords;
            setState((prev2) => ({
              ...prev2,
              permissions: { ...prev2.permissions, geolocation: "granted" },
              userLocation: { lat: latitude, lng: longitude },
              isSearchingLocation: false
            }));
            addLocationMarker(latitude, longitude);
            localStorage.setItem(getUserKey("geolocation_permission_status"), "granted");
            setTimeout(() => {
              setSuccessMessage(t2("onboarding.locationSuccess") || "✓ Location detected and geolocation is active!");
              setShowSuccess(true);
              setTimeout(() => {
                handleNext();
              }, 5e3);
            }, 2e3);
          },
          (error) => {
            console.error("Web geolocation error:", error);
            setState((prev2) => ({
              ...prev2,
              permissions: { ...prev2.permissions, geolocation: "denied" },
              isSearchingLocation: false
            }));
            localStorage.setItem(getUserKey("geolocation_permission_status"), "denied");
            handleNext();
          },
          {
            enableHighAccuracy: true,
            timeout: 1e4,
            maximumAge: 6e4
          }
        );
      } else {
        const permission = await Geolocation.requestPermissions();
        if (permission.location === "granted") {
          const position2 = await Geolocation.getCurrentPosition({
            enableHighAccuracy: true,
            timeout: 1e4,
            maximumAge: 6e4
          });
          const { latitude, longitude } = position2.coords;
          setState((prev2) => ({
            ...prev2,
            permissions: { ...prev2.permissions, geolocation: "granted" },
            userLocation: { lat: latitude, lng: longitude },
            isSearchingLocation: false
          }));
          addLocationMarker(latitude, longitude);
          localStorage.setItem(getUserKey("geolocation_permission_status"), "granted");
          setTimeout(() => {
            setSuccessMessage(t2("onboarding.locationSuccess") || "✓ Location detected and geolocation is active!");
            setShowSuccess(true);
            setTimeout(() => {
              handleNext();
            }, 5e3);
          }, 2e3);
        } else {
          setState((prev2) => ({
            ...prev2,
            permissions: { ...prev2.permissions, geolocation: "denied" },
            isSearchingLocation: false
          }));
          localStorage.setItem(getUserKey("geolocation_permission_status"), "denied");
          handleNext();
        }
      }
    } catch (error) {
      console.error("Geolocation permission error:", error);
      setState((prev2) => ({
        ...prev2,
        permissions: { ...prev2.permissions, geolocation: "denied" },
        isSearchingLocation: false
      }));
      localStorage.setItem(getUserKey("geolocation_permission_status"), "denied");
      handleNext();
    }
  };
  const handleNotificationPermission = async () => {
    try {
      const { PushNotificationService: PushNotificationService2 } = await __vitePreload(async () => {
        const { PushNotificationService: PushNotificationService3 } = await Promise.resolve().then(() => pushNotificationService);
        return { PushNotificationService: PushNotificationService3 };
      }, true ? [] : void 0);
      const success = await PushNotificationService2.getInstance().requestPermissionsAndInitialize();
      const status = success ? "granted" : "denied";
      setState((prev2) => ({
        ...prev2,
        permissions: { ...prev2.permissions, notifications: status }
      }));
      if (status === "granted") {
        console.log("✅ Push notifications enabled by user");
        setSuccessMessage(t2("onboarding.notificationsSuccess") || "✓ Notifications enabled! You'll receive real-time safety alerts.");
        setShowSuccess(true);
      }
      localStorage.setItem(getUserKey("notification_permission_status"), status);
      setTimeout(() => {
        handleNext();
      }, status === "granted" ? 2e3 : 500);
    } catch (error) {
      console.error("Notification permission error:", error);
      setState((prev2) => ({
        ...prev2,
        permissions: { ...prev2.permissions, notifications: "denied" }
      }));
      localStorage.setItem(getUserKey("notification_permission_status"), "denied");
      handleNext();
    }
  };
  const handleComplete = () => {
    markCompleted();
    navigate("/main");
  };
  const handleStepAction = () => {
    switch (state.activeStep) {
      case 0:
        handleLocationPermission();
        break;
      case 1:
        handleNotificationPermission();
        break;
      case 2:
        handleComplete();
        break;
    }
  };
  const currentStep = steps2[state.activeStep];
  const pageTransition = {
    initial: { opacity: 0, y: 20 },
    animate: { opacity: 1, y: 0 },
    exit: { opacity: 0, y: -20 }
  };
  return /* @__PURE__ */ jsxRuntimeExports.jsx(ThemeProvider, { theme: darkTheme, children: /* @__PURE__ */ jsxRuntimeExports.jsxs(
    Box,
    {
      sx: {
        minHeight: "100vh",
        background: "linear-gradient(180deg, #0E0E0E 0%, #1C1C1C 100%)",
        display: "flex",
        flexDirection: "column",
        position: "relative",
        overflow: "hidden"
      },
      children: [
        /* @__PURE__ */ jsxRuntimeExports.jsxs(
          Container,
          {
            maxWidth: "sm",
            sx: {
              height: "100vh",
              display: "flex",
              flexDirection: "column",
              py: 3
            },
            children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx(Box, { sx: { mb: 4 }, children: /* @__PURE__ */ jsxRuntimeExports.jsx(
                Stepper,
                {
                  activeStep: state.activeStep,
                  alternativeLabel: true,
                  sx: {
                    "& .MuiStepConnector-line": {
                      borderColor: "#333"
                    },
                    "& .MuiStepLabel-label": {
                      color: "#666",
                      fontSize: "0.75rem",
                      "&.Mui-active": {
                        color: "#4A5568"
                      },
                      "&.Mui-completed": {
                        color: "#48BB78"
                      }
                    }
                  },
                  children: steps2.map((step, index2) => /* @__PURE__ */ jsxRuntimeExports.jsx(Step, { completed: state.completedSteps.has(step.id), children: /* @__PURE__ */ jsxRuntimeExports.jsx(StepLabel, { StepIconComponent: CustomStepIcon, children: index2 === 0 ? "Location" : index2 === 1 ? "Notifications" : "Welcome" }) }, step.id))
                }
              ) }),
              /* @__PURE__ */ jsxRuntimeExports.jsx(
                Box,
                {
                  sx: {
                    flex: 1,
                    display: "flex",
                    flexDirection: "column",
                    justifyContent: "center",
                    textAlign: "center",
                    px: 2
                  },
                  children: /* @__PURE__ */ jsxRuntimeExports.jsx(AnimatePresence, { mode: "wait", children: /* @__PURE__ */ jsxRuntimeExports.jsxs(
                    motion.div,
                    {
                      ...pageTransition,
                      style: {
                        display: "flex",
                        flexDirection: "column",
                        alignItems: "center",
                        height: "100%",
                        justifyContent: "center"
                      },
                      children: [
                        /* @__PURE__ */ jsxRuntimeExports.jsx(
                          Typography,
                          {
                            variant: "h4",
                            sx: {
                              color: "#FFFFFF",
                              fontWeight: 600,
                              fontSize: { xs: "1.4rem", sm: "1.5rem" },
                              mb: 3,
                              lineHeight: 1.3
                            },
                            children: currentStep.title
                          }
                        ),
                        /* @__PURE__ */ jsxRuntimeExports.jsx(
                          Typography,
                          {
                            variant: "body1",
                            sx: {
                              color: "#C7C7C7",
                              fontSize: "1rem",
                              lineHeight: 1.5,
                              maxWidth: "90%",
                              mb: state.activeStep === 0 ? 2 : 6,
                              px: 1
                            },
                            children: currentStep.description
                          }
                        ),
                        state.activeStep === 0 && /* @__PURE__ */ jsxRuntimeExports.jsx(
                          Typography,
                          {
                            variant: "body2",
                            sx: {
                              color: "#48BB78",
                              fontSize: "0.875rem",
                              fontWeight: 500,
                              mb: 4,
                              opacity: 0.8
                            },
                            children: "💡 Click on the interactive map below to start location detection"
                          }
                        ),
                        state.activeStep === 0 && /* @__PURE__ */ jsxRuntimeExports.jsx(Box, { sx: { width: "100%", display: "flex", flexDirection: "column", alignItems: "center", mb: 4, position: "relative" }, children: /* @__PURE__ */ jsxRuntimeExports.jsxs(
                          PinContainer,
                          {
                            title: state.isSearchingLocation ? "Detecting your position..." : state.userLocation ? "✓ Location detected successfully!" : "Click to detect your location",
                            onClick: handleLocationPermission,
                            className: "w-80 h-60",
                            children: [
                              /* @__PURE__ */ jsxRuntimeExports.jsx(
                                Box,
                                {
                                  ref: mapRef,
                                  sx: {
                                    width: "100%",
                                    height: "100%",
                                    borderRadius: 4,
                                    overflow: "hidden",
                                    position: "relative",
                                    // Скрываем все элементы Mapbox через CSS
                                    "& .mapboxgl-ctrl-top-right": {
                                      display: "none !important"
                                    },
                                    "& .mapboxgl-ctrl-bottom-right": {
                                      display: "none !important"
                                    },
                                    "& .mapboxgl-ctrl-bottom-left": {
                                      display: "none !important"
                                    },
                                    "& .mapboxgl-ctrl-attrib": {
                                      display: "none !important"
                                    },
                                    "& .mapboxgl-ctrl-logo": {
                                      display: "none !important"
                                    },
                                    "& .mapboxgl-ctrl": {
                                      display: "none !important"
                                    }
                                  }
                                }
                              ),
                              state.isSearchingLocation && /* @__PURE__ */ jsxRuntimeExports.jsx(
                                Box,
                                {
                                  sx: {
                                    position: "absolute",
                                    top: 0,
                                    left: 0,
                                    right: 0,
                                    bottom: 0,
                                    backgroundColor: "rgba(0, 0, 0, 0.8)",
                                    display: "flex",
                                    flexDirection: "column",
                                    alignItems: "center",
                                    justifyContent: "center",
                                    borderRadius: 1,
                                    zIndex: 1e3
                                  },
                                  children: /* @__PURE__ */ jsxRuntimeExports.jsxs(
                                    motion.div,
                                    {
                                      initial: { scale: 0.8, opacity: 0 },
                                      animate: { scale: 1, opacity: 1 },
                                      style: { display: "flex", flexDirection: "column", alignItems: "center" },
                                      children: [
                                        /* @__PURE__ */ jsxRuntimeExports.jsxs(Box, { sx: { position: "relative", mb: 2 }, children: [
                                          /* @__PURE__ */ jsxRuntimeExports.jsx(
                                            CircularProgress,
                                            {
                                              size: 40,
                                              sx: {
                                                color: "#48BB78",
                                                "& .MuiCircularProgress-circle": {
                                                  strokeLinecap: "round"
                                                }
                                              }
                                            }
                                          ),
                                          /* @__PURE__ */ jsxRuntimeExports.jsx(
                                            Box,
                                            {
                                              sx: {
                                                position: "absolute",
                                                top: "50%",
                                                left: "50%",
                                                transform: "translate(-50%, -50%)"
                                              },
                                              children: /* @__PURE__ */ jsxRuntimeExports.jsx(MyLocation, { sx: { color: "#48BB78", fontSize: 20 } })
                                            }
                                          )
                                        ] }),
                                        /* @__PURE__ */ jsxRuntimeExports.jsx(
                                          Typography,
                                          {
                                            variant: "body2",
                                            sx: {
                                              color: "#48BB78",
                                              fontWeight: 600,
                                              textAlign: "center",
                                              fontSize: "0.8rem",
                                              animation: "pulse 2s infinite"
                                            },
                                            children: "Searching..."
                                          }
                                        )
                                      ]
                                    }
                                  )
                                }
                              )
                            ]
                          }
                        ) }),
                        state.activeStep === 1 && /* @__PURE__ */ jsxRuntimeExports.jsxs(Box, { sx: { position: "relative", width: "100%", height: 350 }, children: [
                          /* @__PURE__ */ jsxRuntimeExports.jsx(
                            NotificationMockup,
                            {
                              icon: /* @__PURE__ */ jsxRuntimeExports.jsx(Warning, {}),
                              title: "Danger Zone Alert",
                              message: "You are approaching a high-risk area. Stay alert and avoid if possible.",
                              severity: "danger",
                              delay: 0.5,
                              position: { top: "10px", left: "10px" }
                            }
                          ),
                          /* @__PURE__ */ jsxRuntimeExports.jsx(
                            NotificationMockup,
                            {
                              icon: /* @__PURE__ */ jsxRuntimeExports.jsx(Security, {}),
                              title: "Incident Nearby",
                              message: "Traffic accident reported 200m ahead. Consider alternative route.",
                              severity: "warning",
                              delay: 1.2,
                              position: { top: "80px", right: "15px" }
                            }
                          ),
                          /* @__PURE__ */ jsxRuntimeExports.jsx(
                            NotificationMockup,
                            {
                              icon: /* @__PURE__ */ jsxRuntimeExports.jsx(Info, {}),
                              title: "Community Alert",
                              message: "Emergency services conducting operation in your area. Expect delays.",
                              severity: "info",
                              delay: 1.9,
                              position: { bottom: "100px", left: "20px" }
                            }
                          ),
                          /* @__PURE__ */ jsxRuntimeExports.jsx(
                            NotificationMockup,
                            {
                              icon: /* @__PURE__ */ jsxRuntimeExports.jsx(Check, {}),
                              title: "Enable Safety Alerts",
                              message: "Get instant notifications about incidents near you for better safety.",
                              severity: "success",
                              delay: 2.6,
                              position: { bottom: "10px", right: "15px" },
                              hasButton: true,
                              buttonText: "Enable Notifications",
                              onButtonClick: handleNotificationPermission
                            }
                          )
                        ] }),
                        state.activeStep === 2 && /* @__PURE__ */ jsxRuntimeExports.jsx(
                          motion.div,
                          {
                            initial: { opacity: 0 },
                            animate: { opacity: 1 },
                            exit: { opacity: 0 },
                            transition: { duration: 0.5 },
                            style: { width: "100%", height: "100%", position: "relative" },
                            children: /* @__PURE__ */ jsxRuntimeExports.jsx(WarpBackground, { className: "fixed inset-0 flex items-center justify-center", children: /* @__PURE__ */ jsxRuntimeExports.jsx("div", {}) })
                          }
                        )
                      ]
                    },
                    state.activeStep
                  ) })
                }
              ),
              state.activeStep !== 0 && state.activeStep !== 1 && /* @__PURE__ */ jsxRuntimeExports.jsx(Box, { sx: { pt: 3, textAlign: "center" }, children: /* @__PURE__ */ jsxRuntimeExports.jsx(
                Button,
                {
                  variant: "contained",
                  onClick: handleStepAction,
                  disabled: state.isSearchingLocation,
                  sx: {
                    minWidth: 200,
                    py: 1.5,
                    fontSize: "1rem",
                    fontWeight: 600,
                    borderRadius: 3,
                    background: "linear-gradient(135deg, #2D3748 0%, #4A5568 100%)",
                    boxShadow: "0 4px 20px rgba(45, 55, 72, 0.3)",
                    "&:hover": {
                      background: "linear-gradient(135deg, #1A202C 0%, #2D3748 100%)",
                      boxShadow: "0 6px 25px rgba(45, 55, 72, 0.4)",
                      transform: "translateY(-1px)"
                    },
                    transition: "all 0.2s ease"
                  },
                  children: state.isSearchingLocation ? /* @__PURE__ */ jsxRuntimeExports.jsxs(Box, { sx: { display: "flex", alignItems: "center", gap: 1 }, children: [
                    /* @__PURE__ */ jsxRuntimeExports.jsx(CircularProgress, { size: 16, sx: { color: "white" } }),
                    /* @__PURE__ */ jsxRuntimeExports.jsx("span", { children: "Searching..." })
                  ] }) : currentStep.buttonText
                }
              ) })
            ]
          }
        ),
        /* @__PURE__ */ jsxRuntimeExports.jsx(
          Snackbar,
          {
            open: showSuccess,
            autoHideDuration: 4e3,
            onClose: () => setShowSuccess(false),
            anchorOrigin: { vertical: "top", horizontal: "center" },
            children: /* @__PURE__ */ jsxRuntimeExports.jsx(
              Alert,
              {
                onClose: () => setShowSuccess(false),
                severity: "success",
                sx: {
                  backgroundColor: "#48BB78",
                  color: "white",
                  "& .MuiAlert-icon": {
                    color: "white"
                  }
                },
                children: successMessage
              }
            )
          }
        )
      ]
    }
  ) });
};
const OnboardingWrapper = ({ children }) => {
  const navigate = useNavigate();
  const { user } = useAuth();
  const { needsOnboarding, isCompleted, isSkipped } = useOnboarding();
  reactExports.useEffect(() => {
    console.log("OnboardingWrapper: Effect triggered", {
      user: !!user,
      needsOnboarding,
      isCompleted,
      isSkipped
    });
    if (user && needsOnboarding) {
      console.log("OnboardingWrapper: Navigating to onboarding");
      navigate("/onboarding", { replace: true });
    }
  }, [user, needsOnboarding, navigate, isCompleted, isSkipped]);
  if (user && needsOnboarding) {
    return /* @__PURE__ */ jsxRuntimeExports.jsx(TransitionSpinner, {});
  }
  return /* @__PURE__ */ jsxRuntimeExports.jsx(jsxRuntimeExports.Fragment, { children });
};
const componentCache = /* @__PURE__ */ new Map();
const getNavigationStats = () => {
  try {
    const stored = localStorage.getItem("navigation_stats");
    return stored ? JSON.parse(stored) : [];
  } catch {
    return [];
  }
};
const saveNavigationStats = (stats) => {
  try {
    const recentStats = stats.slice(-100);
    localStorage.setItem("navigation_stats", JSON.stringify(recentStats));
  } catch (error) {
    console.warn("Failed to save navigation stats:", error);
  }
};
const recordNavigation = (from2, to) => {
  const stats = getNavigationStats();
  const existing = stats.find((s) => s.from === from2 && s.to === to);
  if (existing) {
    existing.count++;
    existing.lastUsed = Date.now();
  } else {
    stats.push({
      from: from2,
      to,
      count: 1,
      lastUsed: Date.now()
    });
  }
  saveNavigationStats(stats);
  preloadLikelyScreens(to);
};
const predictNextScreens = (currentScreen) => {
  const stats = getNavigationStats();
  const transitions = stats.filter((s) => s.from === currentScreen);
  const sortedTransitions = transitions.sort((a2, b2) => {
    const aScore = a2.count * 0.7 + (Date.now() - a2.lastUsed) / (1e3 * 60 * 60 * 24) * 0.3;
    const bScore = b2.count * 0.7 + (Date.now() - b2.lastUsed) / (1e3 * 60 * 60 * 24) * 0.3;
    return bScore - aScore;
  }).slice(0, 2);
  return sortedTransitions.map((t2) => t2.to);
};
const getComponentByRoute = (route) => {
  switch (route) {
    case "/main":
      return () => __vitePreload(() => Promise.resolve().then(() => MainScreen$2), true ? void 0 : void 0);
    case "/report":
      return () => __vitePreload(() => import("./ReportScreen-oSpIKUUr.js"), true ? __vite__mapDeps([7,1,8,9,10]) : void 0);
    case "/community":
      return () => __vitePreload(() => import("./CommunityScreen-D3u4riBz.js"), true ? __vite__mapDeps([11,1,12,13,14,15,16,9,10]) : void 0);
    case "/wanted":
      return () => __vitePreload(() => import("./WantedScreen-3ZoZ5CNG.js"), true ? __vite__mapDeps([17,1,14,18,13,8,16,19,15,10]) : void 0);
    case "/profile":
      return () => __vitePreload(() => import("./ProfileScreen-B-u0OBWE.js"), true ? __vite__mapDeps([20,1,12,13,18,8,16,19,15,21]) : void 0);
    case "/friends":
      return () => __vitePreload(() => import("./FriendsScreen-9dg4djNo.js"), true ? __vite__mapDeps([22,1,18,13,8,16,21]) : void 0);
    case "/notifications":
      return () => __vitePreload(() => import("./NotificationsPage-BOueT-I7.js"), true ? __vite__mapDeps([23,1,16]) : void 0);
    default:
      return null;
  }
};
const preloadComponent = (route) => {
  if (componentCache.has(route)) {
    return;
  }
  const componentLoader = getComponentByRoute(route);
  if (!componentLoader) {
    return;
  }
  console.log(`🚀 Preloading component for route: ${route}`);
  const componentPromise = componentLoader();
  componentCache.set(route, componentPromise);
  componentPromise.catch((error) => {
    console.warn(`Failed to preload component for ${route}:`, error);
    componentCache.delete(route);
  });
};
const preloadLikelyScreens = (currentScreen) => {
  const likelyScreens = predictNextScreens(currentScreen);
  const defaultPreloads = getDefaultPreloads(currentScreen);
  const screensToPreload = [.../* @__PURE__ */ new Set([...likelyScreens, ...defaultPreloads])];
  screensToPreload.forEach((screen) => {
    setTimeout(() => preloadComponent(screen), 100);
  });
};
const getDefaultPreloads = (currentRoute) => {
  switch (currentRoute) {
    case "/main":
      return ["/report", "/community"];
    case "/report":
      return ["/main"];
    case "/community":
      return ["/friends", "/profile"];
    case "/wanted":
      return ["/main"];
    case "/profile":
      return ["/main", "/friends"];
    case "/friends":
      return ["/profile", "/community"];
    case "/notifications":
      return ["/main"];
    default:
      return ["/main"];
  }
};
const initializePreloader = (currentRoute) => {
  preloadLikelyScreens(currentRoute);
  if ("requestIdleCallback" in window) {
    requestIdleCallback(() => {
      const criticalRoutes = ["/main", "/report"];
      criticalRoutes.forEach((route) => {
        if (!componentCache.has(route)) {
          preloadComponent(route);
        }
      });
    });
  }
};
new QueryClient();
const MainScreen = reactExports.lazy(() => __vitePreload(() => Promise.resolve().then(() => MainScreen$2), true ? void 0 : void 0));
const ReportScreen = reactExports.lazy(() => __vitePreload(() => import("./ReportScreen-oSpIKUUr.js"), true ? __vite__mapDeps([7,1,8,9,10]) : void 0));
const ProfileScreen = reactExports.lazy(() => __vitePreload(() => import("./ProfileScreen-B-u0OBWE.js"), true ? __vite__mapDeps([20,1,12,13,18,8,16,19,15,21]) : void 0));
const WantedScreen = reactExports.lazy(() => __vitePreload(() => import("./WantedScreen-3ZoZ5CNG.js"), true ? __vite__mapDeps([17,1,14,18,13,8,16,19,15,10]) : void 0));
const CommunityScreen = reactExports.lazy(() => __vitePreload(() => import("./CommunityScreen-D3u4riBz.js"), true ? __vite__mapDeps([11,1,12,13,14,15,16,9,10]) : void 0));
const NotificationsPage = reactExports.lazy(() => __vitePreload(() => import("./NotificationsPage-BOueT-I7.js"), true ? __vite__mapDeps([23,1,16]) : void 0));
const FriendsScreen = reactExports.lazy(() => __vitePreload(() => import("./FriendsScreen-9dg4djNo.js"), true ? __vite__mapDeps([22,1,18,13,8,16,21]) : void 0));
const ProtectedRoute = ({ children }) => {
  const { user, loading } = useAuth();
  if (loading) {
    return /* @__PURE__ */ jsxRuntimeExports.jsx(TransitionSpinner, {});
  }
  if (!user) {
    return /* @__PURE__ */ jsxRuntimeExports.jsx(Navigate, { to: "/auth", replace: true });
  }
  return /* @__PURE__ */ jsxRuntimeExports.jsx(jsxRuntimeExports.Fragment, { children });
};
const PublicRoute = ({ children }) => {
  const { user, loading } = useAuth();
  if (loading) {
    return /* @__PURE__ */ jsxRuntimeExports.jsx(TransitionSpinner, {});
  }
  return !user ? /* @__PURE__ */ jsxRuntimeExports.jsx(jsxRuntimeExports.Fragment, { children }) : /* @__PURE__ */ jsxRuntimeExports.jsx(Navigate, { to: "/main", replace: true });
};
const OptimizedLazyLoader = reactExports.memo(({ children, route }) => {
  const location2 = useLocation();
  reactExports.useEffect(() => {
    const currentPath = location2.pathname;
    if (currentPath !== route) {
      recordNavigation(currentPath, route);
    }
  }, [location2.pathname, route]);
  return /* @__PURE__ */ jsxRuntimeExports.jsx(reactExports.Suspense, { fallback: /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "min-h-screen bg-dark flex items-center justify-center", children: /* @__PURE__ */ jsxRuntimeExports.jsx(TransitionSpinner, {}) }), children });
});
reactExports.memo(({ children }) => /* @__PURE__ */ jsxRuntimeExports.jsx(reactExports.Suspense, { fallback: /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "min-h-screen bg-dark flex items-center justify-center", children: /* @__PURE__ */ jsxRuntimeExports.jsx(TransitionSpinner, {}) }), children }));
const AppRoutes = () => /* @__PURE__ */ jsxRuntimeExports.jsxs(Routes, { children: [
  /* @__PURE__ */ jsxRuntimeExports.jsx(Route, { path: "/", element: /* @__PURE__ */ jsxRuntimeExports.jsx(PublicRoute, { children: /* @__PURE__ */ jsxRuntimeExports.jsx(SplashScreen, {}) }) }),
  /* @__PURE__ */ jsxRuntimeExports.jsx(Route, { path: "/auth", element: /* @__PURE__ */ jsxRuntimeExports.jsx(PublicRoute, { children: /* @__PURE__ */ jsxRuntimeExports.jsx(AuthScreen, {}) }) }),
  /* @__PURE__ */ jsxRuntimeExports.jsx(Route, { path: "/onboarding", element: /* @__PURE__ */ jsxRuntimeExports.jsx(ProtectedRoute, { children: /* @__PURE__ */ jsxRuntimeExports.jsx(OnboardingMinimal, {}) }) }),
  /* @__PURE__ */ jsxRuntimeExports.jsxs(Route, { element: /* @__PURE__ */ jsxRuntimeExports.jsx(ProtectedRoute, { children: /* @__PURE__ */ jsxRuntimeExports.jsx(OnboardingWrapper, { children: /* @__PURE__ */ jsxRuntimeExports.jsx(OptimizedPersistentLayout, {}) }) }), children: [
    /* @__PURE__ */ jsxRuntimeExports.jsx(Route, { path: "/main", element: /* @__PURE__ */ jsxRuntimeExports.jsx(OptimizedLazyLoader, { route: "/main", children: /* @__PURE__ */ jsxRuntimeExports.jsx(MainScreen, {}) }) }),
    /* @__PURE__ */ jsxRuntimeExports.jsx(Route, { path: "/report", element: /* @__PURE__ */ jsxRuntimeExports.jsx(OptimizedLazyLoader, { route: "/report", children: /* @__PURE__ */ jsxRuntimeExports.jsx(ReportScreen, {}) }) }),
    /* @__PURE__ */ jsxRuntimeExports.jsx(Route, { path: "/wanted", element: /* @__PURE__ */ jsxRuntimeExports.jsx(OptimizedLazyLoader, { route: "/wanted", children: /* @__PURE__ */ jsxRuntimeExports.jsx(WantedScreen, {}) }) }),
    /* @__PURE__ */ jsxRuntimeExports.jsx(Route, { path: "/community", element: /* @__PURE__ */ jsxRuntimeExports.jsx(OptimizedLazyLoader, { route: "/community", children: /* @__PURE__ */ jsxRuntimeExports.jsx(CommunityScreen, {}) }) }),
    /* @__PURE__ */ jsxRuntimeExports.jsx(Route, { path: "/notifications", element: /* @__PURE__ */ jsxRuntimeExports.jsx(OptimizedLazyLoader, { route: "/notifications", children: /* @__PURE__ */ jsxRuntimeExports.jsx(NotificationsPage, {}) }) }),
    /* @__PURE__ */ jsxRuntimeExports.jsx(Route, { path: "/friends", element: /* @__PURE__ */ jsxRuntimeExports.jsx(OptimizedLazyLoader, { route: "/friends", children: /* @__PURE__ */ jsxRuntimeExports.jsx(FriendsScreen, {}) }) }),
    /* @__PURE__ */ jsxRuntimeExports.jsx(Route, { path: "/profile", element: /* @__PURE__ */ jsxRuntimeExports.jsx(OptimizedLazyLoader, { route: "/profile", children: /* @__PURE__ */ jsxRuntimeExports.jsx(ProfileScreen, {}) }) })
  ] }),
  /* @__PURE__ */ jsxRuntimeExports.jsx(Route, { path: "*", element: /* @__PURE__ */ jsxRuntimeExports.jsx(NotFound, {}) })
] });
const optimizedQueryClient = new QueryClient({
  defaultOptions: {
    queries: {
      staleTime: 5 * 60 * 1e3,
      // 5 минут - данные считаются свежими
      gcTime: 10 * 60 * 1e3,
      // 10 минут - время хранения в кэше
      retry: 1,
      // Меньше попыток для быстрого отказа
      refetchOnWindowFocus: false,
      // Не перезагружаем при фокусе окна
      refetchOnMount: false
      // Не перезагружаем при монтировании если есть кэш
    },
    mutations: {
      retry: 1
    }
  }
});
const MemoizedLanguageProvider = reactExports.memo(LanguageProvider);
const MemoizedAuthProvider = reactExports.memo(AuthProvider);
const MemoizedAppStateProvider = reactExports.memo(AppStateProvider);
const MemoizedTooltipProvider = reactExports.memo(TooltipProvider);
const App = reactExports.memo(() => {
  console.log("App component initializing...");
  if (!React.createContext) {
    console.error("React.createContext is not available in App component");
    return /* @__PURE__ */ jsxRuntimeExports.jsx("div", { style: {
      display: "flex",
      justifyContent: "center",
      alignItems: "center",
      height: "100vh",
      background: "#1a1a1a",
      color: "white",
      fontFamily: "sans-serif",
      textAlign: "center",
      padding: "20px"
    }, children: /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx("h2", { children: "🚨 Radar - Context Error" }),
      /* @__PURE__ */ jsxRuntimeExports.jsx("p", { children: "React Context is not available" }),
      /* @__PURE__ */ jsxRuntimeExports.jsx("p", { style: { fontSize: "12px", opacity: 0.7 }, children: "Please restart the app" })
    ] }) });
  }
  reactExports.useEffect(() => {
    console.log("App useEffect running...");
    initializePreloader("/main");
  }, []);
  const providers = reactExports.useMemo(() => /* @__PURE__ */ jsxRuntimeExports.jsx(QueryClientProvider, { client: optimizedQueryClient, children: /* @__PURE__ */ jsxRuntimeExports.jsx(MemoizedLanguageProvider, { children: /* @__PURE__ */ jsxRuntimeExports.jsx(MemoizedAuthProvider, { children: /* @__PURE__ */ jsxRuntimeExports.jsx(MemoizedAppStateProvider, { children: /* @__PURE__ */ jsxRuntimeExports.jsxs(MemoizedTooltipProvider, { children: [
    /* @__PURE__ */ jsxRuntimeExports.jsx(Toaster$1, {}),
    /* @__PURE__ */ jsxRuntimeExports.jsx(Toaster, {}),
    /* @__PURE__ */ jsxRuntimeExports.jsx(BrowserRouter, { children: /* @__PURE__ */ jsxRuntimeExports.jsx(AppRoutes, {}) })
  ] }) }) }) }) }), []);
  console.log("App component rendering...");
  return /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "min-h-screen bg-dark", children: providers });
});
console.log("main.tsx loading...");
if (typeof window !== "undefined") {
  window.React = React;
}
if (typeof globalThis !== "undefined") {
  globalThis.React = React;
}
const checkReactAvailability = () => {
  if (typeof React === "undefined") {
    throw new Error("React is not available");
  }
  if (typeof React.createContext !== "function") {
    throw new Error("React.createContext is not available");
  }
  console.log("✅ React Context API is available");
};
const initApp = async () => {
  try {
    console.log("Checking React availability...");
    checkReactAvailability();
    console.log("Creating React root...");
    const rootElement = document.getElementById("root");
    if (!rootElement) {
      console.error("Root element not found!");
      throw new Error("Root element not found");
    }
    if ("serviceWorker" in navigator) {
      try {
        await navigator.serviceWorker.register("/mobile-sw.js", {
          scope: "/"
        });
        console.log("✅ Service Worker registered successfully");
      } catch (error) {
        console.warn("⚠️ Service Worker registration failed:", error);
      }
    }
    console.log("Root element found, rendering app...");
    const root = createRoot(rootElement);
    root.render(/* @__PURE__ */ jsxRuntimeExports.jsx(App, {}));
    console.log("App rendered successfully");
  } catch (error) {
    console.error("❌ App initialization failed:", error);
    const rootElement = document.getElementById("root");
    if (rootElement) {
      rootElement.innerHTML = `
        <div style="
          display: flex; 
          justify-content: center; 
          align-items: center; 
          height: 100vh; 
          background: #1a1a1a; 
          color: white; 
          font-family: sans-serif;
          text-align: center;
          padding: 20px;
        ">
          <div>
            <h2>🚨 Radar - Initialization Error</h2>
            <p>Please restart the app or contact support.</p>
            <p style="font-size: 12px; opacity: 0.7;">Error: ${error.message}</p>
          </div>
        </div>
      `;
    }
  }
};
initApp();
export {
  $b5e257d569688ac6$export$535bd6ca7f90a273 as $,
  tv as A,
  Button$1 as B,
  Card as C,
  $65484d02dcb7eb3e$export$457c3d6518dd4c6f as D,
  Eye as E,
  $3ef42575df84b30b$export$9d1611c77c2fe928 as F,
  Geolocation as G,
  useProviderContext as H,
  Item as I,
  mapPropsVariants as J,
  useDOMRef as K,
  clsx$1 as L,
  MapPin as M,
  objectToDeps as N,
  OptimizedInput as O,
  Primitive as P,
  clampPercentage as Q,
  Root$1 as R,
  SemipolarSpinner as S,
  dataAttr as T,
  forwardRef as U,
  createLucideIcon as V,
  Dialog as W,
  DialogContent as X,
  DialogHeader as Y,
  DialogTitle as Z,
  Label as _,
  composeEventHandlers as a,
  formatDateTimeAMPM as a$,
  EyeOff as a0,
  LoaderCircle as a1,
  Avatar as a2,
  AvatarImage as a3,
  AvatarFallback as a4,
  useLanguage as a5,
  useToast as a6,
  Tabs as a7,
  TabsList as a8,
  TabsTrigger as a9,
  Send as aA,
  MessageCircle as aB,
  DialogDescription as aC,
  useTypedLanguage as aD,
  motion as aE,
  realtimeService as aF,
  UserRoleBadge as aG,
  ChevronRight as aH,
  Target as aI,
  AlertRadiusDialog as aJ,
  createPopperScope as aK,
  Anchor as aL,
  hideOthers as aM,
  ReactRemoveScroll as aN,
  Slot as aO,
  useFocusGuards as aP,
  FocusScope as aQ,
  DismissableLayer as aR,
  Content$2 as aS,
  Arrow as aT,
  Root2$1 as aU,
  useId$1 as aV,
  Portal$1 as aW,
  buttonVariants as aX,
  ChevronLeft as aY,
  useQueryClient as aZ,
  useMutation as a_,
  Shield as aa,
  Settings as ab,
  TriangleAlert as ac,
  Database as ad,
  TabsContent as ae,
  RefreshCw as af,
  CircleCheckBig as ag,
  CardDescription as ah,
  Slider as ai,
  Trash2 as aj,
  MessageSquare as ak,
  ScrollArea as al,
  useUserRole as am,
  Jt as an,
  Users as ao,
  Crown as ap,
  UserCheck as aq,
  Bell as ar,
  Search as as,
  DialogTrigger as at,
  UserPlus as au,
  testPushNotifications as av,
  XPService as aw,
  FileText as ax,
  Lock as ay,
  Share2 as az,
  Presence as b,
  Subscribable as b$,
  DialogFooter as b0,
  UserDisplayWrapper as b1,
  LanguageToggle as b2,
  X as b3,
  User as b4,
  formatDateOnly as b5,
  ownerDocument as b6,
  clsx as b7,
  resolveComponentProps as b8,
  mergeSlotProps as b9,
  useRtl as bA,
  slotShouldForwardProp as bB,
  useId as bC,
  formatTimeAMPM as bD,
  Overlay as bE,
  Content$1 as bF,
  Close as bG,
  Title as bH,
  Description as bI,
  Portal as bJ,
  cva as bK,
  Root$4 as bL,
  Trigger$1 as bM,
  Capacitor as bN,
  ZoomIn as bO,
  AnimatePresence as bP,
  UserProfileCard as bQ,
  ThumbsUp as bR,
  ThumbsDown as bS,
  WebPlugin as bT,
  CapacitorException as bU,
  registerPlugin as bV,
  createCollection as bW,
  useLayoutEffect2 as bX,
  VisuallyHidden as bY,
  useCallbackRef$1 as bZ,
  clamp$2 as b_,
  useForkRef as ba,
  appendOwnerState as bb,
  getReactElementRef as bc,
  useEnhancedEffect as bd,
  useEventCallback as be,
  generateUtilityClasses as bf,
  generateUtilityClass as bg,
  capitalize as bh,
  styled as bi,
  memoTheme as bj,
  useDefaultProps as bk,
  composeClasses as bl,
  globalCss as bm,
  formatMuiErrorMessage as bn,
  createSvgIcon as bo,
  useTheme as bp,
  Transition as bq,
  reflow as br,
  getTransitionProps as bs,
  useSlot as bt,
  extractEventHandlers as bu,
  rootShouldForwardProp as bv,
  createSimplePaletteValueFilter as bw,
  deepmerge as bx,
  Paper as by,
  Grow as bz,
  createContextScope$3 as c,
  pendingThenable as c0,
  resolveEnabled as c1,
  shallowEqualObjects as c2,
  resolveStaleTime as c3,
  noop$5 as c4,
  isServer as c5,
  isValidTimeout as c6,
  timeUntilStale as c7,
  focusManager as c8,
  fetchState as c9,
  replaceData as ca,
  notifyManager as cb,
  shouldThrowError as cc,
  noop$4 as cd,
  NotificationsCenter as ce,
  Input as cf,
  en as cg,
  es as ch,
  UserService as ci,
  composeRefs as cj,
  dispatchDiscreteCustomEvent as ck,
  createDomVisualElement as cl,
  animations as cm,
  gestureAnimations as cn,
  usePrevious as d,
  useSize as e,
  createRovingFocusGroupScope as f,
  useDirection as g,
  useControllableState as h,
  cn as i,
  jsxRuntimeExports as j,
  useLanguage$1 as k,
  useAuth as l,
  mapboxgl as m,
  CardHeader as n,
  CardTitle as o,
  CardContent as p,
  Info$1 as q,
  Clock$1 as r,
  OptimizedTextarea as s,
  toast as t,
  useComposedRefs as u,
  Badge as v,
  PhotoGallery as w,
  supabase as x,
  INCIDENT_DURATION_LIMITS as y,
  $bdb11010cef70236$export$f680877a34711e37 as z
};
