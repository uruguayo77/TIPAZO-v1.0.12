/**
 * üöÄ Mobile-Optimized Service Worker
 * –ê–≥—Ä–µ—Å—Å–∏–≤–Ω–æ–µ –∫—ç—à–∏—Ä–æ–≤–∞–Ω–∏–µ –¥–ª—è –º–≥–Ω–æ–≤–µ–Ω–Ω—ã—Ö –ø–µ—Ä–µ—Ö–æ–¥–æ–≤ –Ω–∞ –º–æ–±–∏–ª—å–Ω—ã—Ö —É—Å—Ç—Ä–æ–π—Å—Ç–≤–∞—Ö
 */

const CACHE_NAME = 'radar-mobile-v1.0.5';
const STATIC_CACHE = 'radar-static-v1.0.5';
const DYNAMIC_CACHE = 'radar-dynamic-v1.0.5';
const API_CACHE = 'radar-api-v1.0.5';

// –ö—Ä–∏—Ç–∏—á–µ—Å–∫–∏–µ —Ä–µ—Å—É—Ä—Å—ã –¥–ª—è –Ω–µ–º–µ–¥–ª–µ–Ω–Ω–æ–≥–æ –∫—ç—à–∏—Ä–æ–≤–∞–Ω–∏—è
const CRITICAL_ASSETS = [
  '/',
  '/index.html',
  '/manifest.json',
  '/app-icon.png',
  '/assets/index.js', // –û—Å–Ω–æ–≤–Ω–æ–π bundle
  '/assets/react-vendor.js', // React –±–∏–±–ª–∏–æ—Ç–µ–∫–∏
  '/assets/app-core.js', // –ö–æ–Ω—Ç–µ–∫—Å—Ç—ã –∏ —Ö—É–∫–∏
];

// JavaScript chunks –¥–ª—è –∫–æ–º–ø–æ–Ω–µ–Ω—Ç–æ–≤ (–±—É–¥—É—Ç –∫—ç—à–∏—Ä–æ–≤–∞—Ç—å—Å—è –ø–æ –∑–∞–ø—Ä–æ—Å—É)
const COMPONENT_CHUNKS = [
  '/chunks/main-screen-',
  '/chunks/report-screen-',
  '/chunks/community-screen-',
  '/chunks/profile-screen-',
  '/chunks/friends-screen-',
  '/chunks/wanted-screen-',
  '/chunks/notifications-screen-',
];

// API —ç–Ω–¥–ø–æ–∏–Ω—Ç—ã –¥–ª—è –∫—ç—à–∏—Ä–æ–≤–∞–Ω–∏—è
const API_ENDPOINTS = [
  '/rest/v1/profiles',
  '/rest/v1/incidents', 
  '/rest/v1/social_feed',
  '/rest/v1/friend_requests',
  '/rest/v1/user_push_tokens',
];

// –£—Å—Ç–∞–Ω–∞–≤–ª–∏–≤–∞–µ–º Service Worker
self.addEventListener('install', (event) => {
  console.log('üöÄ SW: Installing mobile-optimized service worker');
  
  event.waitUntil(
    (async () => {
      // –ö—ç—à–∏—Ä—É–µ–º –∫—Ä–∏—Ç–∏—á–µ—Å–∫–∏–µ —Ä–µ—Å—É—Ä—Å—ã
      const staticCache = await caches.open(STATIC_CACHE);
      
      try {
        await staticCache.addAll(CRITICAL_ASSETS);
        console.log('‚úÖ SW: Critical assets cached');
      } catch (error) {
        console.warn('‚ö†Ô∏è SW: Some critical assets failed to cache:', error);
        // –ö—ç—à–∏—Ä—É–µ–º —Ç–µ, –∫–æ—Ç–æ—Ä—ã–µ –¥–æ—Å—Ç—É–ø–Ω—ã
        for (const asset of CRITICAL_ASSETS) {
          try {
            await staticCache.add(asset);
          } catch (e) {
            console.warn(`Failed to cache ${asset}:`, e);
          }
        }
      }
      
      // –ü—Ä–∏–Ω—É–¥–∏—Ç–µ–ª—å–Ω–æ –∞–∫—Ç–∏–≤–∏—Ä—É–µ–º –Ω–æ–≤—ã–π SW
      self.skipWaiting();
    })()
  );
});

// –ê–∫—Ç–∏–≤–∏—Ä—É–µ–º Service Worker
self.addEventListener('activate', (event) => {
  console.log('üöÄ SW: Activating mobile service worker');
  
  event.waitUntil(
    (async () => {
      // –û—á–∏—â–∞–µ–º —Å—Ç–∞—Ä—ã–µ –∫—ç—à–∏
      const cacheNames = await caches.keys();
      const oldCaches = cacheNames.filter(name => 
        name.startsWith('radar-') && 
        !name.includes('v1.0.5')
      );
      
      await Promise.all(
        oldCaches.map(cache => {
          console.log(`üóëÔ∏è SW: Deleting old cache: ${cache}`);
          return caches.delete(cache);
        })
      );
      
      // –ü–æ–ª—É—á–∞–µ–º –∫–æ–Ω—Ç—Ä–æ–ª—å –Ω–∞–¥ –≤—Å–µ–º–∏ –≤–∫–ª–∞–¥–∫–∞–º–∏
      self.clients.claim();
      console.log('‚úÖ SW: Service worker activated');
    })()
  );
});

// –û–±—Ä–∞–±–æ—Ç–∫–∞ fetch –∑–∞–ø—Ä–æ—Å–æ–≤ —Å —É–º–Ω—ã–º –∫—ç—à–∏—Ä–æ–≤–∞–Ω–∏–µ–º
self.addEventListener('fetch', (event) => {
  const { request } = event;
  const url = new URL(request.url);
  
  // –ò–≥–Ω–æ—Ä–∏—Ä—É–µ–º non-GET –∑–∞–ø—Ä–æ—Å—ã
  if (request.method !== 'GET') {
    return;
  }
  
  // –ò–≥–Ω–æ—Ä–∏—Ä—É–µ–º –∑–∞–ø—Ä–æ—Å—ã –∫ –¥—Ä—É–≥–∏–º –¥–æ–º–µ–Ω–∞–º (–∫—Ä–æ–º–µ API)
  if (url.origin !== location.origin && !url.hostname.includes('supabase')) {
    return;
  }
  
  event.respondWith(handleFetch(request));
});

/**
 * –£–º–Ω—ã–π –æ–±—Ä–∞–±–æ—Ç—á–∏–∫ fetch –∑–∞–ø—Ä–æ—Å–æ–≤
 */
async function handleFetch(request) {
  const url = new URL(request.url);
  const pathname = url.pathname;
  
  try {
    // 1. –°—Ç–∞—Ç–∏—á–µ—Å–∫–∏–µ —Ä–µ—Å—É—Ä—Å—ã (JS, CSS, –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏—è)
    if (isStaticAsset(pathname)) {
      return await handleStaticAsset(request);
    }
    
    // 2. JavaScript chunks –∫–æ–º–ø–æ–Ω–µ–Ω—Ç–æ–≤
    if (isComponentChunk(pathname)) {
      return await handleComponentChunk(request);
    }
    
    // 3. API –∑–∞–ø—Ä–æ—Å—ã –∫ Supabase
    if (isApiRequest(url)) {
      return await handleApiRequest(request);
    }
    
    // 4. HTML —Å—Ç—Ä–∞–Ω–∏—Ü—ã (SPA)
    if (isNavigationRequest(request)) {
      return await handleNavigation(request);
    }
    
    // 5. –í—Å–µ –æ—Å—Ç–∞–ª—å–Ω–æ–µ - –ø—Ä–æ—Å—Ç–æ –ø—Ä–æ–±—É–µ–º —Å–µ—Ç—å
    return await fetch(request);
    
  } catch (error) {
    console.error('SW: Fetch error:', error);
    
    // Fallback –¥–ª—è –Ω–∞–≤–∏–≥–∞—Ü–∏–∏
    if (isNavigationRequest(request)) {
      const cache = await caches.open(STATIC_CACHE);
      const cachedResponse = await cache.match('/index.html');
      if (cachedResponse) {
        return cachedResponse;
      }
    }
    
    throw error;
  }
}

/**
 * –û–±—Ä–∞–±–æ—Ç–∫–∞ —Å—Ç–∞—Ç–∏—á–µ—Å–∫–∏—Ö —Ä–µ—Å—É—Ä—Å–æ–≤ (Cache First)
 */
async function handleStaticAsset(request) {
  const cache = await caches.open(STATIC_CACHE);
  const cachedResponse = await cache.match(request);
  
  if (cachedResponse) {
    // –í–æ–∑–≤—Ä–∞—â–∞–µ–º –∏–∑ –∫—ç—à–∞ –Ω–µ–º–µ–¥–ª–µ–Ω–Ω–æ
    updateCacheInBackground(cache, request);
    return cachedResponse;
  }
  
  // –ó–∞–≥—Ä—É–∂–∞–µ–º –∏ –∫—ç—à–∏—Ä—É–µ–º
  const response = await fetch(request);
  if (response.ok) {
    cache.put(request, response.clone());
  }
  return response;
}

/**
 * –û–±—Ä–∞–±–æ—Ç–∫–∞ JavaScript chunks (Cache First —Å –∏–Ω—Ç–µ–ª–ª–µ–∫—Ç—É–∞–ª—å–Ω–æ–π –ø—Ä–µ–¥–∑–∞–≥—Ä—É–∑–∫–æ–π)
 */
async function handleComponentChunk(request) {
  const cache = await caches.open(DYNAMIC_CACHE);
  const cachedResponse = await cache.match(request);
  
  if (cachedResponse) {
    return cachedResponse;
  }
  
  // –ó–∞–≥—Ä—É–∂–∞–µ–º –∏ –∫—ç—à–∏—Ä—É–µ–º
  const response = await fetch(request);
  if (response.ok) {
    cache.put(request, response.clone());
    
    // –ó–∞–ø—É—Å–∫–∞–µ–º –ø—Ä–µ–¥–∑–∞–≥—Ä—É–∑–∫—É —Å–≤—è–∑–∞–Ω–Ω—ã—Ö chunks
    preloadRelatedChunks(request.url);
  }
  
  return response;
}

/**
 * –û–±—Ä–∞–±–æ—Ç–∫–∞ API –∑–∞–ø—Ä–æ—Å–æ–≤ (Stale While Revalidate)
 */
async function handleApiRequest(request) {
  const cache = await caches.open(API_CACHE);
  const cachedResponse = await cache.match(request);
  
  // –ó–∞–ø—É—Å–∫–∞–µ–º –æ–±–Ω–æ–≤–ª–µ–Ω–∏–µ –≤ —Ñ–æ–Ω–µ
  const fetchPromise = fetch(request).then(response => {
    if (response.ok) {
      cache.put(request, response.clone());
    }
    return response;
  }).catch(() => cachedResponse); // Fallback –Ω–∞ –∫—ç—à –ø—Ä–∏ –æ—à–∏–±–∫–µ
  
  // –í–æ–∑–≤—Ä–∞—â–∞–µ–º –∫—ç—à –Ω–µ–º–µ–¥–ª–µ–Ω–Ω–æ, –µ—Å–ª–∏ –µ—Å—Ç—å
  if (cachedResponse) {
    return cachedResponse;
  }
  
  // –ò–Ω–∞—á–µ –∂–¥–µ–º —Å–µ—Ç—å
  return fetchPromise;
}

/**
 * –û–±—Ä–∞–±–æ—Ç–∫–∞ –Ω–∞–≤–∏–≥–∞—Ü–∏–∏ (SPA)
 */
async function handleNavigation(request) {
  const cache = await caches.open(STATIC_CACHE);
  const cachedResponse = await cache.match('/index.html');
  
  if (cachedResponse) {
    return cachedResponse;
  }
  
  // –ï—Å–ª–∏ –Ω–µ—Ç –∫—ç—à–∞, –ø—Ä–æ–±—É–µ–º —Å–µ—Ç—å
  return fetch(request);
}

/**
 * –ü—Ä–µ–¥–∑–∞–≥—Ä—É–∑–∫–∞ —Å–≤—è–∑–∞–Ω–Ω—ã—Ö chunks –≤ —Ñ–æ–Ω–µ
 */
function preloadRelatedChunks(currentChunkUrl) {
  // –û–ø—Ä–µ–¥–µ–ª—è–µ–º, –∫–∞–∫–∏–µ chunks –º–æ–≥—É—Ç –ø–æ–Ω–∞–¥–æ–±–∏—Ç—å—Å—è —Å–ª–µ–¥—É—é—â–∏–º–∏
  const chunkMap = {
    'main-screen': ['report-screen', 'community-screen'],
    'report-screen': ['main-screen'],
    'community-screen': ['friends-screen', 'profile-screen'],
    'profile-screen': ['friends-screen', 'main-screen'],
    'friends-screen': ['profile-screen', 'community-screen'],
    'wanted-screen': ['main-screen'],
    'notifications-screen': ['main-screen']
  };
  
  const currentChunk = Object.keys(chunkMap).find(chunk => 
    currentChunkUrl.includes(chunk)
  );
  
  if (currentChunk) {
    const relatedChunks = chunkMap[currentChunk];
    relatedChunks.forEach(chunk => {
      // –ü—Ä–µ–¥–∑–∞–≥—Ä—É–∂–∞–µ–º —Å –∑–∞–¥–µ—Ä–∂–∫–æ–π, —á—Ç–æ–±—ã –Ω–µ –º–µ—à–∞—Ç—å —Ç–µ–∫—É—â–µ–π –∑–∞–≥—Ä—É–∑–∫–µ
      setTimeout(() => preloadChunk(chunk), 1000);
    });
  }
}

/**
 * –ü—Ä–µ–¥–∑–∞–≥—Ä—É–∑–∫–∞ –∫–æ–Ω–∫—Ä–µ—Ç–Ω–æ–≥–æ chunk
 */
async function preloadChunk(chunkName) {
  try {
    const cache = await caches.open(DYNAMIC_CACHE);
    const chunkPattern = `/chunks/${chunkName}-`;
    
    // –ò—â–µ–º –∞–∫—Ç—É–∞–ª—å–Ω—ã–π —Ö—ç—à chunk –≤ –∫—ç—à–µ
    const cachedKeys = await cache.keys();
    const existingChunk = cachedKeys.find(request => 
      request.url.includes(chunkPattern)
    );
    
    if (!existingChunk) {
      console.log(`üöÄ SW: Preloading chunk: ${chunkName}`);
      // –ó–¥–µ—Å—å –º–æ–∂–Ω–æ –±—ã–ª–æ –±—ã –ø–æ–ø—Ä–æ–±–æ–≤–∞—Ç—å –∑–∞–≥—Ä—É–∑–∏—Ç—å, –Ω–æ –±–µ–∑ —Ç–æ—á–Ω–æ–≥–æ —Ö—ç—à–∞ —Å–ª–æ–∂–Ω–æ
    }
  } catch (error) {
    console.warn(`SW: Failed to preload chunk ${chunkName}:`, error);
  }
}

/**
 * –û–±–Ω–æ–≤–ª–µ–Ω–∏–µ –∫—ç—à–∞ –≤ —Ñ–æ–Ω–µ
 */
function updateCacheInBackground(cache, request) {
  // –û–±–Ω–æ–≤–ª—è–µ–º –∫—ç—à –≤ —Ñ–æ–Ω–µ, –Ω–µ –±–ª–æ–∫–∏—Ä—É—è –æ—Ç–≤–µ—Ç
  setTimeout(async () => {
    try {
      const response = await fetch(request);
      if (response.ok) {
        cache.put(request, response);
      }
    } catch (error) {
      // –ò–≥–Ω–æ—Ä–∏—Ä—É–µ–º –æ—à–∏–±–∫–∏ —Ñ–æ–Ω–æ–≤–æ–≥–æ –æ–±–Ω–æ–≤–ª–µ–Ω–∏—è
    }
  }, 100);
}

// –£—Ç–∏–ª–∏—Ç—ã –¥–ª—è –æ–ø—Ä–µ–¥–µ–ª–µ–Ω–∏—è —Ç–∏–ø–∞ –∑–∞–ø—Ä–æ—Å–∞
function isStaticAsset(pathname) {
  return pathname.includes('/assets/') || 
         pathname.endsWith('.js') || 
         pathname.endsWith('.css') || 
         pathname.endsWith('.png') || 
         pathname.endsWith('.jpg') || 
         pathname.endsWith('.svg') ||
         pathname.endsWith('.ico');
}

function isComponentChunk(pathname) {
  return pathname.includes('/chunks/') && pathname.endsWith('.js');
}

function isApiRequest(url) {
  return url.hostname.includes('supabase.co') || 
         url.pathname.startsWith('/rest/v1/') ||
         url.pathname.startsWith('/functions/v1/');
}

function isNavigationRequest(request) {
  return request.mode === 'navigate' || 
         (request.method === 'GET' && 
          request.headers.get('accept').includes('text/html'));
}

// –û–±—Ä–∞–±–æ—Ç–∫–∞ —Å–æ–æ–±—â–µ–Ω–∏–π –æ—Ç –ø—Ä–∏–ª–æ–∂–µ–Ω–∏—è
self.addEventListener('message', (event) => {
  const { type, data } = event.data || {};
  
  switch (type) {
    case 'SKIP_WAITING':
      self.skipWaiting();
      break;
      
    case 'CACHE_ROUTE':
      // –ü—Ä–∏–ª–æ–∂–µ–Ω–∏–µ –º–æ–∂–µ—Ç –∑–∞–ø—Ä–æ—Å–∏—Ç—å –∫—ç—à–∏—Ä–æ–≤–∞–Ω–∏–µ –∫–æ–Ω–∫—Ä–µ—Ç–Ω–æ–≥–æ —Ä–æ—É—Ç–∞
      if (data?.url) {
        cacheRoute(data.url);
      }
      break;
      
    case 'CLEAR_CACHE':
      clearAllCaches();
      break;
      
    default:
      break;
  }
});

/**
 * –ö—ç—à–∏—Ä–æ–≤–∞–Ω–∏–µ –∫–æ–Ω–∫—Ä–µ—Ç–Ω–æ–≥–æ —Ä–æ—É—Ç–∞ –ø–æ –∑–∞–ø—Ä–æ—Å—É
 */
async function cacheRoute(url) {
  try {
    const cache = await caches.open(DYNAMIC_CACHE);
    await cache.add(url);
    console.log(`‚úÖ SW: Cached route: ${url}`);
  } catch (error) {
    console.warn(`SW: Failed to cache route ${url}:`, error);
  }
}

/**
 * –û—á–∏—Å—Ç–∫–∞ –≤—Å–µ—Ö –∫—ç—à–µ–π
 */
async function clearAllCaches() {
  const cacheNames = await caches.keys();
  await Promise.all(
    cacheNames
      .filter(name => name.startsWith('radar-'))
      .map(name => caches.delete(name))
  );
  console.log('üóëÔ∏è SW: All caches cleared');
} 